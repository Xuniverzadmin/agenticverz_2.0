{
  "hoc_spine": {
    "l2_1_facade": null,
    "l2_apis": [],
    "l4_spine": [
      {
        "file_name": "auth_wiring.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/auth_wiring.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 55,
        "module_docstring": "Auth Wiring \u2014 main.py Import Aggregator\n\nProvides a single import surface for main.py so it never imports from\n``app.auth`` directly. All policy lives in ``hoc_spine/authority/``;\nmiddleware and startup orchestration live in ``app/auth/`` shims that\ndelegate to authority modules.\n\nThis module re-exports the concrete symbols main.py needs:\n  - AUTH_GATEWAY_ENABLED        (from authority.gateway_policy)\n  - configure_auth_gateway      (from auth.gateway_config \u2014 startup orchestration)\n  - setup_auth_middleware        (from auth.gateway_config \u2014 startup orchestration)\n  - RBACMiddleware              (from auth.rbac_middleware \u2014 Starlette middleware)\n  - OnboardingGateMiddleware    (from auth.onboarding_gate \u2014 Starlette middleware)\n  - verify_api_key              (from auth \u2014 FastAPI dependency)",
        "functions": [],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.hoc.cus.hoc_spine.authority.gateway_policy",
            "names": [
              "AUTH_GATEWAY_ENABLED"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.auth.gateway_config",
            "names": [
              "configure_auth_gateway",
              "setup_auth_middleware"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.rbac_middleware",
            "names": [
              "RBACMiddleware"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.auth.onboarding_gate",
            "names": [
              "OnboardingGateMiddleware"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.auth",
            "names": [
              "verify_api_key"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": [
          "AUTH_GATEWAY_ENABLED",
          "configure_auth_gateway",
          "setup_auth_middleware",
          "RBACMiddleware",
          "OnboardingGateMiddleware",
          "verify_api_key"
        ]
      },
      {
        "file_name": "concurrent_runs.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/concurrent_runs.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 247,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_concurrent_limiter",
            "signature": "() -> ConcurrentRunsLimiter",
            "docstring": "Get the singleton concurrent runs limiter.",
            "is_async": false,
            "line": 224
          },
          {
            "name": "acquire_slot",
            "signature": "(key: str, max_slots: int)",
            "docstring": "Convenience context manager for acquiring a slot.\n\nArgs:\n    key: Unique key (e.g., \"agent:{agent_id}\")\n    max_slots: Maximum concurrent runs\n\nYields:\n    Token string\n\nRaises:\n    RuntimeError: If limit reached",
            "is_async": false,
            "line": 233
          }
        ],
        "classes": [
          {
            "name": "ConcurrentRunsLimiter",
            "docstring": "Limits concurrent runs using Redis-based semaphore.\n\nUses Redis sets to track active runs per key.\nAutomatically expires slots after timeout.",
            "methods": [
              "__init__",
              "_get_client",
              "acquire",
              "release",
              "get_count",
              "slot"
            ],
            "line": 36
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "contextlib",
            "names": [
              "contextmanager"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 28
          }
        ],
        "constants": [
          {
            "name": "REDIS_URL",
            "line": 32
          },
          {
            "name": "DEFAULT_SLOT_TIMEOUT",
            "line": 33
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "contract_engine.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/contracts/contract_engine.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 741,
        "module_docstring": "Part-2 Contract Service (L4)\n\nManages the System Contract state machine - the first stateful component\nin the Part-2 governance workflow.\n\nResponsibilities:\n1. Create contracts from validated + eligible proposals\n2. Enforce state machine transitions\n3. Record transition history for audit\n4. Enforce terminal state immutability\n\nInvariants (from SYSTEM_CONTRACT_OBJECT.md):\n- CONTRACT-001: Status transitions must follow state machine\n- CONTRACT-002: APPROVED requires approved_by\n- CONTRACT-003: ACTIVE requires job exists\n- CONTRACT-004: COMPLETED requires audit_verdict = PASS\n- CONTRACT-005: Terminal states are immutable\n- CONTRACT-006: proposed_changes must validate schema\n- CONTRACT-007: confidence_score range [0,1]\n\nMAY_NOT ENFORCEMENT (PIN-291):\n- MAY_NOT verdicts are mechanically un-overridable\n- No constructor, method, or bypass can create contracts from MAY_NOT\n- This is not a business rule; it is a system invariant\n\nReference: PIN-291, SYSTEM_CONTRACT_OBJECT.md, part2-design-v1",
        "functions": [],
        "classes": [
          {
            "name": "_EligibilityDecisionValue",
            "docstring": "Enum-like value wrapper for string comparison.",
            "methods": [
              "__init__",
              "__eq__"
            ],
            "line": 107
          },
          {
            "name": "_EligibilityDecision",
            "docstring": "Local proxy for EligibilityDecision enum values used in contract logic.",
            "methods": [],
            "line": 119
          },
          {
            "name": "ContractState",
            "docstring": "In-memory representation of contract state.\n\nUsed for state machine operations before persistence.",
            "methods": [],
            "line": 137
          },
          {
            "name": "ContractStateMachine",
            "docstring": "State machine for System Contract lifecycle.\n\nEnforces:\n- CONTRACT-001: Valid transitions only\n- CONTRACT-002: APPROVED requires approved_by\n- CONTRACT-003: ACTIVE requires job_id\n- CONTRACT-004: COMPLETED requires audit_verdict = PASS\n- CONTRACT-005: Terminal states are immutable",
            "methods": [
              "can_transition",
              "validate_transition",
              "transition"
            ],
            "line": 174
          },
          {
            "name": "ContractService",
            "docstring": "Part-2 Contract Service (L4)\n\nManages System Contract lifecycle - the first stateful component\nof the Part-2 governance workflow.\n\nKey Properties:\n- Consumes validator + eligibility outputs\n- Enforces MAY_NOT mechanically (un-overridable)\n- Implements state machine with invariants\n- No execution logic (that's for Job Executor)\n\nReference: SYSTEM_CONTRACT_OBJECT.md, PIN-291",
            "methods": [
              "__init__",
              "version",
              "create_contract",
              "approve",
              "reject",
              "activate",
              "complete",
              "fail",
              "expire",
              "is_terminal",
              "is_approved",
              "can_approve",
              "get_valid_transitions"
            ],
            "line": 335
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 78
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 79
          },
          {
            "module": "uuid",
            "names": [
              "UUID",
              "uuid4"
            ],
            "is_relative": false,
            "line": 80
          },
          {
            "module": "app.models.contract",
            "names": [
              "TERMINAL_STATES",
              "VALID_TRANSITIONS",
              "AuditVerdict",
              "ContractApproval",
              "ContractImmutableError",
              "ContractSource",
              "ContractStatus",
              "EligibilityVerdictData",
              "InvalidTransitionError",
              "MayNotVerdictError",
              "RiskLevel",
              "TransitionRecord",
              "ValidatorVerdictData"
            ],
            "is_relative": false,
            "line": 82
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.protocols",
            "names": [
              "EligibilityVerdictPort",
              "ValidatorVerdictPort"
            ],
            "is_relative": false,
            "line": 101
          }
        ],
        "constants": [
          {
            "name": "CONTRACT_SERVICE_VERSION",
            "line": 128
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "degraded_mode_checker.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/degraded_mode_checker.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 676,
        "module_docstring": "Module: degraded_mode_checker\nPurpose: Check and manage governance degraded mode with incident integration.\n\nWhen governance systems are unavailable or degraded, this module:\n    - Tracks the degraded state with proper metadata\n    - Creates incidents for degraded mode transitions\n    - Enforces degraded mode rules (block new runs, warn existing)\n    - Integrates with incident response for visibility\n\nDegraded Mode States:\n    - NORMAL: Governance is fully operational\n    - DEGRADED: Governance is partially unavailable\n    - CRITICAL: Governance is fully unavailable (block all)\n\nExports:\n    - GovernanceDegradedModeError: Raised when degraded mode blocks operation\n    - GovernanceDegradedModeChecker: Main checker class\n    - DegradedModeIncidentCreator: Creates incidents for degraded mode\n    - check_degraded_mode: Quick helper function\n    - enter_degraded_with_incident: Enter degraded mode with incident",
        "functions": [
          {
            "name": "check_degraded_mode",
            "signature": "(check_enabled: bool = True) -> DegradedModeCheckResponse",
            "docstring": "Quick helper to check degraded mode.\n\nArgs:\n    check_enabled: Whether checking is enabled\n\nReturns:\n    DegradedModeCheckResponse with current state",
            "is_async": false,
            "line": 606
          },
          {
            "name": "ensure_not_degraded",
            "signature": "(operation: str, check_enabled: bool = True) -> None",
            "docstring": "Quick helper to ensure not in degraded mode or raise error.\n\nArgs:\n    operation: Name of the operation being attempted\n    check_enabled: Whether checking is enabled\n\nRaises:\n    GovernanceDegradedModeError: If governance is degraded and blocking",
            "is_async": false,
            "line": 622
          },
          {
            "name": "enter_degraded_with_incident",
            "signature": "(state: DegradedModeState, reason: str, entered_by: str, new_runs_action: str = 'BLOCK', existing_runs_action: str = 'WARN') -> DegradedModeStatus",
            "docstring": "Quick helper to enter degraded mode with incident.\n\nArgs:\n    state: Degraded mode state to enter\n    reason: Reason for entering degraded mode\n    entered_by: Who/what triggered the transition\n    new_runs_action: Action for new runs\n    existing_runs_action: Action for existing runs\n\nReturns:\n    DegradedModeStatus after transition",
            "is_async": false,
            "line": 640
          },
          {
            "name": "_reset_degraded_mode_state",
            "signature": "() -> None",
            "docstring": "Reset global state (for testing only).",
            "is_async": false,
            "line": 672
          }
        ],
        "classes": [
          {
            "name": "DegradedModeCheckResult",
            "docstring": "Result of a degraded mode check.",
            "methods": [],
            "line": 46
          },
          {
            "name": "DegradedModeState",
            "docstring": "Possible degraded mode states.",
            "methods": [],
            "line": 55
          },
          {
            "name": "GovernanceDegradedModeError",
            "docstring": "Raised when governance degraded mode blocks an operation.\n\nThis error indicates that governance is in a degraded state\nand the requested operation cannot be performed.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 71
          },
          {
            "name": "DegradedModeStatus",
            "docstring": "Current degraded mode status.",
            "methods": [
              "to_dict"
            ],
            "line": 106
          },
          {
            "name": "DegradedModeCheckResponse",
            "docstring": "Response from a degraded mode check.",
            "methods": [
              "to_dict"
            ],
            "line": 131
          },
          {
            "name": "DegradedModeIncident",
            "docstring": "Incident data for degraded mode transition.",
            "methods": [],
            "line": 162
          },
          {
            "name": "DegradedModeIncidentCreator",
            "docstring": "Creates incidents for degraded mode transitions.\n\nWhen governance enters or exits degraded mode, an incident\nis created to provide visibility and audit trail.",
            "methods": [
              "__init__",
              "create_degraded_incident",
              "create_recovery_incident"
            ],
            "line": 175
          },
          {
            "name": "GovernanceDegradedModeChecker",
            "docstring": "Checks and manages governance degraded mode.\n\nGAP-070: Add DEGRADED state for incident response.\n\nThe checker validates governance availability and can enter/exit\ndegraded mode, creating incidents for visibility.\n\nUsage:\n    checker = GovernanceDegradedModeChecker(check_enabled=True)\n\n    # Check before starting a new run\n    response = checker.check()\n    if response.is_degraded:\n        handle_degraded_mode(response)\n\n    # Or ensure not degraded (raises on degraded)\n    checker.ensure_not_degraded(\"start_new_run\")\n\n    # Enter degraded mode with incident\n    checker.enter_degraded(\n        state=DegradedModeState.DEGRADED,\n        reason=\"Database connection pool exhausted\",\n        entered_by=\"health_monitor\",\n    )",
            "methods": [
              "__init__",
              "from_governance_config",
              "check_enabled",
              "get_current_status",
              "check",
              "ensure_not_degraded",
              "enter_degraded",
              "exit_degraded",
              "should_allow_new_run",
              "get_existing_run_action"
            ],
            "line": 310
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "threading",
            "names": [
              "Lock"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "FrozenSet",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "gateway_policy.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/gateway_policy.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 159,
        "module_docstring": "Gateway Public-Path Policy (Canonical)\n\nDefines which request paths are exempt from authentication.\nAll paths use canonical (unversioned) form.\n\nNo `/api/v1` paths are included \u2014 live route scan confirms 0 mounted\n`/api/v1/auth` routes in this environment.\n\nThis module contains NO framework imports \u2014 it is pure policy data.",
        "functions": [
          {
            "name": "get_public_paths",
            "signature": "() -> list[str]",
            "docstring": "Return the canonical public path exemption list.",
            "is_async": false,
            "line": 130
          },
          {
            "name": "get_public_patterns",
            "signature": "() -> list[str]",
            "docstring": "Return the canonical public pattern list.",
            "is_async": false,
            "line": 135
          },
          {
            "name": "get_gateway_policy_config",
            "signature": "() -> dict",
            "docstring": "Return kwargs for AuthGatewayMiddleware initialization.\n\nThis is the canonical source of gateway public-path policy.",
            "is_async": false,
            "line": 140
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": [
          "AUTH_GATEWAY_ENABLED",
          "PUBLIC_PATHS",
          "PUBLIC_PATTERNS",
          "get_public_paths",
          "get_public_patterns",
          "get_gateway_policy_config"
        ]
      },
      {
        "file_name": "guard_write_engine.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/guard_write_engine.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 154,
        "module_docstring": "Guard Write Engine (L5)\n\nDB write operations for Guard API.\nDelegates to GuardWriteDriver (L6) for all database access.\n\nL2 (API) \u2192 L4 (this service) \u2192 L6 (GuardWriteDriver)\n\nResponsibilities:\n- Delegate to L6 driver for data access\n- Maintain backward compatibility for callers\n\nReference: PIN-250, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [],
        "classes": [
          {
            "name": "GuardWriteService",
            "docstring": "DB write operations for Guard Console.\n\nDelegates all operations to GuardWriteDriver (L6).\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "get_or_create_killswitch_state",
              "freeze_killswitch",
              "unfreeze_killswitch",
              "acknowledge_incident",
              "resolve_incident",
              "create_demo_incident"
            ],
            "line": 62
          }
        ],
        "imports": [
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.hoc_spine.drivers.guard_write_driver",
            "names": [
              "GuardWriteDriver",
              "get_guard_write_driver"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lifecycle_provider.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/lifecycle_provider.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 363,
        "module_docstring": "Phase-9 Tenant Lifecycle Provider (Canonical)\n\nThis module provides:\n- TenantLifecycleProvider: Protocol for lifecycle operations\n- MockTenantLifecycleProvider: Deterministic mock implementation\n- TransitionResult: Result of lifecycle transitions\n\nIt is a *provider surface* used to mechanically validate OFFBOARD invariants.\nRuntime request gating and lifecycle transitions are owned by the HOC execution\npath (L2 -> L4 -> L5 -> L6) and DB-backed state, but the mock provider remains\nuseful for isolated invariant tests.\n\nDESIGN INVARIANTS (LOCKED):\n- OFFBOARD-001: Lifecycle transitions are monotonic\n- OFFBOARD-002: TERMINATED is irreversible\n- OFFBOARD-003: ARCHIVED is unreachable from ACTIVE\n- OFFBOARD-004: No customer-initiated offboarding mutations\n- OFFBOARD-005: All API keys must be revoked on TERMINATED\n- OFFBOARD-006: SDK execution must be blocked before termination completes\n- OFFBOARD-007: No new auth tokens after TERMINATED\n- OFFBOARD-008: Offboarding emits unified observability events\n- OFFBOARD-009: Observability never blocks offboarding\n- OFFBOARD-010: All offboarding actions are auditable\n\nAPPLICABILITY:\n    Lifecycle applies ONLY after OnboardingState.COMPLETE.\n    Before COMPLETE, lifecycle is not applicable.",
        "functions": [
          {
            "name": "get_lifecycle_provider",
            "signature": "() -> TenantLifecycleProvider",
            "docstring": null,
            "is_async": false,
            "line": 341
          },
          {
            "name": "set_lifecycle_provider",
            "signature": "(provider: TenantLifecycleProvider) -> None",
            "docstring": null,
            "is_async": false,
            "line": 348
          }
        ],
        "classes": [
          {
            "name": "ActorType",
            "docstring": "Who initiated the lifecycle action.",
            "methods": [],
            "line": 61
          },
          {
            "name": "ActorContext",
            "docstring": "Context about who is performing the action.",
            "methods": [],
            "line": 70
          },
          {
            "name": "TransitionResult",
            "docstring": "Result of a lifecycle transition attempt.\n\nAttributes:\n    success: Whether the transition succeeded\n    from_state: The state before transition attempt\n    to_state: The resulting state (same as from_state if failed)\n    action: The action that was attempted\n    error: Error message if transition failed\n    timestamp: When the transition occurred\n    revoked_api_keys: Number of API keys revoked (on TERMINATED)\n    blocked_workers: Number of background workers stopped",
            "methods": [
              "to_audit_record"
            ],
            "line": 79
          },
          {
            "name": "LifecycleTransitionRecord",
            "docstring": "Historical record of a lifecycle transition.",
            "methods": [],
            "line": 118
          },
          {
            "name": "TenantLifecycleProvider",
            "docstring": "Protocol for tenant lifecycle operations.",
            "methods": [
              "get_state",
              "transition",
              "suspend",
              "resume",
              "terminate",
              "archive",
              "get_history",
              "allows_sdk_execution",
              "allows_writes",
              "allows_new_api_keys"
            ],
            "line": 131
          },
          {
            "name": "MockTenantLifecycleProvider",
            "docstring": "Deterministic mock implementation of TenantLifecycleProvider.\n\nIn-memory storage with full invariant enforcement.\nEmits observability events via callback (non-blocking per OFFBOARD-009).",
            "methods": [
              "__init__",
              "get_state",
              "_emit_event",
              "transition",
              "_record_history",
              "suspend",
              "resume",
              "terminate",
              "archive",
              "get_history",
              "allows_sdk_execution",
              "allows_writes",
              "allows_new_api_keys",
              "set_state",
              "clear"
            ],
            "line": 170
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Callable",
              "Dict",
              "List",
              "Optional",
              "Protocol"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.tenant_lifecycle_state",
            "names": [
              "LifecycleAction",
              "TenantLifecycleState",
              "get_action_for_transition",
              "is_valid_transition"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [],
        "all_exports": [
          "ActorType",
          "ActorContext",
          "TransitionResult",
          "LifecycleTransitionRecord",
          "TenantLifecycleProvider",
          "MockTenantLifecycleProvider",
          "get_lifecycle_provider",
          "set_lifecycle_provider"
        ]
      },
      {
        "file_name": "onboarding_policy.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/onboarding_policy.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 185,
        "module_docstring": "Onboarding Gate Policy (Canonical)\n\nDefines which onboarding state is required for each endpoint.\nAll paths use canonical (unversioned) form.\n\nNo `/api/v1` paths are included \u2014 live route scan confirms 0 mounted\n`/api/v1/auth` routes in this environment. Auth callbacks use\ncanonical paths and are exempt via INFRA_PATHS.\n\nRESOLUTION ORDER:\n1. Infra paths \u2192 exempt (no gating)\n2. Auth-exempt prefixes \u2192 exempt\n3. Non-tenant prefixes \u2192 exempt\n4. Exact path match \u2192 required state\n5. Regex pattern match (first match wins) \u2192 required state\n6. Default \u2192 COMPLETE (fail-safe)\n\nThis module contains NO framework imports \u2014 it is pure policy data.",
        "functions": [
          {
            "name": "get_required_state",
            "signature": "(path: str) -> Optional[OnboardingState]",
            "docstring": "Get the required onboarding state for a path.\n\nRESOLUTION ORDER:\n1. Infra paths \u2192 None (exempt)\n2. Auth-exempt prefixes \u2192 None (exempt)\n3. Non-tenant prefixes \u2192 None (exempt)\n4. Exact path match \u2192 required state\n5. Regex pattern match (first match wins) \u2192 required state\n6. Default \u2192 COMPLETE (fail-safe)\n\nReturns None if the path is exempt from onboarding gating.",
            "is_async": false,
            "line": 137
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.onboarding_state",
            "names": [
              "OnboardingState"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": [
          "AUTH_EXEMPT_PREFIXES",
          "NON_TENANT_PREFIXES",
          "INFRA_PATHS",
          "ENDPOINT_STATE_REQUIREMENTS",
          "ENDPOINT_PATTERN_REQUIREMENTS",
          "get_required_state"
        ]
      },
      {
        "file_name": "profile_policy_mode.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/profile_policy_mode.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 459,
        "module_docstring": "Governance Profile Configuration\n\nReduces cognitive load and configuration drift by providing three\nwell-defined governance profiles:\n\n- STRICT: Full enforcement, all features enabled, production-ready\n- STANDARD: Core features enabled, some optional features disabled\n- OBSERVE_ONLY: Audit and observe without enforcement (safe rollout)\n\nUsage:\n    from app.hoc.cus.hoc_spine.authority.profile_policy_mode import (\n        get_governance_profile,\n        validate_governance_config,\n        GovernanceProfile,\n    )\n\n    # At startup\n    profile = get_governance_profile()\n    validate_governance_config()  # Raises if invalid combination\n\n    # Check profile\n    if profile == GovernanceProfile.STRICT:\n        # Full enforcement mode\n        ...\n\nEnvironment Variables:\n    GOVERNANCE_PROFILE: STRICT | STANDARD | OBSERVE_ONLY (default: STANDARD)\n\n    Individual flags (override profile defaults):\n    - ROK_ENABLED\n    - RAC_ENABLED\n    - TRANSACTION_COORDINATOR_ENABLED\n    - EVENT_REACTOR_ENABLED\n    - MID_EXECUTION_POLICY_CHECK_ENABLED\n    - RAC_DURABILITY_ENFORCE (STRICT only)\n    - PHASE_STATUS_INVARIANT_ENFORCE (STRICT only)",
        "functions": [
          {
            "name": "_get_bool_env",
            "signature": "(name: str, default: bool) -> bool",
            "docstring": "Get boolean from environment variable.",
            "is_async": false,
            "line": 246
          },
          {
            "name": "get_governance_profile",
            "signature": "() -> GovernanceProfile",
            "docstring": "Get the current governance profile from environment.\n\nReturns:\n    GovernanceProfile enum value",
            "is_async": false,
            "line": 254
          },
          {
            "name": "load_governance_config",
            "signature": "() -> GovernanceConfig",
            "docstring": "Load complete governance configuration.\n\nLoads profile defaults, then applies any environment variable overrides.\n\nReturns:\n    GovernanceConfig with all settings",
            "is_async": false,
            "line": 276
          },
          {
            "name": "validate_governance_config",
            "signature": "(config: Optional[GovernanceConfig] = None) -> List[str]",
            "docstring": "Validate governance configuration for invalid combinations.\n\nArgs:\n    config: Configuration to validate (loads from env if not provided)\n\nReturns:\n    List of warning messages (empty if valid)\n\nRaises:\n    GovernanceConfigError: If configuration has blocking violations",
            "is_async": false,
            "line": 326
          },
          {
            "name": "get_governance_config",
            "signature": "() -> GovernanceConfig",
            "docstring": "Get the validated governance configuration singleton.\n\nLoads and validates on first call, caches thereafter.\n\nReturns:\n    Validated GovernanceConfig",
            "is_async": false,
            "line": 411
          },
          {
            "name": "reset_governance_config",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 427
          },
          {
            "name": "validate_governance_at_startup",
            "signature": "() -> None",
            "docstring": "Validate governance configuration at application startup.\n\nCall this from main.py during FastAPI lifespan startup.\n\nRaises:\n    GovernanceConfigError: If configuration is invalid",
            "is_async": false,
            "line": 438
          }
        ],
        "classes": [
          {
            "name": "GovernanceProfile",
            "docstring": "Pre-defined governance profiles.\n\nEach profile represents a coherent set of feature flag settings\ndesigned for specific deployment scenarios.",
            "methods": [],
            "line": 68
          },
          {
            "name": "GovernanceConfig",
            "docstring": "Complete governance configuration derived from profile + overrides.",
            "methods": [
              "to_dict"
            ],
            "line": 110
          },
          {
            "name": "GovernanceConfigError",
            "docstring": "Raised when governance configuration is invalid.",
            "methods": [
              "__init__"
            ],
            "line": 233
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "FrozenSet",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "rbac_policy.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/rbac_policy.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 544,
        "module_docstring": "RBAC Policy (Canonical)\n\nDefines the RBAC role-resource matrix and path-to-policy mapping.\nAll path matchers use canonical (unversioned) form.\n\nThis module contains NO framework imports \u2014 it is pure policy data.\nThe `enforce()` function (which needs Request) stays in the middleware.",
        "functions": [
          {
            "name": "get_policy_for_path",
            "signature": "(path: str, method: str) -> Optional[PolicyObject]",
            "docstring": "Map request path and method to a PolicyObject.\n\nReturns None for explicitly public paths (no RBAC needed).\nAll path matchers use canonical (unversioned) form.",
            "is_async": false,
            "line": 227
          }
        ],
        "classes": [
          {
            "name": "PolicyObject",
            "docstring": "Represents an authorization policy for a resource action.\n\nAttributes:\n    resource: Resource type (e.g., \"memory_pin\", \"prometheus\")\n    action: Action type (e.g., \"read\", \"write\", \"delete\", \"admin\")\n    attrs: Optional additional attributes for context-aware decisions",
            "methods": [],
            "line": 41
          },
          {
            "name": "Decision",
            "docstring": "Result of an authorization decision.\n\nAttributes:\n    allowed: Whether the action is permitted\n    reason: Human-readable reason for the decision\n    roles: Roles that contributed to the decision\n    policy: The policy that was evaluated",
            "methods": [],
            "line": 57
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 28
          }
        ],
        "constants": [
          {
            "name": "CURRENT_ENVIRONMENT",
            "line": 33
          }
        ],
        "all_exports": [
          "PolicyObject",
          "Decision",
          "RBAC_MATRIX",
          "CURRENT_ENVIRONMENT",
          "get_policy_for_path"
        ]
      },
      {
        "file_name": "route_planes.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/route_planes.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 257,
        "module_docstring": "Route Plane Policy (Canonical)\n\nDefines which authentication plane (HUMAN, MACHINE, or BOTH)\nis allowed for each route pattern. All paths use canonical\n(unversioned) form.\n\nINVARIANTS:\n1. Worker endpoints NEVER accept JWT (workers can't impersonate users)\n2. Admin endpoints NEVER accept API keys (prevent privilege escalation)\n3. Mismatch = 403 Forbidden (not 401)\n\nThis module contains NO framework imports \u2014 it is pure policy data.",
        "functions": [
          {
            "name": "get_plane_requirement",
            "signature": "(path: str) -> PlaneRequirement",
            "docstring": "Get the plane requirement for a path.\n\nReturns PlaneRequirement.BOTH if no rule matches.",
            "is_async": false,
            "line": 173
          },
          {
            "name": "check_plane_match",
            "signature": "(path: str, actual_plane: AuthPlane) -> tuple[bool, Optional[str]]",
            "docstring": "Check if the actual auth plane matches the route requirement.\n\nReturns (is_allowed, error_message).",
            "is_async": false,
            "line": 185
          },
          {
            "name": "is_worker_path",
            "signature": "(path: str) -> bool",
            "docstring": "Check if path is a worker execution path (MACHINE_ONLY).",
            "is_async": false,
            "line": 212
          },
          {
            "name": "is_admin_path",
            "signature": "(path: str) -> bool",
            "docstring": "Check if path is an admin/founder path (HUMAN_ONLY).",
            "is_async": false,
            "line": 217
          },
          {
            "name": "enforce_plane_requirement",
            "signature": "(path: str, actual_plane: AuthPlane) -> Optional[dict]",
            "docstring": "Enforce plane requirement for a path.\n\nReturns None if allowed, or error dict if blocked.",
            "is_async": true,
            "line": 226
          }
        ],
        "classes": [
          {
            "name": "PlaneRequirement",
            "docstring": "What authentication plane(s) a route accepts.",
            "methods": [],
            "line": 38
          },
          {
            "name": "RoutePlaneRule",
            "docstring": "A rule mapping route pattern to plane requirement.",
            "methods": [
              "__post_init__",
              "matches"
            ],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.auth.contexts",
            "names": [
              "AuthPlane"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": [
          "PlaneRequirement",
          "RoutePlaneRule",
          "ROUTE_PLANE_RULES",
          "get_plane_requirement",
          "check_plane_match",
          "is_worker_path",
          "is_admin_path",
          "enforce_plane_requirement"
        ]
      },
      {
        "file_name": "runtime.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/runtime.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 68,
        "module_docstring": "Runtime Utilities - Centralized Shared Helpers\n\nCANONICAL LOCATION: All code needing generate_uuid() or utc_now() must import from here.\nDO NOT define these functions elsewhere.\nDO NOT import them transitively through other modules.\n\nThis prevents import hygiene violations where services fail at runtime\nbecause they relied on transitive imports that aren't guaranteed.\n\nSee LESSONS_ENFORCED.md Invariant #5: Import Locality",
        "functions": [
          {
            "name": "generate_uuid",
            "signature": "() -> str",
            "docstring": "Generate a UUID string.\n\nCANONICAL LOCATION: Import from app.utils.runtime, not from other modules.",
            "is_async": false,
            "line": 37
          },
          {
            "name": "utc_now",
            "signature": "() -> datetime",
            "docstring": "Return timezone-aware UTC datetime.\n\nCANONICAL LOCATION: Import from app.utils.runtime, not from other modules.\n\nFor asyncpg compatibility in raw SQL, use utc_now_naive() instead.",
            "is_async": false,
            "line": 46
          },
          {
            "name": "utc_now_naive",
            "signature": "() -> datetime",
            "docstring": "Return timezone-naive UTC datetime (for asyncpg raw SQL compatibility).\n\nUse this ONLY when:\n- Writing raw SQL with asyncpg\n- You explicitly need a naive datetime\n\nFor all other cases, prefer utc_now().",
            "is_async": false,
            "line": 57
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "runtime_adapter.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/runtime_adapter.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 217,
        "module_docstring": "Runtime Adapter (L2)\n\nAdapter for runtime API operations. This is the boundary between:\n- L2 (API routes) - callers\n- L4 (Domain commands) - domain decisions\n\nThis adapter:\n1. Receives API requests from L2\n2. Translates them into L4 domain facts\n3. Calls L4 command functions\n4. Returns domain results to L2\n\nIt does NOT:\n- Import from L5 (workers)\n- Execute skills directly\n- Make domain decisions (that's L4's job)\n\nReference: PIN-258 Phase F-3 Runtime Cluster",
        "functions": [
          {
            "name": "get_runtime_adapter",
            "signature": "() -> RuntimeAdapter",
            "docstring": "Factory function to get RuntimeAdapter instance.\n\nThis is the entry point for L2 to get the adapter.\n\nReturns:\n    RuntimeAdapter instance\n\nReference: PIN-258 Phase F-3",
            "is_async": false,
            "line": 196
          }
        ],
        "classes": [
          {
            "name": "RuntimeAdapter",
            "docstring": "Adapter for runtime operations.\n\nTranslates API requests into L4 domain commands.\nThis is the ONLY runtime interface L2 may call.\n\nReference: PIN-258 Phase F-3 Runtime Cluster",
            "methods": [
              "__init__",
              "query",
              "get_supported_queries",
              "describe_skill",
              "list_skills",
              "get_skill_descriptors",
              "get_resource_contract",
              "get_capabilities"
            ],
            "line": 60
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.commands.runtime_command",
            "names": [
              "CapabilitiesInfo",
              "QueryResult",
              "ResourceContractInfo",
              "SkillInfo",
              "execute_query",
              "get_all_skill_descriptors",
              "get_capabilities",
              "get_resource_contract",
              "get_skill_info",
              "get_supported_query_types",
              "list_skills"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": [
          "RuntimeAdapter",
          "get_runtime_adapter"
        ]
      },
      {
        "file_name": "runtime_switch.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/runtime_switch.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 279,
        "module_docstring": "Module: runtime_switch\nPurpose: Provides runtime toggle for governance. Emergency kill switch.\n\nImports (Dependencies):\n    - logging\n    - datetime\n    - threading (for atomic operations)\n\nExports (Provides):\n    - is_governance_active() -> bool\n    - disable_governance_runtime(reason, actor) -> None\n    - enable_governance_runtime(actor) -> None\n    - get_governance_state() -> GovernanceState\n    - is_degraded_mode() -> bool (GAP-070)\n    - enter_degraded_mode(reason, actor) -> None (GAP-070)\n    - exit_degraded_mode(actor) -> None (GAP-070)\n\nWiring Points:\n    - Called from: prevention_engine.py (check before enforcement)\n    - Called from: runner.py (check before accepting new runs)\n    - Called from: ops_api.py (manual toggle endpoint)\n    - Emits: governance_state_changed event\n\nAcceptance Criteria:\n    - [x] AC-069-01: Governance active by default\n    - [x] AC-069-02: Kill switch disables enforcement\n    - [x] AC-069-03: Kill switch logs critical audit\n    - [x] AC-069-04: Re-enable restores enforcement\n    - [x] AC-069-05: OPS endpoint exists\n    - [x] AC-069-06: Requires OPS permission\n    - [x] AC-069-07: State visible in health\n    - [x] AC-069-08: Thread-safe operations",
        "functions": [
          {
            "name": "is_governance_active",
            "signature": "() -> bool",
            "docstring": "Check if governance is currently active.\n\nReturns:\n    True if governance enforcement is active",
            "is_async": false,
            "line": 82
          },
          {
            "name": "is_degraded_mode",
            "signature": "() -> bool",
            "docstring": "Check if system is in degraded mode (GAP-070).\n\nDegraded mode:\n- Governance is active\n- New runs are blocked\n- Existing runs complete with WARN\n\nReturns:\n    True if in degraded mode",
            "is_async": false,
            "line": 93
          },
          {
            "name": "disable_governance_runtime",
            "signature": "(reason: str, actor: str) -> None",
            "docstring": "Emergency kill switch. Disables governance enforcement.\n\nWARNING: This allows runs to bypass policy enforcement.\nUse only for emergency incident response.\n\nArgs:\n    reason: Why governance is being disabled\n    actor: Who/what triggered the disable (user_id or \"system\")",
            "is_async": false,
            "line": 109
          },
          {
            "name": "enable_governance_runtime",
            "signature": "(actor: str) -> None",
            "docstring": "Re-enable governance after emergency.\n\nArgs:\n    actor: Who/what triggered the re-enable",
            "is_async": false,
            "line": 141
          },
          {
            "name": "enter_degraded_mode",
            "signature": "(reason: str, actor: str) -> None",
            "docstring": "GAP-070: Enter degraded mode.\n\nDegraded mode:\n- Blocks new runs\n- Existing runs complete with WARN\n- Full audit emitted\n\nArgs:\n    reason: Why entering degraded mode\n    actor: Who/what triggered degraded mode",
            "is_async": false,
            "line": 167
          },
          {
            "name": "exit_degraded_mode",
            "signature": "(actor: str) -> None",
            "docstring": "Exit degraded mode, return to normal operation.\n\nArgs:\n    actor: Who/what triggered exit from degraded mode",
            "is_async": false,
            "line": 200
          },
          {
            "name": "get_governance_state",
            "signature": "() -> dict",
            "docstring": "Get current governance state for health checks.\n\nReturns:\n    Dict with governance state details",
            "is_async": false,
            "line": 226
          },
          {
            "name": "reset_governance_state",
            "signature": "() -> None",
            "docstring": "Reset governance state to defaults (for testing).",
            "is_async": false,
            "line": 243
          },
          {
            "name": "_emit_governance_event",
            "signature": "(event_type: str, reason: str, actor: str) -> None",
            "docstring": "Emit governance state change event.\n\nArgs:\n    event_type: Type of event (governance_disabled, governance_enabled, etc.)\n    reason: Reason for the change\n    actor: Who triggered the change",
            "is_async": false,
            "line": 257
          }
        ],
        "classes": [
          {
            "name": "GovernanceState",
            "docstring": "Current governance state.",
            "methods": [],
            "line": 62
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "threading",
            "names": [
              "threading"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "veil_policy.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/authority/veil_policy.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 70,
        "module_docstring": "Veil controls reduce attack-surface observability.\n\nThese are not authentication or authorization; they are posture choices:\n- schema/docs exposure gating\n- deny-as-404 posture for unauthorized paths\n- probe rate limiting for unauthenticated requests",
        "functions": [
          {
            "name": "_mode",
            "signature": "() -> str",
            "docstring": null,
            "is_async": false,
            "line": 16
          },
          {
            "name": "is_prod",
            "signature": "() -> bool",
            "docstring": null,
            "is_async": false,
            "line": 20
          },
          {
            "name": "fastapi_schema_urls",
            "signature": "() -> dict[str, object]",
            "docstring": "Return FastAPI docs/openapi configuration.\n\nDefault posture:\n- Non-prod: keep docs enabled (developer convenience).\n- Prod: hide docs and OpenAPI by default.",
            "is_async": false,
            "line": 24
          },
          {
            "name": "deny_as_404_enabled",
            "signature": "() -> bool",
            "docstring": "If enabled, deny responses avoid revealing existence of protected resources.",
            "is_async": false,
            "line": 42
          },
          {
            "name": "unauthorized_http_status_code",
            "signature": "(default: int = 403) -> int",
            "docstring": null,
            "is_async": false,
            "line": 51
          },
          {
            "name": "unauthenticated_http_status_code",
            "signature": "(default: int = 401) -> int",
            "docstring": null,
            "is_async": false,
            "line": 55
          },
          {
            "name": "probe_rate_limit_enabled",
            "signature": "() -> bool",
            "docstring": null,
            "is_async": false,
            "line": 59
          },
          {
            "name": "probe_rate_per_minute",
            "signature": "() -> int",
            "docstring": null,
            "is_async": false,
            "line": 65
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 11
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 13
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "dispatch_metrics_adapter.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/consequences/adapters/dispatch_metrics_adapter.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 154,
        "module_docstring": "Dispatch Metrics Adapter.\n\nAggregates operational metrics from DispatchRecords:\n- Per-operation call counts (total, success, failure)\n- Per-operation latency tracking (min, max, sum for avg computation)\n- Per-tenant operation counts\n\nIn-memory only \u2014 no external dependencies. Thread-safe via Lock.\nMetrics are queryable for observability dashboards and health checks.",
        "functions": [
          {
            "name": "get_dispatch_metrics_adapter",
            "signature": "() -> DispatchMetricsAdapter",
            "docstring": "Get the dispatch metrics adapter singleton.",
            "is_async": false,
            "line": 149
          }
        ],
        "classes": [
          {
            "name": "OperationMetrics",
            "docstring": "Aggregated metrics for a single operation name.",
            "methods": [
              "avg_latency_ms",
              "error_rate",
              "to_dict"
            ],
            "line": 44
          },
          {
            "name": "DispatchMetricsAdapter",
            "docstring": "Post-dispatch consequence: aggregate operation metrics.\n\nSatisfies ConsequenceAdapter protocol. Thread-safe.",
            "methods": [
              "__init__",
              "name",
              "handle",
              "get_operation_metrics",
              "get_tenant_counts",
              "get_summary"
            ],
            "line": 77
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "collections",
            "names": [
              "defaultdict"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "threading",
            "names": [
              "Lock"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.dispatch_audit",
            "names": [
              "DispatchRecord"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "export_bundle_adapter.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/consequences/adapters/export_bundle_adapter.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 431,
        "module_docstring": "Export Bundle Adapter (L2)\n\nGenerates structured export bundles from incidents, runs, and traces\nfor evidence export, SOC2 compliance, and executive debriefs.\n\nADAPTER CONTRACT:\n- NO sqlalchemy imports\n- NO direct database queries\n- Delegates all data access to L6 ExportBundleStore",
        "functions": [
          {
            "name": "get_export_bundle_adapter",
            "signature": "() -> ExportBundleAdapter",
            "docstring": "Get or create ExportBundleAdapter singleton.",
            "is_async": false,
            "line": 420
          }
        ],
        "classes": [
          {
            "name": "ExportBundleAdapter",
            "docstring": "Adapter for generating export bundles.\n\nTranslates between API requests and L6 store,\ncomposing bundle structures from raw data.",
            "methods": [
              "__init__",
              "create_evidence_bundle",
              "create_soc2_bundle",
              "create_executive_debrief",
              "_compute_bundle_hash",
              "_generate_attestation",
              "_assess_risk_level",
              "_generate_incident_summary",
              "_assess_business_impact",
              "_generate_recommendations"
            ],
            "line": 63
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.models.export_bundles",
            "names": [
              "DEFAULT_SOC2_CONTROLS",
              "EvidenceBundle",
              "ExecutiveDebriefBundle",
              "PolicyContext",
              "SOC2Bundle",
              "TraceStepEvidence"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.hoc.cus.logs.L6_drivers.export_bundle_store",
            "names": [
              "IncidentSnapshot",
              "RunSnapshot",
              "TraceSummarySnapshot"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": [
          "ExportBundleAdapter",
          "get_export_bundle_adapter"
        ]
      },
      {
        "file_name": "pipeline.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/consequences/pipeline.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 140,
        "module_docstring": "Consequences Pipeline.\n\nEntry point for post-dispatch consequences. Runs registered adapters\nagainst each DispatchRecord after audit store persistence.\n\nConstitution \u00a72.3: Consequences are post-commit only. They never\nparticipate in the operation's transaction. Adapter failures are\nlogged but never propagate \u2014 the operation result is already final.\n\nUsage (from OperationRegistry._audit_dispatch):\n    from app.hoc.cus.hoc_spine.consequences.pipeline import get_consequence_pipeline\n    get_consequence_pipeline().run(record)",
        "functions": [
          {
            "name": "get_consequence_pipeline",
            "signature": "() -> ConsequencePipeline",
            "docstring": "Get the consequence pipeline singleton.\n\nReturns:\n    ConsequencePipeline instance",
            "is_async": false,
            "line": 130
          }
        ],
        "classes": [
          {
            "name": "ConsequencePipeline",
            "docstring": "Post-dispatch consequence pipeline.\n\nAdapters are registered at startup and run synchronously for each\ndispatch. Each adapter is wrapped in try/except \u2014 a failing adapter\nnever blocks other adapters or the dispatch response.",
            "methods": [
              "__init__",
              "register",
              "freeze",
              "is_frozen",
              "adapter_count",
              "adapter_names",
              "run"
            ],
            "line": 44
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.hoc.cus.hoc_spine.consequences.ports",
            "names": [
              "ConsequenceAdapter"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.dispatch_audit",
            "names": [
              "DispatchRecord"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "ports.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/consequences/ports.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 60,
        "module_docstring": "Consequence Adapter Protocol.\n\nDefines the port that all consequence adapters must satisfy.\nAdapters run AFTER dispatch completes \u2014 post-commit only,\nnever inside the operation's transaction (Constitution \u00a72.3).",
        "functions": [],
        "classes": [
          {
            "name": "ConsequenceAdapter",
            "docstring": "Port for post-dispatch consequence adapters.\n\nImplementations must:\n- Accept a DispatchRecord (immutable, frozen)\n- Be non-blocking (no long I/O in the sync path)\n- Be side-effect safe (failures must not propagate)\n- Have a name property for logging/diagnostics\n\nThe pipeline wraps each adapter call in try/except,\nso a failing adapter never breaks other adapters.",
            "methods": [
              "name",
              "handle"
            ],
            "line": 34
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.dispatch_audit",
            "names": [
              "DispatchRecord"
            ],
            "is_relative": false,
            "line": 30
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "alert_driver.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/alert_driver.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 342,
        "module_docstring": "Alert Driver (L6)\n\nPure database operations for alert queue management.\nAll business logic stays in L4 engine.\nAll HTTP delivery stays in adapter.\n\nOperations:\n- Read pending alerts from queue\n- Update alert status (sent, retry, failed)\n- Update incident alert_sent flag\n- Queue statistics\n- Enqueue new alerts\n- Retry/purge operations\n\nNO business logic:\n- NO retry decision logic (L4)\n- NO backoff calculation (L4)\n- NO HTTP operations (adapter)\n\nReference: Phase-2.5A Analytics Extraction",
        "functions": [
          {
            "name": "get_alert_driver",
            "signature": "(session: AsyncSession) -> AlertDriver",
            "docstring": "Factory function to get AlertDriver instance.",
            "is_async": false,
            "line": 334
          }
        ],
        "classes": [
          {
            "name": "AlertDriver",
            "docstring": "L6 driver for alert queue data access.\n\nPure database access - no business logic, no HTTP.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "fetch_pending_alerts",
              "fetch_queue_stats",
              "update_alert_sent",
              "update_alert_retry",
              "update_alert_failed",
              "mark_incident_alert_sent",
              "insert_alert",
              "retry_failed_alerts",
              "purge_old_alerts"
            ],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "delete",
              "func",
              "select",
              "update"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "app.models.costsim_cb",
            "names": [
              "CostSimAlertQueueModel",
              "CostSimCBIncidentModel"
            ],
            "is_relative": false,
            "line": 73
          }
        ],
        "constants": [],
        "all_exports": [
          "AlertDriver",
          "get_alert_driver"
        ]
      },
      {
        "file_name": "alert_emitter.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/alert_emitter.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 479,
        "module_docstring": "Alert Emitter Service\n\nEmits alerts for threshold events via configured channels:\n- UI notifications\n- Webhooks\n- Email (future)\n- Slack (future)\n\nAlert flow:\n1. ThresholdSignal created\n2. AlertEmitter checks AlertConfig\n3. If enabled and not throttled, send via configured channels\n4. Record alert sent status",
        "functions": [
          {
            "name": "get_alert_emitter",
            "signature": "() -> AlertEmitter",
            "docstring": "Get or create AlertEmitter singleton.",
            "is_async": false,
            "line": 474
          }
        ],
        "classes": [
          {
            "name": "AlertEmitter",
            "docstring": "Emits alerts for threshold events.\n\nHandles alert throttling, channel routing, and delivery tracking.",
            "methods": [
              "__init__",
              "emit_near_threshold",
              "emit_breach",
              "_send_via_channel",
              "_send_ui_notification",
              "_send_webhook",
              "_send_slack",
              "_send_email",
              "_persist_signal",
              "_persist_config"
            ],
            "line": 52
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.db",
            "names": [
              "engine"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.alert_config",
            "names": [
              "AlertChannel",
              "AlertConfig"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.models.threshold_signal",
            "names": [
              "SignalType",
              "ThresholdSignal"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cross_domain.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/cross_domain.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 506,
        "module_docstring": "Cross-Domain Governance Functions (Mandatory)\n\nPIN: design/CROSS_DOMAIN_GOVERNANCE.md\n\nThese functions implement mandatory governance for customer-facing paths.\nThey MUST succeed or raise GovernanceError. Silent failures are forbidden.\n\nDOCTRINE:\n- Rule 1: Governance must throw\n- Rule 2: No optional dependencies\n- Rule 3: Learning is downstream only\n\nDOMAINS:\n- Analytics \u2192 Incidents: Cost anomalies MUST create incidents\n- Policies \u2194 Analytics: Limit breaches MUST be recorded\n\nCOROLLARY: GovernanceError must surface - never catch and ignore.",
        "functions": [
          {
            "name": "utc_now",
            "signature": "() -> datetime",
            "docstring": "Return timezone-aware UTC datetime.",
            "is_async": false,
            "line": 62
          },
          {
            "name": "generate_uuid",
            "signature": "() -> str",
            "docstring": "Generate a UUID string.",
            "is_async": false,
            "line": 67
          },
          {
            "name": "create_incident_from_cost_anomaly",
            "signature": "(session: AsyncSession, tenant_id: str, anomaly_id: str, anomaly_type: str, severity: str, current_value_cents: int, expected_value_cents: int, entity_type: Optional[str] = None, entity_id: Optional[str] = None, description: Optional[str] = None) -> str",
            "docstring": "Create an incident from a cost anomaly. MANDATORY.\n\nThis function MUST succeed or raise GovernanceError.\nIt cannot be skipped based on optional configuration.\n\nArgs:\n    session: Database session\n    tenant_id: Tenant scope\n    anomaly_id: ID of the cost anomaly\n    anomaly_type: Type of anomaly (BUDGET_EXCEEDED, USER_SPIKE, etc.)\n    severity: Anomaly severity (CRITICAL, HIGH, MEDIUM, LOW)\n    current_value_cents: Actual cost in cents\n    expected_value_cents: Expected cost in cents\n    entity_type: Optional entity type (user, tenant, etc.)\n    entity_id: Optional entity ID\n    description: Optional description\n\nReturns:\n    incident_id\n\nRaises:\n    GovernanceError: If incident cannot be created\n\nExample:\n    incident_id = await create_incident_from_cost_anomaly(\n        session=session,\n        tenant_id=\"tenant-123\",\n        anomaly_id=\"anomaly-456\",\n        anomaly_type=\"BUDGET_EXCEEDED\",\n        severity=\"HIGH\",\n        current_value_cents=15000,\n        expected_value_cents=10000,\n    )",
            "is_async": true,
            "line": 97
          },
          {
            "name": "record_limit_breach",
            "signature": "(session: AsyncSession, tenant_id: str, limit_id: str, breach_type: str, value_at_breach: Decimal, limit_value: Decimal, run_id: Optional[str] = None, incident_id: Optional[str] = None, details: Optional[dict] = None) -> str",
            "docstring": "Record a limit breach. MANDATORY.\n\nThis function MUST succeed or raise GovernanceError.\nEvery budget/rate/threshold breach MUST be recorded.\n\nArgs:\n    session: Database session\n    tenant_id: Tenant scope\n    limit_id: ID of the limit that was breached\n    breach_type: Type of breach (BREACHED, EXHAUSTED, THROTTLED, VIOLATED)\n    value_at_breach: The value that caused the breach\n    limit_value: The limit value that was exceeded\n    run_id: Optional ID of the run that caused the breach\n    incident_id: Optional ID of resulting incident\n    details: Optional additional context\n\nReturns:\n    breach_id\n\nRaises:\n    GovernanceError: If breach cannot be recorded\n\nExample:\n    breach_id = await record_limit_breach(\n        session=session,\n        tenant_id=\"tenant-123\",\n        limit_id=\"limit-456\",\n        breach_type=\"BREACHED\",\n        value_at_breach=Decimal(\"150.00\"),\n        limit_value=Decimal(\"100.00\"),\n        run_id=\"run-789\",\n    )",
            "is_async": true,
            "line": 222
          },
          {
            "name": "table_exists",
            "signature": "(session: AsyncSession, table_name: str) -> bool",
            "docstring": "Check if a table exists in the database.\n\nUsed by Overview for defensive queries that should degrade gracefully.\n\nArgs:\n    session: Database session\n    table_name: Name of the table to check\n\nReturns:\n    True if table exists, False otherwise",
            "is_async": true,
            "line": 313
          },
          {
            "name": "create_incident_from_cost_anomaly_sync",
            "signature": "(session: Session, tenant_id: str, anomaly_id: str, anomaly_type: str, severity: str, current_value_cents: int, expected_value_cents: int, entity_type: Optional[str] = None, entity_id: Optional[str] = None, description: Optional[str] = None) -> str",
            "docstring": "Create an incident from a cost anomaly (SYNC version). MANDATORY.\n\nSame as create_incident_from_cost_anomaly but for sync sessions.\nSee async version for full documentation.\n\nRaises:\n    GovernanceError: If incident cannot be created",
            "is_async": false,
            "line": 354
          },
          {
            "name": "record_limit_breach_sync",
            "signature": "(session: Session, tenant_id: str, limit_id: str, breach_type: str, value_at_breach: Decimal, limit_value: Decimal, run_id: Optional[str] = None, incident_id: Optional[str] = None, details: Optional[dict] = None) -> str",
            "docstring": "Record a limit breach (SYNC version). MANDATORY.\n\nSame as record_limit_breach but for sync sessions.\nSee async version for full documentation.\n\nRaises:\n    GovernanceError: If breach cannot be recorded",
            "is_async": false,
            "line": 448
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "Optional",
              "Union"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.errors.governance",
            "names": [
              "GovernanceError"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.metrics",
            "names": [
              "governance_incidents_created_total",
              "governance_limit_breaches_recorded_total"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "LimitBreach"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [
          {
            "name": "ANOMALY_SEVERITY_MAP",
            "line": 76
          },
          {
            "name": "ANOMALY_TRIGGER_TYPE_MAP",
            "line": 83
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "dag_executor.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/dag_executor.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 325,
        "module_docstring": "DAG-based executor for PLang v2.0.\n\nExecutes policies in topologically sorted order:\n- Parallel execution within stages\n- Sequential execution across stages\n- Governance-aware ordering\n- Full execution trace",
        "functions": [],
        "classes": [
          {
            "name": "StageResult",
            "docstring": "Result of executing a single stage.",
            "methods": [
              "success",
              "was_blocked"
            ],
            "line": 50
          },
          {
            "name": "ExecutionTrace",
            "docstring": "Full execution trace across all stages.",
            "methods": [
              "to_dict"
            ],
            "line": 72
          },
          {
            "name": "DAGExecutor",
            "docstring": "Executes policies in DAG order.\n\nFeatures:\n- Parallel execution within stages\n- Early termination on DENY\n- Governance-aware execution order\n- Full audit trail",
            "methods": [
              "__init__",
              "execute",
              "_execute_stage",
              "_execute_policy",
              "_is_more_restrictive",
              "get_execution_plan",
              "visualize_plan"
            ],
            "line": 112
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRModule"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.policy.optimizer.dag_sorter",
            "names": [
              "DAGSorter",
              "ExecutionPlan"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.deterministic_engine",
            "names": [
              "DeterministicEngine",
              "ExecutionContext",
              "ExecutionResult"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.intent",
            "names": [
              "Intent"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "decisions.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/decisions.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 1291,
        "module_docstring": "Phase 4B: Decision Record Models and Service\n\nImplements DECISION_RECORD_CONTRACT v0.2.\n\nContract-mandated fields:\n- decision_source: human | system | hybrid\n- decision_trigger: explicit | autonomous | reactive\n\nRule: Emit records where decisions already happen. No logic changes.\n\nTransaction ownership: All functions accept a connection parameter.\nThe caller (L4 handler) owns the connection lifecycle and commits.",
        "functions": [
          {
            "name": "get_decision_service",
            "signature": "() -> DecisionRecordService",
            "docstring": "Get singleton decision record service.",
            "is_async": false,
            "line": 344
          },
          {
            "name": "emit_routing_decision",
            "signature": "(connection: Any, run_id: Optional[str], routed: bool, selected_agent: Optional[str], eligible_agents: list, rejection_reason: Optional[str] = None, tenant_id: str = 'default', details: Optional[Dict[str, Any]] = None, request_id: Optional[str] = None, causal_role: CausalRole = CausalRole.PRE_RUN) -> DecisionRecord",
            "docstring": "Emit a routing decision record.\n\nCalled from CARE engine after every route() call.\nNote: Routing typically happens BEFORE run exists, so causal_role=PRE_RUN.",
            "is_async": false,
            "line": 361
          },
          {
            "name": "emit_recovery_decision",
            "signature": "(connection: Any, run_id: Optional[str], evaluated: bool, triggered: bool, action: Optional[str] = None, candidates_count: int = 0, reason: Optional[str] = None, tenant_id: str = 'default', request_id: Optional[str] = None, causal_role: CausalRole = CausalRole.IN_RUN) -> DecisionRecord",
            "docstring": "Emit a recovery decision record.\n\nCalled from recovery engine after every evaluation.\nNote: Recovery happens DURING run execution, so causal_role=IN_RUN.",
            "is_async": false,
            "line": 406
          },
          {
            "name": "emit_memory_decision",
            "signature": "(connection: Any, run_id: Optional[str], queried: bool, matched: bool, injected: bool, sources: Optional[list] = None, reason: Optional[str] = None, tenant_id: str = 'default', request_id: Optional[str] = None, causal_role: CausalRole = CausalRole.IN_RUN) -> DecisionRecord",
            "docstring": "Emit a memory injection decision record.\n\nCalled after every memory query attempt.\nNote: Memory injection can happen pre-run or in-run. Default is IN_RUN.",
            "is_async": false,
            "line": 455
          },
          {
            "name": "emit_policy_decision",
            "signature": "(connection: Any, run_id: Optional[str], policy_id: str, evaluated: bool, violated: bool, severity: str = 'warning', reason: Optional[str] = None, tenant_id: str = 'default', request_id: Optional[str] = None, causal_role: CausalRole = CausalRole.IN_RUN) -> DecisionRecord",
            "docstring": "Emit a policy enforcement decision record.\n\nCalled after every policy check.\nNote: Policy checks can happen pre-run or in-run. Default is IN_RUN.",
            "is_async": false,
            "line": 508
          },
          {
            "name": "emit_budget_decision",
            "signature": "(connection: Any, run_id: Optional[str], budget_requested: int, budget_available: int, enforcement: str = 'soft', simulation_feasible: Optional[bool] = None, proceeded: bool = True, reason: Optional[str] = None, tenant_id: str = 'default', request_id: Optional[str] = None, causal_role: CausalRole = CausalRole.PRE_RUN) -> DecisionRecord",
            "docstring": "Emit a budget handling decision record.\n\nCalled after every budget check.\nNote: Budget checks typically happen pre-run to verify resource availability.",
            "is_async": false,
            "line": 556
          },
          {
            "name": "_check_budget_enforcement_exists",
            "signature": "(connection: Any, run_id: str) -> bool",
            "docstring": "Check if a budget_enforcement decision already exists for this run.\n\nIdempotency guard: prevents double emission on retry/restart.",
            "is_async": false,
            "line": 616
          },
          {
            "name": "emit_budget_enforcement_decision",
            "signature": "(connection: Any, run_id: str, budget_limit_cents: int, budget_consumed_cents: int, step_cost_cents: int, completed_steps: int, total_steps: int, tenant_id: str = 'default') -> Optional[DecisionRecord]",
            "docstring": "Emit a budget enforcement decision record when hard limit halts execution.\n\nPhase 5A: This is the ONLY decision type for hard budget halts.\nCalled immediately when execution is halted due to hard budget limit.\n\nIDEMPOTENT: If already emitted for this run_id, returns None.\n\nContract alignment:\n- decision_type: budget_enforcement\n- decision_source: system\n- decision_trigger: reactive\n- decision_outcome: execution_halted",
            "is_async": false,
            "line": 647
          },
          {
            "name": "_check_policy_precheck_exists",
            "signature": "(connection: Any, request_id: str, outcome: str) -> bool",
            "docstring": "Check if a policy_pre_check decision already exists for this request+outcome.\n\nIdempotency guard: prevents double emission on retry/restart.",
            "is_async": false,
            "line": 711
          },
          {
            "name": "emit_policy_precheck_decision",
            "signature": "(connection: Any, request_id: str, posture: str, passed: bool, service_available: bool, violations: Optional[list] = None, tenant_id: str = 'default') -> Optional[DecisionRecord]",
            "docstring": "Emit a policy pre-check decision record.\n\nPhase 5B: Pre-execution policy check.\n\nEMISSION RULE (FROZEN):\n  - EMIT IFF (posture == strict AND (failed OR unavailable))\n  - DO NOT EMIT if passed or posture == advisory\n\nContract alignment:\n- decision_type: policy_pre_check\n- decision_source: system\n- decision_trigger: explicit (pre-check is proactive)\n- causal_role: pre_run (always - run doesn't exist yet)\n- run_id: None (run not created on block)\n\nIDEMPOTENT: If already emitted for this request_id+outcome, returns None.",
            "is_async": false,
            "line": 744
          },
          {
            "name": "_check_recovery_evaluation_exists",
            "signature": "(connection: Any, run_id: str, failure_type: str) -> bool",
            "docstring": "Check if a recovery_evaluation decision already exists for this run+failure.\n\nIdempotency guard: prevents double emission on retry/restart.",
            "is_async": false,
            "line": 846
          },
          {
            "name": "emit_recovery_evaluation_decision",
            "signature": "(connection: Any, run_id: str, request_id: str, recovery_class: str, recovery_action: Optional[str], failure_type: str, failure_context: Optional[Dict[str, Any]] = None, tenant_id: str = 'default') -> Optional[DecisionRecord]",
            "docstring": "Emit a recovery evaluation decision record.\n\nPhase 5C: Post-failure recovery evaluation.\n\nEMISSION RULE (FROZEN per PIN-174):\n  - ALWAYS emit exactly one RECOVERY_EVALUATION decision after any:\n    - execution_halted\n    - execution_failed\n\n  Outcome mapping:\n    - R1 and applied \u2192 recovery_applied\n    - R2 and suggested \u2192 recovery_suggested\n    - R3 or no applicable recovery \u2192 recovery_skipped\n\nContract alignment:\n- decision_type: recovery_evaluation\n- decision_source: system\n- decision_trigger: reactive (recovery is always reactive to failure)\n- causal_role: post_run (always - recovery evaluates after failure)\n\nIDEMPOTENT: If already emitted for this run_id+failure_type, returns None.",
            "is_async": false,
            "line": 879
          },
          {
            "name": "backfill_run_id_for_request",
            "signature": "(connection: Any, request_id: str, run_id: str) -> int",
            "docstring": "Backfill run_id for all decisions with matching request_id.\n\nCalled from run creation to bind pre-run decisions (routing, policy, budget)\nto the newly created run. This is context enrichment, not mutation.\n\nReturns the number of records updated.",
            "is_async": false,
            "line": 973
          },
          {
            "name": "check_signal_access",
            "signature": "(signal_name: str) -> bool",
            "docstring": "Check if a signal is allowed for CARE optimization.\n\nPhase 5D: Hard guard on signal access.\n\nRaises:\n    CARESignalAccessError: If signal is forbidden\n\nReturns:\n    True if signal is allowed",
            "is_async": false,
            "line": 1068
          },
          {
            "name": "activate_care_kill_switch",
            "signature": "() -> bool",
            "docstring": "Activate the CARE optimization kill-switch.\n\nWhen activated:\n- Forces baseline selection\n- Prevents decision emission\n- Takes effect within 1 request cycle\n\nReturns:\n    True on successful activation",
            "is_async": false,
            "line": 1089
          },
          {
            "name": "deactivate_care_kill_switch",
            "signature": "() -> bool",
            "docstring": "Deactivate the CARE optimization kill-switch.\n\nReturns:\n    True on successful deactivation",
            "is_async": false,
            "line": 1107
          },
          {
            "name": "is_care_kill_switch_active",
            "signature": "() -> bool",
            "docstring": "Check if CARE kill-switch is currently active.",
            "is_async": false,
            "line": 1120
          },
          {
            "name": "_check_care_optimization_exists",
            "signature": "(connection: Any, request_id: str) -> bool",
            "docstring": "Check if a care_routing_optimized decision already exists for this request.\n\nIdempotency guard: prevents double emission.",
            "is_async": false,
            "line": 1125
          },
          {
            "name": "emit_care_optimization_decision",
            "signature": "(connection: Any, request_id: str, baseline_agent: str, optimized_agent: str, confidence_score: float, signals_used: list, optimization_enabled: bool = True, shadow_mode: bool = False, tenant_id: str = 'default') -> Optional[DecisionRecord]",
            "docstring": "Emit a CARE routing optimization decision record.\n\nPhase 5D: Optimization-driven routing decision.\n\nEMISSION RULE (FROZEN per PIN-176):\n  - EMIT CARE_ROUTING_OPTIMIZED decision IF AND ONLY IF:\n    - optimization_enabled = true\n    - AND NOT shadow_mode\n    - AND optimized_agent != baseline_agent\n\n  - DO NOT EMIT if:\n    - optimization_disabled\n    - shadow_mode (log only, no decision record)\n    - baseline == optimized (silence allowed)\n    - kill_switch active\n\nContract alignment:\n- decision_type: care_routing_optimized\n- decision_source: system\n- decision_trigger: autonomous (learning-driven)\n- causal_role: pre_run (always - before run exists)\n\nIDEMPOTENT: If already emitted for this request_id, returns None.",
            "is_async": false,
            "line": 1156
          }
        ],
        "classes": [
          {
            "name": "DecisionType",
            "docstring": "Types of decisions that must be recorded.",
            "methods": [],
            "line": 57
          },
          {
            "name": "DecisionSource",
            "docstring": "Who originated the decision authority.",
            "methods": [],
            "line": 71
          },
          {
            "name": "DecisionTrigger",
            "docstring": "Why the decision occurred.",
            "methods": [],
            "line": 79
          },
          {
            "name": "DecisionOutcome",
            "docstring": "Result of the decision.",
            "methods": [],
            "line": 87
          },
          {
            "name": "CausalRole",
            "docstring": "When in the lifecycle this decision occurred.",
            "methods": [],
            "line": 108
          },
          {
            "name": "DecisionRecord",
            "docstring": "Contract-aligned decision record.\n\nEvery decision (routing, recovery, memory, policy, budget) emits one of these.\nAppend-only. No business logic.",
            "methods": [
              "to_dict"
            ],
            "line": 121
          },
          {
            "name": "DecisionRecordService",
            "docstring": "Append-only sink for decision records.\n\nEmits to contracts.decision_records table.\nNon-blocking - failures are logged but don't affect callers.\n\nEvidence Architecture v1.0: Also bridges to governance.policy_decisions for taxonomy evidence.\n\nTransaction ownership: All methods accept a connection parameter.\nThe service NEVER creates engines, connections, or commits.\nL4 caller owns the transaction lifecycle.",
            "methods": [
              "__init__",
              "_bridge_to_taxonomy",
              "emit"
            ],
            "line": 184
          },
          {
            "name": "CARESignalAccessError",
            "docstring": "Raised when attempting to access a forbidden CARE signal.",
            "methods": [],
            "line": 1062
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "sqlalchemy.exc",
            "names": [
              "SQLAlchemyError"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [
          {
            "name": "CARE_ALLOWED_SIGNALS",
            "line": 1029
          },
          {
            "name": "CARE_FORBIDDEN_SIGNALS",
            "line": 1042
          },
          {
            "name": "CARE_CONFIDENCE_THRESHOLD",
            "line": 1059
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "governance_signal_driver.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/governance_signal_driver.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 293,
        "module_docstring": "Governance Signal Service (Phase E FIX-03)\n\nL6 service for persisting and querying governance signals.\n\nWrite Path (L7 \u2192 L6):\n- BLCA, CI, OPS write signals via record_signal()\n- Signals are persisted to governance_signals table\n- Previous signals for same scope/type are superseded\n\nRead Path (L4/L5 \u2190 L6):\n- Domain orchestrators check governance before decisions\n- Workers check governance before execution\n- Returns blocking/warning signals for scope\n\nContract:\n- All governance influence becomes visible data\n- No implicit pressure - only explicit signals\n- L4/L5 can query WHY they're blocked",
        "functions": [
          {
            "name": "check_governance_status",
            "signature": "(session: Session, scope: str, signal_type: Optional[str] = None) -> GovernanceCheckResult",
            "docstring": "Check governance status for a scope.",
            "is_async": false,
            "line": 255
          },
          {
            "name": "is_governance_blocked",
            "signature": "(session: Session, scope: str, signal_type: Optional[str] = None) -> bool",
            "docstring": "Quick check if scope is blocked.",
            "is_async": false,
            "line": 265
          },
          {
            "name": "record_governance_signal",
            "signature": "(session: Session, signal_type: str, scope: str, decision: str, recorded_by: str, reason: Optional[str] = None, constraints: Optional[dict] = None) -> GovernanceSignal",
            "docstring": "Record a governance signal.",
            "is_async": false,
            "line": 275
          }
        ],
        "classes": [
          {
            "name": "GovernanceSignalService",
            "docstring": "Service for governance signal operations.\n\nPhase E: Makes L7 \u2192 L4/L5 influence explicit and queryable.",
            "methods": [
              "__init__",
              "record_signal",
              "_supersede_existing_signals",
              "check_governance",
              "is_blocked",
              "get_active_signals",
              "clear_signal"
            ],
            "line": 55
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "or_",
              "select",
              "update"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy.orm",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.models.governance",
            "names": [
              "GovernanceCheckResult",
              "GovernanceSignal",
              "GovernanceSignalResponse"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard_cache.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/guard_cache.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 253,
        "module_docstring": "Redis-based cache for Guard Console endpoints.\n\nReduces database query latency by caching frequently-accessed data.\nCritical for cross-region deployments (EU server, Singapore DB).\n\nCache Keys:\n- guard:status:{tenant_id} - 5s TTL (real-time status)\n- guard:snapshot:{tenant_id} - 10s TTL (today's metrics)\n- guard:incidents:{tenant_id}:{limit}:{offset} - 5s TTL\n\nPerformance Target:\n- Reduce /guard/status from 4-7s to <100ms (cache hit)\n- Reduce /guard/snapshot/today from 2-6s to <100ms (cache hit)",
        "functions": [
          {
            "name": "get_guard_cache",
            "signature": "() -> GuardCache",
            "docstring": "Get guard cache singleton.",
            "is_async": false,
            "line": 248
          }
        ],
        "classes": [
          {
            "name": "GuardCache",
            "docstring": "Redis-based cache for Guard Console API.\n\nUsage:\n    cache = GuardCache()\n\n    # Check cache first\n    data = await cache.get_status(tenant_id)\n    if data is None:\n        data = fetch_from_db(...)\n        await cache.set_status(tenant_id, data)",
            "methods": [
              "__init__",
              "get_instance",
              "_get_redis",
              "_make_key",
              "get",
              "set",
              "invalidate",
              "get_status",
              "set_status",
              "get_snapshot",
              "set_snapshot",
              "get_incidents",
              "set_incidents",
              "invalidate_tenant"
            ],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.metrics_helpers",
            "names": [
              "get_or_create_counter",
              "get_or_create_histogram"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [
          {
            "name": "GUARD_CACHE_ENABLED",
            "line": 50
          },
          {
            "name": "GUARD_STATUS_TTL",
            "line": 51
          },
          {
            "name": "GUARD_SNAPSHOT_TTL",
            "line": 52
          },
          {
            "name": "GUARD_INCIDENTS_TTL",
            "line": 53
          },
          {
            "name": "GUARD_CACHE_PREFIX",
            "line": 54
          },
          {
            "name": "GUARD_CACHE_HITS",
            "line": 57
          },
          {
            "name": "GUARD_CACHE_MISSES",
            "line": 63
          },
          {
            "name": "GUARD_CACHE_LATENCY",
            "line": 69
          }
        ],
        "all_exports": [
          "GuardCache",
          "get_guard_cache",
          "GUARD_STATUS_TTL",
          "GUARD_SNAPSHOT_TTL",
          "GUARD_INCIDENTS_TTL"
        ]
      },
      {
        "file_name": "guard_write_driver.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/guard_write_driver.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 267,
        "module_docstring": "Guard Write Driver (L6)\n\nPure database write operations for Guard Console (KillSwitch, Incidents).\n\nL4 (GuardWriteService) \u2192 L6 (this driver)\n\nResponsibilities:\n- Get/create KillSwitchState records\n- Freeze/unfreeze killswitch\n- Acknowledge/resolve incidents\n- Create demo incidents with events\n- NO business logic (L4 responsibility)\n\nReference: PIN-250, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_guard_write_driver",
            "signature": "(session: Session) -> GuardWriteDriver",
            "docstring": "Factory function to get GuardWriteDriver instance.",
            "is_async": false,
            "line": 259
          }
        ],
        "classes": [
          {
            "name": "GuardWriteDriver",
            "docstring": "L6 driver for guard write operations.\n\nPure database access - no business logic.",
            "methods": [
              "__init__",
              "get_or_create_killswitch_state",
              "freeze_killswitch",
              "unfreeze_killswitch",
              "acknowledge_incident",
              "resolve_incident",
              "create_demo_incident"
            ],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "select"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentEvent",
              "IncidentSeverity",
              "IncidentStatus",
              "KillSwitchState",
              "TriggerType"
            ],
            "is_relative": false,
            "line": 55
          }
        ],
        "constants": [],
        "all_exports": [
          "GuardWriteDriver",
          "get_guard_write_driver"
        ]
      },
      {
        "file_name": "idempotency.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/idempotency.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 161,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_existing_run",
            "signature": "(idempotency_key: str, tenant_id: Optional[str] = None, agent_id: Optional[str] = None) -> Optional[Run]",
            "docstring": "Check if a run with this idempotency key already exists.\n\nArgs:\n    idempotency_key: The idempotency key to check\n    tenant_id: Optional tenant filter\n    agent_id: Optional agent filter\n\nReturns:\n    Existing Run if found, None otherwise",
            "is_async": false,
            "line": 52
          },
          {
            "name": "check_idempotency",
            "signature": "(idempotency_key: str, tenant_id: Optional[str] = None, agent_id: Optional[str] = None) -> IdempotencyResult",
            "docstring": "Check idempotency and return result with status.\n\nArgs:\n    idempotency_key: The idempotency key to check\n    tenant_id: Optional tenant filter\n    agent_id: Optional agent filter\n\nReturns:\n    IdempotencyResult indicating if key exists and its status",
            "is_async": false,
            "line": 86
          },
          {
            "name": "should_return_cached",
            "signature": "(result: IdempotencyResult) -> bool",
            "docstring": "Determine if we should return cached result.\n\nReturns True if:\n- Key exists and is not expired\n- Status is succeeded, failed, or in progress (queued/running)\n\nReturns False if:\n- Key doesn't exist\n- Key is expired",
            "is_async": false,
            "line": 146
          }
        ],
        "classes": [
          {
            "name": "IdempotencyResult",
            "docstring": "Result of idempotency check.",
            "methods": [],
            "line": 43
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.db",
            "names": [
              "Run",
              "engine"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [
          {
            "name": "IDEMPOTENCY_TTL_SECONDS",
            "line": 39
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "ledger.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/ledger.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 251,
        "module_docstring": "Discovery Ledger - signal recording helpers (pure driver).\n\nCore principle: Discovery Ledger records curiosity, not decisions.\n\nThis module provides:\n- emit_signal(): Record a discovery signal (aggregating duplicates)\n- get_signals(): Query discovery signals from the ledger\n- DiscoverySignal: Pydantic model for signal data\n\nSignals are aggregated: same (artifact, field, signal_type) updates seen_count.\nNothing in the system depends on this table - it's pure observation.\n\nTransaction ownership: L4 handler creates and commits the connection.\nThis driver only executes SQL on a caller-provided connection.",
        "functions": [
          {
            "name": "emit_signal",
            "signature": "(connection: Any, artifact: str, signal_type: str, evidence: dict[str, Any], detected_by: str, field: Optional[str] = None, confidence: Optional[float] = None, notes: Optional[str] = None, phase: Optional[str] = None, environment: Optional[str] = None) -> Optional[UUID]",
            "docstring": "Record a discovery signal to the ledger.\n\nSignals are aggregated: same (artifact, field, signal_type) updates seen_count.\nThis is non-blocking and safe to call frequently.\n\nArgs:\n    connection: SQLAlchemy Connection (caller owns lifecycle and commit)\n    artifact: Artifact name (e.g. \"prediction_events\")\n    signal_type: Signal type (e.g. \"high_operator_access\")\n    evidence: Evidence data as dict\n    detected_by: Subsystem name that detected the signal\n    field: Optional field name within the artifact\n    confidence: Optional confidence score 0.0-1.0\n    notes: Optional notes\n    phase: Current phase (defaults to env var or \"C\")\n    environment: Environment (defaults to env var or \"local\")\n\nReturns:\n    UUID of the signal record, or None if recording failed\n\nTransaction Semantics:\n    Driver does NOT commit. Caller (L4 handler) owns the transaction.",
            "is_async": false,
            "line": 66
          },
          {
            "name": "get_signals",
            "signature": "(connection: Any, artifact: Optional[str] = None, signal_type: Optional[str] = None, status: Optional[str] = None, limit: int = 100) -> list[dict]",
            "docstring": "Query discovery signals from the ledger.\n\nArgs:\n    connection: SQLAlchemy Connection (caller owns lifecycle)\n    artifact: Filter by artifact name\n    signal_type: Filter by signal type\n    status: Filter by status (observed/ignored/promoted)\n    limit: Max records to return\n\nReturns:\n    List of signal records as dicts",
            "is_async": false,
            "line": 175
          }
        ],
        "classes": [
          {
            "name": "DiscoverySignal",
            "docstring": "Discovery signal data model.",
            "methods": [],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "sqlalchemy.exc",
            "names": [
              "SQLAlchemyError"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "schema_parity.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/schema_parity.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 166,
        "module_docstring": "M26 Prevention Mechanism #2: Startup Schema Parity Guard\n=========================================================\n\nINVARIANT: SQLModel metadata must match live DB schema exactly.\nIf not \u2192 hard crash on boot.\n\nWhy hard-fail?\nBecause cost integrity errors are worse than downtime.",
        "functions": [
          {
            "name": "check_schema_parity",
            "signature": "(engine: Engine, models: Optional[List[type]] = None, hard_fail: bool = True) -> Tuple[bool, List[str]]",
            "docstring": "Check that SQLModel definitions match actual database schema.\n\nArgs:\n    engine: SQLAlchemy engine\n    models: List of SQLModel classes to check (default: all with __tablename__)\n    hard_fail: If True, raise exception on mismatch\n\nReturns:\n    Tuple of (is_valid, list of errors)",
            "is_async": false,
            "line": 49
          },
          {
            "name": "check_m26_cost_tables",
            "signature": "(engine: Engine) -> Tuple[bool, List[str]]",
            "docstring": "Specific check for M26 cost tables - the most critical.\n\nThese tables MUST match exactly:\n- feature_tags\n- cost_records\n- cost_anomalies\n- cost_budgets\n- cost_daily_aggregates",
            "is_async": false,
            "line": 117
          },
          {
            "name": "run_startup_parity_check",
            "signature": "(engine: Engine) -> None",
            "docstring": "Run full schema parity check on startup.\nCall this from main.py before accepting requests.",
            "is_async": false,
            "line": 143
          }
        ],
        "classes": [
          {
            "name": "SchemaParityError",
            "docstring": "Raised when model schema doesn't match database schema.",
            "methods": [],
            "line": 43
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "sqlalchemy",
            "names": [
              "inspect"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "sqlalchemy.engine",
            "names": [
              "Engine"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlmodel",
            "names": [
              "SQLModel"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "transaction_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/transaction_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 823,
        "module_docstring": "Transaction Coordinator for Cross-Domain Writes\n\nThis module provides atomic transaction coordination for run completion,\nensuring that ALL domain updates succeed or NONE persist.\n\nProblem Addressed (FIX-001):\n- Incident/policy/trace writes are independent\n- Partial failure causes inconsistent state\n- Events published before all operations complete\n\nSolution:\n- Wrap all domain operations in single transaction boundary\n- Track which operations succeeded for rollback\n- Publish events ONLY after successful commit\n\nArchitecture:\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502              Transaction Coordinator (L4)                        \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502  TRANSACTION FLOW:                                               \u2502\n    \u2502  1. Begin transaction                                            \u2502\n    \u2502  2. Create incident (via IncidentFacade)                         \u2502\n    \u2502  3. Create policy evaluation (via GovernanceFacade)              \u2502\n    \u2502  4. Complete trace (via TraceFacade)                             \u2502\n    \u2502  5. Commit transaction                                           \u2502\n    \u2502  6. Publish events (post-commit only)                            \u2502\n    \u2502                                                                  \u2502\n    \u2502  ON FAILURE:                                                     \u2502\n    \u2502  \u2022 Rollback transaction                                          \u2502\n    \u2502  \u2022 No events published                                           \u2502\n    \u2502  \u2022 Raise TransactionFailed with context                          \u2502\n    \u2502                                                                  \u2502\n    \u2502  INVARIANTS:                                                     \u2502\n    \u2502  \u2022 Events ONLY after successful commit                           \u2502\n    \u2502  \u2022 Partial state is never visible                                \u2502\n    \u2502  \u2022 All domain operations use facades (layer compliance)          \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nUsage:\n\n    from app.hoc.cus.hoc_spine.drivers.transaction_coordinator import (\n        RunCompletionTransaction,\n        get_transaction_coordinator,\n    )\n\n    coordinator = get_transaction_coordinator()\n    result = coordinator.execute(\n        run_id=run_id,\n        tenant_id=tenant_id,\n        run_status=\"succeeded\",\n        agent_id=agent_id,\n    )",
        "functions": [
          {
            "name": "get_transaction_coordinator",
            "signature": "() -> RunCompletionTransaction",
            "docstring": "Get the singleton transaction coordinator instance.\n\nReturns:\n    RunCompletionTransaction instance",
            "is_async": false,
            "line": 798
          },
          {
            "name": "create_transaction_coordinator",
            "signature": "(publisher = None) -> RunCompletionTransaction",
            "docstring": "Create a new transaction coordinator instance.\n\nUse this for testing or when you need a fresh instance.\n\nArgs:\n    publisher: Optional event publisher\n\nReturns:\n    RunCompletionTransaction instance",
            "is_async": false,
            "line": 811
          }
        ],
        "classes": [
          {
            "name": "TransactionPhase",
            "docstring": "Phases of transaction execution.",
            "methods": [],
            "line": 112
          },
          {
            "name": "TransactionFailed",
            "docstring": "Raised when cross-domain transaction fails.",
            "methods": [
              "__init__"
            ],
            "line": 125
          },
          {
            "name": "RollbackNotSupportedError",
            "docstring": "Raised when rollback is attempted but the target model does not support it.",
            "methods": [],
            "line": 141
          },
          {
            "name": "DomainResult",
            "docstring": "Result from a single domain operation.",
            "methods": [
              "to_dict"
            ],
            "line": 147
          },
          {
            "name": "TransactionResult",
            "docstring": "Result of a successful cross-domain transaction.",
            "methods": [
              "is_complete",
              "all_domains_succeeded",
              "to_dict"
            ],
            "line": 170
          },
          {
            "name": "RollbackAction",
            "docstring": "Describes a rollback action for a domain operation.",
            "methods": [],
            "line": 208
          },
          {
            "name": "RunCompletionTransaction",
            "docstring": "Atomic cross-domain transaction for run completion.\n\nEnsures either ALL domain updates succeed or NONE persist.\nEvents published ONLY after commit succeeds.\n\nLayer: L4 (Domain Logic)\nCallers: ROK (L5), RunRunner (L5)",
            "methods": [
              "__init__",
              "execute",
              "_create_incident",
              "_create_policy_evaluation",
              "_complete_trace",
              "_publish_events",
              "_execute_rollback",
              "_emit_rollback_ack",
              "_rollback_incident",
              "_rollback_policy"
            ],
            "line": 218
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 79
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 80
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 81
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 82
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 83
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 84
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 85
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 87
          },
          {
            "module": "app.db",
            "names": [
              "engine"
            ],
            "is_relative": false,
            "line": 89
          },
          {
            "module": "app.events",
            "names": [
              "get_publisher"
            ],
            "is_relative": false,
            "line": 90
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.rac_models",
            "names": [
              "AckStatus",
              "AuditAction",
              "AuditDomain",
              "DomainAck"
            ],
            "is_relative": false,
            "line": 93
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.audit_store",
            "names": [
              "get_audit_store"
            ],
            "is_relative": false,
            "line": 100
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.protocols",
            "names": [
              "TraceFacadePort"
            ],
            "is_relative": false,
            "line": 101
          }
        ],
        "constants": [
          {
            "name": "RAC_ROLLBACK_AUDIT_ENABLED",
            "line": 104
          },
          {
            "name": "TRANSACTION_COORDINATOR_ENABLED",
            "line": 109
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "worker_write_driver_async.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/drivers/worker_write_driver_async.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 222,
        "module_docstring": "Worker Write Service (Async) - DB write operations for Worker API.\n\nPhase 2B Batch 4: Extracted from api/workers.py.\n\nConstraints (enforced by PIN-250):\n- Write-only: No policy logic\n- No cross-service calls\n- No domain refactoring\n- Call-path relocation only\n- Preserve async semantics exactly",
        "functions": [],
        "classes": [
          {
            "name": "WorkerWriteServiceAsync",
            "docstring": "Async DB write operations for Worker API.\n\nWrite-only facade. No policy logic, no branching beyond DB operations.\nAll methods preserve existing async execution model.",
            "methods": [
              "__init__",
              "upsert_worker_run",
              "insert_cost_record",
              "insert_cost_advisory",
              "delete_worker_run",
              "get_worker_run"
            ],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.db",
            "names": [
              "CostAnomaly",
              "CostRecord"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "constraint_checker.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/constraint_checker.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 310,
        "module_docstring": "Module: constraint_checker\nPurpose: Enforce inspection constraints from MonitorConfig.\n\nInspection constraints are \"negative capabilities\" - they define what\na policy is NOT allowed to inspect or capture. Before any logging\noperation, the runner/worker must check these constraints.\n\nConstraint Fields (from MonitorConfig):\n    - allow_prompt_logging: Can prompts be logged?\n    - allow_response_logging: Can responses be logged?\n    - allow_pii_capture: Can PII be captured?\n    - allow_secret_access: Can secrets be accessed?\n\nExports:\n    - InspectionOperation: Enum of operations requiring checks\n    - InspectionConstraintViolation: Violation record\n    - InspectionConstraintChecker: Main enforcement class\n    - check_inspection_allowed: Quick helper function\n    - get_constraint_violations: Get all violations",
        "functions": [
          {
            "name": "check_inspection_allowed",
            "signature": "(operation: InspectionOperation, allow_prompt_logging: bool = False, allow_response_logging: bool = False, allow_pii_capture: bool = False, allow_secret_access: bool = False) -> bool",
            "docstring": "Quick helper to check if an operation is allowed.\n\nArgs:\n    operation: The operation to check\n    allow_prompt_logging: Whether prompts can be logged\n    allow_response_logging: Whether responses can be logged\n    allow_pii_capture: Whether PII can be captured\n    allow_secret_access: Whether secrets can be accessed\n\nReturns:\n    True if operation is allowed, False otherwise",
            "is_async": false,
            "line": 254
          },
          {
            "name": "get_constraint_violations",
            "signature": "(operations: list[InspectionOperation], allow_prompt_logging: bool = False, allow_response_logging: bool = False, allow_pii_capture: bool = False, allow_secret_access: bool = False) -> list[dict[str, Any]]",
            "docstring": "Get all constraint violations for a set of operations.\n\nArgs:\n    operations: List of operations to check\n    allow_prompt_logging: Whether prompts can be logged\n    allow_response_logging: Whether responses can be logged\n    allow_pii_capture: Whether PII can be captured\n    allow_secret_access: Whether secrets can be accessed\n\nReturns:\n    List of violation dicts (empty if all allowed)",
            "is_async": false,
            "line": 283
          }
        ],
        "classes": [
          {
            "name": "InspectionOperation",
            "docstring": "Operations that require inspection constraint checks.",
            "methods": [],
            "line": 47
          },
          {
            "name": "InspectionConstraintViolation",
            "docstring": "Record of an inspection constraint violation.\n\nCreated when an operation is attempted that violates\nthe MonitorConfig inspection constraints.",
            "methods": [
              "to_dict"
            ],
            "line": 66
          },
          {
            "name": "InspectionConstraintChecker",
            "docstring": "Enforces inspection constraints from MonitorConfig.\n\nThis class checks whether logging and data capture operations\nare allowed based on the MonitorConfig's inspection constraint\nsettings (negative capabilities).\n\nGAP-033: Wire MonitorConfig flags to runner.\n\nUsage:\n    checker = InspectionConstraintChecker(monitor_config)\n    if checker.is_allowed(InspectionOperation.LOG_PROMPT):\n        # Log the prompt\n    else:\n        # Skip logging, constraint forbids it",
            "methods": [
              "__init__",
              "from_monitor_config",
              "from_snapshot",
              "is_allowed",
              "check",
              "check_all",
              "get_allowed_operations",
              "get_denied_operations",
              "to_dict"
            ],
            "line": 89
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "anomaly_incident_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/anomaly_incident_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 182,
        "module_docstring": "Anomaly Incident Coordinator (PIN-510 Phase 1C)\n\nL4 coordinator that owns the cross-domain sequencing:\n  analytics (detect) \u2192 incidents (ingest)\n\nThis coordinator replaces the direct cross-domain imports in\ncost_anomaly_detector_engine.py (lines 976, 982, 1048).\n\nResponsibilities:\n- Call analytics detection (returns pure CostAnomalyFact list)\n- Pass facts to incidents bridge for incident creation\n- Return combined results\n\nRules:\n- No retry logic (L4 coordinators are pass-through)\n- No business logic (that belongs in L5 engines)\n- Cross-domain sequencing ONLY",
        "functions": [
          {
            "name": "get_anomaly_incident_coordinator",
            "signature": "() -> AnomalyIncidentCoordinator",
            "docstring": "Get the singleton AnomalyIncidentCoordinator instance.",
            "is_async": false,
            "line": 171
          }
        ],
        "classes": [
          {
            "name": "AnomalyIncidentCoordinator",
            "docstring": "L4 coordinator: analytics anomaly detection \u2192 incidents bridge.\n\nOwns the cross-domain sequencing that previously lived in\nrun_anomaly_detection_with_governance() (deprecated).",
            "methods": [
              "detect_and_ingest",
              "detect_only",
              "persist_coordination_audit"
            ],
            "line": 39
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": [
          "AnomalyIncidentCoordinator",
          "get_anomaly_incident_coordinator"
        ]
      },
      {
        "file_name": "account_bridge.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/bridges/account_bridge.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 70,
        "module_docstring": "Account Bridge (PIN-513)\n\nDomain-scoped capability accessor for account domain.",
        "functions": [
          {
            "name": "get_account_bridge",
            "signature": "() -> AccountBridge",
            "docstring": "Get the singleton AccountBridge instance.",
            "is_async": false,
            "line": 62
          }
        ],
        "classes": [
          {
            "name": "AccountBridge",
            "docstring": "Capabilities for account domain. Max 5 methods.",
            "methods": [
              "account_query_capability",
              "notifications_capability",
              "tenant_capability",
              "billing_provider_capability",
              "rbac_engine_capability"
            ],
            "line": 14
          }
        ],
        "imports": [],
        "constants": [],
        "all_exports": [
          "AccountBridge",
          "get_account_bridge"
        ]
      },
      {
        "file_name": "activity_bridge.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/bridges/activity_bridge.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 100,
        "module_docstring": "Activity Bridge (PIN-510)\n\nDomain-scoped capability accessor for activity domain.",
        "functions": [
          {
            "name": "get_activity_bridge",
            "signature": "() -> ActivityBridge",
            "docstring": "Get the singleton ActivityBridge instance.",
            "is_async": false,
            "line": 27
          },
          {
            "name": "get_activity_engine_bridge",
            "signature": "() -> ActivityEngineBridge",
            "docstring": "Get the singleton ActivityEngineBridge instance.",
            "is_async": false,
            "line": 87
          }
        ],
        "classes": [
          {
            "name": "ActivityBridge",
            "docstring": "Capabilities for activity domain. Max 5 methods.",
            "methods": [
              "activity_query_capability"
            ],
            "line": 14
          },
          {
            "name": "ActivityEngineBridge",
            "docstring": "Extended capabilities for activity domain coordinators. Max 5 methods.\n\nPIN-520: These capabilities are injected into L5 ActivityFacade so it\ndoesn't need to import L4 coordinators directly.",
            "methods": [
              "run_evidence_coordinator_capability",
              "run_proof_coordinator_capability",
              "signal_feedback_coordinator_capability"
            ],
            "line": 40
          }
        ],
        "imports": [],
        "constants": [],
        "all_exports": [
          "ActivityBridge",
          "get_activity_bridge",
          "ActivityEngineBridge",
          "get_activity_engine_bridge"
        ]
      },
      {
        "file_name": "analytics_bridge.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/bridges/analytics_bridge.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 221,
        "module_docstring": "Analytics Bridge (L4 Coordinator)\n\nDomain-specific capability factory for analytics L5 engines.\nReturns factory callables that handlers bind with session.\n\nBridge Contract:\n    - Max 5 methods per bridge\n    - Returns facades/engines (not sessions)\n    - Lazy imports from domain L5/L6\n    - No cross-domain imports at top level\n\nSwitchboard Pattern (Law 4 - PIN-507):\n    - Never accepts session parameters\n    - Returns factory callables\n    - Handler binds session (Law 4 responsibility)\n    - No retry logic, no decisions, no state\n\nUsage:\n    from app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges.analytics_bridge import (\n        get_analytics_bridge,\n    )\n\n    bridge = get_analytics_bridge()\n    config = bridge.config_capability()\n    result = await config.is_v2_disabled_by_drift()",
        "functions": [
          {
            "name": "get_analytics_bridge",
            "signature": "() -> AnalyticsBridge",
            "docstring": "Get the analytics bridge singleton.\n\nReturns the same instance for the lifetime of the process.",
            "is_async": false,
            "line": 139
          },
          {
            "name": "get_analytics_engine_bridge",
            "signature": "() -> AnalyticsEngineBridge",
            "docstring": "Get the singleton AnalyticsEngineBridge instance.",
            "is_async": false,
            "line": 208
          }
        ],
        "classes": [
          {
            "name": "AnalyticsBridge",
            "docstring": "Analytics domain capability factory.\n\nProvides lazy access to analytics L5 engines without importing them\nat module level. This preserves layer isolation and enables testing.",
            "methods": [
              "config_capability",
              "sandbox_capability",
              "canary_capability",
              "divergence_capability",
              "datasets_capability",
              "cost_write_capability"
            ],
            "line": 45
          },
          {
            "name": "AnalyticsEngineBridge",
            "docstring": "Extended capabilities for analytics domain coordinators. Max 5 methods.",
            "methods": [
              "anomaly_coordinator_capability",
              "detection_facade_capability",
              "alert_driver_capability",
              "alert_adapter_factory_capability"
            ],
            "line": 156
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "AnalyticsBridge",
          "get_analytics_bridge",
          "AnalyticsEngineBridge",
          "get_analytics_engine_bridge"
        ]
      },
      {
        "file_name": "api_keys_bridge.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/bridges/api_keys_bridge.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 40,
        "module_docstring": "API Keys Bridge (PIN-510)\n\nDomain-scoped capability accessor for api_keys domain.",
        "functions": [
          {
            "name": "get_api_keys_bridge",
            "signature": "() -> ApiKeysBridge",
            "docstring": "Get the singleton ApiKeysBridge instance.",
            "is_async": false,
            "line": 32
          }
        ],
        "classes": [
          {
            "name": "ApiKeysBridge",
            "docstring": "Capabilities for api_keys domain. Max 5 methods.",
            "methods": [
              "keys_read_capability",
              "keys_write_capability"
            ],
            "line": 14
          }
        ],
        "imports": [],
        "constants": [],
        "all_exports": [
          "ApiKeysBridge",
          "get_api_keys_bridge"
        ]
      },
      {
        "file_name": "controls_bridge.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/bridges/controls_bridge.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 63,
        "module_docstring": "Controls Bridge (PIN-510)\n\nDomain-scoped capability accessor for controls domain.\nReturns capability-satisfying objects bound to caller's session.",
        "functions": [
          {
            "name": "get_controls_bridge",
            "signature": "() -> ControlsBridge",
            "docstring": "Get the singleton ControlsBridge instance.",
            "is_async": false,
            "line": 55
          }
        ],
        "classes": [
          {
            "name": "ControlsBridge",
            "docstring": "Capabilities for controls domain. Max 5 methods.",
            "methods": [
              "limits_query_capability",
              "policy_limits_capability",
              "killswitch_capability",
              "limit_breaches_capability",
              "scoped_execution_capability"
            ],
            "line": 15
          }
        ],
        "imports": [],
        "constants": [],
        "all_exports": [
          "ControlsBridge",
          "get_controls_bridge"
        ]
      },
      {
        "file_name": "incidents_bridge.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/bridges/incidents_bridge.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 173,
        "module_docstring": "Incidents Bridge (PIN-510)\n\nDomain-scoped capability accessor for incidents domain.\nReturns capability-satisfying objects bound to caller's session.\n\nRules:\n- Max 5 capability methods (CI check 19)\n- Never accepts session in constructor\n- Lazy imports only\n- Only L4 handlers/coordinators may use this",
        "functions": [
          {
            "name": "get_incidents_bridge",
            "signature": "() -> IncidentsBridge",
            "docstring": "Get the singleton IncidentsBridge instance.",
            "is_async": false,
            "line": 59
          },
          {
            "name": "get_incident_driver",
            "signature": "(db_url = None)",
            "docstring": "Get the singleton IncidentDriver, wired with IncidentEngine via Protocol.\n\nPIN-511 Option B: L4 is the only layer that sees both L5 and L6.\nThis factory creates the L5 engine, injects it into the L6 driver\nvia IncidentDecisionPort, and returns the composed driver.\n\nArgs:\n    db_url: Optional database URL override\n\nReturns:\n    IncidentDriver instance (L6) backed by IncidentEngine (L5)",
            "is_async": false,
            "line": 74
          },
          {
            "name": "get_incidents_engine_bridge",
            "signature": "() -> IncidentsEngineBridge",
            "docstring": "Get the singleton IncidentsEngineBridge instance.",
            "is_async": false,
            "line": 158
          }
        ],
        "classes": [
          {
            "name": "IncidentsBridge",
            "docstring": "Capabilities for incidents domain. Max 5 methods.",
            "methods": [
              "incident_read_capability",
              "incident_write_capability",
              "lessons_capability",
              "export_capability",
              "incidents_for_run_capability"
            ],
            "line": 21
          },
          {
            "name": "IncidentsEngineBridge",
            "docstring": "Extended capabilities for incidents domain engines. Max 5 methods.",
            "methods": [
              "recovery_rule_engine_capability",
              "evidence_recorder_capability"
            ],
            "line": 128
          }
        ],
        "imports": [],
        "constants": [],
        "all_exports": [
          "IncidentsBridge",
          "get_incidents_bridge",
          "get_incident_driver",
          "get_incident_facade",
          "IncidentsEngineBridge",
          "get_incidents_engine_bridge"
        ]
      },
      {
        "file_name": "integrations_bridge.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/bridges/integrations_bridge.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 190,
        "module_docstring": "Integrations Bridge (L4 Coordinator)\n\nDomain-specific capability factory for integrations L5 engines.\nReturns module references for lazy access to integration capabilities.\n\nBridge Contract:\n    - Max 5 capability methods per bridge\n    - Returns modules (not sessions)\n    - Lazy imports from domain L5/L6\n    - No cross-domain imports at top level\n\nSwitchboard Pattern (Law 4 - PIN-507):\n    - Never accepts session parameters\n    - Returns module references\n    - Handler binds session (Law 4 responsibility)\n    - No retry logic, no decisions, no state\n\nUsage:\n    from app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges.integrations_bridge import (\n        get_integrations_bridge,\n    )\n\n    bridge = get_integrations_bridge()\n    mcp = bridge.mcp_capability()\n    result = await mcp.invoke_tool(session, tool_name, params)",
        "functions": [
          {
            "name": "get_integrations_bridge",
            "signature": "() -> IntegrationsBridge",
            "docstring": "Get the integrations bridge singleton.\n\nReturns the same instance for the lifetime of the process.",
            "is_async": false,
            "line": 118
          },
          {
            "name": "get_integrations_driver_bridge",
            "signature": "() -> IntegrationsDriverBridge",
            "docstring": "Get the singleton IntegrationsDriverBridge instance.",
            "is_async": false,
            "line": 177
          }
        ],
        "classes": [
          {
            "name": "IntegrationsBridge",
            "docstring": "Integrations domain capability factory.\n\nProvides lazy access to integrations L5 engines without importing them\nat module level. This preserves layer isolation and enables testing.",
            "methods": [
              "mcp_capability",
              "connector_capability",
              "health_capability",
              "datasources_capability",
              "credentials_capability"
            ],
            "line": 45
          },
          {
            "name": "IntegrationsDriverBridge",
            "docstring": "Extended capabilities for integrations L6 drivers. Max 5 methods.",
            "methods": [
              "worker_registry_capability",
              "worker_registry_exceptions",
              "incident_creator_capability"
            ],
            "line": 135
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "IntegrationsBridge",
          "get_integrations_bridge",
          "IntegrationsDriverBridge",
          "get_integrations_driver_bridge"
        ]
      },
      {
        "file_name": "logs_bridge.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/bridges/logs_bridge.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 91,
        "module_docstring": "Logs Bridge (PIN-510)\n\nDomain-scoped capability accessor for logs domain.",
        "functions": [
          {
            "name": "get_logs_bridge",
            "signature": "() -> LogsBridge",
            "docstring": "Get the singleton LogsBridge instance.",
            "is_async": false,
            "line": 83
          }
        ],
        "classes": [
          {
            "name": "LogsBridge",
            "docstring": "Capabilities for logs domain. Max 5 methods.",
            "methods": [
              "logs_read_service",
              "traces_store_capability",
              "audit_ledger_read_capability",
              "capture_driver_capability",
              "cost_intelligence_capability"
            ],
            "line": 14
          }
        ],
        "imports": [],
        "constants": [],
        "all_exports": [
          "LogsBridge",
          "get_logs_bridge"
        ]
      },
      {
        "file_name": "overview_bridge.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/bridges/overview_bridge.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 105,
        "module_docstring": "Overview Bridge (L4 Coordinator)\n\nDomain-specific capability factory for overview L5 engines.\nReturns module references for lazy access to overview capabilities.\n\nBridge Contract:\n    - Max 5 capability methods per bridge\n    - Returns modules (not sessions)\n    - Lazy imports from domain L5/L6\n    - No cross-domain imports at top level\n\nSwitchboard Pattern (Law 4 - PIN-507):\n    - Never accepts session parameters\n    - Returns module references\n    - Handler binds session (Law 4 responsibility)\n    - No retry logic, no decisions, no state\n\nNote:\n    Overview is a minimal domain (dashboard aggregation point).\n    It has a single facade that aggregates data from other domains\n    via hoc_spine coordinators.\n\nUsage:\n    from app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges.overview_bridge import (\n        get_overview_bridge,\n    )\n\n    bridge = get_overview_bridge()\n    facade = bridge.overview_capability()\n    highlights = await facade.get_highlights(session, tenant_id)",
        "functions": [
          {
            "name": "get_overview_bridge",
            "signature": "() -> OverviewBridge",
            "docstring": "Get the overview bridge singleton.\n\nReturns the same instance for the lifetime of the process.",
            "is_async": false,
            "line": 90
          }
        ],
        "classes": [
          {
            "name": "OverviewBridge",
            "docstring": "Overview domain capability factory.\n\nProvides lazy access to overview L5 engines without importing them\nat module level. This preserves layer isolation and enables testing.\n\nNote: Overview is a minimal domain with primarily a single facade.",
            "methods": [
              "overview_capability",
              "dashboard_capability"
            ],
            "line": 50
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": [
          "OverviewBridge",
          "get_overview_bridge"
        ]
      },
      {
        "file_name": "policies_bridge.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/bridges/policies_bridge.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 180,
        "module_docstring": "Policies Bridge (PIN-510)\n\nDomain-scoped capability accessor for policies domain.",
        "functions": [
          {
            "name": "get_policies_engine_bridge",
            "signature": "() -> PoliciesEngineBridge",
            "docstring": "Get the singleton PoliciesEngineBridge instance.",
            "is_async": false,
            "line": 155
          },
          {
            "name": "get_policies_bridge",
            "signature": "() -> PoliciesBridge",
            "docstring": "Get the singleton PoliciesBridge instance.",
            "is_async": false,
            "line": 167
          }
        ],
        "classes": [
          {
            "name": "PoliciesBridge",
            "docstring": "Capabilities for policies domain. Max 5 methods.",
            "methods": [
              "customer_policy_read_capability",
              "policy_evaluations_capability",
              "recovery_write_capability",
              "recovery_matcher_capability",
              "recovery_read_capability"
            ],
            "line": 16
          },
          {
            "name": "PoliciesEngineBridge",
            "docstring": "Extended capabilities for policies domain engines. Max 5 methods.",
            "methods": [
              "prevention_hook_capability",
              "policy_engine_capability",
              "policy_engine_class_capability",
              "governance_runtime_capability",
              "governance_config_capability",
              "sandbox_engine_capability",
              "policy_engine_write_context"
            ],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "contextlib",
            "names": [
              "contextmanager"
            ],
            "is_relative": false,
            "line": 13
          }
        ],
        "constants": [],
        "all_exports": [
          "PoliciesBridge",
          "get_policies_bridge",
          "PoliciesEngineBridge",
          "get_policies_engine_bridge"
        ]
      },
      {
        "file_name": "canary_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/canary_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 72,
        "module_docstring": "Canary Coordinator (PIN-513 Batch 3A1 Wiring)\n\nL4 coordinator that owns scheduled canary validation runs.\n\nWires from analytics/L5_engines/canary_engine.py:\n- run_canary(sample_count, drift_threshold, session)\n\nFlow:\n  Scheduler / Cron\n    \u2192 CanaryCoordinator.run(...)\n        \u2192 canary_engine.run_canary(..., session)\n        \u2192 L4 commits (transaction boundary owner)\n\nTransaction Ownership (PIN-520):\n  L4 coordinator creates session and owns commit/rollback.\n  L5 engine and L6 driver do NOT commit.",
        "functions": [],
        "classes": [
          {
            "name": "CanaryCoordinator",
            "docstring": "L4 coordinator: canary validation scheduling and execution.\n\nSystem-level safety mechanism \u2014 no API surface.\nTransaction boundary owner for canary DB operations.",
            "methods": [
              "run"
            ],
            "line": 36
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "domain_bridge.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/domain_bridge.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 110,
        "module_docstring": "Domain Bridge (C4 \u2014 Loop Model)\n\nCross-domain service accessor. Switchboard, not brain.\nReturns factory callables \u2014 handler binds session (Law 4, PIN-507).\n\nRules:\n- No retry logic\n- No decisions\n- No state\n- No session parameters (Law 4)\n- Only L4 handlers and coordinators may use this\n\nAbsorbs logs_coordinator.py (PIN-504).",
        "functions": [
          {
            "name": "get_domain_bridge",
            "signature": "() -> DomainBridge",
            "docstring": "Get the singleton DomainBridge instance.",
            "is_async": false,
            "line": 99
          }
        ],
        "classes": [
          {
            "name": "DomainBridge",
            "docstring": "Cross-domain service accessor \u2014 backward-compat facade.\n\nPIN-510 Phase 0A: Delegates to per-domain bridges.\nNew code should import per-domain bridges directly:\n    from app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges import get_incidents_bridge\n\nThis class remains for existing callers. No new methods should be added here.\n\nLaw 4 (PIN-507): DomainBridge never accepts session.\nIt returns factory callables; the handler owns binding.",
            "methods": [
              "logs_read_service",
              "lessons_driver_factory",
              "limits_read_driver_factory",
              "policy_limits_driver_factory",
              "lessons_capability",
              "limits_query_capability",
              "policy_limits_capability"
            ],
            "line": 31
          }
        ],
        "imports": [],
        "constants": [],
        "all_exports": [
          "DomainBridge",
          "get_domain_bridge"
        ]
      },
      {
        "file_name": "evidence_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/evidence_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 222,
        "module_docstring": "Evidence Coordinator (PIN-513 Batch 3B1 Wiring)\n\nL4 coordinator that owns evidence capture operations.\n\nWires from logs/L6_drivers/capture_driver.py:\n- capture_environment_evidence(session, ctx, ...)\n- capture_activity_evidence(session, ctx, ...)\n- capture_provider_evidence(session, ctx, ...)\n- capture_policy_decision_evidence(session, ctx, ...)\n- capture_integrity_evidence(session, run_id, ...)\n- compute_integrity(run_id)\n- hash_prompt(prompt)",
        "functions": [],
        "classes": [
          {
            "name": "EvidenceCoordinator",
            "docstring": "L4 coordinator: evidence capture orchestration.\n\nAll evidence capture flows route through this coordinator.",
            "methods": [
              "capture_environment",
              "capture_activity",
              "capture_provider",
              "capture_policy_decision",
              "capture_integrity",
              "compute_integrity",
              "hash_prompt"
            ],
            "line": 32
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "execution_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/execution_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 263,
        "module_docstring": "Execution Coordinator (PIN-513 Wiring)\n\nL4 coordinator that owns pre-execution scoping and job lifecycle services.\n\nBinds two L6 drivers:\n- ScopedExecutionDriver: pre-execution risk gates, scope creation/enforcement\n- JobExecutionDriver: retry strategies, progress tracking, audit trail\n\nResponsibilities:\n- Create bound scopes for MEDIUM+ risk recovery actions\n- Enforce scope gates before execution proceeds\n- Manage retry decisions (should_retry, calculate_delay)\n- Track job progress (stages, ETA)\n- Emit tamper-evident audit chain\n\nRules:\n- No business logic (L5 engines decide WHAT; this coordinates HOW)\n- No session.commit() \u2014 transaction ownership stays at L4 boundary\n- Cross-domain sequencing ONLY",
        "functions": [],
        "classes": [
          {
            "name": "ExecutionCoordinator",
            "docstring": "L4 coordinator: pre-execution scoping + job lifecycle.\n\nPairs ScopedExecutionDriver (risk gates) with JobExecutionDriver\n(retry, progress, audit) to provide complete execution lifecycle\nmanagement for L4 handlers and job_executor.",
            "methods": [
              "create_scope",
              "execute_with_scope",
              "should_retry",
              "track_progress",
              "emit_audit_created",
              "emit_audit_completed",
              "emit_audit_failed"
            ],
            "line": 39
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "leadership_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/leadership_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 123,
        "module_docstring": "Leadership Coordinator (PIN-513 Batch 3A6 Wiring)\n\nL4 coordinator that owns distributed locking primitives.\nNo business logic imports this directly.\n\nWires from analytics/L6_drivers/leader_driver.py:\n- try_acquire_leader_lock(session, lock_id)\n- release_leader_lock(session, lock_id)\n- is_lock_held(session, lock_id)\n- leader_election(lock_id, timeout_seconds)\n- with_leader_lock(lock_id, callback, *args, timeout_seconds, **kwargs)\n- with_canary_lock(callback, *args, **kwargs)\n- with_alert_worker_lock(callback, *args, **kwargs)\n- with_archiver_lock(callback, *args, **kwargs)",
        "functions": [],
        "classes": [
          {
            "name": "LeadershipCoordinator",
            "docstring": "L4 coordinator: distributed locking primitives.\n\nSchedulers and background jobs use this coordinator\nto acquire advisory locks before executing.",
            "methods": [
              "try_acquire",
              "release",
              "is_held",
              "with_lock",
              "with_canary_lock",
              "with_alert_worker_lock",
              "with_archiver_lock"
            ],
            "line": 34
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lessons_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/lessons_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 92,
        "module_docstring": "Lessons Coordinator (C4 \u2014 Loop Model)\n\nProvides cross-domain evidence recording without domain-specific nouns.\nReplaces direct incidents\u2192policies L5 import.\n\nPattern:\n    L4 handler \u2192 LessonsCoordinator.record_evidence() \u2192 policies L5 engine",
        "functions": [
          {
            "name": "get_lessons_coordinator",
            "signature": "() -> LessonsCoordinator",
            "docstring": "Get the singleton LessonsCoordinator instance.",
            "is_async": false,
            "line": 81
          }
        ],
        "classes": [
          {
            "name": "LessonsCoordinator",
            "docstring": "Cross-domain evidence recorder.\n\nMediates between incident detection (incidents domain) and\nlearning subsystem (policies domain) without either domain\nimporting the other directly.\n\nRules:\n- No retry logic\n- No decisions\n- No state\n- Neutral naming only (no domain nouns)",
            "methods": [
              "record_evidence"
            ],
            "line": 25
          }
        ],
        "imports": [],
        "constants": [],
        "all_exports": [
          "LessonsCoordinator",
          "get_lessons_coordinator"
        ]
      },
      {
        "file_name": "provenance_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/provenance_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 176,
        "module_docstring": "Provenance Coordinator (PIN-513 Batch 3A5 Wiring)\n\nL4 coordinator that owns provenance DB operations.\n\nWires from analytics/L6_drivers/provenance_driver.py:\n- write_provenance(...)\n- write_provenance_batch(records, session)\n- query_provenance(...)\n- count_provenance(...)\n- get_drift_stats(start_date, end_date)\n- check_duplicate(input_hash)\n- compute_input_hash(payload)\n- backfill_v1_baseline(records, batch_size)",
        "functions": [],
        "classes": [
          {
            "name": "ProvenanceCoordinator",
            "docstring": "L4 coordinator: provenance logging DB operations.",
            "methods": [
              "write",
              "write_batch",
              "query",
              "count",
              "get_drift_stats",
              "check_duplicate",
              "compute_input_hash",
              "backfill_v1_baseline"
            ],
            "line": 34
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "replay_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/replay_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 130,
        "module_docstring": "Replay Coordinator (PIN-513 Wiring)\n\nL4 coordinator that owns deterministic replay enforcement.\n\nBinds ReplayDriver (L6) to provide:\n- Step-level replay behavior enforcement (EXECUTE / SKIP / CHECK)\n- Idempotency verification via SHA256 output hashing\n- Trace-level replay orchestration\n\nFlow:\n  Step execution\n    \u2192 ReplayCoordinator.enforce_step(...)\n        \u2192 ReplayEnforcer.enforce_step(step, execute_fn, tenant_id)\n        \u2192 ReplayResult (executed/skipped/checked)\n\nRules:\n- Coordinator decides WHEN to enforce replay (scheduling authority)\n- Driver decides HOW to enforce (idempotency mechanics)\n- No business logic \u2014 pure replay semantics",
        "functions": [],
        "classes": [
          {
            "name": "ReplayCoordinator",
            "docstring": "L4 coordinator: deterministic replay enforcement.\n\nOwns the replay lifecycle \u2014 no L5 engine or L2 route may\ncall ReplayDriver directly.",
            "methods": [
              "__init__",
              "_get_enforcer",
              "enforce_step",
              "enforce_trace"
            ],
            "line": 39
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Awaitable",
              "Callable",
              "Dict"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "run_evidence_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/run_evidence_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 239,
        "module_docstring": "Run Evidence Coordinator (PIN-519)\n\nL4 coordinator that composes cross-domain impact for a run.\n\nAggregates:\n- Incidents caused by the run\n- Policies evaluated during the run\n- Limits breached by the run\n- Decisions made during the run",
        "functions": [
          {
            "name": "get_run_evidence_coordinator",
            "signature": "() -> RunEvidenceCoordinator",
            "docstring": "Get the singleton RunEvidenceCoordinator instance.",
            "is_async": false,
            "line": 228
          }
        ],
        "classes": [
          {
            "name": "RunEvidenceCoordinator",
            "docstring": "L4 coordinator: Compose run impact from multiple domains.\n\nAggregates evidence from incidents, policies, and controls domains\nto provide a complete picture of a run's cross-domain impact.",
            "methods": [
              "get_run_evidence",
              "_get_incidents_for_run",
              "_get_policy_evaluations_for_run",
              "_get_limit_breaches_for_run",
              "_derive_decisions"
            ],
            "line": 38
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.run_introspection_protocols",
            "names": [
              "DecisionSummary",
              "IncidentSummary",
              "LimitHitSummary",
              "PolicyEvaluationSummary",
              "RunEvidenceResult"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": [
          "RunEvidenceCoordinator",
          "get_run_evidence_coordinator"
        ]
      },
      {
        "file_name": "run_proof_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/run_proof_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 255,
        "module_docstring": "Run Proof Coordinator (PIN-519)\n\nL4 coordinator that verifies run integrity via traces.\n\nSupports integrity models:\n- HASH_CHAIN (Phase 1): Sequential hash of trace steps\n- MERKLE_TREE (future): Merkle tree of trace evidence",
        "functions": [
          {
            "name": "get_run_proof_coordinator",
            "signature": "() -> RunProofCoordinator",
            "docstring": "Get the singleton RunProofCoordinator instance.",
            "is_async": false,
            "line": 244
          }
        ],
        "classes": [
          {
            "name": "RunProofCoordinator",
            "docstring": "L4 coordinator: Verify run integrity via traces.\n\nFetches traces and computes integrity verification based on\nthe configured integrity model (HASH_CHAIN by default).",
            "methods": [
              "get_run_proof",
              "_compute_integrity",
              "_compute_hash_chain"
            ],
            "line": 37
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.run_introspection_protocols",
            "names": [
              "INTEGRITY_CONFIG",
              "IntegrityVerificationResult",
              "RunProofResult",
              "TraceStepSummary",
              "TraceSummary"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": [
          "RunProofCoordinator",
          "get_run_proof_coordinator"
        ]
      },
      {
        "file_name": "signal_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/signal_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 112,
        "module_docstring": "Signal Coordinator (C4 \u2014 Loop Model)\n\nContext-free cross-domain mediator for threshold signal dispatch.\nOwns TOPOLOGY only \u2014 controls\u2192activity emission order.\nSession binding happens in emit_and_persist_threshold_signal (L4 entry point),\nnever inside the coordinator itself.\n\nLaw 4 (PIN-507): Coordinators must NEVER accept session or execution context.",
        "functions": [
          {
            "name": "get_signal_coordinator",
            "signature": "() -> SignalCoordinator",
            "docstring": "Get the signal coordinator singleton.",
            "is_async": false,
            "line": 58
          },
          {
            "name": "emit_and_persist_threshold_signal",
            "signature": "(session: Any, tenant_id: str, run_id: str, state: str, signals: list, params_used: dict) -> None",
            "docstring": "L4 orchestration \u2014 binds session to callables, delegates to coordinator.\n\nThis is the ONLY place where session meets cross-domain topology.\nSession binding happens here; coordinator never sees it.\n\nArgs:\n    session: SQLAlchemy sync session\n    tenant_id: Tenant identifier\n    run_id: Run identifier\n    state: Run state (\"live\" or \"completed\")\n    signals: List of ThresholdSignal values\n    params_used: The threshold params that were evaluated against",
            "is_async": false,
            "line": 71
          }
        ],
        "classes": [
          {
            "name": "SignalCoordinator",
            "docstring": "Context-free cross-domain signal dispatch coordinator.\n\nOwns topology only: emit first (controls), then update risk (activity).\nNever receives session or execution context.",
            "methods": [
              "emit_and_update_risk"
            ],
            "line": 31
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "signal_feedback_coordinator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/signal_feedback_coordinator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 137,
        "module_docstring": "Signal Feedback Coordinator (PIN-519)\n\nL4 coordinator that queries signal feedback from audit ledger.\n\nProvides feedback status for signals:\n- Acknowledged: Signal was reviewed by a user\n- Suppressed: Signal is temporarily hidden\n- Escalated: Signal was escalated to higher priority",
        "functions": [
          {
            "name": "get_signal_feedback_coordinator",
            "signature": "() -> SignalFeedbackCoordinator",
            "docstring": "Get the singleton SignalFeedbackCoordinator instance.",
            "is_async": false,
            "line": 126
          }
        ],
        "classes": [
          {
            "name": "SignalFeedbackCoordinator",
            "docstring": "L4 coordinator: Query signal feedback from audit ledger.\n\nProvides feedback status for signals by querying the audit ledger\nfor SIGNAL_ACKNOWLEDGED, SIGNAL_SUPPRESSED, and SIGNAL_ESCALATED events.",
            "methods": [
              "get_signal_feedback",
              "_parse_datetime"
            ],
            "line": 33
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.run_introspection_protocols",
            "names": [
              "SignalFeedbackResult"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": [
          "SignalFeedbackCoordinator",
          "get_signal_feedback_coordinator"
        ]
      },
      {
        "file_name": "snapshot_scheduler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/coordinators/snapshot_scheduler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 95,
        "module_docstring": "Snapshot Scheduler (PIN-513 Batch 4 Final Wiring)\n\nL4 coordinator that owns multi-tenant scheduled snapshot batch execution.\nNever called via handler or API \u2014 only via cron/scheduler.\n\nWires from analytics/L5_engines/cost_snapshots_engine.py:\n- run_hourly_snapshot_job(driver, tenant_ids)\n- run_daily_snapshot_and_baseline_job(driver, tenant_ids)\n\nFlow:\n  Cron / systemd timer\n    \u2192 SnapshotScheduler.run_hourly(driver, tenant_ids)\n        \u2192 cost_snapshots_engine.run_hourly_snapshot_job(...)\n    \u2192 SnapshotScheduler.run_daily(driver, tenant_ids)\n        \u2192 cost_snapshots_engine.run_daily_snapshot_and_baseline_job(...)",
        "functions": [],
        "classes": [
          {
            "name": "SnapshotScheduler",
            "docstring": "L4 coordinator: scheduled snapshot batch execution.\n\nEntry points for cron/systemd timers only.\nNot API-driven. System authority.",
            "methods": [
              "run_hourly",
              "run_daily"
            ],
            "line": 35
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List"
            ],
            "is_relative": false,
            "line": 30
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "job_executor.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/execution/job_executor.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 837,
        "module_docstring": "Part-2 Job Executor (L5)\n\nExecutes governance job steps in order and emits evidence.\n\nThis is a MACHINE that performs declared steps. It does not:\n- Decide what to execute (that's Contract + Orchestrator)\n- Retry failures (failed = done)\n- Interpret results (that's Audit)\n- Modify health (that's PlatformHealthService)\n\nThe Executor is \"just physics\" - it runs the plan and records what happened.\n\nInvariants:\n- EXEC-001: Execute steps in declared order\n- EXEC-002: Emit evidence per step\n- EXEC-003: Stop on first failure\n- EXEC-004: Health is observed, never modified\n- EXEC-005: No eligibility or contract mutation\n- EXEC-006: No retry logic\n\nClasses:\n- JobExecutor: Base executor (synchronous, no coordinator)\n- CoordinatedJobExecutor: Extended executor with ExecutionCoordinator integration\n  - execute_job_with_audit(): Job execution with audit trail\n  - execute_scoped_job(): Job execution within P2FC-4 scope\n  - get_retry_advice(): Advisory retry decisions (caller decides)\n  - track_job_progress(): Progress tracking during execution\n\nReference: PIN-294, PIN-292, PIN-520, PART2_CRM_WORKFLOW_CHARTER.md",
        "functions": [
          {
            "name": "create_default_executor",
            "signature": "() -> JobExecutor",
            "docstring": "Create a JobExecutor with default handlers.\n\nDefault handlers are no-ops for testing.\nProduction handlers should be registered separately.",
            "is_async": false,
            "line": 467
          },
          {
            "name": "create_coordinated_executor",
            "signature": "() -> CoordinatedJobExecutor",
            "docstring": "Create a CoordinatedJobExecutor with default handlers.\n\nIncludes ExecutionCoordinator integration for:\n- Scoped execution\n- Audit trail\n- Progress tracking\n- Retry advice\n\nReference: PIN-520 Wiring Audit",
            "is_async": false,
            "line": 770
          },
          {
            "name": "execution_result_to_evidence",
            "signature": "(result: ExecutionResult) -> dict[str, Any]",
            "docstring": "Convert ExecutionResult to audit evidence format.\n\nThis is what gets passed to the Audit Trigger.",
            "is_async": false,
            "line": 801
          }
        ],
        "classes": [
          {
            "name": "HealthObserver",
            "docstring": "Protocol for observing health state (read-only).\n\nJOB EXECUTOR RULE: Health is OBSERVED, not MODIFIED.",
            "methods": [
              "observe_health"
            ],
            "line": 88
          },
          {
            "name": "StepHandler",
            "docstring": "Protocol for step type handlers.\n\nEach step type (capability_enable, capability_disable, etc.)\nhas a handler that performs the actual operation.",
            "methods": [
              "execute"
            ],
            "line": 108
          },
          {
            "name": "StepOutput",
            "docstring": "Output from executing a single step.\n\nThis is the raw output from the step handler,\nbefore it becomes a StepResult.",
            "methods": [],
            "line": 140
          },
          {
            "name": "ExecutionContext",
            "docstring": "Context passed to step handlers during execution.\n\nContains information the handler needs without\ngiving it authority to change governance state.",
            "methods": [],
            "line": 154
          },
          {
            "name": "ExecutionResult",
            "docstring": "Result of executing a job.\n\nContains the final status and all step results.",
            "methods": [],
            "line": 172
          },
          {
            "name": "JobExecutor",
            "docstring": "Part-2 Job Executor (L5)\n\nExecutes governance job steps in order and emits evidence.\n\nKey Properties (PIN-294):\n- Consumes job plans only\n- No eligibility, no approval, no contract mutation\n- Emits evidence per step\n- Stops on failure\n- Health is observed, never modified\n\nUsage:\n    executor = JobExecutor()\n    result = executor.execute_job(job_state, health_observer)",
            "methods": [
              "__init__",
              "version",
              "register_handler",
              "execute_job",
              "_execute_step"
            ],
            "line": 197
          },
          {
            "name": "NoOpHandler",
            "docstring": "No-op handler for testing.\n\nAlways succeeds without doing anything.",
            "methods": [
              "execute"
            ],
            "line": 423
          },
          {
            "name": "FailingHandler",
            "docstring": "Failing handler for testing.\n\nAlways fails with a configurable error.",
            "methods": [
              "__init__",
              "execute"
            ],
            "line": 443
          },
          {
            "name": "CoordinatedJobExecutor",
            "docstring": "JobExecutor with ExecutionCoordinator integration.\n\nAdds optional coordinator capabilities:\n- Scoped execution with P2FC-4 risk gates\n- Progress tracking during execution\n- Audit trail emission (created/completed/failed)\n\nINVARIANT: Still respects EXEC-006 (no automatic retry).\nCoordinator.should_retry() is advisory only - caller decides.\n\nUsage:\n    executor = create_coordinated_executor()\n    result = await executor.execute_job_with_audit(\n        job_id=job_id,\n        tenant_id=tenant_id,\n        contract_id=contract_id,\n        steps=steps,\n        handler=\"recovery_worker\",\n    )\n\nReference: PIN-520 Wiring Audit",
            "methods": [
              "__init__",
              "_get_coordinator",
              "execute_job_with_audit",
              "execute_scoped_job",
              "get_retry_advice",
              "track_job_progress"
            ],
            "line": 493
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional",
              "Protocol"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "app.models.governance_job",
            "names": [
              "JobStatus",
              "JobStep",
              "StepResult",
              "StepStatus"
            ],
            "is_relative": false,
            "line": 72
          }
        ],
        "constants": [
          {
            "name": "EXECUTOR_VERSION",
            "line": 80
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "governance_orchestrator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/governance_orchestrator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 829,
        "module_docstring": "Part-2 Governance Orchestrator (L4)\n\nOrchestrates the governance workflow from contract activation through\naudit triggering. This is the \"traffic controller\" - it directs flow\nbut does not execute.\n\nComponents:\n1. Contract Activation Service - APPROVED \u2192 ACTIVE\n2. Execution Orchestrator - contract \u2192 job plan\n3. Job State Tracker - observes job states\n4. Audit Trigger - hands evidence to audit layer\n\nKey Constraints (PIN-292):\n- Orchestrates only; does not execute jobs\n- No health or audit authority\n- Contract is the sole source of execution intent\n- MAY_NOT remains mechanically un-overridable\n\nReference: PART2_CRM_WORKFLOW_CHARTER.md, PIN-292, part2-design-v1",
        "functions": [
          {
            "name": "get_audit_service",
            "signature": "()",
            "docstring": "Return singleton AuditService (L8) implementation.\n\nLives in account-owned CRM audit namespace. Wired here so audit is reachable\nfrom the execution authority (hoc_spine).",
            "is_async": false,
            "line": 96
          }
        ],
        "classes": [
          {
            "name": "HealthLookup",
            "docstring": "Protocol for capturing health state (read-only).",
            "methods": [
              "capture_health_snapshot"
            ],
            "line": 115
          },
          {
            "name": "JobState",
            "docstring": "In-memory representation of job state.\n\nUsed for state tracking before persistence.",
            "methods": [],
            "line": 129
          },
          {
            "name": "JobStateMachine",
            "docstring": "State machine for Governance Job lifecycle.\n\nEnforces:\n- JOB-002: Job steps execute in order\n- JOB-003: Terminal states are immutable",
            "methods": [
              "can_transition",
              "validate_transition",
              "transition"
            ],
            "line": 160
          },
          {
            "name": "ExecutionOrchestrator",
            "docstring": "Translates contract \u2192 job plan.\n\nThis is purely a planning service. It does NOT execute.\n\nResponsibilities:\n1. Parse contract proposed_changes into JobSteps\n2. Validate step ordering\n3. Calculate timeouts\n\nReference: PART2_CRM_WORKFLOW_CHARTER.md Step 7",
            "methods": [
              "create_job_plan",
              "_parse_change_to_step"
            ],
            "line": 280
          },
          {
            "name": "JobStateTracker",
            "docstring": "Observes job state - does NOT control execution.\n\nThis is purely an observation service.\n\nResponsibilities:\n1. Track job state transitions\n2. Record step results\n3. Capture evidence for audit\n\nKey constraint: This service READS state, it doesn't DRIVE execution.\nThe actual execution is done by L5 Job Executor.",
            "methods": [
              "record_step_result",
              "calculate_completion_status"
            ],
            "line": 362
          },
          {
            "name": "AuditEvidence",
            "docstring": "Evidence package for audit layer.\n\nThis is what we hand to the auditor (L8).",
            "methods": [],
            "line": 451
          },
          {
            "name": "AuditTrigger",
            "docstring": "Prepares and hands evidence to audit layer.\n\nThis service does NOT make audit decisions.\nIt packages evidence and signals that audit should occur.\n\nThe actual audit logic is in the Audit Service (L8).",
            "methods": [
              "prepare_evidence",
              "should_trigger_audit"
            ],
            "line": 469
          },
          {
            "name": "ContractActivationError",
            "docstring": "Raised when contract activation fails.",
            "methods": [
              "__init__"
            ],
            "line": 523
          },
          {
            "name": "ContractActivationService",
            "docstring": "Activates approved contracts (APPROVED \u2192 ACTIVE).\n\nThis is the bridge between the contract state machine and job creation.\n\nResponsibilities:\n1. Verify contract is APPROVED\n2. Create job plan from contract\n3. Create job record\n4. Transition contract to ACTIVE\n\nKey constraint: Activation creates a job but does NOT execute it.",
            "methods": [
              "__init__",
              "activate_contract"
            ],
            "line": 532
          },
          {
            "name": "GovernanceOrchestrator",
            "docstring": "Facade for all governance orchestration services.\n\nThis is the main entry point for governance workflow orchestration.\nIt combines:\n- Contract Activation Service\n- Execution Orchestrator\n- Job State Tracker\n- Audit Trigger\n\nKey Properties (PIN-292):\n- Orchestrates only; does not execute jobs\n- No health or audit authority\n- Contract is the sole source of execution intent\n\nReference: PART2_CRM_WORKFLOW_CHARTER.md, PIN-292",
            "methods": [
              "__init__",
              "version",
              "activate_contract",
              "start_job",
              "record_step_result",
              "complete_job",
              "cancel_job",
              "should_trigger_audit",
              "prepare_audit_evidence",
              "is_job_terminal",
              "can_start_job",
              "get_job_progress"
            ],
            "line": 651
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional",
              "Protocol"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "uuid",
            "names": [
              "UUID",
              "uuid4"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "app.models.contract",
            "names": [
              "ContractStatus"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.models.governance_job",
            "names": [
              "JOB_TERMINAL_STATES",
              "JOB_VALID_TRANSITIONS",
              "HealthSnapshot",
              "InvalidJobTransitionError",
              "JobImmutableError",
              "JobStatus",
              "JobStep",
              "JobTransitionRecord",
              "StepResult",
              "StepStatus"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "app.hoc.cus.hoc_spine.authority.contracts.contract_engine",
            "names": [
              "ContractService",
              "ContractState"
            ],
            "is_relative": false,
            "line": 82
          }
        ],
        "constants": [
          {
            "name": "ORCHESTRATOR_VERSION",
            "line": 85
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "account_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/account_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 290,
        "module_docstring": "Account Handler (L4 Orchestrator)\n\nRoutes account domain operations to L5 facades.\nRegisters two operations:\n  - account.query \u2192 AccountsFacade\n  - account.notifications \u2192 NotificationsFacade",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register account operations with the registry.",
            "is_async": false,
            "line": 282
          }
        ],
        "classes": [
          {
            "name": "AccountQueryHandler",
            "docstring": "Handler for account.query operations.\n\nDispatches to AccountsFacade methods (list_projects, get_project_detail,\nlist_users, get_user_detail, get_profile, get_billing_summary, etc.).",
            "methods": [
              "execute"
            ],
            "line": 30
          },
          {
            "name": "AccountNotificationsHandler",
            "docstring": "Handler for account.notifications operations.\n\nDispatches to NotificationsFacade methods (send_notification,\nlist_notifications, get_notification, mark_as_read, etc.).",
            "methods": [
              "execute"
            ],
            "line": 68
          },
          {
            "name": "AccountBillingProviderHandler",
            "docstring": "Handler for account.billing.provider operations.\n\nPIN-520 Phase 1: Routes billing provider access through L4 registry.\nDispatches to billing_provider_engine (get_billing_provider).\n\nMethods:\n  - get_provider: Get billing provider for tenant\n  - get_state: Get billing state for tenant\n  - get_plan: Get current plan for tenant\n  - get_limits: Get limits for tenant",
            "methods": [
              "execute"
            ],
            "line": 106
          },
          {
            "name": "AccountMemoryPinsHandler",
            "docstring": "Handler for account.memory_pins operations.\n\nDispatches to MemoryPinsEngine methods (upsert_pin, get_pin,\nlist_pins, delete_pin, cleanup_expired).",
            "methods": [
              "execute"
            ],
            "line": 163
          },
          {
            "name": "AccountTenantHandler",
            "docstring": "Handler for account.tenant operations.\n\nPIN-520 ITER3.5: Routes tenant read operations to TenantEngine (L5).\nDispatches to TenantEngine methods (get_tenant, get_usage_summary,\ncheck_run_quota, check_token_quota, list_runs).\n\nSync session pattern: TenantEngine is sync, so L2 passes the sync\nsession via params[\"sync_session\"] (ctx.session is for async only).",
            "methods": [
              "execute"
            ],
            "line": 223
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 23
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "activity_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/activity_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 322,
        "module_docstring": "Activity Handler (L4 Orchestrator)\n\nRoutes activity domain operations to L5 engines and hoc_spine drivers.\nRegisters five operations:\n  - activity.query \u2192 ActivityFacade (15+ async methods)\n  - activity.signal_fingerprint \u2192 signal_identity (pure computation)\n  - activity.signal_feedback \u2192 SignalFeedbackService (feedback operations)\n  - activity.telemetry \u2192 CusTelemetryEngine (telemetry ingestion/query)\n  - activity.discovery \u2192 Discovery Ledger (emit_signal, get_signals) \u2014 PIN-520",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register activity domain handlers.",
            "is_async": false,
            "line": 314
          }
        ],
        "classes": [
          {
            "name": "ActivityQueryHandler",
            "docstring": "Handler for activity.query operations.\n\nDispatches to ActivityFacade methods (get_run_detail, get_patterns,\nget_cost_analysis, get_attention_queue, acknowledge_signal,\nsuppress_signal, etc.).\n\nFacade methods require session as first kwarg.",
            "methods": [
              "execute"
            ],
            "line": 33
          },
          {
            "name": "ActivitySignalFingerprintHandler",
            "docstring": "Handler for activity.signal_fingerprint operations.\n\nWraps pure computation from signal_identity module.\nMethods:\n  - compute_from_row \u2192 compute_signal_fingerprint_from_row(row)",
            "methods": [
              "execute"
            ],
            "line": 85
          },
          {
            "name": "ActivitySignalFeedbackHandler",
            "docstring": "Handler for activity.signal_feedback operations.\n\nWraps SignalFeedbackService methods:\n  - get_bulk_feedback \u2192 get_bulk_signal_feedback(tenant_id, signal_ids)",
            "methods": [
              "execute"
            ],
            "line": 128
          },
          {
            "name": "ActivityTelemetryHandler",
            "docstring": "Handler for activity.telemetry operations.\n\nWraps CusTelemetryEngine methods:\n  - ingest_usage, ingest_batch, get_usage_summary,\n    get_usage_history, get_daily_aggregates",
            "methods": [
              "execute"
            ],
            "line": 161
          },
          {
            "name": "ActivityDiscoveryHandler",
            "docstring": "Handler for activity.discovery operations.\n\nWraps discovery ledger functions (PIN-520):\n  - emit_signal \u2192 Record a discovery signal (aggregating duplicates)\n  - get_signals \u2192 Query discovery signals from the ledger\n\nDiscovery Ledger records curiosity, not decisions. Signals are\naggregated: same (artifact, field, signal_type) updates seen_count.\n\nL4 handler owns transaction boundaries \u2014 creates connection, passes\nto driver, commits writes.",
            "methods": [
              "execute"
            ],
            "line": 203
          },
          {
            "name": "ActivityOrphanRecoveryHandler",
            "docstring": "Handler for activity.orphan_recovery operations.\n\nPIN-520 Phase 1: Routes orphan recovery through L4 registry.\nDispatches to orphan_recovery_driver (recover_orphaned_runs).\n\nMethods:\n  - recover: Detect and mark runs orphaned due to system crash",
            "methods": [
              "execute"
            ],
            "line": 284
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "agent_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/agent_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 946,
        "module_docstring": "Agent Handler (L4 Orchestrator)\n\nRoutes agent domain operations to L6 drivers and agent services.\nRegisters operations:\n  - agent.discovery_stats \u2192 DiscoveryStatsDriver\n  - agent.routing \u2192 RoutingDriver (get_stats, get_decision)\n  - agent.strategy \u2192 RoutingDriver (update_sba)\n  - agents.job \u2192 job_service + worker_service + credit_service (ITER3.7)\n  - agents.blackboard \u2192 blackboard_service (ITER3.7)\n  - agents.instance \u2192 registry_service (ITER3.7)\n  - agents.message \u2192 message_service (ITER3.7)\n  - agents.activity \u2192 cross-service activity queries (ITER3.7)",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register agent operations with the registry.",
            "is_async": false,
            "line": 936
          }
        ],
        "classes": [
          {
            "name": "AgentDiscoveryStatsHandler",
            "docstring": "Handler for agent.discovery_stats operations.\n\nDispatches to DiscoveryStatsDriver.get_stats() method.\nNote: Uses sync session \u2014 driver is synchronous.",
            "methods": [
              "execute"
            ],
            "line": 36
          },
          {
            "name": "AgentRoutingHandler",
            "docstring": "Handler for agent.routing operations.\n\nDispatches to RoutingDriver methods:\n- get_stats: Aggregate routing stats\n- get_decision: Single routing decision",
            "methods": [
              "execute"
            ],
            "line": 66
          },
          {
            "name": "AgentStrategyHandler",
            "docstring": "Handler for agent.strategy operations.\n\nDispatches to RoutingDriver methods:\n- update_sba: Update agent SBA",
            "methods": [
              "execute"
            ],
            "line": 115
          },
          {
            "name": "AgentJobHandler",
            "docstring": "Handler for agents.job operations.\n\nWraps job_service, worker_service, and credit_service for job lifecycle.\nMethods: simulate, create, get, cancel, claim_item, complete_item, fail_item",
            "methods": [
              "execute",
              "_simulate",
              "_create",
              "_get",
              "_cancel",
              "_claim_item",
              "_complete_item",
              "_fail_item"
            ],
            "line": 161
          },
          {
            "name": "AgentBlackboardHandler",
            "docstring": "Handler for agents.blackboard operations.\n\nWraps blackboard_service for shared-state operations.\nMethods: get, set, increment, lock",
            "methods": [
              "execute"
            ],
            "line": 410
          },
          {
            "name": "AgentInstanceHandler",
            "docstring": "Handler for agents.instance operations.\n\nWraps registry_service for agent instance lifecycle.\nMethods: register, heartbeat, deregister, get, list",
            "methods": [
              "execute"
            ],
            "line": 474
          },
          {
            "name": "AgentMessageHandler",
            "docstring": "Handler for agents.message operations.\n\nWraps message_service for inter-agent messaging.\nMethods: send, get_inbox, mark_read",
            "methods": [
              "execute"
            ],
            "line": 566
          },
          {
            "name": "AgentActivityHandler",
            "docstring": "Handler for agents.activity operations.\n\nCross-service aggregation for agent activity views.\nMethods: costs, spending, retries, blockers",
            "methods": [
              "execute",
              "_costs",
              "_spending",
              "_retries",
              "_blockers"
            ],
            "line": 639
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "analytics_config_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/analytics_config_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 62,
        "module_docstring": "Analytics Config Handler (PIN-513 Batch 3A2 Wiring)\n\nL4 handler \u2014 single choke-point for CostSim configuration visibility.\n\nWires from analytics/L5_engines/config_engine.py:\n- get_config()\n- is_v2_sandbox_enabled()\n- is_v2_disabled_by_drift()\n- get_commit_sha()",
        "functions": [],
        "classes": [
          {
            "name": "AnalyticsConfigHandler",
            "docstring": "L4 handler: CostSim configuration read logic.\n\nSingle choke-point for config visibility.\nNo direct L5 imports outside L4.",
            "methods": [
              "get_config",
              "is_v2_sandbox_enabled",
              "is_v2_disabled_by_drift",
              "get_commit_sha"
            ],
            "line": 29
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "analytics_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/analytics_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 478,
        "module_docstring": "Analytics Handler (L4 Orchestrator)\n\nRoutes analytics domain operations to L5 facades and coordinators.\nRegisters four operations:\n  - analytics.query \u2192 AnalyticsFacade\n  - analytics.detection \u2192 DetectionFacade\n  - analytics.canary_reports \u2192 CanaryReportDriver (L6 queries)\n  - analytics.canary \u2192 CanaryCoordinator (scheduled validation runs)",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register analytics operations with the registry.",
            "is_async": false,
            "line": 467
          }
        ],
        "classes": [
          {
            "name": "FeedbackReadHandler",
            "docstring": "Handler for analytics.feedback operations.\n\nDispatches to FeedbackReadEngine methods (list_feedback,\nget_feedback, get_feedback_stats).\n\nPB-S3 Pattern: READ-ONLY operations only.",
            "methods": [
              "execute"
            ],
            "line": 32
          },
          {
            "name": "AnalyticsQueryHandler",
            "docstring": "Handler for analytics.query operations.\n\nDispatches to AnalyticsFacade methods (get_usage_statistics,\nget_cost_statistics, get_status).",
            "methods": [
              "execute"
            ],
            "line": 96
          },
          {
            "name": "AnalyticsDetectionHandler",
            "docstring": "Handler for analytics.detection operations.\n\nDispatches to DetectionFacade methods (run_detection, list_anomalies,\nget_anomaly, resolve_anomaly, acknowledge_anomaly, get_detection_status).",
            "methods": [
              "execute"
            ],
            "line": 133
          },
          {
            "name": "CanaryReportHandler",
            "docstring": "Handler for analytics.canary_reports operations.\n\nRoutes canary report queries through L4 to L6.\nEnsures policy/audit hooks can be added later.",
            "methods": [
              "execute"
            ],
            "line": 173
          },
          {
            "name": "CanaryRunHandler",
            "docstring": "Handler for analytics.canary operations.\n\nDispatches to CanaryCoordinator for scheduled canary validation runs.\nThis is the L4 entry point for scheduler/cron invocations.\n\nMethods:\n  - run: Execute canary validation (sample_count, drift_threshold)\n\nReference: PIN-520 Wiring Audit",
            "methods": [
              "execute"
            ],
            "line": 218
          },
          {
            "name": "CostsimStatusHandler",
            "docstring": "Handler for analytics.costsim.status operations.\n\nReturns V2 sandbox status including feature flags, circuit breaker state,\nmodel version, and drift thresholds.\n\nPIN-520 Phase 3: Migrates costsim.py /v2/status endpoint to L4.",
            "methods": [
              "execute"
            ],
            "line": 255
          },
          {
            "name": "CostsimSimulateHandler",
            "docstring": "Handler for analytics.costsim.simulate operations.\n\nRuns V2 simulation through sandbox. Always runs V1 for production results,\noptionally runs V2 in shadow mode for comparison.\n\nPIN-520 Phase 3: Migrates costsim.py /v2/simulate endpoint to L4.",
            "methods": [
              "execute"
            ],
            "line": 289
          },
          {
            "name": "CostsimDivergenceHandler",
            "docstring": "Handler for analytics.costsim.divergence operations.\n\nGenerates cost divergence report between V1 and V2.\n\nPIN-520 Phase 3: Migrates costsim.py /divergence endpoint to L4.",
            "methods": [
              "execute"
            ],
            "line": 332
          },
          {
            "name": "CostsimDatasetsHandler",
            "docstring": "Handler for analytics.costsim.datasets operations.\n\nProvides dataset validation capabilities:\n  - list: List all reference datasets\n  - info: Get dataset info by ID\n  - validate: Validate against specific dataset\n  - validate_all: Validate against all datasets\n\nPIN-520 Phase 3: Migrates costsim.py /datasets/* endpoints to L4.",
            "methods": [
              "execute"
            ],
            "line": 378
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 25
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "analytics_metrics_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/analytics_metrics_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 40,
        "module_docstring": "Analytics Metrics Handler (PIN-513 Batch 3A4 Wiring)\n\nL4 handler for CostSim metrics and alert rules.\n\nWires from analytics/L5_engines/metrics_engine.py:\n- get_metrics()\n- get_alert_rules()",
        "functions": [],
        "classes": [
          {
            "name": "AnalyticsMetricsHandler",
            "docstring": "L4 handler: CostSim metrics and alert rules.",
            "methods": [
              "get_metrics",
              "get_alert_rules"
            ],
            "line": 27
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 22
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "analytics_prediction_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/analytics_prediction_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 239,
        "module_docstring": "Analytics Prediction Handler (L4 Orchestrator)\n\nRoutes prediction operations to PredictionEngine and PredictionReadEngine (L5).\nPredictions are read-only advisory outputs \u2014 no execution side effects.\n\nOperations:\n  - analytics.prediction \u2192 PredictionEngine (generate, summary, cycle)\n  - analytics.prediction_read \u2192 PredictionReadEngine (list, get, for_subject, stats)\n\nNote: predict_failure_likelihood and predict_cost_overrun require a\nPredictionDriver (L6) instance. run_prediction_cycle and get_prediction_summary\nreceive their session from the L4 handler (PIN-520 Phase 4).",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register analytics prediction operations with the OperationRegistry.",
            "is_async": false,
            "line": 231
          }
        ],
        "classes": [
          {
            "name": "AnalyticsPredictionHandler",
            "docstring": "Handler for analytics.prediction operations.\n\nDispatches to PredictionEngine (L5) methods.\nAll predictions are advisory \u2014 zero execution impact.",
            "methods": [
              "execute",
              "_predict_failure",
              "_predict_cost_overrun",
              "_run_cycle",
              "_get_summary"
            ],
            "line": 41
          },
          {
            "name": "AnalyticsPredictionReadHandler",
            "docstring": "Handler for analytics.prediction_read operations.\n\nDispatches to PredictionReadEngine (L5) methods.\nPure read operations - no side effects.",
            "methods": [
              "execute",
              "_list_predictions",
              "_get_prediction",
              "_get_for_subject",
              "_get_stats"
            ],
            "line": 119
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "analytics_sandbox_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/analytics_sandbox_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 67,
        "module_docstring": "Analytics Sandbox Handler (PIN-513 Batch 3A5 Wiring)\n\nL4 handler for controlled CostSim sandbox experimentation.\n\nWires from analytics/L5_engines/sandbox_engine.py:\n- simulate_with_sandbox(plan, budget_cents, allowed_skills, tenant_id, run_id)\n- get_sandbox(budget_cents, tenant_id)",
        "functions": [],
        "classes": [
          {
            "name": "AnalyticsSandboxHandler",
            "docstring": "L4 handler: CostSim sandbox experimentation.",
            "methods": [
              "simulate",
              "get_sandbox"
            ],
            "line": 27
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 22
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "analytics_snapshot_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/analytics_snapshot_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 142,
        "module_docstring": "Analytics Snapshot Handler (L4 Orchestrator)\n\nOwns the scheduled lifecycle for cost snapshot computation.\nRoutes to CostSnapshotsEngine (L5) via driver protocol injection.\n\nResponsibilities:\n- Owns schedule trigger authority (no L5 engine may self-trigger)\n- Iterates tenants\n- Injects CostSnapshotsDriverProtocol\n- Calls engine entrypoints: hourly snapshots, daily baselines\n\nFlow:\n  Cron / Scheduler\n    \u2192 AnalyticsSnapshotHandler.run_hourly()\n        \u2192 CostSnapshotsEngine.compute_hourly_snapshot(driver)\n    \u2192 AnalyticsSnapshotHandler.run_daily()\n        \u2192 CostSnapshotsEngine.compute_daily_snapshot(driver)\n        \u2192 CostSnapshotsEngine.compute_baselines(driver)",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register analytics.snapshot operation with the OperationRegistry.",
            "is_async": false,
            "line": 139
          }
        ],
        "classes": [
          {
            "name": "AnalyticsSnapshotHandler",
            "docstring": "Handler for analytics.snapshot operations.\n\nDispatches scheduled snapshot computation to CostSnapshotsEngine (L5).\nThe engine is pure business logic; the driver is injected by this handler.",
            "methods": [
              "execute",
              "_run_hourly",
              "_run_daily",
              "_evaluate_anomalies"
            ],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "analytics_validation_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/analytics_validation_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 91,
        "module_docstring": "Analytics Validation Handler (PIN-513 Batch 3A3 Wiring)\n\nL4 handler for dataset validation and divergence reporting.\n\nWires from analytics/L5_engines/datasets_engine.py:\n- get_dataset_validator()\n- validate_dataset(dataset_id)\n- validate_all_datasets()\n\nWires from analytics/L5_engines/divergence_engine.py:\n- generate_divergence_report(start_date, end_date, tenant_id)",
        "functions": [],
        "classes": [
          {
            "name": "AnalyticsValidationHandler",
            "docstring": "L4 handler: dataset validation and divergence reporting.",
            "methods": [
              "get_validator",
              "validate_dataset",
              "validate_all",
              "generate_divergence_report"
            ],
            "line": 32
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "api_keys_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/api_keys_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 143,
        "module_docstring": "API Keys Handler (L4 Orchestrator)\n\nRoutes api_keys domain operations to the L5 ApiKeysFacade.\nRegistered as \"api_keys.query\" in the OperationRegistry.",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register api_keys operations with the registry.",
            "is_async": false,
            "line": 139
          }
        ],
        "classes": [
          {
            "name": "ApiKeysQueryHandler",
            "docstring": "Handler for api_keys.query operations.\n\nDispatches to ApiKeysFacade methods (list_api_keys, get_api_key_detail).",
            "methods": [
              "execute"
            ],
            "line": 28
          },
          {
            "name": "ApiKeysWriteHandler",
            "docstring": "Handler for api_keys.write operations.\n\nPIN-520 ITER3.5: Routes API key write operations to TenantEngine (L5).\nDispatches to TenantEngine methods (create_api_key, revoke_api_key,\nlist_api_keys).\n\nL4 owns transaction boundary: commits after write methods.\nSync session pattern: TenantEngine is sync, so L2 passes the sync\nsession via params[\"sync_session\"].",
            "methods": [
              "execute"
            ],
            "line": 63
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 21
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "circuit_breaker_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/circuit_breaker_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 291,
        "module_docstring": "Circuit Breaker Handler (PIN-513 Batch 2A Wiring)\n\nL4 handler that owns ALL circuit breaker operations. Single authority\nfor the CostSim V2 control plane.\n\nWires:\n  From controls/L5_engines/cb_sync_wrapper_engine.py:\n    - get_state_sync(timeout)\n    - is_v2_disabled_sync(timeout)\n    - shutdown_executor()\n\n  From controls/L6_drivers/circuit_breaker_async_driver.py:\n    - get_async_circuit_breaker()\n    - get_state()\n    - is_v2_disabled(session)\n    - disable_v2(reason, disabled_by, disabled_until)\n    - enable_v2(enabled_by, reason)\n    - report_drift(drift_score, sample_count, details)\n    - report_schema_error(error_count, details)\n    - get_incidents(include_resolved, limit)\n\n  From controls/L6_drivers/circuit_breaker_driver.py:\n    - create_circuit_breaker(session, ...)\n    - disable_v2(session, ...)\n    - enable_v2(session, ...)\n    - is_v2_disabled(session)\n\nFlow:\n  Admin API / CostSim orchestrator / drift detector\n    \u2192 CircuitBreakerHandler.<method>()\n        \u2192 L5/L6 driver call",
        "functions": [],
        "classes": [
          {
            "name": "CircuitBreakerHandler",
            "docstring": "L4 handler: circuit breaker control plane.\n\nSingle authority for all CostSim V2 circuit breaker operations.\nNo L2 or L5 may call drivers directly.",
            "methods": [
              "get_state",
              "is_v2_disabled",
              "disable_v2",
              "enable_v2",
              "report_drift",
              "report_schema_error",
              "get_incidents",
              "get_singleton",
              "get_state_sync",
              "is_v2_disabled_sync",
              "shutdown",
              "create_breaker",
              "disable_v2_sync",
              "enable_v2_sync",
              "is_v2_disabled_with_session"
            ],
            "line": 52
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "controls_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/controls_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 521,
        "module_docstring": "Controls Handler (L4 Orchestrator)\n\nRoutes controls domain operations to L5 engines and L6 drivers.\nRegisters operations:\n  - controls.query \u2192 ControlsFacade (6 async endpoints)\n  - controls.thresholds \u2192 ThresholdEngine (constants + validation, 2 endpoints)\n  - controls.overrides \u2192 LimitOverrideService\n  - controls.circuit_breaker \u2192 CircuitBreakerAsyncDriver\n  - controls.killswitch.read \u2192 KillswitchOpsDriver (entity verification, state queries)\n  - controls.killswitch.write \u2192 GuardWriteDriver (freeze/unfreeze)",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register controls operations with the registry.",
            "is_async": false,
            "line": 512
          }
        ],
        "classes": [
          {
            "name": "ControlsQueryHandler",
            "docstring": "Handler for controls.query operations.\n\nDispatches to ControlsFacade methods (list_controls, get_status,\nget_control, update_control, enable_control, disable_control).",
            "methods": [
              "execute"
            ],
            "line": 34
          },
          {
            "name": "ControlsThresholdHandler",
            "docstring": "Handler for controls.thresholds operations.\n\nProvides threshold engine constants and validation:\n  - get_defaults \u2192 returns DEFAULT_LLM_RUN_PARAMS\n  - validate_params \u2192 validates ThresholdParams",
            "methods": [
              "execute"
            ],
            "line": 72
          },
          {
            "name": "ControlsOverrideHandler",
            "docstring": "Handler for controls.overrides operations.\n\nRoutes to LimitOverrideService (PIN-504: L2 must not import L6 directly).\nMethods: request_override, list_overrides, get_override, cancel_override.",
            "methods": [
              "execute"
            ],
            "line": 121
          },
          {
            "name": "CircuitBreakerHandler",
            "docstring": "Handler for controls.circuit_breaker operations.\n\nRoutes circuit breaker operations for CostSim V2 sandbox:\n  - is_disabled: Check if circuit breaker is open\n  - get_state: Get full circuit breaker state\n  - reset: Reset circuit breaker (re-enable V2)\n  - get_incidents: Get recent incidents\n\nPIN-520 Phase 3: Migrates costsim.py circuit breaker access to L4.",
            "methods": [
              "execute"
            ],
            "line": 176
          },
          {
            "name": "KillswitchReadHandler",
            "docstring": "Handler for controls.killswitch.read operations.\n\nRoutes killswitch read operations to KillswitchOpsDriver (L6):\n  - verify_tenant: Check if tenant exists\n  - verify_api_key: Check if API key exists\n  - get_state: Get killswitch state for entity\n  - get_key_states: Get all key states for tenant\n  - list_guardrails: Get active guardrails\n  - list_incidents: List incidents for tenant\n  - get_incident: Get incident detail\n  - get_incident_events: Get timeline events\n  - get_proxy_call: Get proxy call for replay/detail\n\nEliminates session.execute() from L2 v1_killswitch.py.",
            "methods": [
              "execute"
            ],
            "line": 249
          },
          {
            "name": "KillswitchWriteHandler",
            "docstring": "Handler for controls.killswitch.write operations.\n\nRoutes killswitch write operations to GuardWriteDriver (hoc_spine L6):\n  - freeze: Freeze an entity (tenant or key)\n  - unfreeze: Unfreeze an entity\n  - get_or_create_state: Get or create killswitch state\n\nUses existing GuardWriteDriver from hoc_spine.",
            "methods": [
              "execute"
            ],
            "line": 369
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "governance_audit_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/governance_audit_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 117,
        "module_docstring": "Governance Audit Handler (Part-2 CRM)\n\nCreates an explicit L4-owned execution call path to the (L8) governance audit\nengine: evidence in \u2192 verdict out.\n\nThis handler does not decide outcomes; it only runs the auditor.",
        "functions": [
          {
            "name": "_parse_uuid",
            "signature": "(val: Any, label: str) -> tuple[Optional[UUID], Optional[OperationResult]]",
            "docstring": null,
            "is_async": false,
            "line": 36
          },
          {
            "name": "_parse_dt",
            "signature": "(val: Any, label: str) -> tuple[Optional[datetime], Optional[OperationResult]]",
            "docstring": null,
            "is_async": false,
            "line": 45
          },
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register governance audit operations with the registry.",
            "is_async": false,
            "line": 115
          }
        ],
        "classes": [
          {
            "name": "GovernanceAuditJobHandler",
            "docstring": "Handler for governance.audit_job.",
            "methods": [
              "execute"
            ],
            "line": 57
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "idempotency_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/idempotency_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 49,
        "module_docstring": "Idempotency Handler (PIN-513 Batch 3B3 Wiring)\n\nL4 handler for request idempotency operations.\n\nWires from logs/L6_drivers/idempotency_driver.py:\n- get_idempotency_store()\n- canonical_json(obj)\n- hash_request(data)",
        "functions": [],
        "classes": [
          {
            "name": "IdempotencyHandler",
            "docstring": "L4 handler: request idempotency.",
            "methods": [
              "get_store",
              "canonical_json",
              "hash_request"
            ],
            "line": 28
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict"
            ],
            "is_relative": false,
            "line": 23
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incidents_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/incidents_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 385,
        "module_docstring": "Incidents Handler (L4 Orchestrator)\n\nRoutes incidents domain operations to the L5 IncidentsFacade.\nRegistered as \"incidents.query\" in the OperationRegistry.",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register incidents operations with the registry.",
            "is_async": false,
            "line": 377
          }
        ],
        "classes": [
          {
            "name": "IncidentsQueryHandler",
            "docstring": "Handler for incidents.query operations.\n\nDispatches to IncidentsFacade methods (list_active_incidents,\nlist_resolved_incidents, list_historical_incidents, detect_patterns,\nanalyze_recurrence, get_incident_learnings, etc.).",
            "methods": [
              "execute"
            ],
            "line": 28
          },
          {
            "name": "IncidentsExportHandler",
            "docstring": "Handler for incidents.export operations.\n\nDispatches to ExportBundleDriver methods (PIN-504: L2 must not import L6 directly).\nRoutes export_evidence, export_soc2, export_executive_debrief through L4.",
            "methods": [
              "execute"
            ],
            "line": 77
          },
          {
            "name": "IncidentsWriteHandler",
            "docstring": "Handler for incidents.write operations.\n\nDispatches to IncidentWriteService with audit service injection (PIN-504).\nThe L4 handler creates the audit service via lazy import (legal: L4\u2192L5/L6)\nand injects it into the L5 engine, avoiding cross-domain L5\u2192L5 imports.",
            "methods": [
              "execute"
            ],
            "line": 120
          },
          {
            "name": "IncidentsRecoveryRuleHandler",
            "docstring": "Handler for incidents.recovery_rules operations.\n\nPIN-520 Phase 1: Routes recovery rule engine through L4 registry.\nDispatches to RecoveryRuleEngine methods.\n\nMethods:\n  - evaluate: Evaluate recovery rules for a failure\n  - get_rules: List available recovery rules",
            "methods": [
              "execute"
            ],
            "line": 166
          },
          {
            "name": "CostGuardQueryHandler",
            "docstring": "Handler for incidents.cost_guard operations.\n\nDispatches to CostGuardDriver methods for cost visibility queries.\nExtracted from cost_guard.py L2 to comply with L2 no-execute rule.\n\nMethods:\n  - get_spend_totals: Get spend today/mtd/week\n  - get_budget: Get budget limits\n  - get_baseline: Get baseline for trend\n  - get_last_snapshot: Get last snapshot time\n  - get_total_spend: Get total spend for period\n  - get_baselines: Get all baselines\n  - get_spend_by_feature: Breakdown by feature\n  - get_spend_by_model: Breakdown by model\n  - get_spend_by_user: Breakdown by user\n  - get_cost_anomalies: Get cost anomalies",
            "methods": [
              "execute"
            ],
            "line": 210
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 21
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "integration_bootstrap_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/integration_bootstrap_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 165,
        "module_docstring": "Integration Bootstrap Handler (PIN-513 Batch 1D Wiring)\n\nL4 handler that owns integration subsystem initialization and\nnotification dispatch authority.\n\nWires previously orphaned symbols:\n\nFrom integrations/L5_notifications/engines/channel_engine.py:\n- get_notify_service()        \u2192 singleton accessor\n- get_channel_config()        \u2192 channel config read\n- check_channel_health()      \u2192 health check\n- send_notification()         \u2192 notification dispatch\n\nFrom integrations/L6_drivers/worker_registry_driver.py:\n- get_worker_registry_service() \u2192 already wired via IntegrationsWorkersHandler\n\nNote on bridges_engine (create_bridges/register_all_bridges):\n  These live in legacy app/integrations/bridges.py, NOT in HOC.\n  The HOC file cost_bridges_engine.py is a different component (cost loop).\n  Bridge bootstrap requires legacy-to-HOC migration first (separate PIN).\n\nNote on external_response_driver:\n  Lives in hoc/int/ (INTERNAL audience), not hoc/cus/.\n  Out of scope for this handler (hoc/cus/* scope).\n\nFlow:\n  App startup\n    \u2192 IntegrationBootstrapHandler.initialize()\n        \u2192 get_notify_service() [warm singleton]\n\n  Alert/Incident/Policy coordinator\n    \u2192 IntegrationBootstrapHandler.send_notification(...)\n        \u2192 send_notification(tenant_id, event_type, payload)\n\n  Ops dashboard\n    \u2192 IntegrationBootstrapHandler.check_health(tenant_id)\n        \u2192 check_channel_health(tenant_id)",
        "functions": [],
        "classes": [
          {
            "name": "IntegrationBootstrapHandler",
            "docstring": "L4 handler: integration subsystem bootstrap and notification dispatch.\n\nOwns initialization authority and notification routing.\nL5 channel engine provides business logic.",
            "methods": [
              "initialize",
              "send_notification",
              "check_health",
              "get_channel_config"
            ],
            "line": 57
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "integrations_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/integrations_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 229,
        "module_docstring": "Integrations Handler (L4 Orchestrator)\n\nRoutes integrations domain operations to L5 facades and L6 drivers.\nRegisters four operations:\n  - integrations.query \u2192 IntegrationsFacade\n  - integrations.connectors \u2192 ConnectorsFacade\n  - integrations.datasources \u2192 DataSourcesFacade\n  - integrations.workers \u2192 WorkerRegistryService (L6 driver)",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register integrations operations with the registry.",
            "is_async": false,
            "line": 224
          }
        ],
        "classes": [
          {
            "name": "IntegrationsQueryHandler",
            "docstring": "Handler for integrations.query operations.\n\nDispatches to IntegrationsFacade methods (list_integrations, get_integration,\ncreate_integration, update_integration, delete_integration, etc.).",
            "methods": [
              "execute"
            ],
            "line": 32
          },
          {
            "name": "IntegrationsConnectorsHandler",
            "docstring": "Handler for integrations.connectors operations.\n\nDispatches to ConnectorsFacade methods (list_connectors, register_connector,\nget_connector, update_connector, delete_connector, test_connector).",
            "methods": [
              "execute"
            ],
            "line": 77
          },
          {
            "name": "IntegrationsDataSourcesHandler",
            "docstring": "Handler for integrations.datasources operations.\n\nDispatches to DataSourcesFacade methods (register_source, list_sources,\nget_source, update_source, delete_source, test_connection, etc.).",
            "methods": [
              "execute"
            ],
            "line": 117
          },
          {
            "name": "IntegrationsWorkersHandler",
            "docstring": "Handler for integrations.workers operations.\n\nDispatches to WorkerRegistryService (L6 driver) for worker discovery,\nregistration, and per-tenant configuration.",
            "methods": [
              "execute"
            ],
            "line": 160
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 25
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "integrity_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/integrity_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 38,
        "module_docstring": "Integrity Handler (PIN-513 Batch 3B1 Wiring)\n\nL4 handler for V2 integrity computation.\n\nWires from logs/L6_drivers/integrity_driver.py:\n- compute_integrity_v2(run_id)",
        "functions": [],
        "classes": [
          {
            "name": "IntegrityHandler",
            "docstring": "L4 handler: V2 integrity computation.",
            "methods": [
              "compute"
            ],
            "line": 26
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict"
            ],
            "is_relative": false,
            "line": 21
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "killswitch_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/killswitch_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 207,
        "module_docstring": "Killswitch Handler (L4 Orchestrator)\n\nRoutes killswitch domain operations to L6 drivers:\n  - killswitch.read \u2192 KillswitchOpsDriver (read operations)\n  - killswitch.write \u2192 GuardWriteDriver (write operations)",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register killswitch operations with the registry.",
            "is_async": false,
            "line": 204
          }
        ],
        "classes": [
          {
            "name": "KillswitchReadHandler",
            "docstring": "Handler for killswitch.read operations.\n\nDispatches to KillswitchOpsDriver methods for read operations.",
            "methods": [
              "execute"
            ],
            "line": 29
          },
          {
            "name": "KillswitchWriteHandler",
            "docstring": "Handler for killswitch.write operations.\n\nDispatches to GuardWriteDriver methods for write operations.",
            "methods": [
              "execute"
            ],
            "line": 132
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 22
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lifecycle_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/lifecycle_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 170,
        "module_docstring": "Lifecycle Handler (L4 Orchestrator)\n\nRoutes lifecycle domain operations to L5 engine.\nRegisters two operations:\n  - account.lifecycle.query \u2192 LifecycleStateSnapshot\n  - account.lifecycle.transition \u2192 LifecycleTransitionResult\n\nL4 owns transaction boundaries for mutations.",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register lifecycle operations with the registry.",
            "is_async": false,
            "line": 167
          }
        ],
        "classes": [
          {
            "name": "AccountLifecycleQueryHandler",
            "docstring": "Handler for account.lifecycle.query operations.\n\nReturns lifecycle state snapshot for a tenant.",
            "methods": [
              "execute"
            ],
            "line": 32
          },
          {
            "name": "AccountLifecycleTransitionHandler",
            "docstring": "Handler for account.lifecycle.transition operations.\n\nPerforms lifecycle transitions (suspend, resume, terminate, archive).\nL4 owns transaction boundary.\n\nRequired params:\n  - sync_session: SQLModel Session (from L2 DI)\n  - action: \"suspend\" | \"resume\" | \"terminate\" | \"archive\"\n  - reason: Human-readable reason for transition\n  - actor_id: ID of the actor performing the transition\n  - actor_type: \"FOUNDER\" | \"SYSTEM\"",
            "methods": [
              "execute"
            ],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 25
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "logs_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/logs_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 389,
        "module_docstring": "Logs Handler (L4 Orchestrator)\n\nRoutes logs domain operations to L5 engines and L4 coordinators.\nRegisters six operations:\n  - logs.query \u2192 LogsFacade (27 async endpoints)\n  - logs.evidence \u2192 EvidenceFacade (8 async endpoints)\n  - logs.certificate \u2192 CertificateService (4 sync endpoints)\n  - logs.replay \u2192 ReplayValidator + ReplayContextBuilder (2 sync) + ReplayCoordinator (2 async, PIN-520)\n  - logs.evidence_report \u2192 generate_evidence_report (1 sync function)\n  - logs.pdf \u2192 PDFRenderer (3 sync endpoints, cross-domain: incidents L2 \u2192 logs L5)",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register logs operations with the registry.",
            "is_async": false,
            "line": 380
          }
        ],
        "classes": [
          {
            "name": "LogsQueryHandler",
            "docstring": "Handler for logs.query operations.\n\nDispatches to LogsFacade methods (list_llm_run_records, get_llm_run_envelope,\nget_llm_run_trace, get_llm_run_governance, get_llm_run_replay,\nget_llm_run_export, list_system_records, get_system_snapshot,\nget_system_telemetry, get_system_events, get_system_replay,\nget_system_audit, list_audit_entries, get_audit_entry, etc.).",
            "methods": [
              "execute"
            ],
            "line": 34
          },
          {
            "name": "LogsEvidenceHandler",
            "docstring": "Handler for logs.evidence operations.\n\nDispatches to EvidenceFacade methods (list_chains, get_chain,\ncreate_chain, add_evidence, verify_chain, create_export, etc.).",
            "methods": [
              "execute"
            ],
            "line": 94
          },
          {
            "name": "LogsCertificateHandler",
            "docstring": "Handler for logs.certificate operations.\n\nDispatches to CertificateService.create_replay_certificate().\nSync \u2014 no DB access.",
            "methods": [
              "execute"
            ],
            "line": 134
          },
          {
            "name": "LogsReplayHandler",
            "docstring": "Handler for logs.replay operations.\n\nDispatches to ReplayValidator, ReplayContextBuilder, and ReplayCoordinator.\n\nValidation methods (sync, L5):\n  - build_call_record \u2192 ReplayContextBuilder.build_call_record()\n  - validate_replay \u2192 ReplayValidator.validate_replay()\n\nEnforcement methods (async, L4 coordinator - PIN-520):\n  - enforce_step \u2192 ReplayCoordinator.enforce_step()\n  - enforce_trace \u2192 ReplayCoordinator.enforce_trace()",
            "methods": [
              "execute"
            ],
            "line": 170
          },
          {
            "name": "LogsEvidenceReportHandler",
            "docstring": "Handler for logs.evidence_report operations.\n\nDispatches to generate_evidence_report() function.\nSync \u2014 returns PDF bytes.",
            "methods": [
              "execute"
            ],
            "line": 259
          },
          {
            "name": "LogsPdfHandler",
            "docstring": "Handler for logs.pdf operations.\n\nDispatches to PDFRenderer methods (render_evidence_pdf,\nrender_soc2_pdf, render_executive_debrief_pdf).\nSync \u2014 returns PDF bytes.\n\nNote: This is a cross-domain operation \u2014 incidents L2 \u2192 logs L5.\nThe L4 registry is the correct mediator for cross-domain calls.",
            "methods": [
              "execute"
            ],
            "line": 278
          },
          {
            "name": "LogsCaptureHandler",
            "docstring": "Handler for logs.capture operations.\n\nDispatches to capture_driver for evidence capture (PIN-520 Phase 1).\nUsed by workers.py for Evidence Architecture v1.0.\n\nMethods:\n  - capture_environment: Capture environment evidence at run creation",
            "methods": [
              "execute"
            ],
            "line": 317
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "m25_integration_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/m25_integration_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 407,
        "module_docstring": "M25 Integration Handler (L4 Orchestrator)\n\nRoutes M25 integration domain operations to L6 drivers.\nRegisters operations:\n  - m25.read_stages \u2192 get_loop_stages\n  - m25.read_checkpoint \u2192 get_checkpoint\n  - m25.read_stats \u2192 get integration stats (6 queries combined)\n  - m25.read_simulation_state \u2192 get simulation state\n  - m25.read_timeline \u2192 get prevention timeline data (4 queries combined)\n  - m25.write_prevention \u2192 insert prevention record\n  - m25.write_regret \u2192 insert regret event + upsert summary\n  - m25.write_timeline_view \u2192 insert timeline view\n  - m25.write_graduation_history \u2192 insert graduation history\n  - m25.update_graduation_status \u2192 update graduation status",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register M25 integration operations with the registry.",
            "is_async": false,
            "line": 394
          }
        ],
        "classes": [
          {
            "name": "M25ReadStagesHandler",
            "docstring": "Handler for m25.read_stages operation.",
            "methods": [
              "execute"
            ],
            "line": 41
          },
          {
            "name": "M25ReadCheckpointHandler",
            "docstring": "Handler for m25.read_checkpoint operation.",
            "methods": [
              "execute"
            ],
            "line": 70
          },
          {
            "name": "M25ReadStatsHandler",
            "docstring": "Handler for m25.read_stats operation \u2014 combines all 6 stats queries.",
            "methods": [
              "execute"
            ],
            "line": 105
          },
          {
            "name": "M25ReadSimulationStateHandler",
            "docstring": "Handler for m25.read_simulation_state operation.",
            "methods": [
              "execute"
            ],
            "line": 163
          },
          {
            "name": "M25ReadTimelineHandler",
            "docstring": "Handler for m25.read_timeline operation \u2014 combines incident + events + preventions + regrets.",
            "methods": [
              "execute"
            ],
            "line": 181
          },
          {
            "name": "M25WritePreventionHandler",
            "docstring": "Handler for m25.write_prevention operation.",
            "methods": [
              "execute"
            ],
            "line": 251
          },
          {
            "name": "M25WriteRegretHandler",
            "docstring": "Handler for m25.write_regret operation.",
            "methods": [
              "execute"
            ],
            "line": 280
          },
          {
            "name": "M25WriteTimelineViewHandler",
            "docstring": "Handler for m25.write_timeline_view operation.",
            "methods": [
              "execute"
            ],
            "line": 312
          },
          {
            "name": "M25WriteGraduationHistoryHandler",
            "docstring": "Handler for m25.write_graduation_history operation.",
            "methods": [
              "execute"
            ],
            "line": 341
          },
          {
            "name": "M25UpdateGraduationStatusHandler",
            "docstring": "Handler for m25.update_graduation_status operation.",
            "methods": [
              "execute"
            ],
            "line": 368
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "mcp_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/mcp_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 264,
        "module_docstring": "MCP Servers Handler (L4 Orchestrator)\n\nRoutes MCP server lifecycle operations to L5 engines.\nRegisters one operation:\n  - integrations.mcp_servers \u2192 McpServerEngine, McpToolInvocationEngine\n\nMethods:\n  - register_server: Register a new MCP server\n  - get_server: Get server details by ID\n  - list_servers: List all servers for tenant\n  - discover_tools: Discover tools from MCP server\n  - health_check: Check MCP server health\n  - delete_server: Soft-delete a server\n  - list_tools: List tools for a server\n  - get_invocations: Get invocation history\n  - invoke_tool: Invoke an MCP tool (Phase 4 - governed execution)",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register MCP server operations with the registry.",
            "is_async": false,
            "line": 262
          }
        ],
        "classes": [
          {
            "name": "McpServersHandler",
            "docstring": "Handler for integrations.mcp_servers operations.\n\nDispatches to McpServerEngine methods for MCP server lifecycle management.",
            "methods": [
              "execute"
            ],
            "line": 40
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 33
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "onboarding_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/onboarding_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 317,
        "module_docstring": "Onboarding Handler (L4 Orchestrator)\n\nRoutes onboarding domain operations to L5 engine.\nRegisters two operations:\n  - account.onboarding.query -> OnboardingStateSnapshot\n  - account.onboarding.advance -> OnboardingTransitionResult\n\nAlso provides async helper functions for call sites that need\nonboarding state reads/advances outside of DI (middleware, side-effects).\nL4 owns transaction boundaries for mutations.",
        "functions": [
          {
            "name": "async_advance_onboarding",
            "signature": "(tenant_id: str, target_state: int, trigger: str) -> dict",
            "docstring": "L4-owned async onboarding advance for middleware/async call sites.\n\nUses raw SQL via get_async_session_context() \u2014 no ORM dependency.\nL4 owns the transaction (commit inside the async context manager).",
            "is_async": true,
            "line": 141
          },
          {
            "name": "async_get_onboarding_state",
            "signature": "(tenant_id: str) -> Optional[int]",
            "docstring": "L4-owned async onboarding state read.\n\nUses raw SQL via get_async_session_context() \u2014 no ORM dependency.",
            "is_async": true,
            "line": 212
          },
          {
            "name": "async_detect_stalled_onboarding",
            "signature": "(threshold_hours: int = 24) -> list[dict]",
            "docstring": "L4-owned stalled onboarding detection.\n\nOps/founder visibility helper: returns tenants that are not COMPLETE and were\ncreated more than `threshold_hours` ago.\n\nReturns:\n  [\n    {\n      \"tenant_id\": \"...\",\n      \"state_value\": 1,\n      \"state_name\": \"IDENTITY_VERIFIED\",\n      \"created_at\": \"2026-02-08T00:00:00\",\n      \"hours_stalled\": 25.0,\n    },\n    ...\n  ]\n\nUses raw SQL via get_async_session_context() \u2014 no ORM dependency.",
            "is_async": true,
            "line": 243
          },
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register onboarding operations with the registry.",
            "is_async": false,
            "line": 314
          }
        ],
        "classes": [
          {
            "name": "AccountOnboardingQueryHandler",
            "docstring": "Handler for account.onboarding.query operations.\n\nReturns onboarding state snapshot for a tenant.",
            "methods": [
              "execute"
            ],
            "line": 41
          },
          {
            "name": "AccountOnboardingAdvanceHandler",
            "docstring": "Handler for account.onboarding.advance operations.\n\nPerforms onboarding state transitions.\nL4 owns transaction boundary.\n\nRequired params:\n  - sync_session: SQLModel Session (from L2 DI)\n  - target_state: int (OnboardingStatus value)\n  - trigger: str (what caused the transition)",
            "methods": [
              "execute"
            ],
            "line": 79
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "ops_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/ops_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 102,
        "module_docstring": "Ops Handler (L4 Orchestrator)\n\nRoutes ops domain operations to L5 cost ops engine.\nRegisters one operation:\n  - ops.cost \u2192 CostOpsEngine (overview, anomalies, tenants, customer_drilldown)",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register ops domain handlers.",
            "is_async": false,
            "line": 100
          }
        ],
        "classes": [
          {
            "name": "CostOpsHandler",
            "docstring": "Handler for ops.cost operations.\n\nDispatches to CostOpsEngine methods:\n  - get_overview: Global cost overview\n  - get_anomalies: Cross-tenant anomaly aggregation\n  - get_tenants: Per-tenant cost drilldown\n  - get_customer_drilldown: Single customer deep-dive",
            "methods": [
              "execute"
            ],
            "line": 28
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 21
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "orphan_recovery_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/orphan_recovery_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 202,
        "module_docstring": "Orphan Recovery Handler (PIN-513 Batch 1A Wiring)\n\nL4 handler that owns orphan recovery orchestration.\n\nExtracted from activity/L6_drivers/orphan_recovery_driver.py which\nviolated \"no implicit execution\" \u2014 the driver was creating its own\nsessions and scheduling itself.\n\nL4 owns:\n- Session lifecycle\n- Scheduling authority (startup hook / cron)\n- Transaction commit boundary\n\nL6 provides:\n- detect_orphaned_runs(session, threshold) \u2192 list[WorkerRun]\n- mark_run_as_crashed(session, run, reason) \u2192 bool\n\nFlow:\n  App startup\n    \u2192 OrphanRecoveryHandler.execute(threshold_minutes)\n        \u2192 detect_orphaned_runs(session, threshold)\n        \u2192 mark_run_as_crashed(session, run) [per orphan]\n\n  GET /ops/crash-recovery\n    \u2192 OrphanRecoveryHandler.get_summary()\n        \u2192 query crashed runs (L6 read)",
        "functions": [],
        "classes": [
          {
            "name": "OrphanRecoveryHandler",
            "docstring": "L4 handler: orphan recovery orchestration.\n\nOwns session lifecycle and scheduling authority.\nL6 driver provides pure data primitives only.",
            "methods": [
              "execute",
              "get_summary"
            ],
            "line": 51
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [
          {
            "name": "ORPHAN_THRESHOLD_MINUTES",
            "line": 47
          },
          {
            "name": "RECOVERY_ENABLED",
            "line": 48
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "overview_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/overview_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 73,
        "module_docstring": "Overview Handler (L4 Orchestrator)\n\nRoutes overview domain operations to the L5 OverviewFacade.\nRegistered as \"overview.query\" in the OperationRegistry.\n\nThe handler dispatches to specific facade methods based on ctx.params[\"method\"].",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register overview operations with the registry.",
            "is_async": false,
            "line": 71
          }
        ],
        "classes": [
          {
            "name": "OverviewQueryHandler",
            "docstring": "Handler for overview.query operations.\n\nDispatches to OverviewFacade methods:\n  - get_highlights\n  - get_decisions\n  - get_costs\n  - get_decisions_count\n  - get_recovery_stats",
            "methods": [
              "execute"
            ],
            "line": 30
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 23
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "platform_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/platform_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 90,
        "module_docstring": "Platform Handler (L4 Orchestrator)\n\nRoutes platform domain operations to L6 platform_driver.\nRegisters operations:\n  - platform.health \u2192 PlatformDriver (get_blca_status, get_lifecycle_coherence, etc.)",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register platform operations with the registry.",
            "is_async": false,
            "line": 88
          }
        ],
        "classes": [
          {
            "name": "PlatformHealthHandler",
            "docstring": "Handler for platform.health operations.\n\nDispatches to PlatformDriver methods for platform health queries.\nNote: Uses sync session \u2014 driver is synchronous.",
            "methods": [
              "execute"
            ],
            "line": 29
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 22
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policies_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/policies_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 1658,
        "module_docstring": "Policies Handler (L4 Orchestrator)\n\nRoutes policies domain operations to L5 engines.\nRegisters twelve operations:\n  - policies.query \u2192 PoliciesFacade (15+ async methods)\n  - policies.enforcement \u2192 CusEnforcementEngine (3 methods)\n  - policies.governance \u2192 GovernanceFacade (7+ sync methods)\n  - policies.lessons \u2192 LessonsLearnedEngine (async methods)\n  - policies.policy_facade \u2192 PolicyDriver (37+ async methods)\n  - policies.limits \u2192 PolicyLimitsService (create, update, delete)\n  - policies.rules \u2192 PolicyRulesService (create, update)\n  - policies.rate_limits \u2192 LimitsFacade (6 async methods)\n  - policies.simulate \u2192 LimitsSimulationEngine (simulate)",
        "functions": [
          {
            "name": "_policy_write_ctx",
            "signature": "(facade)",
            "docstring": "L4 transaction context for PolicyEngine write operations.\n\nOpens engine.begin() and injects into driver.managed_connection().\nAuto-commits on clean exit, auto-rollbacks on exception.\nL4 is the sole transaction boundary owner (PIN-520).\n\nArgs:\n    facade: PolicyDriver (L5) with policy_engine_driver property.",
            "is_async": false,
            "line": 44
          },
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register policies domain handlers.",
            "is_async": false,
            "line": 1530
          },
          {
            "name": "record_enforcement_standalone",
            "signature": "(tenant_id: str, rule_id: str, action_taken: str, run_id: Optional[str] = None, incident_id: Optional[str] = None, details: Optional[Dict[str, Any]] = None) -> Optional[str]",
            "docstring": "Record a policy enforcement event via L4 handler (L4 owns commit).\n\nDispatches to PoliciesEnforcementWriteHandler, which creates its own\nsession and commits. Fail-safe: recording failures are logged but don't\nraise exceptions.\n\nArgs:\n    tenant_id: Tenant owning the run\n    rule_id: Policy rule that triggered\n    action_taken: Action taken (BLOCKED, WARNED, AUDITED, STOPPED, KILLED)\n    run_id: Optional run ID that was affected\n    incident_id: Optional incident ID if one was created\n    details: Optional enforcement details\n\nReturns:\n    Enforcement record ID, or None if recording failed",
            "is_async": true,
            "line": 1578
          }
        ],
        "classes": [
          {
            "name": "PoliciesQueryHandler",
            "docstring": "Handler for policies.query operations.\n\nDispatches to PoliciesFacade methods (list_policy_rules, get_policy_rule_detail,\nlist_limits, get_limit_detail, list_lessons, get_lesson_stats, etc.).",
            "methods": [
              "execute"
            ],
            "line": 61
          },
          {
            "name": "PoliciesEnforcementHandler",
            "docstring": "Handler for policies.enforcement operations.\n\nDispatches to CusEnforcementEngine methods (evaluate, get_enforcement_status,\nevaluate_batch).",
            "methods": [
              "execute"
            ],
            "line": 102
          },
          {
            "name": "PoliciesGovernanceHandler",
            "docstring": "Handler for policies.governance operations.\n\nDispatches to GovernanceFacade methods. Note: facade methods are SYNC.",
            "methods": [
              "execute"
            ],
            "line": 137
          },
          {
            "name": "PoliciesLessonsHandler",
            "docstring": "Handler for policies.lessons operations.\n\nDispatches to LessonsLearnedEngine methods.",
            "methods": [
              "execute"
            ],
            "line": 174
          },
          {
            "name": "PoliciesPolicyFacadeHandler",
            "docstring": "Handler for policies.policy_facade operations.\n\nDispatches to PolicyDriver (policy_driver.py) methods.\n37+ call sites in policy_layer.py.",
            "methods": [
              "execute"
            ],
            "line": 220
          },
          {
            "name": "PoliciesLimitsHandler",
            "docstring": "Handler for policies.limits operations.\n\nDispatches to PolicyLimitsService (create, update, delete).\nError classes (LimitNotFoundError, etc.) are translated to OperationResult.fail.\nInjects audit service into L5 engine (PIN-504: no cross-domain imports).",
            "methods": [
              "execute"
            ],
            "line": 294
          },
          {
            "name": "PoliciesRulesHandler",
            "docstring": "Handler for policies.rules operations.\n\nDispatches to PolicyRulesService (create, update).\nError classes translated to OperationResult.fail.\nInjects audit service into L5 engine (PIN-504: no cross-domain imports).",
            "methods": [
              "execute"
            ],
            "line": 355
          },
          {
            "name": "PoliciesRateLimitsHandler",
            "docstring": "Handler for policies.rate_limits operations.\n\nDispatches to LimitsFacade methods (list_limits, get_limit, update_limit,\nget_usage, check_limit, reset_usage).",
            "methods": [
              "execute"
            ],
            "line": 408
          },
          {
            "name": "PoliciesSimulateHandler",
            "docstring": "Handler for policies.simulate operations.\n\nDispatches to LimitsSimulationEngine (simulate).",
            "methods": [
              "execute"
            ],
            "line": 445
          },
          {
            "name": "PoliciesLimitsQueryHandler",
            "docstring": "Handler for policies.limits_query operations (PIN-513 Batch 2B).\n\nDispatches to LimitsQueryEngine (get_limits_query_engine).",
            "methods": [
              "execute"
            ],
            "line": 486
          },
          {
            "name": "PoliciesProposalsQueryHandler",
            "docstring": "Handler for policies.proposals_query operations (PIN-513 Batch 2B).\n\nDispatches to ProposalsQueryEngine (get_proposals_query_engine).",
            "methods": [
              "execute"
            ],
            "line": 518
          },
          {
            "name": "PoliciesRulesQueryHandler",
            "docstring": "Handler for policies.rules_query operations (PIN-513 Batch 2B).\n\nDispatches to PolicyRulesQueryEngine (get_policy_rules_query_engine).",
            "methods": [
              "execute"
            ],
            "line": 550
          },
          {
            "name": "PoliciesHealthHandler",
            "docstring": "Handler for policies.health operations (PIN-520 Phase 1).\n\nReports availability of policy-related L5 engines.\nUsed by workers.py health endpoint to check moat status.\n\nThis handler absorbs the L5 import checks that were previously\ndone directly in workers.py, routing them through L4.",
            "methods": [
              "execute"
            ],
            "line": 582
          },
          {
            "name": "PoliciesRecoveryMatchHandler",
            "docstring": "Handler for policies.recovery.match operations.\n\nPIN-520 Phase 1: Routes RecoveryMatcher through L4 registry.\nDispatches to RecoveryMatcher methods.\n\nMethods:\n  - suggest: Synchronous pattern matching and suggestion generation\n  - suggest_hybrid: Async hybrid (embedding + LLM) suggestion\n  - get_candidates: List recovery candidates\n  - count_candidates: Count candidates by status\n  - count_by_status: Get candidate counts grouped by status",
            "methods": [
              "execute"
            ],
            "line": 619
          },
          {
            "name": "PoliciesRecoveryWriteHandler",
            "docstring": "Handler for policies.recovery.write operations.\n\nPIN-520 Phase 1: Routes RecoveryWriteService through L4 registry.\nDispatches to RecoveryWriteService methods for candidate management.\n\nMethods:\n  - upsert_candidate: Atomic upsert of recovery candidate (no commit)\n  - upsert_candidate_transactional: Upsert with L4-owned commit/rollback\n  - get_by_idempotency_key: Get candidate by idempotency key\n  - enqueue_evaluation_transactional: DB fallback enqueue with commit",
            "methods": [
              "execute"
            ],
            "line": 718
          },
          {
            "name": "PoliciesGuardReadHandler",
            "docstring": "Handler for policies.guard_read operations.\n\nL2 first-principles purity: Routes all guard/killswitch DB read\noperations through L4 to L6 GuardReadDriver.\nThis eliminates sqlalchemy/sqlmodel imports from L2 guard files.\n\nMethods dispatch directly to GuardReadDriver by method name.",
            "methods": [
              "execute"
            ],
            "line": 921
          },
          {
            "name": "PoliciesSyncGuardReadHandler",
            "docstring": "Handler for policies.sync_guard_read operations.\n\nL2 first-principles purity: Routes all sync guard/killswitch DB read\noperations through L4 to L6 SyncGuardReadDriver.\nThis eliminates session.execute() calls from L2 guard.py.\n\nUses synchronous Session (SQLModel Session via get_sync_session_dep).\n\nMethods dispatch directly to SyncGuardReadDriver by method name.",
            "methods": [
              "execute"
            ],
            "line": 961
          },
          {
            "name": "PoliciesCustomerVisibilityHandler",
            "docstring": "Handler for policies.customer_visibility operations.\n\nRoutes customer visibility DB read operations through L4 to L6 GuardReadDriver.\nSupports fetch_run_outcome and fetch_decision_summary for outcome reconciliation.\n\nMethods:\n  - fetch_run_outcome: Get run data for outcome reconciliation\n  - fetch_decision_summary: Get decision summary (effects only)",
            "methods": [
              "execute"
            ],
            "line": 1004
          },
          {
            "name": "PoliciesRecoveryReadHandler",
            "docstring": "Handler for policies.recovery.read operations.\n\nL2 first-principles purity: Routes all recovery DB read\noperations through L4 to L6 RecoveryReadDriver.\nThis eliminates session.execute() from L2 recovery.py.\n\nMethods:\n  - get_candidate_detail: Get detailed candidate by ID\n  - get_selected_action: Get action by ID\n  - get_suggestion_inputs: Get inputs for a suggestion\n  - get_suggestion_provenance: Get provenance history for a suggestion\n  - candidate_exists: Check if candidate exists (returns exists, confidence)\n  - list_actions: List recovery actions from catalog",
            "methods": [
              "execute"
            ],
            "line": 1061
          },
          {
            "name": "PoliciesReplayHandler",
            "docstring": "Handler for policies.replay operations.\n\nL2 first-principles purity: Routes all replay UX DB read\noperations through L4 to L6 ReplayReadDriver.\nThis eliminates session.execute() from L2 replay.py.\n\nMethods:\n  - get_incident: Get incident by ID with tenant check\n  - get_incident_no_tenant_check: Get incident by ID (caller does tenant check)\n  - get_proxy_calls_in_window: Get proxy calls within time window\n  - get_incident_events_in_window: Get incident events within time window\n  - get_proxy_calls_for_timeline: Get all proxy calls for timeline\n  - get_all_incident_events: Get all incident events\n  - get_proxy_call_by_id: Get single proxy call\n  - get_incident_event_by_id: Get single incident event",
            "methods": [
              "execute"
            ],
            "line": 1151
          },
          {
            "name": "RbacAuditHandler",
            "docstring": "Handler for rbac.audit_query and rbac.audit_cleanup operations.\n\nL2 first-principles purity: Routes all RBAC audit DB operations\nthrough L4 to L6 RbacAuditDriver.\nThis eliminates db.execute() and db.commit() from L2 rbac_api.py.\n\nTransaction boundary: L4 owns commit/rollback (not L6 driver).\n\nMethods:\n  - query_audit_logs: Query audit entries with filters (read-only)\n  - cleanup_audit_logs: Delete old audit entries (L4 commits after driver call)",
            "methods": [
              "execute"
            ],
            "line": 1267
          },
          {
            "name": "PoliciesWorkersHandler",
            "docstring": "Handler for policies.workers operations.\n\nL2 first-principles purity: Routes all worker DB read/write\noperations through L4 to L6 WorkersReadDriver.\nThis eliminates session.execute() from L2 workers.py.\n\nMethods:\n  - verify_run_exists: Verify worker_run exists\n  - get_run: Get worker run by ID\n  - list_runs: List recent worker runs\n  - count_runs: Count worker runs for health check\n  - get_active_tenant_budget: Get tenant's active cost budget\n  - get_daily_spend: Calculate today's spend\n  - get_existing_advisory: Check if advisory exists\n  - count_advisories: Count advisories for run\n  - get_run_for_retry: Get run from `runs` table\n  - insert_retry_run: Insert new retry run",
            "methods": [
              "execute"
            ],
            "line": 1335
          },
          {
            "name": "PoliciesEnforcementWriteHandler",
            "docstring": "Handler for policies.enforcement_write operations.\n\nL4 owns transaction boundary for enforcement record writes.\nCreates own session, calls driver, commits.\n\nMethods:\n  - record_enforcement: Record a policy enforcement event (L4 commits)",
            "methods": [
              "execute"
            ],
            "line": 1474
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "contextlib",
            "names": [
              "contextmanager"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policies_sandbox_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/policies_sandbox_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 75,
        "module_docstring": "Policies Sandbox Handler (GAP-174)\n\nProvides an L4-owned call path for policy sandbox execution so the sandbox\nengine is a live execution dependency (not just a wired import).",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register policies sandbox operations with the registry.",
            "is_async": false,
            "line": 72
          }
        ],
        "classes": [
          {
            "name": "PoliciesSandboxExecuteHandler",
            "docstring": "Handler for policies.sandbox_execute.",
            "methods": [
              "execute"
            ],
            "line": 32
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 25
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_approval_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/policy_approval_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 446,
        "module_docstring": "Policy Approval Handler (L4)\n\nL4 handler that routes policy approval operations to L6 drivers.\nThis handler enables L2 to use registry.execute() instead of session.execute().\n\nWires from policies/L6_drivers/policy_approval_driver.py:\n- get_policy_approval_driver(session)\n\nFlow:\n  L2 API\n    \u2192 PolicyApprovalHandler.<method>(ctx)\n        \u2192 L6 driver call",
        "functions": [
          {
            "name": "get_policy_approval_handler",
            "signature": "() -> PolicyApprovalHandler",
            "docstring": "Factory function for PolicyApprovalHandler.",
            "is_async": false,
            "line": 438
          }
        ],
        "classes": [
          {
            "name": "PolicyApprovalHandler",
            "docstring": "L4 handler: policy approval workflow operations.\n\nDispatches to L6 PolicyApprovalDriver based on ctx.params[\"method\"].",
            "methods": [
              "execute",
              "_get_approval_level_config",
              "_create_approval_request",
              "_get_approval_request",
              "_get_approval_request_for_action",
              "_get_approval_request_for_reject",
              "_update_approval_request_status",
              "_update_approval_request_approved",
              "_update_approval_request_escalated",
              "_list_approval_requests",
              "_list_pending_for_escalation",
              "_batch_update_expired",
              "_batch_escalate",
              "_list_policy_rules",
              "_get_policy_rule_detail",
              "_list_limits",
              "_get_limit_detail",
              "_review_proposal"
            ],
            "line": 40
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationHandler",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyApprovalHandler",
          "get_policy_approval_handler"
        ]
      },
      {
        "file_name": "policy_governance_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/policy_governance_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 257,
        "module_docstring": "Policy Governance Handler (PIN-513 Batch 2B Wiring)\n\nL4 handler that owns the policy proposal lifecycle and snapshot\ngovernance operations.\n\nWires from policies/L5_engines/policy_proposal_engine.py:\n- get_policy_proposal_engine(session)\n- check_proposal_eligibility(session, ...)\n- create_policy_proposal(session, proposal)\n- review_policy_proposal(session, proposal_id, review, audit)\n- delete_policy_rule(session, rule_id, tenant_id, deleted_by)\n- get_proposal_summary(session, ...)\n- generate_default_rule(policy_type, feedback_type) [pure import]\n\nWires from policies/L5_engines/snapshot_engine.py:\n- create_policy_snapshot(tenant_id, policies, thresholds, ...)\n- get_active_snapshot(tenant_id)\n- get_policy_snapshot(snapshot_id)\n- get_snapshot_history(tenant_id, limit)\n- verify_snapshot(snapshot_id)\n- get_snapshot_registry()\n\nFlow:\n  Admin API\n    \u2192 PolicyGovernanceHandler.<method>(session, ...)\n        \u2192 L5 engine call",
        "functions": [],
        "classes": [
          {
            "name": "PolicyGovernanceHandler",
            "docstring": "L4 handler: policy proposal lifecycle + snapshot governance.\n\nPB-S4: Proposals are HUMAN decisions. This handler enforces\nthe draft \u2192 review \u2192 activate lifecycle.",
            "methods": [
              "check_eligibility",
              "create_proposal",
              "review_proposal",
              "delete_rule",
              "get_summary",
              "generate_rule_template",
              "create_snapshot",
              "get_active_snapshot",
              "get_snapshot",
              "get_history",
              "verify_snapshot"
            ],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "proxy_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/proxy_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 151,
        "module_docstring": "Proxy Handler (L4 Orchestrator)\n\nRoutes proxy domain operations to L6 proxy_driver.\nRegisters operations:\n  - proxy.get_api_key_by_hash \u2192 ProxyDriver.get_api_key_by_hash()\n  - proxy.get_tenant_by_id \u2192 ProxyDriver.get_tenant_by_id()\n  - proxy.record_api_key_usage \u2192 ProxyDriver.record_api_key_usage()\n  - proxy.get_killswitch_state \u2192 ProxyDriver.get_killswitch_state()\n  - proxy.get_enabled_guardrails \u2192 ProxyDriver.get_enabled_guardrails()\n  - proxy.log_proxy_call \u2192 ProxyDriver.log_proxy_call()\n  - proxy.get_latency_stats \u2192 ProxyDriver.get_latency_stats()\n  - proxy.get_blocked_call_count \u2192 ProxyDriver.get_blocked_call_count()\n  - proxy.get_last_incident \u2192 ProxyDriver.get_last_incident()\n  - proxy.get_api_key_id_and_tenant \u2192 ProxyDriver.get_api_key_id_and_tenant()",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register proxy operations with the registry.",
            "is_async": false,
            "line": 149
          }
        ],
        "classes": [
          {
            "name": "ProxyHandler",
            "docstring": "Handler for proxy.* operations.\n\nDispatches to ProxyDriver methods for all proxy-related DB operations.\nNote: Uses sync session \u2014 driver is synchronous.",
            "methods": [
              "execute"
            ],
            "line": 38
          }
        ],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "run_governance_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/run_governance_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 210,
        "module_docstring": "Run Governance Handler (PIN-513 Batch 1B Wiring)\n\nL4 handler that owns run-lifecycle policy side effects.\n\nWires three previously orphaned symbols from\nincidents/L5_engines/policy_violation_engine.py:\n\n- handle_policy_evaluation_for_run  (async run \u2192 evaluation record)\n- handle_policy_violation           (async violation \u2192 incident flow)\n- create_policy_evaluation_record   (async raw evaluation creation)\n\nThese are run-lifecycle side effects that must be owned by L4.\nThe L5 engine provides the business logic; L4 owns session and\ninvocation authority.\n\nFlow:\n  Run completed\n    \u2192 RunGovernanceHandler.evaluate_run(session, run_id, tenant_id, run_status)\n        \u2192 handle_policy_evaluation_for_run(session, ...)\n\n  Policy violation detected\n    \u2192 RunGovernanceHandler.report_violation(session, ...)\n        \u2192 handle_policy_violation(session, ...)",
        "functions": [],
        "classes": [
          {
            "name": "RunGovernanceHandler",
            "docstring": "L4 handler: run governance policy evaluation and violation handling.\n\nOwns invocation authority for policy evaluation side effects.\nL5 engine provides business logic and driver delegation.",
            "methods": [
              "evaluate_run",
              "report_violation",
              "create_evaluation"
            ],
            "line": 43
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "system_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/system_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 99,
        "module_docstring": "System Runtime Health Handler\n\nMoves DB validation out of app.main and into hoc_spine, so L2 /health remains\nthe single owner of the health endpoint while still providing truth-grade\nruntime checks.",
        "functions": [
          {
            "name": "register",
            "signature": "(registry: OperationRegistry) -> None",
            "docstring": "Register system operations with the registry.",
            "is_async": false,
            "line": 95
          }
        ],
        "classes": [
          {
            "name": "SystemHealthHandler",
            "docstring": "Handler for system.health.",
            "methods": [
              "execute"
            ],
            "line": 37
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationRegistry",
              "OperationResult",
              "get_async_session_context",
              "get_operation_registry",
              "sql_text"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "traces_handler.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/handlers/traces_handler.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 361,
        "module_docstring": "Traces Handler (L4 Orchestrator)\n\nWraps L5 trace_mismatch_engine calls in OperationHandler protocol.\n\nOperations registered:\n- traces.list_mismatches: List all mismatches with filters\n- traces.list_trace_mismatches: List mismatches for a specific trace\n- traces.report_mismatch: Report a new mismatch\n- traces.resolve_mismatch: Mark a mismatch as resolved\n- traces.bulk_report_mismatches: Create bulk GitHub issue",
        "functions": [
          {
            "name": "register_traces_handlers",
            "signature": "() -> None",
            "docstring": "Register all trace mismatch handlers with the operation registry.\n\nCall this once at startup.",
            "is_async": false,
            "line": 346
          }
        ],
        "classes": [
          {
            "name": "ListAllMismatchesHandler",
            "docstring": "Handler for listing all mismatches.\n\nParams:\n    window: Optional[str] - Time window (e.g., \"24h\", \"7d\")\n    status: Optional[str] - Filter by status (\"open\" or \"resolved\")\n    limit: int - Max results (default 100)",
            "methods": [
              "execute"
            ],
            "line": 51
          },
          {
            "name": "ListTraceMismatchesHandler",
            "docstring": "Handler for listing mismatches for a specific trace.\n\nParams:\n    trace_id: str - Trace ID to list mismatches for\n    is_admin: bool - Whether caller has admin role",
            "methods": [
              "execute"
            ],
            "line": 94
          },
          {
            "name": "ReportMismatchHandler",
            "docstring": "Handler for reporting a mismatch.\n\nParams:\n    trace_id: str - Trace ID\n    step_index: int - Step index\n    reason: str - Reason for mismatch\n    expected_hash: Optional[str] - Expected hash\n    actual_hash: Optional[str] - Actual hash\n    details: dict - Additional details\n    user_id: str - User reporting\n    is_admin: bool - Whether caller has admin role",
            "methods": [
              "execute"
            ],
            "line": 140
          },
          {
            "name": "ResolveMismatchHandler",
            "docstring": "Handler for resolving a mismatch.\n\nParams:\n    trace_id: str - Trace ID\n    mismatch_id: str - Mismatch ID\n    user_id: str - User resolving\n    resolution_note: Optional[str] - Resolution note",
            "methods": [
              "execute"
            ],
            "line": 203
          },
          {
            "name": "BulkReportMismatchesHandler",
            "docstring": "Handler for bulk reporting mismatches.\n\nParams:\n    mismatch_ids: list[str] - List of mismatch IDs\n    user_id: str - User creating the bulk report\n    github_issue: bool - Whether to create GitHub issue (default True)",
            "methods": [
              "execute"
            ],
            "line": 252
          },
          {
            "name": "VerifyTraceTenantHandler",
            "docstring": "Handler for verifying trace tenant ownership.\n\nParams:\n    trace_id: str - Trace ID to verify\n    is_admin: bool - Whether caller has admin role\n\nReturns:\n    trace_tenant: str - Tenant ID of the trace (if found)",
            "methods": [
              "execute"
            ],
            "line": 299
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationHandler",
              "OperationResult",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "execution.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/lifecycle/drivers/execution.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 1332,
        "module_docstring": "Module: execution\nPurpose: Real execution implementations for knowledge plane lifecycle stages.\n\nWires:\n    - Source: ConnectorRegistry for data source access\n    - Target: Internal storage for processed data\n\nContains:\n    - DataIngestionExecutor (GAP-159): Real data ingestion from connectors\n    - IndexingExecutor (GAP-160): Real embedding generation and indexing\n    - ClassificationExecutor (GAP-161): Real PII detection and classification\n\nAcceptance Criteria:\n    - AC-159-01: Data read via ConnectorRegistry\n    - AC-159-02: Supports HTTP, SQL, File connector types\n    - AC-159-03: Progress reported via JobProgressTracker\n    - AC-159-04: Failures captured with retry support\n    - AC-160-01: Embeddings generated for text content\n    - AC-160-02: Vectors stored in VectorConnector\n    - AC-160-03: Metadata indexed for search\n    - AC-161-01: PII patterns detected\n    - AC-161-02: Sensitivity levels assigned\n    - AC-161-03: Classification evidence emitted",
        "functions": [
          {
            "name": "get_ingestion_executor",
            "signature": "() -> DataIngestionExecutor",
            "docstring": "Get or create the singleton DataIngestionExecutor.",
            "is_async": false,
            "line": 1297
          },
          {
            "name": "get_indexing_executor",
            "signature": "() -> IndexingExecutor",
            "docstring": "Get or create the singleton IndexingExecutor.",
            "is_async": false,
            "line": 1307
          },
          {
            "name": "get_classification_executor",
            "signature": "() -> ClassificationExecutor",
            "docstring": "Get or create the singleton ClassificationExecutor.",
            "is_async": false,
            "line": 1317
          },
          {
            "name": "reset_executors",
            "signature": "() -> None",
            "docstring": "Reset all singletons (for testing).",
            "is_async": false,
            "line": 1327
          }
        ],
        "classes": [
          {
            "name": "IngestionSourceType",
            "docstring": "Types of data sources for ingestion.",
            "methods": [],
            "line": 65
          },
          {
            "name": "IngestionBatch",
            "docstring": "A batch of ingested records.",
            "methods": [
              "__post_init__"
            ],
            "line": 75
          },
          {
            "name": "IngestionResult",
            "docstring": "Result of data ingestion operation.",
            "methods": [
              "to_dict"
            ],
            "line": 96
          },
          {
            "name": "DataIngestionExecutor",
            "docstring": "Real data ingestion executor (GAP-159).\n\nReads data from configured connectors and prepares it for indexing.\n\nSupported source types:\n- HTTP: REST API endpoints via HttpConnectorService\n- SQL: Database queries via SqlGatewayService\n- FILE: File storage via FileConnector\n- VECTOR: Existing vector stores via VectorConnector",
            "methods": [
              "__init__",
              "execute",
              "_get_connector",
              "_ingest_from_http",
              "_ingest_from_sql",
              "_ingest_from_file",
              "_ingest_from_vector",
              "_simulate_ingestion"
            ],
            "line": 121
          },
          {
            "name": "IndexingResult",
            "docstring": "Result of indexing operation.",
            "methods": [
              "to_dict"
            ],
            "line": 631
          },
          {
            "name": "IndexingExecutor",
            "docstring": "Real indexing executor (GAP-160).\n\nGenerates embeddings and stores vectors for search.\n\nFeatures:\n- Text chunking for long documents\n- Embedding generation (via configured provider)\n- Vector upsert to VectorConnector\n- Metadata indexing for filtering",
            "methods": [
              "__init__",
              "execute",
              "_get_vector_connector",
              "_extract_documents",
              "_chunk_documents",
              "_generate_embeddings",
              "_simulate_embedding",
              "_call_embedding_api"
            ],
            "line": 654
          },
          {
            "name": "SensitivityLevel",
            "docstring": "Data sensitivity levels.",
            "methods": [],
            "line": 953
          },
          {
            "name": "PIIType",
            "docstring": "Types of PII detected.",
            "methods": [],
            "line": 961
          },
          {
            "name": "PIIDetection",
            "docstring": "A detected PII instance.",
            "methods": [],
            "line": 976
          },
          {
            "name": "ClassificationResult",
            "docstring": "Result of classification operation.",
            "methods": [
              "to_dict"
            ],
            "line": 985
          },
          {
            "name": "ClassificationExecutor",
            "docstring": "Real classification executor (GAP-161).\n\nAnalyzes data for:\n- PII detection (emails, phones, SSNs, etc.)\n- Sensitivity classification\n- Content categorization\n\nFeatures:\n- Regex-based PII detection\n- Configurable sensitivity thresholds\n- Category inference from content",
            "methods": [
              "__init__",
              "execute",
              "_sample_records",
              "_detect_pii",
              "_redact",
              "_detect_categories",
              "_determine_sensitivity"
            ],
            "line": 1012
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Iterator",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "knowledge_plane.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/lifecycle/drivers/knowledge_plane.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 482,
        "module_docstring": "KnowledgePlane - Knowledge plane models and registry.\n\nProvides knowledge graph abstraction for:\n- Knowledge organization\n- Semantic relationships\n- Multi-source integration",
        "functions": [
          {
            "name": "get_knowledge_plane_registry",
            "signature": "() -> KnowledgePlaneRegistry",
            "docstring": "Get the singleton registry instance.",
            "is_async": false,
            "line": 440
          },
          {
            "name": "_reset_registry",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 448
          },
          {
            "name": "create_knowledge_plane",
            "signature": "(tenant_id: str, name: str, description: Optional[str] = None) -> KnowledgePlane",
            "docstring": "Create a new knowledge plane using the singleton registry.",
            "is_async": false,
            "line": 457
          },
          {
            "name": "get_knowledge_plane",
            "signature": "(plane_id: str) -> Optional[KnowledgePlane]",
            "docstring": "Get a knowledge plane by ID using the singleton registry.",
            "is_async": false,
            "line": 471
          },
          {
            "name": "list_knowledge_planes",
            "signature": "(tenant_id: Optional[str] = None) -> list[KnowledgePlane]",
            "docstring": "List knowledge planes using the singleton registry.",
            "is_async": false,
            "line": 477
          }
        ],
        "classes": [
          {
            "name": "KnowledgePlaneStatus",
            "docstring": "Status of a knowledge plane.",
            "methods": [],
            "line": 35
          },
          {
            "name": "KnowledgeNodeType",
            "docstring": "Types of knowledge nodes.",
            "methods": [],
            "line": 47
          },
          {
            "name": "KnowledgeNode",
            "docstring": "A node in the knowledge graph.",
            "methods": [
              "add_child",
              "add_related",
              "to_dict"
            ],
            "line": 60
          },
          {
            "name": "KnowledgePlane",
            "docstring": "Representation of a knowledge plane.\n\nA knowledge plane is a tenant-specific knowledge graph\nthat organizes and indexes content from multiple sources.",
            "methods": [
              "add_node",
              "get_node",
              "remove_node",
              "add_source",
              "remove_source",
              "activate",
              "deactivate",
              "start_indexing",
              "finish_indexing",
              "archive",
              "record_error",
              "to_dict"
            ],
            "line": 115
          },
          {
            "name": "KnowledgePlaneError",
            "docstring": "Exception for knowledge plane errors.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 259
          },
          {
            "name": "KnowledgePlaneStats",
            "docstring": "Statistics for knowledge planes.",
            "methods": [
              "to_dict"
            ],
            "line": 280
          },
          {
            "name": "KnowledgePlaneRegistry",
            "docstring": "Registry for managing knowledge planes.\n\nFeatures:\n- Plane registration and lookup\n- Node management\n- Status tracking\n- Tenant isolation",
            "methods": [
              "__init__",
              "register",
              "get",
              "get_by_name",
              "list",
              "delete",
              "get_statistics",
              "clear_tenant",
              "reset"
            ],
            "line": 304
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "offboarding.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/lifecycle/engines/offboarding.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 537,
        "module_docstring": "Offboarding Stage Handlers\n\nThese handlers implement the \"dumb plugin\" contract for knowledge plane offboarding.\n\nOffboarding Path:\n    ACTIVE \u2192 PENDING_DEACTIVATE \u2192 DEACTIVATED \u2192 ARCHIVED \u2192 PURGED\n\nEach handler:\n- Performs ONLY its specific operation\n- Returns success/failure\n- Does NOT manage state\n- Does NOT emit events\n- Does NOT check policies\n\nThe KnowledgeLifecycleManager orchestrates everything else.\n\nCRITICAL: Offboarding is governance-controlled for GDPR/CCPA compliance.\n- PENDING_DEACTIVATE has a grace period (cancel window)\n- DEACTIVATED preserves data (soft delete)\n- ARCHIVED exports to cold storage\n- PURGED deletes data but preserves audit trail",
        "functions": [],
        "classes": [
          {
            "name": "DeregisterHandler",
            "docstring": "GAP-078: Start offboarding process.\n\nInitiates deregistration by moving to PENDING_DEACTIVATE state.\nThis starts a grace period where the offboarding can be cancelled.\n\nResponsibilities:\n- Validate no active runs are using this plane\n- Check for dependent resources\n- Calculate grace period end time\n\nDoes NOT:\n- Actually deactivate the plane\n- Delete any data\n- Change state (orchestrator does that)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_check_active_references",
              "_check_dependents"
            ],
            "line": 62
          },
          {
            "name": "VerifyDeactivateHandler",
            "docstring": "GAP-079: Verify deactivation is safe.\n\nVerifies that the knowledge plane can be safely deactivated:\n- No active runs\n- No pending queries\n- Grace period has passed (or forced)\n\nResponsibilities:\n- Verify grace period status\n- Check for any remaining active usage\n- Validate deactivation is safe\n\nDoes NOT:\n- Actually deactivate\n- Make policy decisions (orchestrator's policy gate does that)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_check_active_usage"
            ],
            "line": 162
          },
          {
            "name": "DeactivateHandler",
            "docstring": "GAP-080: Deactivate knowledge plane (soft delete).\n\nPerforms soft deletion - the plane is no longer queryable but data is preserved.\n\nResponsibilities:\n- Disable query endpoint\n- Revoke active access tokens\n- Mark as deactivated\n\nDoes NOT:\n- Delete any data (preserved for archival)\n- Remove from storage\n- Delete audit trail",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_perform_deactivation"
            ],
            "line": 258
          },
          {
            "name": "ArchiveHandler",
            "docstring": "GAP-081: Archive knowledge plane to cold storage.\n\nExports data to cold storage for long-term retention.\n\nResponsibilities:\n- Export data to archive storage\n- Generate archive manifest\n- Verify archive integrity\n- Remove from hot storage (after verification)\n\nDoes NOT:\n- Delete audit trail\n- Remove from system entirely\n- Make purge decision (requires separate approval)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_perform_archive"
            ],
            "line": 337
          },
          {
            "name": "PurgeHandler",
            "docstring": "GAP-082: Purge knowledge plane (permanent deletion).\n\nPermanently deletes all data except the audit trail.\n\nResponsibilities:\n- Delete data from archive storage\n- Delete indexes and embeddings\n- Delete metadata\n- Preserve audit trail (REQUIRED for compliance)\n\nDoes NOT:\n- Delete audit trail (audit is immutable)\n- Make this reversible (PURGED is terminal)\n\nCRITICAL: This operation requires approval via GAP-087 policy gate.\nThe orchestrator calls the policy gate BEFORE this handler.",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_perform_purge"
            ],
            "line": 434
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.models.knowledge_lifecycle",
            "names": [
              "KnowledgePlaneLifecycleState"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.lifecycle_stages_base",
            "names": [
              "BaseStageHandler",
              "StageContext",
              "StageResult"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "onboarding.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/lifecycle/engines/onboarding.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 709,
        "module_docstring": "Onboarding Stage Handlers\n\nThese handlers implement the \"dumb plugin\" contract for knowledge plane onboarding.\n\nOnboarding Path:\n    DRAFT \u2192 PENDING_VERIFY \u2192 VERIFIED \u2192 INGESTING \u2192 INDEXED \u2192\n    CLASSIFIED \u2192 PENDING_ACTIVATE \u2192 ACTIVE\n\nEach handler:\n- Performs ONLY its specific operation\n- Returns success/failure\n- Does NOT manage state\n- Does NOT emit events\n- Does NOT check policies\n\nThe KnowledgeLifecycleManager orchestrates everything else.",
        "functions": [],
        "classes": [
          {
            "name": "RegisterHandler",
            "docstring": "GAP-071: Register knowledge plane.\n\nCreates the initial knowledge plane record in DRAFT state.\nThis is a special handler - it doesn't transition FROM a state,\nit creates a new entity.\n\nResponsibilities:\n- Validate registration request\n- Create plane configuration\n- Initialize metadata\n\nDoes NOT:\n- Create database records (orchestrator does that)\n- Set state (orchestrator does that)\n- Emit events (orchestrator does that)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute"
            ],
            "line": 58
          },
          {
            "name": "VerifyHandler",
            "docstring": "GAP-072: Verify knowledge plane connectivity.\n\nVerifies that the knowledge source is accessible and credentials are valid.\n\nResponsibilities:\n- Test connection to source\n- Validate credentials\n- Check source schema/structure\n\nDoes NOT:\n- Store credentials (already done at registration)\n- Update state (orchestrator does that)\n- Retry on failure (orchestrator handles retry logic)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_simulate_verification"
            ],
            "line": 140
          },
          {
            "name": "IngestHandler",
            "docstring": "GAP-073: Ingest data from knowledge source.\nGAP-159: Real execution via DataIngestionExecutor.\n\nReads data from the source and stores it for processing.\n\nResponsibilities:\n- Read data from source via ConnectorRegistry\n- Transform to internal format\n- Store raw data for indexing\n\nDoes NOT:\n- Create indexes (IndexHandler does that)\n- Classify data (ClassifyHandler does that)\n- Track progress in state (orchestrator does that)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute"
            ],
            "line": 249
          },
          {
            "name": "IndexHandler",
            "docstring": "GAP-074: Create indexes and embeddings.\nGAP-160: Real execution via IndexingExecutor.\n\nCreates vector embeddings and search indexes for the ingested data.\n\nResponsibilities:\n- Generate embeddings via configured provider\n- Create vector indexes in VectorConnector\n- Build search structures\n\nDoes NOT:\n- Classify data (ClassifyHandler does that)\n- Manage index lifecycle (orchestrator does that)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute"
            ],
            "line": 343
          },
          {
            "name": "ClassifyHandler",
            "docstring": "GAP-075: Classify data sensitivity and schema.\nGAP-161: Real execution via ClassificationExecutor.\n\nAnalyzes the data to determine:\n- Sensitivity level (public, internal, confidential, restricted)\n- Data schema/structure\n- Content categories\n- PII presence\n\nResponsibilities:\n- Detect PII via pattern matching\n- Classify sensitivity based on content\n- Categorize content\n\nDoes NOT:\n- Enforce policies (policy gate does that)\n- Block activation (orchestrator does that)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute"
            ],
            "line": 453
          },
          {
            "name": "ActivateHandler",
            "docstring": "GAP-076: Activate knowledge plane.\n\nFinal activation steps before the plane becomes operational.\n\nResponsibilities:\n- Validate policies are bound\n- Initialize runtime state\n- Set up access controls\n\nDoes NOT:\n- Check policy gate (orchestrator does that via GAP-087)\n- Emit activation event (orchestrator does that)\n\nNote: This handler runs AFTER the policy gate check.\nThe orchestrator calls GAP-087 policy gate first, then this handler.",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_simulate_activation"
            ],
            "line": 566
          },
          {
            "name": "GovernHandler",
            "docstring": "GAP-077: Runtime governance hooks.\n\nCalled on every access to the knowledge plane to emit governance evidence.\n\nResponsibilities:\n- Emit access evidence\n- Track usage metrics\n- Validate access context\n\nDoes NOT:\n- Enforce policies (runtime enforcer does that)\n- Block access (returns evidence, enforcer decides)\n\nNote: This is not a state transition handler.\nIt's called at runtime when the plane is ACTIVE.",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute"
            ],
            "line": 645
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.models.knowledge_lifecycle",
            "names": [
              "KnowledgePlaneLifecycleState"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.lifecycle_stages_base",
            "names": [
              "BaseStageHandler",
              "StageContext",
              "StageResult",
              "StageStatus"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "pool_manager.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/lifecycle/engines/pool_manager.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 606,
        "module_docstring": "Connection Pool Manager (GAP-172)\n\nManages connection pools for various services with:\n- Health checking\n- Per-tenant limits\n- Metrics\n- Graceful shutdown",
        "functions": [],
        "classes": [
          {
            "name": "PoolType",
            "docstring": "Types of connection pools.",
            "methods": [],
            "line": 41
          },
          {
            "name": "PoolStatus",
            "docstring": "Pool health status.",
            "methods": [],
            "line": 50
          },
          {
            "name": "PoolConfig",
            "docstring": "Configuration for a connection pool.",
            "methods": [],
            "line": 60
          },
          {
            "name": "PoolStats",
            "docstring": "Statistics for a connection pool.",
            "methods": [
              "to_dict"
            ],
            "line": 86
          },
          {
            "name": "PoolHandle",
            "docstring": "Handle to a managed connection pool.",
            "methods": [],
            "line": 131
          },
          {
            "name": "ConnectionPoolManager",
            "docstring": "Unified connection pool manager.\n\nFeatures:\n- Manages multiple pool types (database, redis, http)\n- Health checking with automatic status updates\n- Per-tenant connection limits\n- Graceful shutdown\n- Metrics collection",
            "methods": [
              "__init__",
              "start",
              "stop",
              "create_database_pool",
              "create_redis_pool",
              "create_http_pool",
              "get_pool",
              "acquire_connection",
              "release_connection",
              "close_pool",
              "get_stats",
              "health_check",
              "_health_check_loop",
              "list_pools"
            ],
            "line": 143
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "knowledge_lifecycle_manager.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/lifecycle/knowledge_lifecycle_manager.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 908,
        "module_docstring": "GAP-086: Knowledge Lifecycle Manager\n\nTHE ORCHESTRATOR \u2014 Single service owning entire knowledge plane lifecycle.\n\nARCHITECTURAL PRINCIPLE:\n    Lifecycle operations are governance-controlled, not user-controlled.\n    SDK calls REQUEST transitions. This manager DECIDES.\n    Policy + state machine ARBITRATE.\n    Users never force transitions directly.\n\nRESPONSIBILITIES:\n1. Enforce state machine transitions (GAP-089)\n2. Coordinate with policy gates (GAP-087)\n3. Emit audit events for all transitions (GAP-088)\n4. Coordinate async background jobs\n5. Block illegal transitions with clear reasons\n\nDESIGN INVARIANTS:\n- MANAGER-001: All transitions go through this manager\n- MANAGER-002: No transition without audit event\n- MANAGER-003: Policy gates are mandatory for protected transitions\n- MANAGER-004: Failed transitions leave state unchanged\n- MANAGER-005: Async jobs report completion back to manager",
        "functions": [
          {
            "name": "utc_now",
            "signature": "() -> datetime",
            "docstring": "Return timezone-aware UTC datetime.",
            "is_async": false,
            "line": 65
          },
          {
            "name": "generate_id",
            "signature": "(prefix: str = 'kp') -> str",
            "docstring": "Generate a unique ID with prefix.",
            "is_async": false,
            "line": 70
          },
          {
            "name": "get_knowledge_lifecycle_manager",
            "signature": "() -> KnowledgeLifecycleManager",
            "docstring": "Get the singleton KnowledgeLifecycleManager instance.",
            "is_async": false,
            "line": 883
          },
          {
            "name": "reset_manager",
            "signature": "() -> None",
            "docstring": "Reset the singleton instance (for testing).",
            "is_async": false,
            "line": 891
          }
        ],
        "classes": [
          {
            "name": "GateDecision",
            "docstring": "Policy gate decision.",
            "methods": [],
            "line": 80
          },
          {
            "name": "GateResult",
            "docstring": "Result of a policy gate check.",
            "methods": [
              "__bool__",
              "allowed",
              "blocked",
              "pending"
            ],
            "line": 88
          },
          {
            "name": "LifecycleAuditEventType",
            "docstring": "Types of lifecycle audit events.",
            "methods": [],
            "line": 124
          },
          {
            "name": "LifecycleAuditEvent",
            "docstring": "Audit event for lifecycle transitions (GAP-088).",
            "methods": [
              "to_dict"
            ],
            "line": 136
          },
          {
            "name": "KnowledgePlane",
            "docstring": "In-memory representation of a knowledge plane.",
            "methods": [
              "record_state_change"
            ],
            "line": 178
          },
          {
            "name": "TransitionRequest",
            "docstring": "Request to transition a knowledge plane to a new state.",
            "methods": [],
            "line": 221
          },
          {
            "name": "TransitionResponse",
            "docstring": "Response from a transition attempt.",
            "methods": [
              "to_dict"
            ],
            "line": 235
          },
          {
            "name": "KnowledgeLifecycleManager",
            "docstring": "GAP-086: Knowledge Lifecycle Manager \u2014 THE ORCHESTRATOR.\n\nSingle service owning entire knowledge plane lifecycle.\n\nUsage:\n    manager = KnowledgeLifecycleManager()\n\n    # Register a new plane\n    response = manager.handle_transition(TransitionRequest(\n        plane_id=\"new\",\n        tenant_id=\"tenant-123\",\n        action=LifecycleAction.REGISTER,\n        actor_id=\"user-456\",\n    ))\n\n    # Check current state\n    state = manager.get_state(\"plane-id\")\n\n    # Wait for state\n    reached = manager.wait_until(\"plane-id\", KnowledgePlaneLifecycleState.ACTIVE)",
            "methods": [
              "__init__",
              "handle_transition",
              "_handle_register",
              "get_state",
              "get_plane",
              "get_history",
              "get_audit_log",
              "get_next_action",
              "can_transition_to",
              "_default_policy_gate",
              "set_policy_gate",
              "_emit_transition_event",
              "_emit_blocked_event",
              "_default_audit_sink",
              "set_audit_sink",
              "_start_async_job",
              "_get_job_type_for_state",
              "_default_job_scheduler",
              "complete_job",
              "bind_policy",
              "unbind_policy",
              "approve_purge"
            ],
            "line": 269
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.models.knowledge_lifecycle",
            "names": [
              "KnowledgePlaneLifecycleState",
              "LifecycleAction",
              "TransitionResult",
              "is_valid_transition",
              "validate_transition",
              "get_action_for_transition",
              "get_transition_for_action",
              "get_next_onboarding_state",
              "get_next_offboarding_state"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [],
        "all_exports": [
          "KnowledgeLifecycleManager",
          "KnowledgePlane",
          "TransitionRequest",
          "TransitionResponse",
          "GateDecision",
          "GateResult",
          "LifecycleAuditEventType",
          "LifecycleAuditEvent",
          "get_knowledge_lifecycle_manager",
          "reset_manager"
        ]
      },
      {
        "file_name": "knowledge_sdk.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/lifecycle/knowledge_sdk.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 971,
        "module_docstring": "GAP-083-085: Knowledge SDK Fa\u00e7ade\n\nA thin, state-driven, async-aware SDK interface over KnowledgeLifecycleManager.\n\nARCHITECTURAL PRINCIPLE:\n    SDK calls REQUEST transitions.\n    LifecycleManager DECIDES.\n    Policy + state machine ARBITRATE.\n\nDESIGN INVARIANTS:\n- SDK-001: SDK does NOT force transitions \u2014 it requests them\n- SDK-002: SDK does NOT manage state \u2014 orchestrator does\n- SDK-003: SDK does NOT bypass policy gates \u2014 gates are mandatory\n- SDK-004: SDK provides async-aware wait semantics\n- SDK-005: SDK returns rich results, not exceptions\n\nWHY THIN:\n- If SDK owns state logic, you get split-brain with orchestrator\n- If SDK bypasses gates, you lose governance\n- If SDK throws exceptions, you lose structured outcomes\n\nCOVERAGE:\n- GAP-083: Onboarding SDK methods (register, verify, ingest, index, classify, activate)\n- GAP-084: Offboarding SDK methods (deregister, deactivate, archive, purge)\n- GAP-085: Wait semantics and state queries",
        "functions": [
          {
            "name": "create_knowledge_sdk",
            "signature": "(tenant_id: str, actor_id: Optional[str] = None) -> KnowledgeSDK",
            "docstring": "Create a KnowledgeSDK instance for a tenant.\n\nArgs:\n    tenant_id: Tenant ID (required)\n    actor_id: Optional actor ID for audit trails\n\nReturns:\n    KnowledgeSDK instance bound to the tenant",
            "is_async": false,
            "line": 947
          }
        ],
        "classes": [
          {
            "name": "KnowledgePlaneConfig",
            "docstring": "Configuration for creating a knowledge plane.",
            "methods": [],
            "line": 66
          },
          {
            "name": "WaitOptions",
            "docstring": "Options for wait operations.",
            "methods": [],
            "line": 76
          },
          {
            "name": "SDKResult",
            "docstring": "Structured result from SDK operations.\n\nSDK-005: SDK returns rich results, not exceptions.\nEvery SDK method returns this type with success/failure and context.",
            "methods": [
              "from_transition_response",
              "error",
              "to_dict"
            ],
            "line": 89
          },
          {
            "name": "PlaneInfo",
            "docstring": "Information about a knowledge plane for SDK consumers.",
            "methods": [
              "from_plane",
              "to_dict"
            ],
            "line": 158
          },
          {
            "name": "KnowledgeSDK",
            "docstring": "GAP-083-085: Knowledge SDK Fa\u00e7ade.\n\nA thin, state-driven, async-aware SDK interface.\n\nUsage:\n    sdk = KnowledgeSDK(tenant_id=\"tenant-123\")\n\n    # Register a new knowledge plane\n    result = sdk.register(KnowledgePlaneConfig(\n        name=\"My Knowledge Base\",\n        connection_string=\"postgresql://...\",\n    ))\n\n    if result.success:\n        plane_id = result.plane_id\n\n        # Progress through lifecycle\n        await sdk.verify(plane_id)\n        await sdk.wait_until(plane_id, KnowledgePlaneLifecycleState.VERIFIED)\n\n        await sdk.ingest(plane_id)\n        await sdk.wait_until(plane_id, KnowledgePlaneLifecycleState.INDEXED)\n\n        # ... continue through activation\n\nIMPORTANT:\n    SDK calls REQUEST transitions. This SDK does NOT guarantee success.\n    The KnowledgeLifecycleManager decides whether transitions are allowed\n    based on state machine rules and policy gates.",
            "methods": [
              "__init__",
              "register",
              "verify",
              "ingest",
              "index",
              "classify",
              "request_activation",
              "activate",
              "deregister",
              "cancel_deregister",
              "deactivate",
              "archive",
              "purge",
              "get_state",
              "get_plane",
              "get_history",
              "get_audit_log",
              "get_next_action",
              "can_transition_to",
              "wait_until",
              "wait_until_sync",
              "bind_policy",
              "unbind_policy",
              "approve_purge"
            ],
            "line": 238
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.models.knowledge_lifecycle",
            "names": [
              "KnowledgePlaneLifecycleState",
              "LifecycleAction"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.lifecycle.knowledge_lifecycle_manager",
            "names": [
              "KnowledgeLifecycleManager",
              "KnowledgePlane",
              "TransitionRequest",
              "TransitionResponse",
              "GateDecision",
              "get_knowledge_lifecycle_manager"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": [
          "KnowledgeSDK",
          "KnowledgePlaneConfig",
          "WaitOptions",
          "SDKResult",
          "PlaneInfo",
          "create_knowledge_sdk"
        ]
      },
      {
        "file_name": "stages.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/lifecycle/stages.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 105,
        "module_docstring": "Canonical stage surface for the knowledge plane lifecycle.\n\nThis module exists to prevent split-brain imports between:\n- app.services.lifecycle_stages (legacy surface)\n- hoc_spine lifecycle engines/drivers (runtime surface)\n\nAll stage handlers and base types should be imported from here going forward.",
        "functions": [],
        "classes": [],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.services.lifecycle_stages_base",
            "names": [
              "BaseStageHandler",
              "StageContext",
              "StageHandler",
              "StageRegistry",
              "StageResult",
              "StageStatus"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.lifecycle.engines.onboarding",
            "names": [
              "ActivateHandler",
              "ClassifyHandler",
              "GovernHandler",
              "IndexHandler",
              "IngestHandler",
              "RegisterHandler",
              "VerifyHandler"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.lifecycle.engines.offboarding",
            "names": [
              "ArchiveHandler",
              "DeactivateHandler",
              "DeregisterHandler",
              "PurgeHandler",
              "VerifyDeactivateHandler"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.lifecycle.drivers.execution",
            "names": [
              "ClassificationExecutor",
              "ClassificationResult",
              "DataIngestionExecutor",
              "IndexingExecutor",
              "IndexingResult",
              "IngestionBatch",
              "IngestionResult",
              "IngestionSourceType",
              "PIIDetection",
              "PIIType",
              "SensitivityLevel",
              "get_classification_executor",
              "get_indexing_executor",
              "get_ingestion_executor",
              "reset_executors"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": [
          "BaseStageHandler",
          "StageContext",
          "StageHandler",
          "StageRegistry",
          "StageResult",
          "StageStatus",
          "RegisterHandler",
          "VerifyHandler",
          "IngestHandler",
          "IndexHandler",
          "ClassifyHandler",
          "ActivateHandler",
          "GovernHandler",
          "DeregisterHandler",
          "VerifyDeactivateHandler",
          "DeactivateHandler",
          "ArchiveHandler",
          "PurgeHandler",
          "DataIngestionExecutor",
          "IngestionBatch",
          "IngestionResult",
          "IngestionSourceType",
          "get_ingestion_executor",
          "IndexingExecutor",
          "IndexingResult",
          "get_indexing_executor",
          "ClassificationExecutor",
          "ClassificationResult",
          "SensitivityLevel",
          "PIIType",
          "PIIDetection",
          "get_classification_executor",
          "reset_executors"
        ]
      },
      {
        "file_name": "operation_registry.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/operation_registry.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 620,
        "module_docstring": "Operation Registry (L4 Orchestrator)\n\nCentral dispatch layer for domain operations. L2 APIs call this instead of\nimporting L5 engines directly.\n\nFlow:\n    L2 HTTP \u2192 OperationRegistry.execute(op_name, ctx) \u2192 L5 handler \u2192 L6 driver\n\nWhat the registry adds to every operation:\n    1. Authority check (is governance active? degraded mode?)\n    2. Audit record (who called what, when, outcome)\n    3. Consistent error handling (L5 exceptions \u2192 OperationResult)\n    4. Single dispatch point (operation name \u2192 handler lookup)\n\nWhat the registry does NOT do:\n    - Execute business logic (that stays in L5)\n    - Make decisions (authority is checked, not created here)\n\nTransaction ownership (PIN-520, TRANSACTION_COORDINATION_RATIONALE.md):\n    - L4 handlers OWN transaction boundaries (commit/rollback)\n    - L5 engines may call session.add(), session.flush()\n    - L6 drivers may call session.add(), session.execute() - NEVER commit\n    - Session comes from L2 via FastAPI DI, but L4 decides when to commit\n\nUsage:\n    # L2 API file (e.g., hoc/api/cus/overview/overview.py)\n    from app.hoc.cus.hoc_spine.orchestrator.operation_registry import (\n        get_operation_registry,\n        OperationContext,\n    )\n\n    registry = get_operation_registry()\n    result = await registry.execute(\"overview.query\", OperationContext(\n        session=session,\n        tenant_id=tenant_id,\n        params={\"endpoint\": \"highlights\"},\n    ))\n    if not result.success:\n        raise HTTPException(status_code=500, detail=result.error)\n    return result.data\n\nHandler registration:\n    # In hoc_spine/orchestrator/handlers/{domain}_handler.py\n    from app.hoc.cus.hoc_spine.orchestrator.operation_registry import (\n        OperationHandler,\n        OperationContext,\n        OperationResult,\n    )\n\n    class OverviewQueryHandler(OperationHandler):\n        async def execute(self, ctx: OperationContext) -> OperationResult:\n            from app.hoc.cus.overview.L5_engines.overview_facade import get_overview_facade\n            facade = get_overview_facade()\n            data = await facade.get_highlights(session=ctx.session, tenant_id=ctx.tenant_id)\n            return OperationResult.ok(data)\n\n    # Registration (called once at startup)\n    registry = get_operation_registry()\n    registry.register(\"overview.query\", OverviewQueryHandler())",
        "functions": [
          {
            "name": "get_session_dep",
            "signature": "() -> AsyncGenerator[AsyncSession, None]",
            "docstring": "L4-provided session dependency for L2 endpoints.\n\nL2 files must NOT import sqlalchemy or app.db directly.\nInstead, they import this dependency from L4 (operation_registry)\nand use it with FastAPI Depends():\n\n    from app.hoc.cus.hoc_spine.orchestrator.operation_registry import get_session_dep\n    session = Depends(get_session_dep)\n\nThis keeps L2 free of DB/ORM imports while still providing\nthe session needed for OperationContext construction.",
            "is_async": true,
            "line": 533
          },
          {
            "name": "get_sync_session_dep",
            "signature": "() -> Generator",
            "docstring": "L4-provided SYNC session dependency for L2 endpoints that use\nsynchronous Session (sqlmodel Session).\n\nUsage:\n    from app.hoc.cus.hoc_spine.orchestrator.operation_registry import get_sync_session_dep\n    session = Depends(get_sync_session_dep)",
            "is_async": false,
            "line": 553
          },
          {
            "name": "sql_text",
            "signature": "(sql: str)",
            "docstring": "L4-provided wrapper for sqlalchemy text().\n\nL2 files must not import sqlalchemy directly. Use this helper\nfor raw SQL text queries:\n\n    from app.hoc.cus.hoc_spine.orchestrator.operation_registry import sql_text\n    result = await session.execute(sql_text(\"SELECT ...\"), params)",
            "is_async": false,
            "line": 567
          },
          {
            "name": "get_async_session_context",
            "signature": "()",
            "docstring": "L4-provided async session context manager for L2 endpoints that\nuse `async with get_async_session() as session:` pattern.\n\nUsage:\n    from app.hoc.cus.hoc_spine.orchestrator.operation_registry import get_async_session_context\n    async with get_async_session_context() as session:\n        ...",
            "is_async": true,
            "line": 583
          },
          {
            "name": "get_operation_registry",
            "signature": "() -> OperationRegistry",
            "docstring": "Get the operation registry singleton.\n\nReturns the same instance for the lifetime of the process.\nHandlers register against this instance at import time.",
            "is_async": false,
            "line": 599
          },
          {
            "name": "reset_operation_registry",
            "signature": "() -> None",
            "docstring": "Reset the registry singleton. FOR TESTING ONLY.\n\nProduction code must never call this.",
            "is_async": false,
            "line": 612
          }
        ],
        "classes": [
          {
            "name": "OperationContext",
            "docstring": "Immutable context passed to every operation handler.\n\nThe session comes from L2 via FastAPI DI. L4 handlers own transaction\nboundaries (commit/rollback).\n\nSession patterns:\n    - Async operations: session is AsyncSession (ctx.session)\n    - Sync operations: session=None, pass sync session via params[\"sync_session\"]\n    - Self-contained: session=None, L4 handler creates session internally\n\nNote: sync_session smuggling via params is the accepted pattern until\nwe refactor to explicit dual-session fields (future work).",
            "methods": [],
            "line": 109
          },
          {
            "name": "OperationResult",
            "docstring": "Outcome of an operation dispatch.\n\nL2 code inspects .success and either uses .data or raises\nbased on .error / .error_code.",
            "methods": [
              "ok",
              "fail"
            ],
            "line": 134
          },
          {
            "name": "OperationHandler",
            "docstring": "Protocol for domain operation handlers.\n\nEach handler wraps ONE L5 facade call. The handler:\n  - Receives an OperationContext (session, tenant, params)\n  - Calls the L5 facade\n  - Returns an OperationResult\n\nThe handler MUST NOT:\n  - Import from L2\n  - Create sessions\n  - Call other domain handlers directly (use registry for cross-domain)\n\nTransaction ownership (PIN-520):\n  - L4 handlers/coordinators own transaction boundaries for write operations.\n  - L5 engines may call session.add(), session.flush().\n  - L6 drivers may call session.add(), session.execute() \u2014 NEVER commit/rollback.\n  - Read-only operations should not commit/rollback.",
            "methods": [
              "execute"
            ],
            "line": 167
          },
          {
            "name": "OperationRegistry",
            "docstring": "Central dispatch for domain operations.\n\nMaps operation name strings (e.g., \"policies.query\") to OperationHandler\ninstances. L2 APIs call execute() instead of importing L5 directly.\n\nAuthority Gate:\n    Before dispatching, checks governance runtime state.\n    If governance is disabled (kill switch), operations still execute\n    but are tagged as unguarded in audit.\n    If degraded mode is active, a warning is logged.\n\nAudit & Consequences:\n    Every dispatch logs: operation name, tenant, duration, outcome.\n    V3: Structured logging + AuditStore persistence + Consequences pipeline.\n    Dispatch records and consequences are post-commit only (Constitution \u00a72.3).",
            "methods": [
              "__init__",
              "register",
              "freeze",
              "execute",
              "_check_authority",
              "_audit_dispatch",
              "operations",
              "operation_count",
              "is_frozen",
              "has_operation",
              "get_handler",
              "status"
            ],
            "line": 198
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 84
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 85
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 86
          },
          {
            "module": "contextlib",
            "names": [
              "asynccontextmanager"
            ],
            "is_relative": false,
            "line": 87
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "AsyncGenerator",
              "Generator",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 88
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 90
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 95
          }
        ],
        "constants": [
          {
            "name": "REGISTRY_VERSION",
            "line": 100
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "phase_status_invariants.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/phase_status_invariants.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 361,
        "module_docstring": "Module: phase_status_invariants\nPurpose: Enforce phase-status invariants using GovernanceConfig.\n\nThe phase_status_invariant_enforce flag in GovernanceConfig controls\nwhether invalid phase-status combinations are blocked.\n\nPhase-Status Invariants:\n    - CREATED, AUTHORIZED: status must be \"queued\"\n    - EXECUTING, GOVERNANCE_CHECK, FINALIZING: status must be \"running\"\n    - COMPLETED: status must be \"succeeded\"\n    - FAILED: status must be \"failed\", \"failed_policy\", \"cancelled\", or \"retry\"\n\nWhen enforcement is enabled, attempting an invalid combination raises\nPhaseStatusInvariantEnforcementError.\n\nExports:\n    - PhaseStatusInvariantEnforcementError: Raised on violation\n    - PhaseStatusInvariantChecker: Main checker class\n    - check_phase_status_invariant: Quick helper function",
        "functions": [
          {
            "name": "check_phase_status_invariant",
            "signature": "(phase: str, status: str, enforcement_enabled: bool = True) -> InvariantCheckResponse",
            "docstring": "Quick helper to check a phase-status invariant.\n\nArgs:\n    phase: Phase name\n    status: Status value\n    enforcement_enabled: Whether enforcement is enabled\n\nReturns:\n    InvariantCheckResponse with validation result",
            "is_async": false,
            "line": 324
          },
          {
            "name": "ensure_phase_status_invariant",
            "signature": "(phase: str, status: str, enforcement_enabled: bool = True) -> None",
            "docstring": "Quick helper to ensure phase-status invariant or raise error.\n\nArgs:\n    phase: Phase name\n    status: Status value\n    enforcement_enabled: Whether enforcement is enabled\n\nRaises:\n    PhaseStatusInvariantEnforcementError: If invalid and enforcement enabled",
            "is_async": false,
            "line": 344
          }
        ],
        "classes": [
          {
            "name": "InvariantCheckResult",
            "docstring": "Result of an invariant check.",
            "methods": [],
            "line": 47
          },
          {
            "name": "PhaseStatusInvariantEnforcementError",
            "docstring": "Raised when phase-status invariant enforcement fails.\n\nThis error indicates that an invalid phase-status combination\nwas attempted when enforcement is enabled.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 68
          },
          {
            "name": "InvariantCheckResponse",
            "docstring": "Response from an invariant check.",
            "methods": [
              "to_dict"
            ],
            "line": 103
          },
          {
            "name": "PhaseStatusInvariantChecker",
            "docstring": "Checks and enforces phase-status invariants.\n\nGAP-051: Add invariant checks to ROK.\n\nThe checker validates that phase-status combinations are valid\nand can raise errors when enforcement is enabled.\n\nUsage:\n    checker = PhaseStatusInvariantChecker(enforcement_enabled=True)\n\n    # Before a phase transition\n    checker.ensure_valid(\"EXECUTING\", \"running\")\n\n    # Or check without raising\n    response = checker.check(\"EXECUTING\", \"running\")\n    if not response.is_valid and response.enforcement_enabled:\n        handle_invariant_violation()",
            "methods": [
              "__init__",
              "from_governance_config",
              "enforcement_enabled",
              "get_allowed_statuses",
              "is_valid_combination",
              "check",
              "ensure_valid",
              "should_allow_transition"
            ],
            "line": 127
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "FrozenSet",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "plan_generation_engine.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/plan_generation_engine.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 265,
        "module_docstring": "Domain engine for plan generation.\n\nThis L4 engine contains the authoritative logic for:\n1. Memory context retrieval\n2. Plan generation via planner\n3. Plan validation\n\nL5 workers must receive plans from this engine (via run.plan_json),\nnot generate their own plans.\n\nReference: PIN-257 Phase R-2\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md",
        "functions": [
          {
            "name": "generate_plan_for_run",
            "signature": "(agent_id: str, goal: str, run_id: str) -> PlanGenerationResult",
            "docstring": "Convenience function to generate a plan for a run.\n\nThis is the L4 entry point for plan generation. It should be called\nby the run creation flow (in L2 API) to generate plans before\nthe run is queued for execution.\n\nArgs:\n    agent_id: Agent ID\n    goal: Run goal\n    run_id: Run ID\n\nReturns:\n    PlanGenerationResult with the generated plan\n\nReference: PIN-257 Phase R-2",
            "is_async": false,
            "line": 219
          }
        ],
        "classes": [
          {
            "name": "PlanGenerationContext",
            "docstring": "Context for plan generation.",
            "methods": [],
            "line": 63
          },
          {
            "name": "PlanGenerationResult",
            "docstring": "Result of plan generation.",
            "methods": [],
            "line": 73
          },
          {
            "name": "PlanGenerationEngine",
            "docstring": "L4 Domain Engine for plan generation.\n\nThis engine contains ALL plan generation logic that was previously\nscattered in L5 runner.py. It generates plans from goals using\nmemory context and the configured planner.\n\nL5 workers must NOT:\n- Import memory.get_retriever()\n- Import planners.get_planner()\n- Generate plans inline\n\nL5 workers must ONLY:\n- Execute plans provided via run.plan_json\n- Fail if no plan is provided\n\nReference: PIN-257 Phase R-2\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md Section 3.2",
            "methods": [
              "__init__",
              "generate"
            ],
            "line": 90
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.memory",
            "names": [
              "get_retriever"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.planners",
            "names": [
              "get_planner"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.skills",
            "names": [
              "get_skill_manifest"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.utils.budget_tracker",
            "names": [
              "get_budget_tracker"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.utils.plan_inspector",
            "names": [
              "validate_plan"
            ],
            "is_relative": false,
            "line": 55
          }
        ],
        "constants": [],
        "all_exports": [
          "PlanGenerationContext",
          "PlanGenerationResult",
          "PlanGenerationEngine",
          "generate_plan_for_run"
        ]
      },
      {
        "file_name": "run_governance_facade.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/orchestrator/run_governance_facade.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 422,
        "module_docstring": "Run Governance Facade (L4 Domain Logic)\n\nThis facade provides the external interface for governance operations\nduring run execution. The L5 runner MUST use this facade instead of\ndirectly importing L4 engines.\n\nWhy This Facade Exists (PIN-454):\n- Prevents L5\u2192L4 layer violations (runner importing engines directly)\n- Centralizes governance logic for run lifecycle\n- Provides RAC (Runtime Audit Contract) acknowledgment emission\n- Single point for audit expectation/acknowledgment emission\n\nWrapped Services:\n- LessonsLearnedEngine: Learning from run outcomes\n- PolicyViolationService: Policy evaluation for runs\n\nRAC Integration (PIN-454):\n- Emits acknowledgments after policy evaluation\n- Domain: POLICIES\n- Action: EVALUATE_POLICY\n\nUsage:\n    from app.hoc.cus.hoc_spine.orchestrator.run_governance_facade import get_run_governance_facade\n\n    facade = get_run_governance_facade()\n\n    # Policy evaluation (emits RAC ack automatically)\n    policy_id = facade.create_policy_evaluation(\n        run_id=run_id,\n        tenant_id=tenant_id,\n        run_status=\"succeeded\",\n    )\n\n    # Lesson emission\n    lesson_id = facade.emit_near_threshold_lesson(\n        tenant_id=tenant_id,\n        metric=\"budget\",\n        utilization=87.5,\n        ...\n    )",
        "functions": [
          {
            "name": "wire_run_governance_facade",
            "signature": "() -> RunGovernanceFacade",
            "docstring": "Wire the RunGovernanceFacade singleton with real L5 engines.\n\nCalled once from bootstrap_hoc_spine() at application startup.\nAfter this call, get_run_governance_facade() returns a facade\nwith live lessons_engine and policy_evaluator \u2014 no silent no-ops.\n\nEngines injected:\n    - lessons_engine: LessonsLearnedEngine (policies/L5_engines)\n    - policy_evaluator: create_policy_evaluation_sync (incidents/L5_engines)\n\nReturns:\n    The wired RunGovernanceFacade singleton",
            "is_async": false,
            "line": 335
          },
          {
            "name": "get_run_governance_facade",
            "signature": "() -> RunGovernanceFacade",
            "docstring": "Get the run governance facade instance.\n\nThis is the recommended way to access governance operations from\nthe L5 worker runtime.\n\nReturns:\n    RunGovernanceFacade instance (wired at startup via wire_run_governance_facade)\n\nRaises:\n    RuntimeError: If called before wire_run_governance_facade() at startup",
            "is_async": false,
            "line": 403
          }
        ],
        "classes": [
          {
            "name": "RunGovernanceFacade",
            "docstring": "Facade for run governance operations.\n\nThis is the ONLY entry point for L5 worker code to interact with\nlessons learned and policy evaluation services.\n\nLayer: L4 (Domain Logic)\nCallers: RunRunner (L5)",
            "methods": [
              "__init__",
              "_lessons",
              "create_policy_evaluation",
              "_emit_ack",
              "emit_near_threshold_lesson",
              "emit_critical_success_lesson"
            ],
            "line": 75
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.protocols",
            "names": [
              "LessonsEnginePort",
              "PolicyEvaluationPort"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [
          {
            "name": "RAC_ENABLED",
            "line": 72
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "agent.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/agent.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 229,
        "module_docstring": null,
        "functions": [
          {
            "name": "_utc_now",
            "signature": "() -> datetime",
            "docstring": "Return timezone-aware UTC datetime.",
            "is_async": false,
            "line": 30
          }
        ],
        "classes": [
          {
            "name": "AgentStatus",
            "docstring": "Agent operational status.",
            "methods": [],
            "line": 38
          },
          {
            "name": "PlannerType",
            "docstring": "Supported planner backends.",
            "methods": [],
            "line": 47
          },
          {
            "name": "PlannerConfig",
            "docstring": "Configuration for the agent's planner.\n\nControls how goals are translated into execution plans.",
            "methods": [],
            "line": 57
          },
          {
            "name": "RateLimitConfig",
            "docstring": "Rate limiting configuration for an agent.",
            "methods": [],
            "line": 84
          },
          {
            "name": "BudgetConfig",
            "docstring": "Budget tracking configuration for an agent.",
            "methods": [
              "remaining_cents",
              "usage_percent"
            ],
            "line": 94
          },
          {
            "name": "AgentCapabilities",
            "docstring": "Defines what an agent can and cannot do.\n\nControls access to skills, external resources,\nand establishes security boundaries.",
            "methods": [
              "can_use_skill",
              "can_access_domain"
            ],
            "line": 119
          },
          {
            "name": "AgentConfig",
            "docstring": "Complete configuration for an agent.\n\nCombines capabilities, planner settings, rate limits,\nand budget tracking.",
            "methods": [],
            "line": 188
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "ConfigDict",
              "Field"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "retry",
            "names": [
              "RetryPolicy"
            ],
            "is_relative": true,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "anomaly_types.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/anomaly_types.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 57,
        "module_docstring": "Anomaly Types (Spine Schemas)\n\nCross-domain fact types for anomaly detection \u2192 incident creation flow.\n\nAnalytics emits CostAnomalyFact; incidents bridge ingests it.\nThis type lives in hoc_spine because it crosses domain boundaries.",
        "functions": [],
        "classes": [
          {
            "name": "CostAnomalyFact",
            "docstring": "Pure fact emitted by analytics when a cost anomaly is detected.\n\nThis dataclass contains NO database references, NO session objects,\nand NO imports from analytics. It is a pure data transfer object.\n\nAnalytics engines emit this; the incidents bridge decides what to do with it.\n\nMoved from incidents/L5_engines/anomaly_bridge.py to hoc_spine/schemas/\nper PIN-510 Phase 1C (schema admission: >=2 consumers, facts only, append-only).",
            "methods": [],
            "line": 30
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": [
          "CostAnomalyFact"
        ]
      },
      {
        "file_name": "artifact.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/artifact.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 158,
        "module_docstring": null,
        "functions": [
          {
            "name": "_utc_now",
            "signature": "() -> datetime",
            "docstring": "UTC timestamp (inlined to keep schemas pure \u2014 no service imports).",
            "is_async": false,
            "line": 29
          }
        ],
        "classes": [
          {
            "name": "ArtifactType",
            "docstring": "Type of artifact produced by a run.",
            "methods": [],
            "line": 34
          },
          {
            "name": "StorageBackend",
            "docstring": "Where the artifact is stored.",
            "methods": [],
            "line": 49
          },
          {
            "name": "Artifact",
            "docstring": "An artifact produced by a run or step.\n\nArtifacts capture outputs, files, and data produced\nduring execution for later retrieval and analysis.",
            "methods": [
              "is_inline",
              "has_content",
              "get_inline_content"
            ],
            "line": 58
          },
          {
            "name": "ArtifactReference",
            "docstring": "Lightweight reference to an artifact.\n\nUsed when you need to reference an artifact without\nloading its full content.",
            "methods": [
              "from_artifact"
            ],
            "line": 134
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "ConfigDict",
              "Field"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "authority_decision.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/authority_decision.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 238,
        "module_docstring": "AuthorityDecision \u2014 Unified Schema for L4 Authority Gates\n\nAll authority checks in hoc_spine return this unified schema.\nThis ensures consistent handling of allow/deny/degraded states\nacross concurrent_runs, degraded_mode_checker, contract_engine, etc.\n\nUsage:\n    from app.hoc.cus.hoc_spine.schemas.authority_decision import AuthorityDecision\n\n    # In authority module\n    def check_concurrent_runs(tenant_id: str, limit: int) -> AuthorityDecision:\n        current = get_active_runs(tenant_id)\n        if current >= limit:\n            return AuthorityDecision.deny(\n                reason=f\"Concurrent run limit ({limit}) exceeded\",\n                code=\"CONCURRENT_LIMIT_EXCEEDED\",\n            )\n        return AuthorityDecision.allow()\n\n    # In executor\n    authority = check_concurrent_runs(tenant_id, limit=5)\n    if not authority.allowed:\n        return OperationResult.fail(authority.reason, authority.code)\n    if authority.degraded:\n        logger.warning(\"operation.degraded_mode\", extra={\"reason\": authority.reason})\n\nDesign Principles:\n    1. IMMUTABLE \u2014 frozen dataclass, no mutation after creation\n    2. EXPLICIT \u2014 allow/deny/degraded are separate states, not inferred\n    3. AUDITABLE \u2014 every decision has reason and optional code\n    4. COMPOSABLE \u2014 conditions list allows compound decisions",
        "functions": [],
        "classes": [
          {
            "name": "AuthorityDecision",
            "docstring": "Unified authority decision returned by all L4 authority checks.\n\nAttributes:\n    allowed: Whether the operation is permitted\n    reason: Human-readable explanation of the decision\n    degraded: Whether system is in degraded mode (operation allowed but flagged)\n    code: Machine-readable error/status code\n    conditions: List of conditions that affected the decision",
            "methods": [
              "allow",
              "deny",
              "allow_with_degraded_flag",
              "with_condition",
              "combine",
              "to_dict",
              "__str__"
            ],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "common.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/common.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 155,
        "module_docstring": "Common Data Contracts - Shared Infrastructure Types\n\nThese are NON-DOMAIN contracts used by both consoles:\n- Health checks\n- Error responses\n- Pagination\n\nThese are the ONLY contracts allowed to be shared between domains.\nDomain-specific data MUST NOT be in this module.\n\nFrozen: 2025-12-23 (M29)",
        "functions": [],
        "classes": [
          {
            "name": "HealthDTO",
            "docstring": "GET /health response.\n\nNon-authenticated health check.",
            "methods": [],
            "line": 44
          },
          {
            "name": "HealthDetailDTO",
            "docstring": "GET /health/detail response (if authenticated).\n\nDetailed health with component status.",
            "methods": [],
            "line": 56
          },
          {
            "name": "ErrorDTO",
            "docstring": "Standard error response.\n\nAll 4xx/5xx responses use this format.",
            "methods": [],
            "line": 75
          },
          {
            "name": "ValidationErrorDTO",
            "docstring": "422 Validation error response.\n\nPydantic validation errors.",
            "methods": [],
            "line": 88
          },
          {
            "name": "PaginationMetaDTO",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 105
          },
          {
            "name": "CursorPaginationMetaDTO",
            "docstring": "Cursor-based pagination metadata.",
            "methods": [],
            "line": 116
          },
          {
            "name": "ActionResultDTO",
            "docstring": "Generic action result (activate, deactivate, etc.).",
            "methods": [],
            "line": 130
          },
          {
            "name": "ContractVersionDTO",
            "docstring": "GET /api/v1/contracts/version response.\n\nContract version for client compatibility checks.",
            "methods": [],
            "line": 145
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "domain_enums.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/domain_enums.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 106,
        "module_docstring": "Domain-level enum mirrors.\n\nThese mirror the canonical enums in app.models so that\nL5 engines never need a runtime import of app.models.\nValues MUST stay in sync with the L7 originals.\n\nCanonical sources:\n- app/models/audit_ledger.py (PIN-413): ActorType, AuditEntityType, AuditEventType\n- app/models/killswitch.py: IncidentSeverity\n- app/models/contract.py: AuditVerdict",
        "functions": [],
        "classes": [
          {
            "name": "ActorType",
            "docstring": "Types of actors performing actions.\n\nMirror of app.models.audit_ledger.ActorType.",
            "methods": [],
            "line": 30
          },
          {
            "name": "AuditEntityType",
            "docstring": "Entity types tracked in audit ledger.\n\nMirror of app.models.audit_ledger.AuditEntityType.",
            "methods": [],
            "line": 41
          },
          {
            "name": "AuditEventType",
            "docstring": "Canonical audit events \u2014 only these create audit rows.\n\nMirror of app.models.audit_ledger.AuditEventType.",
            "methods": [],
            "line": 54
          },
          {
            "name": "IncidentSeverity",
            "docstring": "Incident severity levels.\n\nMirror of app.models.killswitch.IncidentSeverity.",
            "methods": [],
            "line": 85
          },
          {
            "name": "AuditVerdict",
            "docstring": "Audit verification verdict.\n\nMirror of app.models.contract.AuditVerdict.",
            "methods": [],
            "line": 97
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lifecycle_harness.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/lifecycle_harness.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 86,
        "module_docstring": "Lifecycle Harness Kit\n\nProtocol interfaces for lifecycle operations. These define the behavioral\ncontracts that L4 uses to interact with domain-specific lifecycle engines\nwithout direct cross-domain imports.\n\nFollows hoc_spine/schemas/protocols.py pattern (@runtime_checkable).",
        "functions": [],
        "classes": [
          {
            "name": "LifecycleReaderPort",
            "docstring": "Behavioral contract for lifecycle state reads.\n\nImplemented by: TenantLifecycleEngine (account/L5_engines)\nConsumed by: L4 handlers, lifecycle gate\nWired by: L4 handler (constructor injection)",
            "methods": [
              "get_state"
            ],
            "line": 31
          },
          {
            "name": "LifecycleWriterPort",
            "docstring": "Behavioral contract for lifecycle state mutations.\n\nImplemented by: TenantLifecycleEngine (account/L5_engines)\nConsumed by: L4 handlers\nWired by: L4 handler (constructor injection)",
            "methods": [
              "transition"
            ],
            "line": 46
          },
          {
            "name": "LifecycleGateDecision",
            "docstring": "Decision from lifecycle gate evaluation.\n\nUsed by middleware to decide whether to allow/deny a request\nbased on the entity's current lifecycle state.",
            "methods": [],
            "line": 68
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": [
          "LifecycleReaderPort",
          "LifecycleWriterPort",
          "LifecycleGateDecision"
        ]
      },
      {
        "file_name": "plan.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/plan.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 259,
        "module_docstring": null,
        "functions": [
          {
            "name": "_utc_now",
            "signature": "() -> datetime",
            "docstring": "UTC timestamp (inlined to keep schemas pure \u2014 no service imports).",
            "is_async": false,
            "line": 29
          }
        ],
        "classes": [
          {
            "name": "OnErrorPolicy",
            "docstring": "What to do when a step fails.",
            "methods": [],
            "line": 37
          },
          {
            "name": "StepStatus",
            "docstring": "Execution status of a plan step.",
            "methods": [],
            "line": 46
          },
          {
            "name": "ConditionOperator",
            "docstring": "Operators for step conditions.",
            "methods": [],
            "line": 57
          },
          {
            "name": "StepCondition",
            "docstring": "Condition for conditional step execution.\n\nAllows steps to be skipped based on previous step outputs.",
            "methods": [],
            "line": 70
          },
          {
            "name": "PlanStep",
            "docstring": "A single step in an execution plan.\n\nDefines what skill to run, with what parameters,\ndependencies, conditions, and error handling.",
            "methods": [
              "validate_fallback"
            ],
            "line": 82
          },
          {
            "name": "PlanMetadata",
            "docstring": "Metadata about the plan and how it was created.",
            "methods": [],
            "line": 151
          },
          {
            "name": "Plan",
            "docstring": "Complete execution plan for achieving a goal.\n\nThe plan is the contract between planner and executor.\nIt defines what steps to run and in what order.",
            "methods": [
              "validate_step_ids_unique",
              "validate_dependencies",
              "get_step",
              "get_ready_steps"
            ],
            "line": 165
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "ConfigDict",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "retry",
            "names": [
              "RetryPolicy"
            ],
            "is_relative": true,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "protocols.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/protocols.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 335,
        "module_docstring": "L1 Re-wiring Protocol Interfaces (PIN-513)\n\nThese Protocols define the behavioral contracts that L4 hoc_spine uses\nto interact with L5 domain engines WITHOUT direct cross-domain imports.\n\nEach Protocol is implemented by the target L5 engine and injected via\nconstructor or bridge at L4 wiring time.",
        "functions": [],
        "classes": [
          {
            "name": "LessonsEnginePort",
            "docstring": "Behavioral contract for lessons learned engine.\n\nImplemented by: LessonsLearnedEngine (policies/L5_engines)\nConsumed by: RunGovernanceFacade (L4)\nWired by: L4 orchestrator context",
            "methods": [
              "emit_near_threshold",
              "emit_critical_success"
            ],
            "line": 24
          },
          {
            "name": "PolicyEvaluationPort",
            "docstring": "Behavioral contract for policy evaluation service.\n\nImplemented by: create_policy_evaluation_sync (incidents/L5_engines)\nConsumed by: RunGovernanceFacade (L4)\nWired by: L4 orchestrator context",
            "methods": [
              "__call__"
            ],
            "line": 57
          },
          {
            "name": "TraceFacadePort",
            "docstring": "Behavioral contract for trace facade.\n\nImplemented by: TraceFacade (logs/L5_engines)\nConsumed by: TransactionCoordinator (L4)\nWired by: L4 orchestrator context",
            "methods": [
              "complete_trace_sync"
            ],
            "line": 77
          },
          {
            "name": "ConnectorLookupPort",
            "docstring": "Behavioral contract for connector registry lookup.\n\nImplemented by: ConnectorRegistry (integrations/L6_drivers)\nConsumed by: DataIngestionExecutor, IndexingExecutor (L4)\nWired by: L4 orchestrator execution context",
            "methods": [
              "get_connector"
            ],
            "line": 94
          },
          {
            "name": "ValidatorVerdictPort",
            "docstring": "Behavioral contract for CRM validator verdict type.\n\nImplemented by: ValidatorVerdict (account/L5_engines)\nConsumed by: ContractEngine (L4)\nWired by: Caller passes typed object",
            "methods": [
              "issue_type",
              "severity",
              "affected_capabilities",
              "recommended_action",
              "confidence_score",
              "reason",
              "analyzed_at"
            ],
            "line": 110
          },
          {
            "name": "EligibilityVerdictPort",
            "docstring": "Behavioral contract for eligibility verdict type.\n\nImplemented by: EligibilityVerdict (policies/L5_engines)\nConsumed by: ContractEngine (L4)\nWired by: Caller passes typed object",
            "methods": [
              "decision",
              "reason",
              "decided_at",
              "rule_results"
            ],
            "line": 141
          },
          {
            "name": "TraceStorePort",
            "docstring": "Behavioral contract for trace storage.\n\nImplemented by: SQLiteTraceStore, InMemoryTraceStore (logs/L6_drivers)\nConsumed by: Export bundle orchestration (wired by L4 / L5)\nWired by: L5 export_engine or L4 orchestrator\n\nPIN-521: Protocol enables cross-domain dependency injection without\ndirect L6\u2192L6 imports.",
            "methods": [
              "get_trace",
              "list_traces",
              "get_trace_summary",
              "get_trace_steps"
            ],
            "line": 163
          },
          {
            "name": "CircuitBreakerPort",
            "docstring": "Behavioral contract for circuit breaker operations.\n\nImplemented by: circuit_breaker_async_driver functions (controls/L6_drivers)\nConsumed by: canary_engine, sandbox_engine (analytics/L5_engines)\nWired by: L4 orchestrator or CanaryCoordinator\n\nPIN-521: Protocol enables cross-domain dependency injection without\ndirect L5\u2192L6 imports across domain boundaries.",
            "methods": [
              "is_v2_disabled",
              "report_drift",
              "get_circuit_breaker_state"
            ],
            "line": 197
          },
          {
            "name": "IntegrityDriverPort",
            "docstring": "Behavioral contract for integrity verification.\n\nImplemented by: integrity_driver (logs/L6_drivers)\nConsumed by: export_engine (incidents/L5_engines)\nWired by: L4 orchestrator or L5 engine via bridge\n\nPIN-521: Protocol enables cross-domain dependency injection without\ndirect L5\u2192L6 imports across domain boundaries.",
            "methods": [
              "verify_integrity",
              "get_integrity_proof"
            ],
            "line": 221
          },
          {
            "name": "MCPAuditEmitterPort",
            "docstring": "Behavioral contract for MCP audit event emission.\n\nImplemented by: MCPAuditEmitter (logs/L5_engines/audit_evidence.py)\nConsumed by: McpToolInvocationEngine (integrations/L5_engines)\nWired by: L4 handler or constructor injection\n\nPIN-521: Protocol enables cross-domain dependency injection without\ndirect L5\u2192L5 imports across domain boundaries.",
            "methods": [
              "emit_tool_requested",
              "emit_tool_allowed",
              "emit_tool_denied",
              "emit_tool_started",
              "emit_tool_completed",
              "emit_tool_failed"
            ],
            "line": 246
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 17
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 20
          }
        ],
        "constants": [],
        "all_exports": [
          "LessonsEnginePort",
          "PolicyEvaluationPort",
          "TraceFacadePort",
          "ConnectorLookupPort",
          "ValidatorVerdictPort",
          "EligibilityVerdictPort",
          "TraceStorePort",
          "CircuitBreakerPort",
          "IntegrityDriverPort",
          "MCPAuditEmitterPort"
        ]
      },
      {
        "file_name": "rac_models.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/rac_models.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 409,
        "module_docstring": "Runtime Audit Contract (RAC) Models\n\nThese models define the data structures for the audit system:\n\n- AuditExpectation: Declares what action MUST happen for a run\n- DomainAck: Reports that an action has completed\n- ReconciliationResult: Result of comparing expectations vs acks\n\nDesign Principles:\n1. Immutable after creation (expectations are contracts)\n2. UUID-based for correlation across domains\n3. Serializable for Redis storage\n4. Type-safe with enums for domains and actions",
        "functions": [
          {
            "name": "create_run_expectations",
            "signature": "(run_id: UUID, run_timeout_ms: int = 30000, grace_period_ms: int = 5000) -> List[AuditExpectation]",
            "docstring": "Create the standard set of expectations for a run.\n\nThis is called by ROK at T0 (run creation) to declare\nwhat MUST happen during run execution.\n\nArgs:\n    run_id: The run ID\n    run_timeout_ms: Expected run duration\n    grace_period_ms: Grace period after run timeout\n\nReturns:\n    List of AuditExpectation objects",
            "is_async": false,
            "line": 305
          },
          {
            "name": "create_domain_ack",
            "signature": "(run_id: UUID, domain: AuditDomain, action: AuditAction, result_id: Optional[str] = None, error: Optional[str] = None, **metadata: Any) -> DomainAck",
            "docstring": "Create a domain acknowledgment.\n\nThis is called by facades after completing domain operations.\n\nArgs:\n    run_id: The run ID\n    domain: Which domain performed the action\n    action: What action was performed\n    result_id: ID of created entity (e.g., incident_id)\n    error: Error message if action failed\n    **metadata: Additional context\n\nReturns:\n    DomainAck object",
            "is_async": false,
            "line": 358
          }
        ],
        "classes": [
          {
            "name": "AuditStatus",
            "docstring": "Status of an audit expectation.",
            "methods": [],
            "line": 44
          },
          {
            "name": "AuditDomain",
            "docstring": "Domains that participate in the audit contract.",
            "methods": [],
            "line": 53
          },
          {
            "name": "AuditAction",
            "docstring": "Actions that can be expected/acked.",
            "methods": [],
            "line": 62
          },
          {
            "name": "AuditExpectation",
            "docstring": "An expectation that an action MUST happen for a run.\n\nCreated at run start (T0) by ROK, one per expected domain action.\nThe finalize_run expectation is the liveness guarantee.\n\nAttributes:\n    id: Unique expectation ID\n    run_id: The run this expectation belongs to\n    domain: Which domain should perform the action\n    action: What action is expected\n    status: Current status (PENDING -> ACKED | MISSING | FAILED)\n    deadline_ms: Time allowed for ack (from creation)\n    created_at: When this expectation was created\n    acked_at: When the ack was received (if any)\n    metadata: Additional context (e.g., expected result type)",
            "methods": [
              "to_dict",
              "from_dict",
              "key"
            ],
            "line": 80
          },
          {
            "name": "AckStatus",
            "docstring": "Status of a domain acknowledgment.",
            "methods": [],
            "line": 143
          },
          {
            "name": "DomainAck",
            "docstring": "Acknowledgment that a domain action has completed.\n\nEmitted by facades after successful domain operations.\nMatched against expectations during reconciliation.\n\nAttributes:\n    id: Unique ack ID\n    run_id: The run this ack belongs to\n    domain: Which domain performed the action\n    action: What action was performed\n    status: Status of the ack (SUCCESS, FAILED, ROLLED_BACK)\n    result_id: ID of the created entity (e.g., incident_id)\n    error: Error message if action failed\n    rolled_back: True if this action was rolled back (audit trail)\n    rollback_reason: Why the action was rolled back\n    created_at: When this ack was created\n    metadata: Additional context (e.g., execution time)",
            "methods": [
              "is_success",
              "is_rolled_back",
              "to_dict",
              "from_dict",
              "key"
            ],
            "line": 152
          },
          {
            "name": "ReconciliationResult",
            "docstring": "Result of reconciling expectations against acknowledgments.\n\nProduced by AuditReconciler after comparing what was expected\nvs what actually happened.\n\nAttributes:\n    run_id: The run that was reconciled\n    status: Overall status (COMPLETE, INCOMPLETE, STALE)\n    missing_actions: Actions expected but not acked\n    drift_actions: Actions acked but not expected\n    failed_actions: Actions acked with errors\n    stale_run: True if finalize_run was never acked\n    reconciled_at: When reconciliation was performed\n    expectations_count: Total expectations\n    acks_count: Total acks received",
            "methods": [
              "is_clean",
              "has_missing",
              "has_drift",
              "to_dict"
            ],
            "line": 234
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "uuid",
            "names": [
              "UUID",
              "uuid4"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "AckStatus",
          "AuditAction",
          "AuditDomain",
          "AuditStatus",
          "AuditExpectation",
          "DomainAck",
          "ReconciliationResult",
          "create_domain_ack",
          "create_run_expectations"
        ]
      },
      {
        "file_name": "response.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/response.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 340,
        "module_docstring": "Standard API Response Envelope\n\nThis module provides the standard response format for all API endpoints.\nConsistent response structures enable:\n- Predictable error handling in clients\n- Request tracing via metadata\n- Pagination support\n- SDK code generation\n\nStandard format:\n    {\n        \"success\": true,\n        \"data\": { ... },\n        \"meta\": {\n            \"timestamp\": \"2024-01-15T10:30:00Z\",\n            \"request_id\": \"req-abc123\"\n        }\n    }\n\nUsage:\n    from app.schemas.response import ResponseEnvelope, ok, error, paginated\n\n    # Simple success response\n    @router.get(\"/items/{id}\")\n    async def get_item(id: str) -> ResponseEnvelope:\n        item = await fetch_item(id)\n        return ok(item)\n\n    # Error response\n    @router.get(\"/items/{id}\")\n    async def get_item(id: str) -> ResponseEnvelope:\n        item = await fetch_item(id)\n        if not item:\n            return error(\"Item not found\", code=\"NOT_FOUND\")\n        return ok(item)\n\n    # Paginated response\n    @router.get(\"/items\")\n    async def list_items(page: int = 1) -> ResponseEnvelope:\n        items, total = await fetch_items_paginated(page)\n        return paginated(items, total=total, page=page, page_size=20)",
        "functions": [
          {
            "name": "ok",
            "signature": "(data: Any, request_id: Optional[str] = None) -> ResponseEnvelope",
            "docstring": "Create a successful response envelope.\n\nArgs:\n    data: The response payload\n    request_id: Optional request ID (auto-generated if not provided)\n\nReturns:\n    ResponseEnvelope with success=True",
            "is_async": false,
            "line": 122
          },
          {
            "name": "error",
            "signature": "(message: str, code: Optional[str] = None, details: Optional[Dict[str, Any]] = None, request_id: Optional[str] = None) -> ResponseEnvelope",
            "docstring": "Create an error response envelope.\n\nArgs:\n    message: Human-readable error message\n    code: Machine-readable error code\n    details: Additional error context\n    request_id: Optional request ID (auto-generated if not provided)\n\nReturns:\n    ResponseEnvelope with success=False",
            "is_async": false,
            "line": 144
          },
          {
            "name": "paginated",
            "signature": "(items: List[Any], total: int, page: int = 1, page_size: int = 20, request_id: Optional[str] = None) -> ResponseEnvelope",
            "docstring": "Create a paginated response envelope.\n\nArgs:\n    items: List of items for current page\n    total: Total count of all items\n    page: Current page number (1-indexed)\n    page_size: Number of items per page\n    request_id: Optional request ID (auto-generated if not provided)\n\nReturns:\n    ResponseEnvelope with pagination metadata",
            "is_async": false,
            "line": 180
          },
          {
            "name": "wrap_dict",
            "signature": "(data: Dict[str, Any], request_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Wrap a dictionary in the standard envelope format.\n\nUse this when you need a dict instead of Pydantic model (e.g., for legacy endpoints).\n\nArgs:\n    data: Dictionary to wrap (MUST be finalized output, see warnings below)\n    request_id: Optional request ID\n\nReturns:\n    Dictionary with envelope structure\n\nWARNING - API-002-CR-001 (Counter-rule):\n    `data` must ONLY be:\n    1. model_dump() output from Pydantic models\n    2. Fully constructed response dictionaries\n\n    NEVER pass:\n    - Raw ORM/SQLModel entities\n    - Internal domain objects\n    - Partial computation results\n\n    Example:\n        # \u2705 CORRECT\n        return wrap_dict(result.model_dump())\n        return wrap_dict({\"key\": \"value\"})\n\n        # \u274c VIOLATION\n        return wrap_dict(orm_entity)\n        return wrap_dict(partial_result)\n\nWARNING - API-002-CR-002 (Counter-rule for lists):\n    When using {\"items\": [...], \"total\": len(results)}:\n    - Valid ONLY for non-paginated endpoints\n    - For paginated endpoints, total MUST come from COUNT(*) query\n\nReference: docs/architecture/GOVERNANCE_GUARDRAILS.md (API-002)",
            "is_async": false,
            "line": 216
          },
          {
            "name": "wrap_list",
            "signature": "(items: List[Any], total: Optional[int] = None, page: Optional[int] = None, page_size: Optional[int] = None, request_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Wrap a list in the standard envelope format.\n\nUse this when you need a dict instead of Pydantic model.\n\nArgs:\n    items: List to wrap\n    total: Optional total count for pagination\n    page: Optional current page\n    page_size: Optional page size\n    request_id: Optional request ID\n\nReturns:\n    Dictionary with envelope structure",
            "is_async": false,
            "line": 265
          },
          {
            "name": "wrap_error",
            "signature": "(message: str, code: Optional[str] = None, details: Optional[Dict[str, Any]] = None, request_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Create an error response as a dictionary.\n\nArgs:\n    message: Error message\n    code: Error code\n    details: Additional context\n    request_id: Optional request ID\n\nReturns:\n    Dictionary with error envelope structure",
            "is_async": false,
            "line": 308
          }
        ],
        "classes": [
          {
            "name": "ResponseMeta",
            "docstring": "Metadata included with every response.",
            "methods": [],
            "line": 73
          },
          {
            "name": "ResponseEnvelope",
            "docstring": "Standard API response envelope.\n\nAll API endpoints should return this structure for consistency.",
            "methods": [],
            "line": 91
          },
          {
            "name": "ErrorDetail",
            "docstring": "Structured error information.",
            "methods": [],
            "line": 108
          }
        ],
        "imports": [
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Generic",
              "List",
              "Optional",
              "TypeVar"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 68
          }
        ],
        "constants": [
          {
            "name": "T",
            "line": 70
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "retry.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/retry.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 89,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "BackoffStrategy",
            "docstring": "Backoff strategy for retries.",
            "methods": [],
            "line": 22
          },
          {
            "name": "RetryPolicy",
            "docstring": "Retry policy configuration for skills and steps.\n\nDefines how failures should be retried, including\nmax attempts, delays, and backoff strategies.",
            "methods": [
              "get_delay",
              "_fibonacci"
            ],
            "line": 31
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 16
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 17
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "ConfigDict",
              "Field"
            ],
            "is_relative": false,
            "line": 19
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "run_introspection_protocols.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/run_introspection_protocols.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 257,
        "module_docstring": "Run Introspection Protocol Interfaces (PIN-519)\n\nThese Protocols define the behavioral contracts for run introspection:\n- RunEvidenceProvider: Cross-domain impact for a run\n- RunProofProvider: Integrity verification for a run\n- SignalFeedbackProvider: Signal feedback status queries\n\nEach Protocol is implemented by L4 coordinators and consumed by L5 facades.",
        "functions": [],
        "classes": [
          {
            "name": "IncidentSummary",
            "docstring": "Summary of an incident caused by a run.",
            "methods": [],
            "line": 42
          },
          {
            "name": "PolicyEvaluationSummary",
            "docstring": "Summary of a policy evaluation for a run.",
            "methods": [],
            "line": 52
          },
          {
            "name": "LimitHitSummary",
            "docstring": "Summary of a limit breach for a run.",
            "methods": [],
            "line": 62
          },
          {
            "name": "DecisionSummary",
            "docstring": "Summary of a decision made during a run.",
            "methods": [],
            "line": 73
          },
          {
            "name": "RunEvidenceResult",
            "docstring": "Cross-domain impact evidence for a run.\n\nAggregates incidents, policy evaluations, limit breaches,\nand decisions related to a specific run.",
            "methods": [],
            "line": 83
          },
          {
            "name": "IntegrityVerificationResult",
            "docstring": "Integrity verification status for a run's trace chain.\n\nSupports HASH_CHAIN (Phase 1) and MERKLE_TREE (future).",
            "methods": [],
            "line": 100
          },
          {
            "name": "TraceSummary",
            "docstring": "Summary of a trace record.",
            "methods": [],
            "line": 115
          },
          {
            "name": "TraceStepSummary",
            "docstring": "Summary of a trace step.",
            "methods": [],
            "line": 127
          },
          {
            "name": "RunProofResult",
            "docstring": "Integrity proof for a run.\n\nContains trace data and integrity verification results.",
            "methods": [],
            "line": 138
          },
          {
            "name": "SignalFeedbackResult",
            "docstring": "Feedback status for a signal from audit ledger.\n\nTracks acknowledgment and suppression state.",
            "methods": [],
            "line": 154
          },
          {
            "name": "RunEvidenceProvider",
            "docstring": "Behavioral contract for run evidence queries.\n\nImplemented by: RunEvidenceCoordinator (L4)\nConsumed by: ActivityFacade (L5)\nWired by: L4 orchestrator context",
            "methods": [
              "get_run_evidence"
            ],
            "line": 176
          },
          {
            "name": "RunProofProvider",
            "docstring": "Behavioral contract for run integrity proof queries.\n\nImplemented by: RunProofCoordinator (L4)\nConsumed by: ActivityFacade (L5)\nWired by: L4 orchestrator context",
            "methods": [
              "get_run_proof"
            ],
            "line": 197
          },
          {
            "name": "SignalFeedbackProvider",
            "docstring": "Behavioral contract for signal feedback queries.\n\nImplemented by: SignalFeedbackCoordinator (L4)\nConsumed by: ActivityFacade (L5)\nWired by: L4 orchestrator context",
            "methods": [
              "get_signal_feedback"
            ],
            "line": 219
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Literal",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 22
          }
        ],
        "constants": [
          {
            "name": "INTEGRITY_CONFIG",
            "line": 29
          }
        ],
        "all_exports": [
          "INTEGRITY_CONFIG",
          "IncidentSummary",
          "PolicyEvaluationSummary",
          "LimitHitSummary",
          "DecisionSummary",
          "RunEvidenceResult",
          "IntegrityVerificationResult",
          "TraceSummary",
          "TraceStepSummary",
          "RunProofResult",
          "SignalFeedbackResult",
          "RunEvidenceProvider",
          "RunProofProvider",
          "SignalFeedbackProvider"
        ]
      },
      {
        "file_name": "skill.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/skill.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 457,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "SkillStatus",
            "docstring": "Skill execution status.",
            "methods": [],
            "line": 30
          },
          {
            "name": "SkillInputBase",
            "docstring": "Base class for all skill inputs.\n\nAll skill-specific inputs should inherit from this.\nProvides common validation and serialization.",
            "methods": [],
            "line": 40
          },
          {
            "name": "SkillOutputBase",
            "docstring": "Base class for all skill outputs.\n\nProvides consistent structure for all skill results.",
            "methods": [],
            "line": 50
          },
          {
            "name": "HttpMethod",
            "docstring": "Supported HTTP methods.",
            "methods": [],
            "line": 72
          },
          {
            "name": "HttpCallInput",
            "docstring": "Input schema for http_call skill.",
            "methods": [
              "validate_url"
            ],
            "line": 84
          },
          {
            "name": "HttpCallOutput",
            "docstring": "Output schema for http_call skill.",
            "methods": [],
            "line": 103
          },
          {
            "name": "LLMProvider",
            "docstring": "Supported LLM providers.",
            "methods": [],
            "line": 119
          },
          {
            "name": "LLMMessage",
            "docstring": "A single message in the LLM conversation.",
            "methods": [],
            "line": 127
          },
          {
            "name": "LLMInvokeInput",
            "docstring": "Input schema for llm_invoke skill.",
            "methods": [],
            "line": 134
          },
          {
            "name": "LLMInvokeOutput",
            "docstring": "Output schema for llm_invoke skill.",
            "methods": [],
            "line": 147
          },
          {
            "name": "FileReadInput",
            "docstring": "Input schema for file_read skill.",
            "methods": [],
            "line": 165
          },
          {
            "name": "FileReadOutput",
            "docstring": "Output schema for file_read skill.",
            "methods": [],
            "line": 173
          },
          {
            "name": "FileWriteInput",
            "docstring": "Input schema for file_write skill.",
            "methods": [],
            "line": 187
          },
          {
            "name": "FileWriteOutput",
            "docstring": "Output schema for file_write skill.",
            "methods": [],
            "line": 197
          },
          {
            "name": "PostgresQueryInput",
            "docstring": "Input schema for postgres_query skill.",
            "methods": [],
            "line": 209
          },
          {
            "name": "PostgresQueryOutput",
            "docstring": "Output schema for postgres_query skill.",
            "methods": [],
            "line": 219
          },
          {
            "name": "JsonTransformInput",
            "docstring": "Input schema for json_transform skill.",
            "methods": [],
            "line": 233
          },
          {
            "name": "JsonTransformOutput",
            "docstring": "Output schema for json_transform skill.",
            "methods": [],
            "line": 242
          },
          {
            "name": "EmailSendInput",
            "docstring": "Input schema for email_send skill.",
            "methods": [
              "normalize_recipients"
            ],
            "line": 255
          },
          {
            "name": "EmailSendOutput",
            "docstring": "Output schema for email_send skill.",
            "methods": [],
            "line": 283
          },
          {
            "name": "KVOperation",
            "docstring": "KV store operations.",
            "methods": [],
            "line": 297
          },
          {
            "name": "KVStoreInput",
            "docstring": "Input schema for kv_store skill.",
            "methods": [],
            "line": 310
          },
          {
            "name": "KVStoreOutput",
            "docstring": "Output schema for kv_store skill.",
            "methods": [],
            "line": 326
          },
          {
            "name": "SlackSendInput",
            "docstring": "Input schema for slack_send skill.",
            "methods": [],
            "line": 342
          },
          {
            "name": "SlackSendOutput",
            "docstring": "Output schema for slack_send skill.",
            "methods": [],
            "line": 357
          },
          {
            "name": "WebhookSendInput",
            "docstring": "Input schema for webhook_send skill.",
            "methods": [
              "validate_webhook_url"
            ],
            "line": 370
          },
          {
            "name": "WebhookSendOutput",
            "docstring": "Output schema for webhook_send skill.",
            "methods": [],
            "line": 391
          },
          {
            "name": "VoyageModel",
            "docstring": "Voyage AI embedding models.",
            "methods": [],
            "line": 406
          },
          {
            "name": "VoyageInputType",
            "docstring": "Input type for Voyage embeddings.",
            "methods": [],
            "line": 415
          },
          {
            "name": "VoyageEmbedInput",
            "docstring": "Input schema for voyage_embed skill.",
            "methods": [],
            "line": 422
          },
          {
            "name": "VoyageEmbedOutput",
            "docstring": "Output schema for voyage_embed skill.",
            "methods": [],
            "line": 433
          },
          {
            "name": "SkillMetadata",
            "docstring": "Metadata about a registered skill.",
            "methods": [],
            "line": 447
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Union"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "ConfigDict",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "threshold_types.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/schemas/threshold_types.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 40,
        "module_docstring": "Threshold Types (Spine Schemas)\n\nShared data types for threshold limit operations.\nHistorical extraction point for `LimitSnapshot`.\n\nAs of 2026-02-08 (T0 strict mode), L6 drivers under `hoc/cus/*/L6_drivers`\nmust not import `hoc_spine`. Domain-local DTOs are preferred (e.g.\n`controls/L6_drivers/threshold_driver.py` defines its own `LimitSnapshot`).",
        "functions": [],
        "classes": [
          {
            "name": "LimitSnapshot",
            "docstring": "Immutable snapshot of a Limit record returned to engines.\n\nThis is the boundary contract between L6 (driver) and L5 (engine).\nEngines receive snapshots, not ORM models.",
            "methods": [],
            "line": 26
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 22
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "alert_delivery.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/alert_delivery.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 168,
        "module_docstring": "Alert Delivery Adapter (L2)\n\nPure HTTP delivery to Alertmanager.\nAll business logic stays in L4 engine.\nAll database operations stay in L6 driver.\n\nOperations:\n- Send alert payload to Alertmanager\n- Handle HTTP errors and timeouts\n- Report delivery result\n\nNO business logic:\n- NO retry decisions (L4)\n- NO status updates (L6)\n- NO queue management (L6)\n\nReference: Phase-2.5A Analytics Extraction",
        "functions": [
          {
            "name": "get_alert_delivery_adapter",
            "signature": "(alertmanager_url: Optional[str] = None, timeout_seconds: float = 30.0) -> AlertDeliveryAdapter",
            "docstring": "Factory function to get AlertDeliveryAdapter instance.",
            "is_async": false,
            "line": 153
          }
        ],
        "classes": [
          {
            "name": "DeliveryResult",
            "docstring": "Result of alert delivery attempt.",
            "methods": [],
            "line": 50
          },
          {
            "name": "AlertDeliveryAdapter",
            "docstring": "Adapter for HTTP alert delivery.\n\nPure HTTP operations - no business logic, no database.",
            "methods": [
              "__init__",
              "_get_client",
              "close",
              "send_alert"
            ],
            "line": 59
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": [
          "AlertDeliveryAdapter",
          "DeliveryResult",
          "get_alert_delivery_adapter"
        ]
      },
      {
        "file_name": "alerts_facade.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/alerts_facade.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 679,
        "module_docstring": "Alerts Facade (L4 Domain Logic)\n\nThis facade provides the external interface for alert operations.\nAll alert APIs MUST use this facade instead of directly importing\ninternal alert modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes alert configuration and routing\n- Provides unified access to alert history\n- Single point for audit emission\n\nL2 API Routes (GAP-110, GAP-111, GAP-124):\n- POST /api/v1/alerts/rules (create alert rule)\n- GET /api/v1/alerts/rules (list alert rules)\n- GET /api/v1/alerts/rules/{id} (get alert rule)\n- PUT /api/v1/alerts/rules/{id} (update alert rule)\n- DELETE /api/v1/alerts/rules/{id} (delete alert rule)\n- GET /api/v1/alerts/history (alert history)\n- GET /api/v1/alerts/routes (alert routes)\n- POST /api/v1/alerts/routes (create route)\n\nUsage:\n    from app.hoc.cus.hoc_spine.services.alerts_facade import get_alerts_facade\n\n    facade = get_alerts_facade()\n\n    # Create alert rule\n    rule = await facade.create_rule(\n        tenant_id=\"...\",\n        name=\"High Cost Alert\",\n        condition={\"metric\": \"cost\", \"threshold\": 1000},\n    )",
        "functions": [
          {
            "name": "get_alerts_facade",
            "signature": "() -> AlertsFacade",
            "docstring": "Get the alerts facade instance.\n\nThis is the recommended way to access alert operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    AlertsFacade instance",
            "is_async": false,
            "line": 666
          }
        ],
        "classes": [
          {
            "name": "AlertSeverity",
            "docstring": "Alert severity levels.",
            "methods": [],
            "line": 67
          },
          {
            "name": "AlertStatus",
            "docstring": "Alert status.",
            "methods": [],
            "line": 75
          },
          {
            "name": "AlertRule",
            "docstring": "Alert rule definition.",
            "methods": [
              "to_dict"
            ],
            "line": 83
          },
          {
            "name": "AlertEvent",
            "docstring": "Alert event (history entry).",
            "methods": [
              "to_dict"
            ],
            "line": 115
          },
          {
            "name": "AlertRoute",
            "docstring": "Alert routing rule.",
            "methods": [
              "to_dict"
            ],
            "line": 151
          },
          {
            "name": "AlertsFacade",
            "docstring": "Facade for alert operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nalert services.\n\nLayer: L4 (Domain Logic)\nCallers: alerts.py (L2), aos_sdk, Worker",
            "methods": [
              "__init__",
              "create_rule",
              "list_rules",
              "get_rule",
              "update_rule",
              "delete_rule",
              "list_history",
              "get_event",
              "acknowledge_event",
              "resolve_event",
              "trigger_alert",
              "create_route",
              "list_routes",
              "get_route",
              "delete_route"
            ],
            "line": 176
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 62
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "audit_durability.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/audit_durability.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 325,
        "module_docstring": "Module: durability\nPurpose: Enforce RAC durability before acknowledgment.\n\nThe rac_durability_enforce flag in GovernanceConfig controls whether\ndurability is strictly enforced before acknowledging audit operations.\n\nWhen enabled:\n    - Acks must be persisted to durable storage before being accepted\n    - Expectations must be durably stored before run starts\n    - In-memory-only mode raises RACDurabilityEnforcementError\n\nThis ensures audit contracts survive crashes and can be reconciled\neven if workers fail.\n\nExports:\n    - RACDurabilityEnforcementError: Raised when durability not satisfied\n    - RACDurabilityChecker: Checks durability constraints\n    - check_rac_durability: Quick helper function",
        "functions": [
          {
            "name": "check_rac_durability",
            "signature": "(enforcement_enabled: bool = True, durability_mode: str = 'MEMORY') -> DurabilityCheckResponse",
            "docstring": "Quick helper to check RAC durability.\n\nArgs:\n    enforcement_enabled: Whether rac_durability_enforce is True\n    durability_mode: Current durability mode\n\nReturns:\n    DurabilityCheckResponse with status and metadata",
            "is_async": false,
            "line": 284
          },
          {
            "name": "ensure_rac_durability",
            "signature": "(operation: str, enforcement_enabled: bool = True, durability_mode: str = 'MEMORY') -> None",
            "docstring": "Quick helper to ensure RAC durability or raise error.\n\nArgs:\n    operation: Name of the operation being performed\n    enforcement_enabled: Whether rac_durability_enforce is True\n    durability_mode: Current durability mode\n\nRaises:\n    RACDurabilityEnforcementError: If enforcement enabled and not durable",
            "is_async": false,
            "line": 305
          }
        ],
        "classes": [
          {
            "name": "DurabilityCheckResult",
            "docstring": "Result of a durability check.",
            "methods": [],
            "line": 44
          },
          {
            "name": "RACDurabilityEnforcementError",
            "docstring": "Raised when RAC durability enforcement fails.\n\nThis error indicates that an operation requiring durable storage\nwas attempted without durable backing store available.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 53
          },
          {
            "name": "DurabilityCheckResponse",
            "docstring": "Response from a durability check.",
            "methods": [
              "to_dict"
            ],
            "line": 85
          },
          {
            "name": "RACDurabilityChecker",
            "docstring": "Checks and enforces RAC durability constraints.\n\nGAP-050: Add durability checks to RAC.\n\nThe checker verifies that audit data is durably stored before\nallowing acknowledgment operations when enforcement is enabled.\n\nUsage:\n    checker = RACDurabilityChecker(\n        enforcement_enabled=True,\n        durability_mode=\"REDIS\",\n    )\n\n    # Before adding an ack\n    checker.ensure_durable(\"add_ack\")\n\n    # Or check without raising\n    response = checker.check()\n    if not response.is_durable and response.enforcement_enabled:\n        handle_durability_issue()",
            "methods": [
              "__init__",
              "from_governance_config",
              "from_audit_store",
              "is_durable",
              "enforcement_enabled",
              "check",
              "ensure_durable",
              "should_allow_operation"
            ],
            "line": 105
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "audit_store.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/audit_store.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 526,
        "module_docstring": "Audit Store\n\nProvides storage for audit expectations and acknowledgments.\n\nStorage Strategy:\n- MEMORY: In-memory dictionary (dev/test only - NOT crash-safe)\n- REDIS: Redis-backed store (staging/prod - crash-safe, cross-process)\n\nDurability Modes:\n- AOS_MODE=local \u2192 MEMORY allowed\n- AOS_MODE=test/prod \u2192 REDIS required (startup fails without it)\n\nThe store is designed to be:\n1. Fast for writes (acks happen in hot path)\n2. Durable in production (Redis backing mandatory)\n3. TTL-managed (old data expires automatically)\n\nRedis keys:\n- rac:expectations:{run_id} -> JSON list of expectations\n- rac:acks:{run_id} -> JSON list of acks\n- TTL: 1 hour (runs should complete within this time)",
        "functions": [
          {
            "name": "_determine_durability_mode",
            "signature": "(redis_client) -> StoreDurabilityMode",
            "docstring": "Determine the durability mode based on environment and Redis availability.\n\nRules:\n- AOS_MODE=local \u2192 MEMORY allowed (dev)\n- AOS_MODE=test/prod + RAC_ENABLED + no Redis \u2192 ERROR\n- AOS_MODE=test/prod + RAC_ENABLED + Redis \u2192 REDIS",
            "is_async": false,
            "line": 78
          },
          {
            "name": "get_audit_store",
            "signature": "(redis_client = None) -> AuditStore",
            "docstring": "Get the audit store singleton.\n\nArgs:\n    redis_client: Optional Redis client (only used on first call)\n\nReturns:\n    AuditStore instance",
            "is_async": false,
            "line": 513
          }
        ],
        "classes": [
          {
            "name": "StoreDurabilityMode",
            "docstring": "Durability mode for the audit store.",
            "methods": [],
            "line": 65
          },
          {
            "name": "RACDurabilityError",
            "docstring": "Raised when RAC requires durable storage but none is available.",
            "methods": [],
            "line": 72
          },
          {
            "name": "AuditStore",
            "docstring": "Storage for audit expectations and acknowledgments.\n\nThread-safe store with configurable durability:\n- MEMORY mode: In-memory only (dev/test, NOT crash-safe)\n- REDIS mode: Redis-backed (staging/prod, crash-safe)\n\nUsage:\n    store = get_audit_store()\n\n    # Add expectations at run start\n    store.add_expectations(run_id, expectations)\n\n    # Add acks as domains complete\n    store.add_ack(run_id, ack)\n\n    # Get for reconciliation\n    expectations = store.get_expectations(run_id)\n    acks = store.get_acks(run_id)\n\nDurability:\n    In production (AOS_MODE=test/prod), Redis is REQUIRED when RAC_ENABLED=true.\n    This ensures expectations/acks survive worker crashes.",
            "methods": [
              "__init__",
              "durability_mode",
              "is_durable",
              "add_expectations",
              "get_expectations",
              "update_expectation_status",
              "add_ack",
              "get_acks",
              "record_dispatch",
              "get_dispatch_records",
              "_sync_dispatch_to_redis",
              "clear_run",
              "get_pending_run_ids",
              "_sync_expectations_to_redis",
              "_sync_acks_to_redis",
              "load_from_redis"
            ],
            "line": 104
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "threading",
            "names": [
              "Lock"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.rac_models",
            "names": [
              "AuditExpectation",
              "AuditStatus",
              "DomainAck"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.dispatch_audit",
            "names": [
              "DispatchRecord"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [
          {
            "name": "REDIS_TTL_SECONDS",
            "line": 57
          },
          {
            "name": "AUDIT_REDIS_ENABLED",
            "line": 60
          },
          {
            "name": "RAC_ENABLED",
            "line": 61
          },
          {
            "name": "AOS_MODE",
            "line": 62
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "canonical_json.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/canonical_json.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 294,
        "module_docstring": "Canonical JSON serialization for AOS.\n\nEnsures deterministic JSON output for:\n- Replay testing\n- Content hashing\n- Golden file comparison\n\nSee: app/specs/canonical_json.md for full specification.",
        "functions": [
          {
            "name": "canonical_json",
            "signature": "(obj: Any, exclude_fields: Optional[Set[str]] = None) -> str",
            "docstring": "Serialize object to canonical JSON format.\n\nRules:\n- Keys sorted alphabetically\n- No whitespace\n- UTF-8 encoding\n- Minimal escaping\n\nArgs:\n    obj: Object to serialize\n    exclude_fields: Optional set of field names to exclude (for variance fields)\n\nReturns:\n    Canonical JSON string",
            "is_async": false,
            "line": 42
          },
          {
            "name": "canonical_json_bytes",
            "signature": "(obj: Any, exclude_fields: Optional[Set[str]] = None) -> bytes",
            "docstring": "Serialize object to canonical JSON bytes (UTF-8).\n\nArgs:\n    obj: Object to serialize\n    exclude_fields: Optional set of field names to exclude\n\nReturns:\n    UTF-8 encoded canonical JSON bytes",
            "is_async": false,
            "line": 65
          },
          {
            "name": "content_hash",
            "signature": "(obj: Any, exclude_fields: Optional[Set[str]] = None, length: int = 16) -> str",
            "docstring": "Compute deterministic content hash.\n\nArgs:\n    obj: Object to hash\n    exclude_fields: Fields to exclude from hash (e.g., timestamps)\n    length: Length of hash to return (default 16 hex chars)\n\nReturns:\n    Hex string of SHA-256 hash (truncated to length)",
            "is_async": false,
            "line": 79
          },
          {
            "name": "content_hash_full",
            "signature": "(obj: Any, exclude_fields: Optional[Set[str]] = None) -> str",
            "docstring": "Compute full SHA-256 content hash.\n\nArgs:\n    obj: Object to hash\n    exclude_fields: Fields to exclude from hash\n\nReturns:\n    Full 64-character hex hash",
            "is_async": false,
            "line": 96
          },
          {
            "name": "deterministic_hash",
            "signature": "(obj: Any, length: int = 16) -> str",
            "docstring": "Compute hash excluding allowed variance fields.\n\nThis is the standard hashing function for replay comparisons.\n\nArgs:\n    obj: Object to hash\n    length: Length of hash to return\n\nReturns:\n    Hex hash string",
            "is_async": false,
            "line": 130
          },
          {
            "name": "_json_serializer",
            "signature": "(obj: Any) -> Any",
            "docstring": "Custom JSON serializer for non-standard types.\n\nHandles:\n- datetime/date \u2192 ISO format string\n- UUID \u2192 string\n- Enum \u2192 value\n- bytes \u2192 base64 string (if needed)\n- Objects with to_dict() method\n- Objects with __dict__ attribute",
            "is_async": false,
            "line": 146
          },
          {
            "name": "_filter_fields",
            "signature": "(obj: Any, exclude: Set[str]) -> Any",
            "docstring": "Recursively filter out excluded fields from an object.\n\nArgs:\n    obj: Object to filter\n    exclude: Set of field names to exclude\n\nReturns:\n    Filtered object",
            "is_async": false,
            "line": 178
          },
          {
            "name": "is_canonical",
            "signature": "(json_str: str) -> bool",
            "docstring": "Check if a JSON string is in canonical format.\n\nArgs:\n    json_str: JSON string to check\n\nReturns:\n    True if canonical, False otherwise",
            "is_async": false,
            "line": 196
          },
          {
            "name": "canonicalize_file",
            "signature": "(filepath: str) -> None",
            "docstring": "Rewrite a JSON file in canonical format.\n\nArgs:\n    filepath: Path to JSON file\n\nRaises:\n    ValueError: If file is not valid JSON",
            "is_async": false,
            "line": 214
          },
          {
            "name": "assert_canonical",
            "signature": "(filepath: str) -> None",
            "docstring": "Assert that a JSON file is in canonical format.\n\nArgs:\n    filepath: Path to JSON file\n\nRaises:\n    AssertionError: If file is not canonical",
            "is_async": false,
            "line": 233
          },
          {
            "name": "compare_deterministic",
            "signature": "(actual: Dict[str, Any], expected: Dict[str, Any], deterministic_fields: Optional[List[str]] = None) -> Dict[str, Any]",
            "docstring": "Compare two outputs, checking only deterministic fields.\n\nArgs:\n    actual: Actual output\n    expected: Expected output\n    deterministic_fields: List of fields that must match exactly\n\nReturns:\n    Dict with 'match' (bool) and 'differences' (list)",
            "is_async": false,
            "line": 253
          },
          {
            "name": "_get_nested",
            "signature": "(obj: Dict[str, Any], path: str) -> Any",
            "docstring": "Get nested value using dot notation.",
            "is_async": false,
            "line": 285
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [
          {
            "name": "ALLOWED_VARIANCE_FIELDS",
            "line": 112
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "compliance_facade.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/compliance_facade.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 518,
        "module_docstring": "Compliance Facade (L4 Domain Logic)\n\nThis facade provides the external interface for compliance verification operations.\nAll compliance APIs MUST use this facade instead of directly importing\ninternal compliance modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes compliance verification logic\n- Provides unified access to compliance checks and reports\n- Single point for audit emission\n\nL2 API Routes (GAP-103):\n- POST /api/v1/compliance/verify (run compliance verification)\n- GET /api/v1/compliance/reports (list compliance reports)\n- GET /api/v1/compliance/reports/{id} (get compliance report)\n- GET /api/v1/compliance/rules (list compliance rules)\n- GET /api/v1/compliance/status (compliance status)\n\nUsage:\n    from app.hoc.cus.hoc_spine.services.compliance_facade import get_compliance_facade\n\n    facade = get_compliance_facade()\n\n    # Run compliance verification\n    result = await facade.verify_compliance(tenant_id=\"...\", scope=\"all\")\n\n    # List compliance reports\n    reports = await facade.list_reports(tenant_id=\"...\")",
        "functions": [
          {
            "name": "get_compliance_facade",
            "signature": "() -> ComplianceFacade",
            "docstring": "Get the compliance facade instance.\n\nThis is the recommended way to access compliance operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    ComplianceFacade instance",
            "is_async": false,
            "line": 505
          }
        ],
        "classes": [
          {
            "name": "ComplianceScope",
            "docstring": "Compliance verification scope.",
            "methods": [],
            "line": 63
          },
          {
            "name": "ComplianceStatus",
            "docstring": "Compliance status.",
            "methods": [],
            "line": 72
          },
          {
            "name": "ComplianceRule",
            "docstring": "Compliance rule definition.",
            "methods": [
              "to_dict"
            ],
            "line": 81
          },
          {
            "name": "ComplianceViolation",
            "docstring": "A compliance violation.",
            "methods": [
              "to_dict"
            ],
            "line": 103
          },
          {
            "name": "ComplianceReport",
            "docstring": "Compliance verification report.",
            "methods": [
              "to_dict"
            ],
            "line": 123
          },
          {
            "name": "ComplianceStatusInfo",
            "docstring": "Overall compliance status.",
            "methods": [
              "to_dict"
            ],
            "line": 155
          },
          {
            "name": "ComplianceFacade",
            "docstring": "Facade for compliance verification operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ncompliance services.\n\nLayer: L4 (Domain Logic)\nCallers: compliance.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "_init_default_rules",
              "verify_compliance",
              "_check_rule_compliance",
              "list_reports",
              "get_report",
              "list_rules",
              "get_rule",
              "get_compliance_status"
            ],
            "line": 174
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "control_registry.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/control_registry.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 455,
        "module_docstring": "Module: control_registry\nPurpose: Registry of SOC2 Trust Service Criteria controls.\n\nSOC2 Trust Service Categories:\n    - CC (Common Criteria): Security-related controls\n    - A (Availability): System availability controls\n    - PI (Processing Integrity): Processing accuracy controls\n    - C (Confidentiality): Data confidentiality controls\n    - P (Privacy): Privacy-related controls\n\nKey Controls for AI Agent Governance:\n    - CC7.x: System Operations (Incident Response)\n    - CC6.x: Logical and Physical Access Controls\n    - CC8.x: Change Management\n    - PI1.x: Processing Integrity\n    - A1.x: Availability\n\nExports:\n    - SOC2Category: Enum of trust service categories\n    - SOC2ComplianceStatus: Enum of compliance states\n    - SOC2Control: Control definition\n    - SOC2ControlMapping: Mapping with evidence\n    - SOC2ControlRegistry: Registry singleton",
        "functions": [
          {
            "name": "get_control_registry",
            "signature": "() -> SOC2ControlRegistry",
            "docstring": "Get or create the singleton control registry.",
            "is_async": false,
            "line": 450
          }
        ],
        "classes": [
          {
            "name": "SOC2Category",
            "docstring": "SOC2 Trust Service Categories.",
            "methods": [],
            "line": 52
          },
          {
            "name": "SOC2ComplianceStatus",
            "docstring": "Compliance status for a control mapping.",
            "methods": [],
            "line": 62
          },
          {
            "name": "SOC2Control",
            "docstring": "SOC2 Trust Service Criteria control definition.\n\nRepresents a single SOC2 control with its ID, name, description,\nand the category it belongs to.",
            "methods": [
              "__post_init__"
            ],
            "line": 73
          },
          {
            "name": "SOC2ControlMapping",
            "docstring": "Mapping of incident/evidence to a SOC2 control.\n\nContains the control, the evidence provided, and compliance status.",
            "methods": [
              "to_dict"
            ],
            "line": 103
          },
          {
            "name": "SOC2ControlRegistry",
            "docstring": "Registry of SOC2 Trust Service Criteria controls.\n\nProvides lookup and management of SOC2 controls relevant to\nAI agent governance and incident response.\n\nGAP-025: Complete SOC2 control objective mapping.",
            "methods": [
              "__init__",
              "_register_all_controls",
              "_register_incident_response_controls",
              "_register_access_controls",
              "_register_change_management_controls",
              "_register_processing_integrity_controls",
              "_register_availability_controls",
              "_register_communication_controls",
              "_register_risk_controls",
              "get_control",
              "get_controls_by_category",
              "get_controls_by_prefix",
              "get_all_controls",
              "get_incident_response_controls"
            ],
            "line": 136
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "costsim_config.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/costsim_config.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 184,
        "module_docstring": "CostSim V2 Configuration - HOC Spine Shared Service\n\nPIN-521 Migration:\n- Extracted from analytics/L5_engines/config_engine.py to hoc_spine/services\n- L6 drivers can import this without layer violation\n- Analytics L5_engines re-exports for backward compatibility\n\nEnvironment Variables:\n- COSTSIM_V2_SANDBOX: Enable V2 sandbox path (default: false)\n- COSTSIM_V2_AUTO_DISABLE: Enable auto-disable on drift (default: true)\n- COSTSIM_DRIFT_THRESHOLD: Max acceptable drift score (default: 0.2)\n- COSTSIM_CANARY_ENABLED: Enable daily canary runner (default: true)\n- ALERTMANAGER_URL: Alertmanager API endpoint for alerts\n- INSTANCE_ID: Instance identifier for alerts",
        "functions": [
          {
            "name": "get_config",
            "signature": "() -> CostSimConfig",
            "docstring": "Get the global CostSim configuration.",
            "is_async": false,
            "line": 124
          },
          {
            "name": "is_v2_sandbox_enabled",
            "signature": "() -> bool",
            "docstring": "Check if V2 sandbox is enabled.\n\nReturns False if:\n- COSTSIM_V2_SANDBOX != true\n- Disable file exists (auto-disabled due to drift)",
            "is_async": false,
            "line": 132
          },
          {
            "name": "is_v2_disabled_by_drift",
            "signature": "() -> bool",
            "docstring": "Check if V2 was auto-disabled due to drift.",
            "is_async": false,
            "line": 153
          },
          {
            "name": "get_commit_sha",
            "signature": "() -> str",
            "docstring": "Get current git commit SHA.",
            "is_async": false,
            "line": 159
          }
        ],
        "classes": [
          {
            "name": "CostSimConfig",
            "docstring": "Configuration for CostSim V2.",
            "methods": [
              "from_env"
            ],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "CostSimConfig",
          "get_config",
          "is_v2_sandbox_enabled",
          "is_v2_disabled_by_drift",
          "get_commit_sha"
        ]
      },
      {
        "file_name": "costsim_metrics.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/costsim_metrics.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 394,
        "module_docstring": "CostSim V2 Prometheus Metrics - HOC Spine Shared Service\n\nPIN-521 Migration:\n- Extracted from analytics/L5_engines/metrics_engine.py to hoc_spine/services\n- L6 drivers can import this without layer violation\n- Analytics L5_engines re-exports for backward compatibility\n\nMetrics (6 required):\n1. costsim_v2_drift_score - Drift score histogram\n2. costsim_v2_cost_delta_cents - Cost delta distribution\n3. costsim_v2_schema_errors_total - Schema validation errors\n4. costsim_v2_simulation_duration_ms - V2 simulation latency\n5. costsim_v2_comparison_verdict - Verdict distribution\n6. costsim_v2_circuit_breaker_state - Circuit breaker state\n\nAlert Rules:\n- P1: drift_score > 0.2 for 5m (auto-disable)\n- P2: drift_score > 0.15 for 15m (warning)\n- P3: schema_errors > 5 in 1h (investigate)",
        "functions": [
          {
            "name": "get_metrics",
            "signature": "() -> CostSimMetrics",
            "docstring": "Get the global CostSim metrics instance.",
            "is_async": false,
            "line": 379
          }
        ],
        "classes": [
          {
            "name": "CostSimMetrics",
            "docstring": "Prometheus metrics for CostSim V2.\n\nUsage:\n    metrics = CostSimMetrics()\n    metrics.record_drift(drift_score=0.15, verdict=\"minor_drift\")\n    metrics.record_cost_delta(delta_cents=25)\n    metrics.record_schema_error()",
            "methods": [
              "__init__",
              "_init_metrics",
              "record_drift",
              "record_cost_delta",
              "record_schema_error",
              "record_simulation_duration",
              "record_simulation",
              "set_circuit_breaker_state",
              "record_provenance_log",
              "record_canary_run",
              "set_kl_divergence",
              "record_cb_disabled",
              "record_cb_enabled",
              "record_cb_incident",
              "set_alert_queue_depth",
              "record_alert_send_failure",
              "record_auto_recovery",
              "set_consecutive_failures"
            ],
            "line": 64
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.costsim_config",
            "names": [
              "get_config"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [
          {
            "name": "DRIFT_SCORE_BUCKETS",
            "line": 59
          },
          {
            "name": "COST_DELTA_BUCKETS",
            "line": 60
          },
          {
            "name": "DURATION_BUCKETS",
            "line": 61
          }
        ],
        "all_exports": [
          "CostSimMetrics",
          "get_metrics",
          "DRIFT_SCORE_BUCKETS",
          "COST_DELTA_BUCKETS",
          "DURATION_BUCKETS"
        ]
      },
      {
        "file_name": "cross_domain_gateway.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/cross_domain_gateway.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 38,
        "module_docstring": "Cross-Domain Gateway (L4)\n\nProvides hoc_spine-mediated access to functions that L5 engines from\none domain need from another domain.  L5 engines MUST import cross-domain\nfunctions from this module (or another hoc_spine module) \u2014 never directly\nfrom a sibling domain's L5_engines / L6_drivers.\n\nCurrent re-exports:\n  - Circuit breaker utilities  (controls domain)\n  - Recovery rule evaluation   (incidents domain)",
        "functions": [],
        "classes": [],
        "imports": [
          {
            "module": "app.hoc.cus.controls.L6_drivers.circuit_breaker_async_driver",
            "names": [
              "get_circuit_breaker",
              "is_v2_disabled",
              "report_drift"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "app.hoc.cus.incidents.L5_engines.recovery_rule_engine",
            "names": [
              "evaluate_rules"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": [
          "get_circuit_breaker",
          "is_v2_disabled",
          "report_drift",
          "evaluate_rules"
        ]
      },
      {
        "file_name": "cus_credential_engine.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/cus_credential_engine.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 570,
        "module_docstring": "Customer Credential Service\n\nPURPOSE:\n    Secure handling of customer LLM API credentials.\n    Encrypts credentials at rest, provides vault-ready integration.\n\nSECURITY PRINCIPLES:\n    1. NO PLAINTEXT PERSISTENCE: All stored credentials are encrypted\n    2. ROTATION-READY: Credentials can be rotated without downtime\n    3. AUDIT TRAIL: All credential access is logged\n    4. MINIMAL EXPOSURE: Decryption only at point of use\n\nCREDENTIAL REFERENCE FORMAT:\n    - vault://<path>         - HashiCorp Vault reference\n    - encrypted://<id>       - Locally encrypted (AES-256-GCM)\n    - env://<var_name>       - Environment variable (dev only)\n\nENCRYPTION:\n    - Algorithm: AES-256-GCM\n    - Key derivation: PBKDF2 with per-tenant salt\n    - In production: KEK from external key management service",
        "functions": [],
        "classes": [
          {
            "name": "CusCredentialService",
            "docstring": "Service for managing customer LLM credentials.\n\nPhase 4: Secure credential storage and retrieval.\nProduction deployments should use external vault integration.",
            "methods": [
              "__init__",
              "_derive_dev_key",
              "_derive_tenant_key",
              "encrypt_credential",
              "decrypt_credential",
              "resolve_credential",
              "_resolve_vault_credential",
              "resolve_cus_vault_credential",
              "_resolve_env_credential",
              "rotate_credential",
              "validate_credential_format",
              "generate_master_key",
              "mask_credential"
            ],
            "line": 55
          }
        ],
        "imports": [
          {
            "module": "base64",
            "names": [
              "base64"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "secrets",
            "names": [
              "secrets"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "cryptography.hazmat.primitives.ciphers.aead",
            "names": [
              "AESGCM"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "dag_sorter.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/dag_sorter.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 318,
        "module_docstring": "DAG-based execution ordering for PLang v2.0.\n\nFeatures:\n- Topological sort for dependency-respecting execution\n- Category-aware ordering (SAFETY first)\n- Priority-based tie breaking\n- Deterministic execution plan generation",
        "functions": [],
        "classes": [
          {
            "name": "ExecutionPhase",
            "docstring": "Execution phases in deterministic order.",
            "methods": [],
            "line": 40
          },
          {
            "name": "ExecutionNode",
            "docstring": "A node in the execution DAG.\n\nRepresents a policy/rule to execute with its dependencies\nand governance metadata.",
            "methods": [
              "__hash__",
              "__eq__"
            ],
            "line": 51
          },
          {
            "name": "ExecutionDAG",
            "docstring": "Directed Acyclic Graph of policy execution.\n\nProvides deterministic ordering for policy evaluation.",
            "methods": [
              "add_node",
              "add_edge",
              "get_roots",
              "get_leaves"
            ],
            "line": 76
          },
          {
            "name": "ExecutionPlan",
            "docstring": "A deterministic execution plan.\n\nContains ordered list of policies to execute with\nparallel execution opportunities.",
            "methods": [
              "to_dict"
            ],
            "line": 108
          },
          {
            "name": "DAGSorter",
            "docstring": "Sorts policies into deterministic execution order.\n\nUses topological sort with governance-aware ordering:\n1. SAFETY policies always execute first\n2. Higher priority policies execute before lower\n3. Dependencies are respected\n4. Parallelizable policies grouped into stages",
            "methods": [
              "__init__",
              "build_dag",
              "_get_phase",
              "_add_category_dependencies",
              "_add_routing_dependencies",
              "sort",
              "get_execution_order",
              "visualize"
            ],
            "line": 129
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set",
              "Tuple"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRFunction",
              "IRGovernance",
              "IRModule"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "db_helpers.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/db_helpers.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 437,
        "module_docstring": "Database helper functions for SQLModel row extraction.\n\nPIN-099: SQLModel Row Extraction Patterns\n\nThis module provides helper functions to safely extract values from\nSQLModel/SQLAlchemy query results, avoiding common anti-patterns that\ncause runtime errors.\n\nCommon Issues Prevented:\n1. Row objects are truthy even when containing 0/None\n2. Row objects don't support direct comparison operators\n3. Row objects from .all() are not Python tuples\n\nUsage:\n    from app.utils.db_helpers import scalar_or_default, extract_model\n\n    # For scalar queries (COUNT, SUM, AVG, etc.)\n    row = session.exec(select(func.count(Model.id))).first()\n    count = scalar_or_default(row, default=0)\n\n    # For model queries with potential Row wrapping\n    results = session.exec(stmt).all()\n    for row in results:\n        model = extract_model(row, 'id')",
        "functions": [
          {
            "name": "scalar_or_default",
            "signature": "(row: Optional[Any], default: Any = 0) -> Any",
            "docstring": "Extract scalar value from Row or return default.\n\nSQLModel's session.exec(stmt).first() returns a Row object for scalar\nqueries (like func.count, func.sum). This function safely extracts\nthe scalar value.\n\nArgs:\n    row: The Row object from .first(), or None if no results\n    default: Value to return if row is None or contains None\n\nReturns:\n    The scalar value from row[0], or default if unavailable\n\nExample:\n    stmt = select(func.count(Incident.id)).where(...)\n    row = session.exec(stmt).first()\n    count = scalar_or_default(row, 0)  # Returns int, not Row",
            "is_async": false,
            "line": 53
          },
          {
            "name": "scalar_or_none",
            "signature": "(row: Optional[Any]) -> Optional[Any]",
            "docstring": "Extract scalar value from Row, returning None if unavailable.\n\nSimilar to scalar_or_default but returns None instead of a default.\n\nArgs:\n    row: The Row object from .first(), or None\n\nReturns:\n    The scalar value from row[0], or None\n\nExample:\n    stmt = select(func.max(Run.ended_at)).where(...)\n    row = session.exec(stmt).first()\n    last_time = scalar_or_none(row)  # Returns datetime or None",
            "is_async": false,
            "line": 82
          },
          {
            "name": "extract_model",
            "signature": "(row: Any, model_attr: str = 'id') -> Any",
            "docstring": "Extract model instance from Row or return as-is.\n\nWhen using session.exec(stmt).all(), results may be:\n1. Model instances directly (single model select)\n2. Row objects (joins, expressions, order_by with expressions)\n\nThis function detects which case and extracts appropriately.\n\nArgs:\n    row: A result from .all() iteration\n    model_attr: An attribute that exists on the model (for detection)\n\nReturns:\n    The model instance, extracted from Row if necessary\n\nExample:\n    for row in session.exec(select(Incident).order_by(...)).all():\n        incident = extract_model(row, 'tenant_id')\n        print(incident.title)",
            "is_async": false,
            "line": 106
          },
          {
            "name": "extract_models",
            "signature": "(results: List[Any], model_attr: str = 'id') -> List[Any]",
            "docstring": "Extract model instances from a list of results.\n\nConvenience wrapper around extract_model for processing .all() results.\n\nArgs:\n    results: List from session.exec(stmt).all()\n    model_attr: An attribute that exists on the model\n\nReturns:\n    List of extracted model instances\n\nExample:\n    results = session.exec(select(Tenant).order_by(...)).all()\n    tenants = extract_models(results, 'tenant_id')",
            "is_async": false,
            "line": 142
          },
          {
            "name": "count_or_zero",
            "signature": "(row: Optional[Any]) -> int",
            "docstring": "Extract count value, guaranteed to return int.",
            "is_async": false,
            "line": 162
          },
          {
            "name": "sum_or_zero",
            "signature": "(row: Optional[Any]) -> float",
            "docstring": "Extract sum value, guaranteed to return numeric.",
            "is_async": false,
            "line": 168
          },
          {
            "name": "query_one",
            "signature": "(session: Any, statement: Any, model_class: Optional[type] = None) -> Optional[Any]",
            "docstring": "Safe single-row query with automatic Row/Model detection.\n\nHandles SQLModel version differences where .first() may return:\n- Row tuple (needs [0] extraction)\n- Model directly (no extraction needed)\n\nArgs:\n    session: SQLModel Session\n    statement: Select statement\n    model_class: Optional model class for isinstance check\n\nReturns:\n    Model instance or None\n\nExample:\n    user = query_one(session, select(User).where(User.email == email), User)",
            "is_async": false,
            "line": 179
          },
          {
            "name": "query_all",
            "signature": "(session: Any, statement: Any, model_class: Optional[type] = None) -> list",
            "docstring": "Safe multi-row query with automatic Row/Model detection.\n\nHandles SQLModel version differences where .all() may return:\n- List of Row tuples (needs [0] extraction)\n- List of Models directly (no extraction needed)\n\nArgs:\n    session: SQLModel Session\n    statement: Select statement\n    model_class: Optional model class for isinstance check\n\nReturns:\n    List of model instances\n\nExample:\n    users = query_all(session, select(User).where(User.status == 'active'), User)",
            "is_async": false,
            "line": 224
          },
          {
            "name": "model_to_dict",
            "signature": "(model: Any, include: Optional[list] = None, exclude: Optional[list] = None) -> dict",
            "docstring": "Convert ORM model to dict to prevent DetachedInstanceError.\n\nCall this BEFORE the session closes to extract values safely.\n\nArgs:\n    model: ORM model instance\n    include: List of attributes to include (None = all)\n    exclude: List of attributes to exclude\n\nReturns:\n    Dictionary with model values\n\nExample:\n    with Session(engine) as session:\n        user = session.get(User, user_id)\n        user_data = model_to_dict(user, exclude=['password_hash'])\n    # user_data is safe to use after session closes\n    return user_data",
            "is_async": false,
            "line": 268
          },
          {
            "name": "models_to_dicts",
            "signature": "(models: list, include: Optional[list] = None, exclude: Optional[list] = None) -> list",
            "docstring": "Convert list of ORM models to list of dicts.\n\nArgs:\n    models: List of ORM model instances\n    include: List of attributes to include\n    exclude: List of attributes to exclude\n\nReturns:\n    List of dictionaries",
            "is_async": false,
            "line": 331
          },
          {
            "name": "safe_get",
            "signature": "(session: Any, model_class: type, id: Any, to_dict: bool = False, include: Optional[list] = None, exclude: Optional[list] = None) -> Any",
            "docstring": "Safe session.get() wrapper with optional dict conversion.\n\nUse session.get() for direct ID lookups - it's simpler and always\nreturns the model directly (not a Row tuple).\n\nArgs:\n    session: SQLModel Session\n    model_class: Model class to query\n    id: Primary key value\n    to_dict: If True, convert to dict before returning\n    include: Attributes to include in dict\n    exclude: Attributes to exclude from dict\n\nReturns:\n    Model instance, dict, or None\n\nExample:\n    # Simple get\n    user = safe_get(session, User, user_id)\n\n    # Get as dict (safe after session closes)\n    user_data = safe_get(session, User, user_id, to_dict=True)",
            "is_async": false,
            "line": 346
          },
          {
            "name": "get_or_create",
            "signature": "(session: Any, model_class: type, defaults: Optional[dict] = None, **kwargs) -> tuple",
            "docstring": "Get existing model or create new one.\n\nSimilar to Django's get_or_create, but with proper SQLModel handling.\n\nArgs:\n    session: SQLModel Session\n    model_class: Model class\n    defaults: Dict of fields to set on creation only\n    **kwargs: Fields to filter by\n\nReturns:\n    Tuple of (instance, created: bool)\n\nExample:\n    user, created = get_or_create(\n        session, User,\n        defaults={'status': 'active'},\n        email='test@example.com'\n    )",
            "is_async": false,
            "line": 388
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional",
              "TypeVar"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [
          {
            "name": "T",
            "line": 50
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "deterministic.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/deterministic.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 143,
        "module_docstring": null,
        "functions": [
          {
            "name": "seeded_jitter",
            "signature": "(workflow_run_id: str, attempt: int) -> float",
            "docstring": "Generate deterministic jitter value from workflow ID and attempt number.\n\nUses HMAC-SHA256 to produce a consistent float between 0 and 1\nthat is reproducible given the same inputs.\n\nArgs:\n    workflow_run_id: Unique workflow run identifier\n    attempt: Current attempt number (1-based)\n\nReturns:\n    Float between 0.0 and 1.0",
            "is_async": false,
            "line": 30
          },
          {
            "name": "deterministic_backoff_ms",
            "signature": "(workflow_run_id: str, attempt: int, initial_ms: int = 200, multiplier: float = 2.0, jitter_pct: float = 0.1, max_ms: int = 10000) -> int",
            "docstring": "Calculate exponential backoff with deterministic jitter.\n\nThe jitter is derived from the workflow_run_id and attempt number,\nmaking the backoff sequence reproducible for replay verification.\n\nArgs:\n    workflow_run_id: Unique workflow run identifier\n    attempt: Current attempt number (1-based)\n    initial_ms: Initial backoff in milliseconds\n    multiplier: Exponential multiplier per attempt\n    jitter_pct: Jitter percentage (0.1 = +/- 10%)\n    max_ms: Maximum backoff in milliseconds\n\nReturns:\n    Backoff duration in milliseconds",
            "is_async": false,
            "line": 51
          },
          {
            "name": "deterministic_timestamp",
            "signature": "(workflow_run_id: str, step_index: int, base_time: Optional[float] = None) -> int",
            "docstring": "Generate a deterministic timestamp for replay scenarios.\n\nIn production, returns current time. In replay mode with base_time,\nreturns a reproducible offset from base_time.\n\nArgs:\n    workflow_run_id: Unique workflow run identifier\n    step_index: Step index within workflow\n    base_time: Base timestamp for replay (None = use current time)\n\nReturns:\n    Unix timestamp in seconds",
            "is_async": false,
            "line": 89
          },
          {
            "name": "generate_idempotency_key",
            "signature": "(workflow_run_id: str, skill_name: str, step_index: int) -> str",
            "docstring": "Generate a deterministic idempotency key for a skill execution.\n\nArgs:\n    workflow_run_id: Unique workflow run identifier\n    skill_name: Name of the skill being executed\n    step_index: Step index within workflow\n\nReturns:\n    Idempotency key string",
            "is_async": false,
            "line": 113
          },
          {
            "name": "hash_params",
            "signature": "(params: dict) -> str",
            "docstring": "Generate a hash of skill parameters for idempotency comparison.\n\nArgs:\n    params: Skill input parameters\n\nReturns:\n    SHA256 hash prefix (16 chars)",
            "is_async": false,
            "line": 130
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "struct",
            "names": [
              "struct"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "dispatch_audit.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/dispatch_audit.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 139,
        "module_docstring": "Dispatch Audit Record \u2014 pure builder for operation dispatch records.\n\nThis module provides:\n- DispatchRecord: Frozen dataclass capturing a single registry dispatch\n- build_dispatch_record(): Pure builder function (no side effects)\n\nConstitution \u00a72.3: consequences are post-commit. This module records what\nhappened AFTER the operation completed. It never participates in the\noperation's transaction.\n\nUsage:\n    record = build_dispatch_record(\n        operation=\"policies.query\",\n        tenant_id=\"t_abc\",\n        success=True,\n        duration_ms=42.3,\n        authority_allowed=True,\n        authority_degraded=False,\n        authority_reason=\"governance active\",\n        authority_code=\"ALLOWED\",\n    )\n    # Caller (AuditStore) handles persistence",
        "functions": [
          {
            "name": "build_dispatch_record",
            "signature": "(operation: str, tenant_id: str, success: bool, duration_ms: float, authority_allowed: bool = True, authority_degraded: bool = False, authority_reason: str = '', authority_code: str = '', error: Optional[str] = None, error_code: Optional[str] = None) -> DispatchRecord",
            "docstring": "Build a DispatchRecord from dispatch parameters.\n\nPure function \u2014 no side effects, no I/O, no state mutation.\n\nArgs:\n    operation: Operation name (e.g. \"policies.query\")\n    tenant_id: Tenant identifier\n    success: Whether the operation succeeded\n    duration_ms: Execution duration in milliseconds\n    authority_allowed: Whether authority allowed the operation\n    authority_degraded: Whether authority was in degraded mode\n    authority_reason: Human-readable authority reason\n    authority_code: Machine-readable authority code\n    error: Error message (failures only)\n    error_code: Error code (failures only)\n\nReturns:\n    Frozen DispatchRecord",
            "is_async": false,
            "line": 95
          }
        ],
        "classes": [
          {
            "name": "DispatchRecord",
            "docstring": "Immutable record of a single operation dispatch.\n\nFields mirror _audit_dispatch() log_data plus timestamp.\nFrozen: once built, never mutated.",
            "methods": [
              "to_dict"
            ],
            "line": 52
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "fatigue_controller.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/fatigue_controller.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 749,
        "module_docstring": "AlertFatigueController - Alert fatigue management service.\n\nManages alert fatigue through:\n- Rate limiting: Limit alerts per source per time window\n- Suppression: Temporarily suppress repetitive alerts\n- Aggregation: Group similar alerts together\n- Cool-down periods: Auto-suppress after threshold breaches",
        "functions": [
          {
            "name": "get_alert_fatigue_controller",
            "signature": "() -> AlertFatigueController",
            "docstring": "Get the singleton controller instance.",
            "is_async": false,
            "line": 695
          },
          {
            "name": "_reset_controller",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 703
          },
          {
            "name": "check_alert_fatigue",
            "signature": "(tenant_id: str, alert_type: str, source_id: Optional[str] = None, source_data: Optional[dict[str, Any]] = None, alert_data: Optional[dict[str, Any]] = None) -> FatigueCheckResult",
            "docstring": "Check if an alert should be allowed or suppressed.",
            "is_async": false,
            "line": 712
          },
          {
            "name": "suppress_alert",
            "signature": "(tenant_id: str, source_id: str, alert_type: str, duration_seconds: Optional[int] = None) -> AlertFatigueState",
            "docstring": "Manually suppress an alert source.",
            "is_async": false,
            "line": 730
          },
          {
            "name": "get_fatigue_stats",
            "signature": "(tenant_id: Optional[str] = None) -> AlertFatigueStats",
            "docstring": "Get fatigue statistics.",
            "is_async": false,
            "line": 746
          }
        ],
        "classes": [
          {
            "name": "AlertFatigueMode",
            "docstring": "Operating modes for fatigue control.",
            "methods": [],
            "line": 37
          },
          {
            "name": "AlertFatigueAction",
            "docstring": "Actions taken by the fatigue controller.",
            "methods": [],
            "line": 46
          },
          {
            "name": "AlertFatigueConfig",
            "docstring": "Configuration for alert fatigue thresholds.",
            "methods": [
              "to_dict"
            ],
            "line": 58
          },
          {
            "name": "AlertFatigueState",
            "docstring": "State tracking for an alert source.",
            "methods": [
              "record_alert",
              "reset_window",
              "start_suppression",
              "end_suppression",
              "start_cooldown",
              "end_cooldown",
              "add_to_aggregation",
              "flush_aggregation",
              "is_window_expired",
              "is_suppression_expired",
              "is_cooldown_expired",
              "to_dict"
            ],
            "line": 96
          },
          {
            "name": "AlertFatigueStats",
            "docstring": "Statistics from fatigue controller.",
            "methods": [
              "update_rates",
              "to_dict"
            ],
            "line": 257
          },
          {
            "name": "AlertFatigueError",
            "docstring": "Exception for fatigue controller errors.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 304
          },
          {
            "name": "FatigueCheckResult",
            "docstring": "Result of a fatigue check.",
            "methods": [
              "to_dict"
            ],
            "line": 328
          },
          {
            "name": "AlertFatigueController",
            "docstring": "Controller for managing alert fatigue.\n\nFeatures:\n- Rate limiting per source\n- Automatic suppression after thresholds\n- Alert aggregation\n- Cool-down periods\n- Per-tenant configuration",
            "methods": [
              "__init__",
              "_get_state_key",
              "_generate_source_id",
              "configure_tenant",
              "get_config",
              "get_or_create_state",
              "get_state",
              "check_alert",
              "suppress_source",
              "unsuppress_source",
              "get_statistics",
              "get_active_sources",
              "clear_tenant",
              "reset"
            ],
            "line": 351
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/guard.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 622,
        "module_docstring": "Guard Console Data Contracts - Customer-Facing API\n\nDOMAIN: Customer Console (/guard/*)\nAUDIENCE: Customers (tenant-scoped access)\nAUTH: aud=\"console\", requires org_id\n\nThese contracts are FROZEN as of M29. Changes require:\n1. Deprecation annotation\n2. 2-version grace period\n3. PIN documentation\n\nINVARIANTS:\n- All responses are tenant-scoped (no cross-tenant data)\n- No founder-only fields (those belong in ops.py)\n- Times are ISO8601 strings\n- IDs are prefixed strings (inc_, key_, etc.)",
        "functions": [],
        "classes": [
          {
            "name": "GuardStatusDTO",
            "docstring": "GET /guard/status response.\n\nTells customer if their traffic is protected.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 48
          },
          {
            "name": "TodaySnapshotDTO",
            "docstring": "GET /guard/snapshot/today response.\n\nToday's metrics at a glance.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 83
          },
          {
            "name": "IncidentSummaryDTO",
            "docstring": "Incident list item.\n\nUsed in GET /guard/incidents (list) and detail views.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 114
          },
          {
            "name": "IncidentEventDTO",
            "docstring": "Timeline event within an incident.",
            "methods": [],
            "line": 137
          },
          {
            "name": "IncidentDetailDTO",
            "docstring": "GET /guard/incidents/{id} response.\n\nFull incident with timeline.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 147
          },
          {
            "name": "IncidentListDTO",
            "docstring": "GET /guard/incidents response (paginated).\n\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 159
          },
          {
            "name": "CustomerIncidentImpactDTO",
            "docstring": "Impact assessment for customers - calm, explicit.\n\nFrozen: 2025-12-24 (M29 Category 5)",
            "methods": [],
            "line": 183
          },
          {
            "name": "CustomerIncidentResolutionDTO",
            "docstring": "Resolution status for customers - reassuring.\n\nFrozen: 2025-12-24 (M29 Category 5)",
            "methods": [],
            "line": 197
          },
          {
            "name": "CustomerIncidentActionDTO",
            "docstring": "Customer action item - only if necessary.\n\nFrozen: 2025-12-24 (M29 Category 5)",
            "methods": [],
            "line": 210
          },
          {
            "name": "CustomerIncidentNarrativeDTO",
            "docstring": "GET /guard/incidents/{id} enhanced response.\n\nCustomer-friendly incident detail with calm narrative.\nAnswers: What happened? Did it affect me? Is it fixed? Do I need to act?\n\nFrozen: 2025-12-24 (M29 Category 5)\n\nIMPORTANT: This is CUSTOMER-ONLY data.\n- Uses calm vocabulary (normal, rising, protected, resolved)\n- No internal terminology (no policy names, no thresholds)\n- No cross-tenant data (no affected_tenants, no percentiles)",
            "methods": [],
            "line": 223
          },
          {
            "name": "ApiKeyDTO",
            "docstring": "API key response (masked).\n\nGET /guard/keys response item.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 302
          },
          {
            "name": "ApiKeyListDTO",
            "docstring": "GET /guard/keys response.",
            "methods": [],
            "line": 321
          },
          {
            "name": "GuardrailConfigDTO",
            "docstring": "Individual guardrail configuration.",
            "methods": [],
            "line": 333
          },
          {
            "name": "TenantSettingsDTO",
            "docstring": "GET /guard/settings response.\n\nRead-only tenant configuration view.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 342
          },
          {
            "name": "ReplayCallSnapshotDTO",
            "docstring": "Original call context for replay.",
            "methods": [],
            "line": 364
          },
          {
            "name": "ReplayCertificateDTO",
            "docstring": "Cryptographic proof of replay (M23).",
            "methods": [],
            "line": 374
          },
          {
            "name": "ReplayResultDTO",
            "docstring": "POST /guard/replay/{call_id} response.\n\nResult of replaying a call with determinism validation.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 386
          },
          {
            "name": "KillSwitchActionDTO",
            "docstring": "POST /guard/killswitch/activate and /deactivate response.\n\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 407
          },
          {
            "name": "OnboardingVerifyResponseDTO",
            "docstring": "POST /guard/onboarding/verify response.\n\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 425
          },
          {
            "name": "CustomerCostSummaryDTO",
            "docstring": "GET /guard/costs/summary response.\n\nCustomer cost summary with trend and projection.\nFrozen: 2025-12-23 (M29 Category 4)\n\nTHE INVARIANT: All values derive from complete snapshots, never live data.\nCustomer sees their own tenant data only - no cross-tenant leakage.",
            "methods": [],
            "line": 443
          },
          {
            "name": "CostBreakdownItemDTO",
            "docstring": "Individual cost breakdown item.",
            "methods": [],
            "line": 497
          },
          {
            "name": "CustomerCostExplainedDTO",
            "docstring": "GET /guard/costs/explained response.\n\nExplains WHY costs are what they are.\nFrozen: 2025-12-23 (M29 Category 4)\n\nIMPORTANT: Does not expose founder-only fields like churn_risk or affected_tenants.",
            "methods": [],
            "line": 508
          },
          {
            "name": "CustomerCostIncidentDTO",
            "docstring": "Cost-related incident visible to customer.\n\nUsed in GET /guard/costs/incidents response.\nFrozen: 2025-12-23 (M29 Category 4)\n\nIMPORTANT: Uses calm vocabulary (protected, attention_needed).\nDoes not expose severity levels - maps internally.",
            "methods": [],
            "line": 582
          },
          {
            "name": "CustomerCostIncidentListDTO",
            "docstring": "GET /guard/costs/incidents response.",
            "methods": [],
            "line": 617
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Literal",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "input_sanitizer.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/input_sanitizer.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 260,
        "module_docstring": null,
        "functions": [
          {
            "name": "detect_injection_patterns",
            "signature": "(text: str) -> List[tuple]",
            "docstring": "Detect prompt injection patterns in text.\n\nReturns:\n    List of (pattern_name, matched_text) tuples",
            "is_async": false,
            "line": 110
          },
          {
            "name": "extract_urls",
            "signature": "(text: str) -> List[str]",
            "docstring": "Extract all URLs from text.",
            "is_async": false,
            "line": 124
          },
          {
            "name": "is_url_safe",
            "signature": "(url: str) -> tuple[bool, Optional[str]]",
            "docstring": "Check if a URL is safe (not targeting internal resources).\n\nReturns:\n    Tuple of (is_safe, reason_if_unsafe)",
            "is_async": false,
            "line": 130
          },
          {
            "name": "sanitize_goal",
            "signature": "(goal: str) -> SanitizationResult",
            "docstring": "Sanitize a goal string before processing.\n\nThis is the main entry point for the input sanitizer.\n\nArgs:\n    goal: The user-provided goal text\n\nReturns:\n    SanitizationResult with sanitized text and safety info",
            "is_async": false,
            "line": 168
          },
          {
            "name": "validate_goal",
            "signature": "(goal: str) -> tuple[bool, Optional[str], List[str]]",
            "docstring": "Convenience function to validate a goal.\n\nReturns:\n    Tuple of (is_valid, error_message, warnings)",
            "is_async": false,
            "line": 253
          }
        ],
        "classes": [
          {
            "name": "SanitizationResult",
            "docstring": "Result of input sanitization.",
            "methods": [
              "__post_init__"
            ],
            "line": 96
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "urllib.parse",
            "names": [
              "urlparse"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [
          {
            "name": "MAX_GOAL_LENGTH",
            "line": 35
          },
          {
            "name": "ENABLE_INJECTION_DETECTION",
            "line": 38
          },
          {
            "name": "ENABLE_URL_SANITIZATION",
            "line": 39
          },
          {
            "name": "INJECTION_PATTERNS",
            "line": 55
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "lifecycle_facade.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/lifecycle_facade.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 709,
        "module_docstring": "Lifecycle Facade (L4 Domain Logic)\n\nThis facade provides the external interface for lifecycle operations.\nAll lifecycle APIs MUST use this facade instead of directly importing\ninternal lifecycle modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes agent and run lifecycle logic\n- Provides unified access to state transitions\n- Single point for audit emission\n\nL2 API Routes (GAP-131 to GAP-136):\n- POST /api/v1/lifecycle/agents (create agent)\n- GET /api/v1/lifecycle/agents (list agents)\n- GET /api/v1/lifecycle/agents/{id} (get agent)\n- POST /api/v1/lifecycle/agents/{id}/start (start agent)\n- POST /api/v1/lifecycle/agents/{id}/stop (stop agent)\n- POST /api/v1/lifecycle/agents/{id}/terminate (terminate agent)\n- POST /api/v1/lifecycle/runs (create run)\n- GET /api/v1/lifecycle/runs (list runs)\n- GET /api/v1/lifecycle/runs/{id} (get run)\n- POST /api/v1/lifecycle/runs/{id}/pause (pause run)\n- POST /api/v1/lifecycle/runs/{id}/resume (resume run)\n- POST /api/v1/lifecycle/runs/{id}/cancel (cancel run)\n\nUsage:\n    # L5 engine import (V2.0.0 - hoc_spine)\n    from app.hoc.cus.hoc_spine.services.lifecycle_facade import get_lifecycle_facade\n\n    facade = get_lifecycle_facade()\n\n    # Start an agent\n    agent = await facade.start_agent(agent_id=\"...\", tenant_id=\"...\")",
        "functions": [
          {
            "name": "get_lifecycle_facade",
            "signature": "() -> LifecycleFacade",
            "docstring": "Get the lifecycle facade instance.\n\nThis is the recommended way to access lifecycle operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    LifecycleFacade instance",
            "is_async": false,
            "line": 696
          }
        ],
        "classes": [
          {
            "name": "AgentState",
            "docstring": "Agent lifecycle states.",
            "methods": [],
            "line": 69
          },
          {
            "name": "RunState",
            "docstring": "Run lifecycle states.",
            "methods": [],
            "line": 80
          },
          {
            "name": "AgentLifecycle",
            "docstring": "Agent lifecycle information.",
            "methods": [
              "to_dict"
            ],
            "line": 91
          },
          {
            "name": "RunLifecycle",
            "docstring": "Run lifecycle information.",
            "methods": [
              "to_dict"
            ],
            "line": 123
          },
          {
            "name": "LifecycleSummary",
            "docstring": "Summary of lifecycle entities.",
            "methods": [
              "to_dict"
            ],
            "line": 161
          },
          {
            "name": "LifecycleFacade",
            "docstring": "Facade for lifecycle operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nlifecycle services.\n\nLayer: L4 (Domain Logic)\nCallers: lifecycle.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "create_agent",
              "list_agents",
              "get_agent",
              "start_agent",
              "stop_agent",
              "terminate_agent",
              "create_run",
              "list_runs",
              "get_run",
              "pause_run",
              "resume_run",
              "cancel_run",
              "get_summary"
            ],
            "line": 190
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 64
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lifecycle_stages_base.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/lifecycle_stages_base.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 317,
        "module_docstring": "Stage Handler Protocol and Base Types\n\nThis module defines the contract for lifecycle stage handlers.\n\nCRITICAL DESIGN INVARIANT:\n    Stage handlers are DUMB PLUGINS.\n    They do NOT manage state.\n    They do NOT emit events.\n    They do NOT check policies.\n    The orchestrator does ALL of that.\n\nWhy Dumb:\n- If stages manage state, you get split-brain\n- If stages emit events, you get duplicate audit\n- If stages check policy, you get enforcement fragmentation",
        "functions": [],
        "classes": [
          {
            "name": "StageStatus",
            "docstring": "Result status from stage execution.",
            "methods": [],
            "line": 47
          },
          {
            "name": "StageContext",
            "docstring": "Context passed to stage handlers.\n\nContains all information a stage needs to execute,\nwithout giving it direct access to state management.",
            "methods": [],
            "line": 56
          },
          {
            "name": "StageResult",
            "docstring": "Result returned by stage handlers.\n\nStage handlers return this to indicate success/failure.\nThe orchestrator uses this to decide what to do next.",
            "methods": [
              "success",
              "is_async",
              "ok",
              "fail",
              "pending",
              "skipped"
            ],
            "line": 83
          },
          {
            "name": "StageHandler",
            "docstring": "Protocol for stage handlers.\n\nStage handlers are dumb. The orchestrator is smart.\n\nImplementation Requirements:\n- Must be stateless (no instance state that affects execution)\n- Must not call KnowledgeLifecycleManager methods\n- Must not emit audit events\n- Must not check policies\n- Must only perform their specific operation",
            "methods": [
              "stage_name",
              "handles_states",
              "execute",
              "validate"
            ],
            "line": 159
          },
          {
            "name": "BaseStageHandler",
            "docstring": "Base class for stage handlers.\n\nProvides common implementation while enforcing the \"dumb plugin\" contract.",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute"
            ],
            "line": 214
          },
          {
            "name": "StageRegistry",
            "docstring": "Registry of stage handlers.\n\nMaps states to their handlers for the orchestrator to use.",
            "methods": [
              "__init__",
              "register",
              "get_handler",
              "has_handler",
              "create_default"
            ],
            "line": 253
          }
        ],
        "imports": [
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.models.knowledge_lifecycle",
            "names": [
              "KnowledgePlaneLifecycleState"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "metrics_helpers.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/metrics_helpers.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 210,
        "module_docstring": "Prometheus Metrics Helpers - Idempotent Registration\n\nThis module provides helper functions for creating Prometheus metrics\nthat are safe to use in modules that may be reimported during testing.\n\nUsage:\n    from app.utils.metrics_helpers import get_or_create_counter, get_or_create_gauge\n\n    MY_COUNTER = get_or_create_counter(\n        \"mymodule_operations_total\",\n        \"Total operations\",\n        [\"status\", \"type\"]\n    )\n\nPrevention: PIN-120 / PREV-1 - Prevents duplicate timeseries errors in tests.",
        "functions": [
          {
            "name": "_find_existing_metric",
            "signature": "(name: str)",
            "docstring": "Find an existing metric in the registry by name.\n\nPrometheus registers metrics under multiple keys (base name, _total, _created).\nThe collector's _name attribute contains the base name.\n\nArgs:\n    name: The base metric name (without _total suffix for counters)\n\nReturns:\n    The existing metric collector if found, None otherwise",
            "is_async": false,
            "line": 44
          },
          {
            "name": "get_or_create_counter",
            "signature": "(name: str, documentation: str, labelnames: Optional[List[str]] = None) -> Counter",
            "docstring": "Get existing counter or create new one - idempotent.\n\nArgs:\n    name: Metric name (should follow naming convention: {module}_{metric}_total)\n    documentation: Help text for the metric\n    labelnames: List of label names\n\nReturns:\n    Counter metric (existing or new)\n\nExample:\n    MY_COUNTER = get_or_create_counter(\n        \"drift_detector_comparisons_total\",\n        \"Total drift comparisons performed\",\n        [\"status\"]\n    )",
            "is_async": false,
            "line": 69
          },
          {
            "name": "get_or_create_gauge",
            "signature": "(name: str, documentation: str, labelnames: Optional[List[str]] = None) -> Gauge",
            "docstring": "Get existing gauge or create new one - idempotent.\n\nArgs:\n    name: Metric name (should follow naming convention: {module}_{metric})\n    documentation: Help text for the metric\n    labelnames: List of label names\n\nReturns:\n    Gauge metric (existing or new)\n\nExample:\n    MY_GAUGE = get_or_create_gauge(\n        \"policy_cache_size\",\n        \"Current policy cache size\",\n        [\"tenant_id\"]\n    )",
            "is_async": false,
            "line": 94
          },
          {
            "name": "get_or_create_histogram",
            "signature": "(name: str, documentation: str, labelnames: Optional[List[str]] = None, buckets: Optional[List[float]] = None) -> Histogram",
            "docstring": "Get existing histogram or create new one - idempotent.\n\nArgs:\n    name: Metric name (should follow naming convention: {module}_{metric}_seconds)\n    documentation: Help text for the metric\n    labelnames: List of label names\n    buckets: Histogram bucket boundaries\n\nReturns:\n    Histogram metric (existing or new)\n\nExample:\n    MY_HISTOGRAM = get_or_create_histogram(\n        \"outbox_processing_seconds\",\n        \"Time to process outbox events\",\n        buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 5.0]\n    )",
            "is_async": false,
            "line": 119
          },
          {
            "name": "validate_metric_name",
            "signature": "(name: str) -> bool",
            "docstring": "Validate metric name follows conventions.\n\nConvention (PIN-120 / PREV-2):\n- Counter: {module}_{metric}_total\n- Histogram: {module}_{metric}_seconds\n- Gauge: {module}_{metric} (no required suffix)\n- Info: {module}_{metric}_info\n\nArgs:\n    name: Metric name to validate\n\nReturns:\n    True if valid, False otherwise",
            "is_async": false,
            "line": 159
          },
          {
            "name": "reset_metrics_registry",
            "signature": "()",
            "docstring": "Reset the Prometheus registry for test isolation.\n\nWARNING: Only use in test fixtures, never in production code.",
            "is_async": false,
            "line": 192
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "prometheus_client",
            "names": [
              "REGISTRY",
              "Counter",
              "Gauge",
              "Histogram"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [
          {
            "name": "VALID_SUFFIXES",
            "line": 156
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "monitors_facade.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/monitors_facade.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 541,
        "module_docstring": "Monitors Facade (L4 Domain Logic)\n\nThis facade provides the external interface for monitoring operations.\nAll monitor APIs MUST use this facade instead of directly importing\ninternal monitor modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes health monitoring logic\n- Provides unified access to monitor configuration\n- Single point for audit emission\n\nL2 API Routes (GAP-120, GAP-121):\n- POST /api/v1/monitors (create monitor)\n- GET /api/v1/monitors (list monitors)\n- GET /api/v1/monitors/{id} (get monitor)\n- PUT /api/v1/monitors/{id} (update monitor)\n- DELETE /api/v1/monitors/{id} (delete monitor)\n- POST /api/v1/monitors/{id}/check (run health check)\n- GET /api/v1/monitors/{id}/history (check history)\n- GET /api/v1/monitors/status (overall status)\n\nUsage:\n    from app.hoc.cus.hoc_spine.services.monitors_facade import get_monitors_facade\n\n    facade = get_monitors_facade()\n\n    # Create monitor\n    monitor = await facade.create_monitor(\n        tenant_id=\"...\",\n        name=\"API Health\",\n        target={\"url\": \"https://api.example.com/health\"},\n    )",
        "functions": [
          {
            "name": "get_monitors_facade",
            "signature": "() -> MonitorsFacade",
            "docstring": "Get the monitors facade instance.\n\nThis is the recommended way to access monitor operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    MonitorsFacade instance",
            "is_async": false,
            "line": 528
          }
        ],
        "classes": [
          {
            "name": "MonitorType",
            "docstring": "Types of monitors.",
            "methods": [],
            "line": 67
          },
          {
            "name": "MonitorStatus",
            "docstring": "Monitor status.",
            "methods": [],
            "line": 76
          },
          {
            "name": "CheckStatus",
            "docstring": "Health check result status.",
            "methods": [],
            "line": 84
          },
          {
            "name": "MonitorConfig",
            "docstring": "Monitor configuration.",
            "methods": [
              "to_dict"
            ],
            "line": 93
          },
          {
            "name": "HealthCheckResult",
            "docstring": "Health check result.",
            "methods": [
              "to_dict"
            ],
            "line": 133
          },
          {
            "name": "MonitorStatusSummary",
            "docstring": "Overall monitoring status summary.",
            "methods": [
              "to_dict"
            ],
            "line": 159
          },
          {
            "name": "MonitorsFacade",
            "docstring": "Facade for monitor operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nmonitoring services.\n\nLayer: L4 (Domain Logic)\nCallers: monitors.py (L2), aos_sdk, Scheduler",
            "methods": [
              "__init__",
              "create_monitor",
              "list_monitors",
              "get_monitor",
              "update_monitor",
              "delete_monitor",
              "run_check",
              "get_check_history",
              "get_status_summary"
            ],
            "line": 180
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 62
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "rate_limiter.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/rate_limiter.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 184,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_rate_limiter",
            "signature": "() -> RateLimiter",
            "docstring": "Get the singleton rate limiter instance.",
            "is_async": false,
            "line": 166
          },
          {
            "name": "allow_request",
            "signature": "(key: str, rate_per_min: int) -> bool",
            "docstring": "Convenience function to check rate limit.\n\nArgs:\n    key: Rate limit key\n    rate_per_min: Max requests per minute\n\nReturns:\n    True if allowed",
            "is_async": false,
            "line": 174
          }
        ],
        "classes": [
          {
            "name": "RateLimiter",
            "docstring": "Token bucket rate limiter using Redis.\n\nProvides per-key rate limiting with configurable RPM.\nFalls back to allowing requests if Redis is unavailable.",
            "methods": [
              "__init__",
              "_get_client",
              "allow",
              "get_remaining"
            ],
            "line": 60
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [
          {
            "name": "REDIS_URL",
            "line": 31
          },
          {
            "name": "TOKEN_BUCKET_LUA",
            "line": 34
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "retrieval_facade.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/retrieval_facade.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 518,
        "module_docstring": "Retrieval Facade (L4 Domain Logic)\n\nThis facade provides the external interface for mediated data retrieval operations.\nAll retrieval APIs MUST use this facade instead of directly importing\nthe RetrievalMediator.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes retrieval mediation logic\n- Provides unified access to data retrieval with policy enforcement\n- Single point for audit emission\n\nWrapped Services:\n- RetrievalMediator: Central choke point for data access (GAP-065)\n\nL2 API Routes (GAP-094):\n- POST /api/v1/retrieval/access (mediated data access)\n- GET /api/v1/retrieval/planes (list available planes)\n- GET /api/v1/retrieval/evidence (retrieve evidence records)\n\nUsage:\n    from app.hoc.cus.hoc_spine.services.retrieval_facade import get_retrieval_facade\n\n    facade = get_retrieval_facade()\n\n    # Mediated data access\n    result = await facade.access_data(\n        tenant_id=\"...\",\n        run_id=\"...\",\n        plane_id=\"documents\",\n        action=\"query\",\n        payload={\"query\": \"...\"},\n    )\n\n    # List available planes\n    planes = await facade.list_planes(tenant_id=\"...\")",
        "functions": [
          {
            "name": "get_retrieval_facade",
            "signature": "() -> RetrievalFacade",
            "docstring": "Get the retrieval facade instance.\n\nThis is the recommended way to access retrieval operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    RetrievalFacade instance",
            "is_async": false,
            "line": 505
          }
        ],
        "classes": [
          {
            "name": "AccessResult",
            "docstring": "Result of a mediated data access.",
            "methods": [
              "to_dict"
            ],
            "line": 67
          },
          {
            "name": "PlaneInfo",
            "docstring": "Information about a knowledge plane.",
            "methods": [
              "to_dict"
            ],
            "line": 97
          },
          {
            "name": "EvidenceInfo",
            "docstring": "Evidence record information.",
            "methods": [
              "to_dict"
            ],
            "line": 119
          },
          {
            "name": "RetrievalFacade",
            "docstring": "Facade for mediated data retrieval operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nthe retrieval mediator.\n\nLayer: L4 (Domain Logic)\nCallers: retrieval.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "mediator",
              "access_data",
              "list_planes",
              "register_plane",
              "get_plane",
              "list_evidence",
              "get_evidence",
              "record_evidence"
            ],
            "line": 148
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "retrieval_mediator.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/retrieval_mediator.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 471,
        "module_docstring": "Module: retrieval_mediator\nPurpose: All external data access must route through this layer.\n\nThis is the CENTRAL CHOKE POINT for data retrieval.\nAny data access from LLM-controlled code MUST go through here.\n\nImports (Dependencies):\n    - None (interfaces defined here, implementations injected)\n\nExports (Provides):\n    - RetrievalMediator: Main mediation class\n    - MediatedResult: Result of a mediated access\n    - MediationDeniedError: Raised when access denied\n    - get_retrieval_mediator(): Factory to get singleton\n\nWiring Points:\n    - Called from: L2 API route /api/v1/mediation/access\n    - Calls: PolicyEngine (injected), ConnectorRegistry (injected)\n\nInvariant: Deny-by-default. All access blocked unless explicitly allowed.\n\nAcceptance Criteria:\n    - [x] AC-065-01: All data access routes through mediator\n    - [x] AC-065-02: Deny-by-default enforced\n    - [x] AC-065-03: Evidence emitted for every access\n    - [x] AC-065-04: Policy check before connector\n    - [x] AC-065-05: Tenant isolation enforced",
        "functions": [
          {
            "name": "get_retrieval_mediator",
            "signature": "() -> RetrievalMediator",
            "docstring": "Get or create the singleton RetrievalMediator.\n\nIn production, this should be configured with real implementations\nof PolicyChecker, ConnectorRegistry, and EvidenceService.",
            "is_async": false,
            "line": 431
          },
          {
            "name": "configure_retrieval_mediator",
            "signature": "(policy_checker: Optional[PolicyChecker] = None, connector_registry: Optional[ConnectorRegistry] = None, evidence_service: Optional[EvidenceService] = None) -> RetrievalMediator",
            "docstring": "Configure the singleton RetrievalMediator with dependencies.\n\nCall this at startup to inject real implementations.",
            "is_async": false,
            "line": 447
          }
        ],
        "classes": [
          {
            "name": "MediationAction",
            "docstring": "Allowed mediation actions.",
            "methods": [],
            "line": 59
          },
          {
            "name": "MediatedResult",
            "docstring": "Result of a mediated data access.",
            "methods": [],
            "line": 68
          },
          {
            "name": "PolicyCheckResult",
            "docstring": "Result of policy check.",
            "methods": [],
            "line": 82
          },
          {
            "name": "EvidenceRecord",
            "docstring": "Evidence record for a mediated access.",
            "methods": [],
            "line": 91
          },
          {
            "name": "MediationDeniedError",
            "docstring": "Raised when mediation denies access.",
            "methods": [
              "__init__"
            ],
            "line": 105
          },
          {
            "name": "Connector",
            "docstring": "Protocol for connectors.",
            "methods": [
              "execute"
            ],
            "line": 123
          },
          {
            "name": "ConnectorRegistry",
            "docstring": "Protocol for connector registry.",
            "methods": [
              "resolve"
            ],
            "line": 133
          },
          {
            "name": "PolicyChecker",
            "docstring": "Protocol for policy checking.",
            "methods": [
              "check_access"
            ],
            "line": 146
          },
          {
            "name": "EvidenceService",
            "docstring": "Protocol for evidence recording.",
            "methods": [
              "record"
            ],
            "line": 161
          },
          {
            "name": "RetrievalMediator",
            "docstring": "Unified mediation layer for all external data access.\n\nFlow:\n1. Receive access request (plane_id, action, payload)\n2. Tenant isolation check\n3. Policy check (deny-by-default)\n4. Connector resolution (plane -> data source)\n5. Execute access through connector\n6. Emit retrieval evidence\n7. Return result\n\nAll data access from LLM-controlled code MUST go through this layer.",
            "methods": [
              "__init__",
              "access",
              "_check_policy",
              "_resolve_connector",
              "_record_evidence",
              "_hash_payload"
            ],
            "line": 180
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "scheduler_facade.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/scheduler_facade.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 552,
        "module_docstring": "Scheduler Facade (L4 Domain Logic)\n\nThis facade provides the external interface for scheduled job operations.\nAll scheduler APIs MUST use this facade instead of directly importing\ninternal scheduler modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes job scheduling logic\n- Provides unified access to job management\n- Single point for audit emission\n\nL2 API Routes (GAP-112):\n- POST /api/v1/scheduler/jobs (create job)\n- GET /api/v1/scheduler/jobs (list jobs)\n- GET /api/v1/scheduler/jobs/{id} (get job)\n- PUT /api/v1/scheduler/jobs/{id} (update job)\n- DELETE /api/v1/scheduler/jobs/{id} (delete job)\n- POST /api/v1/scheduler/jobs/{id}/trigger (trigger job)\n- POST /api/v1/scheduler/jobs/{id}/pause (pause job)\n- POST /api/v1/scheduler/jobs/{id}/resume (resume job)\n- GET /api/v1/scheduler/jobs/{id}/runs (job run history)\n\nUsage:\n    # L5 engine import (V2.0.0 - hoc_spine)\n    from app.hoc.cus.hoc_spine.services.scheduler_facade import get_scheduler_facade\n\n    facade = get_scheduler_facade()\n\n    # Create scheduled job\n    job = await facade.create_job(\n        tenant_id=\"...\",\n        name=\"Daily Report\",\n        schedule=\"0 9 * * *\",\n        action={\"type\": \"run_agent\", \"agent_id\": \"...\"},\n    )",
        "functions": [
          {
            "name": "get_scheduler_facade",
            "signature": "() -> SchedulerFacade",
            "docstring": "Get the scheduler facade instance.\n\nThis is the recommended way to access scheduler operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    SchedulerFacade instance",
            "is_async": false,
            "line": 539
          }
        ],
        "classes": [
          {
            "name": "JobStatus",
            "docstring": "Job status.",
            "methods": [],
            "line": 69
          },
          {
            "name": "JobRunStatus",
            "docstring": "Job run status.",
            "methods": [],
            "line": 76
          },
          {
            "name": "ScheduledJob",
            "docstring": "Scheduled job definition.",
            "methods": [
              "to_dict"
            ],
            "line": 86
          },
          {
            "name": "JobRun",
            "docstring": "Job run history entry.",
            "methods": [
              "to_dict"
            ],
            "line": 124
          },
          {
            "name": "SchedulerFacade",
            "docstring": "Facade for scheduled job operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nscheduler services.\n\nLayer: L4 (Domain Logic)\nCallers: scheduler.py (L2), aos_sdk, Worker",
            "methods": [
              "__init__",
              "create_job",
              "list_jobs",
              "get_job",
              "update_job",
              "delete_job",
              "trigger_job",
              "pause_job",
              "resume_job",
              "list_runs",
              "get_run",
              "_calculate_next_run"
            ],
            "line": 151
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 64
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "time.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/time.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 25,
        "module_docstring": null,
        "functions": [
          {
            "name": "utc_now",
            "signature": "() -> datetime",
            "docstring": "Get current UTC time.",
            "is_async": false,
            "line": 23
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 20
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "webhook_verify.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/services/webhook_verify.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 294,
        "module_docstring": "Webhook Signature Verification Utility\n\nProvides HMAC-SHA256 signature verification for webhook receivers with\nsupport for key versioning and grace periods during rotation.\n\nUsage (FastAPI example):\n    from app.utils.webhook_verify import WebhookVerifier\n\n    verifier = WebhookVerifier(keys={\n        \"v1\": \"old_key_hex...\",\n        \"v2\": \"new_key_hex...\",\n    }, current_version=\"v2\", grace_versions=[\"v1\"])\n\n    @app.post(\"/webhook\")\n    async def receive_webhook(request: Request):\n        body = await request.body()\n        signature = request.headers.get(\"X-Webhook-Signature\")\n        key_version = request.headers.get(\"X-Webhook-Key-Version\")\n\n        if not verifier.verify(body, signature, key_version):\n            raise HTTPException(status_code=401, detail=\"Invalid signature\")\n        # Process webhook...",
        "functions": [
          {
            "name": "create_file_key_loader",
            "signature": "(keys_path: str) -> Callable[[str], Optional[str]]",
            "docstring": "Create a key loader that reads from files.\n\nArgs:\n    keys_path: Directory containing key files (e.g., /var/lib/aos/webhook-keys)\n\nReturns:\n    Function that loads key hex string for a version",
            "is_async": false,
            "line": 213
          },
          {
            "name": "create_vault_key_loader",
            "signature": "(mount_path: str = 'secret', secret_path: str = 'webhook/keys') -> Callable[[str], Optional[str]]",
            "docstring": "Create a key loader that reads from Vault.\n\nRequires hvac library: pip install hvac\n\nArgs:\n    mount_path: Vault KV v2 mount path\n    secret_path: Path to secret within mount\n\nReturns:\n    Function that loads key hex string for a version",
            "is_async": false,
            "line": 233
          },
          {
            "name": "verify_webhook",
            "signature": "(body: bytes, signature: str, key_version: Optional[str], keys: Dict[str, str], grace_versions: Optional[List[str]] = None) -> bool",
            "docstring": "Quick verification without creating a WebhookVerifier instance.\n\nArgs:\n    body: Raw request body\n    signature: X-Webhook-Signature header\n    key_version: X-Webhook-Key-Version header\n    keys: Dict of version -> hex key\n    grace_versions: List of grace period versions\n\nReturns:\n    True if valid",
            "is_async": false,
            "line": 270
          }
        ],
        "classes": [
          {
            "name": "WebhookVerifier",
            "docstring": "Webhook signature verifier with key version support.\n\nSupports zero-downtime key rotation by accepting:\n1. The specified key version from X-Webhook-Key-Version header\n2. Grace period versions during rotation\n3. Current version as fallback if no header provided",
            "methods": [
              "__init__",
              "_parse_grace_env",
              "_get_key",
              "_compute_signature",
              "verify",
              "sign"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Callable",
              "Dict",
              "List",
              "Optional",
              "Union"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "conftest.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/tests/conftest.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 9,
        "module_docstring": null,
        "functions": [],
        "classes": [],
        "imports": [],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "test_operation_registry.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/tests/test_operation_registry.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 305,
        "module_docstring": "Operation Registry Tests\n\nTests for the L4 operation dispatch registry.\nSubject: backend/app/hoc/cus/hoc_spine/orchestrator/operation_registry.py\n\nInvariants tested:\n- REG-001: Register + execute round-trip works\n- REG-002: Unknown operation returns UNKNOWN_OPERATION error\n- REG-003: Duplicate registration raises RuntimeError\n- REG-004: Frozen registry rejects new registrations\n- REG-005: Handler exceptions are caught and wrapped in OperationResult\n- REG-006: Introspection (operations list, count, has_operation)\n- REG-007: OperationResult.ok() and .fail() factory methods\n- REG-008: Registry status reports correct data",
        "functions": [
          {
            "name": "registry",
            "signature": "()",
            "docstring": "Fresh registry for each test.",
            "is_async": false,
            "line": 74
          },
          {
            "name": "mock_session",
            "signature": "()",
            "docstring": "Mock AsyncSession.",
            "is_async": false,
            "line": 80
          },
          {
            "name": "ctx",
            "signature": "(mock_session)",
            "docstring": "Basic operation context.",
            "is_async": false,
            "line": 86
          },
          {
            "name": "test_register_and_execute",
            "signature": "(registry, ctx)",
            "docstring": "REG-001: Registered handler is found and executed.",
            "is_async": true,
            "line": 118
          },
          {
            "name": "test_unknown_operation",
            "signature": "(registry, ctx)",
            "docstring": "REG-002: Unknown operation returns error, not exception.",
            "is_async": true,
            "line": 137
          },
          {
            "name": "test_duplicate_registration_raises",
            "signature": "(registry)",
            "docstring": "REG-003: Cannot register same operation name twice.",
            "is_async": false,
            "line": 151
          },
          {
            "name": "test_frozen_registry_rejects",
            "signature": "(registry)",
            "docstring": "REG-004: Frozen registry refuses new registrations.",
            "is_async": false,
            "line": 164
          },
          {
            "name": "test_freeze_sets_flag",
            "signature": "(registry)",
            "docstring": "REG-004: freeze() sets is_frozen flag.",
            "is_async": false,
            "line": 173
          },
          {
            "name": "test_handler_exception_wrapped",
            "signature": "(registry, ctx)",
            "docstring": "REG-005: Handler exceptions become OperationResult.fail().",
            "is_async": true,
            "line": 186
          },
          {
            "name": "test_operations_list",
            "signature": "(registry)",
            "docstring": "REG-006: operations returns sorted list.",
            "is_async": false,
            "line": 202
          },
          {
            "name": "test_operation_count",
            "signature": "(registry)",
            "docstring": "REG-006: operation_count is accurate.",
            "is_async": false,
            "line": 210
          },
          {
            "name": "test_has_operation",
            "signature": "(registry)",
            "docstring": "REG-006: has_operation checks correctly.",
            "is_async": false,
            "line": 217
          },
          {
            "name": "test_get_handler",
            "signature": "(registry)",
            "docstring": "REG-006: get_handler returns handler or None.",
            "is_async": false,
            "line": 225
          },
          {
            "name": "test_result_ok",
            "signature": "()",
            "docstring": "REG-007: OperationResult.ok() creates success result.",
            "is_async": false,
            "line": 239
          },
          {
            "name": "test_result_fail",
            "signature": "()",
            "docstring": "REG-007: OperationResult.fail() creates failure result.",
            "is_async": false,
            "line": 247
          },
          {
            "name": "test_status",
            "signature": "(registry)",
            "docstring": "REG-008: status() returns correct diagnostics.",
            "is_async": false,
            "line": 261
          },
          {
            "name": "test_singleton",
            "signature": "()",
            "docstring": "Singleton returns same instance.",
            "is_async": false,
            "line": 278
          },
          {
            "name": "test_reset_singleton",
            "signature": "()",
            "docstring": "Reset creates new instance.",
            "is_async": false,
            "line": 287
          },
          {
            "name": "test_invalid_handler_rejected",
            "signature": "(registry)",
            "docstring": "Handler without execute() method is rejected.",
            "is_async": false,
            "line": 302
          }
        ],
        "classes": [
          {
            "name": "StubHandler",
            "docstring": "Test handler that returns fixed data.",
            "methods": [
              "__init__",
              "execute"
            ],
            "line": 95
          },
          {
            "name": "FailingStubHandler",
            "docstring": "Test handler that raises an exception.",
            "methods": [
              "execute"
            ],
            "line": 105
          }
        ],
        "imports": [
          {
            "module": "unittest.mock",
            "names": [
              "MagicMock"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "pytest",
            "names": [
              "pytest"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "importlib.util",
            "names": [
              "importlib.util"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "sys",
            "names": [
              "sys"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "recovery_decisions.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/utilities/recovery_decisions.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 97,
        "module_docstring": "Recovery Decision Utilities (Spine Utility)\n\nPure decision functions for recovery confidence and threshold logic.\nMoved from hoc_spine/schemas/recovery_decisions.py (PIN-507 Law 6):\nschemas must be declarative only; executable logic is policy, not contract.\n\nThese are cross-domain pure decision functions shared between\nincidents and policies domains. They contain no DB access or side effects.",
        "functions": [
          {
            "name": "combine_confidences",
            "signature": "(rule_confidence: float, match_confidence: float) -> float",
            "docstring": "Combine rule and matcher confidence scores.\n\nThis is an L4 domain decision. L5 workers must NOT implement their own formulas.\n\nArgs:\n    rule_confidence: Confidence from rule evaluation (0.0 to 1.0)\n    match_confidence: Confidence from pattern matching (0.0 to 1.0)\n\nReturns:\n    Combined confidence score (0.0 to 1.0)\n\nReference: PIN-257 Phase E-4 Extraction #3",
            "is_async": false,
            "line": 41
          },
          {
            "name": "should_select_action",
            "signature": "(combined_confidence: float) -> bool",
            "docstring": "Determine if an action should be selected based on combined confidence.\n\nThis is an L4 domain decision. L5 workers must NOT hardcode thresholds.\n\nArgs:\n    combined_confidence: Combined confidence score (0.0 to 1.0)\n\nReturns:\n    True if confidence meets threshold for action selection\n\nReference: PIN-257 Phase E-4 Extraction #3",
            "is_async": false,
            "line": 59
          },
          {
            "name": "should_auto_execute",
            "signature": "(confidence: float) -> bool",
            "docstring": "Determine if a recovery action should be auto-executed based on confidence.\n\nThis is an L4 domain decision. L5 workers must NOT hardcode thresholds.\n\nArgs:\n    confidence: Combined confidence score (0.0 to 1.0)\n\nReturns:\n    True if confidence meets threshold for auto-execution",
            "is_async": false,
            "line": 76
          }
        ],
        "classes": [],
        "imports": [],
        "constants": [],
        "all_exports": [
          "AUTO_EXECUTE_CONFIDENCE_THRESHOLD",
          "ACTION_SELECTION_THRESHOLD",
          "combine_confidences",
          "should_select_action",
          "should_auto_execute"
        ]
      },
      {
        "file_name": "s1_retry_backoff.py",
        "file_path": "backend/app/hoc/cus/hoc_spine/utilities/s1_retry_backoff.py",
        "layer": "L4_spine",
        "domain": "hoc_spine",
        "lines": 150,
        "module_docstring": null,
        "functions": [
          {
            "name": "create_s1_envelope",
            "signature": "(baseline_value: float = 100.0, reference_id: str = 'retry_policy_v3') -> Envelope",
            "docstring": "Create a fresh S1 envelope instance with specified baseline.\n\nArgs:\n    baseline_value: The baseline initial_backoff_ms value\n    reference_id: Version/hash of the baseline config\n\nReturns:\n    New Envelope instance ready for validation",
            "is_async": false,
            "line": 101
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "app.optimization.envelope",
            "names": [
              "BaselineSource",
              "DeltaType",
              "Envelope",
              "EnvelopeBaseline",
              "EnvelopeBounds",
              "EnvelopeClass",
              "EnvelopeScope",
              "EnvelopeTimebox",
              "EnvelopeTrigger",
              "RevertReason"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [
          {
            "name": "S1_RETRY_BACKOFF_ENVELOPE",
            "line": 54
          }
        ],
        "all_exports": null
      }
    ],
    "l5_engines": [],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [],
    "l7_models": [],
    "total_files": 155,
    "violation_count": 0,
    "gap_count": 0
  },
  "overview": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/overview.py",
    "l2_apis": [
      {
        "file_name": "overview.py",
        "file_path": "backend/app/hoc/api/cus/overview/overview.py",
        "layer": "L2_api",
        "domain": "overview",
        "lines": 561,
        "module_docstring": "Unified Overview API (L2)\n\nCustomer-facing endpoints for system overview and health.\nAll requests are tenant-scoped via auth_context.\n\nEndpoints:\n- GET /overview/highlights      \u2192 O1 system pulse & domain counts (Activity, Incidents, Policies)\n- GET /overview/decisions       \u2192 O2 pending decisions queue\n- GET /overview/decisions/count \u2192 O2 decisions count summary\n- GET /overview/costs           \u2192 O2 cost intelligence summary\n- GET /overview/recovery-stats  \u2192 O3 recovery statistics\n\nThis is the ONLY facade for overview operations.\nAll overview APIs flow through this router.",
        "functions": [
          {
            "name": "require_preflight",
            "signature": "() -> None",
            "docstring": "Guard for preflight-only endpoints (O4, O5).",
            "is_async": false,
            "line": 64
          },
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 222
          },
          {
            "name": "get_highlights",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> HighlightsResponse",
            "docstring": "System pulse and domain counts. Tenant-scoped.",
            "is_async": true,
            "line": 260
          },
          {
            "name": "get_decisions",
            "signature": "(request: Request, source_domain: Annotated[str | None, Query(description='Filter by source: INCIDENT, POLICY', pattern='^(INCIDENT|POLICY)$')] = None, priority: Annotated[str | None, Query(description='Filter by priority: CRITICAL, HIGH, MEDIUM, LOW', pattern='^(CRITICAL|HIGH|MEDIUM|LOW)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max items')] = 50, offset: Annotated[int, Query(ge=0, description='Items to skip')] = 0, session = Depends(get_session_dep)) -> DecisionsResponse",
            "docstring": "Pending decisions from incidents and policy proposals. Tenant-scoped.",
            "is_async": true,
            "line": 324
          },
          {
            "name": "get_costs",
            "signature": "(request: Request, period_days: Annotated[int, Query(ge=1, le=365, description='Period in days')] = 30, session = Depends(get_session_dep)) -> CostsResponse",
            "docstring": "Cost intelligence summary. Tenant-scoped.",
            "is_async": true,
            "line": 410
          },
          {
            "name": "get_decisions_count",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> DecisionsCountResponse",
            "docstring": "Decisions count by domain and priority. Tenant-scoped.",
            "is_async": true,
            "line": 476
          },
          {
            "name": "get_recovery_stats",
            "signature": "(request: Request, period_days: Annotated[int, Query(ge=1, le=365, description='Period in days')] = 30, session = Depends(get_session_dep)) -> RecoveryStatsResponse",
            "docstring": "Recovery statistics from incidents. Tenant-scoped.",
            "is_async": true,
            "line": 525
          }
        ],
        "classes": [
          {
            "name": "DomainCount",
            "docstring": "Count for a specific domain.",
            "methods": [],
            "line": 81
          },
          {
            "name": "SystemPulse",
            "docstring": "System health pulse summary.",
            "methods": [],
            "line": 89
          },
          {
            "name": "HighlightsResponse",
            "docstring": "GET /highlights response (O1).",
            "methods": [],
            "line": 99
          },
          {
            "name": "DecisionItem",
            "docstring": "A pending decision requiring human action.",
            "methods": [],
            "line": 111
          },
          {
            "name": "Pagination",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 122
          },
          {
            "name": "DecisionsResponse",
            "docstring": "GET /decisions response (O2).",
            "methods": [],
            "line": 129
          },
          {
            "name": "CostPeriod",
            "docstring": "Time period for cost calculation.",
            "methods": [],
            "line": 143
          },
          {
            "name": "CostActuals",
            "docstring": "Actual costs incurred.",
            "methods": [],
            "line": 149
          },
          {
            "name": "LimitCostItem",
            "docstring": "Single limit with cost status.",
            "methods": [],
            "line": 154
          },
          {
            "name": "CostViolations",
            "docstring": "Cost violation summary.",
            "methods": [],
            "line": 165
          },
          {
            "name": "CostsResponse",
            "docstring": "GET /costs response (O2).",
            "methods": [],
            "line": 171
          },
          {
            "name": "DecisionsCountResponse",
            "docstring": "GET /decisions/count response.",
            "methods": [],
            "line": 185
          },
          {
            "name": "RecoveryStatsResponse",
            "docstring": "GET /recovery-stats response.",
            "methods": [],
            "line": 197
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [
          {
            "name": "_CURRENT_ENVIRONMENT",
            "line": 61
          }
        ],
        "all_exports": null
      }
    ],
    "l4_spine": [],
    "l5_engines": [
      {
        "file_name": "overview_facade.py",
        "file_path": "backend/app/hoc/cus/overview/L5_engines/overview_facade.py",
        "layer": "L5_engines",
        "domain": "overview",
        "lines": 619,
        "module_docstring": "Overview Engine (L5 Domain Logic)\n\nThis facade provides the external interface for overview operations.\nAll overview APIs MUST use this facade instead of directly importing\nmodels or executing queries in L2.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L6 layer violations (direct model imports)\n- Centralizes overview aggregation logic\n- Single point for tenant-scoped queries\n- Maintains projection-only architecture\n\nARCHITECTURAL RULE:\n- Overview DOES NOT own any tables\n- Overview aggregates/projects from existing domains\n- All operations are READ-ONLY\n- All DB access is delegated to overview_facade_driver.py (L6)\n\nL2 API Routes:\n- GET /api/v1/overview/highlights      \u2192 O1 system pulse & domain counts\n- GET /api/v1/overview/decisions       \u2192 O2 pending decisions queue\n- GET /api/v1/overview/decisions/count \u2192 O2 decisions count summary\n- GET /api/v1/overview/costs           \u2192 O2 cost intelligence summary\n- GET /api/v1/overview/recovery-stats  \u2192 O3 recovery statistics\n\nUsage:\n    from app.hoc.cus.overview.L5_engines.overview_facade import get_overview_facade\n\n    facade = get_overview_facade()\n\n    # Get system highlights\n    highlights = await facade.get_highlights(session, tenant_id)",
        "functions": [
          {
            "name": "get_overview_facade",
            "signature": "() -> OverviewFacade",
            "docstring": "Get the singleton OverviewFacade instance.",
            "is_async": false,
            "line": 596
          }
        ],
        "classes": [
          {
            "name": "SystemPulse",
            "docstring": "System health pulse summary.",
            "methods": [
              "to_dict"
            ],
            "line": 85
          },
          {
            "name": "DomainCount",
            "docstring": "Count for a specific domain.",
            "methods": [
              "to_dict"
            ],
            "line": 107
          },
          {
            "name": "HighlightsResult",
            "docstring": "Result from get_highlights.",
            "methods": [
              "to_dict"
            ],
            "line": 125
          },
          {
            "name": "DecisionItem",
            "docstring": "A pending decision requiring human action.",
            "methods": [
              "to_dict"
            ],
            "line": 141
          },
          {
            "name": "DecisionsResult",
            "docstring": "Result from get_decisions.",
            "methods": [
              "to_dict"
            ],
            "line": 165
          },
          {
            "name": "CostPeriod",
            "docstring": "Time period for cost calculation.",
            "methods": [
              "to_dict"
            ],
            "line": 183
          },
          {
            "name": "LimitCostItem",
            "docstring": "Single limit with cost status.",
            "methods": [
              "to_dict"
            ],
            "line": 197
          },
          {
            "name": "CostsResult",
            "docstring": "Result from get_costs.",
            "methods": [
              "to_dict"
            ],
            "line": 221
          },
          {
            "name": "DecisionsCountResult",
            "docstring": "Result from get_decisions_count.",
            "methods": [
              "to_dict"
            ],
            "line": 245
          },
          {
            "name": "RecoveryStatsResult",
            "docstring": "Result from get_recovery_stats.",
            "methods": [
              "to_dict"
            ],
            "line": 261
          },
          {
            "name": "OverviewFacade",
            "docstring": "Overview Facade - Centralized access to overview domain operations.\n\nThis facade aggregates data from multiple domains:\n- Activity (WorkerRun)\n- Incidents (Incident)\n- Policies (PolicyProposal, Limit, LimitBreach)\n- Logs (AuditLedger)\n\nAll DB access is delegated to OverviewFacadeDriver (L6).\nThis facade only contains business logic composition.",
            "methods": [
              "__init__",
              "get_highlights",
              "get_decisions",
              "get_costs",
              "get_decisions_count",
              "get_recovery_stats"
            ],
            "line": 287
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.hoc.cus.overview.L6_drivers.overview_facade_driver",
            "names": [
              "OverviewFacadeDriver"
            ],
            "is_relative": false,
            "line": 69
          }
        ],
        "constants": [],
        "all_exports": [
          "OverviewFacade",
          "get_overview_facade",
          "SystemPulse",
          "DomainCount",
          "HighlightsResult",
          "DecisionItem",
          "DecisionsResult",
          "CostPeriod",
          "LimitCostItem",
          "CostsResult",
          "DecisionsCountResult",
          "RecoveryStatsResult"
        ]
      }
    ],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "overview_facade_driver.py",
        "file_path": "backend/app/hoc/cus/overview/L6_drivers/overview_facade_driver.py",
        "layer": "L6_drivers",
        "domain": "overview",
        "lines": 517,
        "module_docstring": "Overview Facade Driver (L6 Data Access)\n\nThis driver contains all database queries for the overview domain.\nIt returns snapshot dataclasses to the facade (L4) for business logic composition.\n\nARCHITECTURAL RULE:\n- This driver ONLY performs data access\n- NO business logic (no severity thresholds, no status calculations)\n- Returns raw query results as typed snapshots\n- The facade composes business results from these snapshots",
        "functions": [],
        "classes": [
          {
            "name": "IncidentCountSnapshot",
            "docstring": "Raw incident count data from DB.",
            "methods": [],
            "line": 63
          },
          {
            "name": "ProposalCountSnapshot",
            "docstring": "Raw policy proposal count data from DB.",
            "methods": [],
            "line": 72
          },
          {
            "name": "BreachCountSnapshot",
            "docstring": "Raw limit breach count data from DB.",
            "methods": [],
            "line": 80
          },
          {
            "name": "RunCountSnapshot",
            "docstring": "Raw worker run count data from DB.",
            "methods": [],
            "line": 87
          },
          {
            "name": "AuditCountSnapshot",
            "docstring": "Raw audit count data from DB.",
            "methods": [],
            "line": 96
          },
          {
            "name": "IncidentSnapshot",
            "docstring": "Snapshot of a single incident for decisions projection.",
            "methods": [],
            "line": 103
          },
          {
            "name": "ProposalSnapshot",
            "docstring": "Snapshot of a single policy proposal for decisions projection.",
            "methods": [],
            "line": 114
          },
          {
            "name": "LimitSnapshot",
            "docstring": "Snapshot of a single limit for cost projection.",
            "methods": [],
            "line": 124
          },
          {
            "name": "RunCostSnapshot",
            "docstring": "Snapshot of run cost data from DB.",
            "methods": [],
            "line": 135
          },
          {
            "name": "BreachStatsSnapshot",
            "docstring": "Snapshot of breach statistics from DB.",
            "methods": [],
            "line": 142
          },
          {
            "name": "IncidentDecisionCountSnapshot",
            "docstring": "Snapshot of incident counts by severity for decisions count.",
            "methods": [],
            "line": 150
          },
          {
            "name": "RecoverySnapshot",
            "docstring": "Snapshot of incident recovery data from DB.",
            "methods": [],
            "line": 160
          },
          {
            "name": "OverviewFacadeDriver",
            "docstring": "Overview Facade Driver - Pure data access layer.\n\nAll methods execute DB queries and return snapshot dataclasses.\nNo business logic or status calculations.",
            "methods": [
              "fetch_incident_counts",
              "fetch_proposal_counts",
              "fetch_breach_counts",
              "fetch_run_counts",
              "fetch_last_activity",
              "fetch_pending_incidents",
              "fetch_pending_proposals",
              "fetch_run_cost",
              "fetch_budget_limits",
              "fetch_breach_stats",
              "fetch_incident_decision_counts",
              "fetch_proposal_count",
              "fetch_recovery_stats"
            ],
            "line": 174
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "case",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "AuditLedger"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentLifecycleState"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyProposal"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitBreach",
              "LimitCategory"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": [
          "OverviewFacadeDriver",
          "IncidentCountSnapshot",
          "ProposalCountSnapshot",
          "BreachCountSnapshot",
          "RunCountSnapshot",
          "AuditCountSnapshot",
          "IncidentSnapshot",
          "ProposalSnapshot",
          "LimitSnapshot",
          "RunCostSnapshot",
          "BreachStatsSnapshot",
          "IncidentDecisionCountSnapshot",
          "RecoverySnapshot"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 3,
    "violation_count": 0,
    "gap_count": 1
  },
  "activity": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/activity.py",
    "l2_apis": [
      {
        "file_name": "activity.py",
        "file_path": "backend/app/hoc/api/cus/activity/activity.py",
        "layer": "L2_api",
        "domain": "activity",
        "lines": 2293,
        "module_docstring": null,
        "functions": [
          {
            "name": "require_preflight",
            "signature": "() -> None",
            "docstring": "Guard for preflight-only endpoints (O4, O5).",
            "is_async": false,
            "line": 86
          },
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 746
          },
          {
            "name": "list_runs",
            "signature": "(request: Request, project_id: Annotated[str | None, Query(description='Project scope')] = None, state: Annotated[RunState | None, Query(description='Run lifecycle state')] = None, status: Annotated[list[str] | None, Query(description='Run status (multiple)')] = None, risk: Annotated[bool, Query(description='If true, returns runs with risk signals')] = False, risk_level: Annotated[list[RiskLevel] | None, Query(description='Filter by risk level')] = None, latency_bucket: Annotated[list[LatencyBucket] | None, Query(description='Filter by latency')] = None, evidence_health: Annotated[list[EvidenceHealth] | None, Query(description='Filter by evidence health')] = None, integrity_status: Annotated[list[IntegrityStatus] | None, Query(description='Filter by integrity')] = None, source: Annotated[list[RunSource] | None, Query(description='Filter by run source')] = None, provider_type: Annotated[list[ProviderType] | None, Query(description='Filter by LLM provider')] = None, is_synthetic: Annotated[bool | None, Query(description='Filter by synthetic data flag')] = None, started_after: Annotated[datetime | None, Query(description='Filter runs started after')] = None, started_before: Annotated[datetime | None, Query(description='Filter runs started before')] = None, completed_after: Annotated[datetime | None, Query(description='Filter runs completed after')] = None, completed_before: Annotated[datetime | None, Query(description='Filter runs completed before')] = None, limit: Annotated[int, Query(ge=1, le=200, description='Max runs to return')] = 50, offset: Annotated[int, Query(ge=0, description='Number of runs to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.STARTED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session = Depends(get_session_dep)) -> RunListResponse",
            "docstring": "List runs with unified query filters. READ-ONLY from v_runs_o2 view.",
            "is_async": true,
            "line": 797
          },
          {
            "name": "get_run_detail",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> RunDetailResponse",
            "docstring": "Get run detail (O3). Tenant isolation enforced.",
            "is_async": true,
            "line": 929
          },
          {
            "name": "get_run_evidence",
            "signature": "(request: Request, run_id: str) -> dict[str, Any]",
            "docstring": "Get run evidence (O4). Preflight console only.",
            "is_async": true,
            "line": 990
          },
          {
            "name": "get_run_proof",
            "signature": "(request: Request, run_id: str, include_payloads: bool = False) -> dict[str, Any]",
            "docstring": "Get run proof (O5). Preflight console only.",
            "is_async": true,
            "line": 1017
          },
          {
            "name": "get_summary_by_status",
            "signature": "(request: Request, state: Annotated[RunState | None, Query(description='Filter by run state')] = None, session = Depends(get_session_dep)) -> StatusSummaryResponse",
            "docstring": "Get run summary by status (COMP-O3). READ-ONLY from v_runs_o2.",
            "is_async": true,
            "line": 1054
          },
          {
            "name": "_get_runs_by_dimension_internal",
            "signature": "(session, tenant_id: str, dim: DimensionValue, state: RunState, limit: int = 20) -> DimensionBreakdownResponse",
            "docstring": "Internal helper for dimension breakdown with HARDCODED state binding.\n\nThis function is called by topic-scoped endpoints only.\nState is injected by the endpoint, never from caller.\n\nPolicy: TOPIC-SCOPED-ENDPOINT-001",
            "is_async": true,
            "line": 1102
          },
          {
            "name": "get_live_runs_by_dimension",
            "signature": "(request: Request, dim: Annotated[DimensionValue, Query(description='Dimension to group by')], limit: Annotated[int, Query(ge=1, le=100, description='Max groups to return')] = 20, session = Depends(get_session_dep)) -> DimensionBreakdownResponse",
            "docstring": "Get LIVE runs grouped by dimension. State=LIVE is hardcoded.",
            "is_async": true,
            "line": 1172
          },
          {
            "name": "get_completed_runs_by_dimension",
            "signature": "(request: Request, dim: Annotated[DimensionValue, Query(description='Dimension to group by')], limit: Annotated[int, Query(ge=1, le=100, description='Max groups to return')] = 20, session = Depends(get_session_dep)) -> DimensionBreakdownResponse",
            "docstring": "Get COMPLETED runs grouped by dimension. State=COMPLETED is hardcoded.",
            "is_async": true,
            "line": 1208
          },
          {
            "name": "get_runs_by_dimension",
            "signature": "(request: Request, dim: Annotated[DimensionValue, Query(description='Dimension to group by')], state: Annotated[RunState | None, Query(description='Filter by run state')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max groups to return')] = 20, session = Depends(get_session_dep)) -> DimensionBreakdownResponse",
            "docstring": "[INTERNAL] Get runs grouped by dimension with optional state. NOT FOR PANELS.",
            "is_async": true,
            "line": 1246
          },
          {
            "name": "get_patterns",
            "signature": "(request: Request, window_hours: Annotated[int, Query(ge=1, le=168, description='Hours to look back')] = 24, limit: Annotated[int, Query(ge=1, le=50, description='Max patterns per type')] = 10, session = Depends(get_session_dep)) -> PatternDetectionResponse",
            "docstring": "Detect instability patterns (SIG-O3). READ-ONLY from aos_traces/aos_trace_steps.",
            "is_async": true,
            "line": 1305
          },
          {
            "name": "get_cost_analysis",
            "signature": "(request: Request, baseline_days: Annotated[int, Query(ge=1, le=30, description='Days for baseline')] = 7, anomaly_threshold: Annotated[float, Query(ge=1.0, le=5.0, description='Threshold percentage')] = 50.0, session = Depends(get_session_dep)) -> CostAnalysisResponse",
            "docstring": "Analyze cost anomalies (SIG-O4). READ-ONLY from runs table.",
            "is_async": true,
            "line": 1371
          },
          {
            "name": "get_attention_queue",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100, description='Max items to return')] = 20, session = Depends(get_session_dep)) -> AttentionQueueResponse",
            "docstring": "Get attention queue (SIG-O5). READ-ONLY from v_runs_o2.",
            "is_async": true,
            "line": 1437
          },
          {
            "name": "get_risk_signals",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> RiskSignalsResponse",
            "docstring": "Returns aggregated risk signal counts.\n\nSupports: activity.risk_signals capability\nConsumers: Overview panels, Activity summary panels",
            "is_async": true,
            "line": 1515
          },
          {
            "name": "_extract_policy_context",
            "signature": "(row: dict) -> PolicyContext",
            "docstring": "Extract PolicyContext from a v_runs_o2 row (V2 schema).\n\nThe v_runs_o2 view includes policy context fields from migration 107.\nThis helper converts DB row to PolicyContext model.\n\nCross-Domain Navigation (PIN-447):\n- facade_ref: Always populated if policy_id exists\n- threshold_ref: Populated if limit_id exists\n- violation_ref: Populated if violation_id exists",
            "is_async": false,
            "line": 1555
          },
          {
            "name": "_policy_context_from_l5",
            "signature": "(pc: Any) -> PolicyContext",
            "docstring": "Convert L5 PolicyContextResult dataclass to L2 PolicyContext Pydantic model.",
            "is_async": false,
            "line": 1597
          },
          {
            "name": "_run_summary_v2_from_l5",
            "signature": "(item: Any) -> RunSummaryV2",
            "docstring": "Convert L5 RunSummaryV2Result dataclass to L2 RunSummaryV2 Pydantic model.",
            "is_async": false,
            "line": 1617
          },
          {
            "name": "_row_to_run_summary_v2",
            "signature": "(row: dict) -> RunSummaryV2",
            "docstring": "Convert a v_runs_o2 row to RunSummaryV2.\n\nIncludes policy_context extraction.",
            "is_async": false,
            "line": 1646
          },
          {
            "name": "list_live_runs",
            "signature": "(request: Request, project_id: Annotated[str | None, Query(description='Project scope')] = None, risk_level: Annotated[list[RiskLevel] | None, Query(description='Filter by risk level')] = None, evidence_health: Annotated[list[EvidenceHealth] | None, Query(description='Filter by evidence health')] = None, source: Annotated[list[RunSource] | None, Query(description='Filter by run source')] = None, provider_type: Annotated[list[ProviderType] | None, Query(description='Filter by LLM provider')] = None, limit: Annotated[int, Query(ge=1, le=200, description='Max runs to return')] = 50, offset: Annotated[int, Query(ge=0, description='Number of runs to skip')] = 0, session = Depends(get_session_dep)) -> LiveRunsResponse",
            "docstring": "List LIVE runs with policy context.\n\nState=LIVE is HARDCODED - cannot be overridden.\nThis is the canonical endpoint for the LIVE topic.",
            "is_async": true,
            "line": 1707
          },
          {
            "name": "list_completed_runs",
            "signature": "(request: Request, project_id: Annotated[str | None, Query(description='Project scope')] = None, status: Annotated[list[str] | None, Query(description='Run status (multiple)')] = None, risk_level: Annotated[list[RiskLevel] | None, Query(description='Filter by risk level')] = None, completed_after: Annotated[datetime | None, Query(description='Filter runs completed after')] = None, completed_before: Annotated[datetime | None, Query(description='Filter runs completed before')] = None, limit: Annotated[int, Query(ge=1, le=200, description='Max runs to return')] = 50, offset: Annotated[int, Query(ge=0, description='Number of runs to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.COMPLETED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session = Depends(get_session_dep)) -> CompletedRunsResponse",
            "docstring": "List COMPLETED runs with policy context.\n\nState=COMPLETED is HARDCODED - cannot be overridden.\nThis is the canonical endpoint for the COMPLETED topic.",
            "is_async": true,
            "line": 1790
          },
          {
            "name": "list_signals",
            "signature": "(request: Request, project_id: Annotated[str | None, Query(description='Project scope')] = None, signal_type: Annotated[str | None, Query(description='Filter by signal type')] = None, severity: Annotated[str | None, Query(description='Filter by severity (HIGH, MEDIUM, LOW)')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max signals to return')] = 20, session = Depends(get_session_dep)) -> SignalsResponse",
            "docstring": "List activity signals (V2 projection).\n\nSynthesizes signals from runs with attention-worthy conditions.\nSIGNALS is NOT a run state - it's a computed projection.",
            "is_async": true,
            "line": 1879
          },
          {
            "name": "get_activity_metrics",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> MetricsResponse",
            "docstring": "Get aggregated activity metrics (V2).\n\nProvides counts for:\n- Risk levels\n- Topic (LIVE vs COMPLETED)\n- Evidence health\n- Risk types",
            "is_async": true,
            "line": 1966
          },
          {
            "name": "get_threshold_signals",
            "signature": "(request: Request, risk_type: Annotated[RiskType | None, Query(description='Filter by risk type')] = None, evaluation_outcome: Annotated[EvaluationOutcome | None, Query(description='Filter by evaluation outcome')] = None, state: Annotated[RunState | None, Query(description='Filter by run state')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max signals to return')] = 20, session = Depends(get_session_dep)) -> ThresholdSignalsResponse",
            "docstring": "Get threshold proximity signals (V2).\n\nReturns runs with threshold evaluation data.\nCan be filtered by risk_type (COST, TIME, TOKENS, RATE).",
            "is_async": true,
            "line": 2030
          },
          {
            "name": "acknowledge_signal",
            "signature": "(request: Request, signal_fingerprint: Annotated[str, Path(description='Canonical signal fingerprint (sig-{hash})')], body: SignalAckRequest, session = Depends(get_session_dep)) -> SignalAckResponse",
            "docstring": "Acknowledge a signal.\n\nRecords acknowledgment in the audit_ledger.\nThe signal remains visible but receives a ranking dampener (0.6x).",
            "is_async": true,
            "line": 2118
          },
          {
            "name": "suppress_signal",
            "signature": "(request: Request, signal_fingerprint: Annotated[str, Path(description='Canonical signal fingerprint (sig-{hash})')], body: SignalSuppressRequest, session = Depends(get_session_dep)) -> SignalSuppressResponse",
            "docstring": "Suppress a signal temporarily.\n\nRecords suppression in the audit_ledger with a suppress_until timestamp.\nThe signal is excluded from the attention queue until expiry.",
            "is_async": true,
            "line": 2201
          },
          {
            "name": "get_actor_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract actor ID from request auth context.\n\nFalls back to 'unknown' if not available (should not happen in production).",
            "is_async": false,
            "line": 2284
          }
        ],
        "classes": [
          {
            "name": "RunState",
            "docstring": "Run lifecycle state.",
            "methods": [],
            "line": 103
          },
          {
            "name": "RunStatus",
            "docstring": "Run execution status.",
            "methods": [],
            "line": 110
          },
          {
            "name": "RiskLevel",
            "docstring": "Risk classification.",
            "methods": [],
            "line": 121
          },
          {
            "name": "LatencyBucket",
            "docstring": "Latency classification.",
            "methods": [],
            "line": 130
          },
          {
            "name": "EvidenceHealth",
            "docstring": "Evidence capture health.",
            "methods": [],
            "line": 138
          },
          {
            "name": "IntegrityStatus",
            "docstring": "Integrity verification status.",
            "methods": [],
            "line": 146
          },
          {
            "name": "RunSource",
            "docstring": "Run initiator type.",
            "methods": [],
            "line": 155
          },
          {
            "name": "ProviderType",
            "docstring": "LLM provider.",
            "methods": [],
            "line": 163
          },
          {
            "name": "SortField",
            "docstring": "Allowed sort fields.",
            "methods": [],
            "line": 171
          },
          {
            "name": "SortOrder",
            "docstring": "Sort direction.",
            "methods": [],
            "line": 180
          },
          {
            "name": "EvaluationOutcome",
            "docstring": "Policy evaluation outcome.",
            "methods": [],
            "line": 187
          },
          {
            "name": "PolicyScope",
            "docstring": "Policy/limit scope.",
            "methods": [],
            "line": 197
          },
          {
            "name": "RiskType",
            "docstring": "Risk type classification for panels.",
            "methods": [],
            "line": 207
          },
          {
            "name": "PolicyContext",
            "docstring": "Policy context for a run (V2).\n\nAdvisory metadata showing why a run is at-risk.\nDerived at query time from limits table via v_runs_o2 view.\n\nCross-Domain Navigation (PIN-447):\n- facade_ref: Links to /policy/active/{policy_id}\n- threshold_ref: Links to /policy/thresholds/{id} (if limit-based)\n- violation_ref: Links to /policy/violations/{id} (if violation exists)\n\nReference: ACTIVITY_DOMAIN_V2_MIGRATION_PLAN.md, CROSS_DOMAIN_POLICY_CONTRACT.md",
            "methods": [],
            "line": 227
          },
          {
            "name": "RunSummaryV2",
            "docstring": "Run summary with policy context (V2).\n\nExtends RunSummary with mandatory policy_context field.\nUsed by topic-scoped endpoints: /live, /completed.\n\nReference: ACTIVITY_DOMAIN_CONTRACT.md (V2 sections)",
            "methods": [],
            "line": 260
          },
          {
            "name": "Pagination",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 309
          },
          {
            "name": "LiveRunsResponse",
            "docstring": "GET /activity/live response (V2).\n\nTopic-scoped endpoint - hardcoded state=LIVE.\nEvery run includes policy_context.\n\nPanels: LIVE-O1, LIVE-O3, LIVE-O5",
            "methods": [],
            "line": 317
          },
          {
            "name": "CompletedRunsResponse",
            "docstring": "GET /activity/completed response (V2).\n\nTopic-scoped endpoint - hardcoded state=COMPLETED.\nEvery run includes policy_context.\n\nPanels: COMP-O2, COMP-O5",
            "methods": [],
            "line": 334
          },
          {
            "name": "SignalFeedbackModel",
            "docstring": "Feedback state for a signal.\n\nINVARIANTS:\n- ATTN-DAMP-001: Acknowledgement dampening is idempotent (apply once, 0.6x)\n- SIGNAL-SUPPRESS-001: Suppression is temporary (15-1440 minutes)\n- SIGNAL-ACK-001: Acknowledgement records responsibility, doesn't hide signals",
            "methods": [],
            "line": 351
          },
          {
            "name": "SignalProjection",
            "docstring": "A signal projection (V2).\n\nSIGNALS is NOT a run state - it's a computed projection over LIVE + COMPLETED.\nEach signal includes policy_context for the underlying run.\n\nReference: ACTIVITY_DOMAIN_V2_MIGRATION_PLAN.md",
            "methods": [],
            "line": 367
          },
          {
            "name": "SignalsResponse",
            "docstring": "GET /activity/signals response (V2).\n\nProjection endpoint - synthesizes signals from LIVE + COMPLETED runs.\nReturns SignalProjection[], NOT runs.\n\nPanels: SIG-O1",
            "methods": [],
            "line": 388
          },
          {
            "name": "MetricsResponse",
            "docstring": "GET /activity/metrics response (V2).\n\nExtends /risk-signals with topic-aware counts.\n\nPanels: LIVE-O1, LIVE-O2, LIVE-O4, COMP-O1, COMP-O3",
            "methods": [],
            "line": 403
          },
          {
            "name": "ThresholdSignal",
            "docstring": "A threshold proximity signal (V2).\n\nUsed for runs approaching or exceeding limits.",
            "methods": [],
            "line": 436
          },
          {
            "name": "ThresholdSignalsResponse",
            "docstring": "GET /activity/threshold-signals response (V2).\n\nReturns runs with typed threshold proximity.\n\nPanels: LIVE-O2, COMP-O4, SIG-O2",
            "methods": [],
            "line": 450
          },
          {
            "name": "SignalAckRequest",
            "docstring": "POST /activity/signals/{signal_fingerprint}/ack request.\n\nINVARIANT (SIGNAL-ID-001): The signal_fingerprint in the path MUST match\nthe server-computed fingerprint. Clients provide identifying info for\nserver-side validation.",
            "methods": [],
            "line": 470
          },
          {
            "name": "SignalAckResponse",
            "docstring": "POST /activity/signals/{signal_fingerprint}/ack response.",
            "methods": [],
            "line": 485
          },
          {
            "name": "SignalSuppressRequest",
            "docstring": "POST /activity/signals/{signal_fingerprint}/suppress request.\n\nINVARIANT (SIGNAL-SUPPRESS-001): duration_minutes must be 15-1440 (max 24 hours).",
            "methods": [],
            "line": 496
          },
          {
            "name": "SignalSuppressResponse",
            "docstring": "POST /activity/signals/{signal_fingerprint}/suppress response.",
            "methods": [],
            "line": 510
          },
          {
            "name": "RunSummary",
            "docstring": "Run summary for list view (O2).",
            "methods": [],
            "line": 519
          },
          {
            "name": "RunListResponse",
            "docstring": "GET /runs response.",
            "methods": [],
            "line": 558
          },
          {
            "name": "RunDetailResponse",
            "docstring": "GET /runs/{run_id} response (O3).",
            "methods": [],
            "line": 568
          },
          {
            "name": "StatusBucket",
            "docstring": "A bucket in status summary.",
            "methods": [],
            "line": 606
          },
          {
            "name": "StatusSummaryResponse",
            "docstring": "GET /summary/by-status response (COMP-O3).",
            "methods": [],
            "line": 614
          },
          {
            "name": "DimensionValue",
            "docstring": "Allowed dimension values for grouping.",
            "methods": [],
            "line": 627
          },
          {
            "name": "DimensionGroup",
            "docstring": "A group in dimension breakdown.",
            "methods": [],
            "line": 637
          },
          {
            "name": "DimensionBreakdownResponse",
            "docstring": "GET /runs/by-dimension response (LIVE-O5).",
            "methods": [],
            "line": 645
          },
          {
            "name": "PatternMatchResponse",
            "docstring": "A detected pattern.",
            "methods": [],
            "line": 660
          },
          {
            "name": "PatternDetectionResponse",
            "docstring": "GET /patterns response (SIG-O3).",
            "methods": [],
            "line": 669
          },
          {
            "name": "AgentCostResponse",
            "docstring": "Cost analysis for a single agent.",
            "methods": [],
            "line": 683
          },
          {
            "name": "CostAnalysisResponse",
            "docstring": "GET /cost-analysis response (SIG-O4).",
            "methods": [],
            "line": 695
          },
          {
            "name": "AttentionItemResponse",
            "docstring": "An item in the attention queue.",
            "methods": [],
            "line": 710
          },
          {
            "name": "AttentionQueueResponse",
            "docstring": "GET /attention-queue response (SIG-O5).",
            "methods": [],
            "line": 721
          },
          {
            "name": "RiskSignalsResponse",
            "docstring": "GET /risk-signals response.",
            "methods": [],
            "line": 1487
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 17
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Path",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 74
          }
        ],
        "constants": [
          {
            "name": "_CURRENT_ENVIRONMENT",
            "line": 83
          }
        ],
        "all_exports": null
      }
    ],
    "l4_spine": [],
    "l5_engines": [
      {
        "file_name": "activity_enums.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/activity_enums.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 120,
        "module_docstring": "Activity Domain Enums\n\nCanonical enum definitions for the activity domain.\nThese are the single source of truth for categorical fields.\n\nRules (per ACT-DUP-006, ACTIVITY_DTO_RULES.md):\n- No free-text categorical fields in Activity\n- Signals are governance inputs - they must be enumerable\n- Engines own canonical enums, facades import them",
        "functions": [],
        "classes": [
          {
            "name": "SignalType",
            "docstring": "Canonical signal types for activity domain.\n\nSignals are governance inputs and must be enumerable.\nNo free-text signal types allowed.",
            "methods": [],
            "line": 34
          },
          {
            "name": "SeverityLevel",
            "docstring": "Canonical severity levels for display/UI.\n\nRule (per ACT-DUP-005):\n- Engines speak numbers (severity_score: float 0.0-1.0)\n- Facades render labels (severity_level: SeverityLevel)\n\nConversion:\n- HIGH: score >= 0.7\n- MEDIUM: score >= 0.4\n- LOW: score < 0.4",
            "methods": [
              "from_score",
              "from_risk_level"
            ],
            "line": 53
          },
          {
            "name": "RunState",
            "docstring": "Run lifecycle state.",
            "methods": [],
            "line": 90
          },
          {
            "name": "RiskType",
            "docstring": "Types of risk for threshold signals.",
            "methods": [],
            "line": 97
          },
          {
            "name": "EvidenceHealth",
            "docstring": "Evidence health status.",
            "methods": [],
            "line": 106
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "SignalType",
          "SeverityLevel",
          "RunState",
          "RiskType",
          "EvidenceHealth"
        ]
      },
      {
        "file_name": "activity_facade.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/activity_facade.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 1731,
        "module_docstring": "Activity Facade (L5)\n\nProvides unified access to activity domain operations.\nThis is the single entry point for all activity business logic.\n\nOperations:\n- get_runs: List runs with filters\n- get_run_detail: Get run details (O3)\n- get_run_evidence: Get run evidence context (O4)\n- get_run_proof: Get run integrity proof (O5)\n- get_status_summary: Get runs grouped by status\n- get_patterns: Pattern detection (SIG-O3)\n- get_cost_analysis: Cost anomalies (SIG-O4)\n- get_attention_queue: Attention ranking (SIG-O5)\n- get_live_runs: V2 live runs with policy context\n- get_completed_runs: V2 completed runs with policy context\n- get_signals: V2 synthesized signals\n- get_metrics: V2 activity metrics\n- get_threshold_signals: V2 threshold proximity signals\n- get_risk_signals: Risk signal aggregates\n- acknowledge_signal: Acknowledge a signal\n- suppress_signal: Suppress a signal\n\nReference: ACTIVITY_DOMAIN_V2_MIGRATION_PLAN.md",
        "functions": [
          {
            "name": "get_activity_facade",
            "signature": "(run_evidence_coordinator: RunEvidenceCoordinatorPort | None = None, run_proof_coordinator: RunProofCoordinatorPort | None = None, signal_feedback_coordinator: SignalFeedbackCoordinatorPort | None = None) -> ActivityFacade",
            "docstring": "Get the singleton ActivityFacade instance.\n\nPIN-520: L4 callers must inject coordinators. L5 must not import from hoc_spine.\n\nArgs:\n    run_evidence_coordinator: Coordinator for cross-domain evidence queries (injected by L4 caller).\n    run_proof_coordinator: Coordinator for integrity proof queries (injected by L4 caller).\n    signal_feedback_coordinator: Coordinator for signal feedback queries (injected by L4 caller).\n\nReturns:\n    ActivityFacade instance",
            "is_async": false,
            "line": 1699
          }
        ],
        "classes": [
          {
            "name": "RunEvidenceCoordinatorPort",
            "docstring": "Protocol for run evidence coordinator (PIN-520 L5 purity).",
            "methods": [
              "get_run_evidence"
            ],
            "line": 109
          },
          {
            "name": "RunProofCoordinatorPort",
            "docstring": "Protocol for run proof coordinator (PIN-520 L5 purity).",
            "methods": [
              "get_run_proof"
            ],
            "line": 119
          },
          {
            "name": "SignalFeedbackCoordinatorPort",
            "docstring": "Protocol for signal feedback coordinator (PIN-520 L5 purity).",
            "methods": [
              "get_signal_feedback"
            ],
            "line": 129
          },
          {
            "name": "PolicyContextResult",
            "docstring": "Policy context for a run.",
            "methods": [],
            "line": 145
          },
          {
            "name": "RunSummaryResult",
            "docstring": "Run summary for list view.",
            "methods": [],
            "line": 165
          },
          {
            "name": "RunSummaryV2Result",
            "docstring": "Run summary with policy context (V2).",
            "methods": [],
            "line": 193
          },
          {
            "name": "RunListResult",
            "docstring": "Result of listing runs.",
            "methods": [],
            "line": 200
          },
          {
            "name": "RunsResult",
            "docstring": "Unified result for getting runs (V2).\n\nConsolidates LiveRunsResult and CompletedRunsResult per ACT-DUP-003.\nThese were 100% structurally identical - only the name differed.\n\nRule: If structures are identical today, they will diverge accidentally tomorrow.",
            "methods": [],
            "line": 210
          },
          {
            "name": "RunDetailResult",
            "docstring": "Run detail (O3) - extends summary with additional fields.\n\nRefactored per ACT-DUP-002: Detail DTOs must extend summary DTOs,\nnever re-declare shared fields. This prevents field drift and\nguarantees backward compatibility.",
            "methods": [],
            "line": 233
          },
          {
            "name": "RunEvidenceResult",
            "docstring": "Run evidence context (O4).",
            "methods": [],
            "line": 247
          },
          {
            "name": "RunProofResult",
            "docstring": "Run integrity proof (O5).",
            "methods": [],
            "line": 258
          },
          {
            "name": "StatusCount",
            "docstring": "Status count item.",
            "methods": [],
            "line": 269
          },
          {
            "name": "StatusSummaryResult",
            "docstring": "Summary by status.",
            "methods": [],
            "line": 277
          },
          {
            "name": "SignalProjectionResult",
            "docstring": "A signal projection.",
            "methods": [],
            "line": 290
          },
          {
            "name": "SignalsResult",
            "docstring": "Result of getting signals (V2).",
            "methods": [],
            "line": 305
          },
          {
            "name": "MetricsResult",
            "docstring": "Activity metrics (V2).",
            "methods": [],
            "line": 314
          },
          {
            "name": "ThresholdSignalResult",
            "docstring": "A threshold proximity signal.",
            "methods": [],
            "line": 334
          },
          {
            "name": "ThresholdSignalsResult",
            "docstring": "Result of getting threshold signals (V2).",
            "methods": [],
            "line": 345
          },
          {
            "name": "RiskSignalsResult",
            "docstring": "Risk signal aggregates.\n\nNOTE (ACT-DUP-004): This is a DERIVED PROJECTION of MetricsResult.\nThe get_risk_signals() method extracts a subset from get_metrics().\nIf you need full metrics, use MetricsResult directly.\n\nRule: Derived views must be explicitly labeled as such.",
            "methods": [],
            "line": 355
          },
          {
            "name": "DimensionGroupResult",
            "docstring": "A dimension group with count and percentage.",
            "methods": [],
            "line": 374
          },
          {
            "name": "DimensionBreakdownResult",
            "docstring": "Dimension breakdown result.",
            "methods": [],
            "line": 383
          },
          {
            "name": "ActivityFacade",
            "docstring": "Unified facade for Activity domain operations.\n\nThis class provides a single entry point for all activity business logic,\ndelegating to specialized services where appropriate.\n\nNote: Services are instantiated per-request with the session, as they\nrequire the session in their constructors.\n\nPIN-520: Coordinators are now injected via L4 bridge instead of being\nimported directly from L4 orchestrator.",
            "methods": [
              "__init__",
              "_get_driver",
              "_get_pattern_service",
              "_get_cost_service",
              "_get_attention_service",
              "_get_feedback_service",
              "get_runs",
              "get_run_detail",
              "get_run_evidence",
              "get_run_proof",
              "get_status_summary",
              "get_live_runs",
              "get_completed_runs",
              "_get_runs_with_policy_context",
              "get_signals",
              "_get_signal_feedback",
              "_compute_signal_type",
              "_compute_severity",
              "_compute_signal_summary",
              "get_metrics",
              "get_threshold_signals",
              "get_risk_signals",
              "get_dimension_breakdown",
              "get_patterns",
              "get_cost_analysis",
              "get_attention_queue",
              "acknowledge_signal",
              "suppress_signal"
            ],
            "line": 412
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 73
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Protocol"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "app.hoc.cus.activity.L6_drivers.activity_read_driver",
            "names": [
              "get_activity_read_driver"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.attention_ranking",
            "names": [
              "AttentionRankingService"
            ],
            "is_relative": false,
            "line": 83
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.cost_analysis",
            "names": [
              "CostAnalysisService"
            ],
            "is_relative": false,
            "line": 84
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.pattern_detection",
            "names": [
              "PatternDetectionService"
            ],
            "is_relative": false,
            "line": 85
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.signal_feedback_engine",
            "names": [
              "SignalFeedbackService",
              "AcknowledgeResult",
              "SuppressResult",
              "SignalFeedbackStatus"
            ],
            "is_relative": false,
            "line": 86
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.signal_identity",
            "names": [
              "compute_signal_fingerprint_from_row"
            ],
            "is_relative": false,
            "line": 92
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.activity_enums",
            "names": [
              "SignalType",
              "SeverityLevel",
              "RunState"
            ],
            "is_relative": false,
            "line": 95
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.pattern_detection",
            "names": [
              "PatternDetectionResult",
              "DetectedPattern"
            ],
            "is_relative": false,
            "line": 393
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.cost_analysis",
            "names": [
              "CostAnalysisResult",
              "CostAnomaly"
            ],
            "is_relative": false,
            "line": 397
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.attention_ranking",
            "names": [
              "AttentionQueueResult",
              "AttentionSignal"
            ],
            "is_relative": false,
            "line": 401
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "attention_ranking.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/attention_ranking.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 110,
        "module_docstring": "Attention ranking engine for prioritizing signals.",
        "functions": [],
        "classes": [
          {
            "name": "AttentionSignal",
            "docstring": "A signal in the attention queue.",
            "methods": [],
            "line": 32
          },
          {
            "name": "AttentionQueueResult",
            "docstring": "Result of attention queue query.",
            "methods": [],
            "line": 50
          },
          {
            "name": "AttentionRankingService",
            "docstring": "Service for ranking and prioritizing activity signals.\n\nComputes attention scores based on:\n- Signal severity\n- Recency\n- Pattern frequency\n- User acknowledgment status",
            "methods": [
              "__init__",
              "get_attention_queue",
              "compute_attention_score"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 28
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cost_analysis.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/cost_analysis.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 95,
        "module_docstring": "Cost analysis engine for detecting cost anomalies.",
        "functions": [],
        "classes": [
          {
            "name": "CostAnomaly",
            "docstring": "A detected cost anomaly.",
            "methods": [],
            "line": 32
          },
          {
            "name": "CostAnalysisResult",
            "docstring": "Result of cost analysis.",
            "methods": [],
            "line": 49
          },
          {
            "name": "CostAnalysisService",
            "docstring": "Service for analyzing cost patterns and detecting anomalies.\n\nDetects:\n- Cost spikes (sudden increases)\n- Cost trends (gradual increases)\n- Threshold breaches (exceeding limits)",
            "methods": [
              "__init__",
              "analyze_costs",
              "get_cost_breakdown"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 28
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_telemetry_engine.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/cus_telemetry_engine.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 384,
        "module_docstring": "Customer Telemetry Engine\n\nL4 engine for customer telemetry decisions.\n\nDecides: Idempotency checks, integration validation\nDelegates: All persistence to CusTelemetryDriver",
        "functions": [
          {
            "name": "get_cus_telemetry_engine",
            "signature": "() -> CusTelemetryEngine",
            "docstring": "Get engine instance with default driver.\n\nReturns:\n    CusTelemetryEngine instance",
            "is_async": false,
            "line": 376
          }
        ],
        "classes": [
          {
            "name": "IngestResult",
            "docstring": "Result of single usage ingestion.",
            "methods": [],
            "line": 32
          },
          {
            "name": "BatchIngestResult",
            "docstring": "Result of batch usage ingestion.",
            "methods": [],
            "line": 41
          },
          {
            "name": "CusTelemetryEngine",
            "docstring": "L4 engine for customer telemetry decisions.\n\nDecides: Idempotency, integration validation\nDelegates: All persistence to CusTelemetryDriver",
            "methods": [
              "__init__",
              "ingest_usage",
              "ingest_batch",
              "get_usage_summary",
              "get_usage_history",
              "get_daily_aggregates",
              "compute_daily_aggregates"
            ],
            "line": 50
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 12
          },
          {
            "module": "datetime",
            "names": [
              "date"
            ],
            "is_relative": false,
            "line": 13
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 14
          },
          {
            "module": "app.schemas.cus_schemas",
            "names": [
              "CusIntegrationUsage",
              "CusLLMUsageIngest",
              "CusLLMUsageResponse",
              "CusUsageSummary"
            ],
            "is_relative": false,
            "line": 16
          },
          {
            "module": "app.hoc.cus.activity.L6_drivers.cus_telemetry_driver",
            "names": [
              "CusTelemetryDriver",
              "get_cus_telemetry_driver"
            ],
            "is_relative": false,
            "line": 22
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "pattern_detection.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/pattern_detection.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 94,
        "module_docstring": "Pattern detection engine for identifying recurring patterns.",
        "functions": [],
        "classes": [
          {
            "name": "DetectedPattern",
            "docstring": "A detected activity pattern.",
            "methods": [],
            "line": 32
          },
          {
            "name": "PatternDetectionResult",
            "docstring": "Result of pattern detection.",
            "methods": [],
            "line": 49
          },
          {
            "name": "PatternDetectionService",
            "docstring": "Service for detecting patterns in activity data.\n\nDetects:\n- Failure clusters (similar failures occurring together)\n- Latency spikes (performance degradation patterns)\n- Error recurrence (repeated error types)",
            "methods": [
              "__init__",
              "detect_patterns",
              "get_pattern_detail"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 28
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "signal_feedback_engine.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/signal_feedback_engine.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 140,
        "module_docstring": "Signal feedback engine for user interactions with signals.",
        "functions": [],
        "classes": [
          {
            "name": "AcknowledgeResult",
            "docstring": "Result of acknowledging a signal.",
            "methods": [],
            "line": 30
          },
          {
            "name": "SuppressResult",
            "docstring": "Result of suppressing a signal.",
            "methods": [],
            "line": 41
          },
          {
            "name": "SignalFeedbackStatus",
            "docstring": "Current feedback status for a signal.",
            "methods": [],
            "line": 54
          },
          {
            "name": "SignalFeedbackService",
            "docstring": "Service for managing user feedback on signals.\n\nProvides:\n- Acknowledge: Mark signal as seen/reviewed\n- Suppress: Temporarily hide signal from attention queue",
            "methods": [
              "__init__",
              "acknowledge_signal",
              "suppress_signal",
              "get_signal_feedback_status",
              "get_bulk_signal_feedback"
            ],
            "line": 64
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "signal_identity.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/signal_identity.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 79,
        "module_docstring": "Signal identity utilities for fingerprinting and deduplication.",
        "functions": [
          {
            "name": "compute_signal_fingerprint_from_row",
            "signature": "(row: dict[str, Any]) -> str",
            "docstring": "Compute a stable fingerprint for a signal row.\n\nUsed for:\n- Signal deduplication\n- Change detection\n- Idempotent signal creation\n\nArgs:\n    row: A dictionary containing signal data\n\nReturns:\n    A hex digest fingerprint string",
            "is_async": false,
            "line": 26
          },
          {
            "name": "compute_signal_fingerprint",
            "signature": "(signal_type: str, dimension: str, source: str, tenant_id: str) -> str",
            "docstring": "Compute a stable fingerprint for signal identity fields.\n\nArgs:\n    signal_type: Type of signal (e.g., \"pattern\", \"anomaly\")\n    dimension: Dimension being measured\n    source: Source of the signal\n    tenant_id: Tenant identifier\n\nReturns:\n    A hex digest fingerprint string",
            "is_async": false,
            "line": 56
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 23
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "activity_read_driver.py",
        "file_path": "backend/app/hoc/cus/activity/L6_drivers/activity_read_driver.py",
        "layer": "L6_drivers",
        "domain": "activity",
        "lines": 385,
        "module_docstring": "Activity Read Driver (L6 Data Access)\n\nHandles database operations for activity queries:\n- Fetching runs with filters\n- Fetching run details\n- Fetching metrics aggregates\n- Fetching threshold signals\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_activity_read_driver",
            "signature": "(session: AsyncSession) -> ActivityReadDriver",
            "docstring": "Get an ActivityReadDriver instance.",
            "is_async": false,
            "line": 383
          }
        ],
        "classes": [
          {
            "name": "ActivityReadDriver",
            "docstring": "L6 Driver for activity read operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (risk computation, signal synthesis) stay in L5.",
            "methods": [
              "__init__",
              "count_runs",
              "fetch_runs",
              "fetch_run_detail",
              "fetch_status_summary",
              "fetch_runs_with_policy_context",
              "fetch_at_risk_runs",
              "fetch_metrics",
              "fetch_threshold_signals",
              "fetch_dimension_breakdown"
            ],
            "line": 48
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_telemetry_driver.py",
        "file_path": "backend/app/hoc/cus/activity/L6_drivers/cus_telemetry_driver.py",
        "layer": "L6_drivers",
        "domain": "activity",
        "lines": 620,
        "module_docstring": "Customer Telemetry Driver\n\nL6 driver for customer telemetry data access.\n\nPure persistence - no business logic.\nHandles: ingestion, queries, aggregation.\n\nL6 Contract:\n    - Session REQUIRED (passed from L4 handler)\n    - L6 does NOT commit (L4 owns transaction boundary)",
        "functions": [
          {
            "name": "utc_now",
            "signature": "() -> datetime",
            "docstring": "Return current UTC time with timezone info.",
            "is_async": false,
            "line": 35
          },
          {
            "name": "get_cus_telemetry_driver",
            "signature": "(session: AsyncSession) -> CusTelemetryDriver",
            "docstring": "Get driver instance.\n\nArgs:\n    session: AsyncSession from L4 handler (required)\n\nReturns:\n    CusTelemetryDriver instance\n\nNote:\n    Session is REQUIRED. L4 handler owns transaction boundary.",
            "is_async": false,
            "line": 608
          }
        ],
        "classes": [
          {
            "name": "UsageRow",
            "docstring": "Immutable usage record DTO.",
            "methods": [],
            "line": 41
          },
          {
            "name": "UsageSummaryRow",
            "docstring": "Immutable usage summary DTO.",
            "methods": [],
            "line": 62
          },
          {
            "name": "IntegrationUsageRow",
            "docstring": "Immutable per-integration usage DTO.",
            "methods": [],
            "line": 75
          },
          {
            "name": "DailyAggregateRow",
            "docstring": "Immutable daily aggregate DTO.",
            "methods": [],
            "line": 88
          },
          {
            "name": "CusTelemetryDriver",
            "docstring": "L6 driver for customer telemetry data access.\n\nPure persistence - no business logic.\nL6 does NOT commit \u2014 L4 handler owns transaction boundary.",
            "methods": [
              "__init__",
              "fetch_by_call_id",
              "fetch_call_ids_batch",
              "fetch_integration",
              "fetch_usage_summary",
              "fetch_per_integration_usage",
              "fetch_usage_history",
              "fetch_daily_aggregates",
              "create_usage",
              "create_usage_batch",
              "upsert_daily_aggregate",
              "compute_daily_aggregates_raw"
            ],
            "line": 102
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select",
              "and_"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "sqlalchemy.dialects.postgresql",
            "names": [
              "insert"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.models.cus_models",
            "names": [
              "CusIntegration",
              "CusLLMUsage",
              "CusPolicyResult",
              "CusUsageDaily"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "orphan_recovery_driver.py",
        "file_path": "backend/app/hoc/cus/activity/L6_drivers/orphan_recovery_driver.py",
        "layer": "L6_drivers",
        "domain": "activity",
        "lines": 139,
        "module_docstring": null,
        "functions": [
          {
            "name": "detect_orphaned_runs",
            "signature": "(session: AsyncSession, threshold_minutes: int = ORPHAN_THRESHOLD_MINUTES) -> list[WorkerRun]",
            "docstring": "Detect runs that appear to be orphaned.\n\nA run is orphaned if:\n- Status is \"running\" and created > threshold_minutes ago\n- Status is \"queued\" and created > threshold_minutes ago\n\nThe threshold prevents marking in-progress runs as orphaned.",
            "is_async": true,
            "line": 64
          },
          {
            "name": "mark_run_as_crashed",
            "signature": "(session: AsyncSession, run: WorkerRun, reason: str = 'System restart - run was in progress when system crashed') -> bool",
            "docstring": "Mark a run as crashed.\n\nThis is a factual status update, not a mutation of historical data.\nThe run WAS running/queued, and it DID crash. We're recording that fact.\n\nReturns True if successfully marked, False otherwise.",
            "is_async": true,
            "line": 89
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select",
              "update"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 29
          },
          {
            "name": "RETRY_POLICY",
            "line": 30
          },
          {
            "name": "ORPHAN_THRESHOLD_MINUTES",
            "line": 61
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "run_signal_driver.py",
        "file_path": "backend/app/hoc/cus/activity/L6_drivers/run_signal_driver.py",
        "layer": "L6_drivers",
        "domain": "activity",
        "lines": 193,
        "module_docstring": "RunSignalService (L6 Driver)\n\nPURPOSE:\n    Updates run risk levels based on threshold signals.\n    Bridges threshold evaluation (L5) to run state (L7).\n\nINTERFACE:\n    - RunSignalService(session): Constructor takes sync session\n    - update_risk_level(run_id, signals): Updates risk level for a run\n\nL6 CONTRACT:\n    - Pure data access, no business logic\n    - Does NOT determine which signals to emit (that's L5)\n    - Only persists signal outcomes to runs table\n\nCALLERS:\n    - threshold_driver.py: emit_and_persist_threshold_signal()\n    - llm_threshold_driver.py: emit_and_persist_threshold_signal()",
        "functions": [],
        "classes": [
          {
            "name": "RunSignalDriver",
            "docstring": "Service for updating run risk levels based on threshold signals.\n\nL6 Driver Contract:\n- Pure data access, no business logic\n- Takes sync session (for worker/callback context)\n- Updates runs.risk_level column\n\nUsage:\n    service = RunSignalService(session)\n    service.update_risk_level(run_id, signals)",
            "methods": [
              "__init__",
              "update_risk_level",
              "get_risk_level"
            ],
            "line": 69
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [
          {
            "name": "SIGNAL_TO_RISK_LEVEL",
            "line": 58
          },
          {
            "name": "DEFAULT_RISK_LEVEL",
            "line": 66
          }
        ],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 13,
    "violation_count": 0,
    "gap_count": 1
  },
  "incidents": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/incidents.py",
    "l2_apis": [
      {
        "file_name": "cost_guard.py",
        "file_path": "backend/app/hoc/api/cus/incidents/cost_guard.py",
        "layer": "L2_api",
        "domain": "incidents",
        "lines": 484,
        "module_docstring": "Guard Console Cost Visibility API - Customer Cost Transparency\n\nM29 Category 4: Cost Intelligence Completion\n\nThis router provides /guard/costs/* endpoints for the Customer Console.\nCustomers see their own cost data with calm vocabulary.\n\nTHE INVARIANT: All values derive from complete snapshots, never live data.\nCustomer sees ONLY their own tenant data - no cross-tenant leakage.\n\nEndpoints:\n- GET  /guard/costs/summary    - Cost summary with trend and projection\n- GET  /guard/costs/explained  - Why costs are what they are\n- GET  /guard/costs/incidents  - Cost-related incidents\n\nCRITICAL: Uses FROZEN DTOs from app.contracts.guard.\nNEVER expose founder-only fields (affected_tenants, churn_risk, etc.).\n\nREFACTORED: All session.execute() calls moved to L6 driver via L4 handler.\nL2 now uses registry dispatch for all DB operations.",
        "functions": [
          {
            "name": "_map_trend",
            "signature": "(deviation_pct: Optional[float]) -> tuple[Literal['normal', 'rising', 'spike'], str]",
            "docstring": "Map deviation to customer-friendly trend.",
            "is_async": false,
            "line": 73
          },
          {
            "name": "_map_severity_to_status",
            "signature": "(severity: str) -> Literal['protected', 'attention_needed', 'resolved']",
            "docstring": "Map internal severity to calm vocabulary.",
            "is_async": false,
            "line": 88
          },
          {
            "name": "_generate_summary",
            "signature": "(by_feature: List[CostBreakdownItemDTO], by_model: List[CostBreakdownItemDTO], total_spend: int) -> str",
            "docstring": "Generate a one-sentence summary of cost drivers.",
            "is_async": false,
            "line": 98
          },
          {
            "name": "_dispatch",
            "signature": "(session, tenant_id: str, method: str, **params)",
            "docstring": "Dispatch to L4 registry for cost_guard operations.",
            "is_async": true,
            "line": 124
          },
          {
            "name": "get_cost_summary",
            "signature": "(tenant_id: str = Query(..., description='Your tenant ID'), token: CustomerToken = Depends(verify_console_token), session = Depends(get_sync_session_dep)) -> CustomerCostSummaryDTO",
            "docstring": "GET /guard/costs/summary\n\nCustomer cost summary with trend and projection.\nUses calm vocabulary: normal, rising, spike (not critical/high/medium).\n\nShows:\n- Today spend, MTD spend, 7d spend\n- Budget usage (if configured)\n- Projected month-end\n- Trend with human-readable message",
            "is_async": true,
            "line": 144
          },
          {
            "name": "get_cost_explained",
            "signature": "(tenant_id: str = Query(..., description='Your tenant ID'), period: Literal['today', '7d', '30d'] = Query('7d'), token: CustomerToken = Depends(verify_console_token), session = Depends(get_sync_session_dep)) -> CustomerCostExplainedDTO",
            "docstring": "GET /guard/costs/explained\n\nExplains WHY costs are what they are.\nBreaks down by feature, model, and user.\n\nDoes NOT expose:\n- churn_risk_score (founder only)\n- affected_tenants (founder only)\n- stickiness_delta (founder only)",
            "is_async": true,
            "line": 232
          },
          {
            "name": "get_cost_incidents",
            "signature": "(tenant_id: str = Query(..., description='Your tenant ID'), include_resolved: bool = Query(False), limit: int = Query(20, ge=1, le=100), token: CustomerToken = Depends(verify_console_token), session = Depends(get_sync_session_dep)) -> CustomerCostIncidentListDTO",
            "docstring": "GET /guard/costs/incidents\n\nCost-related incidents visible to customer.\nUses calm vocabulary (protected, attention_needed).\nDoes NOT expose severity levels directly.",
            "is_async": true,
            "line": 388
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Literal",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "CustomerToken",
              "verify_console_token"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.contracts.guard",
            "names": [
              "CostBreakdownItemDTO",
              "CustomerCostExplainedDTO",
              "CustomerCostIncidentDTO",
              "CustomerCostIncidentListDTO",
              "CustomerCostSummaryDTO"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_operation_registry",
              "get_sync_session_dep",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incidents.py",
        "file_path": "backend/app/hoc/api/cus/incidents/incidents.py",
        "layer": "L2_api",
        "domain": "incidents",
        "lines": 1922,
        "module_docstring": "Unified Incidents API (L2)\n\nCustomer-facing endpoints for viewing incidents.\nAll requests are tenant-scoped via auth_context.\n\nEndpoints:\n- GET /incidents                        \u2192 O2 list with filters\n- GET /incidents/{incident_id}          \u2192 O3 detail\n- GET /incidents/{incident_id}/evidence \u2192 O4 context (preflight)\n- GET /incidents/{incident_id}/proof    \u2192 O5 raw (preflight)\n- GET /incidents/{incident_id}/learnings \u2192 O4 post-mortem learnings\n- GET /incidents/by-run/{run_id}        \u2192 Incidents linked to run\n- GET /incidents/patterns               \u2192 ACT-O5 pattern detection\n- GET /incidents/recurring              \u2192 HIST-O3 recurrence analysis\n- GET /incidents/cost-impact            \u2192 RES-O3 cost impact analysis\n\nArchitecture:\n- ONE facade for all INCIDENTS needs\n- Tenant isolation via auth_context (not header)\n- SDSR validates this same production API",
        "functions": [
          {
            "name": "require_preflight",
            "signature": "() -> None",
            "docstring": "Guard for preflight-only endpoints (O4, O5).",
            "is_async": false,
            "line": 67
          },
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 452
          },
          {
            "name": "list_incidents",
            "signature": "(request: Request, topic: Annotated[Topic | None, Query(description='UX Topic: ACTIVE or RESOLVED')] = None, lifecycle_state: Annotated[LifecycleState | None, Query(description='Direct lifecycle state filter')] = None, severity: Annotated[Severity | None, Query(description='Filter by severity')] = None, category: Annotated[str | None, Query(description='Filter by category')] = None, cause_type: Annotated[CauseType | None, Query(description='Filter by cause type')] = None, is_synthetic: Annotated[bool | None, Query(description='Filter by synthetic data flag')] = None, created_after: Annotated[datetime | None, Query(description='Filter incidents created after')] = None, created_before: Annotated[datetime | None, Query(description='Filter incidents created before')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max incidents to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of incidents to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.CREATED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session = Depends(get_session_dep)) -> IncidentListResponse",
            "docstring": "List incidents with unified query filters. Tenant-scoped.",
            "is_async": true,
            "line": 511
          },
          {
            "name": "get_incidents_for_run",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> IncidentsByRunResponse",
            "docstring": "Get all incidents linked to a specific run. Tenant-scoped.",
            "is_async": true,
            "line": 628
          },
          {
            "name": "detect_patterns",
            "signature": "(request: Request, window_hours: Annotated[int, Query(ge=1, le=168, description='Hours to look back (max 168 = 7 days)')] = 24, limit: Annotated[int, Query(ge=1, le=50, description='Max patterns per type')] = 10, session = Depends(get_session_dep)) -> PatternDetectionResponse",
            "docstring": "Detect incident patterns. Tenant-scoped.",
            "is_async": true,
            "line": 694
          },
          {
            "name": "analyze_recurrence",
            "signature": "(request: Request, baseline_days: Annotated[int, Query(ge=1, le=90, description='Days to analyze (max 90)')] = 30, recurrence_threshold: Annotated[int, Query(ge=2, le=100, description='Min occurrences to flag as recurring')] = 3, limit: Annotated[int, Query(ge=1, le=50, description='Max groups to return')] = 20, session = Depends(get_session_dep)) -> RecurrenceAnalysisResponse",
            "docstring": "Analyze recurring incident patterns. Tenant-scoped.",
            "is_async": true,
            "line": 751
          },
          {
            "name": "analyze_cost_impact",
            "signature": "(request: Request, baseline_days: Annotated[int, Query(ge=1, le=90, description='Days to analyze (max 90)')] = 30, limit: Annotated[int, Query(ge=1, le=50, description='Max categories to return')] = 20, session = Depends(get_session_dep)) -> CostImpactResponse",
            "docstring": "Analyze cost impact across incidents. Tenant-scoped.",
            "is_async": true,
            "line": 816
          },
          {
            "name": "list_active_incidents",
            "signature": "(request: Request, severity: Annotated[Severity | None, Query(description='Filter by severity')] = None, category: Annotated[str | None, Query(description='Filter by category')] = None, cause_type: Annotated[CauseType | None, Query(description='Filter by cause type')] = None, is_synthetic: Annotated[bool | None, Query(description='Filter by synthetic data flag')] = None, created_after: Annotated[datetime | None, Query(description='Filter incidents created after')] = None, created_before: Annotated[datetime | None, Query(description='Filter incidents created before')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max incidents to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of incidents to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.CREATED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session = Depends(get_session_dep)) -> IncidentListResponse",
            "docstring": "List ACTIVE incidents. Topic enforced at endpoint boundary.",
            "is_async": true,
            "line": 883
          },
          {
            "name": "list_resolved_incidents",
            "signature": "(request: Request, severity: Annotated[Severity | None, Query(description='Filter by severity')] = None, category: Annotated[str | None, Query(description='Filter by category')] = None, cause_type: Annotated[CauseType | None, Query(description='Filter by cause type')] = None, is_synthetic: Annotated[bool | None, Query(description='Filter by synthetic data flag')] = None, resolved_after: Annotated[datetime | None, Query(description='Filter incidents resolved after')] = None, resolved_before: Annotated[datetime | None, Query(description='Filter incidents resolved before')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max incidents to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of incidents to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.RESOLVED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session = Depends(get_session_dep)) -> IncidentListResponse",
            "docstring": "List RESOLVED incidents. Topic enforced at endpoint boundary.",
            "is_async": true,
            "line": 988
          },
          {
            "name": "list_historical_incidents",
            "signature": "(request: Request, retention_days: Annotated[int, Query(ge=7, le=365, description='Retention window in days')] = 30, severity: Annotated[Severity | None, Query(description='Filter by severity')] = None, category: Annotated[str | None, Query(description='Filter by category')] = None, cause_type: Annotated[CauseType | None, Query(description='Filter by cause type')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max incidents to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of incidents to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.RESOLVED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session = Depends(get_session_dep)) -> IncidentListResponse",
            "docstring": "List HISTORICAL incidents (resolved beyond retention). Topic enforced.",
            "is_async": true,
            "line": 1093
          },
          {
            "name": "get_incident_metrics",
            "signature": "(request: Request, window_days: Annotated[int, Query(ge=1, le=90, description='Window in days')] = 30, session = Depends(get_session_dep)) -> IncidentMetricsResponse",
            "docstring": "Get incident metrics. Backend-computed, deterministic.",
            "is_async": true,
            "line": 1194
          },
          {
            "name": "get_historical_trend",
            "signature": "(request: Request, window_days: Annotated[int, Query(ge=7, le=365, description='Window in days')] = 90, granularity: Annotated[str, Query(description='Aggregation granularity')] = 'week', session = Depends(get_session_dep)) -> HistoricalTrendResponse",
            "docstring": "Get historical trend. Backend-computed, deterministic.",
            "is_async": true,
            "line": 1251
          },
          {
            "name": "get_historical_distribution",
            "signature": "(request: Request, window_days: Annotated[int, Query(ge=7, le=365, description='Window in days')] = 90, session = Depends(get_session_dep)) -> HistoricalDistributionResponse",
            "docstring": "Get historical distribution. Backend-computed, deterministic.",
            "is_async": true,
            "line": 1316
          },
          {
            "name": "get_historical_cost_trend",
            "signature": "(request: Request, window_days: Annotated[int, Query(ge=7, le=365, description='Window in days')] = 90, granularity: Annotated[str, Query(description='Aggregation granularity')] = 'week', session = Depends(get_session_dep)) -> CostTrendResponse",
            "docstring": "Get historical cost trend. Backend-computed, deterministic.",
            "is_async": true,
            "line": 1376
          },
          {
            "name": "get_incident_detail",
            "signature": "(request: Request, incident_id: str, session = Depends(get_session_dep)) -> IncidentDetailResponse",
            "docstring": "Get incident detail (O3). Tenant isolation enforced.",
            "is_async": true,
            "line": 1437
          },
          {
            "name": "get_incident_evidence",
            "signature": "(request: Request, incident_id: str) -> dict[str, Any]",
            "docstring": "Get incident evidence (O4). Preflight console only.",
            "is_async": true,
            "line": 1499
          },
          {
            "name": "get_incident_proof",
            "signature": "(request: Request, incident_id: str) -> dict[str, Any]",
            "docstring": "Get incident proof (O5). Preflight console only.",
            "is_async": true,
            "line": 1526
          },
          {
            "name": "get_incident_learnings",
            "signature": "(request: Request, incident_id: str, session = Depends(get_session_dep)) -> LearningsResponse",
            "docstring": "Get post-mortem learnings for an incident. Tenant-scoped.",
            "is_async": true,
            "line": 1561
          },
          {
            "name": "export_evidence",
            "signature": "(request: Request, incident_id: str, export_request: ExportRequest) -> Any",
            "docstring": "Export incident evidence bundle.",
            "is_async": true,
            "line": 1660
          },
          {
            "name": "export_soc2",
            "signature": "(request: Request, incident_id: str, export_request: ExportRequest) -> Any",
            "docstring": "Export SOC2-compliant bundle as PDF.",
            "is_async": true,
            "line": 1753
          },
          {
            "name": "export_executive_debrief",
            "signature": "(request: Request, incident_id: str, export_request: ExportRequest) -> Any",
            "docstring": "Export executive debrief as PDF.",
            "is_async": true,
            "line": 1846
          }
        ],
        "classes": [
          {
            "name": "LifecycleState",
            "docstring": "Incident lifecycle state.",
            "methods": [],
            "line": 84
          },
          {
            "name": "Severity",
            "docstring": "Incident severity.",
            "methods": [],
            "line": 92
          },
          {
            "name": "CauseType",
            "docstring": "Incident cause type.",
            "methods": [],
            "line": 101
          },
          {
            "name": "Topic",
            "docstring": "UX topic for filtering.",
            "methods": [],
            "line": 109
          },
          {
            "name": "SortField",
            "docstring": "Allowed sort fields.",
            "methods": [],
            "line": 116
          },
          {
            "name": "SortOrder",
            "docstring": "Sort direction.",
            "methods": [],
            "line": 124
          },
          {
            "name": "IncidentSummary",
            "docstring": "Incident summary for list view (O2).",
            "methods": [],
            "line": 136
          },
          {
            "name": "Pagination",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 164
          },
          {
            "name": "IncidentListResponse",
            "docstring": "GET /incidents response.",
            "methods": [],
            "line": 172
          },
          {
            "name": "IncidentDetailResponse",
            "docstring": "GET /incidents/{incident_id} response (O3).",
            "methods": [],
            "line": 182
          },
          {
            "name": "IncidentsByRunResponse",
            "docstring": "GET /incidents/by-run/{run_id} response.",
            "methods": [],
            "line": 218
          },
          {
            "name": "PatternMatchResponse",
            "docstring": "A detected incident pattern.",
            "methods": [],
            "line": 231
          },
          {
            "name": "PatternDetectionResponse",
            "docstring": "GET /incidents/patterns response (ACT-O5).",
            "methods": [],
            "line": 241
          },
          {
            "name": "RecurrenceGroupResponse",
            "docstring": "A group of recurring incidents.",
            "methods": [],
            "line": 256
          },
          {
            "name": "RecurrenceAnalysisResponse",
            "docstring": "GET /incidents/recurring response (HIST-O3).",
            "methods": [],
            "line": 269
          },
          {
            "name": "CostImpactSummary",
            "docstring": "Cost impact summary for an incident category.",
            "methods": [],
            "line": 283
          },
          {
            "name": "CostImpactResponse",
            "docstring": "GET /incidents/cost-impact response (RES-O3).",
            "methods": [],
            "line": 293
          },
          {
            "name": "IncidentMetricsResponse",
            "docstring": "GET /incidents/metrics response - Dedicated metrics capability.",
            "methods": [],
            "line": 307
          },
          {
            "name": "HistoricalTrendDataPoint",
            "docstring": "A single data point in a historical trend.",
            "methods": [],
            "line": 340
          },
          {
            "name": "HistoricalTrendResponse",
            "docstring": "GET /incidents/historical/trend response.",
            "methods": [],
            "line": 349
          },
          {
            "name": "HistoricalDistributionEntry",
            "docstring": "A single entry in the distribution.",
            "methods": [],
            "line": 359
          },
          {
            "name": "HistoricalDistributionResponse",
            "docstring": "GET /incidents/historical/distribution response.",
            "methods": [],
            "line": 368
          },
          {
            "name": "CostTrendDataPoint",
            "docstring": "A single data point in the cost trend.",
            "methods": [],
            "line": 379
          },
          {
            "name": "CostTrendResponse",
            "docstring": "GET /incidents/historical/cost-trend response.",
            "methods": [],
            "line": 388
          },
          {
            "name": "LearningInsightResponse",
            "docstring": "A learning insight from incident analysis.",
            "methods": [],
            "line": 404
          },
          {
            "name": "ResolutionSummaryResponse",
            "docstring": "Summary of incident resolution.",
            "methods": [],
            "line": 413
          },
          {
            "name": "LearningsResponse",
            "docstring": "GET /incidents/{id}/learnings response (RES-O4).",
            "methods": [],
            "line": 426
          },
          {
            "name": "ExportFormat",
            "docstring": "Export format options.",
            "methods": [],
            "line": 1632
          },
          {
            "name": "ExportRequest",
            "docstring": "Request for export with optional parameters.",
            "methods": [],
            "line": 1639
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [
          {
            "name": "_CURRENT_ENVIRONMENT",
            "line": 64
          }
        ],
        "all_exports": null
      }
    ],
    "l4_spine": [],
    "l5_engines": [
      {
        "file_name": "anomaly_bridge.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/anomaly_bridge.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 297,
        "module_docstring": "Anomaly-to-Incident Bridge\n\nAccepts pure CostAnomalyFact from analytics and decides if an incident\nshould be created. This is NOT a general service - it applies incident\ncreation rules specific to cost anomalies.\n\nResponsibilities:\n- Accept CostAnomalyFact (pure data, no DB, no imports from analytics)\n- Apply severity/confidence thresholds\n- Apply deduplication window\n- Apply suppression rules\n- Map anomaly data to incident schema\n- Delegate persistence to IncidentWriteDriver\n\nThis bridge ensures analytics never writes to incidents directly.",
        "functions": [
          {
            "name": "get_anomaly_incident_bridge",
            "signature": "(session) -> AnomalyIncidentBridge",
            "docstring": "Factory function to get AnomalyIncidentBridge instance.\n\nPIN-508 Phase 1B: Creates driver from session, passes driver to bridge.\nBridge no longer receives session directly.",
            "is_async": false,
            "line": 282
          }
        ],
        "classes": [
          {
            "name": "AnomalyIncidentBridge",
            "docstring": "Bridge that accepts cost anomaly facts and creates incidents.\n\nOWNED BY INCIDENTS DOMAIN, not by analytics.\n\nThis bridge applies incident creation rules:\n- Only HIGH severity anomalies create incidents\n- Deduplication prevents duplicate incidents\n- Suppression rules may block incident creation\n\nUsage:\n    bridge = AnomalyIncidentBridge(session)\n    incident_id = bridge.ingest(fact)  # Returns None if not created",
            "methods": [
              "__init__",
              "ingest",
              "_meets_severity_threshold",
              "_is_suppressed",
              "_check_existing_incident",
              "_create_incident"
            ],
            "line": 99
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.errors.governance",
            "names": [
              "GovernanceError"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_write_driver",
            "names": [
              "IncidentWriteDriver",
              "get_incident_write_driver"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.metrics",
            "names": [
              "governance_incidents_created_total"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.anomaly_types",
            "names": [
              "CostAnomalyFact"
            ],
            "is_relative": false,
            "line": 64
          }
        ],
        "constants": [
          {
            "name": "INCIDENT_SEVERITY_THRESHOLD",
            "line": 72
          },
          {
            "name": "ANOMALY_SEVERITY_MAP",
            "line": 75
          },
          {
            "name": "ANOMALY_TRIGGER_TYPE_MAP",
            "line": 83
          }
        ],
        "all_exports": [
          "AnomalyIncidentBridge",
          "get_anomaly_incident_bridge",
          "INCIDENT_SEVERITY_THRESHOLD"
        ]
      },
      {
        "file_name": "export_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/export_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 225,
        "module_docstring": "Export Engine (PIN-511 Phase 2.1)\n\nL5 engine that owns export business logic for the incidents domain.\nValidates export requests, selects bundle type, delegates to L6 driver via Protocol.\n\nResponsibilities:\n- Validate export request (permissions, compliance period)\n- Select bundle type (evidence, SOC2, executive)\n- Call driver via Protocol\n- Return structured result\n\nRules:\n- No session \u2014 receives driver via constructor\n- No cross-domain imports\n- No decision logic beyond selection + validation",
        "functions": [],
        "classes": [
          {
            "name": "ExportEngine",
            "docstring": "L5 engine for incident export operations.\n\nReceives ExportBundleProtocol driver via constructor.\nNo direct DB access \u2014 all data operations via Protocol.",
            "methods": [
              "__init__",
              "export_evidence",
              "export_soc2",
              "export_executive_debrief",
              "export_with_integrity"
            ],
            "line": 44
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "hallucination_detector.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/hallucination_detector.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 467,
        "module_docstring": "Module: hallucination_detector\nPurpose: Detect potential hallucinations in LLM outputs.\n\nCRITICAL INVARIANT (INV-002 / HALLU-INV-001):\n    Hallucination detection is ALWAYS non-blocking by default.\n    This is because:\n    - Hallucination detection is PROBABILISTIC (60-90% confidence)\n    - Policy violations (cost, rate, PII) are DETERMINISTIC (facts)\n    - False positives on hallucination blocking destroy customer trust\n    - Blocking requires explicit customer opt-in\n\nImports (Dependencies):\n    - dataclasses: Detection result structures\n    - hashlib: Content hashing for evidence\n\nExports (Provides):\n    - HallucinationDetector: Main detection service\n    - HallucinationResult: Detection result dataclass\n    - HallucinationIndicator: Individual indicator dataclass\n    - HallucinationType: Type of hallucination detected\n\nWiring Points:\n    - Called from: worker/runner.py after step completion\n    - Calls: incident_engine.create_incident() with blocking=False",
        "functions": [
          {
            "name": "create_detector_for_tenant",
            "signature": "(tenant_config: Optional[dict[str, Any]] = None) -> HallucinationDetector",
            "docstring": "Create a detector configured for a specific tenant.\n\nArgs:\n    tenant_config: Optional tenant-specific configuration\n\nReturns:\n    Configured HallucinationDetector\n\nCRITICAL (INV-002): blocking_enabled requires explicit tenant opt-in.",
            "is_async": false,
            "line": 445
          }
        ],
        "classes": [
          {
            "name": "HallucinationType",
            "docstring": "Types of hallucination indicators.",
            "methods": [],
            "line": 56
          },
          {
            "name": "HallucinationSeverity",
            "docstring": "Severity levels for hallucination detections.",
            "methods": [],
            "line": 78
          },
          {
            "name": "HallucinationIndicator",
            "docstring": "Individual hallucination indicator.\n\nRepresents a single piece of evidence suggesting hallucination.\nMultiple indicators combine to form overall confidence.",
            "methods": [
              "to_dict"
            ],
            "line": 88
          },
          {
            "name": "HallucinationResult",
            "docstring": "Result of hallucination detection.\n\nContains overall assessment and individual indicators.",
            "methods": [
              "to_incident_data",
              "_derive_severity"
            ],
            "line": 116
          },
          {
            "name": "HallucinationConfig",
            "docstring": "Configuration for hallucination detection.\n\nINV-002 COMPLIANCE:\n    - blocking_enabled defaults to False\n    - blocking_enabled=True requires explicit customer opt-in",
            "methods": [],
            "line": 167
          },
          {
            "name": "HallucinationDetector",
            "docstring": "Hallucination detection service.\n\nCRITICAL INVARIANT (INV-002 / HALLU-INV-001):\n    This service MUST be non-blocking by default.\n    Hallucination detection is PROBABILISTIC, not DETERMINISTIC.\n    False positives on blocking destroy customer trust.\n\nDetection feeds OBSERVABILITY path, not SPINE.\nCustomer must explicitly opt-in for blocking behavior.",
            "methods": [
              "__init__",
              "detect",
              "_detect_suspicious_urls",
              "_detect_suspicious_citations",
              "_detect_contradictions",
              "_detect_temporal_issues",
              "_hash_content"
            ],
            "line": 195
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incident_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 910,
        "module_docstring": "Incident Engine (L4 Domain Logic)\n\nThis engine implements the SDSR cross-domain propagation contract:\n- Run failure (Activity domain) \u2192 Incident creation (Incidents domain)\n\nPer PIN-370 Rule 6 (Scenarios Inject Causes, Not Consequences):\n- Scenarios inject a failed run\n- This engine AUTOMATICALLY creates incidents\n- If incident doesn't appear, the ENGINE is broken, not the scenario\n\nDECISIONS (L4 - stay here):\n- Severity mapping from error codes\n- Category mapping from error codes\n- Policy suppression decision\n- Title generation\n- Policy proposal creation decision\n\nPERSISTENCE (L6 - delegated to driver):\n- INSERT into incidents\n- INSERT into prevention_records\n- INSERT into policy_proposals\n- UPDATE runs, aos_traces\n\nReference: PIN-370, PIN-468, INCIDENTS-EXEC-FAILURE-001",
        "functions": [
          {
            "name": "get_incident_engine",
            "signature": "(evidence_recorder: Any = None) -> IncidentEngine",
            "docstring": "Get or create singleton incident engine instance.\n\nArgs:\n    evidence_recorder: Optional evidence recorder (lessons coordinator).\n        If not provided, engine runs without evidence recording.\n        L4 callers should use incidents_bridge.evidence_recorder_capability()\n        to get the lessons coordinator implementation.\n\nPIN-520: Removed orchestrator import - L5 must not import L4 orchestrator.\nCallers that need evidence recording should inject via L4 bridge.",
            "is_async": false,
            "line": 894
          }
        ],
        "classes": [
          {
            "name": "IncidentEngine",
            "docstring": "L4 Domain Engine for incident creation.\n\nThis engine implements the SDSR cross-domain propagation:\nActivity (cause) \u2192 Incidents (reactive)\n\nSDSR Contract (PIN-370):\n- This engine is called when a run fails\n- It creates an incident record automatically\n- Incidents are NEVER created by scenarios directly\n- If incidents don't appear for failed runs, THIS ENGINE is broken\n\nCallers:\n- Worker runtime (on run failure)\n- inject_synthetic.py expectations validator\n\nPIN-468 Phase-2.5A:\n- All DB operations delegated to IncidentWriteDriver\n- Engine contains ONLY decision logic\n- No sqlalchemy/sqlmodel imports at runtime",
            "methods": [
              "__init__",
              "_get_driver",
              "_check_policy_suppression",
              "_write_prevention_record",
              "create_incident_for_run",
              "create_incident_for_failed_run",
              "_maybe_create_policy_proposal",
              "_generate_title",
              "check_and_create_incident",
              "create_incident_for_all_runs",
              "_extract_error_code",
              "get_incidents_for_run"
            ],
            "line": 158
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_write_driver",
            "names": [
              "IncidentWriteDriver",
              "get_incident_write_driver"
            ],
            "is_relative": false,
            "line": 76
          }
        ],
        "constants": [
          {
            "name": "INCIDENT_OUTCOME_SUCCESS",
            "line": 115
          },
          {
            "name": "INCIDENT_OUTCOME_FAILURE",
            "line": 116
          },
          {
            "name": "INCIDENT_OUTCOME_BLOCKED",
            "line": 117
          },
          {
            "name": "INCIDENT_OUTCOME_ABORTED",
            "line": 118
          },
          {
            "name": "SEVERITY_NONE",
            "line": 121
          },
          {
            "name": "FAILURE_SEVERITY_MAP",
            "line": 124
          },
          {
            "name": "FAILURE_CATEGORY_MAP",
            "line": 143
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "incident_pattern.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_pattern.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 281,
        "module_docstring": "Incident Pattern Engine - L4 Domain Logic\n\nDetects structural patterns across incidents:\n- category_cluster: Multiple incidents in same category\n- severity_spike: Multiple high/critical in short window\n- cascade_failure: Multiple incidents from same source run\n- resolution_pattern: Common resolution methods\n\nArchitecture:\n- All DB operations delegated to IncidentPatternDriver (L6)\n- Engine contains only pattern detection logic\n- Read-only (no writes)\n\nDesign Rules:\n- Rule-based only (v1, no ML)\n- No cross-service calls",
        "functions": [],
        "classes": [
          {
            "name": "PatternMatch",
            "docstring": "A detected incident pattern.",
            "methods": [],
            "line": 74
          },
          {
            "name": "PatternResult",
            "docstring": "Result of pattern detection.",
            "methods": [],
            "line": 84
          },
          {
            "name": "IncidentPatternService",
            "docstring": "Detect structural patterns across incidents.\n\nRESPONSIBILITIES:\n- Detect category clusters\n- Detect severity spikes\n- Detect cascade failures\n- Return pattern type + confidence\n\nFORBIDDEN:\n- Write to any table\n- Call other services\n- Use machine learning\n\nNote: All DB operations are delegated to IncidentPatternDriver (L6).\nThis engine contains only pattern detection logic.",
            "methods": [
              "__init__",
              "detect_patterns",
              "_detect_category_clusters",
              "_detect_severity_spikes",
              "_detect_cascade_failures"
            ],
            "line": 92
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_pattern_driver",
            "names": [
              "IncidentPatternDriver",
              "get_incident_pattern_driver"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incident_read_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_read_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 153,
        "module_docstring": "Incident Read Service (L4)\n\nThis service provides all READ operations for the Incidents domain.\nIt delegates to IncidentReadDriver (L6) for all database access.\n\nL3 (Adapter) \u2192 L4 (this service) \u2192 L6 (IncidentReadDriver)\n\nResponsibilities:\n- Delegate to L6 driver for data access\n- Apply business rules (if any)\n- Maintain backward compatibility for callers\n\nReference: PIN-281, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_read_service",
            "signature": "(session: 'Session') -> IncidentReadService",
            "docstring": "Factory function to get IncidentReadService instance.",
            "is_async": false,
            "line": 145
          }
        ],
        "classes": [
          {
            "name": "IncidentReadService",
            "docstring": "L4 service for incident read operations.\n\nDelegates all database operations to IncidentReadDriver (L6).\nMaintains backward compatibility for existing callers.\n\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "list_incidents",
              "get_incident",
              "get_incident_events",
              "count_incidents_since",
              "get_last_incident"
            ],
            "line": 59
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_read_driver",
            "names": [
              "IncidentReadDriver",
              "get_incident_read_driver"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentReadService",
          "get_incident_read_service"
        ]
      },
      {
        "file_name": "incident_write_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_write_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 317,
        "module_docstring": "Incident Write Service (L4)\n\nThis service provides all WRITE operations for the Incidents domain.\nIt delegates DB access to IncidentWriteDriver (L6) and applies business logic.\n\nL3 (Adapter) \u2192 L4 (this service) \u2192 L6 (IncidentWriteDriver)\n\nResponsibilities:\n- Acknowledge incidents (audit emit + delegate DB to driver)\n- Resolve incidents (audit emit + delegate DB to driver)\n- Transaction orchestration (begin/commit/rollback)\n- Audit event emission (L4 responsibility)\n- NO direct DB access - driver calls only\n\nReference: PIN-281, PIN-413, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_write_service",
            "signature": "(session: 'Session', audit: Any = None) -> IncidentWriteService",
            "docstring": "Factory function to get IncidentWriteService instance.\n\nArgs:\n    session: SQLAlchemy sync Session\n    audit: Optional audit service (injected by L4 handler for cross-domain audit)",
            "is_async": false,
            "line": 303
          }
        ],
        "classes": [
          {
            "name": "IncidentWriteService",
            "docstring": "L5 engine for incident write operations.\n\nDelegates DB operations to IncidentWriteDriver (L6).\nMaintains business logic (audit events, transactions) in L5.\nAudit service is injected by L4 handler (PIN-504: no cross-domain imports).\n\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "acknowledge_incident",
              "resolve_incident",
              "manual_close_incident"
            ],
            "line": 64
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_write_driver",
            "names": [
              "IncidentWriteDriver",
              "get_incident_write_driver"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.domain_enums",
            "names": [
              "ActorType"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentWriteService",
          "get_incident_write_service"
        ]
      },
      {
        "file_name": "incidents_facade.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incidents_facade.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 1195,
        "module_docstring": "Incidents Domain Facade (L5)\n\nUnified facade for incident management operations.\n\nProvides:\n- List incidents: active, resolved, historical\n- Get incident detail\n- Get incidents by run\n- Pattern detection (ACT-O5)\n- Recurrence analysis (HIST-O3)\n- Cost impact analysis (RES-O3)\n- Metrics\n- Historical trend/distribution/cost-trend\n- Post-mortem learnings (RES-O4)\n\nAll operations are tenant-scoped for isolation.\n\nArchitecture:\n- Facade \u2192 Driver (L6) for DB operations\n- Facade \u2192 Engine (L4) for business logic delegation\n- No direct sqlalchemy imports",
        "functions": [
          {
            "name": "get_incidents_facade",
            "signature": "() -> IncidentsFacade",
            "docstring": "Get the singleton IncidentsFacade instance.",
            "is_async": false,
            "line": 1154
          }
        ],
        "classes": [
          {
            "name": "IncidentSummaryResult",
            "docstring": "Incident summary for list view (O2).",
            "methods": [],
            "line": 68
          },
          {
            "name": "PaginationResult",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 90
          },
          {
            "name": "IncidentListResult",
            "docstring": "Incidents list response.",
            "methods": [],
            "line": 99
          },
          {
            "name": "IncidentDetailResult",
            "docstring": "Incident detail response (O3).",
            "methods": [],
            "line": 115
          },
          {
            "name": "IncidentsByRunResult",
            "docstring": "Incidents by run response.",
            "methods": [],
            "line": 144
          },
          {
            "name": "PatternMatchResult",
            "docstring": "A detected incident pattern.",
            "methods": [],
            "line": 158
          },
          {
            "name": "PatternDetectionResult",
            "docstring": "Pattern detection response.",
            "methods": [],
            "line": 169
          },
          {
            "name": "RecurrenceGroupResult",
            "docstring": "A group of recurring incidents.",
            "methods": [],
            "line": 185
          },
          {
            "name": "RecurrenceAnalysisResult",
            "docstring": "Recurrence analysis response.",
            "methods": [],
            "line": 199
          },
          {
            "name": "CostImpactSummaryResult",
            "docstring": "Cost impact summary for an incident category.",
            "methods": [],
            "line": 214
          },
          {
            "name": "CostImpactResult",
            "docstring": "Cost impact analysis response.",
            "methods": [],
            "line": 225
          },
          {
            "name": "IncidentMetricsResult",
            "docstring": "Incident metrics response.",
            "methods": [],
            "line": 240
          },
          {
            "name": "HistoricalTrendDataPointResult",
            "docstring": "A single data point in a historical trend.",
            "methods": [],
            "line": 268
          },
          {
            "name": "HistoricalTrendResult",
            "docstring": "Historical trend response.",
            "methods": [],
            "line": 278
          },
          {
            "name": "HistoricalDistributionEntryResult",
            "docstring": "A single entry in the distribution.",
            "methods": [],
            "line": 289
          },
          {
            "name": "HistoricalDistributionResult",
            "docstring": "Historical distribution response.",
            "methods": [],
            "line": 299
          },
          {
            "name": "CostTrendDataPointResult",
            "docstring": "A single data point in the cost trend.",
            "methods": [],
            "line": 311
          },
          {
            "name": "CostTrendResult",
            "docstring": "Cost trend response.",
            "methods": [],
            "line": 321
          },
          {
            "name": "LearningInsightResult",
            "docstring": "A learning insight from incident analysis.",
            "methods": [],
            "line": 338
          },
          {
            "name": "ResolutionSummaryResult",
            "docstring": "Summary of incident resolution.",
            "methods": [],
            "line": 348
          },
          {
            "name": "LearningsResult",
            "docstring": "Incident learnings response.",
            "methods": [],
            "line": 362
          },
          {
            "name": "IncidentsFacade",
            "docstring": "Unified facade for incident management.\n\nProvides:\n- List incidents: active, resolved, historical\n- Get incident detail\n- Get incidents by run\n- Metrics\n- Cost impact analysis\n\nAll operations are tenant-scoped for isolation.\n\nArchitecture:\n- Delegates DB operations to IncidentsFacadeDriver (L6)\n- No direct sqlalchemy access",
            "methods": [
              "list_active_incidents",
              "list_resolved_incidents",
              "list_historical_incidents",
              "list_incidents",
              "get_incident_detail",
              "get_incidents_for_run",
              "get_metrics",
              "analyze_cost_impact",
              "get_historical_trend",
              "get_historical_distribution",
              "get_historical_cost_trend",
              "_snapshot_to_summary",
              "detect_patterns",
              "analyze_recurrence",
              "get_incident_learnings"
            ],
            "line": 377
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incidents_facade_driver",
            "names": [
              "IncidentsFacadeDriver",
              "IncidentSnapshot"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentsFacade",
          "get_incidents_facade",
          "IncidentSummaryResult",
          "PaginationResult",
          "IncidentListResult",
          "IncidentDetailResult",
          "IncidentsByRunResult",
          "PatternMatchResult",
          "PatternDetectionResult",
          "RecurrenceGroupResult",
          "RecurrenceAnalysisResult",
          "CostImpactSummaryResult",
          "CostImpactResult",
          "IncidentMetricsResult",
          "HistoricalTrendDataPointResult",
          "HistoricalTrendResult",
          "HistoricalDistributionEntryResult",
          "HistoricalDistributionResult",
          "CostTrendDataPointResult",
          "CostTrendResult",
          "LearningInsightResult",
          "ResolutionSummaryResult",
          "LearningsResult"
        ]
      },
      {
        "file_name": "incidents_types.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incidents_types.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 44,
        "module_docstring": "Incidents Domain Shared Types\n\nCanonical type aliases used across multiple engines in the incidents domain.\nThis file consolidates duplicated type definitions (INC-DUP-008).\n\nUsage:\n    from app.hoc.cus.incidents.L5_engines.incidents_types import (\n        UuidFn,\n        ClockFn,\n    )",
        "functions": [],
        "classes": [],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Callable"
            ],
            "is_relative": false,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": [
          "UuidFn",
          "ClockFn"
        ]
      },
      {
        "file_name": "policy_violation_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/policy_violation_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 725,
        "module_docstring": "Policy Violation Service - S3 Hardening for Phase A.5 Verification\n\nThis service implements the S3 truth model from PIN-195:\n1. Violation detection\n2. Violation fact persistence\n3. Incident creation (severity-bound)\n4. Evidence linking\n5. API + Console exposure\n\nCritical invariants (VERIFICATION_MODE):\n- No incident may exist without a persisted violation fact\n- Policy must be enabled for tenant\n- Evidence must exist before incident creation\n- One incident per (run_id, policy_id)\n- Cost and policy systems don't interfere\n\nSee PIN-195 for full acceptance criteria.",
        "functions": [
          {
            "name": "create_policy_evaluation_record",
            "signature": "(session: 'AsyncSession', run_id: str, tenant_id: str, outcome: str, policies_checked: int = 0, reason: str = '', draft_candidate: bool = False, is_synthetic: bool = False, synthetic_scenario_id: Optional[str] = None) -> str",
            "docstring": "Create a policy evaluation record for ANY run (PIN-407).\n\nEvery run MUST produce exactly one policy evaluation record.\nThis is NOT limited to violations - successful evaluations also get records.\n\nArgs:\n    session: Database session\n    run_id: Run ID\n    tenant_id: Tenant scope\n    outcome: Policy outcome (NO_VIOLATION, VIOLATION, ADVISORY, NOT_APPLICABLE)\n    policies_checked: Number of policies evaluated\n    reason: Human-readable reason\n    draft_candidate: If True, this run is a candidate for policy learning\n    is_synthetic: True if from SDSR scenario\n    synthetic_scenario_id: Scenario ID for traceability\n\nReturns:\n    policy_evaluation_id\n\nDECISION: Confidence calculation based on outcome (business rule).\nPERSISTENCE: Delegated to driver.",
            "is_async": true,
            "line": 471
          },
          {
            "name": "handle_policy_evaluation_for_run",
            "signature": "(session: 'AsyncSession', run_id: str, tenant_id: str, run_status: str, policies_checked: int = 0, is_synthetic: bool = False, synthetic_scenario_id: Optional[str] = None) -> str",
            "docstring": "Create a policy evaluation record for ANY run (PIN-407).\n\nThis is the NEW primary entry point for run \u2192 policy evaluation propagation.\nEvery run creates exactly one policy evaluation record with explicit outcome.\n\nArgs:\n    session: Database session\n    run_id: Run ID\n    tenant_id: Tenant scope\n    run_status: Run status (succeeded, failed, etc.)\n    policies_checked: Number of policies evaluated\n    is_synthetic: True if from SDSR scenario\n    synthetic_scenario_id: Scenario ID for traceability\n\nReturns:\n    policy_evaluation_id",
            "is_async": true,
            "line": 538
          },
          {
            "name": "handle_policy_violation",
            "signature": "(session: 'AsyncSession', run_id: str, tenant_id: str, policy_type: str, policy_id: str, violated_rule: str, reason: str, severity: str = 'medium', evidence: Optional[Dict[str, Any]] = None) -> Optional[ViolationIncident]",
            "docstring": "Handle a policy violation with S3 truth guarantees.\n\nThis is the main entry point for policy violation handling.\nCall this from workers.py when a policy violation is detected.\n\nReturns ViolationIncident if incident was created, None if skipped.",
            "is_async": true,
            "line": 595
          },
          {
            "name": "create_policy_evaluation_sync",
            "signature": "(run_id: str, tenant_id: str, run_status: str, policies_checked: int = 0, is_synthetic: bool = False, synthetic_scenario_id: Optional[str] = None) -> Optional[str]",
            "docstring": "Create a policy evaluation record for ANY run (PIN-407) - SYNC VERSION.\n\nThis is a synchronous wrapper for use in worker contexts where we don't\nhave an async session. Uses psycopg2 with L6 driver.\n\nArgs:\n    run_id: Run ID\n    tenant_id: Tenant scope\n    run_status: Run status (succeeded, failed, etc.)\n    policies_checked: Number of policies evaluated\n    is_synthetic: True if from SDSR scenario\n    synthetic_scenario_id: Scenario ID for traceability\n    conn: Pre-created psycopg2 connection from L4 handler.\n        L4 owns the connection lifecycle and commit. Required.\n\nReturns:\n    policy_evaluation_id if created, None if failed\n\nDECISION: Map run status to policy outcome (business rule).\nPERSISTENCE: Delegated to L6 driver. Transaction owned by L4 when conn provided.",
            "is_async": false,
            "line": 637
          }
        ],
        "classes": [
          {
            "name": "ViolationFact",
            "docstring": "Authoritative violation fact - must be persisted before incident creation.\n\nThis is the \"fact\" that PIN-195 AC-1 requires:\n- Linked to run_id\n- Linked to tenant_id\n- Linked to policy_id\n- Contains violated_rule\n- Contains evaluated_value\n- Contains threshold/condition\n- Contains timestamp",
            "methods": [],
            "line": 84
          },
          {
            "name": "ViolationIncident",
            "docstring": "Result of creating an incident from a violation.",
            "methods": [],
            "line": 114
          },
          {
            "name": "PolicyViolationService",
            "docstring": "Service for handling policy violations with S3 truth guarantees.\n\nUsage:\n    service = PolicyViolationService(session)\n\n    # Create violation fact first\n    violation = ViolationFact(\n        run_id=\"...\",\n        tenant_id=\"...\",\n        policy_id=\"content_accuracy_v1\",\n        violated_rule=\"CA001\",\n        ...\n\nNote: All DB operations are delegated to PolicyViolationDriver (L6).\nThis engine contains only business logic decisions.\n    )\n\n    # Persist and create incident\n    result = await service.persist_violation_and_create_incident(violation)",
            "methods": [
              "__init__",
              "persist_violation_fact",
              "check_violation_persisted",
              "check_policy_enabled",
              "persist_evidence",
              "check_incident_exists",
              "create_incident_from_violation",
              "persist_violation_and_create_incident",
              "verify_violation_truth"
            ],
            "line": 123
          },
          {
            "name": "PolicyEvaluationResult",
            "docstring": "Result of policy evaluation (PIN-407: Success as First-Class Data).\n\nEvery run MUST produce exactly one policy evaluation record.\nThis is NOT limited to violations - successful evaluations also get records.",
            "methods": [],
            "line": 453
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.policy_violation_driver",
            "names": [
              "PolicyViolationDriver",
              "get_policy_violation_driver"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.utils.runtime",
            "names": [
              "generate_uuid"
            ],
            "is_relative": false,
            "line": 75
          }
        ],
        "constants": [
          {
            "name": "VERIFICATION_MODE",
            "line": 80
          },
          {
            "name": "POLICY_OUTCOME_NO_VIOLATION",
            "line": 446
          },
          {
            "name": "POLICY_OUTCOME_VIOLATION",
            "line": 447
          },
          {
            "name": "POLICY_OUTCOME_ADVISORY",
            "line": 448
          },
          {
            "name": "POLICY_OUTCOME_NOT_APPLICABLE",
            "line": 449
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "postmortem.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/postmortem.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 466,
        "module_docstring": "Post-Mortem Engine - L4 Domain Logic\n\nExtracts learnings from resolved incidents:\n- Resolution summaries\n- Impact analysis\n- Prevention recommendations\n- Pattern correlations\n\nArchitecture:\n- All DB operations delegated to PostMortemDriver (L6)\n- Engine contains only insight generation logic\n- Read-only (no writes)\n\nDesign Rules:\n- Aggregation and analysis only\n- No cross-service calls",
        "functions": [],
        "classes": [
          {
            "name": "ResolutionSummary",
            "docstring": "Summary of how an incident was resolved.",
            "methods": [],
            "line": 73
          },
          {
            "name": "LearningInsight",
            "docstring": "A learning extracted from incident analysis.",
            "methods": [],
            "line": 86
          },
          {
            "name": "PostMortemResult",
            "docstring": "Result of post-mortem analysis for an incident.",
            "methods": [],
            "line": 95
          },
          {
            "name": "CategoryLearnings",
            "docstring": "Aggregated learnings for a category.",
            "methods": [],
            "line": 105
          },
          {
            "name": "PostMortemService",
            "docstring": "Extract learnings and post-mortem insights from incidents.\n\nRESPONSIBILITIES:\n- Generate resolution summaries\n- Find similar past incidents\n- Extract actionable insights\n- Aggregate category-level learnings\n\nFORBIDDEN:\n- Write to any table\n- Call other services\n- Modify incident data\n\nNote: All DB operations are delegated to PostMortemDriver (L6).\nThis engine contains only insight generation logic.",
            "methods": [
              "__init__",
              "get_incident_learnings",
              "get_category_learnings",
              "_get_resolution_summary",
              "_find_similar_incidents",
              "_extract_insights",
              "_generate_category_insights"
            ],
            "line": 116
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.postmortem_driver",
            "names": [
              "PostMortemDriver",
              "get_postmortem_driver"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "recovery_rule_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/recovery_rule_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 802,
        "module_docstring": "Rule-based evaluation engine for recovery suggestions.\n\nEvaluates a set of rules against failure context and returns\nscored action recommendations.\n\nRules can be:\n1. Error code matching (exact or prefix)\n2. Historical pattern matching\n3. Skill-specific rules\n4. Tenant-specific overrides\n5. Time-based rules (e.g., different behavior during incidents)\n\nEnvironment Variables:\n- RECOVERY_RULE_DEBUG: Enable debug logging for rule evaluation",
        "functions": [
          {
            "name": "combine_confidences",
            "signature": "(rule_confidence: float, match_confidence: float) -> float",
            "docstring": "Combine rule and matcher confidence scores.\n\nThis is an L4 domain decision. L5 workers must NOT implement their own formulas.\n\nArgs:\n    rule_confidence: Confidence from rule evaluation (0.0 to 1.0)\n    match_confidence: Confidence from pattern matching (0.0 to 1.0)\n\nReturns:\n    Combined confidence score (0.0 to 1.0)\n\nReference: PIN-257 Phase E-4 Extraction #3",
            "is_async": false,
            "line": 613
          },
          {
            "name": "should_select_action",
            "signature": "(combined_confidence: float) -> bool",
            "docstring": "Determine if an action should be selected based on combined confidence.\n\nThis is an L4 domain decision. L5 workers must NOT hardcode thresholds.\n\nArgs:\n    combined_confidence: Combined confidence score (0.0 to 1.0)\n\nReturns:\n    True if confidence meets threshold for action selection\n\nReference: PIN-257 Phase E-4 Extraction #3",
            "is_async": false,
            "line": 631
          },
          {
            "name": "should_auto_execute",
            "signature": "(confidence: float) -> bool",
            "docstring": "Determine if a recovery action should be auto-executed based on confidence.\n\nThis is an L4 domain decision. L5 workers must NOT hardcode thresholds.\n\nArgs:\n    confidence: Combined confidence score (0.0 to 1.0)\n\nReturns:\n    True if confidence meets threshold for auto-execution",
            "is_async": false,
            "line": 648
          },
          {
            "name": "classify_error_category",
            "signature": "(error_codes: List[str]) -> str",
            "docstring": "Classify error codes into a category.\n\nThis is an L4 domain decision. L5 workers must NOT implement their own heuristics.\n\nArgs:\n    error_codes: List of error codes to classify\n\nReturns:\n    Category string (TRANSIENT, PERMISSION, RESOURCE, VALIDATION, INFRASTRUCTURE, PLANNER, PERMANENT)",
            "is_async": false,
            "line": 675
          },
          {
            "name": "suggest_recovery_mode",
            "signature": "(error_codes: List[str]) -> str",
            "docstring": "Suggest a recovery mode based on error codes.\n\nThis is an L4 domain decision. L5 workers must NOT implement their own heuristics.\n\nArgs:\n    error_codes: List of error codes to analyze\n\nReturns:\n    Recovery mode string (RETRY_EXPONENTIAL, RETRY_WITH_JITTER, ESCALATE, ABORT)",
            "is_async": false,
            "line": 706
          },
          {
            "name": "evaluate_rules",
            "signature": "(error_code: str, error_message: str, skill_id: Optional[str] = None, tenant_id: Optional[str] = None, occurrence_count: int = 1, historical_matches: Optional[List[Dict[str, Any]]] = None, custom_rules: Optional[List[Rule]] = None) -> EvaluationResult",
            "docstring": "Convenience function to evaluate rules against a failure.\n\nArgs:\n    error_code: The error code (e.g., \"TIMEOUT\", \"HTTP_503\")\n    error_message: The raw error message\n    skill_id: Optional skill ID\n    tenant_id: Optional tenant ID\n    occurrence_count: How many times this failure has occurred\n    historical_matches: Historical similar failures\n    custom_rules: Custom rules to add to evaluation\n\nReturns:\n    EvaluationResult with recommendation",
            "is_async": false,
            "line": 732
          }
        ],
        "classes": [
          {
            "name": "RuleContext",
            "docstring": "Context provided to rules for evaluation.",
            "methods": [
              "to_dict"
            ],
            "line": 56
          },
          {
            "name": "RuleResult",
            "docstring": "Result from evaluating a single rule.",
            "methods": [
              "to_dict"
            ],
            "line": 83
          },
          {
            "name": "EvaluationResult",
            "docstring": "Complete result from rule evaluation.",
            "methods": [
              "to_dict"
            ],
            "line": 109
          },
          {
            "name": "Rule",
            "docstring": "Base class for recovery rules.",
            "methods": [
              "__init__",
              "evaluate",
              "__repr__"
            ],
            "line": 135
          },
          {
            "name": "ErrorCodeRule",
            "docstring": "Match based on error code patterns.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 158
          },
          {
            "name": "HistoricalPatternRule",
            "docstring": "Match based on historical success patterns.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 193
          },
          {
            "name": "SkillSpecificRule",
            "docstring": "Rules specific to certain skills.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 267
          },
          {
            "name": "OccurrenceThresholdRule",
            "docstring": "Escalate based on occurrence count.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 297
          },
          {
            "name": "CompositeRule",
            "docstring": "Combine multiple rules with AND/OR logic.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 331
          },
          {
            "name": "RecoveryRuleEngine",
            "docstring": "Evaluates rules against failure context to recommend recovery actions.\n\nUsage:\n    engine = RecoveryRuleEngine()\n    result = engine.evaluate(context)\n    print(result.recommended_action)",
            "methods": [
              "__init__",
              "add_rule",
              "remove_rule",
              "evaluate"
            ],
            "line": 473
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [
          {
            "name": "DEBUG_MODE",
            "line": 47
          }
        ],
        "all_exports": [
          "Rule",
          "RuleContext",
          "RuleResult",
          "EvaluationResult",
          "ErrorCodeRule",
          "HistoricalPatternRule",
          "SkillSpecificRule",
          "OccurrenceThresholdRule",
          "CompositeRule",
          "RecoveryRuleEngine",
          "evaluate_rules",
          "DEFAULT_RULES",
          "AUTO_EXECUTE_CONFIDENCE_THRESHOLD",
          "should_auto_execute",
          "ERROR_CATEGORY_RULES",
          "classify_error_category",
          "RECOVERY_MODE_RULES",
          "suggest_recovery_mode",
          "ACTION_SELECTION_THRESHOLD",
          "combine_confidences",
          "should_select_action"
        ]
      },
      {
        "file_name": "recurrence_analysis.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/recurrence_analysis.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 191,
        "module_docstring": "Recurrence Analysis Service (L4 Engine)\n\nAnswers \"how often does this type repeat?\":\n- Group by (category, resolution_method)\n- Count occurrences over time window\n- Calculate recurrence rate\n\nDesign Rules:\n- Statistical analysis only\n- Read-only (no writes)\n- No cross-service calls\n- Delegates to L6 driver for DB access",
        "functions": [],
        "classes": [
          {
            "name": "RecurrenceGroup",
            "docstring": "A group of recurring incidents.",
            "methods": [],
            "line": 58
          },
          {
            "name": "RecurrenceResult",
            "docstring": "Result of recurrence analysis.",
            "methods": [],
            "line": 71
          },
          {
            "name": "RecurrenceAnalysisService",
            "docstring": "Analyze recurring incident patterns.\n\nRESPONSIBILITIES (L4):\n- Validate input parameters (threshold, baseline days)\n- Delegate to L6 driver for data access\n- Compose RecurrenceResult from driver snapshots\n- Calculate aggregates (total_recurring)\n\nFORBIDDEN:\n- Write to any table\n- Call other services\n- Import sqlalchemy at runtime",
            "methods": [
              "__init__",
              "analyze_recurrence",
              "get_recurrence_for_category",
              "_snapshot_to_group"
            ],
            "line": 79
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.recurrence_analysis_driver",
            "names": [
              "RecurrenceAnalysisDriver",
              "RecurrenceGroupSnapshot"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "semantic_failures.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/semantic_failures.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 298,
        "module_docstring": "Semantic Failures \u2014 Canonical failure taxonomy for two-phase validation.\n\nTwo Phases:\n- Phase A: Intent Guardrails (INT-*) \u2014 design-time, human-facing\n- Phase B: Semantic Reality (SEM-*) \u2014 proof-time, system-facing\n\nEach failure code has:\n- Name: Human-readable name\n- Class: INTENT_VIOLATION or SEMANTIC_VIOLATION\n- Severity: BLOCKING or WARNING\n- Fix Owner: Who is responsible for fixing\n- Fix Action: What action to take\n\nThis taxonomy ensures violations are actionable, not just noise.",
        "functions": [
          {
            "name": "get_failure_info",
            "signature": "(code: FailureCode) -> Dict[str, Any]",
            "docstring": "Get failure taxonomy info for a code (INT-* or SEM-*).",
            "is_async": false,
            "line": 267
          },
          {
            "name": "get_fix_owner",
            "signature": "(code: FailureCode) -> str",
            "docstring": "Get the fix owner for a failure code.",
            "is_async": false,
            "line": 280
          },
          {
            "name": "get_fix_action",
            "signature": "(code: FailureCode) -> str",
            "docstring": "Get the fix action for a failure code.",
            "is_async": false,
            "line": 285
          },
          {
            "name": "get_violation_class",
            "signature": "(code: FailureCode) -> ViolationClass",
            "docstring": "Get the violation class for a failure code.",
            "is_async": false,
            "line": 290
          },
          {
            "name": "format_violation_message",
            "signature": "(code: FailureCode, context_msg: str) -> str",
            "docstring": "Format a violation message with context.",
            "is_async": false,
            "line": 295
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Union"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "semantic_types",
            "names": [
              "FailureCode",
              "IntentFailureCode",
              "SemanticFailureCode",
              "SemanticSeverity",
              "ViolationClass"
            ],
            "is_relative": true,
            "line": 43
          }
        ],
        "constants": [
          {
            "name": "SEMANTIC_FAILURE_TAXONOMY",
            "line": 257
          },
          {
            "name": "INTENT_FAILURE_TAXONOMY",
            "line": 262
          }
        ],
        "all_exports": null
      }
    ],
    "l5_schemas": [
      {
        "file_name": "export_schemas.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_schemas/export_schemas.py",
        "layer": "L5_schemas",
        "domain": "incidents",
        "lines": 52,
        "module_docstring": "Export Schemas (PIN-511 Phase 2.1)\n\nDefines the ExportBundleProtocol that export_engine.py (L5) depends on.\nL6 export_bundle_driver implements this Protocol.",
        "functions": [],
        "classes": [
          {
            "name": "ExportBundleProtocol",
            "docstring": "Protocol for export bundle operations.\n\nImplemented by: ExportBundleDriver (L6)\nConsumed by: ExportEngine (L5 engine)",
            "methods": [
              "create_evidence_bundle",
              "create_soc2_bundle",
              "create_executive_debrief"
            ],
            "line": 20
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 14
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 16
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incident_decision_port.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_schemas/incident_decision_port.py",
        "layer": "L5_schemas",
        "domain": "incidents",
        "lines": 75,
        "module_docstring": "Incident Decision Port (PIN-511 Option B)\n\nProtocol that defines the decision surface of IncidentEngine (L5).\nL6 incident_driver depends ONLY on this contract, never on the engine directly.\n\nDependency direction:\n    L6 (incident_driver) \u2192 Protocol (this file) \u2190 L5 (incident_engine implements)\n    L4 (coordinator/bridge) wires them together.\n\nThis makes the L6\u2192L5 import violation unrepresentable by construction.",
        "functions": [],
        "classes": [
          {
            "name": "IncidentDecisionPort",
            "docstring": "Behavioral contract for incident domain decisions.\n\nImplemented by: IncidentEngine (L5)\nConsumed by: IncidentDriver (L6)\nWired by: L4 (incidents bridge / coordinator)",
            "methods": [
              "check_and_create_incident",
              "create_incident_for_run",
              "get_incidents_for_run"
            ],
            "line": 26
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 22
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "severity_policy.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_schemas/severity_policy.py",
        "layer": "L5_schemas",
        "domain": "incidents",
        "lines": 203,
        "module_docstring": "Incident Severity Policy (L5 Schema)\n\nPure stateless severity decision logic for incidents.\nExtracted from incidents/L5_engines/incident_severity_engine.py (PIN-507 Law 1)\nso L6 drivers can import policy without reaching up to L5 engines.\n\nThis is POLICY (pure decision logic), not types (contracts).\nIt lives in L5_schemas/ under the *_policy.py naming convention\nper PIN-507 Law 6 domain-level convention.",
        "functions": [
          {
            "name": "generate_incident_title",
            "signature": "(trigger_type: str, trigger_value: str) -> str",
            "docstring": "Generate human-readable incident title.\n\nThis is presentation logic but lives here because it's domain-specific.\n\nArgs:\n    trigger_type: Type of incident trigger\n    trigger_value: Value/details of the trigger\n\nReturns:\n    Human-readable title string",
            "is_async": false,
            "line": 173
          }
        ],
        "classes": [
          {
            "name": "SeverityConfig",
            "docstring": "Configuration for severity decisions.",
            "methods": [
              "default"
            ],
            "line": 33
          },
          {
            "name": "IncidentSeverityEngine",
            "docstring": "Severity decision engine for incidents.\n\nRESPONSIBILITIES:\n- Calculate initial severity from trigger type\n- Calculate severity from affected calls count\n- Determine if severity should escalate\n\nFORBIDDEN:\n- Database access\n- I/O operations\n- State mutation (stateless calculations only)",
            "methods": [
              "__init__",
              "get_initial_severity",
              "calculate_severity_for_calls",
              "should_escalate"
            ],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "Tuple"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.domain_enums",
            "names": [
              "IncidentSeverity"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_SEVERITY",
            "line": 68
          }
        ],
        "all_exports": [
          "IncidentSeverityEngine",
          "SeverityConfig",
          "TRIGGER_SEVERITY_MAP",
          "DEFAULT_SEVERITY",
          "generate_incident_title"
        ]
      }
    ],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "cost_guard_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/cost_guard_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 485,
        "module_docstring": "Cost Guard Driver (L6)\n\nPure data access layer for cost guard read operations.\nNo business logic - only query construction and data retrieval.\n\nArchitecture:\n    L2 (cost_guard.py) -> L4 (incidents_handler) -> L6 (this driver) -> Database\n\nOperations:\n- Spend totals (today, mtd, week)\n- Budget limits\n- Baselines for trend calculation\n- Snapshot timestamps\n- Breakdown by feature/model/user\n- Cost anomalies\n\nReference: Extracted from cost_guard.py",
        "functions": [
          {
            "name": "get_cost_guard_driver",
            "signature": "(session: Session) -> CostGuardDriver",
            "docstring": "Factory function to get CostGuardDriver instance.",
            "is_async": false,
            "line": 473
          }
        ],
        "classes": [
          {
            "name": "SpendTotals",
            "docstring": "Spend totals for different periods.",
            "methods": [],
            "line": 57
          },
          {
            "name": "BudgetLimits",
            "docstring": "Budget configuration for a tenant.",
            "methods": [],
            "line": 66
          },
          {
            "name": "BreakdownRow",
            "docstring": "A row in a cost breakdown.",
            "methods": [],
            "line": 74
          },
          {
            "name": "AnomalyRow",
            "docstring": "A cost anomaly record.",
            "methods": [],
            "line": 84
          },
          {
            "name": "CostGuardDriver",
            "docstring": "L6 driver for cost guard read operations.\n\nPure data access - no business logic.\nAll methods require tenant_id for isolation.",
            "methods": [
              "__init__",
              "get_spend_totals",
              "get_budget",
              "get_baseline",
              "get_last_snapshot",
              "get_total_spend",
              "get_baselines",
              "get_spend_by_feature",
              "get_spend_by_model",
              "get_spend_by_user",
              "get_cost_anomalies"
            ],
            "line": 101
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": [
          "CostGuardDriver",
          "get_cost_guard_driver",
          "SpendTotals",
          "BudgetLimits",
          "BreakdownRow",
          "AnomalyRow"
        ]
      },
      {
        "file_name": "export_bundle_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/export_bundle_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 434,
        "module_docstring": "Export Bundle Service\n\nGenerates structured export bundles from incidents, runs, and traces\nfor evidence export, SOC2 compliance, and executive debriefs.\n\nKey Responsibilities:\n1. Load incident, run, and trace data\n2. Assemble EvidenceBundle with all cross-domain links\n3. Enhance for SOC2 compliance (control mappings)\n4. Generate executive summary (non-technical)",
        "functions": [
          {
            "name": "get_export_bundle_driver",
            "signature": "() -> ExportBundleDriver",
            "docstring": "Get or create ExportBundleDriver singleton.",
            "is_async": false,
            "line": 425
          }
        ],
        "classes": [
          {
            "name": "TraceStorePort",
            "docstring": null,
            "methods": [
              "get_trace_summary",
              "get_trace_steps"
            ],
            "line": 61
          },
          {
            "name": "ExportBundleDriver",
            "docstring": "Generate structured export bundles from incidents/traces.",
            "methods": [
              "__init__",
              "trace_store",
              "create_evidence_bundle",
              "create_soc2_bundle",
              "create_executive_debrief",
              "_compute_bundle_hash",
              "_generate_attestation",
              "_assess_risk_level",
              "_generate_incident_summary",
              "_assess_business_impact",
              "_generate_recommendations"
            ],
            "line": 69
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.db",
            "names": [
              "Run",
              "engine"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.models.export_bundles",
            "names": [
              "DEFAULT_SOC2_CONTROLS",
              "EvidenceBundle",
              "ExecutiveDebriefBundle",
              "PolicyContext",
              "SOC2Bundle",
              "TraceStepEvidence"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incident_aggregator.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_aggregator.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 614,
        "module_docstring": "Incident Aggregation Driver - Prevents Incident Explosion Under Load\n\nThis service implements intelligent incident grouping to prevent thousands of\nmicro-incidents during large outages. It uses a sliding window approach with\nconfigurable thresholds.\n\nKey Features:\n1. Time-window aggregation (default 5 minutes)\n2. Tenant + trigger_type grouping key\n3. Rate limiting (max 1 incident per key per window)\n4. Auto-escalation for high-volume windows\n5. Incident merging for related failures\n\nWatchpoint #1: Incident Explosion Under Load\n- During a 1000-request outage, we create 1 incident, not 1000\n- Related calls are added to the incident's related_call_ids\n- Severity auto-escalates based on affected call count\n\nARCHITECTURE RULE (LESSONS_ENFORCED.md Invariant #10):\n- This service MUST be constructed with explicit dependency injection\n- NO lazy service resolution (get_incident_aggregator is BANNED)\n- All collaborators (clock, uuid_fn) MUST be passed via constructor\n- Verification scripts and production MUST use the same constructor pattern",
        "functions": [
          {
            "name": "create_incident_aggregator",
            "signature": "(config: Optional[IncidentAggregatorConfig] = None) -> IncidentAggregator",
            "docstring": "Create an IncidentAggregator with canonical dependencies.\n\nThis is the ONLY sanctioned way to create an aggregator.\nUses generate_uuid and utc_now from app.utils.runtime.\n\nUsage:\n    aggregator = create_incident_aggregator()\n    # or with custom config:\n    aggregator = create_incident_aggregator(config=IncidentAggregatorConfig(...))",
            "is_async": false,
            "line": 596
          }
        ],
        "classes": [
          {
            "name": "IncidentAggregatorConfig",
            "docstring": "Configuration for incident aggregation behavior (L6 persistence config only).",
            "methods": [],
            "line": 80
          },
          {
            "name": "IncidentKey",
            "docstring": "Grouping key for incident aggregation.\n\nIncidents are grouped by:\n- tenant_id: Isolation between tenants\n- trigger_type: Type of failure (failure_spike, budget_breach, rate_limit)\n- window_start: 5-minute bucketed window",
            "methods": [
              "__hash__",
              "__eq__",
              "from_event"
            ],
            "line": 105
          },
          {
            "name": "IncidentAggregator",
            "docstring": "L6 Driver for intelligent incident aggregation.\n\nPrevents incident explosion by:\n1. Grouping related failures into single incidents\n2. Rate limiting incident creation per tenant\n3. Auto-escalating severity based on impact (delegated to L4 engine)\n4. Merging calls into existing open incidents\n\nINVARIANT #10: Explicit Dependency Injection Required\n- clock: Function that returns current UTC datetime\n- uuid_fn: Function that generates UUID strings\n- severity_engine: L4 engine for severity decisions (optional, defaults to standard)\n- These MUST be passed explicitly, not resolved lazily\n\nEXTRACTION NOTE (2026-01-24):\nSeverity logic extracted to incident_severity_engine.py (L4).\nThis driver delegates severity decisions to the engine.",
            "methods": [
              "__init__",
              "get_or_create_incident",
              "_find_open_incident",
              "_can_create_incident",
              "_get_rate_limit_incident",
              "_create_incident",
              "_add_call_to_incident",
              "_add_incident_event",
              "resolve_stale_incidents",
              "get_incident_stats"
            ],
            "line": 147
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "Optional",
              "Tuple",
              "cast"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "and_",
              "select"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.incidents.L5_schemas.severity_policy",
            "names": [
              "IncidentSeverityEngine",
              "SeverityConfig",
              "generate_incident_title"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentEvent",
              "IncidentSeverity",
              "IncidentStatus"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.utils.runtime",
            "names": [
              "generate_uuid",
              "utc_now"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incident_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 250,
        "module_docstring": "Incident Domain Driver (INTERNAL)\n\nThis driver provides the internal interface for incident operations.\nUsed by workers, governance services, and transaction coordinators.\n\nFor CUSTOMER API operations, use incidents_facade.py instead.\n\nPIN-511 Option B \u2014 Dependency Inversion:\n    Before: L6 driver \u2192 imports L5 engine (Law 1 violation)\n    After:  L6 driver \u2192 imports L5_schemas Protocol (legal)\n            L5 engine \u2192 implements Protocol\n            L4 \u2192 wires them together\n\nUsage:\n    from app.hoc.cus.incidents.L6_drivers.incident_driver import IncidentDriver\n\n    # L4 wiring (coordinator/bridge):\n    engine = IncidentEngine(db_url=...)\n    driver = IncidentDriver(decision_port=engine)\n\n    # Or use the singleton (wired lazily via L4):\n    driver = get_incident_driver()\n    incident_id = driver.create_incident_for_run(...)",
        "functions": [],
        "classes": [
          {
            "name": "IncidentDriver",
            "docstring": "Driver for Incident domain operations (INTERNAL).\n\nThis is the entry point for internal code (workers, governance)\nto interact with incident services.\n\nCUSTOMER-facing code should use incidents_facade.py instead.\n\nPIN-511 Option B: Accepts IncidentDecisionPort (Protocol) \u2014 never\nimports L5_engines directly. L4 wires the engine at construction time.",
            "methods": [
              "__init__",
              "check_and_create_incident",
              "create_incident_for_run",
              "_emit_ack",
              "get_incidents_for_run"
            ],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.incidents.L5_schemas.incident_decision_port",
            "names": [
              "IncidentDecisionPort"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [
          {
            "name": "RAC_ENABLED",
            "line": 63
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "incident_pattern_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_pattern_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 255,
        "module_docstring": "Incident Pattern Driver (L6)\n\nPure database operations for incident pattern detection.\nAll business logic stays in L4 engine.\n\nOperations:\n- Incident count queries\n- Category cluster aggregation\n- Severity spike detection\n- Cascade failure grouping\n\nNO business logic:\n- NO confidence calculation (L4)\n- NO threshold decisions (L4)\n- NO pattern type determination (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_pattern_driver",
            "signature": "(session: AsyncSession) -> IncidentPatternDriver",
            "docstring": "Factory function to get IncidentPatternDriver instance.",
            "is_async": false,
            "line": 247
          }
        ],
        "classes": [
          {
            "name": "IncidentPatternDriver",
            "docstring": "L6 driver for incident pattern detection operations (async).\n\nPure database access - no business logic.\nAll operations are READ-ONLY.",
            "methods": [
              "__init__",
              "fetch_incidents_count",
              "fetch_category_clusters",
              "fetch_severity_spikes",
              "fetch_cascade_failures"
            ],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 68
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentPatternDriver",
          "get_incident_pattern_driver"
        ]
      },
      {
        "file_name": "incident_read_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_read_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 212,
        "module_docstring": "Incident Read Driver (L6)\n\nPure data access layer for incident read operations.\nNo business logic - only query construction and data retrieval.\n\nArchitecture:\n    L3 (Adapter) \u2192 L4 (Engine) \u2192 L6 (this driver) \u2192 Database\n\nOperations:\n- Query incidents with tenant isolation\n- Query incident events\n- Count queries\n- No mutations (read-only)\n\nReference: PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_read_driver",
            "signature": "(session: Session) -> IncidentReadDriver",
            "docstring": "Factory function to get IncidentReadDriver instance.",
            "is_async": false,
            "line": 201
          }
        ],
        "classes": [
          {
            "name": "IncidentReadDriver",
            "docstring": "L6 driver for incident read operations.\n\nPure data access - no business logic.\nAll methods require tenant_id for isolation.",
            "methods": [
              "__init__",
              "list_incidents",
              "get_incident",
              "get_incident_events",
              "count_incidents_since",
              "get_last_incident"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentEvent"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentReadDriver",
          "get_incident_read_driver"
        ]
      },
      {
        "file_name": "incident_write_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_write_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 611,
        "module_docstring": "Incident Write Driver (L6)\n\nPure database write operations for incidents.\nAll business logic stays in L4 engine.\n\nOperations:\n- Create incidents from run failures/successes\n- Create prevention records (policy suppression)\n- Create policy proposals\n- Update incident state (acknowledge, resolve)\n- Update related tables (runs.incident_count, aos_traces.incident_id)\n- Create incident events (timeline)\n\nNO business logic:\n- NO severity/category mapping (L4)\n- NO policy suppression decisions (L4)\n- NO proposal creation decisions (L4)\n\nReference: PIN-281, PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_write_driver",
            "signature": "(session: Session) -> IncidentWriteDriver",
            "docstring": "Factory function to get IncidentWriteDriver instance.",
            "is_async": false,
            "line": 600
          }
        ],
        "classes": [
          {
            "name": "IncidentWriteDriver",
            "docstring": "L6 driver for incident write operations.\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "update_incident_acknowledged",
              "update_incident_resolved",
              "create_incident_event",
              "refresh_incident",
              "insert_incident",
              "update_run_incident_count",
              "update_trace_incident_id",
              "insert_prevention_record",
              "insert_policy_proposal",
              "fetch_suppressing_policy",
              "fetch_incidents_by_run_id",
              "insert_incident_from_anomaly"
            ],
            "line": 86
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 79
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 80
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentEvent",
              "IncidentStatus"
            ],
            "is_relative": false,
            "line": 83
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentWriteDriver",
          "get_incident_write_driver"
        ]
      },
      {
        "file_name": "incidents_facade_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incidents_facade_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 807,
        "module_docstring": "Incidents Facade Driver (L6)\n\nPure database access layer for the incidents facade.\nReturns snapshots (dicts/dataclasses), not ORM models.\n\nResponsibilities:\n- Execute queries against incidents table\n- Return data snapshots\n- NO business logic\n- NO result type composition (that's L4's job)\n\nThis driver was extracted from incidents_facade.py per HOC Layer Topology V1.",
        "functions": [],
        "classes": [
          {
            "name": "IncidentSnapshot",
            "docstring": "Raw incident data snapshot from database.",
            "methods": [],
            "line": 53
          },
          {
            "name": "IncidentListSnapshot",
            "docstring": "Paginated list of incident snapshots.",
            "methods": [],
            "line": 77
          },
          {
            "name": "MetricsSnapshot",
            "docstring": "Raw metrics aggregates from database.",
            "methods": [],
            "line": 85
          },
          {
            "name": "CostImpactRowSnapshot",
            "docstring": "Single row from cost impact query.",
            "methods": [],
            "line": 105
          },
          {
            "name": "HistoricalTrendRowSnapshot",
            "docstring": "Single row from historical trend query.",
            "methods": [],
            "line": 116
          },
          {
            "name": "HistoricalDistributionRowSnapshot",
            "docstring": "Single row from distribution query.",
            "methods": [],
            "line": 126
          },
          {
            "name": "CostTrendRowSnapshot",
            "docstring": "Single row from cost trend query.",
            "methods": [],
            "line": 135
          },
          {
            "name": "IncidentsFacadeDriver",
            "docstring": "L6 Database driver for incidents facade.\n\nPure data access - no business logic.\nReturns snapshots, not ORM models.",
            "methods": [
              "__init__",
              "fetch_active_incidents",
              "fetch_resolved_incidents",
              "fetch_historical_incidents",
              "fetch_incident_by_id",
              "fetch_incidents_by_run",
              "fetch_metrics_aggregates",
              "fetch_cost_impact_data",
              "fetch_all_incidents",
              "fetch_historical_trend",
              "fetch_historical_distribution",
              "fetch_historical_cost_trend",
              "_to_snapshot"
            ],
            "line": 148
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select",
              "text"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentsFacadeDriver",
          "IncidentSnapshot",
          "IncidentListSnapshot",
          "MetricsSnapshot",
          "CostImpactRowSnapshot",
          "HistoricalTrendRowSnapshot",
          "HistoricalDistributionRowSnapshot",
          "CostTrendRowSnapshot"
        ]
      },
      {
        "file_name": "lessons_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/lessons_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 649,
        "module_docstring": "Lessons Driver (L6)\n\nPure database operations for lessons_learned table.\nAll business logic stays in L4 engine.\n\nOperations:\n- Create lessons from various triggers\n- Query lessons with filters\n- Update lesson state (defer, dismiss, convert, reactivate)\n- Debounce checks\n- Scheduler support (expired deferred)\n\nNO business logic:\n- NO state machine validation (L4)\n- NO debounce decisions (L4)\n- NO severity mapping (L4)\n- NO description generation (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_lessons_driver",
            "signature": "(session: Session) -> LessonsDriver",
            "docstring": "Factory function to get LessonsDriver instance.",
            "is_async": false,
            "line": 641
          }
        ],
        "classes": [
          {
            "name": "LessonsDriver",
            "docstring": "L6 driver for lessons_learned operations.\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "insert_lesson",
              "fetch_lesson_by_id",
              "fetch_lessons_list",
              "fetch_lesson_stats",
              "update_lesson_deferred",
              "update_lesson_dismissed",
              "update_lesson_converted",
              "update_lesson_reactivated",
              "fetch_debounce_count",
              "fetch_expired_deferred",
              "insert_policy_proposal_from_lesson"
            ],
            "line": 83
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 79
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 80
          }
        ],
        "constants": [],
        "all_exports": [
          "LessonsDriver",
          "get_lessons_driver"
        ]
      },
      {
        "file_name": "llm_failure_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/llm_failure_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 331,
        "module_docstring": "LLM Failure Driver (L6)\n\nPure database operations for LLM failure handling.\nAll business logic stays in L4 engine.\n\nOperations:\n- Create failure facts\n- Create evidence records\n- Mark runs as failed\n- Contamination verification (read-only)\n\nNO business logic:\n- NO invariant checking (L4)\n- NO verification mode decisions (L4)\n- NO failure type validation (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_llm_failure_driver",
            "signature": "(session: AsyncSession) -> LLMFailureDriver",
            "docstring": "Factory function to get LLMFailureDriver instance.",
            "is_async": false,
            "line": 323
          }
        ],
        "classes": [
          {
            "name": "LLMFailureDriver",
            "docstring": "L6 driver for LLM failure operations (async).\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "insert_failure",
              "insert_evidence",
              "update_run_failed",
              "fetch_failure_by_run_id",
              "fetch_contamination_check"
            ],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 71
          }
        ],
        "constants": [],
        "all_exports": [
          "LLMFailureDriver",
          "get_llm_failure_driver"
        ]
      },
      {
        "file_name": "policy_violation_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/policy_violation_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 481,
        "module_docstring": "Policy Violation Driver (L6)\n\nPure database operations for policy violation handling.\nAll business logic stays in L4 engine.\n\nOperations:\n- Create violation facts\n- Check violation/policy existence\n- Create evidence events\n- Policy evaluation records (both async and sync patterns)\n\nNO business logic:\n- NO outcome mapping (L4)\n- NO verification mode decisions (L4)\n- NO validation decisions (L4)\n- NO severity mapping (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "insert_policy_evaluation_sync_with_cursor",
            "signature": "(cursor, evaluation_id: str, run_id: str, tenant_id: str, outcome: str, policies_checked: int, confidence: float, created_at: datetime, is_synthetic: bool, synthetic_scenario_id: Optional[str]) -> Optional[str]",
            "docstring": "Insert policy evaluation record using provided cursor.\n\nL6 Contract:\n    - Cursor REQUIRED (passed from L4 owner)\n    - L6 does NOT commit (L4 owns transaction boundary)\n\nArgs:\n    cursor: psycopg2 cursor from L4 owner\n    evaluation_id: Generated evaluation ID\n    run_id: Run being evaluated\n    tenant_id: Tenant scope\n    outcome: Policy outcome\n    policies_checked: Number of policies checked\n    confidence: Match confidence\n    created_at: Timestamp\n    is_synthetic: SDSR flag\n    synthetic_scenario_id: Scenario ID for SDSR\n\nReturns:\n    evaluation_id if inserted, None if conflict",
            "is_async": false,
            "line": 408
          },
          {
            "name": "get_policy_violation_driver",
            "signature": "(session: AsyncSession) -> PolicyViolationDriver",
            "docstring": "Factory function to get PolicyViolationDriver instance.",
            "is_async": false,
            "line": 472
          }
        ],
        "classes": [
          {
            "name": "PolicyViolationDriver",
            "docstring": "L6 driver for policy violation operations (async).\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "insert_violation_record",
              "fetch_violation_exists",
              "fetch_policy_enabled",
              "insert_evidence_event",
              "fetch_incident_by_violation",
              "fetch_violation_truth_check",
              "insert_policy_evaluation"
            ],
            "line": 82
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 73
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 77
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyViolationDriver",
          "get_policy_violation_driver",
          "insert_policy_evaluation_sync_with_cursor"
        ]
      },
      {
        "file_name": "postmortem_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/postmortem_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 316,
        "module_docstring": "Post-Mortem Driver (L6)\n\nPure database operations for post-mortem analytics.\nAll business logic stays in L4 engine.\n\nOperations:\n- Category statistics queries\n- Resolution method aggregation\n- Recurrence rate calculation\n- Similar incident lookup\n\nNO business logic:\n- NO insight generation (L4)\n- NO confidence calculation (L4)\n- NO pattern analysis (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_postmortem_driver",
            "signature": "(session: AsyncSession) -> PostMortemDriver",
            "docstring": "Factory function to get PostMortemDriver instance.",
            "is_async": false,
            "line": 308
          }
        ],
        "classes": [
          {
            "name": "PostMortemDriver",
            "docstring": "L6 driver for post-mortem analytics operations (async).\n\nPure database access - no business logic.\nAll operations are READ-ONLY.",
            "methods": [
              "__init__",
              "fetch_category_stats",
              "fetch_resolution_methods",
              "fetch_recurrence_data",
              "fetch_resolution_summary",
              "fetch_similar_incidents"
            ],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 68
          }
        ],
        "constants": [],
        "all_exports": [
          "PostMortemDriver",
          "get_postmortem_driver"
        ]
      },
      {
        "file_name": "recurrence_analysis_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/recurrence_analysis_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 213,
        "module_docstring": "Recurrence Analysis Driver (L6)\n\nPure database access layer for recurrence analysis.\nReturns snapshots (dicts/dataclasses), not ORM models.\n\nResponsibilities:\n- Execute queries against incidents table for recurrence patterns\n- Return data snapshots\n- NO business logic\n- NO threshold decisions (that's L4's job)\n\nThis driver was extracted from recurrence_analysis_service.py per HOC Layer Topology V1.",
        "functions": [],
        "classes": [
          {
            "name": "RecurrenceGroupSnapshot",
            "docstring": "Raw recurrence group data from database.",
            "methods": [],
            "line": 51
          },
          {
            "name": "RecurrenceAnalysisDriver",
            "docstring": "L6 Database driver for recurrence analysis.\n\nPure data access - no business logic.\nReturns snapshots, not computed analysis.",
            "methods": [
              "__init__",
              "fetch_recurrence_groups",
              "fetch_recurrence_for_category"
            ],
            "line": 69
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "RecurrenceAnalysisDriver",
          "RecurrenceGroupSnapshot"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 32,
    "violation_count": 0,
    "gap_count": 1
  },
  "policies": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/policies.py",
    "l2_apis": [
      {
        "file_name": "M25_integrations.py",
        "file_path": "backend/app/hoc/api/cus/policies/M25_integrations.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1384,
        "module_docstring": "M25 Integration API\n\nEndpoints for:\n- Loop status monitoring\n- Human checkpoint resolution\n- Integration statistics\n- Retry/revert operations\n- Graduation status (M25 learning proof)\n- Prevention timeline (Gate 3)",
        "functions": [
          {
            "name": "get_tenant_id_from_token",
            "signature": "(token: FounderToken = Depends(verify_fops_token)) -> str",
            "docstring": "Get tenant ID from founder token - PIN-318 secure implementation.",
            "is_async": false,
            "line": 55
          },
          {
            "name": "get_current_user_from_token",
            "signature": "(token: FounderToken = Depends(verify_fops_token)) -> dict",
            "docstring": "Get current user from founder token - PIN-318 secure implementation.",
            "is_async": false,
            "line": 61
          },
          {
            "name": "get_tenant_id",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID')) -> str",
            "docstring": "DEPRECATED: Get tenant ID from query parameter. Use get_tenant_id_from_token instead.",
            "is_async": false,
            "line": 67
          },
          {
            "name": "get_current_user",
            "signature": "(user_id: Optional[str] = Query(None, description='User ID')) -> Optional[dict]",
            "docstring": "DEPRECATED: Get current user from query parameter. Use get_current_user_from_token instead.",
            "is_async": false,
            "line": 72
          },
          {
            "name": "get_loop_status",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id)) -> LoopStatusResponse",
            "docstring": "Get current loop status for an incident.\n\nReturns the full loop state including:\n- Completed and failed stages\n- Pending human checkpoints\n- Narrative artifacts for storytelling",
            "is_async": true,
            "line": 188
          },
          {
            "name": "get_loop_stages",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id)) -> list[StageDetail]",
            "docstring": "Get detailed stage information for a loop.",
            "is_async": true,
            "line": 232
          },
          {
            "name": "stream_loop_status",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id))",
            "docstring": "SSE endpoint for live loop status updates.\n\nConnect to receive real-time updates as the loop progresses.",
            "is_async": true,
            "line": 269
          },
          {
            "name": "retry_loop_stage",
            "signature": "(incident_id: str, request: RetryStageRequest, tenant_id: str = Depends(get_tenant_id)) -> LoopStatusResponse",
            "docstring": "Retry a failed loop stage.",
            "is_async": true,
            "line": 316
          },
          {
            "name": "revert_loop",
            "signature": "(incident_id: str, request: RevertLoopRequest, tenant_id: str = Depends(get_tenant_id), user: dict = Depends(get_current_user)) -> dict",
            "docstring": "Revert all changes made by a loop.\n\nThis is the ultimate human override - use with caution.",
            "is_async": true,
            "line": 351
          },
          {
            "name": "list_pending_checkpoints",
            "signature": "(tenant_id: str = Depends(get_tenant_id)) -> list[CheckpointResponse]",
            "docstring": "List all pending human checkpoints for the tenant.",
            "is_async": true,
            "line": 386
          },
          {
            "name": "get_checkpoint",
            "signature": "(checkpoint_id: str, tenant_id: str = Depends(get_tenant_id)) -> CheckpointResponse",
            "docstring": "Get details of a specific checkpoint.",
            "is_async": true,
            "line": 416
          },
          {
            "name": "resolve_checkpoint",
            "signature": "(checkpoint_id: str, request: ResolveCheckpointRequest, tenant_id: str = Depends(get_tenant_id), user: dict = Depends(get_current_user)) -> dict",
            "docstring": "Resolve a pending checkpoint.\n\nAvailable resolutions depend on checkpoint type:\n- approve_policy: approve, reject, modify\n- approve_recovery: apply, reject, defer\n- simulate_routing: apply, cancel\n- revert_loop: confirm_revert, cancel",
            "is_async": true,
            "line": 459
          },
          {
            "name": "get_integration_stats",
            "signature": "(tenant_id: str = Depends(get_tenant_id), hours: int = Query(24, ge=1, le=720, description='Period in hours')) -> IntegrationStatsResponse",
            "docstring": "Get integration loop statistics for the specified period.",
            "is_async": true,
            "line": 500
          },
          {
            "name": "get_loop_narrative",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Get narrative artifacts for an incident loop.\n\nReturns storytelling elements:\n- before_after: Before vs After this incident\n- policy_origin: Policy born from this failure\n- agent_improvement: How agent behavior improved",
            "is_async": true,
            "line": 562
          },
          {
            "name": "get_graduation_status",
            "signature": "(tenant_id: str = Depends(get_tenant_id)) -> HardenedGraduationResponse",
            "docstring": "Get M25 graduation status (HARDENED).\n\nCRITICAL: This status is DERIVED from evidence, not manually set.\n\nReturns:\n- Derived graduation level (alpha/beta/candidate/complete/degraded)\n- Gate status with evidence\n- Capability gates (what's unlocked/blocked)\n- Simulation state (separate from real graduation)\n- Degradation info if status has regressed\n\nGraduation is computed from real evidence only:\n- Simulated records are excluded\n- Status is re-evaluated on each call\n- Degradation occurs when evidence regresses",
            "is_async": true,
            "line": 671
          },
          {
            "name": "simulate_prevention",
            "signature": "(request: SimulatePreventionRequest, tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Simulate a prevention event for demo/testing purposes.\n\nIMPORTANT: Simulated records are marked with is_simulated=true\nand DO NOT count toward real graduation.\n\nThis endpoint creates demo data for UI testing only.\nReal graduation requires real prevention evidence.",
            "is_async": true,
            "line": 848
          },
          {
            "name": "simulate_regret",
            "signature": "(request: SimulateRegretRequest, tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Simulate a regret event for demo/testing purposes.\n\nIMPORTANT: Simulated records are marked with is_simulated=true\nand DO NOT count toward real graduation.\n\nThis endpoint creates demo data for UI testing only.\nReal graduation requires real regret/demotion evidence.",
            "is_async": true,
            "line": 915
          },
          {
            "name": "simulate_timeline_view",
            "signature": "(incident_id: str = Query(..., description='Incident ID to mark as viewed in timeline'), tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Simulate viewing a prevention timeline for Gate 3.\n\nIMPORTANT: Simulated views are marked with is_simulated=true\nand DO NOT count toward real graduation.\n\nThis endpoint creates demo data for UI testing only.\nReal graduation requires real timeline views.",
            "is_async": true,
            "line": 972
          },
          {
            "name": "record_timeline_view",
            "signature": "(incident_id: str = Query(..., description='Incident ID viewed in timeline'), has_prevention: bool = Query(False, description='Timeline shows prevention event'), has_rollback: bool = Query(False, description='Timeline shows rollback event'), tenant_id: str = Depends(get_tenant_id), user: dict = Depends(get_current_user)) -> dict",
            "docstring": "Record a REAL timeline view for Gate 3 graduation.\n\nThis endpoint is called by the console when a user ACTUALLY views\nan incident's prevention timeline. This counts toward real graduation.\n\nCall this when:\n- User opens the prevention timeline UI\n- Timeline shows learning proof (prevention or rollback)",
            "is_async": true,
            "line": 1029
          },
          {
            "name": "trigger_graduation_re_evaluation",
            "signature": "(tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Trigger a re-evaluation of graduation status.\n\nThis recalculates graduation level from current evidence.\nUseful after:\n- New prevention/regret events\n- Timeline views recorded\n- Manual verification\n\nNote: Graduation is automatically re-evaluated on GET /graduation,\nbut this endpoint forces a fresh computation and stores history.",
            "is_async": true,
            "line": 1087
          },
          {
            "name": "get_prevention_timeline",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id)) -> PreventionTimelineResponse",
            "docstring": "Get the prevention timeline for an incident.\n\nThis is the Gate 3 UI - shows the learning loop in action:\n1. Original incident detected\n2. Pattern identified\n3. Policy born from failure\n4. (later) Similar incident detected\n5. Policy PREVENTED recurrence\n\nViewing this timeline with a prevention event proves Gate 3.",
            "is_async": true,
            "line": 1224
          }
        ],
        "classes": [
          {
            "name": "LoopStatusResponse",
            "docstring": "Response for loop status endpoint.",
            "methods": [],
            "line": 94
          },
          {
            "name": "StageDetail",
            "docstring": "Detail for a single stage.",
            "methods": [],
            "line": 112
          },
          {
            "name": "CheckpointResponse",
            "docstring": "Response for human checkpoint.",
            "methods": [],
            "line": 123
          },
          {
            "name": "ResolveCheckpointRequest",
            "docstring": "Request to resolve a checkpoint.",
            "methods": [],
            "line": 140
          },
          {
            "name": "IntegrationStatsResponse",
            "docstring": "Statistics for integration loop.",
            "methods": [],
            "line": 146
          },
          {
            "name": "RetryStageRequest",
            "docstring": "Request to retry a failed stage.",
            "methods": [],
            "line": 170
          },
          {
            "name": "RevertLoopRequest",
            "docstring": "Request to revert a loop.",
            "methods": [],
            "line": 176
          },
          {
            "name": "GateEvidenceResponse",
            "docstring": "Evidence for a graduation gate.",
            "methods": [],
            "line": 607
          },
          {
            "name": "CapabilityStatus",
            "docstring": "Status of a capability gate.",
            "methods": [],
            "line": 618
          },
          {
            "name": "SimulationStatus",
            "docstring": "Simulation mode status - separate from real graduation.",
            "methods": [],
            "line": 625
          },
          {
            "name": "HardenedGraduationResponse",
            "docstring": "Hardened graduation status response.\n\nKey differences from v1:\n- Status is DERIVED from evidence, not manually set\n- Includes capability gates (what's unlocked/blocked)\n- Includes simulation status (separate from real)\n- Includes degradation info",
            "methods": [],
            "line": 633
          },
          {
            "name": "SimulatePreventionRequest",
            "docstring": "Request to simulate a prevention event for demo/testing.",
            "methods": [],
            "line": 838
          },
          {
            "name": "SimulateRegretRequest",
            "docstring": "Request to simulate a regret event for demo/testing.",
            "methods": [],
            "line": 905
          },
          {
            "name": "TimelineEventResponse",
            "docstring": "A single event in the prevention timeline.",
            "methods": [],
            "line": 1201
          },
          {
            "name": "PreventionTimelineResponse",
            "docstring": "Response for prevention timeline endpoint.",
            "methods": [],
            "line": 1213
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "fastapi.responses",
            "names": [
              "StreamingResponse"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "FounderToken",
              "verify_fops_token"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_async_session_context",
              "get_operation_registry",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.integrations.events",
            "names": [
              "LoopStage"
            ],
            "is_relative": false,
            "line": 79
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "alerts.py",
        "file_path": "backend/app/hoc/api/cus/policies/alerts.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 446,
        "module_docstring": "Alerts API (L2)\n\nProvides alert operations:\n- POST /alerts/rules (create rule)\n- GET /alerts/rules (list rules)\n- GET /alerts/rules/{id} (get rule)\n- PUT /alerts/rules/{id} (update rule)\n- DELETE /alerts/rules/{id} (delete rule)\n- GET /alerts/history (alert history)\n- GET /alerts/history/{id} (get event)\n- POST /alerts/history/{id}/acknowledge (acknowledge)\n- POST /alerts/history/{id}/resolve (resolve)\n- POST /alerts/routes (create route)\n- GET /alerts/routes (list routes)\n- DELETE /alerts/routes/{id} (delete route)\n\nThis is the ONLY facade for alert operations.\nAll alert APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> AlertsFacade",
            "docstring": "Get the alerts facade.",
            "is_async": false,
            "line": 98
          },
          {
            "name": "create_rule",
            "signature": "(request: CreateRuleRequest, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.write')))",
            "docstring": "Create an alert rule (GAP-110).\n\n**Tier: REACT ($9)** - Alert configuration.\n\nCondition example:\n```json\n{\n    \"metric\": \"cost_daily\",\n    \"operator\": \"gt\",\n    \"threshold\": 1000\n}\n```",
            "is_async": true,
            "line": 109
          },
          {
            "name": "list_rules",
            "signature": "(severity: Optional[str] = Query(None, description='Filter by severity'), enabled_only: bool = Query(False, description='Only enabled rules'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "List alert rules.",
            "is_async": true,
            "line": 144
          },
          {
            "name": "get_rule",
            "signature": "(rule_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "Get a specific alert rule.",
            "is_async": true,
            "line": 173
          },
          {
            "name": "update_rule",
            "signature": "(rule_id: str, request: UpdateRuleRequest, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.write')))",
            "docstring": "Update an alert rule.",
            "is_async": true,
            "line": 194
          },
          {
            "name": "delete_rule",
            "signature": "(rule_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.write')))",
            "docstring": "Delete an alert rule.",
            "is_async": true,
            "line": 222
          },
          {
            "name": "list_history",
            "signature": "(rule_id: Optional[str] = Query(None, description='Filter by rule'), severity: Optional[str] = Query(None, description='Filter by severity'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "List alert history (GAP-111).\n\nReturns triggered alert events with status.",
            "is_async": true,
            "line": 248
          },
          {
            "name": "get_event",
            "signature": "(event_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "Get a specific alert event.",
            "is_async": true,
            "line": 281
          },
          {
            "name": "acknowledge_event",
            "signature": "(event_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.acknowledge')))",
            "docstring": "Acknowledge an alert event.",
            "is_async": true,
            "line": 302
          },
          {
            "name": "resolve_event",
            "signature": "(event_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.resolve')))",
            "docstring": "Resolve an alert event.",
            "is_async": true,
            "line": 326
          },
          {
            "name": "create_route",
            "signature": "(request: CreateRouteRequest, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.routes')))",
            "docstring": "Create an alert route (GAP-124).\n\n**Tier: PREVENT ($199)** - Alert routing configuration.\n\nRoutes determine where alerts are sent based on labels.",
            "is_async": true,
            "line": 355
          },
          {
            "name": "list_routes",
            "signature": "(enabled_only: bool = Query(False, description='Only enabled routes'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "List alert routes.",
            "is_async": true,
            "line": 381
          },
          {
            "name": "get_route",
            "signature": "(route_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "Get a specific alert route.",
            "is_async": true,
            "line": 408
          },
          {
            "name": "delete_route",
            "signature": "(route_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.routes')))",
            "docstring": "Delete an alert route.",
            "is_async": true,
            "line": 429
          }
        ],
        "classes": [
          {
            "name": "CreateRuleRequest",
            "docstring": "Request to create alert rule.",
            "methods": [],
            "line": 63
          },
          {
            "name": "UpdateRuleRequest",
            "docstring": "Request to update alert rule.",
            "methods": [],
            "line": 74
          },
          {
            "name": "CreateRouteRequest",
            "docstring": "Request to create alert route.",
            "methods": [],
            "line": 84
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.alerts_facade",
            "names": [
              "AlertsFacade",
              "get_alerts_facade"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "analytics.py",
        "file_path": "backend/app/hoc/api/cus/policies/analytics.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1128,
        "module_docstring": "Unified Analytics API (L2)\n\nCustomer-facing endpoints for viewing usage statistics.\nAll requests are tenant-scoped via auth_context.\n\nDomain: Analytics\nSubdomain: Statistics\nTopic v1: Usage\n\nEndpoints:\n- GET /analytics/statistics/usage             \u2192 Usage statistics\n- GET /analytics/statistics/usage/export.csv  \u2192 CSV export\n- GET /analytics/statistics/usage/export.json \u2192 JSON export\n- GET /analytics/_status                      \u2192 Capability probe\n\nArchitecture:\n- ONE facade for all ANALYTICS needs\n- Facade normalizes, aggregates, enforces contracts\n- Does NOT compute - delegates to signal adapters\n- Tenant isolation via auth_context (not header)\n- Export endpoints use SAME aggregator (bit-equivalent)",
        "functions": [
          {
            "name": "get_usage_statistics",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session = Depends(get_session_dep)) -> UsageStatisticsResponse",
            "docstring": "Get usage statistics for the specified time window.\n\nThis is the primary read endpoint for the Usage topic.\nREAD-ONLY customer facade - delegates to L4 AnalyticsFacade.",
            "is_async": true,
            "line": 239
          },
          {
            "name": "get_analytics_status",
            "signature": "() -> AnalyticsStatusResponse",
            "docstring": "Analytics capability probe.\n\nUsed by console/clients to discover available capabilities\nbefore attempting to render panels.\nREAD-ONLY customer facade - delegates to L4 operation registry.",
            "is_async": true,
            "line": 371
          },
          {
            "name": "get_cost_statistics",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session = Depends(get_session_dep)) -> CostStatisticsResponse",
            "docstring": "Get cost statistics for the specified time window.\n\nPrimary endpoint for the Cost topic.\nREAD-ONLY customer facade - delegates to L4 operation registry.",
            "is_async": true,
            "line": 438
          },
          {
            "name": "analytics_health",
            "signature": "()",
            "docstring": "Internal health check for analytics facade.",
            "is_async": true,
            "line": 592
          },
          {
            "name": "_get_usage_data",
            "signature": "(request: Request, from_ts: datetime, to_ts: datetime, resolution: ResolutionType, scope: ScopeType, session) -> UsageStatisticsResponse",
            "docstring": "Internal helper to get usage data (shared by read and export endpoints).\n\nEnsures export is bit-equivalent to read API - no alternate code paths.\nDelegates to L4 operation registry.",
            "is_async": true,
            "line": 602
          },
          {
            "name": "export_usage_csv",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session = Depends(get_session_dep)) -> Response",
            "docstring": "Export usage statistics as CSV.\n\nUses the same aggregation logic as the read API.\nDeterministic ordering. UTC only.",
            "is_async": true,
            "line": 722
          },
          {
            "name": "export_usage_json",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session = Depends(get_session_dep)) -> UsageStatisticsResponse",
            "docstring": "Export usage statistics as JSON.\n\nStructure matches the standard usage response.\nBit-equivalent to read API.",
            "is_async": true,
            "line": 808
          },
          {
            "name": "_get_cost_data",
            "signature": "(request: Request, from_ts: datetime, to_ts: datetime, resolution: ResolutionType, scope: ScopeType, session) -> CostStatisticsResponse",
            "docstring": "Internal helper to get cost data (shared by read and export endpoints).\n\nEnsures export is bit-equivalent to read API - no alternate code paths.\nDelegates to L4 operation registry.",
            "is_async": true,
            "line": 855
          },
          {
            "name": "export_cost_csv",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session = Depends(get_session_dep)) -> Response",
            "docstring": "Export cost statistics as CSV.\n\nUses the same aggregation logic as the read API.\nDeterministic ordering. UTC only.",
            "is_async": true,
            "line": 1002
          },
          {
            "name": "export_cost_json",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session = Depends(get_session_dep)) -> CostStatisticsResponse",
            "docstring": "Export cost statistics as JSON.\n\nStructure matches the standard cost response.\nBit-equivalent to read API.",
            "is_async": true,
            "line": 1089
          }
        ],
        "classes": [
          {
            "name": "ResolutionType",
            "docstring": "Time resolution for usage data.",
            "methods": [],
            "line": 73
          },
          {
            "name": "ScopeType",
            "docstring": "Scope of usage aggregation.",
            "methods": [],
            "line": 79
          },
          {
            "name": "TimeWindow",
            "docstring": "Generic time window specification (shared across topics).",
            "methods": [],
            "line": 91
          },
          {
            "name": "UsageWindow",
            "docstring": "Time window specification.",
            "methods": [],
            "line": 106
          },
          {
            "name": "UsageTotals",
            "docstring": "Aggregate usage totals.",
            "methods": [],
            "line": 116
          },
          {
            "name": "UsageDataPoint",
            "docstring": "Single data point in usage time series.",
            "methods": [],
            "line": 123
          },
          {
            "name": "UsageSignals",
            "docstring": "Signal source metadata for provenance.",
            "methods": [],
            "line": 131
          },
          {
            "name": "UsageStatisticsResponse",
            "docstring": "GET /analytics/statistics/usage response (contracted).",
            "methods": [],
            "line": 137
          },
          {
            "name": "CostTotals",
            "docstring": "Aggregate cost totals.",
            "methods": [],
            "line": 150
          },
          {
            "name": "CostDataPoint",
            "docstring": "Single data point in cost time series.",
            "methods": [],
            "line": 159
          },
          {
            "name": "CostByModel",
            "docstring": "Cost breakdown by model.",
            "methods": [],
            "line": 168
          },
          {
            "name": "CostByFeature",
            "docstring": "Cost breakdown by feature tag.",
            "methods": [],
            "line": 178
          },
          {
            "name": "CostSignals",
            "docstring": "Signal source metadata for cost provenance.",
            "methods": [],
            "line": 186
          },
          {
            "name": "CostStatisticsResponse",
            "docstring": "GET /analytics/statistics/cost response (contracted).",
            "methods": [],
            "line": 192
          },
          {
            "name": "TopicStatus",
            "docstring": "Status of a topic within a subdomain.",
            "methods": [],
            "line": 202
          },
          {
            "name": "AnalyticsStatusResponse",
            "docstring": "GET /analytics/_status response.",
            "methods": [],
            "line": 209
          }
        ],
        "imports": [
          {
            "module": "csv",
            "names": [
              "csv"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "io",
            "names": [
              "io"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Dict",
              "List"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "fastapi.responses",
            "names": [
              "Response"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "aos_accounts.py",
        "file_path": "backend/app/hoc/api/cus/policies/aos_accounts.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1475,
        "module_docstring": "Unified Accounts API (L2)\n\nCustomer-facing endpoints for account management: projects, users, profile, billing.\nAll requests are tenant-scoped via auth_context.\n\nIMPORTANT: Account is NOT a domain. It manages:\n- WHO (users, profile)\n- WHAT (projects)\n- BILLING (subscription, invoices)\n\nIt does NOT manage or display:\n- Executions\n- Incidents\n- Policies\n- Logs\n\nEndpoints:\n- GET /accounts/projects            \u2192 O2 list projects\n- GET /accounts/projects/{id}       \u2192 O3 project detail\n- GET /accounts/users               \u2192 O2 list users\n- GET /accounts/users/{id}          \u2192 O3 user detail\n- GET /accounts/profile             \u2192 Current user profile\n- PUT /accounts/profile             \u2192 Update profile\n- GET /accounts/billing             \u2192 Billing summary\n- GET /accounts/billing/invoices    \u2192 Invoice history\n\nArchitecture:\n- ONE facade for all ACCOUNTS needs\n- Tenant isolation via auth_context (not header)\n- SDSR validates this same production API",
        "functions": [
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 82
          },
          {
            "name": "get_user_id_from_auth",
            "signature": "(request: Request) -> str | None",
            "docstring": "Extract user_id from auth_context. Returns None if not available.",
            "is_async": false,
            "line": 106
          },
          {
            "name": "list_projects",
            "signature": "(request: Request, status: Annotated[Optional[str], Query(description='Filter by status: active, suspended', pattern='^(active|suspended)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max items to return')] = 50, offset: Annotated[int, Query(ge=0, description='Rows to skip')] = 0, session = Depends(get_session_dep)) -> ProjectsListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 276
          },
          {
            "name": "get_project_detail",
            "signature": "(request: Request, project_id: str, session = Depends(get_session_dep)) -> ProjectDetailResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 356
          },
          {
            "name": "list_users",
            "signature": "(request: Request, role: Annotated[Optional[str], Query(description='Filter by role: owner, admin, member, viewer', pattern='^(owner|admin|member|viewer)$')] = None, status: Annotated[Optional[str], Query(description='Filter by status: active, suspended', pattern='^(active|suspended)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max items to return')] = 50, offset: Annotated[int, Query(ge=0, description='Rows to skip')] = 0, session = Depends(get_session_dep)) -> UsersListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 431
          },
          {
            "name": "get_user_detail",
            "signature": "(request: Request, user_id: str, session = Depends(get_session_dep)) -> UserDetailResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 519
          },
          {
            "name": "get_profile",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> ProfileResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 589
          },
          {
            "name": "get_billing_summary",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> BillingSummaryResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 647
          },
          {
            "name": "update_profile",
            "signature": "(request: Request, update: ProfileUpdateRequest, session = Depends(get_session_dep)) -> ProfileUpdateResponse",
            "docstring": "WRITE customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 727
          },
          {
            "name": "get_billing_invoices",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> InvoiceListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 808
          },
          {
            "name": "get_support_contact",
            "signature": "() -> SupportContactResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": false,
            "line": 914
          },
          {
            "name": "create_support_ticket",
            "signature": "(request: Request, ticket: SupportTicketCreate, session = Depends(get_session_dep)) -> SupportTicketResponse",
            "docstring": "WRITE customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 942
          },
          {
            "name": "list_support_tickets",
            "signature": "(request: Request, status: Optional[str] = Query(None, description='Filter by status'), session = Depends(get_session_dep)) -> SupportTicketListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 997
          },
          {
            "name": "invite_user",
            "signature": "(request: Request, invite: InviteUserRequest, session = Depends(get_session_dep)) -> InvitationResponse",
            "docstring": "WRITE customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 1117
          },
          {
            "name": "list_invitations",
            "signature": "(request: Request, status: Optional[str] = Query(None, description='Filter by status'), session = Depends(get_session_dep)) -> InvitationListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 1173
          },
          {
            "name": "accept_invitation",
            "signature": "(invitation_id: str, accept: AcceptInvitationRequest, session = Depends(get_session_dep)) -> dict",
            "docstring": "Accept an invitation to join a tenant.\n\nThis is a public endpoint (no auth required) as the user\nmay not have an account yet.\n\nLayer: L2 (Product APIs) \u2014 delegates to L4 AccountsFacade",
            "is_async": true,
            "line": 1237
          },
          {
            "name": "list_tenant_users",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> TenantUserListResponse",
            "docstring": "List users in the current tenant.\n\nLayer: L2 (Product APIs) \u2014 delegates to L4 AccountsFacade",
            "is_async": true,
            "line": 1301
          },
          {
            "name": "update_user_role",
            "signature": "(request: Request, user_id: str, update: UpdateUserRoleRequest, session = Depends(get_session_dep)) -> TenantUserResponse",
            "docstring": "Update a user's role in the tenant.\n\nRequires: owner role.\n\nLayer: L2 (Product APIs) \u2014 delegates to L4 AccountsFacade",
            "is_async": true,
            "line": 1356
          },
          {
            "name": "remove_user",
            "signature": "(request: Request, user_id: str, session = Depends(get_session_dep)) -> dict",
            "docstring": "Remove a user from the tenant.\n\nRequires: owner or admin role.\n\nLayer: L2 (Product APIs) \u2014 delegates to L4 AccountsFacade",
            "is_async": true,
            "line": 1422
          }
        ],
        "classes": [
          {
            "name": "ProjectSummary",
            "docstring": "O2 Result Shape for projects.",
            "methods": [],
            "line": 121
          },
          {
            "name": "ProjectsListResponse",
            "docstring": "GET /projects response (O2).",
            "methods": [],
            "line": 133
          },
          {
            "name": "ProjectDetailResponse",
            "docstring": "GET /projects/{id} response (O3).",
            "methods": [],
            "line": 142
          },
          {
            "name": "UserSummary",
            "docstring": "O2 Result Shape for users.",
            "methods": [],
            "line": 174
          },
          {
            "name": "UsersListResponse",
            "docstring": "GET /users response (O2).",
            "methods": [],
            "line": 186
          },
          {
            "name": "UserDetailResponse",
            "docstring": "GET /users/{id} response (O3).",
            "methods": [],
            "line": 195
          },
          {
            "name": "ProfileResponse",
            "docstring": "GET /profile response.",
            "methods": [],
            "line": 224
          },
          {
            "name": "BillingSummaryResponse",
            "docstring": "GET /billing response.",
            "methods": [],
            "line": 243
          },
          {
            "name": "ProfileUpdateRequest",
            "docstring": "Request to update user profile preferences.",
            "methods": [],
            "line": 707
          },
          {
            "name": "ProfileUpdateResponse",
            "docstring": "Profile update response.",
            "methods": [],
            "line": 715
          },
          {
            "name": "InvoiceSummary",
            "docstring": "Invoice summary for billing history.",
            "methods": [],
            "line": 788
          },
          {
            "name": "InvoiceListResponse",
            "docstring": "List of invoices response.",
            "methods": [],
            "line": 799
          },
          {
            "name": "SupportTicketCreate",
            "docstring": "Create a support ticket.",
            "methods": [],
            "line": 874
          },
          {
            "name": "SupportTicketResponse",
            "docstring": "Support ticket response.",
            "methods": [],
            "line": 883
          },
          {
            "name": "SupportTicketListResponse",
            "docstring": "List of support tickets.",
            "methods": [],
            "line": 898
          },
          {
            "name": "SupportContactResponse",
            "docstring": "Support contact information.",
            "methods": [],
            "line": 905
          },
          {
            "name": "InviteUserRequest",
            "docstring": "Request to invite a user to the tenant.",
            "methods": [],
            "line": 1061
          },
          {
            "name": "InvitationResponse",
            "docstring": "Invitation response.",
            "methods": [],
            "line": 1068
          },
          {
            "name": "InvitationListResponse",
            "docstring": "List of invitations.",
            "methods": [],
            "line": 1080
          },
          {
            "name": "AcceptInvitationRequest",
            "docstring": "Request to accept an invitation.",
            "methods": [],
            "line": 1087
          },
          {
            "name": "UpdateUserRoleRequest",
            "docstring": "Request to update a user's role.",
            "methods": [],
            "line": 1093
          },
          {
            "name": "TenantUserResponse",
            "docstring": "User in tenant response.",
            "methods": [],
            "line": 1099
          },
          {
            "name": "TenantUserListResponse",
            "docstring": "List of users in tenant.",
            "methods": [],
            "line": 1109
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 60
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "aos_api_key.py",
        "file_path": "backend/app/hoc/api/cus/policies/aos_api_key.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 297,
        "module_docstring": "API Keys API (L2) - Connectivity Domain\n\nCustomer-facing endpoints for managing API keys.\nAll requests are tenant-scoped via auth_context.\n\nEndpoints:\n- GET /api-keys           \u2192 O2 list API keys\n- GET /api-keys/{id}      \u2192 O3 API key detail\n\nArchitecture:\n- ONE facade for API KEYS in Connectivity domain\n- Queries APIKey table\n- Tenant isolation via auth_context (not header)\n- SDSR validates this same production API",
        "functions": [
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 68
          },
          {
            "name": "list_api_keys",
            "signature": "(request: Request, status: Annotated[Optional[str], Query(description='Filter by status: active, revoked, expired', pattern='^(active|revoked|expired)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max items to return')] = 50, offset: Annotated[int, Query(ge=0, description='Rows to skip')] = 0, session = Depends(get_session_dep)) -> APIKeysListResponse",
            "docstring": "List API keys. READ-ONLY. Delegates to L4 operation registry.",
            "is_async": true,
            "line": 159
          },
          {
            "name": "get_api_key_detail",
            "signature": "(request: Request, key_id: str, session = Depends(get_session_dep)) -> APIKeyDetailResponse",
            "docstring": "Get API key detail (O3). Delegates to L4 operation registry.",
            "is_async": true,
            "line": 241
          }
        ],
        "classes": [
          {
            "name": "APIKeySummary",
            "docstring": "O2 Result Shape for API keys.",
            "methods": [],
            "line": 97
          },
          {
            "name": "APIKeysListResponse",
            "docstring": "GET /api-keys response (O2).",
            "methods": [],
            "line": 110
          },
          {
            "name": "APIKeyDetailResponse",
            "docstring": "GET /api-keys/{id} response (O3).",
            "methods": [],
            "line": 119
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "aos_cus_integrations.py",
        "file_path": "backend/app/hoc/api/cus/policies/aos_cus_integrations.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 673,
        "module_docstring": "Customer LLM Integration Management API\n\nPURPOSE:\n    CONTROL PLANE for customer LLM integrations. This API manages the lifecycle\n    of integrations - create, update, enable, disable, delete, health checks.\n\nENDPOINTS:\n    CRUD:\n        GET    /integrations           - List integrations (paginated)\n        GET    /integrations/{id}      - Get integration details\n        POST   /integrations           - Create new integration\n        PUT    /integrations/{id}      - Update integration\n        DELETE /integrations/{id}      - Delete integration (soft)\n\n    Lifecycle:\n        POST   /integrations/{id}/enable   - Enable integration\n        POST   /integrations/{id}/disable  - Disable integration\n\n    Health:\n        GET    /integrations/{id}/health   - Get health status\n        POST   /integrations/{id}/test     - Test credentials\n\n    Limits:\n        GET    /integrations/{id}/limits   - Get current usage vs limits\n\nSEMANTIC:\n    - Tenant-isolated: All operations scoped to authenticated tenant\n    - Status lifecycle: created -> enabled -> disabled\n    - Health checks are non-blocking\n    - Soft delete preserves telemetry references\n\nAUTHENTICATION:\n    Uses standard tenant authentication via gateway middleware.",
        "functions": [
          {
            "name": "get_user_id",
            "signature": "(request: Request) -> Optional[str]",
            "docstring": "Extract user_id from authenticated request.",
            "is_async": false,
            "line": 88
          },
          {
            "name": "list_integrations",
            "signature": "(request: Request, offset: int = Query(default=0, ge=0, description='Pagination offset'), limit: int = Query(default=20, ge=1, le=100, description='Page size'), status: Optional[str] = Query(default=None, description='Filter by status'), provider_type: Optional[str] = Query(default=None, description='Filter by provider'))",
            "docstring": "List all integrations for the tenant.\n\nReturns paginated list of integration summaries.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 102
          },
          {
            "name": "get_integration",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Get full details for a specific integration.\n\nIncludes health state, limits configuration, and timestamps.\nDoes NOT include credential_ref or sensitive config.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 160
          },
          {
            "name": "create_integration",
            "signature": "(payload: CusIntegrationCreate, request: Request)",
            "docstring": "Create a new LLM integration.\n\nThe integration starts in 'created' status. Use /enable to activate it.\nDelegates to L4 IntegrationsFacade.\n\nSECURITY:\n    - credential_ref must be a vault reference or encrypted value\n    - Raw API keys are rejected by schema validation",
            "is_async": true,
            "line": 225
          },
          {
            "name": "update_integration",
            "signature": "(integration_id: UUID, payload: CusIntegrationUpdate, request: Request)",
            "docstring": "Update an existing integration.\n\nPartial update - only provided fields are changed.\nStatus changes should use dedicated enable/disable endpoints.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 294
          },
          {
            "name": "delete_integration",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Delete an integration (soft delete).\n\nThe integration is marked as deleted but retained for telemetry references.\nTelemetry data is NOT deleted.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 364
          },
          {
            "name": "enable_integration",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Enable an integration.\n\nTransitions status from 'created' or 'disabled' to 'enabled'.\nSDK can only use enabled integrations.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 411
          },
          {
            "name": "disable_integration",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Disable an integration.\n\nTransitions status to 'disabled'. SDK calls will fail for disabled integrations.\nTelemetry continues to be accepted for in-flight calls.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 459
          },
          {
            "name": "get_integration_health",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Get current health status without running a new check.\n\nReturns cached health state from last check.\nUse POST /test to trigger a fresh health check.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 512
          },
          {
            "name": "test_integration_credentials",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Test integration credentials and update health status.\n\nPerforms a lightweight API call to the provider to verify:\n- Credentials are valid\n- Provider is reachable\n- Rate limits allow access\n\nThis is NON-BLOCKING but may take a few seconds.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 563
          },
          {
            "name": "get_integration_limits",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Get current usage against configured limits.\n\nReturns budget, token, and rate limit status with percentages.\nUsed by SDK to check limits before making calls (Phase 5).\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 622
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.auth.tenant_resolver",
            "names": [
              "resolve_tenant_id"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.schemas.cus_schemas",
            "names": [
              "CusHealthCheckResponse",
              "CusIntegrationCreate",
              "CusIntegrationResponse",
              "CusIntegrationSummary",
              "CusIntegrationUpdate"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict",
              "wrap_list"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 69
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "billing_dependencies.py",
        "file_path": "backend/app/hoc/api/cus/policies/billing_dependencies.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 203,
        "module_docstring": "Phase-6 Billing Dependencies \u2014 FastAPI Integration\n\nProvides dependencies for accessing billing context in API endpoints.\n\nAPPLICABILITY GATE:\n    Billing is evaluated ONLY when tenant.onboarding_state == COMPLETE.\n    Before COMPLETE, these dependencies return neutral placeholders.\n\nDESIGN INVARIANTS:\n- BILLING-001: Billing never blocks onboarding\n- BILLING-003: Billing state does not affect roles\n\nPIN-520 Phase 1: Routes billing provider access through L4 account bridge.",
        "functions": [
          {
            "name": "_get_billing_provider",
            "signature": "()",
            "docstring": "Get billing provider via L4 bridge (PIN-520 compliance).",
            "is_async": false,
            "line": 45
          },
          {
            "name": "get_billing_context",
            "signature": "(request: Request) -> BillingContext",
            "docstring": "FastAPI dependency: Get billing context for current request.\n\nAPPLICABILITY:\n- Returns neutral context if onboarding is not COMPLETE\n- Returns full billing context if onboarding is COMPLETE\n\nUsage:\n    @router.get(\"/billing/status\")\n    async def get_status(billing: BillingContext = Depends(get_billing_context)):\n        return {\"state\": billing.billing_state.value}",
            "is_async": false,
            "line": 80
          },
          {
            "name": "require_billing_active",
            "signature": "(request: Request) -> BillingContext",
            "docstring": "FastAPI dependency: Require billing state allows usage.\n\nRaises HTTP 402 if billing state is SUSPENDED.\n\nUsage:\n    @router.post(\"/runs\")\n    async def create_run(billing: BillingContext = Depends(require_billing_active)):\n        # Billing state is verified to allow usage\n        ...",
            "is_async": false,
            "line": 132
          },
          {
            "name": "check_limit",
            "signature": "(context: BillingContext, limit_name: str, current_value: float) -> Optional[dict]",
            "docstring": "Check if a specific limit is exceeded.\n\nReturns error dict if exceeded, None otherwise.\n\nArgs:\n    context: Billing context\n    limit_name: Name of limit attribute (e.g., \"max_requests_per_day\")\n    current_value: Current usage value\n\nReturns:\n    Error dict if limit exceeded, None otherwise",
            "is_async": false,
            "line": 159
          }
        ],
        "classes": [
          {
            "name": "BillingContext",
            "docstring": "Billing context for a request.\n\nProvides billing state, plan, and limits for the current tenant.\nReturns neutral values if onboarding is not complete.\n\nAttributes:\n    tenant_id: The tenant identifier\n    billing_state: Current billing state (TRIAL if not complete)\n    plan: Current plan (FREE if not complete)\n    limits: Derived limits\n    is_applicable: True if billing logic applies (onboarding complete)",
            "methods": [
              "allows_usage"
            ],
            "line": 52
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "Request",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.billing.state",
            "names": [
              "BillingState"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.billing.plan",
            "names": [
              "Plan",
              "DEFAULT_PLAN"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.billing.limits",
            "names": [
              "Limits",
              "DEFAULT_LIMITS"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges.account_bridge",
            "names": [
              "get_account_bridge"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.onboarding_state",
            "names": [
              "OnboardingState"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "BillingContext",
          "get_billing_context",
          "require_billing_active",
          "check_limit"
        ]
      },
      {
        "file_name": "compliance.py",
        "file_path": "backend/app/hoc/api/cus/policies/compliance.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 220,
        "module_docstring": "Compliance API (L2)\n\nProvides compliance verification operations:\n- POST /compliance/verify (run verification)\n- GET /compliance/reports (list reports)\n- GET /compliance/reports/{id} (get report)\n- GET /compliance/rules (list rules)\n- GET /compliance/rules/{id} (get rule)\n- GET /compliance/status (overall status)\n\nThis is the ONLY facade for compliance verification.\nAll compliance APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> ComplianceFacade",
            "docstring": "Get the compliance facade.",
            "is_async": false,
            "line": 70
          },
          {
            "name": "verify_compliance",
            "signature": "(request: VerifyComplianceRequest, ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.verify')))",
            "docstring": "Run compliance verification (GAP-103).\n\n**Tier: PREVENT ($199)** - Compliance verification.\n\nScopes:\n- all: Run all compliance checks\n- data: Data handling compliance\n- policy: Policy enforcement compliance\n- cost: Cost governance compliance\n- security: Security compliance",
            "is_async": true,
            "line": 81
          },
          {
            "name": "list_reports",
            "signature": "(scope: Optional[str] = Query(None, description='Filter by scope'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "List compliance reports.\n\nReturns compliance verification reports for the tenant.",
            "is_async": true,
            "line": 111
          },
          {
            "name": "get_report",
            "signature": "(report_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "Get a specific compliance report.",
            "is_async": true,
            "line": 142
          },
          {
            "name": "list_rules",
            "signature": "(scope: Optional[str] = Query(None, description='Filter by scope'), enabled_only: bool = Query(True, description='Only enabled rules'), ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "List compliance rules.\n\nReturns all compliance rules that are checked during verification.",
            "is_async": true,
            "line": 163
          },
          {
            "name": "get_rule",
            "signature": "(rule_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "Get a specific compliance rule.",
            "is_async": true,
            "line": 187
          },
          {
            "name": "get_compliance_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "Get overall compliance status.\n\nReturns the current compliance status including:\n- Overall status (compliant, non_compliant, partially_compliant)\n- Last verification timestamp\n- Rule counts\n- Pending violations",
            "is_async": true,
            "line": 205
          }
        ],
        "classes": [
          {
            "name": "VerifyComplianceRequest",
            "docstring": "Request to run compliance verification.",
            "methods": [],
            "line": 57
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.compliance_facade",
            "names": [
              "ComplianceFacade",
              "get_compliance_facade"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "connectors.py",
        "file_path": "backend/app/hoc/api/cus/policies/connectors.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 285,
        "module_docstring": "Connectors API (L2)\n\nProvides connector management operations:\n- GET /connectors (list connectors)\n- POST /connectors (register connector)\n- GET /connectors/{id} (get connector)\n- PUT /connectors/{id} (update connector)\n- DELETE /connectors/{id} (delete connector)\n- POST /connectors/{id}/test (test connector)\n\nThis is the ONLY facade for connector operations.\nAll connector APIs flow through this router.",
        "functions": [
          {
            "name": "list_connectors",
            "signature": "(connector_type: Optional[str] = Query(None, description='Filter by type'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('connectors.read')))",
            "docstring": "List connectors for the tenant.\n\nReturns all registered connectors with optional filtering.",
            "is_async": true,
            "line": 80
          },
          {
            "name": "register_connector",
            "signature": "(request: RegisterConnectorRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('connectors.write')))",
            "docstring": "Register a new connector.\n\nSupported types:\n- http: REST/HTTP APIs\n- sql: SQL databases\n- mcp: Model Context Protocol servers\n- vector: Vector databases\n- file: File storage\n- serverless: Serverless functions",
            "is_async": true,
            "line": 121
          },
          {
            "name": "get_connector",
            "signature": "(connector_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('connectors.read')))",
            "docstring": "Get a specific connector by ID.",
            "is_async": true,
            "line": 161
          },
          {
            "name": "update_connector",
            "signature": "(connector_id: str, request: UpdateConnectorRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('connectors.write')))",
            "docstring": "Update a connector.",
            "is_async": true,
            "line": 192
          },
          {
            "name": "delete_connector",
            "signature": "(connector_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('connectors.write')))",
            "docstring": "Delete a connector.",
            "is_async": true,
            "line": 228
          },
          {
            "name": "test_connector",
            "signature": "(connector_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('connectors.test')))",
            "docstring": "Test a connector connection.\n\nAttempts to establish a connection and returns the result.",
            "is_async": true,
            "line": 259
          }
        ],
        "classes": [
          {
            "name": "RegisterConnectorRequest",
            "docstring": "Request to register a new connector.",
            "methods": [],
            "line": 57
          },
          {
            "name": "UpdateConnectorRequest",
            "docstring": "Request to update a connector.",
            "methods": [],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_enforcement.py",
        "file_path": "backend/app/hoc/api/cus/policies/cus_enforcement.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 265,
        "module_docstring": "Customer LLM Enforcement API\n\nPURPOSE:\n    API endpoints for enforcement policy evaluation.\n    SDK calls these endpoints before making LLM calls.\n\nENDPOINTS:\n    POST   /enforcement/check    - Pre-flight enforcement check\n    GET    /enforcement/status   - Get current limits and usage\n    POST   /enforcement/batch    - Batch pre-flight checks\n\nSEMANTIC:\n    - Tenant-isolated: All operations scoped to authenticated tenant\n    - Read-only: These endpoints evaluate policies, they don't change them\n    - Idempotent: Same request always produces same decision (given same state)\n\nAUTHENTICATION:\n    Uses standard tenant authentication via gateway middleware.\n    SDK uses X-AOS-Key header.",
        "functions": [
          {
            "name": "get_tenant_id",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from authenticated request.",
            "is_async": false,
            "line": 80
          },
          {
            "name": "check_enforcement",
            "signature": "(payload: EnforcementCheckRequest, request: Request)",
            "docstring": "Check enforcement policy before making an LLM call.\n\nThis is the primary endpoint for SDK pre-flight checks. Returns a decision\nthat tells the SDK whether to proceed, warn, throttle, or block.\n\nThe decision includes:\n- result: allowed, warned, throttled, blocked, hard_blocked\n- reasons: Explainability data for why the decision was made\n- degraded: True if decision made with incomplete telemetry\n\nIMPORTANT: This endpoint is read-only and idempotent. Calling it multiple\ntimes with the same state will produce the same result.",
            "is_async": true,
            "line": 102
          },
          {
            "name": "get_enforcement_status",
            "signature": "(request: Request, integration_id: str = Query(..., description='Integration ID'))",
            "docstring": "Get current enforcement status for an integration.\n\nReturns current limits, usage, and remaining allowances. Useful for\ndisplaying in dashboards or for SDK to show users their current state.\n\nDoes NOT make an enforcement decision - use /check for that.",
            "is_async": true,
            "line": 168
          },
          {
            "name": "batch_enforcement_check",
            "signature": "(payload: EnforcementBatchRequest, request: Request)",
            "docstring": "Check enforcement for multiple requests at once.\n\nUseful for batch operations or when making multiple calls in sequence.\nReturns decisions in the same order as the requests.",
            "is_async": true,
            "line": 215
          }
        ],
        "classes": [
          {
            "name": "EnforcementCheckRequest",
            "docstring": "Request for enforcement check.",
            "methods": [],
            "line": 55
          },
          {
            "name": "EnforcementBatchRequest",
            "docstring": "Request for batch enforcement check.",
            "methods": [],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "List"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict",
              "wrap_list"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "customer_visibility.py",
        "file_path": "backend/app/hoc/api/cus/policies/customer_visibility.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 606,
        "module_docstring": "Phase 4C-2: Customer Visibility Endpoints\n\nCustomer-facing endpoints for predictability and accountability.\n\nRules:\n- Show effects, not mechanics\n- No decision records exposed\n- No governance internals\n- Predictability before execution\n- Accountability after execution",
        "functions": [
          {
            "name": "get_budget_mode",
            "signature": "() -> BudgetDeclaration",
            "docstring": "Determine budget enforcement mode from configuration.",
            "is_async": false,
            "line": 199
          },
          {
            "name": "get_policy_posture",
            "signature": "(strict_mode: bool = False) -> PolicyDeclaration",
            "docstring": "Determine policy posture from configuration.",
            "is_async": false,
            "line": 220
          },
          {
            "name": "get_memory_mode",
            "signature": "() -> MemoryDeclaration",
            "docstring": "Determine memory mode from configuration.",
            "is_async": false,
            "line": 236
          },
          {
            "name": "estimate_stages",
            "signature": "(agent_id: str, goal: str) -> List[StageDeclaration]",
            "docstring": "Estimate execution stages based on agent capabilities.\n\nThis is a simplified version - in production, this would\ncall the planner to generate a real plan.",
            "is_async": false,
            "line": 252
          },
          {
            "name": "estimate_cost",
            "signature": "(agent_id: str, goal: str, stages: List[StageDeclaration]) -> CostDeclaration",
            "docstring": "Estimate cost based on stages and historical data.",
            "is_async": false,
            "line": 272
          },
          {
            "name": "get_pre_run_declaration",
            "signature": "(agent_id: str, goal: str, strict_mode: bool = False, _: str = Depends(verify_api_key)) -> PreRunDeclaration",
            "docstring": "Get PRE-RUN declaration before execution.\n\nReturns all information needed for customer to make an informed decision:\n- Stages that will execute (ordered)\n- Estimated cost range\n- Budget enforcement mode\n- Policy posture\n- Memory mode\n\nCustomer must acknowledge before execution can proceed.",
            "is_async": true,
            "line": 313
          },
          {
            "name": "acknowledge_declaration",
            "signature": "(request: AcknowledgementRequest, _: str = Depends(verify_api_key)) -> AcknowledgementResponse",
            "docstring": "Acknowledge PRE-RUN declaration.\n\nCustomer must acknowledge to proceed with execution.\nThis creates an audit trail of informed consent.",
            "is_async": true,
            "line": 379
          },
          {
            "name": "get_outcome_reconciliation",
            "signature": "(run_id: str, request: Request, _: str = Depends(verify_api_key), session = Depends(get_session_dep)) -> OutcomeReconciliation",
            "docstring": "Get outcome reconciliation after execution.\n\nReturns decomposed results (never a single success flag):\n- Task completion status\n- Budget usage status\n- Policy compliance status\n- Recovery status",
            "is_async": true,
            "line": 435
          },
          {
            "name": "get_declaration",
            "signature": "(declaration_id: str, _: str = Depends(verify_api_key)) -> PreRunDeclaration",
            "docstring": "Retrieve a previously created PRE-RUN declaration.",
            "is_async": true,
            "line": 596
          }
        ],
        "classes": [
          {
            "name": "StageDeclaration",
            "docstring": "Single stage in the execution plan.",
            "methods": [],
            "line": 47
          },
          {
            "name": "CostDeclaration",
            "docstring": "Cost expectations before execution.",
            "methods": [],
            "line": 55
          },
          {
            "name": "BudgetDeclaration",
            "docstring": "Budget enforcement mode.",
            "methods": [],
            "line": 64
          },
          {
            "name": "PolicyDeclaration",
            "docstring": "Policy posture declaration.",
            "methods": [],
            "line": 72
          },
          {
            "name": "MemoryDeclaration",
            "docstring": "Memory mode declaration.",
            "methods": [],
            "line": 80
          },
          {
            "name": "EstimationMethodology",
            "docstring": "PIN-254 Phase C Fix (C3 Partial Truth): Explicit disclosure of estimation basis.\n\nEnsures API consumers know whether estimates are derived from:\n- Real planner output (planner_v1)\n- Hardcoded defaults (default_stages_v1)\n- Historical data (historical_avg)",
            "methods": [],
            "line": 87
          },
          {
            "name": "PreRunDeclaration",
            "docstring": "Complete PRE-RUN declaration for customer visibility.\n\nThis is what the customer sees BEFORE execution starts.\nExecution cannot proceed without acknowledgement.",
            "methods": [],
            "line": 103
          },
          {
            "name": "AcknowledgementRequest",
            "docstring": "Customer acknowledgement of PRE-RUN declaration.",
            "methods": [],
            "line": 138
          },
          {
            "name": "AcknowledgementResponse",
            "docstring": "Response after acknowledgement.",
            "methods": [],
            "line": 145
          },
          {
            "name": "OutcomeItem",
            "docstring": "Single outcome item.",
            "methods": [],
            "line": 159
          },
          {
            "name": "OutcomeReconciliation",
            "docstring": "Complete outcome reconciliation for customer visibility.\n\nThis is what the customer sees AFTER execution completes.\nDecomposed results, never a single success flag.",
            "methods": [],
            "line": 167
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_operation_registry",
              "get_session_dep",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "app.auth",
            "names": [
              "verify_api_key"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.middleware.tenancy",
            "names": [
              "get_tenant_id"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "datasources.py",
        "file_path": "backend/app/hoc/api/cus/policies/datasources.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 387,
        "module_docstring": "DataSources API (L2)\n\nProvides data source operations:\n- POST /datasources (create source)\n- GET /datasources (list sources)\n- GET /datasources/{id} (get source)\n- PUT /datasources/{id} (update source)\n- DELETE /datasources/{id} (delete source)\n- POST /datasources/{id}/test (test connection)\n- POST /datasources/{id}/activate (activate source)\n- POST /datasources/{id}/deactivate (deactivate source)\n- GET /datasources/stats (statistics)\n\nThis is the ONLY facade for data source operations.\nAll data source APIs flow through this router.",
        "functions": [
          {
            "name": "create_source",
            "signature": "(request: CreateSourceRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Create a data source (GAP-113).\n\n**Tier: REACT ($9)** - Data source management.\n\nSource types:\n- database: Relational databases (PostgreSQL, MySQL, etc.)\n- file: File storage (S3, GCS, local)\n- api: REST/GraphQL APIs\n- vector: Vector databases (Pinecone, Weaviate)\n- stream: Streaming sources (Kafka, etc.)\n- custom: Custom connectors",
            "is_async": true,
            "line": 84
          },
          {
            "name": "list_sources",
            "signature": "(source_type: Optional[str] = Query(None, description='Filter by type'), status: Optional[str] = Query(None, description='Filter by status'), tag: Optional[str] = Query(None, description='Filter by tag'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.read')))",
            "docstring": "List data sources.",
            "is_async": true,
            "line": 127
          },
          {
            "name": "get_statistics",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.read')))",
            "docstring": "Get data source statistics.",
            "is_async": true,
            "line": 168
          },
          {
            "name": "get_source",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.read')))",
            "docstring": "Get a specific data source.",
            "is_async": true,
            "line": 194
          },
          {
            "name": "update_source",
            "signature": "(source_id: str, request: UpdateSourceRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Update a data source.",
            "is_async": true,
            "line": 225
          },
          {
            "name": "delete_source",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Delete a data source.",
            "is_async": true,
            "line": 261
          },
          {
            "name": "test_connection",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.test')))",
            "docstring": "Test a data source connection.\n\nVerifies that the data source can be reached with the current configuration.",
            "is_async": true,
            "line": 292
          },
          {
            "name": "activate_source",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Activate a data source.\n\nMakes the data source available for use.",
            "is_async": true,
            "line": 325
          },
          {
            "name": "deactivate_source",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Deactivate a data source.\n\nTemporarily disables the data source.",
            "is_async": true,
            "line": 358
          }
        ],
        "classes": [
          {
            "name": "CreateSourceRequest",
            "docstring": "Request to create a data source.",
            "methods": [],
            "line": 60
          },
          {
            "name": "UpdateSourceRequest",
            "docstring": "Request to update a data source.",
            "methods": [],
            "line": 70
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "detection.py",
        "file_path": "backend/app/hoc/api/cus/policies/detection.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 319,
        "module_docstring": "Detection API (L2)\n\nProvides anomaly detection operations:\n- POST /detection/run (run detection on demand)\n- GET /detection/anomalies (list anomalies)\n- GET /detection/anomalies/{id} (get anomaly)\n- POST /detection/anomalies/{id}/resolve (resolve anomaly)\n- POST /detection/anomalies/{id}/acknowledge (acknowledge anomaly)\n- GET /detection/status (detection engine status)\n\nThis is the ONLY facade for anomaly detection operations.\nAll detection APIs flow through this router.",
        "functions": [
          {
            "name": "run_detection",
            "signature": "(request: RunDetectionRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('detection.run')))",
            "docstring": "Run anomaly detection on demand (GAP-102).\n\n**Tier: REACT ($9)** - Anomaly detection.\n\nDetection types:\n- cost: Cost anomalies (spikes, drift, budget issues)\n- behavioral: Behavioral anomalies (pattern changes)\n- drift: Model/data drift detection\n\nReturns detection results including anomalies found and incidents created.",
            "is_async": true,
            "line": 87
          },
          {
            "name": "list_anomalies",
            "signature": "(detection_type: Optional[str] = Query(None, description='Filter by type'), severity: Optional[str] = Query(None, description='Filter by severity'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('detection.read')))",
            "docstring": "List anomalies for the tenant.\n\nReturns detected anomalies with optional filtering.",
            "is_async": true,
            "line": 128
          },
          {
            "name": "get_anomaly",
            "signature": "(anomaly_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('detection.read')))",
            "docstring": "Get a specific anomaly by ID.",
            "is_async": true,
            "line": 174
          },
          {
            "name": "resolve_anomaly",
            "signature": "(anomaly_id: str, request: ResolveAnomalyRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('detection.resolve')))",
            "docstring": "Resolve an anomaly.\n\nResolution options:\n- resolved: Anomaly has been addressed\n- dismissed: Anomaly is not actionable (false positive)",
            "is_async": true,
            "line": 208
          },
          {
            "name": "acknowledge_anomaly",
            "signature": "(anomaly_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('detection.acknowledge')))",
            "docstring": "Acknowledge an anomaly.\n\nMarks the anomaly as seen but not yet resolved.",
            "is_async": true,
            "line": 252
          },
          {
            "name": "get_detection_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get detection engine status.\n\nReturns health status of detection engines:\n- cost: Cost anomaly detector\n- behavioral: Behavioral pattern detector\n- drift: Model/data drift detector",
            "is_async": true,
            "line": 291
          }
        ],
        "classes": [
          {
            "name": "RunDetectionRequest",
            "docstring": "Request to run anomaly detection.",
            "methods": [],
            "line": 57
          },
          {
            "name": "ResolveAnomalyRequest",
            "docstring": "Request to resolve an anomaly.",
            "methods": [],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "evidence.py",
        "file_path": "backend/app/hoc/api/cus/policies/evidence.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 376,
        "module_docstring": "Evidence API (L2)\n\nProvides evidence chain and export operations:\n- GET /evidence/chains (list chains)\n- POST /evidence/chains (create chain)\n- GET /evidence/chains/{id} (get chain)\n- POST /evidence/chains/{id}/evidence (add evidence)\n- GET /evidence/chains/{id}/verify (verify chain)\n- POST /evidence/export (create export)\n- GET /evidence/exports (list exports)\n- GET /evidence/exports/{id} (get export)\n\nThis is the ONLY facade for evidence operations.\nAll evidence APIs flow through this router.",
        "functions": [
          {
            "name": "list_chains",
            "signature": "(run_id: Optional[str] = Query(None, description='Filter by run'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.read')))",
            "docstring": "List evidence chains.\n\nReturns evidence chains for the tenant.",
            "is_async": true,
            "line": 88
          },
          {
            "name": "create_chain",
            "signature": "(request: CreateChainRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.write')))",
            "docstring": "Create an evidence chain (GAP-104).\n\n**Tier: REACT ($9)** - Evidence chain creation.\n\nCreates a new evidence chain, optionally with initial evidence.",
            "is_async": true,
            "line": 128
          },
          {
            "name": "get_chain",
            "signature": "(chain_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.read')))",
            "docstring": "Get a specific evidence chain.",
            "is_async": true,
            "line": 162
          },
          {
            "name": "add_evidence",
            "signature": "(chain_id: str, request: AddEvidenceRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.write')))",
            "docstring": "Add evidence to a chain.\n\nEvidence types:\n- execution: Run execution evidence\n- retrieval: Data retrieval evidence\n- policy: Policy decision evidence\n- cost: Cost event evidence\n- incident: Incident evidence",
            "is_async": true,
            "line": 194
          },
          {
            "name": "verify_chain",
            "signature": "(chain_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.verify')))",
            "docstring": "Verify chain integrity.\n\nVerifies that all links in the chain have valid hashes\nand proper linkage.",
            "is_async": true,
            "line": 236
          },
          {
            "name": "create_export",
            "signature": "(request: CreateExportRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.export')))",
            "docstring": "Create evidence export (GAP-105).\n\n**Tier: PREVENT ($199)** - Evidence export.\n\nExport formats:\n- json: JSON format with full chain data\n- csv: CSV format for spreadsheet import\n- pdf: PDF format for compliance reports",
            "is_async": true,
            "line": 273
          },
          {
            "name": "list_exports",
            "signature": "(chain_id: Optional[str] = Query(None, description='Filter by chain'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.read')))",
            "docstring": "List evidence exports.",
            "is_async": true,
            "line": 310
          },
          {
            "name": "get_export",
            "signature": "(export_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.read')))",
            "docstring": "Get export status.",
            "is_async": true,
            "line": 348
          }
        ],
        "classes": [
          {
            "name": "CreateChainRequest",
            "docstring": "Request to create evidence chain.",
            "methods": [],
            "line": 58
          },
          {
            "name": "AddEvidenceRequest",
            "docstring": "Request to add evidence to chain.",
            "methods": [],
            "line": 67
          },
          {
            "name": "CreateExportRequest",
            "docstring": "Request to create evidence export.",
            "methods": [],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "governance.py",
        "file_path": "backend/app/hoc/api/cus/policies/governance.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 315,
        "module_docstring": "Governance API (L2)\n\nProvides governance control operations:\n- POST /governance/kill-switch (GAP-090)\n- POST /governance/mode (GAP-091)\n- POST /governance/resolve-conflict (GAP-092)\n- GET /governance/boot-status (GAP-095)\n- GET /governance/state\n\nThis is the ONLY facade for governance control operations.\nAll governance APIs flow through this router.",
        "functions": [
          {
            "name": "get_governance_state",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get current governance state.\n\nReturns the current governance mode, whether enforcement is active,\nand details about the last state change.",
            "is_async": true,
            "line": 116
          },
          {
            "name": "toggle_kill_switch",
            "signature": "(request: KillSwitchRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('governance.kill_switch')))",
            "docstring": "Toggle the governance kill switch (GAP-090).\n\n**Tier: REACT ($9)** - Emergency governance control.\n\nWARNING: Enabling the kill switch disables ALL governance enforcement.\nThis is an emergency operation for incident response only.\n\n- enabled=true: Disable governance (emergency kill switch ON)\n- enabled=false: Re-enable governance (kill switch OFF)",
            "is_async": true,
            "line": 140
          },
          {
            "name": "set_governance_mode",
            "signature": "(request: ModeRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('governance.mode')))",
            "docstring": "Set governance mode (GAP-091).\n\n**Tier: REACT ($9)** - Emergency governance control.\n\nModes:\n- NORMAL: Full governance enforcement\n- DEGRADED: Limited enforcement, new runs blocked\n- KILL: All governance disabled (emergency)",
            "is_async": true,
            "line": 177
          },
          {
            "name": "resolve_conflict",
            "signature": "(request: ConflictResolutionRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('governance.resolve_conflict')))",
            "docstring": "Manually resolve a policy conflict (GAP-092).\n\n**Tier: PREVENT ($199)** - Policy management.\n\nResolution strategies:\n- accept_first: Accept the first policy in the conflict\n- accept_second: Accept the second policy in the conflict\n- merge: Attempt to merge conflicting policies\n- defer: Defer resolution to later",
            "is_async": true,
            "line": 223
          },
          {
            "name": "list_conflicts",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), status: Optional[str] = Query(None, description='Filter by status'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('governance.read')))",
            "docstring": "List policy conflicts.\n\nReturns pending and resolved policy conflicts.",
            "is_async": true,
            "line": 262
          },
          {
            "name": "get_boot_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get SPINE component health status (GAP-095).\n\nReturns health status of core governance components:\n- governance: Kill switch state\n- policy_engine: Policy evaluation engine\n- audit_store: Audit event storage\n- policy_facade: Policy facade availability",
            "is_async": true,
            "line": 292
          }
        ],
        "classes": [
          {
            "name": "KillSwitchRequest",
            "docstring": "Request to toggle kill switch.",
            "methods": [],
            "line": 56
          },
          {
            "name": "ModeRequest",
            "docstring": "Request to set governance mode.",
            "methods": [],
            "line": 62
          },
          {
            "name": "ConflictResolutionRequest",
            "docstring": "Request to resolve a policy conflict.",
            "methods": [],
            "line": 68
          },
          {
            "name": "GovernanceStateResponse",
            "docstring": "Governance state response.",
            "methods": [],
            "line": 75
          },
          {
            "name": "KillSwitchResponse",
            "docstring": "Kill switch operation response.",
            "methods": [],
            "line": 85
          },
          {
            "name": "BootStatusResponse",
            "docstring": "Boot status response.",
            "methods": [],
            "line": 96
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard.py",
        "file_path": "backend/app/hoc/api/cus/policies/guard.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 2484,
        "module_docstring": "Guard API - Customer Console Backend\n\nThis router provides endpoints for the Customer Console (guard.agenticverz.com).\nFocused on TRUST and CONTROL - customers can see what's protecting them and stop it if needed.\n\nEndpoints:\n- GET  /guard/status          - Protection status (am I safe?)\n- GET  /guard/snapshot/today  - Today's metrics\n- POST /guard/killswitch/activate   - Stop all traffic\n- POST /guard/killswitch/deactivate - Resume traffic\n- GET  /guard/incidents       - List incidents\n- GET  /guard/incidents/{id}  - Incident detail with timeline\n- POST /guard/incidents/{id}/acknowledge - Acknowledge incident\n- POST /guard/incidents/{id}/resolve     - Resolve incident\n- POST /guard/replay/{call_id} - Replay a call\n- GET  /guard/keys            - List API keys\n- POST /guard/keys/{id}/freeze   - Freeze key\n- POST /guard/keys/{id}/unfreeze - Unfreeze key\n- GET  /guard/settings        - Read-only settings",
        "functions": [
          {
            "name": "utc_now",
            "signature": "() -> datetime",
            "docstring": null,
            "is_async": false,
            "line": 271
          },
          {
            "name": "get_tenant_from_auth",
            "signature": "(session, tenant_id: str) -> dict",
            "docstring": "Get tenant or raise 404. Uses L4 registry dispatch for L2 first-principles purity.",
            "is_async": true,
            "line": 275
          },
          {
            "name": "get_guard_status",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Get protection status - \"Am I safe right now?\"\n\nReturns:\n- Freeze state\n- Active guardrails\n- 24h incident count\n- Last incident time\n\nCached for 5 seconds to reduce cross-region DB latency.",
            "is_async": true,
            "line": 300
          },
          {
            "name": "get_today_snapshot",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Get today's metrics - \"What did it cost/save me?\"\n\nCached for 10 seconds to reduce cross-region DB latency.",
            "is_async": true,
            "line": 393
          },
          {
            "name": "activate_killswitch",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Stop all traffic - Emergency kill switch.\n\nImmediate. All requests blocked until manually resumed.\n\nPIN-281: Uses L3 CustomerKillswitchAdapter for tenant-scoped operations.",
            "is_async": true,
            "line": 472
          },
          {
            "name": "deactivate_killswitch",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Resume traffic - Deactivate kill switch.\n\nGuardrails will continue protecting.\n\nPIN-281: Uses L3 CustomerKillswitchAdapter for tenant-scoped operations.",
            "is_async": true,
            "line": 501
          },
          {
            "name": "list_incidents",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), limit: int = Query(default=50, le=100), offset: int = Query(default=0), session = Depends(get_sync_session_dep))",
            "docstring": "List incidents - \"What did you stop for me?\"\n\nHuman narrative, not logs.\n\nPIN-281: Uses L3 CustomerIncidentsAdapter for tenant-scoped operations.",
            "is_async": true,
            "line": 532
          },
          {
            "name": "get_incident_detail",
            "signature": "(incident_id: str, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Get incident detail with timeline.\n\nOne-screen explanation readable at 2am.\n\nPIN-281: Uses L3 CustomerIncidentsAdapter with tenant isolation.",
            "is_async": true,
            "line": 578
          },
          {
            "name": "acknowledge_incident",
            "signature": "(incident_id: str, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Acknowledge an incident.\n\nPIN-281: Uses L3 CustomerIncidentsAdapter with tenant isolation.",
            "is_async": true,
            "line": 632
          },
          {
            "name": "resolve_incident",
            "signature": "(incident_id: str, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Resolve an incident.\n\nPIN-281: Uses L3 CustomerIncidentsAdapter with tenant isolation.",
            "is_async": true,
            "line": 653
          },
          {
            "name": "get_customer_incident_narrative",
            "signature": "(incident_id: str, token: CustomerToken = Depends(verify_console_token), session = Depends(get_sync_session_dep)) -> CustomerIncidentNarrativeDTO",
            "docstring": "GET /guard/incidents/{id}/narrative\n\nCustomer Incident Narrative - Calm, reassuring summary.\n\nM29 Category 5: Incident Console Contrast\n\nAnswers:\n- What happened? (plain language)\n- Did it affect me? (yes/no/some)\n- Is it fixed? (status + message)\n- Do I need to act? (only if necessary)\n\nIMPORTANT: Uses CALM vocabulary only.\n- No internal terminology (policy names, thresholds)\n- No cross-tenant data\n- No raw metrics that could cause panic",
            "is_async": true,
            "line": 679
          },
          {
            "name": "_generate_plain_title",
            "signature": "(incident: dict) -> str",
            "docstring": "Generate plain language title - no internal terminology.",
            "is_async": false,
            "line": 755
          },
          {
            "name": "_generate_calm_summary",
            "signature": "(incident: dict) -> str",
            "docstring": "Generate calm, reassuring summary - no internal terms.",
            "is_async": false,
            "line": 772
          },
          {
            "name": "_build_customer_impact",
            "signature": "(incident: dict) -> CustomerIncidentImpactDTO",
            "docstring": "Build impact assessment with calm vocabulary.",
            "is_async": false,
            "line": 796
          },
          {
            "name": "_build_customer_resolution",
            "signature": "(incident: dict) -> CustomerIncidentResolutionDTO",
            "docstring": "Build resolution status with reassuring message.",
            "is_async": false,
            "line": 834
          },
          {
            "name": "_build_customer_actions",
            "signature": "(incident: dict) -> list",
            "docstring": "Build customer actions - only if necessary.",
            "is_async": false,
            "line": 867
          },
          {
            "name": "replay_call",
            "signature": "(call_id: str, level: str = Query('logical', description='Determinism level: strict, logical, or semantic'), session = Depends(get_sync_session_dep), auth: AuthorityResult = Depends(require_replay_execute))",
            "docstring": "Replay a call - Trust builder.\n\nM23: Uses real ReplayValidator from replay_determinism.py\n\nDeterminism Levels:\n- strict: Byte-for-byte exact match (only works for cached/local)\n- logical: Policy decision equivalence (default - proves guardrails work)\n- semantic: Meaning-equivalent match (for content validation)\n\nShows:\n- Original outcome\n- Replay outcome\n- Policy decisions (same/different)\n- Model drift detection",
            "is_async": true,
            "line": 921
          },
          {
            "name": "list_api_keys",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "List API keys with status.\n\nCustomer can freeze/unfreeze individual keys.\n\nPIN-281: Uses L3 CustomerKeysAdapter for tenant-scoped operations.",
            "is_async": true,
            "line": 1247
          },
          {
            "name": "freeze_api_key",
            "signature": "(key_id: str, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Freeze an API key.\n\nPIN-281: Uses L3 CustomerKeysAdapter with tenant isolation.",
            "is_async": true,
            "line": 1286
          },
          {
            "name": "unfreeze_api_key",
            "signature": "(key_id: str, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Unfreeze an API key.\n\nPIN-281: Uses L3 CustomerKeysAdapter with tenant isolation.",
            "is_async": true,
            "line": 1307
          },
          {
            "name": "get_settings",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Get read-only settings.\n\nCustomers can see what's configured but can't change it.\nContact support to modify.\n\nIn demo mode (tenant_demo or non-existent tenant), returns demo defaults.",
            "is_async": true,
            "line": 1333
          },
          {
            "name": "search_incidents",
            "signature": "(request: IncidentSearchRequest, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Search incidents with filters - M23 component map spec.\n\nSupports:\n- Free text search in title/description\n- Filter by user_id (from related calls)\n- Filter by policy status (passed/failed)\n- Filter by severity\n- Filter by time range\n- Filter by model",
            "is_async": true,
            "line": 1524
          },
          {
            "name": "get_decision_timeline",
            "signature": "(incident_id: str, session = Depends(get_sync_session_dep))",
            "docstring": "Get decision timeline - M23 component map spec.\n\nReturns step-by-step trace:\n1. INPUT_RECEIVED - What the user asked\n2. CONTEXT_RETRIEVED - What data was fetched\n3. POLICY_EVALUATED - Each policy check (PASS/FAIL/WARN)\n4. MODEL_CALLED - LLM invocation\n5. OUTPUT_GENERATED - Final response\n6. LOGGED - Audit trail\n\nPlus root cause identification if policy failed.",
            "is_async": true,
            "line": 1663
          },
          {
            "name": "export_incident_evidence",
            "signature": "(incident_id: str, tenant_id: str = Query(..., description='Tenant ID'), include_replay: bool = Query(True, description='Include replay verification'), include_prevention: bool = Query(True, description='Include prevention proof'), is_demo: bool = Query(True, description='Add demo watermark'), session = Depends(get_sync_session_dep))",
            "docstring": "Export incident as a legal-grade PDF evidence report.\n\nThis document is designed to survive:\n- Legal review\n- Audit compliance\n- Executive briefing\n- Hostile questioning\n\nSections included:\n1. Executive Summary (for lawyers/leadership)\n2. Factual Reconstruction (pure evidence)\n3. Policy Evaluation Record\n4. Decision Timeline (deterministic trace)\n5. Replay Verification (cryptographic proof)\n6. Prevention Proof (counterfactual)\n7. Remediation & Controls\n8. Legal Attestation\n\nReturns: PDF file with Content-Disposition header",
            "is_async": true,
            "line": 2024
          },
          {
            "name": "onboarding_verify",
            "signature": "(request: OnboardingVerifyRequest, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "REAL safety verification for onboarding.\n\nThis endpoint:\n1. Fires a REAL request through the proxy (not simulated)\n2. Uses a prompt designed to trigger a guardrail\n3. Creates a REAL incident if blocked\n4. Sends a REAL alert if configured\n\nThe user will see:\n- A real API call being made\n- Real tokens being consumed (minimal)\n- A real incident in their console\n- A real alert (if Slack/email configured)\n\nTest types:\n- guardrail_block: Triggers prompt injection guardrail (blocked, no cost)\n- killswitch_demo: Shows what happens when kill switch fires",
            "is_async": true,
            "line": 2293
          }
        ],
        "classes": [
          {
            "name": "GuardStatus",
            "docstring": "Protection status response.",
            "methods": [],
            "line": 114
          },
          {
            "name": "TodaySnapshot",
            "docstring": "Today's metrics snapshot.",
            "methods": [],
            "line": 125
          },
          {
            "name": "IncidentSummary",
            "docstring": "Incident list item.",
            "methods": [],
            "line": 135
          },
          {
            "name": "IncidentEventResponse",
            "docstring": "Timeline event.",
            "methods": [],
            "line": 153
          },
          {
            "name": "IncidentDetailResponse",
            "docstring": "Full incident detail with timeline.",
            "methods": [],
            "line": 163
          },
          {
            "name": "ApiKeyResponse",
            "docstring": "API key for customer console.",
            "methods": [],
            "line": 170
          },
          {
            "name": "PaginatedResponse",
            "docstring": "Generic paginated response.",
            "methods": [],
            "line": 183
          },
          {
            "name": "GuardrailConfig",
            "docstring": "Guardrail configuration for settings page.",
            "methods": [],
            "line": 192
          },
          {
            "name": "TenantSettings",
            "docstring": "Read-only tenant settings.",
            "methods": [],
            "line": 205
          },
          {
            "name": "PolicyDecision",
            "docstring": "Policy decision for replay.",
            "methods": [],
            "line": 221
          },
          {
            "name": "ReplayCallSnapshot",
            "docstring": "Call snapshot for replay comparison.",
            "methods": [],
            "line": 230
          },
          {
            "name": "ReplayCertificate",
            "docstring": "M23: Cryptographic certificate proving deterministic replay.",
            "methods": [],
            "line": 241
          },
          {
            "name": "ReplayResult",
            "docstring": "Replay result response.",
            "methods": [],
            "line": 253
          },
          {
            "name": "IncidentSearchRequest",
            "docstring": "Search incidents with filters.",
            "methods": [],
            "line": 1420
          },
          {
            "name": "IncidentSearchResult",
            "docstring": "Search result item matching component map spec.",
            "methods": [],
            "line": 1434
          },
          {
            "name": "IncidentSearchResponse",
            "docstring": "Search response.",
            "methods": [],
            "line": 1448
          },
          {
            "name": "TimelineEvent",
            "docstring": "Decision timeline event - step by step policy evaluation.",
            "methods": [],
            "line": 1457
          },
          {
            "name": "PolicyEvaluation",
            "docstring": "Individual policy evaluation result.",
            "methods": [],
            "line": 1466
          },
          {
            "name": "CARERoutingInfo",
            "docstring": "M17 CARE routing information for decision timeline.",
            "methods": [],
            "line": 1476
          },
          {
            "name": "FailureCatalogMatch",
            "docstring": "M9 Failure Catalog match information.",
            "methods": [],
            "line": 1491
          },
          {
            "name": "DecisionTimelineResponse",
            "docstring": "Full decision timeline for an incident/call.",
            "methods": [],
            "line": 1503
          },
          {
            "name": "EvidenceExportRequest",
            "docstring": "Request for evidence report export.",
            "methods": [],
            "line": 2014
          },
          {
            "name": "OnboardingVerifyRequest",
            "docstring": "Request for onboarding safety verification.",
            "methods": [],
            "line": 2269
          },
          {
            "name": "OnboardingVerifyResponse",
            "docstring": "Response from onboarding verification.",
            "methods": [],
            "line": 2276
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "cast"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.adapters.customer_incidents_adapter",
            "names": [
              "get_customer_incidents_adapter"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.adapters.customer_keys_adapter",
            "names": [
              "get_customer_keys_adapter"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.adapters.customer_killswitch_adapter",
            "names": [
              "get_customer_killswitch_adapter"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "emit_authority_audit",
              "require_replay_execute"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "CustomerToken",
              "verify_console_token"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.contracts.guard",
            "names": [
              "CustomerIncidentActionDTO",
              "CustomerIncidentImpactDTO",
              "CustomerIncidentNarrativeDTO",
              "CustomerIncidentResolutionDTO"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.domain_enums",
            "names": [
              "IncidentSeverity"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.hoc.cus.hoc_spine.drivers.guard_write_driver",
            "names": [
              "GuardWriteDriver"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationResult",
              "get_operation_registry",
              "get_sync_session_dep"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "app.hoc.cus.logs.L5_schemas.determinism_types",
            "names": [
              "DeterminismLevel"
            ],
            "is_relative": false,
            "line": 83
          },
          {
            "module": "app.utils.guard_cache",
            "names": [
              "get_guard_cache"
            ],
            "is_relative": false,
            "line": 88
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 2006
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 2007
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard_policies.py",
        "file_path": "backend/app/hoc/api/cus/policies/guard_policies.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 128,
        "module_docstring": "Guard Policies API - Customer Console Policy Constraints Endpoint\n\nThis router provides endpoints for the Customer Console (guard.agenticverz.com).\nFocused on POLICY VISIBILITY - customers can see their constraints and limits.\n\nEndpoints:\n- GET  /guard/policies          - Policy constraints summary\n- GET  /guard/policies/guardrails/{id}  - Guardrail detail\n\nPIN-281 Promotion:\n- L4\u2192L3: customer_policies_adapter.py (boundary adapter)\n- L3\u2192L2: This file (API route)\n\nRule: One adapter per route. No business logic here.",
        "functions": [
          {
            "name": "get_policy_constraints",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID (required)'))",
            "docstring": "Get policy constraints for customer.\n\nReturns summary of:\n- Budget constraints (limit, usage, remaining)\n- Rate limits\n- Active guardrails\n\nCustomer can only see their own tenant's constraints (enforced by adapter).\n\nThis endpoint answers:\n- What are my limits?\n- How much have I used?\n- What protection is active?\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 57
          },
          {
            "name": "get_guardrail_detail",
            "signature": "(guardrail_id: str, tenant_id: str = Query(..., description='Tenant ID (required)'))",
            "docstring": "Get guardrail detail.\n\nReturns information about a specific guardrail:\n- Name and description\n- Whether it's enabled\n- Action on trigger (block, warn, log)\n\nNo threshold values exposed (internal implementation detail).\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 93
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.adapters.customer_policies_adapter",
            "names": [
              "CustomerGuardrail",
              "CustomerPolicyConstraints",
              "get_customer_policies_adapter"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "verify_console_token"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lifecycle.py",
        "file_path": "backend/app/hoc/api/cus/policies/lifecycle.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 401,
        "module_docstring": "Lifecycle API (L2)\n\nProvides lifecycle operations:\n- POST /lifecycle/agents (create agent)\n- GET /lifecycle/agents (list agents)\n- GET /lifecycle/agents/{id} (get agent)\n- POST /lifecycle/agents/{id}/start (start agent)\n- POST /lifecycle/agents/{id}/stop (stop agent)\n- POST /lifecycle/agents/{id}/terminate (terminate agent)\n- POST /lifecycle/runs (create run)\n- GET /lifecycle/runs (list runs)\n- GET /lifecycle/runs/{id} (get run)\n- POST /lifecycle/runs/{id}/pause (pause run)\n- POST /lifecycle/runs/{id}/resume (resume run)\n- POST /lifecycle/runs/{id}/cancel (cancel run)\n- GET /lifecycle/summary (lifecycle summary)\n\nThis is the ONLY facade for lifecycle operations.\nAll lifecycle APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> LifecycleFacade",
            "docstring": "Get the lifecycle facade.",
            "is_async": false,
            "line": 85
          },
          {
            "name": "create_agent",
            "signature": "(request: CreateAgentRequest, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.write')))",
            "docstring": "Create a new agent (GAP-131).",
            "is_async": true,
            "line": 96
          },
          {
            "name": "list_agents",
            "signature": "(state: Optional[str] = Query(None, description='Filter by state'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "List agents (GAP-131).\n\nReturns all agents for the tenant.",
            "is_async": true,
            "line": 116
          },
          {
            "name": "get_agent",
            "signature": "(agent_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "Get a specific agent (GAP-131).",
            "is_async": true,
            "line": 145
          },
          {
            "name": "start_agent",
            "signature": "(agent_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Start an agent (GAP-132).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 166
          },
          {
            "name": "stop_agent",
            "signature": "(agent_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Stop an agent (GAP-132).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 189
          },
          {
            "name": "terminate_agent",
            "signature": "(agent_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Terminate an agent (GAP-132).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 212
          },
          {
            "name": "create_run",
            "signature": "(request: CreateRunRequest, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.write')))",
            "docstring": "Create a new run (GAP-133).",
            "is_async": true,
            "line": 240
          },
          {
            "name": "list_runs",
            "signature": "(agent_id: Optional[str] = Query(None, description='Filter by agent'), state: Optional[str] = Query(None, description='Filter by state'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "List runs (GAP-133).\n\nReturns all runs for the tenant.",
            "is_async": true,
            "line": 263
          },
          {
            "name": "get_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "Get a specific run (GAP-133).",
            "is_async": true,
            "line": 294
          },
          {
            "name": "pause_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Pause a run (GAP-134).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 315
          },
          {
            "name": "resume_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Resume a paused run (GAP-135).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 338
          },
          {
            "name": "cancel_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Cancel a run (GAP-136).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 361
          },
          {
            "name": "get_summary",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "Get lifecycle summary.\n\nReturns summary of agents and runs for the tenant.",
            "is_async": true,
            "line": 389
          }
        ],
        "classes": [
          {
            "name": "CreateAgentRequest",
            "docstring": "Request to create an agent.",
            "methods": [],
            "line": 66
          },
          {
            "name": "CreateRunRequest",
            "docstring": "Request to create a run.",
            "methods": [],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.lifecycle_facade",
            "names": [
              "LifecycleFacade",
              "get_lifecycle_facade"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "logs.py",
        "file_path": "backend/app/hoc/api/cus/policies/logs.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1639,
        "module_docstring": "Unified Logs API (L2) - LOGS Domain V2\n\nCustomer-facing endpoints for viewing logs: audit ledger, LLM run records, and system records.\nAll requests are tenant-scoped via auth_context.\n\nTopics & O-Levels (per LOGS_DOMAIN_V2_CONTRACT.md):\n\nLLM_RUNS:\n- GET /logs/llm-runs                          \u2192 List runs\n- GET /logs/llm-runs/{run_id}/envelope        \u2192 O1 canonical record\n- GET /logs/llm-runs/{run_id}/trace           \u2192 O2 step-by-step trace\n- GET /logs/llm-runs/{run_id}/governance      \u2192 O3 policy interaction\n- GET /logs/llm-runs/{run_id}/replay          \u2192 O4 60-second window\n- GET /logs/llm-runs/{run_id}/export          \u2192 O5 evidence bundle\n\nSYSTEM_LOGS:\n- GET /logs/system                            \u2192 List events\n- GET /logs/system/{run_id}/snapshot          \u2192 O1 environment baseline\n- GET /logs/system/{run_id}/telemetry         \u2192 O2 (STUB)\n- GET /logs/system/{run_id}/events            \u2192 O3 infra events\n- GET /logs/system/{run_id}/replay            \u2192 O4 infra replay\n- GET /logs/system/audit                      \u2192 O5 infra attribution\n\nAUDIT:\n- GET /logs/audit                             \u2192 List entries\n- GET /logs/audit/identity                    \u2192 O1 identity lifecycle\n- GET /logs/audit/authorization               \u2192 O2 access decisions\n- GET /logs/audit/access                      \u2192 O3 log access audit\n- GET /logs/audit/integrity                   \u2192 O4 tamper detection\n- GET /logs/audit/exports                     \u2192 O5 compliance exports\n\nAll records are:\n- APPEND-ONLY (enforced by DB trigger)\n- WRITE-ONCE (no UPDATE, no DELETE)\n- Trust anchors for verification",
        "functions": [
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 132
          },
          {
            "name": "list_llm_run_records",
            "signature": "(request: Request, run_id: Annotated[Optional[str], Query(description='Filter by run ID')] = None, provider: Annotated[Optional[str], Query(description='Filter by provider')] = None, model: Annotated[Optional[str], Query(description='Filter by model')] = None, execution_status: Annotated[Optional[str], Query(description='Filter by status')] = None, is_synthetic: Annotated[Optional[bool], Query(description='Filter synthetic')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter created_at >=')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter created_at <=')] = None, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> LLMRunRecordsResponse",
            "docstring": "List LLM run records. READ-ONLY customer facade.",
            "is_async": true,
            "line": 516
          },
          {
            "name": "get_llm_run_envelope",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> LLMRunEnvelope",
            "docstring": "O1: Canonical immutable run record. READ-ONLY customer facade.",
            "is_async": true,
            "line": 593
          },
          {
            "name": "get_llm_run_trace",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> LLMRunTrace",
            "docstring": "O2: Step-by-step execution trace. READ-ONLY customer facade.",
            "is_async": true,
            "line": 656
          },
          {
            "name": "get_llm_run_governance",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> LLMRunGovernance",
            "docstring": "O3: Policy interaction trace. READ-ONLY customer facade.",
            "is_async": true,
            "line": 722
          },
          {
            "name": "get_llm_run_replay",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> LLMRunReplay",
            "docstring": "O4: 60-second replay window. READ-ONLY customer facade.",
            "is_async": true,
            "line": 783
          },
          {
            "name": "get_llm_run_export",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> LLMRunExport",
            "docstring": "O5: Export information. READ-ONLY customer facade.",
            "is_async": true,
            "line": 848
          },
          {
            "name": "list_system_records",
            "signature": "(request: Request, component: Annotated[Optional[str], Query(description='Filter by component')] = None, event_type: Annotated[Optional[str], Query(description='Filter by event type')] = None, severity: Annotated[Optional[str], Query(description='Filter by severity')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter created_at >=')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter created_at <=')] = None, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> SystemRecordsResponse",
            "docstring": "List system records. READ-ONLY customer facade.",
            "is_async": true,
            "line": 906
          },
          {
            "name": "get_system_snapshot",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> SystemSnapshot",
            "docstring": "O1: Environment baseline snapshot. READ-ONLY customer facade.",
            "is_async": true,
            "line": 974
          },
          {
            "name": "get_system_telemetry",
            "signature": "(request: Request, run_id: str) -> TelemetryStub",
            "docstring": "O2: Telemetry stub - producer not implemented. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1027
          },
          {
            "name": "get_system_events",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> SystemEvents",
            "docstring": "O3: Infra events affecting run. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1058
          },
          {
            "name": "get_system_replay",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> SystemReplay",
            "docstring": "O4: Infra replay window. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1120
          },
          {
            "name": "get_system_audit",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> SystemAudit",
            "docstring": "O5: Infra attribution. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1183
          },
          {
            "name": "list_audit_entries",
            "signature": "(request: Request, event_type: Annotated[Optional[str], Query(description='Filter by event type')] = None, entity_type: Annotated[Optional[str], Query(description='Filter by entity type')] = None, actor_type: Annotated[Optional[str], Query(description='Filter by actor type')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter created_at >=')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter created_at <=')] = None, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> AuditLedgerResponse",
            "docstring": "List audit entries. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1249
          },
          {
            "name": "get_audit_entry",
            "signature": "(request: Request, entry_id: str, session = Depends(get_session_dep)) -> AuditLedgerDetailItem",
            "docstring": "Get audit entry detail. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1316
          },
          {
            "name": "get_audit_identity",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, session = Depends(get_session_dep)) -> AuditIdentity",
            "docstring": "O1: Identity lifecycle. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1364
          },
          {
            "name": "get_audit_authorization",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, session = Depends(get_session_dep)) -> AuditAuthorization",
            "docstring": "O2: Authorization decisions. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1421
          },
          {
            "name": "get_audit_access",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, session = Depends(get_session_dep)) -> AuditAccess",
            "docstring": "O3: Log access audit. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1480
          },
          {
            "name": "get_audit_integrity",
            "signature": "(request: Request) -> AuditIntegrity",
            "docstring": "O4: Tamper detection. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1539
          },
          {
            "name": "get_audit_exports",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> AuditExports",
            "docstring": "O5: Compliance exports. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1587
          }
        ],
        "classes": [
          {
            "name": "EvidenceMetadata",
            "docstring": "Global metadata contract for all Logs responses.\n\nPer LOGS_DOMAIN_V2_CONTRACT.md, every Logs response MUST include this.\nAbsence is a contract violation.",
            "methods": [],
            "line": 89
          },
          {
            "name": "LLMRunEnvelope",
            "docstring": "O1: Canonical immutable run record.",
            "methods": [],
            "line": 161
          },
          {
            "name": "TraceStep",
            "docstring": "Individual trace step.",
            "methods": [],
            "line": 182
          },
          {
            "name": "LLMRunTrace",
            "docstring": "O2: Step-by-step trace.",
            "methods": [],
            "line": 194
          },
          {
            "name": "GovernanceEvent",
            "docstring": "Policy interaction event.",
            "methods": [],
            "line": 204
          },
          {
            "name": "LLMRunGovernance",
            "docstring": "O3: Policy interaction trace.",
            "methods": [],
            "line": 216
          },
          {
            "name": "ReplayEvent",
            "docstring": "Replay window event.",
            "methods": [],
            "line": 225
          },
          {
            "name": "LLMRunReplay",
            "docstring": "O4: 60-second replay window.",
            "methods": [],
            "line": 235
          },
          {
            "name": "LLMRunExport",
            "docstring": "O5: Export metadata.",
            "methods": [],
            "line": 246
          },
          {
            "name": "LLMRunRecordItem",
            "docstring": "Single LLM run record entry (list view).",
            "methods": [],
            "line": 256
          },
          {
            "name": "LLMRunRecordsResponse",
            "docstring": "Response envelope for LLM run records.",
            "methods": [],
            "line": 275
          },
          {
            "name": "SystemSnapshot",
            "docstring": "O1: Environment snapshot.",
            "methods": [],
            "line": 289
          },
          {
            "name": "TelemetryStub",
            "docstring": "O2: Telemetry stub response.",
            "methods": [],
            "line": 302
          },
          {
            "name": "SystemEvent",
            "docstring": "System event record.",
            "methods": [],
            "line": 312
          },
          {
            "name": "SystemEvents",
            "docstring": "O3: Infra events affecting run.",
            "methods": [],
            "line": 325
          },
          {
            "name": "SystemReplay",
            "docstring": "O4: Infra replay window.",
            "methods": [],
            "line": 334
          },
          {
            "name": "SystemAudit",
            "docstring": "O5: Infra attribution record.",
            "methods": [],
            "line": 344
          },
          {
            "name": "SystemRecordItem",
            "docstring": "Single system record entry.",
            "methods": [],
            "line": 352
          },
          {
            "name": "SystemRecordsResponse",
            "docstring": "Response envelope for system records.",
            "methods": [],
            "line": 366
          },
          {
            "name": "AuditLedgerItem",
            "docstring": "Single audit ledger entry.",
            "methods": [],
            "line": 380
          },
          {
            "name": "AuditLedgerDetailItem",
            "docstring": "Audit ledger entry with state snapshots.",
            "methods": [],
            "line": 393
          },
          {
            "name": "AuditLedgerResponse",
            "docstring": "Response envelope for audit ledger.",
            "methods": [],
            "line": 401
          },
          {
            "name": "IdentityEvent",
            "docstring": "Identity lifecycle event.",
            "methods": [],
            "line": 410
          },
          {
            "name": "AuditIdentity",
            "docstring": "O1: Identity lifecycle.",
            "methods": [],
            "line": 420
          },
          {
            "name": "AuthorizationDecision",
            "docstring": "Authorization decision record.",
            "methods": [],
            "line": 428
          },
          {
            "name": "AuditAuthorization",
            "docstring": "O2: Access decisions.",
            "methods": [],
            "line": 440
          },
          {
            "name": "AccessEvent",
            "docstring": "Log access event.",
            "methods": [],
            "line": 448
          },
          {
            "name": "AuditAccess",
            "docstring": "O3: Log access audit.",
            "methods": [],
            "line": 460
          },
          {
            "name": "IntegrityCheck",
            "docstring": "Integrity verification record.",
            "methods": [],
            "line": 468
          },
          {
            "name": "AuditIntegrity",
            "docstring": "O4: Tamper detection.",
            "methods": [],
            "line": 477
          },
          {
            "name": "ExportRecord",
            "docstring": "Export record.",
            "methods": [],
            "line": 484
          },
          {
            "name": "AuditExports",
            "docstring": "O5: Compliance exports.",
            "methods": [],
            "line": 497
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Literal",
              "Optional"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "monitors.py",
        "file_path": "backend/app/hoc/api/cus/policies/monitors.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 298,
        "module_docstring": "Monitors API (L2)\n\nProvides monitoring operations:\n- POST /monitors (create monitor)\n- GET /monitors (list monitors)\n- GET /monitors/{id} (get monitor)\n- PUT /monitors/{id} (update monitor)\n- DELETE /monitors/{id} (delete monitor)\n- POST /monitors/{id}/check (run health check)\n- GET /monitors/{id}/history (check history)\n- GET /monitors/status (overall status)\n\nThis is the ONLY facade for monitoring operations.\nAll monitor APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> MonitorsFacade",
            "docstring": "Get the monitors facade.",
            "is_async": false,
            "line": 89
          },
          {
            "name": "create_monitor",
            "signature": "(request: CreateMonitorRequest, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.write')))",
            "docstring": "Create a monitor (GAP-121).\n\n**Tier: REACT ($9)** - Monitor configuration.\n\nMonitor types:\n- http: HTTP endpoint monitoring\n- tcp: TCP port monitoring\n- dns: DNS resolution monitoring\n- heartbeat: Passive heartbeat monitoring\n- custom: Custom check implementation",
            "is_async": true,
            "line": 100
          },
          {
            "name": "list_monitors",
            "signature": "(monitor_type: Optional[str] = Query(None, description='Filter by type'), status: Optional[str] = Query(None, description='Filter by status'), enabled_only: bool = Query(False, description='Only enabled monitors'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.read')))",
            "docstring": "List monitors.",
            "is_async": true,
            "line": 134
          },
          {
            "name": "get_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.read')))",
            "docstring": "Get overall monitoring status (GAP-120).\n\nReturns aggregate health status across all monitors.",
            "is_async": true,
            "line": 165
          },
          {
            "name": "get_monitor",
            "signature": "(monitor_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.read')))",
            "docstring": "Get a specific monitor.",
            "is_async": true,
            "line": 181
          },
          {
            "name": "update_monitor",
            "signature": "(monitor_id: str, request: UpdateMonitorRequest, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.write')))",
            "docstring": "Update a monitor.",
            "is_async": true,
            "line": 202
          },
          {
            "name": "delete_monitor",
            "signature": "(monitor_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.write')))",
            "docstring": "Delete a monitor.",
            "is_async": true,
            "line": 231
          },
          {
            "name": "run_check",
            "signature": "(monitor_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.check')))",
            "docstring": "Run a health check (GAP-120).\n\nManually triggers a health check for the monitor.",
            "is_async": true,
            "line": 252
          },
          {
            "name": "get_history",
            "signature": "(monitor_id: str, limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.read')))",
            "docstring": "Get health check history.",
            "is_async": true,
            "line": 275
          }
        ],
        "classes": [
          {
            "name": "CreateMonitorRequest",
            "docstring": "Request to create a monitor.",
            "methods": [],
            "line": 61
          },
          {
            "name": "UpdateMonitorRequest",
            "docstring": "Request to update a monitor.",
            "methods": [],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.monitors_facade",
            "names": [
              "MonitorsFacade",
              "get_monitors_facade"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "notifications.py",
        "file_path": "backend/app/hoc/api/cus/policies/notifications.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 304,
        "module_docstring": "Notifications API (L2)\n\nProvides notification operations:\n- POST /notifications (send notification)\n- GET /notifications (list notifications)\n- GET /notifications/{id} (get notification)\n- POST /notifications/{id}/read (mark as read)\n- GET /notifications/channels (list channels)\n- GET /notifications/preferences (get preferences)\n- PUT /notifications/preferences (update preferences)\n\nThis is the ONLY facade for notification operations.\nAll notification APIs flow through this router.",
        "functions": [
          {
            "name": "send_notification",
            "signature": "(request: SendNotificationRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('notifications.send')))",
            "docstring": "Send a notification (GAP-109).\n\n**Tier: REACT ($9)** - Notification sending.\n\nChannels:\n- email: Email notifications\n- slack: Slack messages\n- webhook: Webhook callbacks\n- in_app: In-app notifications\n- sms: SMS messages (requires configuration)",
            "is_async": true,
            "line": 79
          },
          {
            "name": "list_notifications",
            "signature": "(channel: Optional[str] = Query(None, description='Filter by channel'), status: Optional[str] = Query(None, description='Filter by status'), recipient: Optional[str] = Query(None, description='Filter by recipient'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('notifications.read')))",
            "docstring": "List notifications for the tenant.",
            "is_async": true,
            "line": 121
          },
          {
            "name": "list_channels",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "List available notification channels.",
            "is_async": true,
            "line": 162
          },
          {
            "name": "get_preferences",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('notifications.read')))",
            "docstring": "Get notification preferences for the current user.",
            "is_async": true,
            "line": 187
          },
          {
            "name": "update_preferences",
            "signature": "(request: UpdatePreferencesRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('notifications.write')))",
            "docstring": "Update notification preferences for the current user.",
            "is_async": true,
            "line": 215
          },
          {
            "name": "get_notification",
            "signature": "(notification_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('notifications.read')))",
            "docstring": "Get a specific notification.",
            "is_async": true,
            "line": 246
          },
          {
            "name": "mark_as_read",
            "signature": "(notification_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('notifications.write')))",
            "docstring": "Mark a notification as read.",
            "is_async": true,
            "line": 277
          }
        ],
        "classes": [
          {
            "name": "SendNotificationRequest",
            "docstring": "Request to send notification.",
            "methods": [],
            "line": 57
          },
          {
            "name": "UpdatePreferencesRequest",
            "docstring": "Request to update notification preferences.",
            "methods": [],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "override.py",
        "file_path": "backend/app/hoc/api/cus/policies/override.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 353,
        "module_docstring": "Limit Override API (PIN-LIM-05)\n\nTemporary limit override request endpoints.\n\nAllows authorized users to request temporary increases to limits,\nwith approval workflow and automatic expiry.\n\nEndpoints:\n    POST /limits/overrides         \u2192 Request new override\n    GET  /limits/overrides         \u2192 List overrides for tenant\n    GET  /limits/overrides/{id}    \u2192 Get specific override\n    DELETE /limits/overrides/{id}  \u2192 Cancel override",
        "functions": [
          {
            "name": "create_override",
            "signature": "(request: Request, body: CreateOverrideRequest, session = Depends(get_session_dep)) -> OverrideDetail",
            "docstring": "Request a temporary limit override.\n\n- Requires justification (reason)\n- Maximum 5 active overrides per tenant\n- Maximum duration: 168 hours (1 week)\n- Cannot stack multiple overrides on same limit",
            "is_async": true,
            "line": 122
          },
          {
            "name": "list_overrides",
            "signature": "(request: Request, status: Optional[str] = Query(default=None, description='Filter by status'), limit: int = Query(default=20, ge=1, le=100), offset: int = Query(default=0, ge=0), session = Depends(get_session_dep)) -> OverrideListResponse",
            "docstring": "List overrides for the tenant.",
            "is_async": true,
            "line": 186
          },
          {
            "name": "get_override",
            "signature": "(request: Request, override_id: str, session = Depends(get_session_dep)) -> OverrideDetail",
            "docstring": "Get override by ID.",
            "is_async": true,
            "line": 234
          },
          {
            "name": "cancel_override",
            "signature": "(request: Request, override_id: str, session = Depends(get_session_dep)) -> OverrideDetail",
            "docstring": "Cancel a pending or active override.",
            "is_async": true,
            "line": 274
          },
          {
            "name": "_to_detail",
            "signature": "(result: LimitOverrideResponse) -> OverrideDetail",
            "docstring": "Convert service response to API response.",
            "is_async": false,
            "line": 318
          },
          {
            "name": "_to_list_item",
            "signature": "(result: LimitOverrideResponse) -> OverrideListItem",
            "docstring": "Convert service response to list item.",
            "is_async": false,
            "line": 340
          }
        ],
        "classes": [
          {
            "name": "CreateOverrideRequest",
            "docstring": "Request to create a limit override.",
            "methods": [],
            "line": 54
          },
          {
            "name": "OverrideListItem",
            "docstring": "Override summary for list view.",
            "methods": [],
            "line": 65
          },
          {
            "name": "OverrideDetail",
            "docstring": "Full override details.",
            "methods": [],
            "line": 80
          },
          {
            "name": "OverrideListResponse",
            "docstring": "Response for override list.",
            "methods": [],
            "line": 101
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.schemas.limits.overrides",
            "names": [
              "LimitOverrideRequest",
              "LimitOverrideResponse",
              "OverrideStatus"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policies.py",
        "file_path": "backend/app/hoc/api/cus/policies/policies.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1658,
        "module_docstring": "Unified Policies API (L2)\n\nCustomer-facing endpoints for viewing policy rules and limits.\nAll requests are tenant-scoped via auth_context.\n\nEndpoints:\n- GET /policies/rules           \u2192 O2 list of policy rules\n- GET /policies/rules/{rule_id} \u2192 O3 rule detail\n- GET /policies/limits          \u2192 O2 list of limits\n- GET /policies/limits/{limit_id} \u2192 O3 limit detail\n\nArchitecture:\n- ONE facade for all POLICIES needs (rules + limits)\n- Queries PolicyRule, PolicyRuleIntegrity, Limit, LimitIntegrity tables\n- Tenant isolation via auth_context (not header)\n- SDSR validates this same production API",
        "functions": [
          {
            "name": "require_preflight",
            "signature": "() -> None",
            "docstring": "Guard for preflight-only endpoints (O4, O5).",
            "is_async": false,
            "line": 62
          },
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 202
          },
          {
            "name": "list_policy_rules",
            "signature": "(request: Request, status: Annotated[str, Query(description='Rule status: ACTIVE or RETIRED', pattern='^(ACTIVE|RETIRED)$')] = 'ACTIVE', enforcement_mode: Annotated[Optional[str], Query(description='Filter by enforcement mode: BLOCK, WARN, AUDIT, DISABLED', pattern='^(BLOCK|WARN|AUDIT|DISABLED)$')] = None, scope: Annotated[Optional[str], Query(description='Filter by scope: GLOBAL, TENANT, PROJECT, AGENT', pattern='^(GLOBAL|TENANT|PROJECT|AGENT)$')] = None, source: Annotated[Optional[str], Query(description='Filter by source: MANUAL, SYSTEM, LEARNED', pattern='^(MANUAL|SYSTEM|LEARNED)$')] = None, rule_type: Annotated[Optional[str], Query(description='Filter by rule type: SYSTEM, SAFETY, ETHICAL, TEMPORAL (PIN-411 Gap Closure)', pattern='^(SYSTEM|SAFETY|ETHICAL|TEMPORAL)$')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter by created_at >= value')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter by created_at <= value')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max rules to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of rules to skip')] = 0, session = Depends(get_session_dep)) -> RulesListResponse",
            "docstring": "List policy rules with unified query filters. READ-ONLY.",
            "is_async": true,
            "line": 241
          },
          {
            "name": "get_policy_rule_detail",
            "signature": "(request: Request, rule_id: str, session = Depends(get_session_dep)) -> PolicyRuleDetailResponse",
            "docstring": "Get policy rule detail (O3). Tenant isolation enforced.",
            "is_async": true,
            "line": 360
          },
          {
            "name": "list_limits",
            "signature": "(request: Request, category: Annotated[str, Query(alias='type', description='Limit category: BUDGET, RATE, or THRESHOLD', pattern='^(BUDGET|RATE|THRESHOLD)$')] = 'BUDGET', status: Annotated[str, Query(description='Limit status: ACTIVE or DISABLED', pattern='^(ACTIVE|DISABLED)$')] = 'ACTIVE', scope: Annotated[Optional[str], Query(description='Filter by scope: GLOBAL, TENANT, PROJECT, AGENT, PROVIDER', pattern='^(GLOBAL|TENANT|PROJECT|AGENT|PROVIDER)$')] = None, enforcement: Annotated[Optional[str], Query(description='Filter by enforcement: BLOCK, WARN, REJECT, QUEUE, DEGRADE, ALERT', pattern='^(BLOCK|WARN|REJECT|QUEUE|DEGRADE|ALERT)$')] = None, limit_type: Annotated[Optional[str], Query(description='Filter by limit_type. Supports prefix match, e.g. RUNS_*, TOKENS_*, RISK_CEILING, COOLDOWN (PIN-411 Gap Closure)')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter by created_at >= value')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter by created_at <= value')] = None, max_limit: Annotated[int, Query(ge=1, le=100, alias='limit', description='Max limits to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of limits to skip')] = 0, session = Depends(get_session_dep)) -> LimitsListResponse",
            "docstring": "List limits with unified query filters. READ-ONLY.",
            "is_async": true,
            "line": 432
          },
          {
            "name": "get_limit_detail",
            "signature": "(request: Request, limit_id: str, session = Depends(get_session_dep)) -> LimitDetailResponse",
            "docstring": "Get limit detail (O3). Tenant isolation enforced.",
            "is_async": true,
            "line": 555
          },
          {
            "name": "get_rule_evidence",
            "signature": "(request: Request, rule_id: str) -> dict[str, Any]",
            "docstring": "Get rule evidence (O4). Preflight console only.",
            "is_async": true,
            "line": 625
          },
          {
            "name": "get_limit_evidence",
            "signature": "(request: Request, limit_id: str) -> dict[str, Any]",
            "docstring": "Get limit evidence (O4). Preflight console only.",
            "is_async": true,
            "line": 651
          },
          {
            "name": "list_lessons",
            "signature": "(request: Request, lesson_type: Annotated[Optional[str], Query(description='Filter by type: failure, near_threshold, critical_success', pattern='^(failure|near_threshold|critical_success)$')] = None, status: Annotated[Optional[str], Query(description='Filter by status: pending, converted_to_draft, deferred, dismissed', pattern='^(pending|converted_to_draft|deferred|dismissed)$')] = None, severity: Annotated[Optional[str], Query(description='Filter by severity: CRITICAL, HIGH, MEDIUM, LOW', pattern='^(CRITICAL|HIGH|MEDIUM|LOW)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max lessons to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of lessons to skip')] = 0, session = Depends(get_session_dep)) -> LessonsListResponse",
            "docstring": "List lessons learned (O2). READ-ONLY customer facade.",
            "is_async": true,
            "line": 732
          },
          {
            "name": "get_lesson_stats",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> LessonStatsResponse",
            "docstring": "Get lesson statistics (O1). READ-ONLY customer facade.",
            "is_async": true,
            "line": 813
          },
          {
            "name": "get_lesson_detail",
            "signature": "(request: Request, lesson_id: str, session = Depends(get_session_dep)) -> LessonDetailResponse",
            "docstring": "Get lesson detail (O3). READ-ONLY customer facade.",
            "is_async": true,
            "line": 848
          },
          {
            "name": "get_policy_state",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> PolicyStateResponse",
            "docstring": "Get policy layer state (ACT-O4). Customer facade.",
            "is_async": true,
            "line": 920
          },
          {
            "name": "get_policy_metrics",
            "signature": "(request: Request, hours: Annotated[int, Query(ge=1, le=720, description='Time window in hours')] = 24, session = Depends(get_session_dep)) -> PolicyMetricsResponse",
            "docstring": "Get policy metrics (ACT-O5). Customer facade.",
            "is_async": true,
            "line": 987
          },
          {
            "name": "list_policy_conflicts",
            "signature": "(request: Request, policy_id: Annotated[Optional[str], Query(description='Filter to conflicts involving this policy')] = None, severity: Annotated[Optional[str], Query(description='Filter by severity: BLOCKING, WARNING')] = None, include_resolved: Annotated[bool, Query(description='Include resolved conflicts')] = False, session = Depends(get_session_dep)) -> ConflictsListResponse",
            "docstring": "Detect policy conflicts (DFT-O4). Uses PolicyConflictEngine via facade.",
            "is_async": true,
            "line": 1078
          },
          {
            "name": "get_policy_dependencies",
            "signature": "(request: Request, policy_id: Annotated[Optional[str], Query(description='Filter to dependencies involving this policy')] = None, session = Depends(get_session_dep)) -> DependencyGraphResponse",
            "docstring": "Get policy dependency graph (DFT-O5). Uses PolicyDependencyEngine via facade.",
            "is_async": true,
            "line": 1214
          },
          {
            "name": "list_policy_violations",
            "signature": "(request: Request, violation_type: Annotated[Optional[str], Query(description='Filter by type: cost, quota, rate, temporal, safety, ethical', pattern='^(cost|quota|rate|temporal|safety|ethical)$')] = None, source: Annotated[Optional[str], Query(description='Filter by source: guard, sim, runtime, cost (PIN-411 Gap Closure)', pattern='^(guard|sim|runtime|cost)$')] = None, severity_min: Annotated[Optional[float], Query(ge=0.0, le=1.0, description='Minimum severity (0.0-1.0)')] = None, violation_kind: Annotated[Optional[str], Query(description='Filter by violation kind: STANDARD, ANOMALY, DIVERGENCE (PIN-411 Gap Closure)', pattern='^(STANDARD|ANOMALY|DIVERGENCE)$')] = None, hours: Annotated[int, Query(ge=1, le=720, description='Time window in hours')] = 24, include_synthetic: Annotated[bool, Query(description='Include synthetic/simulated')] = False, limit: Annotated[int, Query(ge=1, le=100, description='Max items')] = 50, offset: Annotated[int, Query(ge=0, description='Offset')] = 0, session = Depends(get_session_dep)) -> ViolationsListResponse",
            "docstring": "List policy violations (VIO-O1). Unified customer facade.",
            "is_async": true,
            "line": 1338
          },
          {
            "name": "list_budget_definitions",
            "signature": "(request: Request, scope: Annotated[Optional[str], Query(description='Filter by scope: GLOBAL, TENANT, PROJECT, AGENT', pattern='^(GLOBAL|TENANT|PROJECT|AGENT)$')] = None, status: Annotated[str, Query(description='Filter by status: ACTIVE, DISABLED', pattern='^(ACTIVE|DISABLED)$')] = 'ACTIVE', limit: Annotated[int, Query(ge=1, le=100)] = 20, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> BudgetsListResponse",
            "docstring": "List budget definitions (THR-O2). Customer facade.",
            "is_async": true,
            "line": 1466
          },
          {
            "name": "list_policy_requests",
            "signature": "(request: Request, status: Annotated[str, Query(description='Filter by status: draft, approved, rejected (default: draft)', pattern='^(draft|approved|rejected)$')] = 'draft', proposal_type: Annotated[Optional[str], Query(description='Filter by proposal type: rate_limit, cost_cap, retry_policy')] = None, days_old: Annotated[Optional[int], Query(ge=1, le=365, description='Filter to requests older than N days')] = None, include_synthetic: Annotated[bool, Query()] = False, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> PolicyRequestsListResponse",
            "docstring": "List pending policy requests (ACT-O3). Customer facade.",
            "is_async": true,
            "line": 1578
          }
        ],
        "classes": [
          {
            "name": "PolicyRuleSummary",
            "docstring": "O2 Result Shape for policy rules.",
            "methods": [],
            "line": 79
          },
          {
            "name": "RulesListResponse",
            "docstring": "GET /rules response (O2).",
            "methods": [],
            "line": 96
          },
          {
            "name": "PolicyRuleDetailResponse",
            "docstring": "GET /rules/{rule_id} response (O3).",
            "methods": [],
            "line": 105
          },
          {
            "name": "LimitSummary",
            "docstring": "O2 Result Shape for limits.",
            "methods": [],
            "line": 132
          },
          {
            "name": "LimitsListResponse",
            "docstring": "GET /limits response (O2).",
            "methods": [],
            "line": 152
          },
          {
            "name": "LimitDetailResponse",
            "docstring": "GET /limits/{limit_id} response (O3).",
            "methods": [],
            "line": 161
          },
          {
            "name": "LessonSummaryResponse",
            "docstring": "O2 Result Shape for lessons.",
            "methods": [],
            "line": 673
          },
          {
            "name": "LessonsListResponse",
            "docstring": "GET /lessons response (O2).",
            "methods": [],
            "line": 686
          },
          {
            "name": "LessonDetailResponse",
            "docstring": "GET /lessons/{id} response (O3).",
            "methods": [],
            "line": 695
          },
          {
            "name": "LessonStatsResponse",
            "docstring": "Lesson statistics response.",
            "methods": [],
            "line": 715
          },
          {
            "name": "PolicyStateResponse",
            "docstring": "Policy layer state summary (ACT-O4).",
            "methods": [],
            "line": 899
          },
          {
            "name": "PolicyMetricsResponse",
            "docstring": "Policy enforcement metrics (ACT-O5).",
            "methods": [],
            "line": 965
          },
          {
            "name": "PolicyConflictResponse",
            "docstring": "Policy conflict summary (DFT-O4 spec).",
            "methods": [],
            "line": 1037
          },
          {
            "name": "ConflictsListResponse",
            "docstring": "GET /conflicts response (DFT-O4).",
            "methods": [],
            "line": 1051
          },
          {
            "name": "PolicyDependencyRelation",
            "docstring": "A dependency relationship detail.",
            "methods": [],
            "line": 1150
          },
          {
            "name": "PolicyNodeResponse",
            "docstring": "A node in the dependency graph (DFT-O5 spec).",
            "methods": [],
            "line": 1159
          },
          {
            "name": "PolicyDependencyEdge",
            "docstring": "A dependency edge in the graph.",
            "methods": [],
            "line": 1172
          },
          {
            "name": "DependencyGraphResponse",
            "docstring": "GET /dependencies response (DFT-O5).",
            "methods": [],
            "line": 1183
          },
          {
            "name": "PolicyViolationSummary",
            "docstring": "Policy violation summary (VIO-O1).",
            "methods": [],
            "line": 1305
          },
          {
            "name": "ViolationsListResponse",
            "docstring": "GET /violations response (VIO-O1).",
            "methods": [],
            "line": 1320
          },
          {
            "name": "BudgetDefinitionSummary",
            "docstring": "Budget definition summary (THR-O2).",
            "methods": [],
            "line": 1435
          },
          {
            "name": "BudgetsListResponse",
            "docstring": "GET /budgets response (THR-O2).",
            "methods": [],
            "line": 1449
          },
          {
            "name": "PolicyRequestSummary",
            "docstring": "Summary of a pending policy request (draft proposal).",
            "methods": [],
            "line": 1544
          },
          {
            "name": "PolicyRequestsListResponse",
            "docstring": "Response for policy requests list (ACT-O3).",
            "methods": [],
            "line": 1558
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [
          {
            "name": "_CURRENT_ENVIRONMENT",
            "line": 59
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "policy.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 2268,
        "module_docstring": "Policy API Endpoints (M5)\n\nProvides:\n1. Policy sandbox evaluation (/policy/eval)\n2. Approval workflow endpoints (/policy/requests/*)\n3. Webhook callbacks for async approvals\n\nIntegrates with:\n- PolicyEnforcer from workflow/policies.py\n- PolicyApprovalLevel and ApprovalRequest from db.py\n- Workflow metrics for observability\n- CostSim V2 for simulation\n\nNOTE: Policy subsystem MUST use AsyncSession - async endpoints + M17/M19 routing.\n      Do NOT import sync Session from sqlmodel. See test_m19_policy.py guardrail tests.\n\nTier Gating (M32 - PIN-158):\n- PREVENT ($199): Policy evaluation sandbox (pre-execution decisions)\n- ASSIST ($1.5k+): Approval workflows (advanced orchestration)",
        "functions": [
          {
            "name": "_get_policy_adapter",
            "signature": "()",
            "docstring": "Get the L3 policy adapter.\n\nThis is the ONLY way L2 should access policy functionality.\nF-P-RULE-1: Policy Decisions Live Only in L4.",
            "is_async": false,
            "line": 81
          },
          {
            "name": "_record_policy_decision",
            "signature": "(decision: str, policy_type: str) -> None",
            "docstring": "Record policy decision metric via L3 adapter.",
            "is_async": false,
            "line": 99
          },
          {
            "name": "_record_capability_violation",
            "signature": "(violation_type: str, skill_id: str, tenant_id: Optional[str] = None) -> None",
            "docstring": "Record capability violation metric via L3 adapter.",
            "is_async": false,
            "line": 105
          },
          {
            "name": "_record_budget_rejection",
            "signature": "(resource_type: str, skill_id: str) -> None",
            "docstring": "Record budget rejection metric via L3 adapter.",
            "is_async": false,
            "line": 111
          },
          {
            "name": "_record_approval_request_created",
            "signature": "(policy_type: str) -> None",
            "docstring": "Record approval request creation metric via L3 adapter.",
            "is_async": false,
            "line": 117
          },
          {
            "name": "_record_approval_action",
            "signature": "(result: str) -> None",
            "docstring": "Record approval action metric via L3 adapter.",
            "is_async": false,
            "line": 123
          },
          {
            "name": "_record_approval_escalation",
            "signature": "() -> None",
            "docstring": "Record approval escalation metric via L3 adapter.",
            "is_async": false,
            "line": 129
          },
          {
            "name": "_record_webhook_fallback",
            "signature": "() -> None",
            "docstring": "Record webhook fallback metric via L3 adapter.",
            "is_async": false,
            "line": 135
          },
          {
            "name": "_check_rate_limit",
            "signature": "(tenant_id: str, endpoint: str = 'policy') -> None",
            "docstring": "Check rate limit for tenant. Raises HTTPException if exceeded.\n\nArgs:\n    tenant_id: Tenant identifier for rate limiting\n    endpoint: Endpoint category for different limits\n\nRaises:\n    HTTPException: 429 if rate limit exceeded",
            "is_async": false,
            "line": 282
          },
          {
            "name": "_get_policy_version",
            "signature": "() -> str",
            "docstring": "Get current policy version.",
            "is_async": false,
            "line": 326
          },
          {
            "name": "_hash_webhook_secret",
            "signature": "(secret: str) -> str",
            "docstring": "Hash webhook secret for storage.",
            "is_async": false,
            "line": 331
          },
          {
            "name": "_get_approval_level_config",
            "signature": "(session, policy_type: PolicyType, tenant_id: str, agent_id: Optional[str] = None, skill_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Get approval level configuration from PolicyApprovalLevel table.\n\nUses L4 registry dispatch to maintain L2 purity (no session.execute).",
            "is_async": true,
            "line": 336
          },
          {
            "name": "_simulate_cost",
            "signature": "(skill_id: str, tenant_id: str, payload: Dict[str, Any]) -> Optional[int]",
            "docstring": "Simulate cost for a skill execution via L3 adapter.\n\nPhase F-3: This replaces the direct L5 CostSimulator import.\nF-P-RULE-4: No Dual Ownership - CostSimulator logic stays intact in L5.",
            "is_async": true,
            "line": 380
          },
          {
            "name": "_check_policy_violations",
            "signature": "(skill_id: str, tenant_id: str, agent_id: Optional[str], payload: Dict[str, Any], simulated_cost: Optional[int]) -> List[Dict[str, Any]]",
            "docstring": "Check for policy violations via L3 adapter.\n\nPhase F-3: This replaces the direct L5 PolicyEnforcer import.\nF-P-RULE-1: Policy Decisions Live Only in L4 - L4 handles enforcement.\nF-P-RULE-2: Metrics Are Effects - L4 emits metrics via L5.",
            "is_async": true,
            "line": 395
          },
          {
            "name": "_compute_webhook_signature",
            "signature": "(payload: str, secret: str) -> str",
            "docstring": "Compute HMAC-SHA256 signature for webhook.",
            "is_async": false,
            "line": 415
          },
          {
            "name": "_send_webhook",
            "signature": "(url: str, payload: Dict[str, Any], secret: Optional[str] = None, key_version: Optional[str] = None, retry_count: int = 0) -> bool",
            "docstring": "Send webhook callback with retry logic and key versioning.\n\nArgs:\n    url: Webhook endpoint URL\n    payload: JSON payload to send\n    secret: HMAC secret for signing\n    key_version: Version of the key used for signing (for rotation support)\n    retry_count: Current retry attempt\n\nReturns:\n    True if webhook delivered successfully",
            "is_async": true,
            "line": 422
          },
          {
            "name": "verify_webhook_signature",
            "signature": "(body: str, signature: str, key_version: str, secrets: Dict[str, str]) -> bool",
            "docstring": "Verify webhook signature with version support for rotation.\n\nDuring key rotation, accepts signatures from:\n1. Current key version\n2. Any version in grace period (WEBHOOK_KEY_GRACE_VERSIONS)\n\nArgs:\n    body: Raw request body\n    signature: Signature from X-Webhook-Signature header (sha256=...)\n    key_version: Version from X-Webhook-Key-Version header\n    secrets: Dict mapping version -> secret\n\nReturns:\n    True if signature is valid",
            "is_async": false,
            "line": 477
          },
          {
            "name": "evaluate_policy",
            "signature": "(request: PolicyEvalRequest, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('policy.audit'))) -> PolicyEvalResponse",
            "docstring": "Sandbox evaluation of policy for a skill execution.\n\n**Tier: PREVENT ($199)** - Pre-execution policy evaluation. \"You stop the fire.\"",
            "is_async": true,
            "line": 521
          },
          {
            "name": "create_approval_request",
            "signature": "(request: ApprovalRequestCreate, background_tasks: BackgroundTasks, session = Depends(get_session_dep)) -> ApprovalRequestResponse",
            "docstring": "Create a new approval request (persisted to DB).",
            "is_async": true,
            "line": 596
          },
          {
            "name": "get_approval_request",
            "signature": "(request_id: str, session = Depends(get_session_dep)) -> ApprovalStatusResponse",
            "docstring": "Get the current status of an approval request.",
            "is_async": true,
            "line": 687
          },
          {
            "name": "_check_approver_authorization",
            "signature": "(approver_id: str, level: int, tenant_id: Optional[str] = None) -> None",
            "docstring": "RBAC: Verify approver has permission to approve at the given level.\n\nUses the RBAC module when RBAC_ENABLED=true, otherwise allows all approvals.\n\nApproval Levels:\n- Level 1-2: Any authenticated user (team_member, engineer)\n- Level 3: Team lead, senior_engineer, tech_lead\n- Level 4: Manager, director, policy_admin\n- Level 5: Owner override (requires audit)\n\nRaises:\n    HTTPException: If approver lacks required permissions",
            "is_async": false,
            "line": 762
          },
          {
            "name": "approve_request",
            "signature": "(request_id: str, action: ApprovalAction, background_tasks: BackgroundTasks, session = Depends(get_session_dep)) -> ApprovalStatusResponse",
            "docstring": "Approve an approval request.",
            "is_async": true,
            "line": 836
          },
          {
            "name": "reject_request",
            "signature": "(request_id: str, action: ApprovalAction, background_tasks: BackgroundTasks, session = Depends(get_session_dep)) -> ApprovalStatusResponse",
            "docstring": "Reject an approval request.",
            "is_async": true,
            "line": 963
          },
          {
            "name": "list_approval_requests",
            "signature": "(status: Optional[ApprovalStatus] = None, tenant_id: Optional[str] = None, limit: int = 50, offset: int = 0, session = Depends(get_session_dep)) -> List[ApprovalStatusResponse]",
            "docstring": "List approval requests with optional filtering.",
            "is_async": true,
            "line": 1057
          },
          {
            "name": "run_escalation_check",
            "signature": "(session) -> int",
            "docstring": "Check for pending requests that need escalation.\nCalled by external scheduler (cron/celery).",
            "is_async": true,
            "line": 1154
          },
          {
            "name": "run_escalation_task",
            "signature": "()",
            "docstring": "Entry point for scheduled escalation check.\nCan be called from cron, celery, or APScheduler.",
            "is_async": false,
            "line": 1254
          },
          {
            "name": "_build_policy_metadata_from_rule",
            "signature": "(rule) -> PolicyMetadata",
            "docstring": "Build PolicyMetadata from a PolicyRule model instance.\n\nMaps available model fields to governance metadata schema.\nFields not in the model are left as None (to be populated when\nthe underlying schema evolves).",
            "is_async": false,
            "line": 1334
          },
          {
            "name": "_build_policy_metadata_from_limit",
            "signature": "(limit) -> PolicyMetadata",
            "docstring": "Build PolicyMetadata from a Limit model instance.\n\nMaps available model fields to governance metadata schema.",
            "is_async": false,
            "line": 1355
          },
          {
            "name": "_build_policy_metadata_from_violation",
            "signature": "(v) -> PolicyMetadata",
            "docstring": "Build PolicyMetadata from a violation object (from policy engine).\n\nViolations are system-generated enforcement events.",
            "is_async": false,
            "line": 1374
          },
          {
            "name": "_build_policy_metadata_from_lesson",
            "signature": "(lesson: dict) -> PolicyMetadata",
            "docstring": "Build PolicyMetadata from a lesson dict (from lessons_learned_engine).\n\nMaps available dict fields to governance metadata schema.",
            "is_async": false,
            "line": 1393
          },
          {
            "name": "get_active_policies",
            "signature": "(scope: Optional[str] = None, enforcement_mode: Optional[str] = None, limit: int = 50, offset: int = 0, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> ActivePoliciesResponse",
            "docstring": "V2 Facade: What governs execution now?",
            "is_async": true,
            "line": 1573
          },
          {
            "name": "get_active_policy_detail",
            "signature": "(policy_id: str, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> dict",
            "docstring": "V2 Facade: Policy detail for cross-domain navigation.",
            "is_async": true,
            "line": 1654
          },
          {
            "name": "get_policy_library",
            "signature": "(status: Optional[str] = None, rule_type: Optional[str] = None, limit: int = 50, offset: int = 0, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> PolicyLibraryResponse",
            "docstring": "V2 Facade: What patterns are available?",
            "is_async": true,
            "line": 1725
          },
          {
            "name": "get_policy_lessons",
            "signature": "(status: Optional[str] = None, lesson_type: Optional[str] = None, limit: int = 50, offset: int = 0, ctx: TenantContext = Depends(get_tenant_context)) -> LessonsResponse",
            "docstring": "V2 Facade: What governance emerged?",
            "is_async": true,
            "line": 1812
          },
          {
            "name": "get_policy_lesson_detail",
            "signature": "(lesson_id: str, ctx: TenantContext = Depends(get_tenant_context)) -> dict",
            "docstring": "V2 Facade: Lesson detail for cross-domain navigation.",
            "is_async": true,
            "line": 1898
          },
          {
            "name": "get_policy_thresholds",
            "signature": "(limit_category: Optional[str] = None, scope: Optional[str] = None, status: str = 'ACTIVE', limit: int = 50, offset: int = 0, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> ThresholdsResponse",
            "docstring": "V2 Facade: What limits are enforced?",
            "is_async": true,
            "line": 1973
          },
          {
            "name": "get_policy_threshold_detail",
            "signature": "(threshold_id: str, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> dict",
            "docstring": "V2 Facade: Threshold detail for cross-domain navigation.",
            "is_async": true,
            "line": 2054
          },
          {
            "name": "get_policy_violations_v2",
            "signature": "(violation_type: Optional[str] = None, severity_min: Optional[float] = None, hours: int = 24, limit: int = 50, offset: int = 0, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> ViolationsResponse",
            "docstring": "V2 Facade: What enforcement occurred?",
            "is_async": true,
            "line": 2129
          },
          {
            "name": "get_policy_violation_detail",
            "signature": "(violation_id: str, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> dict",
            "docstring": "V2 Facade: Violation detail for cross-domain navigation.",
            "is_async": true,
            "line": 2210
          }
        ],
        "classes": [
          {
            "name": "PolicyType",
            "docstring": "Types of policies that can be evaluated.",
            "methods": [],
            "line": 146
          },
          {
            "name": "ApprovalStatus",
            "docstring": "Status of an approval request.",
            "methods": [],
            "line": 155
          },
          {
            "name": "PolicyEvalRequest",
            "docstring": "Request for policy sandbox evaluation.",
            "methods": [],
            "line": 166
          },
          {
            "name": "PolicyEvalResponse",
            "docstring": "Response from policy sandbox evaluation.",
            "methods": [],
            "line": 177
          },
          {
            "name": "ApprovalRequestCreate",
            "docstring": "Request to create an approval request.",
            "methods": [],
            "line": 189
          },
          {
            "name": "ApprovalRequestResponse",
            "docstring": "Response when creating an approval request.",
            "methods": [],
            "line": 204
          },
          {
            "name": "ApprovalAction",
            "docstring": "Action to approve or reject a request.",
            "methods": [],
            "line": 215
          },
          {
            "name": "ApprovalStatusResponse",
            "docstring": "Full status of an approval request.",
            "methods": [],
            "line": 223
          },
          {
            "name": "PolicyMetadata",
            "docstring": "Governance metadata for policy artifacts (aos_sdk-grade).\n\nSTATUS: DECLARED (PARTIALLY MATERIALIZED)\nReference: docs/contracts/CROSS_DOMAIN_INVARIANTS.md Section IX\nMaturity: docs/contracts/METADATA_MATURITY.md\n\nProvides provenance, lifecycle, and accountability traceability\nfor cross-domain consumers per CROSS_DOMAIN_INVARIANTS.md.\n\nNULL SEMANTICS (INV-META-NULL-001):\n===================================\nA null field means \"NOT YET MATERIALIZED\", not \"NOT APPLICABLE\" or \"DENIED\".\nConsumers MUST NOT:\n- Branch on `field is None` to infer absence\n- Treat null as negative truth (e.g., null approved_by \u2260 rejected)\n- Auto-populate nulls with system actors\n\nFIELD CLASSIFICATION:\n=====================\nClass A (Immutable Provenance) \u2014 DB-backed, never changes once written:\n  - created_by, created_at, origin, source_proposal_id\n\nClass B (Governance Decisions) \u2014 Human-gated, requires workflow:\n  - approved_by, approved_at (null until proposal workflow is real)\n\nClass C (Temporal Validity) \u2014 Required before historical analytics:\n  - effective_from, effective_until (default: effective_from = created_at)",
            "methods": [],
            "line": 1285
          },
          {
            "name": "PolicyContextSummary",
            "docstring": "Summary of an active policy for cross-domain consumption.",
            "methods": [],
            "line": 1429
          },
          {
            "name": "ActivePoliciesResponse",
            "docstring": "GET /policy/active response \u2014 What governs execution now?",
            "methods": [],
            "line": 1445
          },
          {
            "name": "PolicyLibrarySummary",
            "docstring": "Summary of a policy rule in the library.",
            "methods": [],
            "line": 1455
          },
          {
            "name": "PolicyLibraryResponse",
            "docstring": "GET /policy/library response \u2014 What patterns are available?",
            "methods": [],
            "line": 1471
          },
          {
            "name": "PolicyLessonSummary",
            "docstring": "Summary of a lesson or draft for cross-domain consumption.",
            "methods": [],
            "line": 1479
          },
          {
            "name": "LessonsResponse",
            "docstring": "GET /policy/lessons response \u2014 What governance emerged?",
            "methods": [],
            "line": 1495
          },
          {
            "name": "ThresholdSummary",
            "docstring": "Summary of an enforced limit/threshold.",
            "methods": [],
            "line": 1505
          },
          {
            "name": "ThresholdsResponse",
            "docstring": "GET /policy/thresholds response \u2014 What limits are enforced?",
            "methods": [],
            "line": 1521
          },
          {
            "name": "ViolationSummary",
            "docstring": "Summary of a policy violation for cross-domain consumption.",
            "methods": [],
            "line": 1529
          },
          {
            "name": "ViolationsResponse",
            "docstring": "GET /policy/violations response \u2014 What enforcement occurred?",
            "methods": [],
            "line": 1546
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "BackgroundTasks",
              "Depends",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "TenantTier",
              "requires_feature",
              "requires_tier"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_async_session_context",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges",
            "names": [
              "get_policies_engine_bridge"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 69
          }
        ],
        "constants": [
          {
            "name": "WEBHOOK_MAX_RETRIES",
            "line": 252
          },
          {
            "name": "WEBHOOK_RETRY_DELAYS",
            "line": 253
          },
          {
            "name": "WEBHOOK_CURRENT_KEY_VERSION",
            "line": 262
          },
          {
            "name": "WEBHOOK_KEY_GRACE_VERSIONS",
            "line": 269
          },
          {
            "name": "WEBHOOK_KEY_GRACE_VERSIONS",
            "line": 270
          },
          {
            "name": "RATE_LIMIT_ENABLED",
            "line": 277
          },
          {
            "name": "RATE_LIMIT_DEFAULT_RPM",
            "line": 278
          },
          {
            "name": "RATE_LIMIT_BURST_RPM",
            "line": 279
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "policy_layer.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy_layer.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1876,
        "module_docstring": null,
        "functions": [
          {
            "name": "evaluate_action",
            "signature": "(request: EvaluateRequest, db = Depends(get_session_dep)) -> PolicyEvaluationResult",
            "docstring": "Evaluate a proposed action against all applicable policies.\n\nThis is the primary endpoint that agents MUST call before:\n- Routing decisions (CARE)\n- Task/skill execution\n- Strategy adaptation (SBA)\n- Escalation to humans\n- Self-modification\n- Agent spawning/invocation\n- Data access\n- External API calls\n\nReturns ALLOW, BLOCK, or MODIFY with detailed reasoning.",
            "is_async": true,
            "line": 139
          },
          {
            "name": "simulate_evaluation",
            "signature": "(request: SimulateRequest, db = Depends(get_session_dep)) -> PolicyEvaluationResult",
            "docstring": "Simulate policy evaluation without side effects.\n\nUseful for:\n- Testing policy configurations\n- Debugging why actions are blocked\n- Pre-flight checks before batch operations\n\nDoes NOT:\n- Record the evaluation\n- Update risk ceiling counters\n- Create violation records\n- Route to governor",
            "is_async": true,
            "line": 188
          },
          {
            "name": "get_policy_state",
            "signature": "(db = Depends(get_session_dep)) -> PolicyState",
            "docstring": "Get the current state of the policy layer.\n\nReturns summary of:\n- Active policies by category\n- Evaluation statistics\n- Violation counts\n- Risk ceiling status",
            "is_async": true,
            "line": 233
          },
          {
            "name": "reload_policies",
            "signature": "(db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Hot-reload policies from database.\n\nUse this after updating policies to apply changes immediately\nwithout restarting the service.",
            "is_async": true,
            "line": 261
          },
          {
            "name": "list_violations",
            "signature": "(violation_type: Optional[ViolationType] = None, agent_id: Optional[str] = None, tenant_id: Optional[str] = None, severity_min: Optional[float] = Query(None, ge=0.0, le=1.0), hours: int = Query(24, ge=1, le=720), limit: int = Query(100, ge=1, le=1000), db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "List policy violations with filtering.\n\nDefault: violations from last 24 hours.",
            "is_async": true,
            "line": 300
          },
          {
            "name": "get_violation",
            "signature": "(violation_id: str, db = Depends(get_session_dep)) -> PolicyViolation",
            "docstring": "Get a specific violation by ID.",
            "is_async": true,
            "line": 338
          },
          {
            "name": "acknowledge_violation",
            "signature": "(violation_id: str, notes: Optional[str] = None, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Acknowledge a violation (mark as reviewed).\n\nThis does NOT dismiss the violation - it records that\na human has reviewed it.",
            "is_async": true,
            "line": 361
          },
          {
            "name": "list_risk_ceilings",
            "signature": "(tenant_id: Optional[str] = None, include_inactive: bool = False, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "List all risk ceilings with current values.",
            "is_async": true,
            "line": 395
          },
          {
            "name": "get_risk_ceiling",
            "signature": "(ceiling_id: str, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get a specific risk ceiling with current utilization.",
            "is_async": true,
            "line": 432
          },
          {
            "name": "update_risk_ceiling",
            "signature": "(ceiling_id: str, update: RiskCeilingUpdate, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Update a risk ceiling configuration.",
            "is_async": true,
            "line": 469
          },
          {
            "name": "reset_risk_ceiling",
            "signature": "(ceiling_id: str, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Reset a risk ceiling's current value to 0.",
            "is_async": true,
            "line": 499
          },
          {
            "name": "list_safety_rules",
            "signature": "(tenant_id: Optional[str] = None, include_inactive: bool = False, db = Depends(get_session_dep)) -> List[Dict[str, Any]]",
            "docstring": "List all safety rules.",
            "is_async": true,
            "line": 528
          },
          {
            "name": "update_safety_rule",
            "signature": "(rule_id: str, update: SafetyRuleUpdate, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Update a safety rule configuration.",
            "is_async": true,
            "line": 563
          },
          {
            "name": "list_ethical_constraints",
            "signature": "(include_inactive: bool = False, db = Depends(get_session_dep)) -> List[Dict[str, Any]]",
            "docstring": "List all ethical constraints.",
            "is_async": true,
            "line": 597
          },
          {
            "name": "list_active_cooldowns",
            "signature": "(agent_id: Optional[str] = None, db = Depends(get_session_dep)) -> List[CooldownInfo]",
            "docstring": "List all active cooldowns.",
            "is_async": true,
            "line": 635
          },
          {
            "name": "clear_cooldowns",
            "signature": "(agent_id: str, rule_name: Optional[str] = None, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Clear cooldowns for an agent.\n\nUse with caution - bypasses safety cooldowns.",
            "is_async": true,
            "line": 656
          },
          {
            "name": "get_policy_metrics",
            "signature": "(hours: int = Query(24, ge=1, le=720), db = Depends(get_session_dep)) -> PolicyMetrics",
            "docstring": "Get policy engine metrics for the specified time window.",
            "is_async": true,
            "line": 687
          },
          {
            "name": "evaluate_batch",
            "signature": "(requests: List[EvaluateRequest], db = Depends(get_session_dep)) -> List[PolicyEvaluationResult]",
            "docstring": "Evaluate multiple actions in a single call.\n\nUseful for pre-flight checks on batch operations.\nLimited to 50 requests per batch.",
            "is_async": true,
            "line": 713
          },
          {
            "name": "list_policy_versions",
            "signature": "(limit: int = Query(20, ge=1, le=100), include_inactive: bool = False, db = Depends(get_session_dep)) -> List[Dict[str, Any]]",
            "docstring": "List all policy versions.\n\nReturns version history for audit and rollback purposes.",
            "is_async": true,
            "line": 777
          },
          {
            "name": "get_current_version",
            "signature": "(db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get the currently active policy version.\n\nThis is the version being used for all evaluations.",
            "is_async": true,
            "line": 803
          },
          {
            "name": "create_policy_version",
            "signature": "(request: CreateVersionRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Create a new policy version snapshot.\n\nThis captures the current state of all policies for audit\nand potential rollback.",
            "is_async": true,
            "line": 829
          },
          {
            "name": "rollback_to_version",
            "signature": "(request: RollbackRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Rollback to a previous policy version.\n\nThis restores all policies to the state captured in\nthe specified version.",
            "is_async": true,
            "line": 864
          },
          {
            "name": "get_version_provenance",
            "signature": "(version_id: str, db = Depends(get_session_dep)) -> List[Dict[str, Any]]",
            "docstring": "Get the provenance (change history) for a policy version.\n\nShows what changes were made and by whom.",
            "is_async": true,
            "line": 899
          },
          {
            "name": "get_dependency_graph",
            "signature": "(db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get the policy dependency graph.\n\nShows relationships and potential conflicts between policies.",
            "is_async": true,
            "line": 929
          },
          {
            "name": "list_conflicts",
            "signature": "(include_resolved: bool = False, db = Depends(get_session_dep)) -> List[Dict[str, Any]]",
            "docstring": "List policy conflicts.\n\nConflicts occur when policies have contradictory rules.",
            "is_async": true,
            "line": 980
          },
          {
            "name": "resolve_conflict",
            "signature": "(conflict_id: str, request: ResolveConflictRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Resolve a policy conflict.\n\nDocuments how the conflict should be handled during evaluation.",
            "is_async": true,
            "line": 1027
          },
          {
            "name": "list_temporal_policies",
            "signature": "(metric: Optional[str] = None, include_inactive: bool = False, db = Depends(get_session_dep)) -> List[Dict[str, Any]]",
            "docstring": "List temporal (sliding window) policies.\n\nThese policies track cumulative metrics over time windows.",
            "is_async": true,
            "line": 1082
          },
          {
            "name": "create_temporal_policy",
            "signature": "(request: TemporalPolicyCreate, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Create a new temporal policy.\n\nTemporal policies track cumulative metrics over sliding windows.",
            "is_async": true,
            "line": 1122
          },
          {
            "name": "get_temporal_utilization",
            "signature": "(policy_id: str, agent_id: Optional[str] = None, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get current utilization for a temporal policy.\n\nShows how much of the limit has been consumed in the current window.",
            "is_async": true,
            "line": 1152
          },
          {
            "name": "evaluate_with_context",
            "signature": "(request: ContextAwareEvaluateRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Context-aware policy evaluation (GAP 4).\n\nEvaluates with full agent/tenant context, action chain tracking,\nand temporal policy awareness. Returns updated context for\nuse in subsequent evaluations.",
            "is_async": true,
            "line": 1212
          },
          {
            "name": "validate_dependency_dag",
            "signature": "(db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Validate that policy dependencies form a valid DAG.\n\nChecks for cycles in the dependency graph. Cycles cause:\n- Infinite recursion in override resolution\n- Oscillation in dependency evaluation\n- Rule folding failures\n- MODIFY rule loops\n\nReturns:\n- is_dag: True if graph is acyclic\n- cycles: List of detected cycles (if any)\n- topological_order: Evaluation order (if DAG is valid)",
            "is_async": true,
            "line": 1295
          },
          {
            "name": "add_dependency_with_dag_check",
            "signature": "(request: AddDependencyRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Add a policy dependency with DAG validation.\n\nBlocks the addition if it would create a cycle in the\ndependency graph. This ensures the graph remains a\nvalid DAG (Directed Acyclic Graph).\n\nReturns:\n- success: True if added\n- error: Error message if blocked due to cycle\n- blocked: True if cycle detected\n- cycle_path: The path that would form a cycle",
            "is_async": true,
            "line": 1339
          },
          {
            "name": "get_evaluation_order",
            "signature": "(db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get the topological evaluation order for policies.\n\nReturns the order in which policies should be evaluated\nbased on their dependencies. Policies that depend on\nothers are evaluated after their dependencies.",
            "is_async": true,
            "line": 1392
          },
          {
            "name": "prune_temporal_metrics",
            "signature": "(request: PruneTemporalMetricsRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Prune and compact temporal metric events.\n\nThis prevents storage explosion by:\n1. Deleting events older than retention period\n2. Downsampling older events to hourly aggregates\n3. Capping maximum events per policy\n\nShould be run periodically (e.g., via cron job).",
            "is_async": true,
            "line": 1444
          },
          {
            "name": "get_temporal_storage_stats",
            "signature": "(db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get storage statistics for temporal metrics.\n\nUse this to monitor storage growth and determine\nwhen pruning is needed.",
            "is_async": true,
            "line": 1483
          },
          {
            "name": "activate_policy_version",
            "signature": "(request: ActivateVersionRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Activate a policy version with pre-activation integrity checks.\n\nPerforms comprehensive checks before activation:\n1. Dependency closure - all dependencies exist\n2. Conflict scan - no unresolved critical conflicts\n3. DAG validation - no cycles\n4. Temporal integrity - valid window configurations\n5. Severity compatibility - escalation paths exist\n6. Simulation - dry-run against test cases\n\nUse dry_run=True to test without activating.\n\nReturns:\n- success: True if activated (or would be, for dry_run)\n- all_checks_passed: True if all integrity checks pass\n- checks: Detailed results of each check\n- activated_version: The version that was activated",
            "is_async": true,
            "line": 1521
          },
          {
            "name": "check_version_integrity",
            "signature": "(version_id: str, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Run integrity checks on a version without activating.\n\nShortcut for activate with dry_run=True.\nUseful for validating a version before scheduling activation.",
            "is_async": true,
            "line": 1578
          },
          {
            "name": "list_lessons",
            "signature": "(tenant_id: Optional[str] = None, lesson_type: Optional[str] = Query(None, description='Filter: failure, near_threshold, critical_success'), status: Optional[str] = Query(None, description='Filter: pending, converted_to_draft, deferred, dismissed'), severity: Optional[str] = Query(None, description='Filter: CRITICAL, HIGH, MEDIUM, LOW'), limit: int = Query(50, ge=1, le=500), offset: int = Query(0, ge=0), db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "List lessons learned.\n\nReturns lessons with optional filtering by type, status, and severity.\nThis endpoint is for the policy-layer (L3) - internal use.\n\nReference: PIN-411, POLICIES_DOMAIN_AUDIT.md Section 11",
            "is_async": true,
            "line": 1633
          },
          {
            "name": "get_lesson_stats",
            "signature": "(tenant_id: str, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get lesson statistics for a tenant.\n\nReturns counts by type and status.\n\nReference: PIN-411",
            "is_async": true,
            "line": 1687
          },
          {
            "name": "get_lesson",
            "signature": "(lesson_id: str, tenant_id: str, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get a specific lesson by ID.\n\nReturns detailed lesson information.\n\nReference: PIN-411",
            "is_async": true,
            "line": 1715
          },
          {
            "name": "convert_lesson_to_draft",
            "signature": "(lesson_id: str, request: LessonConvertRequest, tenant_id: str = Query(..., description='Tenant ID'), db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Convert a lesson to a draft policy proposal.\n\nCreates a new draft proposal and updates the lesson status.\nPB-S4 compliant: drafts require human approval.\n\nReference: PIN-411, PB-S4",
            "is_async": true,
            "line": 1749
          },
          {
            "name": "defer_lesson",
            "signature": "(lesson_id: str, request: LessonDeferRequest, tenant_id: str = Query(..., description='Tenant ID'), db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Defer a lesson until a future date.\n\nThe lesson will resurface for review after the defer date.\n\nReference: PIN-411",
            "is_async": true,
            "line": 1793
          },
          {
            "name": "dismiss_lesson",
            "signature": "(lesson_id: str, request: LessonDismissRequest, tenant_id: str = Query(..., description='Tenant ID'), db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Dismiss a lesson (mark as not actionable).\n\nDismissed lessons are preserved for audit but won't resurface.\n\nReference: PIN-411",
            "is_async": true,
            "line": 1836
          }
        ],
        "classes": [
          {
            "name": "EvaluateRequest",
            "docstring": "Request to evaluate an action against policies.",
            "methods": [],
            "line": 50
          },
          {
            "name": "SimulateRequest",
            "docstring": "Request to simulate policy evaluation (dry run).",
            "methods": [],
            "line": 66
          },
          {
            "name": "ViolationQuery",
            "docstring": "Query parameters for violations.",
            "methods": [],
            "line": 81
          },
          {
            "name": "RiskCeilingUpdate",
            "docstring": "Update for a risk ceiling.",
            "methods": [],
            "line": 92
          },
          {
            "name": "SafetyRuleUpdate",
            "docstring": "Update for a safety rule.",
            "methods": [],
            "line": 101
          },
          {
            "name": "CooldownInfo",
            "docstring": "Information about an active cooldown.",
            "methods": [],
            "line": 110
          },
          {
            "name": "PolicyMetrics",
            "docstring": "Metrics from the policy engine.",
            "methods": [],
            "line": 120
          },
          {
            "name": "CreateVersionRequest",
            "docstring": "Request to create a new policy version.",
            "methods": [],
            "line": 761
          },
          {
            "name": "RollbackRequest",
            "docstring": "Request to rollback to a previous version.",
            "methods": [],
            "line": 768
          },
          {
            "name": "ResolveConflictRequest",
            "docstring": "Request to resolve a policy conflict.",
            "methods": [],
            "line": 1019
          },
          {
            "name": "TemporalPolicyCreate",
            "docstring": "Request to create a temporal policy.",
            "methods": [],
            "line": 1066
          },
          {
            "name": "ContextAwareEvaluateRequest",
            "docstring": "Request for context-aware policy evaluation (GAP 4).",
            "methods": [],
            "line": 1182
          },
          {
            "name": "AddDependencyRequest",
            "docstring": "Request to add a policy dependency with DAG validation.",
            "methods": [],
            "line": 1327
          },
          {
            "name": "PruneTemporalMetricsRequest",
            "docstring": "Request to prune temporal metrics.",
            "methods": [],
            "line": 1435
          },
          {
            "name": "ActivateVersionRequest",
            "docstring": "Request to activate a policy version.",
            "methods": [],
            "line": 1512
          },
          {
            "name": "LessonConvertRequest",
            "docstring": "Request to convert a lesson to draft proposal.",
            "methods": [],
            "line": 1613
          },
          {
            "name": "LessonDeferRequest",
            "docstring": "Request to defer a lesson.",
            "methods": [],
            "line": 1619
          },
          {
            "name": "LessonDismissRequest",
            "docstring": "Request to dismiss a lesson.",
            "methods": [],
            "line": 1625
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "app.policy",
            "names": [
              "ActionType",
              "PolicyEvaluationRequest",
              "PolicyEvaluationResult",
              "PolicyState",
              "PolicyViolation",
              "ViolationType"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_limits_crud.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy_limits_crud.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 511,
        "module_docstring": "Policy Limits CRUD API (PIN-LIM-01)\n\nMutating endpoints for policy limits.\n\nExtends the read-only policies.py facade with write operations.\n\nEndpoints:\n    POST   /policies/limits              \u2192 Create limit\n    PUT    /policies/limits/{limit_id}   \u2192 Update limit\n    DELETE /policies/limits/{limit_id}   \u2192 Soft-delete limit",
        "functions": [
          {
            "name": "create_limit",
            "signature": "(request: Request, body: CreateLimitRequest, session = Depends(get_session_dep)) -> LimitDetail",
            "docstring": "Create a new policy limit.\n\n- Category and type are immutable after creation\n- BUDGET limits require reset_period\n- RATE limits require window_seconds",
            "is_async": true,
            "line": 162
          },
          {
            "name": "update_limit",
            "signature": "(request: Request, limit_id: str, body: UpdateLimitRequest, session = Depends(get_session_dep)) -> LimitDetail",
            "docstring": "Update an existing policy limit.\n\n- Category and type are immutable (cannot be changed)\n- Other fields can be updated",
            "is_async": true,
            "line": 228
          },
          {
            "name": "delete_limit",
            "signature": "(request: Request, limit_id: str, session = Depends(get_session_dep)) -> None",
            "docstring": "Soft-delete a policy limit.\n\nSets status to DISABLED. The limit is not actually removed.",
            "is_async": true,
            "line": 297
          },
          {
            "name": "get_threshold_params",
            "signature": "(request: Request, limit_id: str, session = Depends(get_session_dep)) -> ThresholdParamsResponse",
            "docstring": "Get threshold parameters for a limit.\n\nReturns both raw params and effective params (with defaults applied).\nOnly valid for limits with limit_category = THRESHOLD.",
            "is_async": true,
            "line": 350
          },
          {
            "name": "set_threshold_params",
            "signature": "(request: Request, limit_id: str, body: ThresholdParamsRequest, session = Depends(get_session_dep)) -> ThresholdParamsResponse",
            "docstring": "Set threshold parameters for a limit.\n\nThis is the authoritative input surface for:\n- Policies \u2192 Limits \u2192 Thresholds \u2192 Set Params panel\n\nThese params drive LLM run governance signals.\n\nValidation Rules (Hard Stop):\n- max_execution_time_ms: 1000-300000 (1s to 5min)\n- max_tokens: 256-200000\n- max_cost_usd: 0.01-100.00\n- failure_signal: boolean\n\nNo partial garbage. No unknown keys. No absurd values.",
            "is_async": true,
            "line": 411
          },
          {
            "name": "_to_detail",
            "signature": "(result: PolicyLimitResponse) -> LimitDetail",
            "docstring": "Convert service response to API response.",
            "is_async": false,
            "line": 493
          }
        ],
        "classes": [
          {
            "name": "CreateLimitRequest",
            "docstring": "API request to create a policy limit.",
            "methods": [],
            "line": 56
          },
          {
            "name": "UpdateLimitRequest",
            "docstring": "API request to update a policy limit.",
            "methods": [],
            "line": 71
          },
          {
            "name": "ThresholdParamsRequest",
            "docstring": "API request to set execution threshold parameters.\n\nUsed for: Policies \u2192 Limits \u2192 Thresholds \u2192 Set Params panel.\n\nThese params drive LLM run governance:\n- Activity \u2192 LLM Runs \u2192 Live \u2192 Signals\n- Activity \u2192 LLM Runs \u2192 Completed \u2192 Signals",
            "methods": [],
            "line": 83
          },
          {
            "name": "ThresholdParamsResponse",
            "docstring": "Response with effective threshold params.",
            "methods": [],
            "line": 120
          },
          {
            "name": "LimitDetail",
            "docstring": "Full limit response.",
            "methods": [],
            "line": 130
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.schemas.limits.policy_limits",
            "names": [
              "CreatePolicyLimitRequest",
              "LimitCategoryEnum",
              "LimitEnforcementEnum",
              "LimitScopeEnum",
              "PolicyLimitResponse",
              "ResetPeriodEnum",
              "UpdatePolicyLimitRequest"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_proposals.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy_proposals.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 523,
        "module_docstring": "PB-S4 Policy Proposals API\n\nExposes policy_proposals and policy_versions data with human-controlled approval.\n\nPB-S4 Contract:\n- Policies are proposed, never auto-enforced\n- Human approval is mandatory\n- Proposals have provenance to triggering feedback\n- Rejection preserved for audit trail\n\nO1: API endpoint exists \u2713\nO2: List visible with pagination \u2713\nO3: Detail accessible \u2713\nO4: Approve/Reject actions (human-controlled) \u2713 (PIN-373)\n\nPIN-513 L2 Purity:\n- All DB operations routed through L4 registry \u2192 L5 engine \u2192 L6 driver\n- Zero session.execute() calls in L2",
        "functions": [
          {
            "name": "list_proposals",
            "signature": "(request: Request, tenant_id: Optional[str] = Query(None, description='Filter by tenant'), status: Optional[str] = Query(None, description='Filter by status (draft/approved/rejected)'), proposal_type: Optional[str] = Query(None, description='Filter by proposal type'), limit: int = Query(50, ge=1, le=200, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'))",
            "docstring": "List policy proposals (PB-S4).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 124
          },
          {
            "name": "get_proposal_stats",
            "signature": "(request: Request, tenant_id: Optional[str] = Query(None, description='Filter by tenant'))",
            "docstring": "Get policy proposal statistics (PB-S4).\n\nREAD-ONLY: This endpoint only reads aggregated data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 190
          },
          {
            "name": "get_proposal",
            "signature": "(request: Request, proposal_id: str)",
            "docstring": "Get detailed policy proposal by ID (PB-S4).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 231
          },
          {
            "name": "list_proposal_versions",
            "signature": "(request: Request, proposal_id: str)",
            "docstring": "List all versions of a policy proposal (PB-S4).\n\nREAD-ONLY: This endpoint only reads data.\nShows the evolution of a policy through approvals.",
            "is_async": true,
            "line": 316
          },
          {
            "name": "approve_proposal",
            "signature": "(http_request: Request, proposal_id: str, request: ApproveRejectRequest, role: TenantRole = Depends(require_role(TenantRole.MEMBER, TenantRole.ADMIN, TenantRole.OWNER)))",
            "docstring": "Approve a policy proposal (PIN-373).\n\nHUMAN ACTION: This creates a policy_rules entry when approved.\nOnly draft proposals can be approved.\n\nPB-S4 Contract: Human approval is mandatory - system cannot auto-approve.",
            "is_async": true,
            "line": 387
          },
          {
            "name": "reject_proposal",
            "signature": "(http_request: Request, proposal_id: str, request: ApproveRejectRequest, role: TenantRole = Depends(require_role(TenantRole.MEMBER, TenantRole.ADMIN, TenantRole.OWNER)))",
            "docstring": "Reject a policy proposal (PIN-373).\n\nHUMAN ACTION: This marks the proposal as rejected.\nRejection is preserved for audit trail.\nOnly draft proposals can be rejected.\n\nPB-S4 Contract: Human decision is mandatory - system cannot auto-reject.",
            "is_async": true,
            "line": 456
          }
        ],
        "classes": [
          {
            "name": "ProposalSummaryResponse",
            "docstring": "Summary of a policy proposal.",
            "methods": [],
            "line": 60
          },
          {
            "name": "ProposalListResponse",
            "docstring": "Paginated list of policy proposals.",
            "methods": [],
            "line": 76
          },
          {
            "name": "ProposalDetailResponse",
            "docstring": "Detailed policy proposal record.",
            "methods": [],
            "line": 87
          },
          {
            "name": "VersionResponse",
            "docstring": "Policy version record.",
            "methods": [],
            "line": 106
          },
          {
            "name": "ApproveRejectRequest",
            "docstring": "Request body for approve/reject actions.",
            "methods": [],
            "line": 369
          },
          {
            "name": "ApprovalResponse",
            "docstring": "Response for approve/reject actions.",
            "methods": [],
            "line": 376
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.role_guard",
            "names": [
              "require_role"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.tenant_roles",
            "names": [
              "TenantRole"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_async_session_context",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_rules_crud.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy_rules_crud.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 264,
        "module_docstring": "Policy Rules CRUD API (PIN-LIM-02)\n\nMutating endpoints for policy rules.\n\nExtends the read-only policies.py facade with write operations.\n\nEndpoints:\n    POST /policies/rules              \u2192 Create rule\n    PUT  /policies/rules/{rule_id}    \u2192 Update rule\n\nRules are never deleted - they are retired with reason.",
        "functions": [
          {
            "name": "create_rule",
            "signature": "(request: Request, body: CreateRuleRequest, session = Depends(get_session_dep)) -> RuleDetail",
            "docstring": "Create a new policy rule.\n\nRules can be created from:\n- MANUAL: User-defined rules\n- SYSTEM: System-generated rules\n- LEARNED: ML/AI proposed rules (from policy proposals)",
            "is_async": true,
            "line": 114
          },
          {
            "name": "update_rule",
            "signature": "(request: Request, rule_id: str, body: UpdateRuleRequest, session = Depends(get_session_dep)) -> RuleDetail",
            "docstring": "Update an existing policy rule.\n\nTo retire a rule:\n- Set status to \"RETIRED\"\n- Provide retirement_reason (required)\n- Optionally set superseded_by\n\nRules are never deleted, only retired.",
            "is_async": true,
            "line": 175
          },
          {
            "name": "_to_detail",
            "signature": "(result: PolicyRuleResponse) -> RuleDetail",
            "docstring": "Convert service response to API response.",
            "is_async": false,
            "line": 242
          }
        ],
        "classes": [
          {
            "name": "CreateRuleRequest",
            "docstring": "API request to create a policy rule.",
            "methods": [],
            "line": 52
          },
          {
            "name": "UpdateRuleRequest",
            "docstring": "API request to update a policy rule.",
            "methods": [],
            "line": 66
          },
          {
            "name": "RuleDetail",
            "docstring": "Full rule response.",
            "methods": [],
            "line": 78
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.schemas.limits.policy_rules",
            "names": [
              "CreatePolicyRuleRequest",
              "PolicyRuleResponse",
              "UpdatePolicyRuleRequest"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "rate_limits.py",
        "file_path": "backend/app/hoc/api/cus/policies/rate_limits.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 278,
        "module_docstring": "Rate Limits API (L2) - GAP-122\n\nProvides rate limit and quota operations:\n- GET /rate-limits (list rate limits)\n- GET /rate-limits/usage (current usage)\n- GET /rate-limits/{id} (get rate limit)\n- PUT /rate-limits/{id} (update rate limit)\n- POST /rate-limits/check (check rate limit)\n- POST /rate-limits/{id}/reset (reset usage)\n\nThis is the ONLY facade for rate limit/quota operations.\nDistinct from PIN-LIM policy limits (app/api/limits/).",
        "functions": [
          {
            "name": "list_limits",
            "signature": "(limit_type: Optional[str] = Query(None, description='Filter by type'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('limits.read')))",
            "docstring": "List limits (GAP-122).\n\nReturns all configured limits for the tenant.",
            "is_async": true,
            "line": 77
          },
          {
            "name": "get_usage",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('limits.read')))",
            "docstring": "Get current usage summary.\n\nReturns usage across all limits with aggregated totals.",
            "is_async": true,
            "line": 116
          },
          {
            "name": "check_limit",
            "signature": "(request: CheckLimitRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('limits.check')))",
            "docstring": "Check if a limit allows an operation.\n\nIf allowed, increments the usage counter.",
            "is_async": true,
            "line": 142
          },
          {
            "name": "get_limit",
            "signature": "(limit_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('limits.read')))",
            "docstring": "Get a specific limit.",
            "is_async": true,
            "line": 173
          },
          {
            "name": "update_limit",
            "signature": "(limit_id: str, request: UpdateLimitRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('limits.write')))",
            "docstring": "Update a limit configuration.",
            "is_async": true,
            "line": 201
          },
          {
            "name": "reset_limit",
            "signature": "(limit_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('limits.admin')))",
            "docstring": "Reset a limit's usage counter.\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 236
          }
        ],
        "classes": [
          {
            "name": "UpdateLimitRequest",
            "docstring": "Request to update a limit.",
            "methods": [],
            "line": 58
          },
          {
            "name": "CheckLimitRequest",
            "docstring": "Request to check a limit.",
            "methods": [],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "rbac_api.py",
        "file_path": "backend/app/hoc/api/cus/policies/rbac_api.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 344,
        "module_docstring": "RBAC Management API\n\nProvides endpoints for managing RBAC policies:\n- GET /rbac/info - Get current policy info\n- POST /rbac/reload - Hot-reload policies from file\n- GET /rbac/matrix - Get current permission matrix\n- GET /rbac/audit - Query audit logs\n\nRequires RBAC permission: rbac:read or rbac:reload\n\nNOTE (PIN-310): Authorization now routes through M28 via authorization_choke.py.\nPolicy introspection (info, matrix, reload) still uses rbac_engine for admin functions.",
        "functions": [
          {
            "name": "_get_rbac_engine",
            "signature": "()",
            "docstring": "Get rbac_engine via L4 bridge to maintain L2 purity.",
            "is_async": false,
            "line": 49
          },
          {
            "name": "get_policy_info",
            "signature": "(request: Request)",
            "docstring": "Get current RBAC policy information.\n\nReturns version, hash, loaded timestamp, roles, and resources.\n\nRequires RBAC permission: rbac:read",
            "is_async": true,
            "line": 118
          },
          {
            "name": "reload_policies",
            "signature": "(request: Request)",
            "docstring": "Hot-reload RBAC policies from file.\n\nReloads the policy file and updates the in-memory policy matrix.\nReturns the previous and new policy hashes for verification.\n\nRequires RBAC permission: rbac:reload",
            "is_async": true,
            "line": 148
          },
          {
            "name": "get_permission_matrix",
            "signature": "(request: Request) -> Dict[str, Any]",
            "docstring": "Get current permission matrix.\n\nReturns the full role->resource->actions mapping.\n\nRequires RBAC permission: rbac:read",
            "is_async": true,
            "line": 198
          },
          {
            "name": "query_audit_logs",
            "signature": "(request: Request, resource: Optional[str] = Query(default=None, description='Filter by resource'), action: Optional[str] = Query(default=None, description='Filter by action'), allowed: Optional[bool] = Query(default=None, description='Filter by decision'), subject: Optional[str] = Query(default=None, description='Filter by subject'), tenant_id: Optional[str] = Query(default=None, description='Filter by tenant'), since: Optional[datetime] = Query(default=None, description='Filter since timestamp'), limit: int = Query(default=100, ge=1, le=1000), offset: int = Query(default=0, ge=0), db = Depends(get_sync_session_dep))",
            "docstring": "Query RBAC audit logs.\n\nSupports filtering by resource, action, decision, subject, tenant, and time.\n\nRequires RBAC permission: rbac:read",
            "is_async": true,
            "line": 221
          },
          {
            "name": "cleanup_audit_logs",
            "signature": "(request: Request, retention_days: int = Query(default=90, ge=1, le=365), db = Depends(get_sync_session_dep))",
            "docstring": "Clean up old audit logs.\n\nDeletes audit entries older than retention_days.\n\nRequires RBAC permission: rbac:reload (admin action)",
            "is_async": true,
            "line": 288
          }
        ],
        "classes": [
          {
            "name": "PolicyInfoResponse",
            "docstring": "Current policy information.",
            "methods": [],
            "line": 64
          },
          {
            "name": "ReloadResponse",
            "docstring": "Policy reload response.",
            "methods": [],
            "line": 76
          },
          {
            "name": "AuditEntry",
            "docstring": "Single audit log entry.",
            "methods": [],
            "line": 86
          },
          {
            "name": "AuditResponse",
            "docstring": "Audit log query response.",
            "methods": [],
            "line": 103
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.auth.authorization_choke",
            "names": [
              "check_permission_request"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_operation_registry",
              "get_sync_session_dep",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges",
            "names": [
              "get_account_bridge"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "replay.py",
        "file_path": "backend/app/hoc/api/cus/policies/replay.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 702,
        "module_docstring": "Replay UX API (H1)\n\nProvides READ-ONLY endpoints for replay visualization:\n- Time-windowed slice of incident data\n- Grouped view: inputs, decisions, actions, side-effects\n- Immutable, paginated responses\n\nINVARIANTS:\n1. All endpoints are READ-ONLY (no mutations)\n2. Uses existing RBAC v2 enforcement (require_replay_read)\n3. Tenant isolation enforced\n4. No execution or write capabilities\n5. All DB access via L4 registry dispatch (L2 first-principles purity)\n\nReference: Phase H1 - Replay UX Enablement",
        "functions": [
          {
            "name": "_parse_json_field",
            "signature": "(value) -> Any",
            "docstring": "Safely parse a JSON string field, returning empty dict/list on failure.",
            "is_async": false,
            "line": 134
          },
          {
            "name": "_get_policy_decisions",
            "signature": "(row: dict) -> list",
            "docstring": "Extract policy decisions from a proxy call row dict.",
            "is_async": false,
            "line": 146
          },
          {
            "name": "_get_related_call_ids",
            "signature": "(row: dict) -> list",
            "docstring": "Extract related call IDs from incident metadata.",
            "is_async": false,
            "line": 153
          },
          {
            "name": "_get_event_data",
            "signature": "(row: dict) -> dict",
            "docstring": "Extract data dict from incident event row.",
            "is_async": false,
            "line": 171
          },
          {
            "name": "_categorize_proxy_call_row",
            "signature": "(row: dict) -> ReplayCategory",
            "docstring": "Categorize a proxy call row into replay category.\n\nCategories:\n- INPUT: Request data, model selection\n- DECISION: Policy decisions, guardrail evaluations\n- ACTION: Actual API call execution\n- SIDE_EFFECT: Cost tracking, logging, notifications",
            "is_async": false,
            "line": 178
          },
          {
            "name": "_proxy_call_row_to_replay_item",
            "signature": "(row: dict) -> ReplayItem",
            "docstring": "Convert proxy call row dict to ReplayItem for visualization.",
            "is_async": false,
            "line": 198
          },
          {
            "name": "_incident_event_row_to_replay_item",
            "signature": "(row: dict) -> ReplayItem",
            "docstring": "Convert IncidentEvent row dict to ReplayItem for visualization.",
            "is_async": false,
            "line": 256
          },
          {
            "name": "_dispatch_replay",
            "signature": "(session, method: str, **kwargs) -> Any",
            "docstring": "Dispatch a replay operation through the L4 registry.",
            "is_async": true,
            "line": 288
          },
          {
            "name": "get_replay_slice",
            "signature": "(request: Request, incident_id: str, window: int = Query(30, ge=5, le=300, description='Time window in seconds (+-window from incident)'), center_time: Optional[str] = Query(None, description='Center time ISO8601 (default: incident start)'), page: int = Query(1, ge=1, description='Page number'), page_size: int = Query(50, ge=10, le=200, description='Items per page'), auth: AuthorityResult = Depends(require_replay_read), session = Depends(get_sync_session_dep))",
            "docstring": "Get time-windowed replay slice of an incident.\n\nReturns grouped, immutable data for replay visualization:\n- inputs: What the agent saw (requests, context)\n- decisions: Policy evaluations, guardrail checks\n- actions: Actual executions, API calls\n- side_effects: Cost tracking, notifications, logging\n\nThis endpoint is READ-ONLY and does not modify any data.\n\nRBAC: Requires read:replay permission\nTenant Isolation: Enforced",
            "is_async": true,
            "line": 308
          },
          {
            "name": "get_incident_summary",
            "signature": "(request: Request, incident_id: str, auth: AuthorityResult = Depends(require_replay_read), session = Depends(get_sync_session_dep))",
            "docstring": "Get incident summary for replay context.\n\nProvides high-level information about an incident before\ndiving into detailed replay visualization.\n\nThis endpoint is READ-ONLY.\n\nRBAC: Requires read:replay permission\nTenant Isolation: Enforced",
            "is_async": true,
            "line": 430
          },
          {
            "name": "get_replay_timeline",
            "signature": "(request: Request, incident_id: str, limit: int = Query(100, ge=10, le=500, description='Maximum items to return'), auth: AuthorityResult = Depends(require_replay_read), session = Depends(get_sync_session_dep))",
            "docstring": "Get full timeline for an incident (unpaginated for scrubbing UI).\n\nReturns all replay items in chronological order for\ntimeline scrubbing and playback visualization.\n\nThis endpoint is READ-ONLY.\n\nRBAC: Requires read:replay permission\nTenant Isolation: Enforced",
            "is_async": true,
            "line": 484
          },
          {
            "name": "explain_replay_item",
            "signature": "(request: Request, incident_id: str, item_id: str, auth: AuthorityResult = Depends(require_replay_read), session = Depends(get_sync_session_dep))",
            "docstring": "Get detailed explanation for a single replay item.\n\nProvides expanded context for:\n- What the agent saw (inputs)\n- Why it decided (decision rationale)\n- What it executed (action details)\n\nThis endpoint is READ-ONLY.\n\nRBAC: Requires read:replay permission\nTenant Isolation: Enforced via incident",
            "is_async": true,
            "line": 572
          }
        ],
        "classes": [
          {
            "name": "ReplayCategory",
            "docstring": "Categories for replay data grouping.",
            "methods": [],
            "line": 58
          },
          {
            "name": "ReplayItem",
            "docstring": "Single item in replay timeline.",
            "methods": [],
            "line": 67
          },
          {
            "name": "ReplaySliceResponse",
            "docstring": "Paginated, grouped replay slice response.",
            "methods": [],
            "line": 80
          },
          {
            "name": "IncidentSummaryResponse",
            "docstring": "Summary of incident for replay context.",
            "methods": [],
            "line": 113
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "require_replay_read",
              "verify_tenant_access"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_operation_registry",
              "get_sync_session_dep",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "retrieval.py",
        "file_path": "backend/app/hoc/api/cus/policies/retrieval.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 243,
        "module_docstring": "Retrieval API (L2)\n\nProvides mediated data retrieval operations:\n- POST /retrieval/access (mediated data access)\n- GET /retrieval/planes (list available planes)\n- POST /retrieval/planes (register plane)\n- GET /retrieval/planes/{id} (get plane)\n- GET /retrieval/evidence (list evidence records)\n- GET /retrieval/evidence/{id} (get evidence)\n\nThis is the ONLY facade for mediated data retrieval.\nAll data access from LLM-controlled code MUST flow through this router.\n\nINVARIANT: Deny-by-default. All access blocked unless explicitly allowed by policy.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> RetrievalFacade",
            "docstring": "Get the retrieval facade.",
            "is_async": false,
            "line": 80
          },
          {
            "name": "access_data",
            "signature": "(request: AccessDataRequest, ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.access')))",
            "docstring": "Mediated data access (GAP-094).\n\n**Tier: REACT ($9)** - Mediated data access.\n\nAll data access from LLM-controlled code MUST go through this endpoint.\nImplements deny-by-default policy enforcement.\n\nINVARIANT: Access is BLOCKED unless explicitly allowed by policy.",
            "is_async": true,
            "line": 91
          },
          {
            "name": "list_planes",
            "signature": "(connector_type: Optional[str] = Query(None, description='Filter by connector type'), status: Optional[str] = Query(None, description='Filter by status'), ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.read')))",
            "docstring": "List available knowledge planes.\n\nReturns all registered knowledge planes for the tenant.",
            "is_async": true,
            "line": 125
          },
          {
            "name": "register_plane",
            "signature": "(request: RegisterPlaneRequest, ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.write')))",
            "docstring": "Register a knowledge plane.\n\nRegisters a new knowledge plane that maps to a connector\nfor mediated data access.",
            "is_async": true,
            "line": 150
          },
          {
            "name": "get_plane",
            "signature": "(plane_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.read')))",
            "docstring": "Get a specific knowledge plane.",
            "is_async": true,
            "line": 174
          },
          {
            "name": "list_evidence",
            "signature": "(run_id: Optional[str] = Query(None, description='Filter by run'), plane_id: Optional[str] = Query(None, description='Filter by plane'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.evidence')))",
            "docstring": "List retrieval evidence records.\n\nReturns evidence of data accesses for audit and compliance.",
            "is_async": true,
            "line": 195
          },
          {
            "name": "get_evidence",
            "signature": "(evidence_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.evidence')))",
            "docstring": "Get a specific evidence record.",
            "is_async": true,
            "line": 226
          }
        ],
        "classes": [
          {
            "name": "AccessDataRequest",
            "docstring": "Request for mediated data access.",
            "methods": [],
            "line": 59
          },
          {
            "name": "RegisterPlaneRequest",
            "docstring": "Request to register a knowledge plane.",
            "methods": [],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.retrieval_facade",
            "names": [
              "RetrievalFacade",
              "get_retrieval_facade"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "runtime.py",
        "file_path": "backend/app/hoc/api/cus/policies/runtime.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 716,
        "module_docstring": "Machine-Native Runtime API Endpoints (M5.5)\n\nProvides REST API exposure for machine-native runtime primitives:\n1. POST /runtime/simulate - Pre-execution plan simulation\n2. POST /runtime/query - Runtime state queries\n3. GET /runtime/skills - List available skills\n4. GET /runtime/skills/{skill_id} - Describe a skill\n5. GET /runtime/capabilities - Get capabilities for an agent\n\nDesign Principles (from PIN-005):\n- Queryable state: Agent asks questions, gets structured answers\n- Capability awareness: Agent knows what it can do and what it costs\n- Pre-execution simulation: Evaluate plans before committing\n- Self-describing skills: Skills explain their behavior and constraints\n- Resource contracts: Boundaries declared upfront\n\nTier Gating (M32 - PIN-158):\n- OBSERVE ($0): Query, list skills, capabilities (observability)\n- PREVENT ($199): Simulate, replay (pre-execution decisions)",
        "functions": [
          {
            "name": "_get_cost_simulator",
            "signature": "()",
            "docstring": "Get CostSimulator instance.",
            "is_async": false,
            "line": 163
          },
          {
            "name": "_get_runtime_adapter",
            "signature": "()",
            "docstring": "Get RuntimeAdapter instance (L3).\n\nThis is the compliant way to access runtime functionality.\nL2 calls L3 (adapter), not L5 (worker).\n\nReference: PIN-258 Phase F-3 Runtime Cluster\n\nReturns:\n    RuntimeAdapter instance",
            "is_async": false,
            "line": 174
          },
          {
            "name": "_get_skill_registry",
            "signature": "()",
            "docstring": "Get skill registry.",
            "is_async": false,
            "line": 191
          },
          {
            "name": "simulate_plan",
            "signature": "(request: SimulateRequest, _http_request: Request = None, _rate_limited: bool = Depends(rate_limit_dependency), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('sdk.simulate.full')))",
            "docstring": "Simulate a plan before execution.\n\n**Tier: PREVENT ($199)** - Pre-execution simulation is the core \"decision tier\"\nfeature that lets you stop problems before they happen.\n\nReturns cost estimates, latency estimates, risk assessment, and feasibility check.\nThis allows agents to evaluate plans before committing resources.\n\nExample:\n```json\n{\n  \"plan\": [\n    {\"skill\": \"http_call\", \"params\": {\"url\": \"https://api.example.com/data\"}},\n    {\"skill\": \"llm_invoke\", \"params\": {\"prompt\": \"Summarize this data\"}}\n  ],\n  \"budget_cents\": 100\n}\n```",
            "is_async": true,
            "line": 212
          },
          {
            "name": "query_runtime",
            "signature": "(request: QueryRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('traces.read')))",
            "docstring": "Query runtime state.\n\n**Tier: OBSERVE ($0)** - Basic observability for all tiers.\n\nSupported query types:\n- remaining_budget_cents: Current budget status\n- what_did_i_try_already: Previous execution attempts\n- allowed_skills: List of available skills\n- last_step_outcome: Most recent execution result\n- skills_available_for_goal: Skills matching a goal\n\nExample:\n```json\n{\n  \"query_type\": \"remaining_budget_cents\",\n  \"params\": {}\n}\n```",
            "is_async": true,
            "line": 358
          },
          {
            "name": "list_available_skills",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "List all available skills.\n\n**Tier: OBSERVE ($0)** - Basic capability discovery.\n\nReturns skill IDs and basic descriptors for each skill.",
            "is_async": true,
            "line": 404
          },
          {
            "name": "describe_skill",
            "signature": "(skill_id: str, ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get detailed descriptor for a skill.\n\n**Tier: OBSERVE ($0)** - Basic capability discovery.\n\nReturns full metadata including:\n- Input/output schemas\n- Cost model\n- Failure modes with recovery hints\n- Constraints\n- Composition hints (what skills often precede/follow)",
            "is_async": true,
            "line": 441
          },
          {
            "name": "get_capabilities",
            "signature": "(agent_id: Optional[str] = Query(default=None, description='Agent ID'), tenant_id: Optional[str] = Query(default=None, description='Tenant ID'), ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get available capabilities for an agent/tenant.\n\n**Tier: OBSERVE ($0)** - Basic capability awareness.\n\nReturns:\n- Available skills with their current status\n- Budget information\n- Rate limit information\n- Permissions\n\nThis allows agents to know exactly what they can do before attempting.",
            "is_async": true,
            "line": 486
          },
          {
            "name": "get_resource_contract",
            "signature": "(resource_id: str)",
            "docstring": "Get resource contract for a specific resource.\n\nReturns budget, rate limits, and concurrency constraints.",
            "is_async": true,
            "line": 518
          },
          {
            "name": "replay_run",
            "signature": "(run_id: str, request: ReplayRequest = ReplayRequest(), _rate_limited: bool = Depends(rate_limit_dependency), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.replay')), auth: AuthorityResult = Depends(require_replay_execute))",
            "docstring": "Replay a stored plan and optionally verify determinism parity.\n\n**Tier: PREVENT ($199)** - Replay for evidence and compliance verification.\n**Authority: execute:replay** - RBAC v2 enforced.\n\nM6 Deliverable: Re-execute stored plans without re-planning.\n\nParity verification checks:\n- Same skill calls in same order\n- Same parameters to each skill\n- Same retry decisions\n- Same error classifications\n\nDoes NOT verify:\n- External API responses (vary between runs)\n- LLM output content (non-deterministic)\n- Timestamps (always different)\n- Execution duration (timing varies)\n\nArgs:\n    run_id: The original run ID to replay\n    request: Replay options\n\nReturns:\n    ReplayResponse with parity check result",
            "is_async": true,
            "line": 575
          },
          {
            "name": "list_traces",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), limit: int = Query(100, ge=1, le=1000, description='Max traces to return'), offset: int = Query(0, ge=0, description='Pagination offset'))",
            "docstring": "List stored traces for a tenant.\n\nM6 Deliverable: Access to execution traces for debugging and replay.\n\nArgs:\n    tenant_id: Filter by tenant (optional)\n    limit: Maximum traces to return\n    offset: Pagination offset\n\nReturns:\n    List of trace summaries",
            "is_async": true,
            "line": 642
          },
          {
            "name": "get_trace",
            "signature": "(run_id: str)",
            "docstring": "Get a specific trace by run ID.\n\nM6 Deliverable: Access to full execution trace for debugging.\n\nArgs:\n    run_id: The run ID to retrieve\n\nReturns:\n    Full trace record with all steps",
            "is_async": true,
            "line": 686
          }
        ],
        "classes": [
          {
            "name": "PlanStep",
            "docstring": "A single step in a plan to simulate.",
            "methods": [],
            "line": 67
          },
          {
            "name": "SimulateRequest",
            "docstring": "Request to simulate a plan before execution.",
            "methods": [],
            "line": 75
          },
          {
            "name": "SimulateResponse",
            "docstring": "Response from plan simulation.",
            "methods": [],
            "line": 88
          },
          {
            "name": "QueryRequest",
            "docstring": "Request to query runtime state.",
            "methods": [],
            "line": 108
          },
          {
            "name": "QueryResponse",
            "docstring": "Response from runtime query.",
            "methods": [],
            "line": 117
          },
          {
            "name": "SkillDescriptorResponse",
            "docstring": "Response describing a skill.",
            "methods": [],
            "line": 125
          },
          {
            "name": "SkillListResponse",
            "docstring": "Response listing available skills.",
            "methods": [],
            "line": 140
          },
          {
            "name": "CapabilitiesResponse",
            "docstring": "Response with agent capabilities.",
            "methods": [],
            "line": 148
          },
          {
            "name": "ReplayRequest",
            "docstring": "Request to replay a stored run.",
            "methods": [],
            "line": 555
          },
          {
            "name": "ReplayResponse",
            "docstring": "Response from replay operation.",
            "methods": [],
            "line": 563
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "require_replay_execute"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.middleware.rate_limit",
            "names": [
              "rate_limit_dependency"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.commands.runtime_command",
            "names": [
              "DEFAULT_SKILL_METADATA"
            ],
            "is_relative": false,
            "line": 204
          }
        ],
        "constants": [
          {
            "name": "AOS_WORKSPACE_ROOT",
            "line": 57
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "scheduler.py",
        "file_path": "backend/app/hoc/api/cus/policies/scheduler.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 341,
        "module_docstring": "Scheduler API (L2)\n\nProvides scheduled job operations:\n- POST /scheduler/jobs (create job)\n- GET /scheduler/jobs (list jobs)\n- GET /scheduler/jobs/{id} (get job)\n- PUT /scheduler/jobs/{id} (update job)\n- DELETE /scheduler/jobs/{id} (delete job)\n- POST /scheduler/jobs/{id}/trigger (trigger job)\n- POST /scheduler/jobs/{id}/pause (pause job)\n- POST /scheduler/jobs/{id}/resume (resume job)\n- GET /scheduler/jobs/{id}/runs (job runs)\n- GET /scheduler/runs/{id} (get run)\n\nThis is the ONLY facade for scheduler operations.\nAll scheduler APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> SchedulerFacade",
            "docstring": "Get the scheduler facade.",
            "is_async": false,
            "line": 85
          },
          {
            "name": "create_job",
            "signature": "(request: CreateJobRequest, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Create a scheduled job (GAP-112).\n\n**Tier: REACT ($9)** - Scheduled jobs.\n\nSchedule format: Standard cron expression\n- Minute (0-59)\n- Hour (0-23)\n- Day of month (1-31)\n- Month (1-12)\n- Day of week (0-7, 0 and 7 are Sunday)\n\nExample: \"0 9 * * *\" = Every day at 9:00 AM",
            "is_async": true,
            "line": 96
          },
          {
            "name": "list_jobs",
            "signature": "(status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.read')))",
            "docstring": "List scheduled jobs.",
            "is_async": true,
            "line": 130
          },
          {
            "name": "get_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.read')))",
            "docstring": "Get a specific scheduled job.",
            "is_async": true,
            "line": 157
          },
          {
            "name": "update_job",
            "signature": "(job_id: str, request: UpdateJobRequest, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Update a scheduled job.",
            "is_async": true,
            "line": 178
          },
          {
            "name": "delete_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Delete a scheduled job.",
            "is_async": true,
            "line": 205
          },
          {
            "name": "trigger_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.trigger')))",
            "docstring": "Trigger a job to run immediately.\n\nBypasses the schedule and runs the job now.",
            "is_async": true,
            "line": 226
          },
          {
            "name": "pause_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Pause a scheduled job.\n\nStops the job from running on schedule until resumed.",
            "is_async": true,
            "line": 249
          },
          {
            "name": "resume_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Resume a paused job.\n\nRestarts the job's schedule.",
            "is_async": true,
            "line": 272
          },
          {
            "name": "list_job_runs",
            "signature": "(job_id: str, status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.read')))",
            "docstring": "List job run history.",
            "is_async": true,
            "line": 295
          },
          {
            "name": "get_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.read')))",
            "docstring": "Get a specific job run.",
            "is_async": true,
            "line": 324
          }
        ],
        "classes": [
          {
            "name": "CreateJobRequest",
            "docstring": "Request to create scheduled job.",
            "methods": [],
            "line": 61
          },
          {
            "name": "UpdateJobRequest",
            "docstring": "Request to update scheduled job.",
            "methods": [],
            "line": 71
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.scheduler_facade",
            "names": [
              "SchedulerFacade",
              "get_scheduler_facade"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "simulate.py",
        "file_path": "backend/app/hoc/api/cus/policies/simulate.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 163,
        "module_docstring": "Limit Simulation API (PIN-LIM-04)\n\nPre-execution limit check endpoint.\n\nAllows callers to test whether an execution would be permitted\nbefore actually running it.\n\nEndpoint:\n    POST /limits/simulate\n\nReturns:\n    - decision: ALLOW | BLOCK | WARN\n    - blocking_limit_id (if blocked)\n    - headroom (remaining capacity)\n    - warnings (soft limit warnings)",
        "functions": [
          {
            "name": "simulate_execution",
            "signature": "(request: Request, body: SimulateRequest, session = Depends(get_session_dep)) -> SimulateResponse",
            "docstring": "Simulate an execution against all limits.\n\nThis endpoint allows callers to check whether an execution would be\npermitted BEFORE actually running it. Useful for:\n- SDK pre-checks\n- UI feedback on resource availability\n- Worker admission control",
            "is_async": true,
            "line": 91
          }
        ],
        "classes": [
          {
            "name": "SimulateRequest",
            "docstring": "Wrapper for simulation request.",
            "methods": [],
            "line": 53
          },
          {
            "name": "SimulateResponse",
            "docstring": "Simulation response with decision and details.",
            "methods": [],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.simulation",
            "names": [
              "LimitSimulationRequest",
              "LimitSimulationResponse",
              "SimulationDecision"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "status_history.py",
        "file_path": "backend/app/hoc/api/cus/policies/status_history.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 457,
        "module_docstring": "API endpoints for immutable status history audit trail.\n\nEndpoints:\n- GET /status_history - Query status history with filters\n- GET /status_history/{entity_type}/{entity_id} - Get history for specific entity\n- GET /status_history/export - Export to CSV/JSONL with signed URL\n- GET /status_history/stats - Get statistics for audit reporting\n\nSecurity:\n- Tenant isolation via tenant_id filter\n- Audit logging for all access\n- Signed URLs for exports (time-limited)",
        "functions": [
          {
            "name": "generate_signed_url",
            "signature": "(export_id: str, format: str) -> tuple[str, datetime]",
            "docstring": "Generate a signed URL for export download.\n\nArgs:\n    export_id: Export file identifier\n    format: Export format (csv/jsonl)\n\nReturns:\n    Tuple of (signed_url, expires_at)",
            "is_async": false,
            "line": 134
          },
          {
            "name": "verify_signed_url",
            "signature": "(export_id: str, format: str, expires_ts: int, signature: str) -> bool",
            "docstring": "Verify a signed URL signature.\n\nArgs:\n    export_id: Export file identifier\n    format: Export format\n    expires_ts: Expiration timestamp\n    signature: Provided signature\n\nReturns:\n    True if valid, False otherwise",
            "is_async": false,
            "line": 158
          },
          {
            "name": "query_status_history",
            "signature": "(entity_type: Optional[str] = Query(None, description='Filter by entity type'), entity_id: Optional[str] = Query(None, description='Filter by entity ID'), tenant_id: Optional[str] = Query(None, description='Filter by tenant'), actor_type: Optional[str] = Query(None, description='Filter by actor type'), new_status: Optional[str] = Query(None, description='Filter by new status'), start_time: Optional[datetime] = Query(None, description='Filter from this time'), end_time: Optional[datetime] = Query(None, description='Filter until this time'), limit: int = Query(100, ge=1, le=1000, description='Max results'), offset: int = Query(0, ge=0, description='Offset for pagination'), session = Depends(get_session_dep))",
            "docstring": "Query status history with filters.\n\nSupports filtering by:\n- entity_type: run, agent, approval, workflow, costsim\n- entity_id: Specific entity ID\n- tenant_id: Tenant scope (required in production)\n- actor_type: system, user, agent, scheduler\n- new_status: Target status\n- start_time/end_time: Time range",
            "is_async": true,
            "line": 184
          },
          {
            "name": "get_entity_history",
            "signature": "(entity_type: str, entity_id: str, limit: int = Query(100, ge=1, le=1000), session = Depends(get_session_dep))",
            "docstring": "Get complete status history for a specific entity.\n\nReturns all status transitions in chronological order.",
            "is_async": true,
            "line": 259
          },
          {
            "name": "create_export",
            "signature": "(request: ExportRequest, session = Depends(get_session_dep))",
            "docstring": "Create an export of status history records.\n\nReturns a signed URL for download that expires in 1 hour.\n\nSupported formats:\n- csv: Comma-separated values\n- jsonl: JSON Lines (one JSON object per line)",
            "is_async": true,
            "line": 316
          },
          {
            "name": "download_export",
            "signature": "(export_id: str, format: str = Query(..., description='Export format'), expires: int = Query(..., description='Expiration timestamp'), sig: str = Query(..., description='Signature'))",
            "docstring": "Download an exported file using signed URL.\n\nThis endpoint verifies the signature and expiration before\nreturning the file contents.",
            "is_async": true,
            "line": 386
          },
          {
            "name": "get_stats",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), session = Depends(get_session_dep))",
            "docstring": "Get statistics about status history records.\n\nUseful for audit reporting and monitoring.",
            "is_async": true,
            "line": 423
          }
        ],
        "classes": [
          {
            "name": "StatusHistoryQuery",
            "docstring": "Query parameters for status history.",
            "methods": [],
            "line": 59
          },
          {
            "name": "StatusHistoryResponse",
            "docstring": "Single status history record.",
            "methods": [],
            "line": 72
          },
          {
            "name": "StatusHistoryListResponse",
            "docstring": "Paginated list of status history records.",
            "methods": [],
            "line": 90
          },
          {
            "name": "ExportRequest",
            "docstring": "Request for status history export.",
            "methods": [],
            "line": 100
          },
          {
            "name": "ExportResponse",
            "docstring": "Response with signed URL for export download.",
            "methods": [],
            "line": 111
          },
          {
            "name": "StatsResponse",
            "docstring": "Statistics for audit reporting.",
            "methods": [],
            "line": 121
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "csv",
            "names": [
              "csv"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "cast"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Response"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [
          {
            "name": "EXPORT_DIR",
            "line": 53
          },
          {
            "name": "SIGNED_URL_SECRET",
            "line": 54
          },
          {
            "name": "SIGNED_URL_TTL_SECONDS",
            "line": 55
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "v1_killswitch.py",
        "file_path": "backend/app/hoc/api/cus/policies/v1_killswitch.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 914,
        "module_docstring": "M22 KillSwitch MVP - Control & Observability API\n\nEndpoints:\n- POST /v1/killswitch/tenant - Freeze tenant\n- POST /v1/killswitch/key - Freeze API key\n- GET /v1/killswitch/status - Get freeze status\n- DELETE /v1/killswitch/tenant - Unfreeze tenant\n- DELETE /v1/killswitch/key - Unfreeze API key\n- GET /v1/policies/active - Get active guardrails\n- GET /v1/incidents - List incidents\n- GET /v1/incidents/{id} - Get incident detail\n- POST /v1/replay/{call_id} - Replay a call\n- GET /v1/calls/{call_id} - Get call detail\n\nM28: Demo endpoint /v1/demo/simulate-incident removed (PIN-145)\n\nTier Gating (M32 - PIN-158):\n- OBSERVE ($0): Read-only status, policies, incidents\n- REACT ($9): Killswitch write (freeze/unfreeze) - \"You see the fire\"\n- PREVENT ($199): Replay for evidence - \"You stop the fire\"",
        "functions": [
          {
            "name": "utc_now",
            "signature": "() -> datetime",
            "docstring": null,
            "is_async": false,
            "line": 168
          },
          {
            "name": "freeze_tenant",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID to freeze'), action: KillSwitchAction = None, session = Depends(get_sync_session_dep), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('killswitch.write')))",
            "docstring": "Hard stop everything for a tenant.\n\n**Tier: REACT ($9)** - Emergency response capability. \"You see the fire.\"\n\nImmediate. No in-flight retries. Sticky until manually lifted.",
            "is_async": true,
            "line": 178
          },
          {
            "name": "freeze_key",
            "signature": "(key_id: str = Query(..., description='API key ID to freeze'), action: KillSwitchAction = None, session = Depends(get_sync_session_dep), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('killswitch.write')))",
            "docstring": "Kill a single API key.\n\n**Tier: REACT ($9)** - Emergency response capability. \"You see the fire.\"\n\nUse cases: Compromised key, rogue experiment, limit damage.",
            "is_async": true,
            "line": 265
          },
          {
            "name": "get_killswitch_status",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('killswitch.read')))",
            "docstring": "Get complete kill switch status for a tenant.\n\n**Tier: REACT ($9)** - KillSwitch visibility.\n\nShows tenant state plus all key overrides.",
            "is_async": true,
            "line": 352
          },
          {
            "name": "unfreeze_tenant",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID to unfreeze'), actor: str = Query(default='system', description='Who is unfreezing'), session = Depends(get_sync_session_dep), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('killswitch.write')))",
            "docstring": "Unfreeze a tenant.\n\n**Tier: REACT ($9)** - Emergency response capability.",
            "is_async": true,
            "line": 421
          },
          {
            "name": "unfreeze_key",
            "signature": "(key_id: str = Query(..., description='API key ID to unfreeze'), actor: str = Query(default='system', description='Who is unfreezing'), session = Depends(get_sync_session_dep), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('killswitch.write')))",
            "docstring": "Unfreeze an API key.\n\n**Tier: REACT ($9)** - Emergency response capability.",
            "is_async": true,
            "line": 497
          },
          {
            "name": "get_active_policies",
            "signature": "(session = Depends(get_sync_session_dep), ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get active guardrails - \"What's protecting me right now?\"\n\n**Tier: OBSERVE ($0)** - Basic visibility into protection.\n\nReturns the Default Guardrail Pack v1 (read-only).\nNo editing in MVP - this is intentional for trust.",
            "is_async": true,
            "line": 578
          },
          {
            "name": "list_incidents",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(default=50, le=100), offset: int = Query(default=0), session = Depends(get_sync_session_dep), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('incident.list')))",
            "docstring": "List incidents (auto-grouped failures).\n\n**Tier: REACT ($9)** - Incident visibility. \"You see the fire.\"\n\nAn incident = correlated failures + retries + cost spike within time window.",
            "is_async": true,
            "line": 625
          },
          {
            "name": "get_incident",
            "signature": "(incident_id: str, session = Depends(get_sync_session_dep), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('incident.read')))",
            "docstring": "Get incident detail with timeline.\n\n**Tier: REACT ($9)** - Incident visibility. \"You see the fire.\"\n\nOne-screen explanation readable by a founder at 2am.",
            "is_async": true,
            "line": 678
          },
          {
            "name": "replay_call",
            "signature": "(call_id: str, request: ReplayRequest = None, session = Depends(get_sync_session_dep), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.replay')), auth: AuthorityResult = Depends(require_replay_execute))",
            "docstring": "REPLAY PROVES ENFORCEMENT\n\n**Tier: PREVENT ($199)** - Evidence and compliance verification. \"You stop the fire.\"\n\nLanguage layer: This is NOT \"re-execution\" - it's PROOF.\nReplay demonstrates that your guardrails are working correctly.\n\nGuarantees:\n- Same input\n- Same policy evaluation\n- Same routing decision\n- Deterministic outcome\n\nReturns comparison showing enforcement consistency.",
            "is_async": true,
            "line": 758
          },
          {
            "name": "get_call",
            "signature": "(call_id: str, session = Depends(get_sync_session_dep), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('timeline.read')))",
            "docstring": "Get single call truth.\n\n**Tier: REACT ($9)** - Decision timeline visibility.\n\nIncludes input hash, policy decisions, cost, outcome, replay eligibility.",
            "is_async": true,
            "line": 843
          }
        ],
        "classes": [
          {
            "name": "TriggerType",
            "docstring": null,
            "methods": [],
            "line": 61
          },
          {
            "name": "KillSwitchAction",
            "docstring": null,
            "methods": [],
            "line": 69
          },
          {
            "name": "KillSwitchStatus",
            "docstring": null,
            "methods": [],
            "line": 74
          },
          {
            "name": "GuardrailSummary",
            "docstring": null,
            "methods": [],
            "line": 85
          },
          {
            "name": "IncidentSummary",
            "docstring": null,
            "methods": [],
            "line": 95
          },
          {
            "name": "IncidentDetail",
            "docstring": null,
            "methods": [],
            "line": 108
          },
          {
            "name": "ReplayRequest",
            "docstring": null,
            "methods": [],
            "line": 125
          },
          {
            "name": "ReplayResult",
            "docstring": null,
            "methods": [],
            "line": 129
          },
          {
            "name": "ProxyCallDetail",
            "docstring": null,
            "methods": [],
            "line": 137
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "emit_authority_audit",
              "require_replay_execute"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_operation_registry",
              "get_sync_session_dep",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "workers.py",
        "file_path": "backend/app/hoc/api/cus/policies/workers.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1595,
        "module_docstring": "API endpoints for Business Builder Worker.\n\nEndpoints:\n- POST /workers/business-builder/run - Execute the worker\n- POST /workers/business-builder/replay - Replay a previous execution\n- GET /workers/business-builder/runs/{run_id} - Get run details\n- GET /workers/business-builder/runs - List recent runs\n- POST /workers/business-builder/validate-brand - Validate brand schema\n- GET /workers/business-builder/stream/{run_id} - SSE stream for real-time updates\n\nAll endpoints require authentication via API key or Bearer token.",
        "functions": [
          {
            "name": "_get_workers_adapter",
            "signature": "()",
            "docstring": "Get the L3 workers adapter.\n\nThis is the ONLY way L2 should access worker functionality.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": false,
            "line": 76
          },
          {
            "name": "_calculate_cost_cents",
            "signature": "(model: str, input_tokens: int, output_tokens: int) -> int",
            "docstring": "Calculate LLM cost in cents via L3 adapter.\n\nPhase F-3: This replaces the direct L5 import.",
            "is_async": false,
            "line": 88
          },
          {
            "name": "_store_run",
            "signature": "(run_id: str, data: Dict[str, Any], tenant_id: str = 'default') -> None",
            "docstring": "Persist a run to PostgreSQL.\n\nP0-005 Fix: Database is the source of truth, not memory.",
            "is_async": true,
            "line": 256
          },
          {
            "name": "_insert_cost_record",
            "signature": "(run_id: str, tenant_id: str, model: str, input_tokens: int, output_tokens: int, cost_cents: int) -> None",
            "docstring": "Insert a cost record for a worker run.\n\nP0-006 Fix: Cost must be recorded as part of worker execution.\nThis creates the authoritative cost fact that S2 requires.",
            "is_async": true,
            "line": 302
          },
          {
            "name": "_check_and_emit_cost_advisory",
            "signature": "(run_id: str, tenant_id: str, cost_cents: int) -> Dict[str, Any]",
            "docstring": "Check if cost threshold is crossed and emit advisory if needed.\n\nS2 Advisory Invariant:\n- If threshold crossed AND hard_limit_enabled=false \u2192 exactly 1 advisory\n- If threshold NOT crossed \u2192 exactly 0 advisories\n- If hard_limit_enabled=true \u2192 this is an incident, not advisory (out of S2 scope)\n\nReturns dict with:\n- threshold_crossed: bool\n- advisory_emitted: bool\n- advisory_id: str | None\n- budget_id: str | None",
            "is_async": true,
            "line": 340
          },
          {
            "name": "_verify_advisory_invariant",
            "signature": "(run_id: str, tenant_id: str, advisory_result: Dict[str, Any]) -> None",
            "docstring": "Verify advisory emission invariant in VERIFICATION_MODE.\n\nS2 Invariant:\n- If threshold_crossed=true AND hard_limit_enabled=false \u2192 advisory_count must be 1\n- If threshold_crossed=false \u2192 advisory_count must be 0\n\nRaises RuntimeError if invariant violated.",
            "is_async": true,
            "line": 464
          },
          {
            "name": "_get_run",
            "signature": "(run_id: str) -> Optional[Dict[str, Any]]",
            "docstring": "Get a run from PostgreSQL via L4 registry.\n\nReturns dict format matching WorkerRunResponse for API compatibility.",
            "is_async": true,
            "line": 521
          },
          {
            "name": "_list_runs",
            "signature": "(limit: int = 20, tenant_id: Optional[str] = None) -> List[Dict[str, Any]]",
            "docstring": "List recent runs from PostgreSQL via L4 registry.",
            "is_async": true,
            "line": 543
          },
          {
            "name": "get_event_bus",
            "signature": "() -> WorkerEventBus",
            "docstring": "Get the global event bus instance.",
            "is_async": false,
            "line": 629
          },
          {
            "name": "_brand_request_to_schema",
            "signature": "(brand_req: BrandRequest)",
            "docstring": "Convert API request to BrandSchema via L3 adapter.\n\nPhase F-3: This replaces the direct L5 schema import.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": false,
            "line": 660
          },
          {
            "name": "_execute_worker_async",
            "signature": "(run_id: str, request: WorkerRunRequest) -> None",
            "docstring": "Execute worker in background and update run store.\n\nPhase F-3: Uses L3 adapter instead of direct L5 worker import.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": true,
            "line": 671
          },
          {
            "name": "run_worker",
            "signature": "(request: WorkerRunRequest, background_tasks: BackgroundTasks, _: str = Depends(verify_api_key))",
            "docstring": "Execute the Business Builder Worker.\n\nTakes a business idea and optionally brand constraints, produces a complete\nlaunch package including:\n- Market research\n- Brand strategy\n- Landing page copy\n- HTML/CSS assets\n- Replay token for deterministic reproduction\n\nIntegrates with:\n- M4: Golden replay (deterministic execution)\n- M9: Failure catalog (pattern detection)\n- M10: Recovery engine (auto-recovery)\n- M15: SBA (strategy-bound agents)\n- M17: CARE (complexity-aware routing)\n- M18: Drift detection\n- M19/M20: Policy governance",
            "is_async": true,
            "line": 807
          },
          {
            "name": "replay_execution_endpoint",
            "signature": "(request: ReplayRequest, auth: AuthorityResult = Depends(require_replay_execute))",
            "docstring": "Replay a previous execution using Golden Replay (M4).\n\nDeterministically reproduces the same outputs given the same replay token.\n\nPhase F-3: Uses L3 adapter instead of direct L5 worker import.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": true,
            "line": 1021
          },
          {
            "name": "get_run",
            "signature": "(run_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Get details of a worker run.\n\nUse this to poll for async run completion or inspect past runs.",
            "is_async": true,
            "line": 1068
          },
          {
            "name": "list_runs",
            "signature": "(limit: int = 20, tenant_id: Optional[str] = None, _: str = Depends(verify_api_key))",
            "docstring": "List recent worker runs.\n\nReturns summary information for recent executions.\nOptionally filter by tenant_id.",
            "is_async": true,
            "line": 1085
          },
          {
            "name": "retry_run",
            "signature": "(run_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Retry a completed or failed run - Phase-2.5.\n\nCreates a new run linked to the original via parent_run_id.\nThis is a lifecycle event, not execution - the run is queued only.\n\nRules:\n- Original run must be COMPLETED or FAILED\n- No agent execution triggered\n- DB write only, deterministic",
            "is_async": true,
            "line": 1114
          },
          {
            "name": "validate_brand",
            "signature": "(request: BrandRequest, _: str = Depends(verify_api_key))",
            "docstring": "Validate a brand schema without executing the worker.\n\nChecks:\n- Schema validity\n- Policy rules generation (M19)\n- Drift anchors extraction (M18)",
            "is_async": true,
            "line": 1192
          },
          {
            "name": "worker_health",
            "signature": "()",
            "docstring": "Health check for Business Builder Worker.\n\nReturns status of all integrated moats.\nPIN-520 Phase 1: Route L5 health checks through L4 registry.",
            "is_async": true,
            "line": 1243
          },
          {
            "name": "delete_run",
            "signature": "(run_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Delete a run from storage.\n\nNote: In production, this would require admin privileges.",
            "is_async": true,
            "line": 1306
          },
          {
            "name": "get_brand_schema",
            "signature": "()",
            "docstring": "Get the JSON schema for BrandRequest.\n\nUseful for clients to understand the expected format.",
            "is_async": true,
            "line": 1328
          },
          {
            "name": "get_run_schema",
            "signature": "()",
            "docstring": "Get the JSON schema for WorkerRunRequest.",
            "is_async": true,
            "line": 1338
          },
          {
            "name": "_sse_event_generator",
            "signature": "(run_id: str, queue: asyncio.Queue) -> AsyncGenerator[str, None]",
            "docstring": "Generate SSE events from the queue.",
            "is_async": true,
            "line": 1350
          },
          {
            "name": "stream_run_events",
            "signature": "(run_id: str, request: Request)",
            "docstring": "Stream real-time events for a worker run via Server-Sent Events (SSE).\n\nEvents include:\n- run_started: Worker execution began\n- stage_started/completed/failed: Stage lifecycle\n- log: Agent output logs\n- routing_decision: CARE routing decisions\n- policy_check/violation: M19 policy events\n- drift_detected: M18 drift detection\n- failure_detected: M9 failure pattern match\n- recovery_started/completed: M10 recovery actions\n- artifact_created: New artifact generated\n- run_completed/failed: Terminal state\n\nUsage (JavaScript):\n```js\nconst sse = new EventSource('/workers/business-builder/stream/{run_id}');\nsse.onmessage = (event) => console.log(JSON.parse(event.data));\nsse.addEventListener('stage_completed', (event) => { ... });\n```",
            "is_async": true,
            "line": 1383
          },
          {
            "name": "get_run_events",
            "signature": "(run_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Get all events for a run (non-streaming).\n\nUseful for replaying events or debugging.",
            "is_async": true,
            "line": 1429
          },
          {
            "name": "_execute_worker_with_events",
            "signature": "(run_id: str, request: WorkerRunRequest) -> None",
            "docstring": "Execute worker with REAL event emission from worker itself.\n\nv0.4: Worker is source of truth. PostgreSQL persistence. No in-memory storage.\n\nPhase F-3: Uses L3 adapter instead of direct L5 worker import.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": true,
            "line": 1451
          },
          {
            "name": "run_worker_streaming",
            "signature": "(request: WorkerRunRequest, background_tasks: BackgroundTasks, _: str = Depends(verify_api_key))",
            "docstring": "Execute the Business Builder Worker with real-time event streaming.\n\nReturns immediately with run_id. Connect to /stream/{run_id} for real-time events.\n\nThis is the preferred endpoint for UI-driven execution where you want to\nshow progress, routing decisions, and artifacts building in real-time.",
            "is_async": true,
            "line": 1548
          }
        ],
        "classes": [
          {
            "name": "ToneRuleRequest",
            "docstring": "Tone rule for brand.",
            "methods": [],
            "line": 106
          },
          {
            "name": "ForbiddenClaimRequest",
            "docstring": "Forbidden claim definition.",
            "methods": [],
            "line": 115
          },
          {
            "name": "VisualIdentityRequest",
            "docstring": "Visual identity for brand.",
            "methods": [],
            "line": 123
          },
          {
            "name": "BrandRequest",
            "docstring": "Brand schema for worker execution.",
            "methods": [],
            "line": 133
          },
          {
            "name": "WorkerRunRequest",
            "docstring": "Request to run the Business Builder Worker.",
            "methods": [],
            "line": 151
          },
          {
            "name": "PolicyStatusModel",
            "docstring": "Phase 5B: Policy pre-check status for PRE-RUN declaration.",
            "methods": [],
            "line": 170
          },
          {
            "name": "WorkerRunResponse",
            "docstring": "Response from worker execution.",
            "methods": [],
            "line": 181
          },
          {
            "name": "ReplayRequest",
            "docstring": "Request to replay a previous execution.",
            "methods": [],
            "line": 203
          },
          {
            "name": "BrandValidationResponse",
            "docstring": "Response from brand validation.",
            "methods": [],
            "line": 209
          },
          {
            "name": "RunListItem",
            "docstring": "Summary item for run listing.",
            "methods": [],
            "line": 219
          },
          {
            "name": "RunListResponse",
            "docstring": "Response for listing runs.",
            "methods": [],
            "line": 230
          },
          {
            "name": "RunRetryResponse",
            "docstring": "Response for run retry - Phase-2.5.",
            "methods": [],
            "line": 237
          },
          {
            "name": "WorkerEventBus",
            "docstring": "Event bus for real-time worker execution streaming.\n\nSupports multiple subscribers per run_id.\nEvents are JSON-serialized and sent as SSE.",
            "methods": [
              "__init__",
              "subscribe",
              "unsubscribe",
              "emit",
              "get_history",
              "cleanup"
            ],
            "line": 568
          },
          {
            "name": "EventType",
            "docstring": "Constants for SSE event types.",
            "methods": [],
            "line": 635
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "collections",
            "names": [
              "defaultdict"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "AsyncGenerator",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "BackgroundTasks",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "fastapi.responses",
            "names": [
              "StreamingResponse"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth",
            "names": [
              "verify_api_key"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "emit_authority_audit",
              "require_replay_execute"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.contracts.decisions",
            "names": [
              "emit_policy_precheck_decision"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_async_session_context",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.hoc.cus.hoc_spine.drivers.worker_write_driver_async",
            "names": [
              "WorkerWriteServiceAsync"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges",
            "names": [
              "get_policies_engine_bridge"
            ],
            "is_relative": false,
            "line": 64
          }
        ],
        "constants": [
          {
            "name": "VERIFICATION_MODE",
            "line": 250
          },
          {
            "name": "COST_ENFORCEMENT_ENABLED",
            "line": 253
          }
        ],
        "all_exports": null
      }
    ],
    "l4_spine": [],
    "l5_engines": [
      {
        "file_name": "ast.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/ast.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 381,
        "module_docstring": "Policy DSL Abstract Syntax Tree (AST) Definitions\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- All nodes are IMMUTABLE (frozen dataclasses)\n- No dynamic fields\n- No generic dicts (typed structures only)\n- No runtime evaluation logic\n- Must be serializable to JSON\n\nGOVERNANCE:\n- These types define the MEANING of policy structure\n- No authority, no execution, no side effects",
        "functions": [
          {
            "name": "is_predicate",
            "signature": "(condition: Condition) -> bool",
            "docstring": "Check if condition is a simple predicate.",
            "is_async": false,
            "line": 354
          },
          {
            "name": "is_exists_predicate",
            "signature": "(condition: Condition) -> bool",
            "docstring": "Check if condition is an exists predicate.",
            "is_async": false,
            "line": 359
          },
          {
            "name": "is_logical_condition",
            "signature": "(condition: Condition) -> bool",
            "docstring": "Check if condition is a compound logical condition.",
            "is_async": false,
            "line": 364
          },
          {
            "name": "is_warn_action",
            "signature": "(action: Action) -> bool",
            "docstring": "Check if action is a WARN action.",
            "is_async": false,
            "line": 369
          },
          {
            "name": "is_block_action",
            "signature": "(action: Action) -> bool",
            "docstring": "Check if action is a BLOCK action.",
            "is_async": false,
            "line": 374
          },
          {
            "name": "is_require_approval_action",
            "signature": "(action: Action) -> bool",
            "docstring": "Check if action is a REQUIRE_APPROVAL action.",
            "is_async": false,
            "line": 379
          }
        ],
        "classes": [
          {
            "name": "Scope",
            "docstring": "Policy scope determines visibility boundaries.",
            "methods": [],
            "line": 48
          },
          {
            "name": "Mode",
            "docstring": "Policy mode determines enforcement semantics.\n\nMONITOR: Can only WARN, cannot BLOCK or REQUIRE_APPROVAL\nENFORCE: Can WARN, BLOCK, or REQUIRE_APPROVAL",
            "methods": [],
            "line": 55
          },
          {
            "name": "Comparator",
            "docstring": "Comparison operators for predicates.",
            "methods": [],
            "line": 67
          },
          {
            "name": "LogicalOperator",
            "docstring": "Logical operators for compound conditions.",
            "methods": [],
            "line": 78
          },
          {
            "name": "WarnAction",
            "docstring": "Emit a warning message.\nAllowed in both MONITOR and ENFORCE modes.",
            "methods": [
              "to_dict"
            ],
            "line": 91
          },
          {
            "name": "BlockAction",
            "docstring": "Block execution.\nONLY allowed in ENFORCE mode (validated by validator.py).",
            "methods": [
              "to_dict"
            ],
            "line": 105
          },
          {
            "name": "RequireApprovalAction",
            "docstring": "Require human approval before proceeding.\nONLY allowed in ENFORCE mode (validated by validator.py).",
            "methods": [
              "to_dict"
            ],
            "line": 118
          },
          {
            "name": "Predicate",
            "docstring": "A simple comparison predicate.\n\nExample: cost_per_hour > 200",
            "methods": [
              "to_dict"
            ],
            "line": 140
          },
          {
            "name": "ExistsPredicate",
            "docstring": "Check if a metric exists.\n\nExample: exists(anomaly_flag)",
            "methods": [
              "to_dict"
            ],
            "line": 161
          },
          {
            "name": "LogicalCondition",
            "docstring": "A compound condition combining two conditions with AND/OR.\n\nExample: cost_per_hour > 200 AND error_rate > 0.1",
            "methods": [
              "to_dict"
            ],
            "line": 178
          },
          {
            "name": "Clause",
            "docstring": "A single when-then clause.\n\nStructure:\n    when <condition>\n    then <action>+",
            "methods": [
              "__post_init__",
              "to_dict"
            ],
            "line": 208
          },
          {
            "name": "PolicyMetadata",
            "docstring": "Policy metadata header.\n\nRequired fields per PIN-341:\n- name: Policy identifier\n- version: Version number (monotonically increasing)\n- scope: ORG or PROJECT\n- mode: MONITOR or ENFORCE",
            "methods": [
              "__post_init__",
              "to_dict"
            ],
            "line": 238
          },
          {
            "name": "PolicyAST",
            "docstring": "Root AST node for a complete policy.\n\nStructure:\n    policy <name>\n    version <n>\n    scope <ORG|PROJECT>\n    mode <MONITOR|ENFORCE>\n\n    when <condition>\n    then <action>+\n    [... more clauses ...]\n\nIMMUTABILITY: This entire structure is frozen.\nSERIALIZATION: Use to_dict() or to_json() for serialization.\nHASHING: Use compute_hash() for deterministic content hash.",
            "methods": [
              "__post_init__",
              "to_dict",
              "to_json",
              "compute_hash",
              "name",
              "version",
              "scope",
              "mode"
            ],
            "line": 277
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Literal",
              "Union"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "authority_checker.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/authority_checker.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 284,
        "module_docstring": "Module: authority_checker\nPurpose: Check override authority status for prevention engine.\n\nThe prevention engine must check override authority before enforcing\nany policy actions. If an override is active, enforcement is skipped.\n\nIntegration Flow:\n    1. Prevention engine receives policy ID\n    2. Calls OverrideAuthorityChecker.check()\n    3. If override is active, skip enforcement\n    4. If no override, proceed with enforcement\n\nExports:\n    - OverrideStatus: Enum of override states\n    - OverrideCheckResult: Result of an override check\n    - OverrideAuthorityChecker: Main integration class\n    - should_skip_enforcement: Quick helper function",
        "functions": [
          {
            "name": "should_skip_enforcement",
            "signature": "(override_authority: Any) -> bool",
            "docstring": "Quick helper to check if enforcement should be skipped.\n\nArgs:\n    override_authority: OverrideAuthority model instance or None\n\nReturns:\n    True if enforcement should be skipped, False otherwise",
            "is_async": false,
            "line": 272
          }
        ],
        "classes": [
          {
            "name": "OverrideStatus",
            "docstring": "Status of an override check.",
            "methods": [],
            "line": 46
          },
          {
            "name": "OverrideCheckResult",
            "docstring": "Result of an override authority check.\n\nContains the status and metadata about any active override.",
            "methods": [
              "to_dict"
            ],
            "line": 56
          },
          {
            "name": "OverrideAuthorityChecker",
            "docstring": "Checks override authority status for the prevention engine.\n\nThe prevention engine must call this before enforcing any\npolicy actions to respect active overrides.\n\nGAP-034: Wire OverrideAuthority to prevention.\n\nUsage:\n    checker = OverrideAuthorityChecker()\n    result = checker.check(override_authority)\n    if result.skip_enforcement:\n        # Skip policy enforcement\n        log.info(f\"Skipping enforcement: override by {result.override_by}\")\n    else:\n        # Proceed with enforcement\n        enforce_policy()",
            "methods": [
              "check",
              "_is_override_active",
              "check_from_dict"
            ],
            "line": 90
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "binding_moment_enforcer.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/binding_moment_enforcer.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 276,
        "module_docstring": "Module: binding_moment_enforcer\nPurpose: Ensures policies are evaluated at the correct binding moment.\n\nBinding moments define WHEN a policy is evaluated:\n- RUN_START: Evaluate once at run start (snapshot-based)\n- STEP_START: Evaluate before each step\n- STEP_END: Evaluate after each step\n- ON_CHANGE: Evaluate when specific fields change\n\nIf a policy has bind_at=RUN_START, it should NOT be re-evaluated mid-run.\n\nImports (Dependencies):\n    - None (standalone)\n\nExports (Provides):\n    - should_evaluate_policy(policy, context) -> bool\n    - BindingMoment: Enum\n    - get_binding_moment(policy) -> BindingMoment\n\nWiring Points:\n    - Called from: prevention_engine.py before evaluating each policy\n\nAcceptance Criteria:\n    - [x] AC-031-01: RUN_START binding respected\n    - [x] AC-031-02: STEP_START binding respected\n    - [x] AC-031-03: Mid-run re-eval blocked for RUN_START\n    - [x] AC-031-04: Binding moment logged",
        "functions": [
          {
            "name": "should_evaluate_policy",
            "signature": "(policy: Any, context: Dict[str, Any], evaluation_point: EvaluationPoint) -> BindingDecision",
            "docstring": "Determine if a policy should be evaluated at this point.\n\nRespects the policy's bind_at setting:\n- RUN_START: Only evaluate once per run, at initialization\n- STEP_START: Evaluate before each step\n- STEP_END: Evaluate after each step\n- ON_CHANGE: Evaluate only when monitored fields change\n- ALWAYS: Evaluate at every point\n\nArgs:\n    policy: Policy object with bind_at attribute\n    context: Evaluation context with run_id, step info, etc.\n    evaluation_point: Current point in execution\n\nReturns:\n    BindingDecision with should_evaluate and reason",
            "is_async": false,
            "line": 89
          },
          {
            "name": "get_binding_moment",
            "signature": "(policy: Any) -> BindingMoment",
            "docstring": "Get the binding moment for a policy.\n\nArgs:\n    policy: Policy object\n\nReturns:\n    BindingMoment enum value",
            "is_async": false,
            "line": 201
          },
          {
            "name": "clear_run_cache",
            "signature": "(run_id: str) -> None",
            "docstring": "Clear the evaluation cache for a run (call on run completion).",
            "is_async": false,
            "line": 242
          },
          {
            "name": "_mark_evaluated",
            "signature": "(run_id: str, policy_id: str) -> None",
            "docstring": "Mark a policy as evaluated for a run.",
            "is_async": false,
            "line": 248
          },
          {
            "name": "_was_evaluated",
            "signature": "(run_id: str, policy_id: str) -> bool",
            "docstring": "Check if a policy was already evaluated for a run.",
            "is_async": false,
            "line": 255
          },
          {
            "name": "_check_fields_changed",
            "signature": "(policy: Any, context: Dict[str, Any]) -> bool",
            "docstring": "Check if monitored fields changed (for ON_CHANGE binding).",
            "is_async": false,
            "line": 260
          }
        ],
        "classes": [
          {
            "name": "BindingMoment",
            "docstring": "When a policy should be evaluated.",
            "methods": [],
            "line": 58
          },
          {
            "name": "EvaluationPoint",
            "docstring": "Current point in execution where evaluation is requested.",
            "methods": [],
            "line": 67
          },
          {
            "name": "BindingDecision",
            "docstring": "Decision about whether to evaluate a policy.",
            "methods": [],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "Optional",
              "Any",
              "Dict",
              "Set"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "compiler_parser.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/compiler_parser.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 460,
        "module_docstring": "Parser for PLang v2.0 with M19 category support.\n\nProduces an AST from tokens, supporting:\n- Policy declarations with categories\n- Rule declarations with priorities\n- Condition blocks (when/then)\n- Action blocks (deny/allow/escalate/route)\n- Expression evaluation",
        "functions": [],
        "classes": [
          {
            "name": "ParseError",
            "docstring": "Error during parsing.",
            "methods": [
              "__init__"
            ],
            "line": 57
          },
          {
            "name": "Parser",
            "docstring": "Parser for PLang v2.0.\n\nConverts tokens into an AST with M19 governance metadata.",
            "methods": [
              "__init__",
              "from_source",
              "current",
              "peek",
              "advance",
              "expect",
              "match",
              "parse",
              "parse_policy_decl",
              "parse_category",
              "parse_policy_body",
              "parse_rule_decl",
              "parse_rule_body",
              "parse_rule_ref",
              "parse_condition_block",
              "parse_action_block",
              "parse_route_target",
              "parse_priority",
              "parse_import",
              "parse_expr",
              "parse_or_expr",
              "parse_and_expr",
              "parse_not_expr",
              "parse_comparison",
              "parse_value",
              "parse_func_call"
            ],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.policy.ast.nodes",
            "names": [
              "ActionBlockNode",
              "ASTNode",
              "AttrAccessNode",
              "BinaryOpNode",
              "ConditionBlockNode",
              "ExprNode",
              "FuncCallNode",
              "IdentNode",
              "ImportNode",
              "LiteralNode",
              "PolicyDeclNode",
              "PriorityNode",
              "ProgramNode",
              "RouteTargetNode",
              "RuleDeclNode",
              "RuleRefNode",
              "UnaryOpNode"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.policy.compiler.tokenizer",
            "names": [
              "Token",
              "Tokenizer",
              "TokenType"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "content_accuracy.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/content_accuracy.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 386,
        "module_docstring": null,
        "functions": [
          {
            "name": "validate_content_accuracy",
            "signature": "(output: str, context: Dict[str, Any], user_query: Optional[str] = None, strict_mode: bool = True) -> ContentAccuracyResult",
            "docstring": "Convenience function to validate content accuracy.\n\nUsage:\n    result = validate_content_accuracy(\n        output=\"Yes, your contract is set to auto-renew on January 1, 2026.\",\n        context={\"auto_renew\": None, \"customer_id\": \"cust_8372\"},\n        user_query=\"Is my contract auto-renewed?\"\n    )\n\n    if result.result == ValidationResult.FAIL:\n        # Block the response or create incident\n        pass",
            "is_async": false,
            "line": 344
          }
        ],
        "classes": [
          {
            "name": "AssertionType",
            "docstring": "Types of assertions detected in output.",
            "methods": [],
            "line": 36
          },
          {
            "name": "ValidationResult",
            "docstring": "Result of content accuracy validation.",
            "methods": [],
            "line": 45
          },
          {
            "name": "AssertionCheck",
            "docstring": "A single assertion check result.",
            "methods": [],
            "line": 54
          },
          {
            "name": "ContentAccuracyResult",
            "docstring": "Complete result of content accuracy validation.",
            "methods": [
              "to_dict"
            ],
            "line": 67
          },
          {
            "name": "ContentAccuracyValidator",
            "docstring": "Validates that LLM output does not make assertions about missing data.\n\nPrevention mechanism for the CONTENT_ACCURACY policy gap:\n- Detects when output makes definitive claims\n- Checks if the claimed data exists in context\n- Blocks/warns when assertions are made about NULL/missing fields",
            "methods": [
              "__init__",
              "validate",
              "_detect_assertion_type",
              "_get_nested_value",
              "_extract_claim",
              "_claims_affirmative"
            ],
            "line": 158
          }
        ],
        "imports": [
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          }
        ],
        "constants": [
          {
            "name": "DEFINITIVE_PATTERNS",
            "line": 104
          },
          {
            "name": "UNCERTAINTY_PATTERNS",
            "line": 119
          },
          {
            "name": "HEDGED_PATTERNS",
            "line": 135
          },
          {
            "name": "CONTRACT_TERMS",
            "line": 149
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "cus_enforcement_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/cus_enforcement_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 559,
        "module_docstring": "Customer Enforcement Engine\n\nL4 engine for enforcement policy decisions.\n\nDecides: Integration status, budget limits, token limits, rate limits\nDelegates: All data access to CusEnforcementDriver\n\nENFORCEMENT RESULT HIERARCHY:\n    HARD_BLOCKED > BLOCKED > THROTTLED > WARNED > ALLOWED",
        "functions": [
          {
            "name": "get_cus_enforcement_engine",
            "signature": "() -> CusEnforcementEngine",
            "docstring": "Get engine instance with default driver.\n\nReturns:\n    CusEnforcementEngine instance",
            "is_async": false,
            "line": 551
          }
        ],
        "classes": [
          {
            "name": "EnforcementResult",
            "docstring": "Enforcement decision result.\n\nOrdered from most restrictive to least restrictive.",
            "methods": [],
            "line": 33
          },
          {
            "name": "EnforcementReason",
            "docstring": "Explanation for an enforcement decision.",
            "methods": [],
            "line": 47
          },
          {
            "name": "EnforcementDecision",
            "docstring": "Complete enforcement decision with explainability.",
            "methods": [
              "to_dict"
            ],
            "line": 60
          },
          {
            "name": "CusEnforcementEngine",
            "docstring": "L4 engine for enforcement policy decisions.\n\nDecides: Status checks, budget limits, token limits, rate limits\nDelegates: All data access to CusEnforcementDriver",
            "methods": [
              "__init__",
              "evaluate",
              "_check_budget",
              "_check_tokens",
              "_check_rate",
              "evaluate_batch",
              "get_enforcement_status"
            ],
            "line": 95
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 15
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 16
          },
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 17
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.cus_enforcement_driver",
            "names": [
              "CusEnforcementDriver",
              "IntegrationRow",
              "get_cus_enforcement_driver"
            ],
            "is_relative": false,
            "line": 21
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "customer_policy_read_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/customer_policy_read_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 343,
        "module_docstring": "Customer Policy Read Service (L4)\n\nThis service provides all READ operations for the Policy domain.\nIt delegates DB access to PolicyReadDriver (L6) and applies business logic.\n\nL3 (Adapter) \u2192 L4 (this service) \u2192 L6 (PolicyReadDriver)\n\nResponsibilities:\n- Calculate period bounds (business logic)\n- Calculate budget remaining/percentage (business logic)\n- Assemble customer-safe DTOs\n- Rate limits defaults (business logic)\n- Delegate DB queries to driver\n\nBusiness Logic (stays in L4):\n- _calculate_period_bounds() - daily/weekly/monthly period calculation\n- Budget remaining calculation\n- Percentage calculation\n- Rate limit defaults\n\nReference: PIN-281, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_customer_policy_read_service",
            "signature": "(session: 'Session') -> CustomerPolicyReadService",
            "docstring": "Factory function for CustomerPolicyReadService.\n\nArgs:\n    session: SQLModel session (REQUIRED - must be provided by L3 adapter)\n\nReturns:\n    Configured CustomerPolicyReadService instance\n\nNote:\n    Session must be provided by caller. This engine does not create sessions.\n    Session creation is the responsibility of L3 adapters.",
            "is_async": false,
            "line": 329
          }
        ],
        "classes": [
          {
            "name": "BudgetConstraint",
            "docstring": "Customer-visible budget constraint.\n\nIMPORTANT: No internal threshold multipliers, no warning levels.\nThis is what customers see for their budget status.",
            "methods": [],
            "line": 67
          },
          {
            "name": "RateLimit",
            "docstring": "Customer-visible rate limit.\n\nIMPORTANT: No internal bucket configuration exposed.",
            "methods": [],
            "line": 84
          },
          {
            "name": "GuardrailSummary",
            "docstring": "Customer-visible guardrail summary.\n\nIMPORTANT: No threshold values, no rule_config, no priority.\nCustomers see what guardrails exist and their actions, not how they're implemented.",
            "methods": [],
            "line": 98
          },
          {
            "name": "PolicyConstraints",
            "docstring": "Customer-visible policy constraints summary.\n\nThis is the aggregate view of all constraints affecting a tenant.",
            "methods": [],
            "line": 115
          },
          {
            "name": "CustomerPolicyReadService",
            "docstring": "L4 service for policy constraint read operations.\n\nDelegates DB operations to PolicyReadDriver (L6).\nApplies business logic for period calculation, budget math, etc.\n\nINVARIANT: tenant_id is REQUIRED for budget operations.\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "get_policy_constraints",
              "get_guardrail_detail",
              "_get_budget_constraint",
              "_calculate_period_bounds",
              "_get_rate_limits",
              "_get_guardrails"
            ],
            "line": 129
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_read_driver",
            "names": [
              "PolicyReadDriver",
              "get_policy_read_driver"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "dag_executor.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/dag_executor.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 322,
        "module_docstring": "DAG-based executor for PLang v2.0.\n\nExecutes policies in topologically sorted order:\n- Parallel execution within stages\n- Sequential execution across stages\n- Governance-aware ordering\n- Full execution trace",
        "functions": [],
        "classes": [
          {
            "name": "StageResult",
            "docstring": "Result of executing a single stage.",
            "methods": [
              "success",
              "was_blocked"
            ],
            "line": 47
          },
          {
            "name": "ExecutionTrace",
            "docstring": "Full execution trace across all stages.",
            "methods": [
              "to_dict"
            ],
            "line": 69
          },
          {
            "name": "DAGExecutor",
            "docstring": "Executes policies in DAG order.\n\nFeatures:\n- Parallel execution within stages\n- Early termination on DENY\n- Governance-aware execution order\n- Full audit trail",
            "methods": [
              "__init__",
              "execute",
              "_execute_stage",
              "_execute_policy",
              "_is_more_restrictive",
              "get_execution_plan",
              "visualize_plan"
            ],
            "line": 109
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRModule"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.policy.optimizer.dag_sorter",
            "names": [
              "DAGSorter",
              "ExecutionPlan"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.deterministic_engine",
            "names": [
              "DeterministicEngine",
              "ExecutionContext",
              "ExecutionResult"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.intent",
            "names": [
              "Intent"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "decorator.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/decorator.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 192,
        "module_docstring": "@governed Decorator - PIN-337 Optional Ergonomic Wrapper\n\nThis decorator provides convenient syntax for routing execution\nthrough the ExecutionKernel.\n\nIMPORTANT:\n- This decorator is OPTIONAL, not required\n- CI does NOT enforce decorator presence\n- CI enforces KERNEL usage (semantic), not syntax\n- The decorator is CONVENIENCE, the kernel is PHYSICS",
        "functions": [
          {
            "name": "governed",
            "signature": "(capability: str, execution_vector: str = 'HTTP', extract_tenant: Optional[Callable[..., str]] = None, extract_subject: Optional[Callable[..., str]] = None, reason: Optional[str] = None) -> Callable[[F], F]",
            "docstring": "Decorator that routes execution through the ExecutionKernel.\n\nUsage:\n    @governed(capability=\"CAP-019\", execution_vector=\"HTTP_ADMIN\")\n    @app.post(\"/admin/retry\")\n    async def retry_run(payload: RetryRequest):\n        # Business logic here\n        ...\n\nArgs:\n    capability: The capability ID (e.g., \"CAP-019\")\n    execution_vector: Where execution is coming from (HTTP, CLI, SDK, etc.)\n    extract_tenant: Optional callable to extract tenant_id from args/kwargs\n    extract_subject: Optional callable to extract subject from args/kwargs\n    reason: Optional reason for the execution\n\nReturns:\n    Decorated function that routes through kernel\n\nIMPORTANT:\n    - This decorator is OPTIONAL\n    - CI does not enforce decorator presence\n    - CI enforces kernel usage (semantic check)",
            "is_async": false,
            "line": 49
          },
          {
            "name": "_extract_tenant_id",
            "signature": "(args: tuple, kwargs: dict, extractor: Optional[Callable[..., str]]) -> str",
            "docstring": "Extract tenant_id from function arguments.",
            "is_async": false,
            "line": 139
          },
          {
            "name": "_extract_subject",
            "signature": "(args: tuple, kwargs: dict, extractor: Optional[Callable[..., str]]) -> str",
            "docstring": "Extract subject from function arguments.",
            "is_async": false,
            "line": 168
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "functools",
            "names": [
              "functools"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "inspect",
            "names": [
              "inspect"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Optional",
              "TypeVar"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.governance.kernel",
            "names": [
              "ExecutionKernel",
              "InvocationContext"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [
          {
            "name": "F",
            "line": 46
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "degraded_mode.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/degraded_mode.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 217,
        "module_docstring": "Degraded Mode - Graceful Governance Degradation\n\nWhen governance systems are partially unavailable, the system\ncan enter degraded mode:\n- New runs are blocked\n- Existing runs continue with WARN action\n- Telemetry and logging continue\n\nThis prevents cascading failures while maintaining visibility.",
        "functions": [
          {
            "name": "enter_degraded_mode",
            "signature": "(reason: str, entered_by: str, existing_runs_action: str = 'WARN') -> DegradedModeTransition",
            "docstring": "Enter degraded mode.\n\nNew runs will be blocked, existing runs continue with warnings.\n\nArgs:\n    reason: Why degraded mode is being entered\n    entered_by: Identifier of operator/system entering\n    existing_runs_action: Action for in-flight runs (WARN, ALLOW, BLOCK)\n\nReturns:\n    DegradedModeTransition result",
            "is_async": false,
            "line": 71
          },
          {
            "name": "exit_degraded_mode",
            "signature": "(exited_by: str = 'system') -> DegradedModeTransition",
            "docstring": "Exit degraded mode.\n\nRestores normal governance operation.\n\nArgs:\n    exited_by: Identifier of operator/system exiting\n\nReturns:\n    DegradedModeTransition result",
            "is_async": false,
            "line": 120
          },
          {
            "name": "is_degraded_mode_active",
            "signature": "() -> bool",
            "docstring": "Check if degraded mode is currently active.\n\nReturns:\n    True if system is in degraded mode",
            "is_async": false,
            "line": 159
          },
          {
            "name": "get_degraded_mode_status",
            "signature": "() -> DegradedModeStatus",
            "docstring": "Get current degraded mode status.\n\nReturns:\n    Current DegradedModeStatus",
            "is_async": false,
            "line": 170
          },
          {
            "name": "should_allow_new_run",
            "signature": "(run_id: str) -> bool",
            "docstring": "Check if a new run should be allowed.\n\nIn degraded mode, new runs are blocked.\n\nArgs:\n    run_id: ID of the run being started\n\nReturns:\n    True if run should be allowed, False to block",
            "is_async": false,
            "line": 185
          },
          {
            "name": "get_existing_run_action",
            "signature": "() -> str",
            "docstring": "Get action for existing/in-flight runs in degraded mode.\n\nReturns:\n    Action string: WARN, ALLOW, or BLOCK",
            "is_async": false,
            "line": 207
          }
        ],
        "classes": [
          {
            "name": "DegradedModeStatus",
            "docstring": "Current status of degraded mode.",
            "methods": [
              "get_inactive"
            ],
            "line": 47
          },
          {
            "name": "DegradedModeTransition",
            "docstring": "Result of degraded mode transition.",
            "methods": [],
            "line": 63
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "threading",
            "names": [
              "Lock"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "deterministic_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/deterministic_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 560,
        "module_docstring": "Deterministic execution engine for PLang v2.0.\n\nKey principles:\n- NO RANDOMNESS: Every execution is reproducible\n- GOVERNANCE-FIRST: Safety checks before any action\n- AUDITABLE: Full execution trace for debugging\n- DETERMINISTIC: Same input = same output\n\nIntegration points:\n- M18: Intent emission for execution\n- M19: Policy validation before actions\n- M4: Execution plan generation",
        "functions": [
          {
            "name": "safe_regex_match",
            "signature": "(input_str: str, pattern: str) -> bool",
            "docstring": "Safe regex match with length limits and ReDoS guards.\n\nReturns False on any failure (fail-closed).",
            "is_async": false,
            "line": 50
          }
        ],
        "classes": [
          {
            "name": "ExecutionStatus",
            "docstring": "Status of policy execution.",
            "methods": [],
            "line": 90
          },
          {
            "name": "ExecutionContext",
            "docstring": "Execution context for policy evaluation.\n\nContains all runtime state needed for deterministic execution.",
            "methods": [
              "__post_init__",
              "_generate_id",
              "get_variable",
              "set_variable",
              "push_call",
              "pop_call",
              "add_trace"
            ],
            "line": 101
          },
          {
            "name": "ExecutionResult",
            "docstring": "Result of policy execution.\n\nContains final decision, intents, and audit trail.",
            "methods": [
              "to_dict"
            ],
            "line": 184
          },
          {
            "name": "DeterministicEngine",
            "docstring": "Deterministic policy execution engine.\n\nExecutes compiled IR with:\n- No randomness (reproducible)\n- Governance validation\n- Intent emission\n- Full audit trail",
            "methods": [
              "__init__",
              "_register_builtins",
              "execute",
              "_execute_function",
              "_execute_instruction",
              "_eval_binary_op",
              "_eval_unary_op",
              "_eval_compare",
              "_call_function",
              "_action_to_intent_type"
            ],
            "line": 214
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.policies.L5_schemas.policy_check",
            "names": [
              "PolicyCheckValidator"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRAction",
              "IRBinaryOp",
              "IRCall",
              "IRCheckPolicy",
              "IRCompare",
              "IREmitIntent",
              "IRFunction",
              "IRInstruction",
              "IRJump",
              "IRJumpIf",
              "IRLoadConst",
              "IRLoadVar",
              "IRModule",
              "IRReturn",
              "IRStoreVar",
              "IRUnaryOp"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.intent",
            "names": [
              "Intent",
              "IntentEmitter",
              "IntentPayload",
              "IntentType"
            ],
            "is_relative": false,
            "line": 87
          }
        ],
        "constants": [
          {
            "name": "MAX_PATTERN_LEN",
            "line": 45
          },
          {
            "name": "MAX_INPUT_LEN",
            "line": 46
          },
          {
            "name": "_REDOS_PATTERN",
            "line": 47
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "dsl_parser.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/dsl_parser.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 523,
        "module_docstring": "Policy DSL Parser\n\nConverts DSL text into typed, immutable AST nodes.\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- Single-pass recursive descent parser\n- No external parser libraries (no PLY, no ANTLR)\n- All errors must be position-aware\n- Must produce valid AST or raise ParseError\n\nGRAMMAR (Simplified EBNF):\n    policy      := header clause+\n    header      := 'policy' NAME 'version' INT 'scope' SCOPE 'mode' MODE\n    clause      := 'when' condition 'then' action+\n    condition   := or_expr\n    or_expr     := and_expr ('OR' and_expr)*\n    and_expr    := atom ('AND' atom)*\n    atom        := predicate | exists_pred | '(' or_expr ')'\n    predicate   := METRIC comparator value\n    exists_pred := 'exists' '(' METRIC ')'\n    comparator  := '>' | '>=' | '<' | '<=' | '==' | '!='\n    value       := INT | FLOAT | STRING | BOOL\n    action      := 'WARN' STRING | 'BLOCK' | 'REQUIRE_APPROVAL'\n\nGOVERNANCE:\n- Pure parsing logic\n- No side effects\n- No I/O, no DB",
        "functions": [
          {
            "name": "parse",
            "signature": "(source: str) -> PolicyAST",
            "docstring": "Parse Policy DSL text into AST.\n\nArgs:\n    source: The DSL source text\n\nReturns:\n    PolicyAST: The parsed AST\n\nRaises:\n    ParseError: If the source is invalid\n\nExample:\n    >>> ast = parse('''\n    ... policy CostGuard\n    ... version 1\n    ... scope PROJECT\n    ... mode MONITOR\n    ...\n    ... when cost_per_hour > 200\n    ... then WARN \"Cost exceeded threshold\"\n    ... ''')\n    >>> ast.name\n    'CostGuard'",
            "is_async": false,
            "line": 467
          },
          {
            "name": "parse_condition",
            "signature": "(source: str) -> Condition",
            "docstring": "Parse a standalone condition expression.\n\nUseful for testing or building conditions programmatically.\n\nArgs:\n    source: The condition expression\n\nReturns:\n    Condition: The parsed condition\n\nExample:\n    >>> cond = parse_condition(\"cost > 100 AND error_rate > 0.1\")\n    >>> is_logical_condition(cond)\n    True",
            "is_async": false,
            "line": 499
          }
        ],
        "classes": [
          {
            "name": "ParseLocation",
            "docstring": "Source location for error reporting.",
            "methods": [
              "__str__"
            ],
            "line": 81
          },
          {
            "name": "ParseError",
            "docstring": "Raised when parsing fails.\n\nContains position information for helpful error messages.",
            "methods": [
              "__init__"
            ],
            "line": 91
          },
          {
            "name": "Token",
            "docstring": "A lexical token with position info.",
            "methods": [],
            "line": 113
          },
          {
            "name": "Lexer",
            "docstring": "Tokenizer for Policy DSL.\n\nProduces tokens from source text for the parser.",
            "methods": [
              "__init__",
              "tokenize",
              "_advance",
              "_convert_value"
            ],
            "line": 122
          },
          {
            "name": "Parser",
            "docstring": "Recursive descent parser for Policy DSL.\n\nConverts token stream to typed AST.",
            "methods": [
              "__init__",
              "current",
              "error",
              "expect",
              "accept",
              "parse",
              "_parse_header",
              "_parse_clauses",
              "_parse_clause",
              "_parse_condition",
              "_parse_or_expr",
              "_parse_and_expr",
              "_parse_atom",
              "_parse_predicate",
              "_parse_value",
              "_parse_actions",
              "_try_parse_action"
            ],
            "line": 244
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.dsl.ast",
            "names": [
              "Action",
              "BlockAction",
              "Clause",
              "Comparator",
              "Condition",
              "ExistsPredicate",
              "LogicalCondition",
              "LogicalOperator",
              "Mode",
              "PolicyAST",
              "PolicyMetadata",
              "Predicate",
              "RequireApprovalAction",
              "Scope",
              "WarnAction"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 2779,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_policy_engine",
            "signature": "() -> PolicyEngine",
            "docstring": "Get singleton policy engine with M18 Governor integration.",
            "is_async": false,
            "line": 2761
          }
        ],
        "classes": [
          {
            "name": "PolicyEngine",
            "docstring": "M19 Policy Engine - Constitutional Governance Layer.\n\nEvery agent decision must go through policy.evaluate() before execution.\n\nResponsibilities:\n- Enforce compliance rules\n- Enforce ethical constraints\n- Enforce risk ceilings\n- Enforce safety rules\n- Enforce business rules\n- Route violations to M18 Governor\n- Audit all evaluations",
            "methods": [
              "__init__",
              "driver",
              "evaluate",
              "pre_check",
              "_check_ethical_constraints",
              "_evaluate_ethical_constraint",
              "_extract_text_content",
              "_check_safety_rules",
              "_evaluate_safety_rule",
              "_check_cooldown",
              "_check_risk_ceilings",
              "_evaluate_risk_ceiling",
              "_get_windowed_value",
              "_add_windowed_value",
              "_check_compliance",
              "_evaluate_compliance_rule",
              "_check_business_rules",
              "_evaluate_business_rule",
              "_route_to_governor",
              "_load_policies",
              "_load_default_policies",
              "_is_cache_stale",
              "_persist_evaluation",
              "get_state",
              "reload_policies",
              "set_governor",
              "get_violations",
              "get_violation",
              "acknowledge_violation",
              "get_risk_ceilings",
              "get_risk_ceiling",
              "update_risk_ceiling",
              "reset_risk_ceiling",
              "get_safety_rules",
              "update_safety_rule",
              "get_ethical_constraints",
              "get_active_cooldowns",
              "clear_cooldowns",
              "get_metrics",
              "get_policy_versions",
              "get_current_version",
              "create_policy_version",
              "rollback_to_version",
              "get_version_provenance",
              "get_dependency_graph",
              "get_policy_conflicts",
              "resolve_conflict",
              "get_temporal_policies",
              "create_temporal_policy",
              "get_temporal_utilization",
              "evaluate_with_context",
              "_safe_dependency_count",
              "_compute_policy_hash",
              "_classify_severity",
              "_classify_recoverability",
              "validate_dependency_dag",
              "add_dependency_with_dag_check",
              "get_topological_evaluation_order",
              "prune_temporal_metrics",
              "get_temporal_storage_stats",
              "activate_policy_version"
            ],
            "line": 155
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 81
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 83
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 84
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 85
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 86
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 87
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 88
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 89
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 90
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 91
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_engine_driver",
            "names": [
              "PolicyEngineDriver",
              "get_policy_engine_driver"
            ],
            "is_relative": false,
            "line": 97
          },
          {
            "module": "app.policy.models",
            "names": [
              "ActionType",
              "BusinessRule",
              "BusinessRuleType",
              "EthicalConstraint",
              "EthicalConstraintType",
              "Policy",
              "PolicyCategory",
              "PolicyDecision",
              "PolicyEvaluationRequest",
              "PolicyEvaluationResult",
              "PolicyLoadResult",
              "PolicyModification",
              "PolicyRule",
              "PolicyState",
              "PolicyViolation",
              "RiskCeiling",
              "SafetyRule",
              "SafetyRuleType",
              "ViolationType"
            ],
            "is_relative": false,
            "line": 105
          },
          {
            "module": "app.contracts.decisions",
            "names": [
              "emit_policy_decision"
            ],
            "is_relative": false,
            "line": 130
          }
        ],
        "constants": [
          {
            "name": "POLICY_SIGNING_SECRET",
            "line": 137
          },
          {
            "name": "MAX_EVALUATION_TIME_MS",
            "line": 140
          },
          {
            "name": "CACHE_TTL_SECONDS",
            "line": 141
          },
          {
            "name": "DEFAULT_COST_CEILING_PER_HOUR",
            "line": 144
          },
          {
            "name": "DEFAULT_RETRY_CEILING_PER_MINUTE",
            "line": 145
          },
          {
            "name": "DEFAULT_CASCADE_DEPTH",
            "line": 146
          },
          {
            "name": "DEFAULT_CONCURRENT_AGENTS",
            "line": 147
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "failure_mode_handler.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/failure_mode_handler.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 296,
        "module_docstring": "Module: failure_mode_handler\nPurpose: Handles failure modes when policy evaluation fails or is uncertain.\n\nKey Principle: FAIL-CLOSED by default.\nIf policy evaluation fails, the system MUST block the action, not allow it.\n\nImports (Dependencies):\n    - app.hoc.cus.hoc_spine.authority.profile_policy_mode: get_governance_config\n\nExports (Provides):\n    - handle_policy_failure(error, context) -> FailureDecision\n    - FailureMode: Enum of failure modes\n    - FailureDecision: Decision when failure occurs\n\nWiring Points:\n    - Called from: prevention_engine.py when evaluation fails\n    - Logs: All failures for audit\n\nAcceptance Criteria:\n    - [x] AC-035-01: Default is fail-closed\n    - [x] AC-035-02: Missing policy = blocked\n    - [x] AC-035-03: Evaluation error = blocked\n    - [x] AC-035-04: All failures logged\n    - [x] AC-035-05: No hardcoded fail-open",
        "functions": [
          {
            "name": "set_governance_config_getter",
            "signature": "(getter: Callable[[], Any]) -> None",
            "docstring": "Set the governance config getter for L5 purity (PIN-520).\n\nPIN-520: L4 callers must inject the config getter at startup.\nL5 must not import from hoc_spine.\n\nArgs:\n    getter: Function that returns the governance config (injected by L4 caller).",
            "is_async": false,
            "line": 58
          },
          {
            "name": "get_failure_mode",
            "signature": "() -> FailureMode",
            "docstring": "Get configured failure mode.\n\nPIN-520: Uses injected governance config getter instead of importing from L4 authority.\nCall set_governance_config_getter() at startup to inject the config getter.\n\nReturns:\n    FailureMode from governance config, defaulting to FAIL_CLOSED",
            "is_async": false,
            "line": 105
          },
          {
            "name": "handle_policy_failure",
            "signature": "(error: Optional[Exception], context: Dict[str, Any], failure_type: FailureType = FailureType.UNKNOWN) -> FailureDecision",
            "docstring": "Handle a policy evaluation failure.\n\nThis function determines what action to take when policy evaluation\nfails. The default is FAIL-CLOSED (block the action).\n\nArgs:\n    error: The exception that occurred, if any\n    context: Evaluation context (run_id, tenant_id, etc.)\n    failure_type: Type of failure\n\nReturns:\n    FailureDecision with action to take",
            "is_async": false,
            "line": 145
          },
          {
            "name": "handle_missing_policy",
            "signature": "(context: Dict[str, Any]) -> FailureDecision",
            "docstring": "Handle case where no policy exists for the action.\n\nBy default, missing policy = BLOCK (fail-closed).\n\nArgs:\n    context: Evaluation context\n\nReturns:\n    FailureDecision",
            "is_async": false,
            "line": 244
          },
          {
            "name": "handle_evaluation_error",
            "signature": "(error: Exception, context: Dict[str, Any]) -> FailureDecision",
            "docstring": "Handle policy evaluation error.\n\nArgs:\n    error: The exception that occurred\n    context: Evaluation context\n\nReturns:\n    FailureDecision",
            "is_async": false,
            "line": 263
          },
          {
            "name": "handle_timeout",
            "signature": "(context: Dict[str, Any], timeout_seconds: float) -> FailureDecision",
            "docstring": "Handle policy evaluation timeout.\n\nArgs:\n    context: Evaluation context\n    timeout_seconds: How long before timeout\n\nReturns:\n    FailureDecision",
            "is_async": false,
            "line": 281
          }
        ],
        "classes": [
          {
            "name": "FailureMode",
            "docstring": "Failure mode for policy evaluation.",
            "methods": [],
            "line": 72
          },
          {
            "name": "FailureType",
            "docstring": "Type of failure encountered.",
            "methods": [],
            "line": 79
          },
          {
            "name": "FailureDecision",
            "docstring": "Decision made when failure occurs.",
            "methods": [],
            "line": 90
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Optional",
              "Any",
              "Dict",
              "Callable"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_FAILURE_MODE",
            "line": 102
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "folds.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/folds.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 403,
        "module_docstring": "IR optimizations for PLang v2.0.\n\nOptimizations:\n- Constant folding: Evaluate constant expressions at compile time\n- Dead code elimination: Remove unreachable code\n- Policy simplification: Merge compatible policies",
        "functions": [],
        "classes": [
          {
            "name": "FoldResult",
            "docstring": "Result of a folding operation.",
            "methods": [],
            "line": 50
          },
          {
            "name": "ConstantFolder",
            "docstring": "Constant folding optimization.\n\nEvaluates constant expressions at compile time without\naffecting governance semantics.",
            "methods": [
              "__init__",
              "fold_module",
              "fold_function",
              "fold_block",
              "try_fold",
              "_fold_binary_op",
              "_fold_unary_op",
              "_fold_compare"
            ],
            "line": 58
          },
          {
            "name": "DeadCodeEliminator",
            "docstring": "Dead code elimination.\n\nRemoves unreachable code and unused definitions while\npreserving governance-critical paths.",
            "methods": [
              "__init__",
              "eliminate",
              "_mark_governance_critical",
              "_eliminate_function",
              "_find_reachable_blocks",
              "_find_used_instructions"
            ],
            "line": 196
          },
          {
            "name": "PolicySimplifier",
            "docstring": "Policy-specific simplifications.\n\nMerges compatible policies based on governance rules\nwhile preserving semantic correctness.",
            "methods": [
              "__init__",
              "simplify",
              "_find_mergeable_policies",
              "_merge_policies"
            ],
            "line": 325
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRAction",
              "IRBinaryOp",
              "IRBlock",
              "IRCompare",
              "IRFunction",
              "IRInstruction",
              "IRJump",
              "IRJumpIf",
              "IRLoadConst",
              "IRModule",
              "IRUnaryOp"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "governance_facade.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/governance_facade.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 740,
        "module_docstring": "Governance Facade (L4 Domain Logic)\n\nThis facade provides the external interface for governance control operations.\nAll governance APIs MUST use this facade instead of directly importing\ninternal governance modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes governance control logic\n- Provides unified access to kill switch, degraded mode, conflict resolution\n- Single point for audit emission\n\nWrapped Services:\n- runtime_switch: Kill switch and degraded mode (GAP-069, GAP-070)\n- ConflictResolver: Policy conflict resolution (GAP-068)\n- BootGuard: SPINE component health (GAP-067)\n\nL2 API Routes (GAP-090 to GAP-095):\n- POST /api/v1/governance/kill-switch (GAP-090)\n- POST /api/v1/governance/mode (GAP-091)\n- POST /api/v1/governance/resolve-conflict (GAP-092)\n- GET /api/v1/governance/boot-status (GAP-095)\n\nUsage:\n    from app.hoc.cus.policies.L5_engines.governance_facade import get_governance_facade\n\n    facade = get_governance_facade()\n\n    # Check governance state\n    state = facade.get_governance_state()\n\n    # Enable kill switch\n    facade.enable_kill_switch(reason=\"Emergency\", actor=\"operator\")\n\n    # Enter degraded mode\n    facade.set_mode(mode=\"DEGRADED\", reason=\"High load\", actor=\"system\")",
        "functions": [
          {
            "name": "get_governance_facade",
            "signature": "(runtime_switch: Optional[ModuleType] = None) -> GovernanceFacade",
            "docstring": "Get the governance facade instance.\n\nThis is the recommended way to access governance control operations\nfrom L2 APIs and the SDK.\n\nPIN-520: L4 callers must inject runtime_switch. L5 must not import from hoc_spine.\n\nArgs:\n    runtime_switch: The runtime_switch module for governance state management (injected by L4 caller).\n\nReturns:\n    GovernanceFacade instance",
            "is_async": false,
            "line": 717
          }
        ],
        "classes": [
          {
            "name": "GovernanceMode",
            "docstring": "Governance operation modes.",
            "methods": [],
            "line": 64
          },
          {
            "name": "GovernanceStateResult",
            "docstring": "Result of governance state query.",
            "methods": [
              "to_dict"
            ],
            "line": 72
          },
          {
            "name": "KillSwitchResult",
            "docstring": "Result of kill switch operation.",
            "methods": [
              "to_dict"
            ],
            "line": 94
          },
          {
            "name": "ConflictResolutionResult",
            "docstring": "Result of conflict resolution.",
            "methods": [
              "to_dict"
            ],
            "line": 118
          },
          {
            "name": "BootStatusResult",
            "docstring": "Result of boot status check.",
            "methods": [
              "to_dict"
            ],
            "line": 142
          },
          {
            "name": "GovernanceFacade",
            "docstring": "Facade for governance control operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ngovernance control services.\n\nLayer: L5 (Domain Engine)\nCallers: governance.py (L2), aos_sdk\n\nPIN-520: runtime_switch is now injected via L4 bridge instead of being\nimported directly from L4 authority.",
            "methods": [
              "__init__",
              "enable_kill_switch",
              "disable_kill_switch",
              "set_mode",
              "get_governance_state",
              "resolve_conflict",
              "list_conflicts",
              "get_boot_status"
            ],
            "line": 159
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "types",
            "names": [
              "ModuleType"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 59
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "grammar.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/grammar.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 216,
        "module_docstring": "PLang v2.0 Grammar (EBNF):\n\nprogram         ::= statement*\nstatement       ::= policy_decl | rule_decl | import_stmt\npolicy_decl     ::= 'policy' IDENT ':' category '{' policy_body '}'\ncategory        ::= 'SAFETY' | 'PRIVACY' | 'OPERATIONAL' | 'ROUTING' | 'CUSTOM'\npolicy_body     ::= (rule_ref | condition_block | action_block)*\nrule_ref        ::= 'rule' IDENT\ncondition_block ::= 'when' expr 'then' action_block\naction_block    ::= 'deny' | 'allow' | 'escalate' | 'route' route_target\nroute_target    ::= 'to' IDENT\nexpr            ::= or_expr\nor_expr         ::= and_expr ('or' and_expr)*\nand_expr        ::= not_expr ('and' not_expr)*\nnot_expr        ::= 'not' not_expr | comparison\ncomparison      ::= value (comp_op value)?\ncomp_op         ::= '==' | '!=' | '<' | '>' | '<=' | '>='\nvalue           ::= IDENT | NUMBER | STRING | 'true' | 'false' | func_call | attr_access\nattr_access     ::= value '.' IDENT\nfunc_call       ::= IDENT '(' args? ')'\nargs            ::= expr (',' expr)*\nrule_decl       ::= 'rule' IDENT ':' category '{' rule_body '}'\nrule_body       ::= (priority_decl | condition_block | action_block)*\npriority_decl   ::= 'priority' NUMBER\nimport_stmt     ::= 'import' STRING",
        "functions": [],
        "classes": [
          {
            "name": "GrammarNodeType",
            "docstring": "Grammar node types for PLang v2.0.",
            "methods": [],
            "line": 55
          },
          {
            "name": "PolicyCategory",
            "docstring": "M19 Policy Categories.",
            "methods": [],
            "line": 86
          },
          {
            "name": "ActionType",
            "docstring": "Policy action types.",
            "methods": [],
            "line": 96
          },
          {
            "name": "GrammarProduction",
            "docstring": "A production rule in the grammar.",
            "methods": [],
            "line": 108
          },
          {
            "name": "PLangGrammar",
            "docstring": "PLang v2.0 Grammar Definition.",
            "methods": [
              "get_category_priority",
              "get_action_precedence",
              "is_keyword",
              "is_operator",
              "is_category",
              "is_action"
            ],
            "line": 118
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "List",
              "Set"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [
          {
            "name": "PLANG_GRAMMAR",
            "line": 216
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "intent.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/intent.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 405,
        "module_docstring": "Intent system for PLang v2.0 runtime.\n\nIntents are the bridge between policy decisions and M18 execution:\n- Policy compiler emits intents based on actions\n- M18 executes intents with governance constraints\n- M19 validates intents before execution\n\nIntent types:\n- ROUTE: Route to specific agent\n- ESCALATE: Escalate to higher authority\n- EXECUTE: Execute with constraints\n- DENY: Block execution with reason\n- ALLOW: Permit execution",
        "functions": [],
        "classes": [
          {
            "name": "IntentType",
            "docstring": "Types of intents emitted by policy runtime.",
            "methods": [],
            "line": 60
          },
          {
            "name": "IntentPayload",
            "docstring": "Payload data for an intent.\n\nContains all data needed for M18 to execute the intent.",
            "methods": [
              "to_dict",
              "from_dict"
            ],
            "line": 73
          },
          {
            "name": "Intent",
            "docstring": "An intent emitted by the policy runtime.\n\nRepresents a governance-validated action to be executed by M18.",
            "methods": [
              "__post_init__",
              "_generate_id",
              "to_dict",
              "from_dict"
            ],
            "line": 133
          },
          {
            "name": "IntentEmitter",
            "docstring": "Emits intents from policy runtime to M18.\n\nHandles:\n- Intent creation\n- M19 validation\n- M18 delivery\n- Audit logging",
            "methods": [
              "__init__",
              "create_intent",
              "validate_intent",
              "emit",
              "emit_all",
              "register_handler",
              "get_pending",
              "get_emitted",
              "clear"
            ],
            "line": 214
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Awaitable",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.hoc.cus.policies.L5_schemas.intent_validation",
            "names": [
              "PolicyIntentValidationResult",
              "PolicyIntentValidator"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [
          {
            "name": "_ENFORCEMENT_INTENT_TYPES",
            "line": 53
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "interpreter.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/interpreter.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 562,
        "module_docstring": "Policy DSL Interpreter\n\nPure evaluation of compiled IR against runtime facts.\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- PURE: No side effects, no I/O, no DB, no network\n- NO CONTEXT: No tenants, actors, permissions, time\n- DESCRIPTIVE OUTPUT: Returns what is true, not what to do\n- STACK-BASED: Explicit stack for condition evaluation\n- NO COERCION: Type mismatches raise errors\n\nINPUT:\n- PolicyIR: Compiled intermediate representation\n- Facts: dict[str, value] - runtime metric values\n\nOUTPUT:\n- EvaluationResult: Describes which clauses matched and what actions apply\n\nGOVERNANCE:\n- Interpreter output defines policy truth\n- IR compiler and future JIT must conform to this\n- Replay uses interpreter, always",
        "functions": [
          {
            "name": "evaluate",
            "signature": "(ir: PolicyIR, facts: dict[str, Any]) -> EvaluationResult",
            "docstring": "Evaluate policy IR against facts.\n\nThis is the CANONICAL evaluation function.\nAll other evaluation paths (JIT, cached, etc.) must produce\nidentical results.\n\nArgs:\n    ir: Compiled PolicyIR\n    facts: dict mapping metric names to values\n\nReturns:\n    EvaluationResult describing what matched\n\nRaises:\n    EvaluationError: On runtime errors\n\nExample:\n    >>> from app.dsl import parse, validate, compile_policy\n    >>> ast = parse('''\n    ... policy CostGuard\n    ... version 1\n    ... scope PROJECT\n    ... mode MONITOR\n    ...\n    ... when cost > 100\n    ... then WARN \"High cost\"\n    ... ''')\n    >>> ir = compile_policy(ast)\n    >>> result = evaluate(ir, {\"cost\": 150})\n    >>> result.any_matched\n    True\n    >>> result.all_actions[0].type\n    'WARN'",
            "is_async": false,
            "line": 447
          },
          {
            "name": "evaluate_policy",
            "signature": "(ir: PolicyIR, facts: dict[str, Any], strict: bool = True) -> EvaluationResult",
            "docstring": "Evaluate policy with optional strict mode.\n\nArgs:\n    ir: Compiled PolicyIR\n    facts: dict mapping metric names to values\n    strict: If True, missing metrics raise error.\n            If False, missing metrics treated as not-exists.\n\nReturns:\n    EvaluationResult describing what matched\n\nNote: strict=False is useful for partial evaluation,\n      but strict=True is required for audit-grade evaluation.",
            "is_async": false,
            "line": 490
          }
        ],
        "classes": [
          {
            "name": "EvaluationError",
            "docstring": "Raised when evaluation fails.\n\nThis is NOT a policy violation - it's a runtime error\n(e.g., type mismatch, missing required metric).",
            "methods": [
              "__init__"
            ],
            "line": 62
          },
          {
            "name": "TypeMismatchError",
            "docstring": "Raised when types are incompatible for comparison.",
            "methods": [],
            "line": 79
          },
          {
            "name": "MissingMetricError",
            "docstring": "Raised when a required metric is not in facts.",
            "methods": [],
            "line": 85
          },
          {
            "name": "ActionResult",
            "docstring": "A single action from evaluation.\n\nThis is DESCRIPTIVE - it says what action applies,\nnot what to do about it.",
            "methods": [
              "to_dict"
            ],
            "line": 97
          },
          {
            "name": "ClauseResult",
            "docstring": "Evaluation result for a single clause.\n\nDESCRIPTIVE: Says whether the clause matched and what actions apply.",
            "methods": [
              "to_dict"
            ],
            "line": 116
          },
          {
            "name": "EvaluationResult",
            "docstring": "Complete evaluation result for a policy.\n\nDESCRIPTIVE OUTPUT:\n- any_matched: Did any clause match?\n- clauses: Per-clause results\n- all_actions: Aggregated actions from all matching clauses\n\nThis tells you WHAT IS TRUE, not what to do about it.",
            "methods": [
              "to_dict",
              "has_block",
              "has_require_approval",
              "warnings"
            ],
            "line": 134
          },
          {
            "name": "Interpreter",
            "docstring": "Pure interpreter for Policy IR.\n\nPURITY GUARANTEE:\n- No side effects\n- No access to DB, time, network, globals\n- No knowledge of tenants, actors, permissions\n\nInput = IR + facts\nOutput = EvaluationResult",
            "methods": [
              "__init__",
              "evaluate",
              "_evaluate_clause",
              "_evaluate_condition",
              "_execute_instruction",
              "_compare",
              "_types_compatible",
              "_collect_actions"
            ],
            "line": 178
          },
          {
            "name": "_LenientInterpreter",
            "docstring": "Lenient interpreter that treats missing metrics as non-matching.\n\nNOT for audit-grade evaluation - only for previews/simulation.",
            "methods": [
              "_execute_instruction",
              "_compare"
            ],
            "line": 519
          },
          {
            "name": "_MissingSentinel",
            "docstring": "Sentinel value for missing metrics.",
            "methods": [],
            "line": 556
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.dsl.ir_compiler",
            "names": [
              "CompiledClause",
              "Instruction",
              "OpCode",
              "PolicyIR"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [
          {
            "name": "_MISSING_SENTINEL",
            "line": 562
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "ir_builder.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/ir_builder.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 408,
        "module_docstring": "IR Builder for PLang v2.0.\n\nTransforms AST nodes into IR with:\n- M19 category propagation\n- Symbol table population\n- Basic block construction\n- Governance metadata attachment",
        "functions": [],
        "classes": [
          {
            "name": "IRBuilder",
            "docstring": "Builds IR from PLang AST.\n\nTransforms AST into IR with governance metadata propagation.",
            "methods": [
              "__init__",
              "build",
              "_next_id",
              "_next_block_name",
              "_emit",
              "_new_block",
              "visit_program",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_import",
              "visit_rule_ref",
              "visit_priority",
              "visit_condition_block",
              "visit_action_block",
              "visit_route_target",
              "visit_binary_op",
              "visit_unary_op",
              "visit_ident",
              "visit_literal",
              "visit_func_call",
              "visit_attr_access"
            ],
            "line": 78
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.policy.ast.nodes",
            "names": [
              "ActionBlockNode",
              "AttrAccessNode",
              "BinaryOpNode",
              "ConditionBlockNode",
              "FuncCallNode",
              "IdentNode",
              "ImportNode",
              "LiteralNode",
              "PolicyDeclNode",
              "PriorityNode",
              "ProgramNode",
              "RouteTargetNode",
              "RuleDeclNode",
              "RuleRefNode",
              "UnaryOpNode"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.policy.ast.visitors",
            "names": [
              "BaseVisitor"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRAction",
              "IRBinaryOp",
              "IRBlock",
              "IRCall",
              "IRCompare",
              "IREmitIntent",
              "IRFunction",
              "IRGovernance",
              "IRInstruction",
              "IRJump",
              "IRJumpIf",
              "IRLoadConst",
              "IRLoadVar",
              "IRModule",
              "IRReturn",
              "IRType",
              "IRUnaryOp"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.policy.ir.symbol_table",
            "names": [
              "Symbol",
              "SymbolTable",
              "SymbolType"
            ],
            "is_relative": false,
            "line": 71
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "ir_compiler.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/ir_compiler.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 460,
        "module_docstring": "Policy DSL Intermediate Representation (IR) Compiler\n\nCompiles validated AST into deterministic bytecode for the interpreter.\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- CLOSED instruction set (exactly 10 opcodes)\n- Deterministic: Same AST \u2192 Same IR \u2192 Same hash\n- No evaluation logic (pure compilation)\n- No jumps, labels, or control flow\n- IR structure is hashable for audit identity\n\nINSTRUCTION SET (CLOSED - NO ADDITIONS):\n    LOAD_METRIC     - Load metric value onto stack\n    LOAD_CONST      - Load constant value onto stack\n    COMPARE         - Compare two values (metric CMP const)\n    EXISTS          - Check if metric exists\n    AND             - Logical AND of two booleans\n    OR              - Logical OR of two booleans\n    EMIT_WARN       - Emit warning action\n    EMIT_BLOCK      - Emit block action\n    EMIT_REQUIRE_APPROVAL - Emit require approval action\n    END             - End of clause/program\n\nSAFE OPTIMIZATIONS (ALLOWED):\n- Constant folding (evaluate known constants)\n- Dead action elimination (unreachable code)\n- Metric de-duplication (load once, reference many)\n\nFORBIDDEN OPTIMIZATIONS:\n- Short-circuit evaluation\n- Any semantic changes\n- Execution logic\n\nGOVERNANCE:\n- IR is the audit identity of a policy\n- Replay uses IR, not DSL text",
        "functions": [
          {
            "name": "compile_policy",
            "signature": "(ast: PolicyAST, optimize: bool = False) -> PolicyIR",
            "docstring": "Compile PolicyAST to PolicyIR.\n\nArgs:\n    ast: Validated PolicyAST\n    optimize: Enable safe optimizations (default False for max determinism)\n\nReturns:\n    PolicyIR: Compiled intermediate representation\n\nExample:\n    >>> from app.dsl import parse, validate\n    >>> ast = parse('''\n    ... policy CostGuard\n    ... version 1\n    ... scope PROJECT\n    ... mode MONITOR\n    ...\n    ... when cost > 100\n    ... then WARN \"High cost\"\n    ... ''')\n    >>> result = validate(ast)\n    >>> assert result.is_valid\n    >>> ir = compile_policy(ast)\n    >>> ir.compute_hash()\n    'a1b2c3...'",
            "is_async": false,
            "line": 418
          },
          {
            "name": "ir_hash",
            "signature": "(ast: PolicyAST) -> str",
            "docstring": "Convenience function to get IR hash from AST.\n\nThis is the audit identity of the policy.",
            "is_async": false,
            "line": 453
          }
        ],
        "classes": [
          {
            "name": "OpCode",
            "docstring": "Closed instruction set for Policy IR.\n\nGUARANTEE: This enum will never grow beyond these 10 opcodes.\nAny new functionality requires a new IR version.",
            "methods": [],
            "line": 89
          },
          {
            "name": "Instruction",
            "docstring": "A single IR instruction.\n\nImmutable to ensure IR integrity after compilation.",
            "methods": [
              "to_dict"
            ],
            "line": 115
          },
          {
            "name": "CompiledClause",
            "docstring": "Compiled form of a single when-then clause.\n\nContains:\n- condition_ir: Instructions to evaluate the condition\n- action_ir: Instructions to emit actions (if condition true)",
            "methods": [
              "to_dict"
            ],
            "line": 134
          },
          {
            "name": "PolicyIR",
            "docstring": "Complete IR for a policy.\n\nGUARANTEE: Same AST \u2192 Same IR \u2192 Same hash",
            "methods": [
              "to_dict",
              "to_json",
              "compute_hash",
              "instruction_count"
            ],
            "line": 155
          },
          {
            "name": "IRCompiler",
            "docstring": "Compiles PolicyAST to PolicyIR.\n\nThe compiler is stateless - each compile() call is independent.",
            "methods": [
              "__init__",
              "compile",
              "_compile_clause",
              "_compile_condition",
              "_emit_condition",
              "_emit_predicate",
              "_emit_exists",
              "_emit_logical",
              "_compile_actions"
            ],
            "line": 209
          },
          {
            "name": "OptimizingIRCompiler",
            "docstring": "IR Compiler with safe optimizations.\n\nSAFE OPTIMIZATIONS:\n- Metric de-duplication: Track loaded metrics, reuse references\n- Constant folding: Pre-compute known constant operations\n\nFORBIDDEN:\n- Short-circuit evaluation\n- Dead code elimination that changes observable behavior\n- Any semantic modifications",
            "methods": [
              "__init__",
              "compile"
            ],
            "line": 388
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.dsl.ast",
            "names": [
              "Action",
              "Clause",
              "Condition",
              "ExistsPredicate",
              "LogicalCondition",
              "LogicalOperator",
              "PolicyAST",
              "Predicate",
              "is_block_action",
              "is_exists_predicate",
              "is_logical_condition",
              "is_predicate",
              "is_require_approval_action",
              "is_warn_action"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "ir_nodes.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/ir_nodes.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 404,
        "module_docstring": "IR nodes for PLang v2.0 compilation.\n\nIR design principles:\n- Category-aware: Every node carries governance metadata\n- SSA-like: Single assignment for optimization\n- Intent-oriented: Designed for M18 intent emission\n- Deterministic: Reproducible execution paths",
        "functions": [],
        "classes": [
          {
            "name": "IRType",
            "docstring": "IR value types.",
            "methods": [],
            "line": 40
          },
          {
            "name": "IRGovernance",
            "docstring": "Governance metadata for IR nodes.\n\nPropagated from AST through compilation to runtime.\nUsed by M19 policy engine for validation.",
            "methods": [
              "from_ast",
              "to_dict"
            ],
            "line": 55
          },
          {
            "name": "IRNode",
            "docstring": "Base class for all IR nodes.",
            "methods": [
              "__str__"
            ],
            "line": 95
          },
          {
            "name": "IRInstruction",
            "docstring": "Base class for IR instructions.",
            "methods": [],
            "line": 112
          },
          {
            "name": "IRLoadConst",
            "docstring": "Load constant value.",
            "methods": [
              "__str__"
            ],
            "line": 119
          },
          {
            "name": "IRLoadVar",
            "docstring": "Load variable value.",
            "methods": [
              "__str__"
            ],
            "line": 129
          },
          {
            "name": "IRStoreVar",
            "docstring": "Store value to variable.",
            "methods": [
              "__str__"
            ],
            "line": 139
          },
          {
            "name": "IRBinaryOp",
            "docstring": "Binary operation.",
            "methods": [
              "__str__"
            ],
            "line": 150
          },
          {
            "name": "IRUnaryOp",
            "docstring": "Unary operation.",
            "methods": [
              "__str__"
            ],
            "line": 162
          },
          {
            "name": "IRCompare",
            "docstring": "Comparison operation.",
            "methods": [
              "__str__"
            ],
            "line": 173
          },
          {
            "name": "IRJump",
            "docstring": "Unconditional jump.",
            "methods": [
              "__str__"
            ],
            "line": 186
          },
          {
            "name": "IRJumpIf",
            "docstring": "Conditional jump.",
            "methods": [
              "__str__"
            ],
            "line": 196
          },
          {
            "name": "IRCall",
            "docstring": "Function call.",
            "methods": [
              "__str__"
            ],
            "line": 208
          },
          {
            "name": "IRReturn",
            "docstring": "Return from function.",
            "methods": [
              "__str__"
            ],
            "line": 220
          },
          {
            "name": "IRAction",
            "docstring": "Policy action instruction.\n\nActions: deny, allow, escalate, route",
            "methods": [
              "__str__"
            ],
            "line": 232
          },
          {
            "name": "IRCheckPolicy",
            "docstring": "Check against M19 policy engine.\n\nEmits validation request to policy engine before action.",
            "methods": [
              "__str__"
            ],
            "line": 253
          },
          {
            "name": "IREmitIntent",
            "docstring": "Emit intent to M18 execution layer.\n\nIntents are executed by M18 with governance constraints.",
            "methods": [
              "__str__"
            ],
            "line": 270
          },
          {
            "name": "IRBlock",
            "docstring": "Basic block in IR.\n\nContains a sequence of instructions with single entry/exit.",
            "methods": [
              "add_instruction",
              "is_terminated",
              "__str__"
            ],
            "line": 298
          },
          {
            "name": "IRFunction",
            "docstring": "Function in IR.\n\nRepresents a policy or rule as a callable unit.",
            "methods": [
              "add_block",
              "get_block",
              "__str__"
            ],
            "line": 330
          },
          {
            "name": "IRModule",
            "docstring": "Module in IR.\n\nRepresents a complete compiled PLang program.",
            "methods": [
              "add_function",
              "get_function",
              "get_functions_by_category",
              "__str__"
            ],
            "line": 362
          }
        ],
        "imports": [
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "kernel.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/kernel.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 623,
        "module_docstring": "ExecutionKernel - PIN-337 Governance Enforcement Infrastructure\n\nThis is the MANDATORY choke point for all EXECUTE-power paths.\nAll execution must flow through this kernel.\n\nINVARIANTS:\n- Every EXECUTE path MUST call ExecutionKernel.invoke()\n- Kernel MUST NOT block execution in v1 (PERMISSIVE mode)\n- Kernel MUST emit ExecutionEnvelope for attribution\n- Kernel MUST record invocation metrics\n- Unknown capability_id = CI FAIL (compile-time), not runtime block\n\nThe kernel is PHYSICS, not POLICY.\nIf code doesn't call the kernel, it doesn't execute.",
        "functions": [
          {
            "name": "get_enforcement_mode",
            "signature": "(capability_id: str) -> EnforcementMode",
            "docstring": "Get enforcement mode for a capability.\n\nArgs:\n    capability_id: The capability ID (e.g., \"CAP-019\")\n\nReturns:\n    EnforcementMode for this capability (default: PERMISSIVE)",
            "is_async": false,
            "line": 75
          },
          {
            "name": "set_enforcement_mode",
            "signature": "(capability_id: str, mode: EnforcementMode) -> None",
            "docstring": "Set enforcement mode for a capability.\n\nThis is CONFIG-DRIVEN, not code-driven.\nUsed for gradual rollout of strictness.\n\nArgs:\n    capability_id: The capability ID\n    mode: The enforcement mode to set",
            "is_async": false,
            "line": 88
          }
        ],
        "classes": [
          {
            "name": "EnforcementMode",
            "docstring": "Enforcement mode for capability execution.\n\nPERMISSIVE: Log and allow (v1 default)\nSTRICT: Enforce authority and policy (v2+, opt-in per capability)",
            "methods": [],
            "line": 55
          },
          {
            "name": "InvocationContext",
            "docstring": "Context for an execution invocation.\n\nCaptures WHO is invoking, WHAT they're invoking, and WHERE from.",
            "methods": [],
            "line": 115
          },
          {
            "name": "ExecutionResult",
            "docstring": "Result of an execution through the kernel.\n\nWraps the actual result with governance metadata.",
            "methods": [],
            "line": 149
          },
          {
            "name": "ExecutionKernel",
            "docstring": "Mandatory execution kernel - single choke point for all EXECUTE power.\n\nAll EXECUTE-power paths MUST route through this kernel:\n- HTTP handlers that mutate state\n- CLI commands that execute logic\n- SDK methods that trigger execution\n- Workers that process jobs\n- AUTO_EXECUTE recovery paths\n\nINVARIANTS:\n- v1: PERMISSIVE (log and allow, never block)\n- Envelope emission is ALWAYS on\n- Invocation recording is ALWAYS on\n- Strictness is capability-scoped, never global\n\nThe kernel is PHYSICS, not POLICY.",
            "methods": [
              "invoke",
              "invoke_async",
              "_emit_envelope",
              "_record_invocation_start",
              "_record_invocation_complete",
              "is_known_capability",
              "get_known_capabilities"
            ],
            "line": 182
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Optional",
              "TypeVar"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [
          {
            "name": "T",
            "line": 47
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "kill_switch.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/kill_switch.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 223,
        "module_docstring": "Kill Switch - Runtime Governance Bypass\n\nProvides emergency governance disable capability without restart.\nWhen active, all governance checks are bypassed (fail-open mode).\n\nUse cases:\n- Emergency maintenance\n- Security incident response\n- Governance system failures\n\nSecurity considerations:\n- Activation requires authenticated operator\n- All activations are logged\n- Automatic timeout for safety",
        "functions": [
          {
            "name": "activate_kill_switch",
            "signature": "(reason: str, activated_by: str, auto_expire_minutes: int = 60) -> KillSwitchActivation",
            "docstring": "Activate the runtime kill switch.\n\nWhen active, governance checks are bypassed (fail-open).\n\nArgs:\n    reason: Why the kill switch is being activated\n    activated_by: Identifier of operator activating\n    auto_expire_minutes: Auto-deactivate after this many minutes\n\nReturns:\n    KillSwitchActivation result",
            "is_async": false,
            "line": 90
          },
          {
            "name": "deactivate_kill_switch",
            "signature": "(deactivated_by: str = 'system') -> KillSwitchDeactivation",
            "docstring": "Deactivate the runtime kill switch.\n\nRestores normal governance enforcement.\n\nArgs:\n    deactivated_by: Identifier of operator deactivating\n\nReturns:\n    KillSwitchDeactivation result",
            "is_async": false,
            "line": 147
          },
          {
            "name": "is_kill_switch_active",
            "signature": "() -> bool",
            "docstring": "Check if kill switch is currently active.\n\nAlso handles auto-expiration.\n\nReturns:\n    True if governance should be bypassed",
            "is_async": false,
            "line": 186
          },
          {
            "name": "should_bypass_governance",
            "signature": "() -> bool",
            "docstring": "Check if governance should be bypassed.\n\nAlias for is_kill_switch_active() for clearer intent.\n\nReturns:\n    True if governance checks should be skipped",
            "is_async": false,
            "line": 214
          }
        ],
        "classes": [
          {
            "name": "KillSwitchStatus",
            "docstring": "Current status of the kill switch.",
            "methods": [
              "get_current"
            ],
            "line": 52
          },
          {
            "name": "KillSwitchActivation",
            "docstring": "Result of kill switch activation.",
            "methods": [],
            "line": 72
          },
          {
            "name": "KillSwitchDeactivation",
            "docstring": "Result of kill switch deactivation.",
            "methods": [],
            "line": 82
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "threading",
            "names": [
              "Lock"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lessons_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/lessons_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 1082,
        "module_docstring": "Lessons Learned Engine (L4 Domain Logic)\n\nThis engine implements the learning-driven governance pattern:\n- Failures (all severities) \u2192 Lesson created\n- Near-threshold events \u2192 Lesson created\n- Critical success events \u2192 Lesson created\n\nLessons are the memory substrate for policy evolution.\nOnly human action (via PolicyProposalEngine) converts lessons to drafts.\n\nReference: PIN-411, POLICIES_DOMAIN_AUDIT.md Section 11",
        "functions": [
          {
            "name": "is_valid_transition",
            "signature": "(from_status: str, to_status: str) -> bool",
            "docstring": "Check if a state transition is valid.",
            "is_async": false,
            "line": 116
          },
          {
            "name": "get_threshold_band",
            "signature": "(utilization: float) -> str",
            "docstring": "Get the threshold band for a utilization percentage.",
            "is_async": false,
            "line": 150
          },
          {
            "name": "get_lessons_learned_engine",
            "signature": "(driver: Any = None) -> LessonsLearnedEngine",
            "docstring": "Get a LessonsLearnedEngine instance.\n\nPIN-508 Phase 2A: When driver (LessonsQueryCapability) is provided,\nreturns a new engine with that capability injected.\nWhen no driver, returns singleton with lazy initialization.",
            "is_async": false,
            "line": 1070
          }
        ],
        "classes": [
          {
            "name": "LessonsLearnedEngine",
            "docstring": "L4 Domain Engine for lesson creation and management.\n\nThis engine implements the learning-driven governance pattern:\n- Detect learning opportunities from system events\n- Create lesson records (memory substrate)\n- Support human-driven conversion to draft proposals\n\nSDSR Contract (PIN-370):\n- This engine is called when events occur\n- It creates lesson records automatically\n- Lessons are NEVER created by scenarios directly\n- If lessons don't appear for events, THIS ENGINE is broken\n\nCallers:\n- IncidentEngine (on failures)\n- Worker runtime (on near-threshold, success)\n- API endpoints (for queries)",
            "methods": [
              "__init__",
              "_get_driver",
              "detect_lesson_from_failure",
              "detect_lesson_from_near_threshold",
              "detect_lesson_from_critical_success",
              "emit_near_threshold",
              "emit_critical_success",
              "list_lessons",
              "get_lesson",
              "convert_lesson_to_draft",
              "defer_lesson",
              "dismiss_lesson",
              "get_lesson_stats",
              "reactivate_deferred_lesson",
              "_is_debounced",
              "_create_lesson",
              "_generate_failure_description",
              "_generate_failure_proposed_action",
              "get_expired_deferred_lessons",
              "reactivate_expired_deferred_lessons"
            ],
            "line": 159
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "uuid",
            "names": [
              "UUID",
              "uuid4"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "prometheus_client",
            "names": [
              "Counter"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [
          {
            "name": "LESSONS_CREATION_FAILED",
            "line": 77
          },
          {
            "name": "LESSON_TYPE_FAILURE",
            "line": 88
          },
          {
            "name": "LESSON_TYPE_NEAR_THRESHOLD",
            "line": 89
          },
          {
            "name": "LESSON_TYPE_CRITICAL_SUCCESS",
            "line": 90
          },
          {
            "name": "LESSON_STATUS_PENDING",
            "line": 92
          },
          {
            "name": "LESSON_STATUS_CONVERTED",
            "line": 93
          },
          {
            "name": "LESSON_STATUS_DEFERRED",
            "line": 94
          },
          {
            "name": "LESSON_STATUS_DISMISSED",
            "line": 95
          },
          {
            "name": "SEVERITY_CRITICAL",
            "line": 124
          },
          {
            "name": "SEVERITY_HIGH",
            "line": 125
          },
          {
            "name": "SEVERITY_MEDIUM",
            "line": 126
          },
          {
            "name": "SEVERITY_LOW",
            "line": 127
          },
          {
            "name": "SEVERITY_NONE",
            "line": 128
          },
          {
            "name": "NEAR_THRESHOLD_PERCENT",
            "line": 138
          },
          {
            "name": "DEBOUNCE_WINDOW_HOURS",
            "line": 139
          },
          {
            "name": "THRESHOLD_BANDS",
            "line": 143
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "limits.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/limits.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 157,
        "module_docstring": "Phase-6 Limits \u2014 Derived from Plan (Not Stored)\n\nPIN-399 Phase-6: Limits are derived from plan at runtime, never hand-edited.\n\nDESIGN INVARIANTS (LOCKED):\n- BILLING-002: Limits are derived, not stored\n\nENFORCEMENT SEMANTICS:\n- Limits are evaluated at runtime\n- Limits are enforced after onboarding COMPLETE\n- Limits may emit warnings before enforcement\n\nWHAT LIMITS CAN DO:\n- Throttle\n- Reject with explicit error\n- Emit usage warnings\n\nWHAT LIMITS MUST NOT DO:\n- Mutate onboarding state\n- Revoke API keys silently\n- Affect auth or roles",
        "functions": [
          {
            "name": "derive_limits",
            "signature": "(limits_profile: str) -> Limits",
            "docstring": "Derive limits from a limits profile key.\n\nINVARIANT: This is the single source of limit derivation.\n\nArgs:\n    limits_profile: Profile key from Plan.limits_profile\n\nReturns:\n    Limits instance (immutable)",
            "is_async": false,
            "line": 137
          }
        ],
        "classes": [
          {
            "name": "Limits",
            "docstring": "Phase-6 Limits Model (Immutable, Derived).\n\nLimits are computed from a plan's limits_profile.\nNEVER stored directly in database.\n\nAttributes:\n    max_requests_per_day: Maximum API requests per day\n    max_active_agents: Maximum concurrent agents\n    max_storage_mb: Maximum storage in megabytes\n    max_monthly_cost_usd: Maximum monthly compute cost (soft limit)\n    max_runs_per_day: Maximum run executions per day\n    max_policies: Maximum policy rules\n\nINVARIANTS:\n- All limits are optional (None = unlimited)\n- Limits are derived from limits_profile at runtime\n- Limits are never directly persisted",
            "methods": [
              "is_unlimited"
            ],
            "line": 49
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_LIMITS",
            "line": 127
          }
        ],
        "all_exports": [
          "Limits",
          "derive_limits",
          "LIMITS_PROFILES",
          "DEFAULT_LIMITS"
        ]
      },
      {
        "file_name": "limits_facade.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/limits_facade.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 459,
        "module_docstring": "Limits Facade (L4 Domain Logic)\n\nThis facade provides the external interface for limit operations.\nAll limit APIs MUST use this facade instead of directly importing\ninternal limit modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes rate limit and quota logic\n- Provides unified access to usage tracking\n- Single point for audit emission\n\nL2 API Routes (GAP-122):\n- GET /api/v1/limits (list limits)\n- GET /api/v1/limits/{id} (get limit)\n- PUT /api/v1/limits/{id} (update limit)\n- GET /api/v1/limits/usage (current usage)\n- POST /api/v1/limits/check (check limit)\n- POST /api/v1/limits/reset (reset usage)\n\nUsage:\n    from app.hoc.cus.policies.L5_engines.limits_facade import get_limits_facade\n\n    facade = get_limits_facade()\n\n    # Check a limit\n    result = await facade.check_limit(\n        tenant_id=\"...\",\n        limit_type=\"api_calls\",\n    )",
        "functions": [
          {
            "name": "get_limits_facade",
            "signature": "() -> LimitsFacade",
            "docstring": "Get the limits facade instance.\n\nThis is the recommended way to access limit operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    LimitsFacade instance",
            "is_async": false,
            "line": 446
          }
        ],
        "classes": [
          {
            "name": "LimitType",
            "docstring": "Types of limits.",
            "methods": [],
            "line": 63
          },
          {
            "name": "LimitPeriod",
            "docstring": "Limit period.",
            "methods": [],
            "line": 73
          },
          {
            "name": "LimitConfig",
            "docstring": "Limit configuration.",
            "methods": [
              "to_dict"
            ],
            "line": 82
          },
          {
            "name": "LimitCheckResult",
            "docstring": "Result of checking a limit.",
            "methods": [
              "to_dict"
            ],
            "line": 118
          },
          {
            "name": "UsageSummary",
            "docstring": "Usage summary across all limits.",
            "methods": [
              "to_dict"
            ],
            "line": 142
          },
          {
            "name": "LimitsFacade",
            "docstring": "Facade for limit operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nlimit services.\n\nLayer: L4 (Domain Logic)\nCallers: limits.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "_get_or_create_limit",
              "list_limits",
              "get_limit",
              "update_limit",
              "check_limit",
              "get_usage",
              "reset_limit"
            ],
            "line": 161
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "limits_simulation_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/limits_simulation_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 275,
        "module_docstring": "Limits Simulation Engine (PIN-LIM-04)\n\nL4 engine for pre-execution limit simulation.\n\nDecides: Cost estimation, context assembly, response normalization\nDelegates: Data access to LimitsSimulationDriver, evaluation to LimitsEvaluator",
        "functions": [
          {
            "name": "get_limits_simulation_engine",
            "signature": "(session: 'AsyncSession') -> LimitsSimulationEngine",
            "docstring": "Get engine instance with driver.\n\nArgs:\n    session: AsyncSession for driver\n\nReturns:\n    LimitsSimulationEngine instance",
            "is_async": false,
            "line": 264
          }
        ],
        "classes": [
          {
            "name": "LimitsSimulationServiceError",
            "docstring": "Base exception for simulation engine.",
            "methods": [],
            "line": 38
          },
          {
            "name": "TenantNotFoundError",
            "docstring": "Raised when tenant is not found.",
            "methods": [],
            "line": 44
          },
          {
            "name": "LimitsSimulationEngine",
            "docstring": "L4 engine for pre-execution limit simulation.\n\nDecides: Cost estimation, context assembly\nDelegates: Data access to driver, evaluation to evaluator",
            "methods": [
              "__init__",
              "simulate",
              "_build_context",
              "_estimate_cost",
              "_load_tenant_quotas",
              "_load_cost_budgets",
              "_load_policy_limits",
              "_load_worker_limits",
              "_load_active_overrides"
            ],
            "line": 50
          }
        ],
        "imports": [
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 12
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 13
          },
          {
            "module": "app.runtime.limits.evaluator",
            "names": [
              "ActiveOverride",
              "CostBudget",
              "EvaluationContext",
              "ExecutionIntent",
              "LimitsEvaluator",
              "PolicyLimit",
              "TenantQuotas",
              "WorkerLimit"
            ],
            "is_relative": false,
            "line": 15
          },
          {
            "module": "app.schemas.limits.simulation",
            "names": [
              "LimitSimulationRequest",
              "LimitSimulationResponse"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.limits_simulation_driver",
            "names": [
              "LimitsSimulationDriver",
              "get_limits_simulation_driver"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "llm_policy.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/llm_policy.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 442,
        "module_docstring": "L4 LLM Policy Engine - Domain Authority for LLM Safety and Cost Controls\n\nB01/B05 FIX: Moved from L3 adapters to L4 domain engine.\nThis engine is the authoritative source for:\n- Safety limits (max tokens, max cost, rate limits)\n- Model selection policy\n- Budget enforcement\n- Model restrictions\n\nL3 adapters must delegate all policy decisions to this engine.\n\nEnvironment Variables:\n- LLM_MAX_TOKENS_PER_REQUEST: Max tokens per request (default: 16000)\n- LLM_MAX_COST_CENTS_PER_REQUEST: Max cost in cents per request (default: 50)\n- LLM_REQUESTS_PER_MINUTE: Rate limit (default: 60)\n- LLM_ALLOWED_MODELS: Comma-separated list of allowed models (optional)",
        "functions": [
          {
            "name": "estimate_tokens",
            "signature": "(text: str) -> int",
            "docstring": "Estimate token count for text (L4 domain function).\n\nUses rough approximation of 4 chars per token.",
            "is_async": false,
            "line": 199
          },
          {
            "name": "estimate_cost_cents",
            "signature": "(model: str, input_tokens: int, output_tokens: int) -> float",
            "docstring": "Estimate cost in cents (L4 domain function).\n\nArgs:\n    model: Model identifier\n    input_tokens: Number of input tokens\n    output_tokens: Number of output tokens\n\nReturns:\n    Estimated cost in cents",
            "is_async": false,
            "line": 208
          },
          {
            "name": "check_safety_limits",
            "signature": "(model: str, max_tokens: int, estimated_input_tokens: int, provider: str = 'default', max_tokens_limit: Optional[int] = None, max_cost_cents_limit: Optional[float] = None) -> SafetyCheckResult",
            "docstring": "Check safety limits before making LLM API call (L4 domain function).\n\nL3 adapters must call this before invoking LLM APIs.\nThey must NOT implement their own safety checks.\n\nArgs:\n    model: Model identifier\n    max_tokens: Requested max tokens for completion\n    estimated_input_tokens: Estimated input token count\n    provider: Provider name for rate limiter\n    max_tokens_limit: Override max tokens limit\n    max_cost_cents_limit: Override max cost limit\n\nReturns:\n    SafetyCheckResult indicating if request is allowed",
            "is_async": false,
            "line": 226
          },
          {
            "name": "is_model_allowed",
            "signature": "(model: str, tenant_allowed_models: Optional[List[str]] = None) -> bool",
            "docstring": "Check if a model is allowed (L4 domain function).\n\nArgs:\n    model: Model identifier\n    tenant_allowed_models: Optional tenant-specific allowed list\n\nReturns:\n    True if model is allowed",
            "is_async": false,
            "line": 314
          },
          {
            "name": "is_expensive_model",
            "signature": "(model: str) -> bool",
            "docstring": "Check if a model is classified as expensive (L4 domain function).",
            "is_async": false,
            "line": 337
          },
          {
            "name": "get_model_for_task",
            "signature": "(task_type: str, requested_model: Optional[str] = None, tenant_allowed_models: Optional[List[str]] = None, allow_expensive: bool = False) -> str",
            "docstring": "Get appropriate model for a task type (L4 policy decision).\n\nL3 TenantLLMConfig must delegate model selection to this function.\n\nArgs:\n    task_type: Type of task (planning, execution, high_value, default)\n    requested_model: Explicitly requested model\n    tenant_allowed_models: Tenant-specific allowed models\n    allow_expensive: Whether expensive models are permitted\n\nReturns:\n    Model identifier to use",
            "is_async": false,
            "line": 342
          },
          {
            "name": "get_effective_model",
            "signature": "(requested_model: Optional[str], preferred_model: str, fallback_model: str, allowed_models: List[str]) -> str",
            "docstring": "Get effective model based on request and tenant config (L4 policy decision).\n\nL3 TenantLLMConfig.get_effective_model() must delegate to this.\n\nArgs:\n    requested_model: Model explicitly requested\n    preferred_model: Tenant's preferred model\n    fallback_model: Tenant's fallback model\n    allowed_models: Tenant's allowed models list\n\nReturns:\n    Model identifier to use",
            "is_async": false,
            "line": 385
          }
        ],
        "classes": [
          {
            "name": "SafetyCheckResult",
            "docstring": "Result of a safety limit check.",
            "methods": [],
            "line": 130
          },
          {
            "name": "LLMRateLimiter",
            "docstring": "Sliding window rate limiter for LLM requests (L4 policy enforcement).\n\nL3 adapters must use this instead of implementing their own.",
            "methods": [
              "get_instance",
              "__init__",
              "check_and_record",
              "requests_remaining"
            ],
            "line": 140
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "threading",
            "names": [
              "threading"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "collections",
            "names": [
              "deque"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [
          {
            "name": "LLM_MAX_TOKENS_PER_REQUEST",
            "line": 56
          },
          {
            "name": "LLM_MAX_COST_CENTS_PER_REQUEST",
            "line": 59
          },
          {
            "name": "LLM_REQUESTS_PER_MINUTE",
            "line": 62
          },
          {
            "name": "DEFAULT_MODELS",
            "line": 76
          },
          {
            "name": "FALLBACK_MODEL",
            "line": 82
          }
        ],
        "all_exports": [
          "LLM_MAX_TOKENS_PER_REQUEST",
          "LLM_MAX_COST_CENTS_PER_REQUEST",
          "LLM_REQUESTS_PER_MINUTE",
          "LLM_ALLOWED_MODELS",
          "LLM_COST_MODEL",
          "SYSTEM_ALLOWED_MODELS",
          "EXPENSIVE_MODELS",
          "TASK_MODEL_POLICY",
          "SafetyCheckResult",
          "LLMRateLimiter",
          "estimate_tokens",
          "estimate_cost_cents",
          "check_safety_limits",
          "is_model_allowed",
          "is_expensive_model",
          "get_model_for_task",
          "get_effective_model"
        ]
      },
      {
        "file_name": "nodes.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/nodes.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 379,
        "module_docstring": "AST nodes for PLang v2.0.\n\nEach node includes:\n- Source location (line, column)\n- Governance metadata where applicable\n- Type-safe structure for analysis",
        "functions": [],
        "classes": [
          {
            "name": "GovernanceMetadata",
            "docstring": "M19 Governance metadata attached to AST nodes.\n\nThis metadata is carried through compilation to runtime\nfor governance-aware execution.",
            "methods": [
              "merge_with"
            ],
            "line": 39
          },
          {
            "name": "ASTNode",
            "docstring": "Base class for all AST nodes.",
            "methods": [
              "accept",
              "location"
            ],
            "line": 70
          },
          {
            "name": "ExprNode",
            "docstring": "Base class for expression nodes.",
            "methods": [],
            "line": 89
          },
          {
            "name": "ProgramNode",
            "docstring": "Root node representing a complete PLang program.",
            "methods": [
              "accept"
            ],
            "line": 101
          },
          {
            "name": "PolicyDeclNode",
            "docstring": "Policy declaration node.",
            "methods": [
              "__post_init__",
              "accept"
            ],
            "line": 111
          },
          {
            "name": "RuleDeclNode",
            "docstring": "Rule declaration node.",
            "methods": [
              "__post_init__",
              "accept"
            ],
            "line": 133
          },
          {
            "name": "ImportNode",
            "docstring": "Import statement node.",
            "methods": [
              "accept"
            ],
            "line": 154
          },
          {
            "name": "RuleRefNode",
            "docstring": "Reference to a named rule.",
            "methods": [
              "accept"
            ],
            "line": 164
          },
          {
            "name": "PriorityNode",
            "docstring": "Priority declaration node.",
            "methods": [
              "accept"
            ],
            "line": 174
          },
          {
            "name": "ConditionBlockNode",
            "docstring": "When/then condition block.",
            "methods": [
              "accept"
            ],
            "line": 189
          },
          {
            "name": "ActionBlockNode",
            "docstring": "Action block (deny, allow, escalate, route).",
            "methods": [
              "accept"
            ],
            "line": 200
          },
          {
            "name": "RouteTargetNode",
            "docstring": "Route target specification.",
            "methods": [
              "accept"
            ],
            "line": 211
          },
          {
            "name": "BinaryOpNode",
            "docstring": "Binary operation (and, or, ==, !=, etc.).",
            "methods": [
              "accept"
            ],
            "line": 226
          },
          {
            "name": "UnaryOpNode",
            "docstring": "Unary operation (not).",
            "methods": [
              "accept"
            ],
            "line": 238
          },
          {
            "name": "ValueNode",
            "docstring": "Base class for value nodes.",
            "methods": [],
            "line": 249
          },
          {
            "name": "IdentNode",
            "docstring": "Identifier node.",
            "methods": [
              "accept"
            ],
            "line": 256
          },
          {
            "name": "LiteralNode",
            "docstring": "Literal value node (number, string, boolean).",
            "methods": [
              "accept"
            ],
            "line": 266
          },
          {
            "name": "FuncCallNode",
            "docstring": "Function call node.",
            "methods": [
              "accept"
            ],
            "line": 276
          },
          {
            "name": "AttrAccessNode",
            "docstring": "Attribute access node (obj.attr).",
            "methods": [
              "accept"
            ],
            "line": 287
          },
          {
            "name": "ASTVisitor",
            "docstring": "Abstract base class for AST visitors.\n\nConcrete implementations must define all visit_* methods.\nThis enables the visitor pattern for AST traversal.",
            "methods": [
              "visit_program",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_import",
              "visit_rule_ref",
              "visit_priority",
              "visit_condition_block",
              "visit_action_block",
              "visit_route_target",
              "visit_binary_op",
              "visit_unary_op",
              "visit_ident",
              "visit_literal",
              "visit_func_call",
              "visit_attr_access"
            ],
            "line": 298
          }
        ],
        "imports": [
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "phase_status_invariants.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/phase_status_invariants.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 360,
        "module_docstring": "Module: phase_status_invariants\nPurpose: Enforce phase-status invariants using GovernanceConfig.\n\nThe phase_status_invariant_enforce flag in GovernanceConfig controls\nwhether invalid phase-status combinations are blocked.\n\nPhase-Status Invariants:\n    - CREATED, AUTHORIZED: status must be \"queued\"\n    - EXECUTING, GOVERNANCE_CHECK, FINALIZING: status must be \"running\"\n    - COMPLETED: status must be \"succeeded\"\n    - FAILED: status must be \"failed\", \"failed_policy\", \"cancelled\", or \"retry\"\n\nWhen enforcement is enabled, attempting an invalid combination raises\nPhaseStatusInvariantEnforcementError.\n\nExports:\n    - PhaseStatusInvariantEnforcementError: Raised on violation\n    - PhaseStatusInvariantChecker: Main checker class\n    - check_phase_status_invariant: Quick helper function",
        "functions": [
          {
            "name": "check_phase_status_invariant",
            "signature": "(phase: str, status: str, enforcement_enabled: bool = True) -> InvariantCheckResponse",
            "docstring": "Quick helper to check a phase-status invariant.\n\nArgs:\n    phase: Phase name\n    status: Status value\n    enforcement_enabled: Whether enforcement is enabled\n\nReturns:\n    InvariantCheckResponse with validation result",
            "is_async": false,
            "line": 323
          },
          {
            "name": "ensure_phase_status_invariant",
            "signature": "(phase: str, status: str, enforcement_enabled: bool = True) -> None",
            "docstring": "Quick helper to ensure phase-status invariant or raise error.\n\nArgs:\n    phase: Phase name\n    status: Status value\n    enforcement_enabled: Whether enforcement is enabled\n\nRaises:\n    PhaseStatusInvariantEnforcementError: If invalid and enforcement enabled",
            "is_async": false,
            "line": 343
          }
        ],
        "classes": [
          {
            "name": "InvariantCheckResult",
            "docstring": "Result of an invariant check.",
            "methods": [],
            "line": 46
          },
          {
            "name": "PhaseStatusInvariantEnforcementError",
            "docstring": "Raised when phase-status invariant enforcement fails.\n\nThis error indicates that an invalid phase-status combination\nwas attempted when enforcement is enabled.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 67
          },
          {
            "name": "InvariantCheckResponse",
            "docstring": "Response from an invariant check.",
            "methods": [
              "to_dict"
            ],
            "line": 102
          },
          {
            "name": "PhaseStatusInvariantChecker",
            "docstring": "Checks and enforces phase-status invariants.\n\nGAP-051: Add invariant checks to ROK.\n\nThe checker validates that phase-status combinations are valid\nand can raise errors when enforcement is enabled.\n\nUsage:\n    checker = PhaseStatusInvariantChecker(enforcement_enabled=True)\n\n    # Before a phase transition\n    checker.ensure_valid(\"EXECUTING\", \"running\")\n\n    # Or check without raising\n    response = checker.check(\"EXECUTING\", \"running\")\n    if not response.is_valid and response.enforcement_enabled:\n        handle_invariant_violation()",
            "methods": [
              "__init__",
              "from_governance_config",
              "enforcement_enabled",
              "get_allowed_statuses",
              "is_valid_combination",
              "check",
              "ensure_valid",
              "should_allow_transition"
            ],
            "line": 126
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "FrozenSet",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "plan.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/plan.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 145,
        "module_docstring": "Phase-6 Plan Model \u2014 Named Contracts (Not Pricing Logic)\n\nPIN-399 Phase-6: Plans are named contracts, not pricing logic.\n\nEXPLICIT NON-GOALS:\n- No prices\n- No currency\n- No billing cycle assumptions\n- No gateway IDs\n- No subscriptions\n- No coupons / proration / invoices\n- No taxes\n\nThose come in future phases, if ever.\n\nThis module defines the abstract Plan model used for limit derivation.",
        "functions": [],
        "classes": [
          {
            "name": "PlanTier",
            "docstring": "Plan tier hierarchy.\n\nTiers represent capability levels, not prices.",
            "methods": [
              "from_string"
            ],
            "line": 44
          },
          {
            "name": "Plan",
            "docstring": "Phase-6 Plan Model (Immutable).\n\nPlans define what a tenant is entitled to, not what they pay.\n\nAttributes:\n    id: Unique plan identifier (e.g., \"free-v1\", \"pro-v1\")\n    name: Human-readable name (e.g., \"Free\", \"Pro\")\n    tier: Capability tier (FREE, PRO, ENTERPRISE)\n    limits_profile: Key for deriving limits (e.g., \"free\", \"pro\", \"enterprise\")\n    description: Optional human-readable description\n\nINVARIANTS:\n- Plans are immutable after creation\n- Plans do not contain pricing information\n- Plans do not reference gateway IDs\n- Limits are derived from limits_profile, not stored on the plan",
            "methods": [
              "__post_init__"
            ],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [
          {
            "name": "PLAN_FREE",
            "line": 110
          },
          {
            "name": "PLAN_PRO",
            "line": 118
          },
          {
            "name": "PLAN_ENTERPRISE",
            "line": 126
          },
          {
            "name": "DEFAULT_PLAN",
            "line": 135
          }
        ],
        "all_exports": [
          "PlanTier",
          "Plan",
          "PLAN_FREE",
          "PLAN_PRO",
          "PLAN_ENTERPRISE",
          "DEFAULT_PLAN"
        ]
      },
      {
        "file_name": "plan_generation.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/plan_generation.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 258,
        "module_docstring": "Domain engine for plan generation.\n\nThis L4 engine contains the authoritative logic for:\n1. Memory context retrieval\n2. Plan generation via planner\n3. Plan validation\n\nL5 workers must receive plans from this engine (via run.plan_json),\nnot generate their own plans.\n\nReference: PIN-257 Phase R-2\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md",
        "functions": [
          {
            "name": "generate_plan_for_run",
            "signature": "(agent_id: str, goal: str, run_id: str) -> PlanGenerationResult",
            "docstring": "Convenience function to generate a plan for a run.\n\nThis is the L4 entry point for plan generation. It should be called\nby the run creation flow (in L2 API) to generate plans before\nthe run is queued for execution.\n\nArgs:\n    agent_id: Agent ID\n    goal: Run goal\n    run_id: Run ID\n\nReturns:\n    PlanGenerationResult with the generated plan\n\nReference: PIN-257 Phase R-2",
            "is_async": false,
            "line": 212
          }
        ],
        "classes": [
          {
            "name": "PlanGenerationContext",
            "docstring": "Context for plan generation.",
            "methods": [],
            "line": 56
          },
          {
            "name": "PlanGenerationResult",
            "docstring": "Result of plan generation.",
            "methods": [],
            "line": 66
          },
          {
            "name": "PlanGenerationEngine",
            "docstring": "L4 Domain Engine for plan generation.\n\nThis engine contains ALL plan generation logic that was previously\nscattered in L5 runner.py. It generates plans from goals using\nmemory context and the configured planner.\n\nL5 workers must NOT:\n- Import memory.get_retriever()\n- Import planners.get_planner()\n- Generate plans inline\n\nL5 workers must ONLY:\n- Execute plans provided via run.plan_json\n- Fail if no plan is provided\n\nReference: PIN-257 Phase R-2\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md Section 3.2",
            "methods": [
              "__init__",
              "generate"
            ],
            "line": 83
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.memory",
            "names": [
              "get_retriever"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.planners",
            "names": [
              "get_planner"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.skills",
            "names": [
              "get_skill_manifest"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.utils.budget_tracker",
            "names": [
              "get_budget_tracker"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.utils.plan_inspector",
            "names": [
              "validate_plan"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": [
          "PlanGenerationContext",
          "PlanGenerationResult",
          "PlanGenerationEngine",
          "generate_plan_for_run"
        ]
      },
      {
        "file_name": "policies_facade.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policies_facade.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 1193,
        "module_docstring": "PoliciesFacade (L5)\n\nUnified facade for policy management operations.\n\nProvides:\n- Policy Rules: list, get detail (via L6 driver)\n- Limits: list, get detail (via L6 driver)\n- Lessons: list, get detail, stats (delegates to LessonsLearnedEngine)\n- Policy State: synthesized snapshot (mixed: driver + engine delegation)\n- Policy Metrics: enforcement effectiveness (delegates to PolicyEngine)\n- Policy Conflicts: detect contradictions (delegates to PolicyConflictEngine)\n- Policy Dependencies: structural relationships (delegates to PolicyDependencyEngine)\n- Policy Violations: unified violation view (delegates to PolicyEngine)\n- Budget Definitions: enforcement limits (via L6 driver)\n- Policy Requests: pending approvals (via L6 driver)\n\nAll operations are tenant-scoped for isolation.",
        "functions": [
          {
            "name": "get_policies_facade",
            "signature": "(driver: Optional[PoliciesFacadeDriver] = None) -> PoliciesFacade",
            "docstring": "Get the singleton PoliciesFacade instance.",
            "is_async": false,
            "line": 1149
          }
        ],
        "classes": [
          {
            "name": "PolicyRuleSummaryResult",
            "docstring": "Policy rule summary for list view (O2).",
            "methods": [],
            "line": 46
          },
          {
            "name": "PolicyRulesListResult",
            "docstring": "Policy rules list response.",
            "methods": [],
            "line": 64
          },
          {
            "name": "PolicyRuleDetailResult",
            "docstring": "Policy rule detail response (O3).",
            "methods": [],
            "line": 74
          },
          {
            "name": "LimitSummaryResult",
            "docstring": "Limit summary for list view (O2).",
            "methods": [],
            "line": 101
          },
          {
            "name": "LimitsListResult",
            "docstring": "Limits list response.",
            "methods": [],
            "line": 122
          },
          {
            "name": "LimitDetailResult",
            "docstring": "Limit detail response (O3).",
            "methods": [],
            "line": 132
          },
          {
            "name": "PolicyStateResult",
            "docstring": "Policy layer state summary (ACT-O4).",
            "methods": [],
            "line": 162
          },
          {
            "name": "PolicyMetricsResult",
            "docstring": "Policy enforcement metrics (ACT-O5).",
            "methods": [],
            "line": 175
          },
          {
            "name": "PolicyConflictResult",
            "docstring": "Policy conflict summary (DFT-O4).",
            "methods": [],
            "line": 194
          },
          {
            "name": "ConflictsListResult",
            "docstring": "Policy conflicts list response.",
            "methods": [],
            "line": 209
          },
          {
            "name": "PolicyDependencyRelation",
            "docstring": "A dependency relationship.",
            "methods": [],
            "line": 219
          },
          {
            "name": "PolicyNodeResult",
            "docstring": "A node in the dependency graph (DFT-O5).",
            "methods": [],
            "line": 229
          },
          {
            "name": "PolicyDependencyEdge",
            "docstring": "A dependency edge in the graph.",
            "methods": [],
            "line": 243
          },
          {
            "name": "DependencyGraphResult",
            "docstring": "Policy dependency graph response.",
            "methods": [],
            "line": 255
          },
          {
            "name": "PolicyViolationResult",
            "docstring": "Policy violation summary (VIO-O1).",
            "methods": [],
            "line": 271
          },
          {
            "name": "ViolationsListResult",
            "docstring": "Policy violations list response.",
            "methods": [],
            "line": 287
          },
          {
            "name": "BudgetDefinitionResult",
            "docstring": "Budget definition summary (THR-O2).",
            "methods": [],
            "line": 302
          },
          {
            "name": "BudgetsListResult",
            "docstring": "Budget definitions list response.",
            "methods": [],
            "line": 317
          },
          {
            "name": "PolicyRequestResult",
            "docstring": "Pending policy request summary (ACT-O3).",
            "methods": [],
            "line": 331
          },
          {
            "name": "PolicyRequestsListResult",
            "docstring": "Policy requests list response.",
            "methods": [],
            "line": 346
          },
          {
            "name": "LessonSummaryResult",
            "docstring": "Lesson summary for list view (O2).",
            "methods": [],
            "line": 361
          },
          {
            "name": "LessonsListResult",
            "docstring": "Lessons list response.",
            "methods": [],
            "line": 375
          },
          {
            "name": "LessonDetailResult",
            "docstring": "Lesson detail response (O3).",
            "methods": [],
            "line": 385
          },
          {
            "name": "LessonStatsResult",
            "docstring": "Lesson statistics response.",
            "methods": [],
            "line": 406
          },
          {
            "name": "PoliciesFacade",
            "docstring": "Unified facade for policy management.\n\nSQL operations delegate to PoliciesFacadeDriver (L6).\nDomain operations delegate to same-domain L5 engines.",
            "methods": [
              "__init__",
              "list_policy_rules",
              "get_policy_rule_detail",
              "list_limits",
              "get_limit_detail",
              "list_lessons",
              "get_lesson_detail",
              "get_lesson_stats",
              "get_policy_state",
              "get_policy_metrics",
              "list_policy_violations",
              "list_policy_conflicts",
              "get_policy_dependencies",
              "list_policy_requests",
              "list_budgets"
            ],
            "line": 419
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policies_facade_driver",
            "names": [
              "PoliciesFacadeDriver"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": [
          "PoliciesFacade",
          "get_policies_facade",
          "PolicyRuleSummaryResult",
          "PolicyRulesListResult",
          "PolicyRuleDetailResult",
          "LimitSummaryResult",
          "LimitsListResult",
          "LimitDetailResult",
          "PolicyStateResult",
          "PolicyMetricsResult",
          "PolicyConflictResult",
          "ConflictsListResult",
          "PolicyDependencyRelation",
          "PolicyNodeResult",
          "PolicyDependencyEdge",
          "DependencyGraphResult",
          "PolicyViolationResult",
          "ViolationsListResult",
          "BudgetDefinitionResult",
          "BudgetsListResult",
          "PolicyRequestResult",
          "PolicyRequestsListResult",
          "LessonSummaryResult",
          "LessonsListResult",
          "LessonDetailResult",
          "LessonStatsResult"
        ]
      },
      {
        "file_name": "policies_limits_query_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policies_limits_query_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 343,
        "module_docstring": "Limits Query Engine (L5)\n\nRead-only query operations for limits and budget definitions.\nProvides list, get detail, filtering, and budget queries.\n\nInvariant: This engine is READ-ONLY. No writes. No state mutation.",
        "functions": [
          {
            "name": "get_limits_query_engine",
            "signature": "(session: 'AsyncSession' = None) -> LimitsQueryEngine",
            "docstring": "Get a LimitsQueryEngine instance.\n\nPIN-508 Phase 2B: Prefer passing driver (LimitsQueryCapability) from DomainBridge.\nFalls back to lazy cross-domain import if no driver provided (legacy path).",
            "is_async": false,
            "line": 302
          }
        ],
        "classes": [
          {
            "name": "LimitSummaryResult",
            "docstring": "Limit summary for list view (O2).",
            "methods": [],
            "line": 43
          },
          {
            "name": "LimitsListResult",
            "docstring": "Limits list response.",
            "methods": [],
            "line": 64
          },
          {
            "name": "LimitDetailResult",
            "docstring": "Limit detail response (O3).",
            "methods": [],
            "line": 74
          },
          {
            "name": "BudgetDefinitionResult",
            "docstring": "Budget definition summary (THR-O2).",
            "methods": [],
            "line": 99
          },
          {
            "name": "BudgetsListResult",
            "docstring": "Budget definitions list response.",
            "methods": [],
            "line": 114
          },
          {
            "name": "LimitsQueryEngine",
            "docstring": "L5 Query Engine for limits.\n\nProvides read-only operations:\n- List limits with filters\n- Get limit detail\n- List budget definitions\n\nAll data access is delegated to L6 driver.",
            "methods": [
              "__init__",
              "list_limits",
              "get_limit_detail",
              "list_budgets"
            ],
            "line": 127
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": [
          "LimitsQueryEngine",
          "get_limits_query_engine",
          "LimitSummaryResult",
          "LimitsListResult",
          "LimitDetailResult",
          "BudgetDefinitionResult",
          "BudgetsListResult"
        ]
      },
      {
        "file_name": "policies_proposals_query_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policies_proposals_query_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 294,
        "module_docstring": "Proposals Query Engine (L5)\n\nRead-only query operations for policy proposals (list view).\nProvides list, get detail, and draft counts.\n\nNote: This engine is for the \"Proposals\" tab UI.\nFor proposal lifecycle operations (create, approve, reject),\nsee policy_proposal_engine.py.\n\nInvariant: This engine is READ-ONLY. No writes. No state mutation.",
        "functions": [
          {
            "name": "get_proposals_query_engine",
            "signature": "(session: 'AsyncSession') -> ProposalsQueryEngine",
            "docstring": "Get a ProposalsQueryEngine instance.",
            "is_async": false,
            "line": 279
          }
        ],
        "classes": [
          {
            "name": "PolicyRequestResult",
            "docstring": "Pending policy request summary (ACT-O3).",
            "methods": [],
            "line": 49
          },
          {
            "name": "PolicyRequestsListResult",
            "docstring": "Policy requests list response.",
            "methods": [],
            "line": 64
          },
          {
            "name": "PolicyRequestDetailResult",
            "docstring": "Policy request detail response.",
            "methods": [],
            "line": 74
          },
          {
            "name": "ProposalsQueryEngine",
            "docstring": "L5 Query Engine for policy proposals.\n\nProvides read-only operations:\n- List proposals with filters\n- Get proposal detail\n- Count draft proposals\n\nAll data access is delegated to L6 driver.",
            "methods": [
              "__init__",
              "list_policy_requests",
              "get_policy_request_detail",
              "count_drafts",
              "list_proposals_paginated",
              "get_proposal_stats",
              "get_proposal_detail",
              "list_proposal_versions"
            ],
            "line": 98
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.proposals_read_driver",
            "names": [
              "ProposalsReadDriver",
              "get_proposals_read_driver"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": [
          "ProposalsQueryEngine",
          "get_proposals_query_engine",
          "PolicyRequestResult",
          "PolicyRequestsListResult",
          "PolicyRequestDetailResult"
        ]
      },
      {
        "file_name": "policies_rules_query_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policies_rules_query_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 246,
        "module_docstring": "Policy Rules Query Engine (L5)\n\nRead-only query operations for policy rules.\nProvides list, get detail, filtering, and counts.\n\nInvariant: This engine is READ-ONLY. No writes. No state mutation.",
        "functions": [
          {
            "name": "get_policy_rules_query_engine",
            "signature": "(session: 'AsyncSession') -> PolicyRulesQueryEngine",
            "docstring": "Get a PolicyRulesQueryEngine instance.",
            "is_async": false,
            "line": 229
          }
        ],
        "classes": [
          {
            "name": "PolicyRuleSummaryResult",
            "docstring": "Policy rule summary for list view (O2).",
            "methods": [],
            "line": 46
          },
          {
            "name": "PolicyRulesListResult",
            "docstring": "Policy rules list response.",
            "methods": [],
            "line": 64
          },
          {
            "name": "PolicyRuleDetailResult",
            "docstring": "Policy rule detail response (O3).",
            "methods": [],
            "line": 74
          },
          {
            "name": "PolicyRulesQueryEngine",
            "docstring": "L5 Query Engine for policy rules.\n\nProvides read-only operations:\n- List rules with filters\n- Get rule detail\n- Count rules\n\nAll data access is delegated to L6 driver.",
            "methods": [
              "__init__",
              "list_policy_rules",
              "get_policy_rule_detail",
              "count_rules"
            ],
            "line": 100
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_rules_read_driver",
            "names": [
              "PolicyRulesReadDriver",
              "get_policy_rules_read_driver"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyRulesQueryEngine",
          "get_policy_rules_query_engine",
          "PolicyRuleSummaryResult",
          "PolicyRulesListResult",
          "PolicyRuleDetailResult"
        ]
      },
      {
        "file_name": "policy_command.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_command.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 480,
        "module_docstring": "Policy Command (L4)\n\nDomain command for policy evaluation and approval workflow. This L4 command:\n1. Owns all policy decisions (cost feasibility, violations, outcomes)\n2. Delegates to L5 for execution (metrics, simulation, enforcement)\n3. Returns result objects to L3 adapter\n\nThis command may import L5 (workflow.metrics, workflow.cost_sim, workflow.policies)\nbecause L4 \u2192 L5 is allowed per layer rules.\n\nReference: PIN-258 Phase F-3 Policy Cluster",
        "functions": [
          {
            "name": "simulate_cost",
            "signature": "(skill_id: str, tenant_id: str, payload: Dict[str, Any]) -> Optional[int]",
            "docstring": "Simulate cost for a skill execution.\n\nThis L4 command delegates to L5 CostSimulator.\nL4 \u2192 L5 is allowed per layer rules.\n\nArgs:\n    skill_id: Skill to simulate\n    tenant_id: Tenant context\n    payload: Execution payload\n\nReturns:\n    Estimated cost in cents, or fallback estimate\n\nReference: PIN-258 Phase F-3 (F-P-RULE-4: No Dual Ownership)",
            "is_async": true,
            "line": 90
          },
          {
            "name": "check_policy_violations",
            "signature": "(skill_id: str, tenant_id: str, agent_id: Optional[str], payload: Dict[str, Any], simulated_cost: Optional[int]) -> List[PolicyViolation]",
            "docstring": "Check for policy violations.\n\nThis L4 command delegates to L5 PolicyEnforcer.\nL4 \u2192 L5 is allowed per layer rules.\n\nArgs:\n    skill_id: Skill being evaluated\n    tenant_id: Tenant context\n    agent_id: Optional agent context\n    payload: Execution payload\n    simulated_cost: Cost estimate from simulation\n\nReturns:\n    List of policy violations found\n\nReference: PIN-258 Phase F-3 (F-P-RULE-1: Policy Decisions in L4)",
            "is_async": true,
            "line": 131
          },
          {
            "name": "evaluate_policy",
            "signature": "(skill_id: str, tenant_id: str, agent_id: Optional[str], payload: Dict[str, Any], auto_approve_max_cost_cents: int = 0, approval_level: int = 1) -> PolicyEvaluationResult",
            "docstring": "Evaluate policy for a skill execution.\n\nThis L4 command orchestrates:\n1. Cost simulation (via L5)\n2. Policy violation check (via L5)\n3. Decision determination\n4. Metrics emission (via L5)\n\nL4 \u2192 L5 is allowed per layer rules.\n\nArgs:\n    skill_id: Skill to evaluate\n    tenant_id: Tenant context\n    agent_id: Optional agent context\n    payload: Execution payload\n    auto_approve_max_cost_cents: Threshold for auto-approval\n    approval_level: Required approval level\n\nReturns:\n    PolicyEvaluationResult with decision and details\n\nReference: PIN-258 Phase F-3 (F-P-RULE-1: Policy Decisions in L4)",
            "is_async": true,
            "line": 230
          },
          {
            "name": "_record_policy_decision",
            "signature": "(decision: str, policy_type: str) -> None",
            "docstring": "Record policy decision metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 317
          },
          {
            "name": "_record_capability_violation",
            "signature": "(violation_type: str, skill_id: str, tenant_id: Optional[str] = None) -> None",
            "docstring": "Record capability violation metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 331
          },
          {
            "name": "_record_budget_rejection",
            "signature": "(resource_type: str, skill_id: str) -> None",
            "docstring": "Record budget rejection metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 345
          },
          {
            "name": "_record_approval_request_created",
            "signature": "(policy_type: str) -> None",
            "docstring": "Record approval request creation metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 359
          },
          {
            "name": "_record_approval_action",
            "signature": "(result: str) -> None",
            "docstring": "Record approval action metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 373
          },
          {
            "name": "_record_approval_escalation",
            "signature": "() -> None",
            "docstring": "Record approval escalation metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 387
          },
          {
            "name": "_record_webhook_fallback",
            "signature": "() -> None",
            "docstring": "Record webhook fallback metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 401
          },
          {
            "name": "record_approval_created",
            "signature": "(policy_type: str) -> None",
            "docstring": "Record that an approval request was created.\n\nThis is a public L4 command for L3 to call.\nDelegates metric emission to L5.",
            "is_async": false,
            "line": 420
          },
          {
            "name": "record_approval_outcome",
            "signature": "(result: str) -> None",
            "docstring": "Record approval outcome (approved/rejected/expired).\n\nThis is a public L4 command for L3 to call.\nDelegates metric emission to L5.",
            "is_async": false,
            "line": 430
          },
          {
            "name": "record_escalation",
            "signature": "() -> None",
            "docstring": "Record that an escalation occurred.\n\nThis is a public L4 command for L3 to call.\nDelegates metric emission to L5.",
            "is_async": false,
            "line": 440
          },
          {
            "name": "record_webhook_used",
            "signature": "() -> None",
            "docstring": "Record that webhook fallback was used.\n\nThis is a public L4 command for L3 to call.\nDelegates metric emission to L5.",
            "is_async": false,
            "line": 450
          }
        ],
        "classes": [
          {
            "name": "PolicyViolation",
            "docstring": "A policy violation detected during evaluation.",
            "methods": [],
            "line": 52
          },
          {
            "name": "PolicyEvaluationResult",
            "docstring": "Result from policy evaluation command.",
            "methods": [],
            "line": 62
          },
          {
            "name": "ApprovalConfig",
            "docstring": "Approval level configuration.",
            "methods": [],
            "line": 74
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyViolation",
          "PolicyEvaluationResult",
          "ApprovalConfig",
          "simulate_cost",
          "check_policy_violations",
          "evaluate_policy",
          "record_approval_created",
          "record_approval_outcome",
          "record_escalation",
          "record_webhook_used"
        ]
      },
      {
        "file_name": "policy_conflict_resolver.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_conflict_resolver.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 267,
        "module_docstring": "Module: conflict_resolver\nPurpose: Defines explicit rules for resolving policy conflicts.\n\nImplements INV-005: Policy Conflict Determinism (CONFLICT-DET-001)\n> When multiple policies apply to the same action, the most restrictive action wins.\n> If two policies have equal restrictiveness, the policy with the lowest policy_id wins\n> (deterministic tiebreaker).\n\nImports (Dependencies):\n    - None (standalone)\n\nExports (Provides):\n    - resolve_policy_conflict(actions: List[PolicyAction]) -> ResolvedAction\n    - ConflictResolutionStrategy: Enum\n    - PolicyConflictLog: Audit record of conflict resolution\n\nWiring Points:\n    - Called from: prevention_engine.py:evaluate_policies()\n    - Emits: PolicyConflictLog to audit ledger\n\nConflict Resolution Rules (INV-005):\n    1. Higher precedence wins (lower number = higher priority)\n    2. Within same precedence, more restrictive action wins\n    3. Action restrictiveness order: KILL > STOP > PAUSE > WARN > CONTINUE\n    4. If precedence and action are equal, lowest policy_id wins (deterministic tiebreaker)\n\nAcceptance Criteria:\n    - [x] AC-068-01: Single policy returns without conflict\n    - [x] AC-068-02: Multiple policies same action no conflict\n    - [x] AC-068-03: Precedence resolves conflict\n    - [x] AC-068-04: Severity resolves same-precedence\n    - [x] AC-068-05: Conflict logged to audit\n    - [x] AC-068-06: Wired to prevention_engine\n    - [x] AC-068-07: Deterministic tiebreaker (INV-005)",
        "functions": [
          {
            "name": "resolve_policy_conflict",
            "signature": "(actions: List[PolicyAction], strategy: ConflictResolutionStrategy = ConflictResolutionStrategy.PRECEDENCE_FIRST) -> ResolvedAction",
            "docstring": "Resolve conflict when multiple policies trigger.\n\nImplements INV-005: Policy Conflict Determinism\n\nResolution Algorithm:\n1. Sort by precedence (lower number = higher priority)\n2. Within same precedence, sort by action severity (higher = more restrictive)\n3. Within same precedence and severity, sort by policy_id (deterministic tiebreaker)\n4. Return the winning action\n\nArgs:\n    actions: List of triggered policy actions\n    strategy: Resolution strategy to use\n\nReturns:\n    ResolvedAction with winning policy and audit trail",
            "is_async": false,
            "line": 133
          },
          {
            "name": "create_conflict_log",
            "signature": "(run_id: str, resolved: ResolvedAction, strategy: ConflictResolutionStrategy) -> PolicyConflictLog",
            "docstring": "Create audit log entry for conflict resolution.\n\nArgs:\n    run_id: ID of the run being evaluated\n    resolved: Resolution result\n    strategy: Strategy used\n\nReturns:\n    PolicyConflictLog for audit trail",
            "is_async": false,
            "line": 217
          },
          {
            "name": "get_action_severity",
            "signature": "(action: str) -> int",
            "docstring": "Get the severity level for an action.\n\nArgs:\n    action: Action string (CONTINUE, WARN, PAUSE, STOP, KILL)\n\nReturns:\n    Severity level (0-4)",
            "is_async": false,
            "line": 243
          },
          {
            "name": "is_more_restrictive",
            "signature": "(action_a: str, action_b: str) -> bool",
            "docstring": "Check if action_a is more restrictive than action_b.\n\nArgs:\n    action_a: First action\n    action_b: Second action\n\nReturns:\n    True if action_a is more restrictive",
            "is_async": false,
            "line": 256
          }
        ],
        "classes": [
          {
            "name": "ActionSeverity",
            "docstring": "Action severity for conflict resolution. Higher = more restrictive.\n\nINV-005 Restrictiveness Order: KILL > STOP > PAUSE > WARN > CONTINUE",
            "methods": [],
            "line": 66
          },
          {
            "name": "ConflictResolutionStrategy",
            "docstring": "Resolution strategy for policy conflicts.",
            "methods": [],
            "line": 82
          },
          {
            "name": "PolicyAction",
            "docstring": "A triggered policy action.",
            "methods": [],
            "line": 90
          },
          {
            "name": "ResolvedAction",
            "docstring": "Result of conflict resolution.",
            "methods": [],
            "line": 100
          },
          {
            "name": "PolicyConflictLog",
            "docstring": "Audit log entry for conflict resolution.",
            "methods": [],
            "line": 110
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum",
              "IntEnum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [
          {
            "name": "ACTION_SEVERITY",
            "line": 121
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "policy_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_driver.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 424,
        "module_docstring": "Policy Domain Driver (INTERNAL)\n\nThis driver provides the internal interface for policy evaluation operations.\nUsed by policy_layer API, governance services, and worker runtime.\n\nFor CUSTOMER policy CRUD operations, use policies_facade.py instead.\n\nWhy Drivers (not Facades for internal use):\n- Facades are API projection layers (CUSTOMER-facing)\n- Drivers are orchestration layers (INTERNAL)\n- Clear separation prevents confusion\n- Import rules become enforceable\n\nUsage:\n    from app.hoc.cus.policies.L5_engines.policy_driver import get_policy_driver\n\n    driver = get_policy_driver()\n    result = await driver.evaluate(eval_request, db)",
        "functions": [
          {
            "name": "get_policy_driver",
            "signature": "(db_url: Optional[str] = None) -> PolicyDriver",
            "docstring": "Get the PolicyDriver singleton.\n\nThis is the recommended way to access policy evaluation from\ninternal code (policy_layer, governance services).\n\nFor CUSTOMER API CRUD operations, use get_policies_facade() instead.\n\nArgs:\n    db_url: Optional database URL override\n\nReturns:\n    PolicyDriver singleton instance",
            "is_async": false,
            "line": 393
          },
          {
            "name": "reset_policy_driver",
            "signature": "() -> None",
            "docstring": "Reset the driver singleton (for testing).",
            "is_async": false,
            "line": 414
          }
        ],
        "classes": [
          {
            "name": "PolicyDriver",
            "docstring": "Driver for Policy domain operations (INTERNAL).\n\nThis is the entry point for internal code (policy_layer, governance)\nto interact with policy evaluation services.\n\nCUSTOMER-facing CRUD code should use policies_facade.py instead.",
            "methods": [
              "__init__",
              "_engine",
              "policy_engine_driver",
              "evaluate",
              "pre_check",
              "get_state",
              "reload_policies",
              "get_violations",
              "get_violation",
              "acknowledge_violation",
              "get_risk_ceilings",
              "get_risk_ceiling",
              "update_risk_ceiling",
              "reset_risk_ceiling",
              "get_safety_rules",
              "update_safety_rule",
              "get_ethical_constraints",
              "get_active_cooldowns",
              "clear_cooldowns",
              "get_metrics",
              "get_policy_versions",
              "get_current_version",
              "create_policy_version",
              "rollback_to_version",
              "get_version_provenance",
              "activate_policy_version",
              "get_dependency_graph",
              "get_policy_conflicts",
              "resolve_conflict",
              "validate_dependency_dag",
              "add_dependency_with_dag_check",
              "get_topological_evaluation_order",
              "get_temporal_policies",
              "create_temporal_policy",
              "get_temporal_utilization",
              "prune_temporal_metrics",
              "get_temporal_storage_stats",
              "evaluate_with_context"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_graph.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_graph.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 824,
        "module_docstring": "Policy Graph Engine \u2014 Conflict Detection & Dependency Analysis\n\nThis module implements:\n- PolicyConflictEngine: Detects logical contradictions between policies (DFT-O4)\n- PolicyDependencyEngine: Computes structural relationships between policies (DFT-O5)\n\nThese engines answer STATIC governance questions, not runtime enforcement.\nThey must be deterministic, explainable, and replayable.\n\nReference: PIN-411 Gap Closure Spec (Part A)",
        "functions": [
          {
            "name": "get_conflict_engine",
            "signature": "(tenant_id: str) -> PolicyConflictEngine",
            "docstring": "Get a PolicyConflictEngine instance for a tenant.",
            "is_async": false,
            "line": 790
          },
          {
            "name": "get_dependency_engine",
            "signature": "(tenant_id: str) -> PolicyDependencyEngine",
            "docstring": "Get a PolicyDependencyEngine instance for a tenant.",
            "is_async": false,
            "line": 795
          }
        ],
        "classes": [
          {
            "name": "ConflictType",
            "docstring": "Conflict taxonomy (LOCKED).",
            "methods": [],
            "line": 53
          },
          {
            "name": "ConflictSeverity",
            "docstring": "Conflict severity levels.",
            "methods": [],
            "line": 62
          },
          {
            "name": "DependencyType",
            "docstring": "Dependency types (LOCKED).",
            "methods": [],
            "line": 69
          },
          {
            "name": "PolicyConflict",
            "docstring": "A detected conflict between two policies.",
            "methods": [
              "to_dict"
            ],
            "line": 83
          },
          {
            "name": "PolicyDependency",
            "docstring": "A dependency relationship between policies.",
            "methods": [
              "to_dict"
            ],
            "line": 111
          },
          {
            "name": "PolicyNode",
            "docstring": "A node in the dependency graph.",
            "methods": [
              "to_dict"
            ],
            "line": 135
          },
          {
            "name": "DependencyGraphResult",
            "docstring": "Result of dependency graph computation.",
            "methods": [
              "to_dict"
            ],
            "line": 161
          },
          {
            "name": "ConflictDetectionResult",
            "docstring": "Result of conflict detection.",
            "methods": [
              "to_dict"
            ],
            "line": 177
          },
          {
            "name": "PolicyConflictEngine",
            "docstring": "Detects logical contradictions, overlaps, or unsafe coexistence between policies.\n\nThis engine prevents:\n- Mutually exclusive policies being active together\n- Silent overrides\n- Temporal deadlocks\n\nConflicts are TYPED, not inferred.",
            "methods": [
              "__init__",
              "detect_conflicts",
              "_detect_scope_overlaps",
              "_detect_threshold_contradictions",
              "_detect_temporal_conflicts",
              "_detect_priority_overrides",
              "_has_contradicting_conditions",
              "_time_windows_overlap",
              "_involves_policy"
            ],
            "line": 198
          },
          {
            "name": "PolicyDependencyEngine",
            "docstring": "Computes structural relationships between policies.\n\nExposes dependencies so that:\n- Deletions don't break enforcement\n- Activations are ordered\n- Impact analysis is possible\n\nThe graph is a computed view (DAG), not persisted edges.",
            "methods": [
              "__init__",
              "compute_dependency_graph",
              "_detect_explicit_dependencies",
              "_detect_implicit_scope_dependencies",
              "_detect_implicit_limit_dependencies",
              "check_can_delete",
              "check_can_activate"
            ],
            "line": 494
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_graph_driver",
            "names": [
              "PolicyGraphDriver",
              "get_policy_graph_driver"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": [
          "ConflictType",
          "ConflictSeverity",
          "DependencyType",
          "PolicyConflict",
          "PolicyDependency",
          "PolicyNode",
          "DependencyGraphResult",
          "ConflictDetectionResult",
          "PolicyConflictEngine",
          "PolicyDependencyEngine",
          "get_conflict_engine",
          "get_dependency_engine",
          "PolicyGraphDriver",
          "get_policy_graph_driver"
        ]
      },
      {
        "file_name": "policy_limits_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_limits_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 391,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "PolicyLimitsServiceError",
            "docstring": "Base exception for policy limits service.",
            "methods": [],
            "line": 74
          },
          {
            "name": "LimitNotFoundError",
            "docstring": "Raised when limit is not found.",
            "methods": [],
            "line": 79
          },
          {
            "name": "LimitValidationError",
            "docstring": "Raised when limit validation fails.",
            "methods": [],
            "line": 84
          },
          {
            "name": "ImmutableFieldError",
            "docstring": "Raised when attempting to modify immutable fields.",
            "methods": [],
            "line": 89
          },
          {
            "name": "PolicyLimitsService",
            "docstring": "Service for policy limit CRUD operations.\n\nINVARIANTS:\n- Limits are tenant-scoped\n- limit_category and limit_type are immutable after creation\n- Every active limit MUST have an integrity record\n- Deletions are soft (status = DISABLED)",
            "methods": [
              "__init__",
              "create",
              "update",
              "delete",
              "get",
              "_get_limit",
              "_validate_category_fields",
              "_to_response"
            ],
            "line": 94
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.hoc_spine.drivers.cross_domain",
            "names": [
              "generate_uuid"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.domain_enums",
            "names": [
              "ActorType"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.policy_limits",
            "names": [
              "CreatePolicyLimitRequest",
              "UpdatePolicyLimitRequest",
              "PolicyLimitResponse"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_mapper.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_mapper.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 643,
        "module_docstring": "Module: policy_mapper\nPurpose: Map MCP tool invocations to policy gates.\n\nWires:\n    - Source: app/services/mcp/server_registry.py (tools)\n    - Source: app/services/policies/policy_engine.py (policy evaluation)\n    - Target: Tool invocations are gated by policy\n\nThis module:\n    1. Maps MCP tool invocations to policy checks\n    2. Determines required permissions for each tool\n    3. Evaluates policy before allowing invocation\n    4. Provides deny-by-default for unknown tools\n\nAcceptance Criteria:\n    - AC-142-01: Tools are mapped to policies\n    - AC-142-02: Deny-by-default for unmapped tools\n    - AC-142-03: Dangerous tools require explicit allow\n    - AC-142-04: Policy decisions are logged\n    - AC-142-05: Tenant policies are respected",
        "functions": [
          {
            "name": "get_mcp_policy_mapper",
            "signature": "() -> MCPPolicyMapper",
            "docstring": "Get or create the singleton MCPPolicyMapper.\n\nReturns:\n    MCPPolicyMapper instance",
            "is_async": false,
            "line": 600
          },
          {
            "name": "configure_mcp_policy_mapper",
            "signature": "(policy_engine: Optional[Any] = None) -> MCPPolicyMapper",
            "docstring": "Configure the singleton MCPPolicyMapper.\n\nArgs:\n    policy_engine: Policy engine to use\n\nReturns:\n    Configured MCPPolicyMapper",
            "is_async": false,
            "line": 616
          },
          {
            "name": "reset_mcp_policy_mapper",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 640
          }
        ],
        "classes": [
          {
            "name": "MCPPolicyDecisionType",
            "docstring": "Types of policy decisions for MCP tools.",
            "methods": [],
            "line": 54
          },
          {
            "name": "MCPDenyReason",
            "docstring": "Reasons for denying MCP tool invocation.",
            "methods": [],
            "line": 62
          },
          {
            "name": "MCPPolicyDecision",
            "docstring": "Policy decision for MCP tool invocation.\n\nContains the decision and context for audit.",
            "methods": [
              "to_dict",
              "allow",
              "deny"
            ],
            "line": 75
          },
          {
            "name": "MCPToolPolicy",
            "docstring": "Policy configuration for an MCP tool.\n\nDefines what permissions are required to invoke the tool.",
            "methods": [],
            "line": 138
          },
          {
            "name": "MCPPolicyMapper",
            "docstring": "Maps MCP tool invocations to policy gates.\n\nThis service:\n1. Maintains tool\u2192policy mappings\n2. Evaluates policies before tool invocation\n3. Enforces deny-by-default\n4. Handles dangerous tool restrictions",
            "methods": [
              "__init__",
              "check_tool_invocation",
              "register_tool_policy",
              "_evaluate_policy",
              "_check_explicit_allow",
              "_check_rate_limit",
              "_get_policy_engine"
            ],
            "line": 155
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_models.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_models.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 739,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "PolicyCategory",
            "docstring": "Categories of policies in the M19 Policy Layer.",
            "methods": [],
            "line": 37
          },
          {
            "name": "PolicyDecision",
            "docstring": "Possible decisions from policy evaluation.",
            "methods": [],
            "line": 47
          },
          {
            "name": "ActionType",
            "docstring": "Types of actions that require policy evaluation.",
            "methods": [],
            "line": 55
          },
          {
            "name": "ViolationType",
            "docstring": "Types of policy violations.",
            "methods": [],
            "line": 69
          },
          {
            "name": "ViolationSeverity",
            "docstring": "Enhanced violation severity classifications (GAP 5).",
            "methods": [],
            "line": 81
          },
          {
            "name": "RecoverabilityType",
            "docstring": "Whether a violation is recoverable.",
            "methods": [],
            "line": 102
          },
          {
            "name": "SafetyRuleType",
            "docstring": "Types of safety rules.",
            "methods": [],
            "line": 111
          },
          {
            "name": "EthicalConstraintType",
            "docstring": "Types of ethical constraints.",
            "methods": [],
            "line": 121
          },
          {
            "name": "BusinessRuleType",
            "docstring": "Types of business rules.",
            "methods": [],
            "line": 130
          },
          {
            "name": "PolicyEvaluationRequest",
            "docstring": "Request for policy evaluation.",
            "methods": [],
            "line": 145
          },
          {
            "name": "PolicyModification",
            "docstring": "Modification applied to an action by policy engine.",
            "methods": [],
            "line": 171
          },
          {
            "name": "PolicyEvaluationResult",
            "docstring": "Result of policy evaluation.",
            "methods": [],
            "line": 180
          },
          {
            "name": "PolicyViolation",
            "docstring": "A policy violation record.",
            "methods": [],
            "line": 203
          },
          {
            "name": "PolicyRule",
            "docstring": "A single rule within a policy.",
            "methods": [],
            "line": 231
          },
          {
            "name": "Policy",
            "docstring": "A policy definition.",
            "methods": [],
            "line": 241
          },
          {
            "name": "RiskCeiling",
            "docstring": "A risk ceiling definition.",
            "methods": [],
            "line": 268
          },
          {
            "name": "SafetyRule",
            "docstring": "A safety rule definition.",
            "methods": [],
            "line": 293
          },
          {
            "name": "EthicalConstraint",
            "docstring": "An ethical constraint definition.",
            "methods": [],
            "line": 318
          },
          {
            "name": "BusinessRule",
            "docstring": "A business rule definition.",
            "methods": [],
            "line": 340
          },
          {
            "name": "PolicyState",
            "docstring": "Current state of the policy layer.",
            "methods": [],
            "line": 365
          },
          {
            "name": "PolicyLoadResult",
            "docstring": "Result of loading policies from database.",
            "methods": [],
            "line": 388
          },
          {
            "name": "PolicyVersion",
            "docstring": "A versioned snapshot of a policy set (GAP 1).",
            "methods": [],
            "line": 406
          },
          {
            "name": "PolicyProvenance",
            "docstring": "Audit trail for policy changes (GAP 1).",
            "methods": [],
            "line": 434
          },
          {
            "name": "PolicyDependency",
            "docstring": "Dependency relationship between policies (GAP 2).",
            "methods": [],
            "line": 460
          },
          {
            "name": "PolicyConflict",
            "docstring": "A detected conflict between policies (GAP 2).",
            "methods": [],
            "line": 476
          },
          {
            "name": "DependencyGraph",
            "docstring": "The complete policy dependency graph (GAP 2).",
            "methods": [],
            "line": 498
          },
          {
            "name": "TemporalPolicyType",
            "docstring": "Types of temporal policies.",
            "methods": [],
            "line": 512
          },
          {
            "name": "TemporalPolicy",
            "docstring": "A temporal/sliding window policy (GAP 3).",
            "methods": [],
            "line": 522
          },
          {
            "name": "TemporalMetricWindow",
            "docstring": "A sliding window of metric values (GAP 3).",
            "methods": [],
            "line": 551
          },
          {
            "name": "PolicyContext",
            "docstring": "Complete policy context passed through the decision cycle (GAP 4).\n\nThis object provides the full state needed for policy evaluation,\nenabling multi-agent coordination and trajectory-based decisions.",
            "methods": [],
            "line": 574
          },
          {
            "name": "EnhancedPolicyEvaluationRequest",
            "docstring": "Enhanced evaluation request with full context (GAP 4).",
            "methods": [],
            "line": 634
          },
          {
            "name": "EnhancedPolicyViolation",
            "docstring": "Enhanced violation with severity classification (GAP 5).",
            "methods": [],
            "line": 659
          },
          {
            "name": "EnhancedPolicyEvaluationResult",
            "docstring": "Enhanced evaluation result with full context (GAPs 1-5).",
            "methods": [],
            "line": 696
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 30
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_proposal_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_proposal_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 716,
        "module_docstring": "Policy Proposal Engine (L5)\n\nProposes policy changes based on observed feedback WITHOUT auto-enforcement.\n\nPB-S4 Contract:\n- Observe feedback patterns \u2192 propose policy \u2192 wait for human\n- NO auto-enforcement\n- NO execution modification\n- Human approval is MANDATORY\n\nRule: Propose \u2192 Review \u2192 Decide (Human)\n\nState Machine:\n    DRAFT \u2192 PENDING \u2192 APPROVED/REJECTED\n                \u2193\n            ACTIVE (on activation)",
        "functions": [
          {
            "name": "generate_default_rule",
            "signature": "(policy_type: str, feedback_type: str) -> dict",
            "docstring": "Generate a default rule template based on policy type.\n\nPB-S4: These are SUGGESTIONS only. Human must review.",
            "is_async": false,
            "line": 587
          },
          {
            "name": "get_policy_proposal_engine",
            "signature": "(session: 'AsyncSession') -> PolicyProposalEngine",
            "docstring": "Get a PolicyProposalEngine instance with drivers.",
            "is_async": false,
            "line": 622
          },
          {
            "name": "check_proposal_eligibility",
            "signature": "(session: 'AsyncSession', tenant_id: Optional[UUID] = None, feedback_type: Optional[str] = None, threshold: int = FEEDBACK_THRESHOLD_FOR_PROPOSAL) -> list[dict]",
            "docstring": "Backward-compatible wrapper for eligibility checking.",
            "is_async": true,
            "line": 637
          },
          {
            "name": "create_policy_proposal",
            "signature": "(session: 'AsyncSession', proposal: PolicyProposalCreate) -> str",
            "docstring": "Backward-compatible wrapper for proposal creation.",
            "is_async": true,
            "line": 652
          },
          {
            "name": "review_policy_proposal",
            "signature": "(session: 'AsyncSession', proposal_id: UUID, review: PolicyApprovalRequest, audit: Any = None) -> dict",
            "docstring": "Backward-compatible wrapper for proposal review.",
            "is_async": true,
            "line": 661
          },
          {
            "name": "delete_policy_rule",
            "signature": "(session: 'AsyncSession', rule_id: str, tenant_id: str, deleted_by: str) -> bool",
            "docstring": "Backward-compatible wrapper for rule deletion.",
            "is_async": true,
            "line": 672
          },
          {
            "name": "get_proposal_summary",
            "signature": "(session: 'AsyncSession', tenant_id: Optional[UUID] = None, status: Optional[str] = None, limit: int = 50) -> dict",
            "docstring": "Backward-compatible wrapper for proposal summary.",
            "is_async": true,
            "line": 683
          }
        ],
        "classes": [
          {
            "name": "PolicyActivationBlockedError",
            "docstring": "GOV-POL-001: Raised when policy activation is blocked due to BLOCKING conflicts.\n\nThis exception is CONSTITUTIONAL - it cannot be caught and ignored.\nThe caller must surface the conflict to the human reviewer.",
            "methods": [
              "__init__"
            ],
            "line": 71
          },
          {
            "name": "PolicyDeletionBlockedError",
            "docstring": "GOV-POL-002: Raised when policy deletion is blocked due to dependents.\n\nThis exception is CONSTITUTIONAL - it cannot be caught and ignored.\nThe caller must resolve dependencies before deletion.",
            "methods": [
              "__init__"
            ],
            "line": 84
          },
          {
            "name": "PolicyProposalEngine",
            "docstring": "L5 Domain Engine for policy proposal lifecycle management.\n\nResponsibilities:\n- Eligibility checking (business logic)\n- Proposal creation orchestration\n- State machine transitions (DRAFT \u2192 APPROVED/REJECTED)\n- Conflict detection coordination\n- Approval workflow\n\nDoes NOT own:\n- Direct DB queries (delegated to L6 drivers)\n- HTTP concerns (that's L2/L3)",
            "methods": [
              "__init__",
              "check_proposal_eligibility",
              "create_proposal",
              "review_proposal",
              "_create_policy_rule_from_proposal",
              "delete_policy_rule",
              "get_proposal_summary"
            ],
            "line": 110
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_proposal_read_driver",
            "names": [
              "PolicyProposalReadDriver",
              "get_policy_proposal_read_driver"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_proposal_write_driver",
            "names": [
              "PolicyProposalWriteDriver",
              "get_policy_proposal_write_driver"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.domain_enums",
            "names": [
              "ActorType"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.policy_graph",
            "names": [
              "ConflictSeverity",
              "get_conflict_engine",
              "get_dependency_engine"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [
          {
            "name": "FEEDBACK_THRESHOLD_FOR_PROPOSAL",
            "line": 98
          },
          {
            "name": "PROPOSAL_TYPES",
            "line": 99
          }
        ],
        "all_exports": [
          "PolicyProposalEngine",
          "get_policy_proposal_engine",
          "PolicyActivationBlockedError",
          "PolicyDeletionBlockedError",
          "FEEDBACK_THRESHOLD_FOR_PROPOSAL",
          "PROPOSAL_TYPES",
          "generate_default_rule",
          "check_proposal_eligibility",
          "create_policy_proposal",
          "review_policy_proposal",
          "delete_policy_rule",
          "get_proposal_summary"
        ]
      },
      {
        "file_name": "policy_rules_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_rules_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 397,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "PolicyRulesServiceError",
            "docstring": "Base exception for policy rules service.",
            "methods": [],
            "line": 79
          },
          {
            "name": "RuleNotFoundError",
            "docstring": "Raised when rule is not found.",
            "methods": [],
            "line": 84
          },
          {
            "name": "RuleValidationError",
            "docstring": "Raised when rule validation fails.",
            "methods": [],
            "line": 89
          },
          {
            "name": "PolicyRulesService",
            "docstring": "Service for policy rule CRUD operations.\n\nINVARIANTS:\n- Rules are tenant-scoped\n- Rules are never deleted, only retired\n- Every active rule MUST have an integrity record\n- Retirement creates audit trail",
            "methods": [
              "__init__",
              "create",
              "update",
              "get",
              "_get_rule",
              "_validate_conditions",
              "_compute_hash",
              "_to_response"
            ],
            "line": 94
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.hoc_spine.drivers.cross_domain",
            "names": [
              "generate_uuid"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_rules_driver",
            "names": [
              "PolicyRulesDriver",
              "get_policy_rules_driver"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.domain_enums",
            "names": [
              "ActorType"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.hoc.cus.policies.L5_schemas.policy_rules",
            "names": [
              "CreatePolicyRuleRequest",
              "UpdatePolicyRuleRequest",
              "PolicyRuleResponse"
            ],
            "is_relative": false,
            "line": 72
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "prevention_hook.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/prevention_hook.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 302,
        "module_docstring": null,
        "functions": [
          {
            "name": "create_prevention_hook",
            "signature": "(strict_mode: bool = True, block_on_fail: bool = True) -> PreventionHook",
            "docstring": "Factory function to create a prevention hook.",
            "is_async": false,
            "line": 240
          },
          {
            "name": "get_prevention_hook",
            "signature": "() -> PreventionHook",
            "docstring": "Get the global prevention hook instance.",
            "is_async": false,
            "line": 255
          },
          {
            "name": "evaluate_response",
            "signature": "(tenant_id: str, call_id: str, user_query: str, context_data: Dict[str, Any], llm_output: str, model: str = 'unknown', user_id: Optional[str] = None) -> PreventionResult",
            "docstring": "Convenience function to evaluate an LLM response.\n\nUsage:\n    result = evaluate_response(\n        tenant_id=\"tenant_123\",\n        call_id=\"call_abc\",\n        user_query=\"Is my contract auto-renewed?\",\n        context_data={\"auto_renew\": None},\n        llm_output=\"Yes, your contract is set to auto-renew...\",\n    )\n\n    if result.action != PreventionAction.ALLOW:\n        # Handle blocked/modified response\n        pass",
            "is_async": false,
            "line": 263
          }
        ],
        "classes": [
          {
            "name": "PreventionAction",
            "docstring": "Action to take when prevention hook triggers.",
            "methods": [],
            "line": 43
          },
          {
            "name": "PreventionContext",
            "docstring": "Context for prevention hook evaluation.",
            "methods": [
              "__post_init__"
            ],
            "line": 54
          },
          {
            "name": "PreventionResult",
            "docstring": "Result of prevention hook evaluation.",
            "methods": [
              "__post_init__",
              "to_dict"
            ],
            "line": 82
          },
          {
            "name": "PreventionHook",
            "docstring": "Prevention hook for pre-response validation.\n\nUsage:\n    hook = PreventionHook(strict_mode=True)\n\n    # Before sending response to client\n    result = hook.evaluate(PreventionContext(\n        tenant_id=\"tenant_123\",\n        call_id=\"call_abc\",\n        user_id=\"cust_8372\",\n        model=\"gpt-4.1\",\n        user_query=\"Is my contract auto-renewed?\",\n        system_prompt=\"You are a helpful assistant.\",\n        context_data={\"auto_renew\": None, \"contract_status\": \"active\"},\n        llm_output=\"Yes, your contract is set to auto-renew...\",\n        output_tokens=18,\n    ))\n\n    if result.action == PreventionAction.BLOCK:\n        # Don't send response, return error or safe message\n        pass\n    elif result.action == PreventionAction.MODIFY:\n        # Send modified response\n        pass",
            "methods": [
              "__init__",
              "evaluate",
              "get_safe_response"
            ],
            "line": 117
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.content_accuracy",
            "names": [
              "ContentAccuracyValidator",
              "ValidationResult"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "protection_provider.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/protection_provider.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 388,
        "module_docstring": "Phase-7 Abuse Protection Provider \u2014 Interface and Mock Implementation\n\nPIN-399 Phase-7: Mock provider must be behavior-compatible with real provider.\n\nDESIGN INVARIANTS (LOCKED):\n- ABUSE-004: Protection providers are swappable behind a fixed interface\n- ABUSE-005: Mock provider must be behavior-compatible with real provider\n\nIMPLEMENTATION CONSTRAINTS:\n- Deterministic thresholds\n- Static configs\n- No external calls\n- No ML\n\nORDERING RULE (Critical):\n    Checks execute in this order:\n    1. Rate limit\n    2. Burst control\n    3. Cost guard\n    4. Anomaly detection\n\n    First REJECT stops evaluation.\n    This order is LOCKED to preserve predictability.",
        "functions": [
          {
            "name": "get_protection_provider",
            "signature": "() -> AbuseProtectionProvider",
            "docstring": "Get the abuse protection provider instance.\n\nReturns MockAbuseProtectionProvider by default.\nCan be replaced for testing or production.",
            "is_async": false,
            "line": 360
          },
          {
            "name": "set_protection_provider",
            "signature": "(provider: AbuseProtectionProvider) -> None",
            "docstring": "Set the abuse protection provider instance.\n\nUsed for testing or to swap in a real provider.",
            "is_async": false,
            "line": 373
          }
        ],
        "classes": [
          {
            "name": "AbuseProtectionProvider",
            "docstring": "Phase-7 Abuse Protection Provider Protocol.\n\nAll protection providers (mock and real) must implement this interface.\n\nThis protocol is LOCKED per ABUSE-004.",
            "methods": [
              "check_rate_limit",
              "check_burst",
              "check_cost",
              "detect_anomaly",
              "check_all"
            ],
            "line": 63
          },
          {
            "name": "MockAbuseProtectionProvider",
            "docstring": "Phase-7 Mock Abuse Protection Provider.\n\nImplements AbuseProtectionProvider protocol with deterministic behavior.\n\nIMPLEMENTATION CONSTRAINTS:\n- Deterministic thresholds\n- Static configs\n- No external calls\n- No ML\n- No adaptive behavior\n\nPROTECTION DIMENSIONS:\n- Rate limits: 1000 req/min default\n- Burst control: 100 req/sec default\n- Cost guards: Read from billing limits\n- Anomaly detection: 10x jump threshold",
            "methods": [
              "__init__",
              "check_rate_limit",
              "check_burst",
              "check_cost",
              "detect_anomaly",
              "check_all",
              "add_cost",
              "reset",
              "reset_rate_limits"
            ],
            "line": 148
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Protocol",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.protection.decisions",
            "names": [
              "Decision",
              "ProtectionResult",
              "AnomalySignal",
              "allow",
              "reject_rate_limit",
              "reject_cost_limit",
              "throttle"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.billing",
            "names": [
              "get_billing_provider",
              "Limits"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": [
          "AbuseProtectionProvider",
          "MockAbuseProtectionProvider",
          "get_protection_provider",
          "set_protection_provider"
        ]
      },
      {
        "file_name": "recovery_evaluation_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/recovery_evaluation_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 415,
        "module_docstring": "Domain engine for recovery evaluation decisions.\n\nThis L4 engine contains the authoritative decision logic for:\n1. Rule evaluation - evaluate_rules()\n2. Pattern matching - RecoveryMatcher\n3. Confidence combination - combine_confidences()\n4. Action selection threshold - should_select_action()\n5. Auto-execution threshold - should_auto_execute()\n6. Decision record emission - emit_recovery_decision()\n\nL5 workers must call this engine and execute the returned decisions,\nnot implement their own decision logic.\n\nReference: PIN-257 Phase R-1\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md",
        "functions": [
          {
            "name": "evaluate_recovery",
            "signature": "(failure_match_id: str, error_code: str, error_message: str, **kwargs) -> RecoveryDecision",
            "docstring": "Convenience function to evaluate a failure and get a decision.\n\nThis is the L4 entry point for recovery evaluation. It returns\na RecoveryDecision that L5 must execute.\n\nArgs:\n    failure_match_id: ID of the failure match record\n    error_code: Error code\n    error_message: Error message\n    **kwargs: Additional context fields\n\nReturns:\n    RecoveryDecision with all domain decisions\n\nReference: PIN-257 Phase R-1",
            "is_async": false,
            "line": 291
          },
          {
            "name": "evaluate_and_execute",
            "signature": "(failure_match_id: str, error_code: str, error_message: str, **kwargs) -> 'EvaluationOutcome'",
            "docstring": "Full entry point: evaluate failure and execute decision.\n\nThis L4 function:\n1. Creates FailureContext from input\n2. Evaluates using RecoveryEvaluationEngine (L4 domain decisions)\n3. Calls L5 RecoveryExecutor to execute the decision\n4. Emits decision record (L4 responsibility)\n5. Returns EvaluationOutcome\n\nThis replaces the old evaluate_failure() in L5 recovery_evaluator.py.\n\nArgs:\n    failure_match_id: ID of the failure match record\n    error_code: Error code\n    error_message: Error message\n    **kwargs: Additional context fields\n\nReturns:\n    EvaluationOutcome with execution result\n\nReference: PIN-257 Phase R-1 (L5\u2192L4 Violation Fix)",
            "is_async": true,
            "line": 329
          }
        ],
        "classes": [
          {
            "name": "FailureContext",
            "docstring": "Context for recovery evaluation (mirrors L5 FailureEvent for L4 use).",
            "methods": [
              "__post_init__"
            ],
            "line": 73
          },
          {
            "name": "RecoveryDecision",
            "docstring": "Domain decision DTO returned by L4 engine to L5 executor.\n\nThis dataclass contains all decisions made by L4 domain logic.\nL5 must execute based on these decisions without reimplementing logic.\n\nReference: PIN-257 Phase R-1",
            "methods": [
              "to_dict"
            ],
            "line": 94
          },
          {
            "name": "RecoveryEvaluationEngine",
            "docstring": "L4 Domain Engine for recovery evaluation decisions.\n\nThis engine contains ALL domain decision logic that was previously\nscattered in L5 recovery_evaluator.py. It evaluates failure context\nand returns a RecoveryDecision DTO that L5 must execute.\n\nL5 may NOT:\n- Re-implement rule evaluation\n- Re-calculate confidence scores\n- Make action selection decisions\n- Make auto-execution decisions\n- Emit decision records\n\nL5 may ONLY:\n- Execute the decision returned by this engine\n- Perform DB operations (L6)\n- Trigger execution hooks\n\nReference: PIN-257 Phase R-1\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md Section 3.4",
            "methods": [
              "__init__",
              "evaluate",
              "emit_decision_record"
            ],
            "line": 140
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.contracts.decisions",
            "names": [
              "emit_recovery_decision"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.recovery_matcher",
            "names": [
              "RecoveryMatcher"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.hoc_spine.utilities.recovery_decisions",
            "names": [
              "combine_confidences",
              "should_auto_execute",
              "should_select_action"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.cross_domain_gateway",
            "names": [
              "evaluate_rules"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [],
        "all_exports": [
          "FailureContext",
          "RecoveryDecision",
          "RecoveryEvaluationEngine",
          "evaluate_recovery",
          "evaluate_and_execute"
        ]
      },
      {
        "file_name": "runtime_command.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/runtime_command.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 561,
        "module_docstring": "Runtime Domain Commands (L4)\n\nDomain engine for runtime-related decisions. Provides authoritative answers for:\n1. Skill descriptions - what skills exist and their metadata\n2. Runtime queries - budget, history, capability information\n3. Resource contracts - budget, rate limits, constraints\n\nThis is an L4 domain engine. It makes decisions based on domain facts.\nIt does NOT execute skills. Execution is L5's responsibility.\n\nReference: PIN-258 Phase F-3 Runtime Cluster",
        "functions": [
          {
            "name": "get_supported_query_types",
            "signature": "() -> List[str]",
            "docstring": "Get list of supported query types.\n\nThis is an L4 domain decision - defining what queries the system supports.\n\nReturns:\n    List of supported query type strings",
            "is_async": false,
            "line": 230
          },
          {
            "name": "query_remaining_budget",
            "signature": "(spent_cents: int = 0, total_cents: int = DEFAULT_BUDGET_CENTS) -> QueryResult",
            "docstring": "Query remaining budget.\n\nL4 domain decision: How to calculate and present budget information.\n\nArgs:\n    spent_cents: Amount already spent\n    total_cents: Total budget available\n\nReturns:\n    QueryResult with budget information",
            "is_async": false,
            "line": 242
          },
          {
            "name": "query_execution_history",
            "signature": "(history: Optional[List[Dict[str, Any]]] = None) -> QueryResult",
            "docstring": "Query execution history.\n\nL4 domain decision: How to present execution history.\n\nArgs:\n    history: Execution history records\n\nReturns:\n    QueryResult with history",
            "is_async": false,
            "line": 268
          },
          {
            "name": "query_allowed_skills",
            "signature": "() -> QueryResult",
            "docstring": "Query list of allowed skills.\n\nL4 domain decision: What skills are available.\n\nReturns:\n    QueryResult with skill list",
            "is_async": false,
            "line": 286
          },
          {
            "name": "query_last_step_outcome",
            "signature": "(outcome: Optional[Dict[str, Any]] = None) -> QueryResult",
            "docstring": "Query last step outcome.\n\nL4 domain decision: How to present last outcome.\n\nArgs:\n    outcome: Last execution outcome\n\nReturns:\n    QueryResult with outcome",
            "is_async": false,
            "line": 305
          },
          {
            "name": "query_skills_for_goal",
            "signature": "(goal: str) -> QueryResult",
            "docstring": "Query skills available for a goal.\n\nL4 domain decision: Deterministic skill matching based on goal.\n\nArgs:\n    goal: Goal description\n\nReturns:\n    QueryResult with matched skills",
            "is_async": false,
            "line": 323
          },
          {
            "name": "execute_query",
            "signature": "(query_type: str, params: Optional[Dict[str, Any]] = None) -> QueryResult",
            "docstring": "Execute a runtime query.\n\nL4 domain command: Routes query to appropriate handler.\n\nArgs:\n    query_type: Type of query\n    params: Query parameters\n\nReturns:\n    QueryResult with query response",
            "is_async": false,
            "line": 350
          },
          {
            "name": "get_skill_info",
            "signature": "(skill_id: str) -> Optional[SkillInfo]",
            "docstring": "Get domain information about a skill.\n\nL4 domain decision: Skill metadata and capabilities.\n\nArgs:\n    skill_id: Skill identifier\n\nReturns:\n    SkillInfo if skill exists, None otherwise",
            "is_async": false,
            "line": 391
          },
          {
            "name": "list_skills",
            "signature": "() -> List[str]",
            "docstring": "List all available skill IDs.\n\nL4 domain decision: What skills are known to the system.\n\nReturns:\n    List of skill IDs",
            "is_async": false,
            "line": 420
          },
          {
            "name": "get_all_skill_descriptors",
            "signature": "() -> Dict[str, Dict[str, Any]]",
            "docstring": "Get descriptors for all skills.\n\nL4 domain decision: Comprehensive skill information.\n\nReturns:\n    Dict mapping skill_id to descriptor dict",
            "is_async": false,
            "line": 432
          },
          {
            "name": "get_resource_contract",
            "signature": "(resource_id: str) -> ResourceContractInfo",
            "docstring": "Get resource contract information.\n\nL4 domain decision: Default resource constraints.\n\nArgs:\n    resource_id: Resource identifier\n\nReturns:\n    ResourceContractInfo with contract details",
            "is_async": false,
            "line": 460
          },
          {
            "name": "get_capabilities",
            "signature": "(agent_id: Optional[str] = None, tenant_id: Optional[str] = None) -> CapabilitiesInfo",
            "docstring": "Get capabilities for an agent/tenant.\n\nL4 domain decision: What capabilities are available.\n\nArgs:\n    agent_id: Optional agent ID\n    tenant_id: Optional tenant ID\n\nReturns:\n    CapabilitiesInfo with capability details",
            "is_async": false,
            "line": 485
          }
        ],
        "classes": [
          {
            "name": "QueryResult",
            "docstring": "Result from a runtime query command.",
            "methods": [],
            "line": 72
          },
          {
            "name": "SkillInfo",
            "docstring": "Domain information about a skill.",
            "methods": [],
            "line": 81
          },
          {
            "name": "ResourceContractInfo",
            "docstring": "Domain information about a resource contract.",
            "methods": [],
            "line": 98
          },
          {
            "name": "CapabilitiesInfo",
            "docstring": "Domain information about available capabilities.",
            "methods": [],
            "line": 108
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "DEFAULT_BUDGET_CENTS",
          "DEFAULT_RATE_LIMIT_PER_MINUTE",
          "DEFAULT_MAX_CONCURRENT",
          "SUPPORTED_QUERY_TYPES",
          "DEFAULT_SKILL_METADATA",
          "QueryResult",
          "SkillInfo",
          "ResourceContractInfo",
          "CapabilitiesInfo",
          "get_supported_query_types",
          "query_remaining_budget",
          "query_execution_history",
          "query_allowed_skills",
          "query_last_step_outcome",
          "query_skills_for_goal",
          "execute_query",
          "get_skill_info",
          "list_skills",
          "get_all_skill_descriptors",
          "get_resource_contract",
          "get_capabilities"
        ]
      },
      {
        "file_name": "sandbox_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/sandbox_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 562,
        "module_docstring": "Sandbox Service (GAP-174)\n\nHigh-level service for managing sandbox execution:\n- Policy-based isolation level selection\n- Execution quota management\n- Audit logging\n- Result caching",
        "functions": [
          {
            "name": "get_sandbox_service",
            "signature": "() -> 'SandboxService'",
            "docstring": "Return the process-wide SandboxService singleton (GAP-174).",
            "is_async": false,
            "line": 557
          }
        ],
        "classes": [
          {
            "name": "SandboxPolicy",
            "docstring": "Policy for sandbox execution.",
            "methods": [
              "to_resource_limits",
              "to_dict"
            ],
            "line": 51
          },
          {
            "name": "ExecutionRequest",
            "docstring": "Request to execute code in a sandbox.",
            "methods": [],
            "line": 113
          },
          {
            "name": "ExecutionRecord",
            "docstring": "Record of a sandbox execution for audit.",
            "methods": [
              "to_dict"
            ],
            "line": 134
          },
          {
            "name": "SandboxService",
            "docstring": "High-level sandbox service.\n\nFeatures:\n- Policy-based execution management\n- Quota enforcement\n- Audit logging\n- Multiple executor support",
            "methods": [
              "__init__",
              "_setup_default_policies",
              "_get_executor",
              "execute",
              "_get_policy",
              "_check_quota",
              "_track_execution",
              "define_policy",
              "get_policy",
              "list_policies",
              "get_execution_records",
              "get_execution_stats"
            ],
            "line": 180
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "sandbox_executor",
            "names": [
              "ExecutionResult",
              "IsolationLevel",
              "NetworkPolicy",
              "ResourceLimits",
              "SandboxExecutor",
              "SandboxStatus",
              "create_sandbox_executor"
            ],
            "is_relative": true,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "sandbox_executor.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/sandbox_executor.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 683,
        "module_docstring": "Sandbox Executor (GAP-174)\n\nProvides low-level execution isolation:\n- Process-based execution with resource limits\n- Container-based execution (Docker/Podman)\n- Network namespace isolation\n- Filesystem sandboxing",
        "functions": [
          {
            "name": "create_sandbox_executor",
            "signature": "(isolation_level: IsolationLevel = IsolationLevel.PROCESS, **kwargs) -> SandboxExecutor",
            "docstring": "Create a sandbox executor with the specified isolation level.\n\nArgs:\n    isolation_level: Level of isolation required\n    **kwargs: Additional arguments for the executor\n\nReturns:\n    SandboxExecutor instance",
            "is_async": false,
            "line": 661
          }
        ],
        "classes": [
          {
            "name": "IsolationLevel",
            "docstring": "Level of isolation for sandbox execution.",
            "methods": [],
            "line": 39
          },
          {
            "name": "SandboxStatus",
            "docstring": "Status of a sandbox execution.",
            "methods": [],
            "line": 48
          },
          {
            "name": "NetworkPolicy",
            "docstring": "Network access policy for sandboxes.",
            "methods": [],
            "line": 59
          },
          {
            "name": "ResourceLimits",
            "docstring": "Resource limits for sandbox execution.",
            "methods": [
              "to_dict"
            ],
            "line": 69
          },
          {
            "name": "ExecutionResult",
            "docstring": "Result of a sandbox execution.",
            "methods": [
              "to_dict"
            ],
            "line": 113
          },
          {
            "name": "SandboxExecutor",
            "docstring": "Abstract base class for sandbox executors.",
            "methods": [
              "execute",
              "cleanup",
              "isolation_level"
            ],
            "line": 155
          },
          {
            "name": "ProcessSandboxExecutor",
            "docstring": "Process-based sandbox executor.\n\nUses subprocess with resource limits (rlimit) for isolation.\nSuitable for moderate security requirements.",
            "methods": [
              "__init__",
              "isolation_level",
              "execute",
              "_write_code_file",
              "_get_interpreter_command",
              "_run_with_limits",
              "cleanup"
            ],
            "line": 194
          },
          {
            "name": "ContainerSandboxExecutor",
            "docstring": "Container-based sandbox executor.\n\nUses Docker or Podman for stronger isolation.\nSuitable for high security requirements.",
            "methods": [
              "__init__",
              "isolation_level",
              "execute",
              "_write_code_file",
              "_get_image_for_language",
              "_build_container_command",
              "_run_container",
              "_kill_container",
              "cleanup"
            ],
            "line": 407
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "resource",
            "names": [
              "resource"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "shutil",
            "names": [
              "shutil"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "tempfile",
            "names": [
              "tempfile"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "snapshot_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/snapshot_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 594,
        "module_docstring": "Policy Snapshot Immutability Engine (GAP-029).\n\nProvides immutable policy snapshot management with:\n- Immutability enforcement (no modifications after creation)\n- Snapshot versioning and history\n- Integrity verification\n- Tenant isolation",
        "functions": [
          {
            "name": "get_snapshot_registry",
            "signature": "() -> PolicySnapshotRegistry",
            "docstring": "Get the singleton registry instance.",
            "is_async": false,
            "line": 535
          },
          {
            "name": "_reset_snapshot_registry",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 543
          },
          {
            "name": "create_policy_snapshot",
            "signature": "(tenant_id: str, policies: list[dict[str, Any]], thresholds: dict[str, Any], policy_version: Optional[str] = None, description: Optional[str] = None) -> PolicySnapshotData",
            "docstring": "Create a new immutable policy snapshot.",
            "is_async": false,
            "line": 552
          },
          {
            "name": "get_policy_snapshot",
            "signature": "(snapshot_id: str) -> Optional[PolicySnapshotData]",
            "docstring": "Get a policy snapshot by ID.",
            "is_async": false,
            "line": 570
          },
          {
            "name": "get_active_snapshot",
            "signature": "(tenant_id: str) -> Optional[PolicySnapshotData]",
            "docstring": "Get the active policy snapshot for a tenant.",
            "is_async": false,
            "line": 576
          },
          {
            "name": "get_snapshot_history",
            "signature": "(tenant_id: str, limit: int = 100) -> List[PolicySnapshotData]",
            "docstring": "Get snapshot version history for a tenant.",
            "is_async": false,
            "line": 582
          },
          {
            "name": "verify_snapshot",
            "signature": "(snapshot_id: str) -> dict[str, Any]",
            "docstring": "Verify snapshot integrity.",
            "is_async": false,
            "line": 591
          }
        ],
        "classes": [
          {
            "name": "SnapshotStatus",
            "docstring": "Status of a policy snapshot.",
            "methods": [],
            "line": 39
          },
          {
            "name": "ImmutabilityViolation",
            "docstring": "Types of immutability violations.",
            "methods": [],
            "line": 48
          },
          {
            "name": "PolicySnapshotData",
            "docstring": "Immutable policy snapshot data.\n\nOnce created, the content cannot be modified.\nOnly status can transition through allowed paths.",
            "methods": [
              "compute_hash",
              "verify_integrity",
              "verify_threshold_integrity",
              "get_policies",
              "get_thresholds",
              "to_dict"
            ],
            "line": 59
          },
          {
            "name": "PolicySnapshotError",
            "docstring": "Exception for policy snapshot errors.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 139
          },
          {
            "name": "SnapshotRegistryStats",
            "docstring": "Statistics for snapshot registry.",
            "methods": [
              "to_dict"
            ],
            "line": 165
          },
          {
            "name": "PolicySnapshotRegistry",
            "docstring": "Registry for managing immutable policy snapshots.\n\nFeatures:\n- Immutability enforcement (no content modifications)\n- Version tracking per tenant\n- Automatic supersession of old snapshots\n- Integrity verification\n- Tenant isolation",
            "methods": [
              "__init__",
              "create",
              "get",
              "get_active",
              "get_by_version",
              "list",
              "get_history",
              "archive",
              "verify",
              "attempt_modify",
              "delete",
              "get_statistics",
              "clear_tenant",
              "reset",
              "_get_next_version",
              "_supersede_active"
            ],
            "line": 193
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "state.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/state.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 108,
        "module_docstring": "Phase-6 Billing State \u2014 Commercial State Model\n\nPIN-399 Phase-6: Billing never blocks onboarding.\n\nDESIGN INVARIANTS (LOCKED):\n- BILLING-001: Billing never blocks onboarding\n- BILLING-002: Limits are derived, not stored\n- BILLING-003: Billing state does not affect roles\n- BILLING-004: No billing mutation without audit\n- BILLING-005: Mock provider must satisfy same interface as real provider\n\nAPPLICABILITY GATE:\n    Billing logic is evaluated ONLY IF tenant.onboarding_state == COMPLETE.\n    Before COMPLETE:\n    - Billing APIs return neutral placeholders\n    - Limits are not enforced\n    - Usage is tracked but not blocked\n\nThis enum is the single source of truth for billing states.",
        "functions": [],
        "classes": [
          {
            "name": "BillingState",
            "docstring": "Phase-6 Billing States (Tenant-scoped).\n\nStates represent the commercial standing of a tenant.\nNOT tied to any specific payment gateway.\n\nSEMANTICS (LOCKED):\n- TRIAL: Default after onboarding COMPLETE\n- ACTIVE: Valid paid plan\n- PAST_DUE: Payment issue, grace period active\n- SUSPENDED: Usage blocked, data intact\n\nNo other states allowed in v1.",
            "methods": [
              "from_string",
              "default",
              "allows_usage",
              "is_in_good_standing"
            ],
            "line": 45
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "BillingState"
        ]
      },
      {
        "file_name": "tokenizer.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/tokenizer.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 352,
        "module_docstring": "Tokenizer for PLang v2.0 with M19 category support.\n\nToken types include:\n- Keywords: policy, rule, when, then, deny, allow, etc.\n- Categories: SAFETY, PRIVACY, OPERATIONAL, ROUTING, CUSTOM\n- Identifiers: user-defined names\n- Literals: numbers, strings, booleans\n- Operators: ==, !=, <, >, etc.\n- Delimiters: {, }, (, ), :, ,",
        "functions": [],
        "classes": [
          {
            "name": "TokenType",
            "docstring": "Token types for PLang v2.0.",
            "methods": [],
            "line": 39
          },
          {
            "name": "Token",
            "docstring": "A token in PLang source code.",
            "methods": [
              "__repr__",
              "is_category",
              "is_action"
            ],
            "line": 123
          },
          {
            "name": "TokenizerError",
            "docstring": "Error during tokenization.",
            "methods": [
              "__init__"
            ],
            "line": 151
          },
          {
            "name": "Tokenizer",
            "docstring": "Tokenizer for PLang v2.0.\n\nConverts source code into a stream of tokens for parsing.\nSupports M19 governance categories and policy-specific syntax.",
            "methods": [
              "__init__",
              "current_char",
              "peek",
              "advance",
              "skip_whitespace",
              "skip_comment",
              "read_string",
              "read_number",
              "read_identifier",
              "read_operator",
              "tokenize",
              "__iter__"
            ],
            "line": 161
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Iterator",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [
          {
            "name": "KEYWORD_TOKENS",
            "line": 96
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "validator.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/validator.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 386,
        "module_docstring": "Policy DSL Semantic Validator\n\nValidates AST against semantic rules. Does NOT parse.\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- Pure validation logic\n- No side effects\n- No I/O, no DB\n- Must produce validation result (errors/warnings), not exceptions\n\nSEMANTIC RULES:\n1. Mode Enforcement:\n   - MONITOR mode: Only WARN actions allowed\n   - ENFORCE mode: WARN, BLOCK, REQUIRE_APPROVAL allowed\n\n2. Metric Validation (optional):\n   - If metric registry provided, validate metrics exist\n\n3. Version Validation:\n   - Version must be >= 1\n\n4. Structural Validation:\n   - At least one clause\n   - At least one action per clause\n\nGOVERNANCE:\n- Validator is the authority on policy correctness\n- All enforcement decisions derive from validator",
        "functions": [
          {
            "name": "validate",
            "signature": "(policy: PolicyAST, allowed_metrics: set[str] | None = None) -> ValidationResult",
            "docstring": "Validate a policy AST.\n\nArgs:\n    policy: The PolicyAST to validate\n    allowed_metrics: If provided, validate metrics against this set\n\nReturns:\n    ValidationResult with all issues found\n\nExample:\n    >>> from app.dsl import parse\n    >>> ast = parse('''\n    ... policy Test\n    ... version 1\n    ... scope ORG\n    ... mode MONITOR\n    ...\n    ... when x > 0\n    ... then BLOCK\n    ... ''')\n    >>> result = validate(ast)\n    >>> result.is_valid\n    False\n    >>> result.errors[0].code\n    'V001'",
            "is_async": false,
            "line": 336
          },
          {
            "name": "is_valid",
            "signature": "(policy: PolicyAST, allowed_metrics: set[str] | None = None) -> bool",
            "docstring": "Quick check if a policy is valid.\n\nArgs:\n    policy: The PolicyAST to validate\n    allowed_metrics: If provided, validate metrics against this set\n\nReturns:\n    True if valid, False otherwise",
            "is_async": false,
            "line": 371
          }
        ],
        "classes": [
          {
            "name": "Severity",
            "docstring": "Severity level for validation issues.",
            "methods": [],
            "line": 73
          },
          {
            "name": "ValidationIssue",
            "docstring": "A single validation issue found in the policy.",
            "methods": [
              "__str__"
            ],
            "line": 81
          },
          {
            "name": "ValidationResult",
            "docstring": "Result of policy validation.",
            "methods": [
              "__post_init__",
              "errors",
              "warnings",
              "__bool__"
            ],
            "line": 95
          },
          {
            "name": "PolicyValidator",
            "docstring": "Validates PolicyAST against semantic rules.\n\nUsage:\n    validator = PolicyValidator()\n    result = validator.validate(ast)\n    if not result.is_valid:\n        for error in result.errors:\n            print(error)",
            "methods": [
              "__init__",
              "validate",
              "_validate_mode_enforcement",
              "_validate_metrics",
              "_extract_metrics",
              "_validate_structure",
              "_check_warnings"
            ],
            "line": 146
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Callable"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.dsl.ast",
            "names": [
              "Condition",
              "Mode",
              "PolicyAST",
              "is_block_action",
              "is_exists_predicate",
              "is_logical_condition",
              "is_predicate",
              "is_require_approval_action"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [
          {
            "name": "V001",
            "line": 126
          },
          {
            "name": "V002",
            "line": 127
          },
          {
            "name": "V010",
            "line": 130
          },
          {
            "name": "V020",
            "line": 133
          },
          {
            "name": "V021",
            "line": 134
          },
          {
            "name": "W001",
            "line": 137
          },
          {
            "name": "W002",
            "line": 138
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "visitors.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/visitors.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 307,
        "module_docstring": "AST visitors for PLang v2.0.\n\nVisitors for:\n- Pretty printing\n- Category collection\n- Rule extraction\n- Governance analysis",
        "functions": [],
        "classes": [
          {
            "name": "BaseVisitor",
            "docstring": "Base visitor with default implementations.",
            "methods": [
              "visit_program",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_import",
              "visit_rule_ref",
              "visit_priority",
              "visit_condition_block",
              "visit_action_block",
              "visit_route_target",
              "visit_binary_op",
              "visit_unary_op",
              "visit_ident",
              "visit_literal",
              "visit_func_call",
              "visit_attr_access"
            ],
            "line": 54
          },
          {
            "name": "PrintVisitor",
            "docstring": "Visitor that prints AST in readable format.",
            "methods": [
              "__init__",
              "_emit",
              "get_output",
              "visit_program",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_import",
              "visit_rule_ref",
              "visit_priority",
              "visit_condition_block",
              "visit_action_block",
              "visit_route_target",
              "visit_binary_op",
              "visit_unary_op",
              "visit_ident",
              "visit_literal",
              "visit_func_call",
              "visit_attr_access"
            ],
            "line": 118
          },
          {
            "name": "CategoryCollector",
            "docstring": "Visitor that collects all categories used in the AST.\n\nUsed for governance analysis and category-based routing.",
            "methods": [
              "__init__",
              "get_categories",
              "visit_policy_decl",
              "visit_rule_decl"
            ],
            "line": 222
          },
          {
            "name": "RuleExtractor",
            "docstring": "Visitor that extracts all rules with their governance metadata.\n\nUsed for building the symbol table and IR.",
            "methods": [
              "__init__",
              "get_rules",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_condition_block"
            ],
            "line": 250
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.policy.ast.nodes",
            "names": [
              "ActionBlockNode",
              "ASTVisitor",
              "AttrAccessNode",
              "BinaryOpNode",
              "ConditionBlockNode",
              "FuncCallNode",
              "IdentNode",
              "ImportNode",
              "LiteralNode",
              "PolicyDeclNode",
              "PriorityNode",
              "ProgramNode",
              "RouteTargetNode",
              "RuleDeclNode",
              "RuleRefNode",
              "UnaryOpNode"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "worker_execution_command.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/worker_execution_command.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 355,
        "module_docstring": "Worker Execution Command (L4)\n\nDomain command for Business Builder Worker execution. This L4 command:\n1. Takes domain facts (task, brand, budget, etc.)\n2. Provides authorization for execution\n3. Delegates to L5 workers (since L4 \u2192 L5 is allowed)\n4. Returns results\n\nThis is NOT an execution layer. It authorizes and delegates.\nAll execution logic remains in L5 workers.\n\nReference: PIN-258 Phase F-3 Workers Cluster",
        "functions": [
          {
            "name": "calculate_cost_cents",
            "signature": "(model: str, input_tokens: int, output_tokens: int) -> int",
            "docstring": "Calculate LLM cost in cents.\n\nThis L4 command delegates to L5 cost calculation.\nL4 \u2192 L5 is an allowed import per layer rules.\n\nArgs:\n    model: Model name\n    input_tokens: Number of input tokens\n    output_tokens: Number of output tokens\n\nReturns:\n    Cost in cents\n\nReference: PIN-258 Phase F-3 (F-W-RULE-1: No semantic changes)",
            "is_async": false,
            "line": 92
          },
          {
            "name": "get_brand_schema_types",
            "signature": "()",
            "docstring": "Get brand schema types from L5.\n\nL4 \u2192 L5 is an allowed import per layer rules.\nReturns the schema types needed for brand conversion.\n\nReference: PIN-258 Phase F-3 (F-W-RULE-1: No semantic changes)",
            "is_async": false,
            "line": 120
          },
          {
            "name": "convert_brand_request",
            "signature": "(brand_req) -> Any",
            "docstring": "Convert API brand request to BrandSchema.\n\nThis L4 command handles the conversion logic using L5 schemas.\nL4 \u2192 L5 is an allowed import per layer rules.\n\nArgs:\n    brand_req: Brand request from API\n\nReturns:\n    BrandSchema instance\n\nReference: PIN-258 Phase F-3 (F-W-RULE-1: No semantic changes)",
            "is_async": false,
            "line": 148
          },
          {
            "name": "execute_worker",
            "signature": "(task: str, brand: Optional[Any] = None, budget: Optional[int] = None, strict_mode: bool = False, depth: int = 2, run_id: Optional[str] = None, event_bus: Optional[Any] = None) -> WorkerExecutionResult",
            "docstring": "Execute Business Builder Worker.\n\nThis L4 command authorizes and delegates execution to L5.\nL4 \u2192 L5 is an allowed import per layer rules.\n\nF-W-RULE-2: Worker is a blind executor. This command delegates to it.\nF-W-RULE-3: This command authorizes, L5 executes.\n\nArgs:\n    task: Business/product idea\n    brand: Optional brand schema\n    budget: Optional budget\n    strict_mode: Whether to use strict mode\n    depth: Execution depth\n    run_id: Optional run ID\n    event_bus: Optional event bus\n\nReturns:\n    WorkerExecutionResult with execution outcome\n\nReference: PIN-258 Phase F-3 Workers Cluster",
            "is_async": true,
            "line": 231
          },
          {
            "name": "replay_execution",
            "signature": "(replay_token: str, run_id: str) -> ReplayResult",
            "docstring": "Replay a previous execution.\n\nThis L4 command authorizes and delegates replay to L5.\nL4 \u2192 L5 is an allowed import per layer rules.\n\nArgs:\n    replay_token: Token from previous execution\n    run_id: New run ID for this replay\n\nReturns:\n    ReplayResult with replay outcome\n\nReference: PIN-258 Phase F-3 Workers Cluster",
            "is_async": true,
            "line": 300
          }
        ],
        "classes": [
          {
            "name": "WorkerExecutionResult",
            "docstring": "Result from worker execution command.",
            "methods": [],
            "line": 48
          },
          {
            "name": "ReplayResult",
            "docstring": "Result from replay command.",
            "methods": [],
            "line": 68
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": [
          "WorkerExecutionResult",
          "ReplayResult",
          "calculate_cost_cents",
          "get_brand_schema_types",
          "convert_brand_request",
          "execute_worker",
          "replay_execution"
        ]
      }
    ],
    "l5_schemas": [
      {
        "file_name": "domain_bridge_capabilities.py",
        "file_path": "backend/app/hoc/cus/policies/L5_schemas/domain_bridge_capabilities.py",
        "layer": "L5_schemas",
        "domain": "policies",
        "lines": 199,
        "module_docstring": "Domain Bridge Capability Protocols (PIN-508 Phase 2)\n\nThese Protocols define the narrow capability interfaces that policies L5 engines\nsee when accessing cross-domain services via DomainBridge.\n\nGap 3 applied: DomainBridge returns capability Protocols, not concrete driver types.\nThe consumer sees only the operations it needs.",
        "functions": [],
        "classes": [
          {
            "name": "LessonsQueryCapability",
            "docstring": "Capability Protocol for lessons data access.\n\nPIN-508 Phase 2A: Only the methods lessons_engine actually calls.\nImplemented by LessonsDriver.",
            "methods": [
              "insert_lesson",
              "fetch_lessons_list",
              "fetch_lesson_by_id",
              "fetch_lesson_stats",
              "fetch_debounce_count",
              "insert_policy_proposal_from_lesson",
              "update_lesson_converted",
              "update_lesson_deferred",
              "update_lesson_dismissed",
              "update_lesson_reactivated",
              "fetch_expired_deferred"
            ],
            "line": 32
          },
          {
            "name": "LimitsQueryCapability",
            "docstring": "Capability Protocol for limits read access.\n\nPIN-508 Phase 2B: Only the methods LimitsQueryEngine actually calls.\nImplemented by LimitsReadDriver.",
            "methods": [
              "fetch_limits",
              "fetch_limit_by_id",
              "fetch_budget_limits"
            ],
            "line": 141
          },
          {
            "name": "PolicyLimitsCapability",
            "docstring": "Capability Protocol for policy limits CRUD.\n\nPIN-508 Phase 2C: Only the methods PolicyLimitsService actually calls.\nImplemented by PolicyLimitsDriver.",
            "methods": [
              "add_limit",
              "add_integrity",
              "fetch_limit_by_id",
              "flush"
            ],
            "line": 182
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 23
          }
        ],
        "constants": [],
        "all_exports": [
          "LessonsQueryCapability",
          "LimitsQueryCapability",
          "PolicyLimitsCapability"
        ]
      },
      {
        "file_name": "intent_validation.py",
        "file_path": "backend/app/hoc/cus/policies/L5_schemas/intent_validation.py",
        "layer": "L5_schemas",
        "domain": "policies",
        "lines": 43,
        "module_docstring": "M19 Intent Validation Protocol.\n\nDefines the contract between IntentEmitter and external M19 validators.\nEnforcement-weight intents (EXECUTE, ROUTE, ESCALATE) require validation;\nobservability intents (LOG, ALLOW, ALERT) skip M19 validation.",
        "functions": [],
        "classes": [
          {
            "name": "PolicyIntentValidationResult",
            "docstring": "Result of M19 intent validation.",
            "methods": [],
            "line": 32
          },
          {
            "name": "PolicyIntentValidator",
            "docstring": "Protocol for M19 intent validators.",
            "methods": [
              "validate_intent"
            ],
            "line": 40
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "typing_extensions",
            "names": [
              "TypedDict"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_check.py",
        "file_path": "backend/app/hoc/cus/policies/L5_schemas/policy_check.py",
        "layer": "L5_schemas",
        "domain": "policies",
        "lines": 42,
        "module_docstring": "IRCheckPolicy Validation Protocol.\n\nDefines the contract for policy check validators used by\nthe deterministic engine's IRCheckPolicy instruction handler.",
        "functions": [],
        "classes": [
          {
            "name": "PolicyCheckResult",
            "docstring": "Result of an IR policy check.",
            "methods": [],
            "line": 31
          },
          {
            "name": "PolicyCheckValidator",
            "docstring": "Protocol for IR policy check validators.",
            "methods": [
              "validate_policy"
            ],
            "line": 39
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing_extensions",
            "names": [
              "TypedDict"
            ],
            "is_relative": false,
            "line": 28
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_rules.py",
        "file_path": "backend/app/hoc/cus/policies/L5_schemas/policy_rules.py",
        "layer": "L5_schemas",
        "domain": "policies",
        "lines": 161,
        "module_docstring": "Policy Rules Schemas (PIN-LIM-02)\n\nRequest and response models for policy rule CRUD operations.\nRules define governance constraints that govern LLM Run behavior.",
        "functions": [],
        "classes": [
          {
            "name": "EnforcementModeEnum",
            "docstring": "Policy rule enforcement modes.",
            "methods": [],
            "line": 26
          },
          {
            "name": "PolicyScopeEnum",
            "docstring": "Policy rule scope levels.",
            "methods": [],
            "line": 34
          },
          {
            "name": "PolicySourceEnum",
            "docstring": "Policy rule creation source.",
            "methods": [],
            "line": 42
          },
          {
            "name": "CreatePolicyRuleRequest",
            "docstring": "Request model for creating a policy rule.",
            "methods": [],
            "line": 49
          },
          {
            "name": "UpdatePolicyRuleRequest",
            "docstring": "Request model for updating a policy rule.",
            "methods": [],
            "line": 98
          },
          {
            "name": "PolicyRuleResponse",
            "docstring": "Response model for policy rule operations.",
            "methods": [],
            "line": 137
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 23
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "arbitrator.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/arbitrator.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 339,
        "module_docstring": "Policy Arbitrator Engine\n\nResolves conflicts when multiple policies apply to the same run:\n1. Sort policies by precedence (lower = higher priority)\n2. Resolve limit conflicts using conflict strategy\n3. Resolve action conflicts (harshest action wins)\n4. Return effective limits and actions\n\nArbitration Rules:\n- MOST_RESTRICTIVE: Smallest limit, harshest action wins\n- EXPLICIT_PRIORITY: Higher precedence (lower number) wins\n- FAIL_CLOSED: If ambiguous, deny/stop",
        "functions": [
          {
            "name": "get_policy_arbitrator",
            "signature": "() -> PolicyArbitrator",
            "docstring": "Get or create PolicyArbitrator singleton.",
            "is_async": false,
            "line": 334
          }
        ],
        "classes": [
          {
            "name": "PolicyLimit",
            "docstring": "Represents a policy limit.",
            "methods": [],
            "line": 56
          },
          {
            "name": "PolicyAction",
            "docstring": "Represents a policy breach action.",
            "methods": [],
            "line": 66
          },
          {
            "name": "ArbitrationInput",
            "docstring": "Input for policy arbitration.",
            "methods": [],
            "line": 83
          },
          {
            "name": "PolicyArbitrator",
            "docstring": "Resolves conflicts between multiple applicable policies.\n\nThe arbitrator determines effective limits and actions when\nmultiple policies apply to the same run.",
            "methods": [
              "__init__",
              "arbitrate",
              "_load_precedence_map",
              "_get_precedence_map",
              "_resolve_limit_conflict",
              "_resolve_action_conflict"
            ],
            "line": 93
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.db",
            "names": [
              "engine"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.policy_precedence",
            "names": [
              "ArbitrationResult",
              "ConflictStrategy",
              "PolicyPrecedence"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [
          {
            "name": "ACTION_SEVERITY",
            "line": 75
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "cus_enforcement_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/cus_enforcement_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 259,
        "module_docstring": "Customer Enforcement Driver\n\nL6 driver for customer enforcement data access.\n\nPure persistence - no business logic.\nReturns raw facts: integration data, usage counts, etc.",
        "functions": [
          {
            "name": "get_cus_enforcement_driver",
            "signature": "() -> CusEnforcementDriver",
            "docstring": "Get driver instance.\n\nReturns:\n    CusEnforcementDriver instance",
            "is_async": false,
            "line": 253
          }
        ],
        "classes": [
          {
            "name": "IntegrationRow",
            "docstring": "Immutable integration data for enforcement.",
            "methods": [],
            "line": 26
          },
          {
            "name": "UsageSnapshot",
            "docstring": "Immutable usage snapshot for enforcement status.",
            "methods": [],
            "line": 43
          },
          {
            "name": "CusEnforcementDriver",
            "docstring": "L6 driver for customer enforcement data access.\n\nPure persistence - no business logic.\nReturns raw facts for engine to make decisions.",
            "methods": [
              "fetch_integration",
              "fetch_budget_usage",
              "fetch_token_usage",
              "fetch_rate_count",
              "fetch_usage_snapshot"
            ],
            "line": 51
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 12
          },
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 13
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 14
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 16
          },
          {
            "module": "app.db",
            "names": [
              "get_engine"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "app.models.cus_models",
            "names": [
              "CusIntegration",
              "CusLLMUsage"
            ],
            "is_relative": false,
            "line": 19
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/guard_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 1089,
        "module_docstring": "Guard Read Driver (L6)\n\nProvides async DB read operations for guard/killswitch domain data.\nExtracted from L2 files (guard.py, v1_killswitch.py, replay.py) to enforce\nL2 first-principles purity (zero sqlalchemy/sqlmodel imports in L2).\n\nAll methods accept an AsyncSession and return plain dicts or model instances.",
        "functions": [
          {
            "name": "get_sync_guard_read_driver",
            "signature": "(session: Any) -> SyncGuardReadDriver",
            "docstring": "Factory function to get SyncGuardReadDriver instance.",
            "is_async": false,
            "line": 1087
          }
        ],
        "classes": [
          {
            "name": "GuardReadDriver",
            "docstring": "Async DB read operations for guard/killswitch domain.",
            "methods": [
              "__init__",
              "get_tenant",
              "get_killswitch_state",
              "get_key_states_for_tenant",
              "get_active_guardrails",
              "get_all_guardrails_ordered",
              "get_enabled_guardrails_ordered",
              "count_incidents_since",
              "get_latest_incident",
              "get_incident_by_id",
              "get_incident_by_id_and_tenant",
              "list_incidents",
              "get_incident_events",
              "get_proxy_call",
              "get_proxy_calls_in_window",
              "get_proxy_calls_by_ids",
              "get_incident_events_in_window",
              "get_today_request_stats",
              "get_today_blocked_stats",
              "get_api_key",
              "query_status_history",
              "get_entity_status_history",
              "get_all_status_history",
              "get_status_history_stats",
              "fetch_run_outcome",
              "fetch_decision_summary",
              "query_rbac_audit",
              "get_worker_run",
              "list_worker_runs",
              "count_worker_runs",
              "get_cost_budget",
              "get_daily_spend",
              "check_existing_advisory",
              "count_advisories_for_run",
              "get_run_by_id",
              "list_policy_proposals",
              "get_policy_proposal",
              "get_policy_versions"
            ],
            "line": 31
          },
          {
            "name": "SyncGuardReadDriver",
            "docstring": "Synchronous DB read operations for guard/killswitch domain.\n\nUsed by L2 APIs that depend on sync SQLModel Session (via get_sync_session_dep).\nAll queries that were previously in L2 guard.py are now here.",
            "methods": [
              "__init__",
              "get_tenant_by_id",
              "get_tenant_name",
              "get_tenant_killswitch_state",
              "get_active_guardrail_names",
              "get_enabled_guardrails_raw",
              "get_all_guardrails_raw",
              "get_enabled_guardrail_id_names",
              "count_tenant_incidents_since",
              "get_last_tenant_incident_time",
              "get_incident_by_id_raw",
              "get_incident_by_id_and_tenant_raw",
              "get_incident_events_raw",
              "search_incidents_raw",
              "get_proxy_call_by_id_raw",
              "get_tenant_today_request_stats",
              "get_tenant_today_blocked_stats"
            ],
            "line": 794
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 28
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "limits_simulation_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/limits_simulation_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 192,
        "module_docstring": "Limits Simulation Driver\n\nL6 driver for limits simulation data access.\n\nPure persistence - no business logic.\nReturns raw facts: tenant quotas, limits, overrides.",
        "functions": [
          {
            "name": "get_limits_simulation_driver",
            "signature": "(session: AsyncSession) -> LimitsSimulationDriver",
            "docstring": "Get driver instance with session.\n\nArgs:\n    session: AsyncSession\n\nReturns:\n    LimitsSimulationDriver instance",
            "is_async": false,
            "line": 183
          }
        ],
        "classes": [
          {
            "name": "TenantQuotaRow",
            "docstring": "Immutable tenant quota data.",
            "methods": [],
            "line": 25
          },
          {
            "name": "PolicyLimitRow",
            "docstring": "Immutable policy limit data.",
            "methods": [],
            "line": 37
          },
          {
            "name": "LimitsSimulationDriver",
            "docstring": "L6 driver for limits simulation data access.\n\nPure persistence - no business logic.\nReturns raw facts for engine to interpret.",
            "methods": [
              "__init__",
              "fetch_tenant_quotas",
              "fetch_policy_limits",
              "fetch_cost_budgets",
              "fetch_worker_limits",
              "fetch_active_overrides"
            ],
            "line": 50
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 12
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 13
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 14
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 15
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "select"
            ],
            "is_relative": false,
            "line": 17
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitStatus"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "app.models.tenant",
            "names": [
              "Tenant"
            ],
            "is_relative": false,
            "line": 21
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "m25_integration_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/m25_integration_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 665,
        "module_docstring": "M25 Integration Read Driver - DB read operations for M25 Integration APIs.\n\nExtracted from hoc/api/cus/policies/M25_integrations.py to achieve L2 first-principles purity.\n\nConstraints (enforced by PIN-250):\n- Read-only: No write operations, no policy logic\n- No cross-service calls\n- SQL text preserved exactly (no changes)\n- L6 drivers DO NOT COMMIT",
        "functions": [
          {
            "name": "get_m25_integration_read_driver",
            "signature": "(session: AsyncSession) -> M25IntegrationReadDriver",
            "docstring": "Factory function for M25IntegrationReadDriver.",
            "is_async": false,
            "line": 663
          }
        ],
        "classes": [
          {
            "name": "LoopStageRow",
            "docstring": "Row from loop_events for stage details.",
            "methods": [],
            "line": 46
          },
          {
            "name": "CheckpointRow",
            "docstring": "Row from human_checkpoints.",
            "methods": [],
            "line": 56
          },
          {
            "name": "LoopStatsRow",
            "docstring": "Aggregated loop statistics.",
            "methods": [],
            "line": 73
          },
          {
            "name": "PatternStatsRow",
            "docstring": "Aggregated pattern match statistics.",
            "methods": [],
            "line": 81
          },
          {
            "name": "RecoveryStatsRow",
            "docstring": "Aggregated recovery statistics.",
            "methods": [],
            "line": 90
          },
          {
            "name": "PolicyStatsRow",
            "docstring": "Aggregated policy statistics.",
            "methods": [],
            "line": 98
          },
          {
            "name": "RoutingStatsRow",
            "docstring": "Aggregated routing adjustment statistics.",
            "methods": [],
            "line": 106
          },
          {
            "name": "CheckpointStatsRow",
            "docstring": "Aggregated checkpoint statistics.",
            "methods": [],
            "line": 113
          },
          {
            "name": "SimulationStateRow",
            "docstring": "Simulation state for graduation gates.",
            "methods": [],
            "line": 120
          },
          {
            "name": "IncidentRow",
            "docstring": "Row from incidents table.",
            "methods": [],
            "line": 128
          },
          {
            "name": "PreventionRow",
            "docstring": "Row from prevention_records.",
            "methods": [],
            "line": 138
          },
          {
            "name": "RegretRow",
            "docstring": "Row from regret_events.",
            "methods": [],
            "line": 149
          },
          {
            "name": "M25IntegrationReadDriver",
            "docstring": "Async DB read operations for M25 Integration APIs.\n\nRead-only driver. No writes, no policy logic.\nRaw SQL preserved exactly as extracted from M25_integrations.py.",
            "methods": [
              "__init__",
              "get_loop_stages",
              "get_checkpoint",
              "get_loop_stats",
              "get_pattern_stats",
              "get_recovery_stats",
              "get_policy_stats",
              "get_routing_stats",
              "get_checkpoint_stats",
              "get_simulation_state",
              "get_incident",
              "get_loop_events_for_timeline",
              "get_prevention_records",
              "get_regret_events_for_incident"
            ],
            "line": 160
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "m25_integration_write_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/m25_integration_write_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 344,
        "module_docstring": "M25 Integration Write Driver - DB write operations for M25 Integration APIs.\n\nExtracted from hoc/api/cus/policies/M25_integrations.py to achieve L2 first-principles purity.\n\nConstraints (enforced by PIN-250):\n- Write operations only, no read operations (use read driver)\n- No cross-service calls\n- SQL text preserved exactly (no changes)\n- L6 drivers DO NOT COMMIT \u2014 caller owns transaction",
        "functions": [
          {
            "name": "get_m25_integration_write_driver",
            "signature": "(session: AsyncSession) -> M25IntegrationWriteDriver",
            "docstring": "Factory function for M25IntegrationWriteDriver.",
            "is_async": false,
            "line": 340
          }
        ],
        "classes": [
          {
            "name": "PreventionRecordInput",
            "docstring": "Input for inserting a prevention record.",
            "methods": [],
            "line": 44
          },
          {
            "name": "RegretEventInput",
            "docstring": "Input for inserting a regret event.",
            "methods": [],
            "line": 57
          },
          {
            "name": "TimelineViewInput",
            "docstring": "Input for inserting a timeline view.",
            "methods": [],
            "line": 69
          },
          {
            "name": "GraduationHistoryInput",
            "docstring": "Input for inserting graduation history.",
            "methods": [],
            "line": 82
          },
          {
            "name": "GraduationStatusUpdateInput",
            "docstring": "Input for updating m25_graduation_status.",
            "methods": [],
            "line": 93
          },
          {
            "name": "M25IntegrationWriteDriver",
            "docstring": "Async DB write operations for M25 Integration APIs.\n\nWrite-only driver. L6 drivers DO NOT COMMIT.\nRaw SQL preserved exactly as extracted from M25_integrations.py.",
            "methods": [
              "__init__",
              "insert_prevention_record",
              "insert_regret_event",
              "upsert_policy_regret_summary",
              "insert_timeline_view",
              "insert_graduation_history",
              "update_graduation_status"
            ],
            "line": 102
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "optimizer_conflict_resolver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/optimizer_conflict_resolver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 390,
        "module_docstring": "Conflict resolution for PLang v2.0.\n\nConflict types:\n- Action conflicts: Different actions for same condition\n- Priority conflicts: Same priority for different policies\n- Category conflicts: Cross-category interactions\n\nResolution strategies:\n- Category precedence: SAFETY > PRIVACY > OPERATIONAL > ROUTING > CUSTOM\n- Priority ordering: Higher priority wins\n- Action precedence: deny > escalate > route > allow",
        "functions": [],
        "classes": [
          {
            "name": "ConflictType",
            "docstring": "Types of policy conflicts.",
            "methods": [],
            "line": 51
          },
          {
            "name": "PolicyConflict",
            "docstring": "A detected conflict between policies.\n\nIncludes conflict type, involved policies, and resolution.",
            "methods": [
              "__str__"
            ],
            "line": 61
          },
          {
            "name": "ConflictResolver",
            "docstring": "Resolves conflicts between policies.\n\nUses M19 governance rules to determine winning policy\nwhen conflicts are detected.",
            "methods": [
              "__init__",
              "resolve",
              "_detect_action_conflicts",
              "_detect_priority_conflicts",
              "_detect_category_conflicts",
              "_detect_circular_dependencies",
              "_get_condition_signature",
              "_might_override",
              "_get_actions",
              "_resolve_conflict",
              "_resolve_action_conflict",
              "_resolve_priority_conflict",
              "_resolve_category_conflict",
              "_resolve_circular_conflict"
            ],
            "line": 81
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "List",
              "Optional",
              "Set",
              "Tuple"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "PLANG_GRAMMAR",
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRAction",
              "IRBlock",
              "IRFunction",
              "IRModule"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policies_facade_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policies_facade_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 478,
        "module_docstring": "PoliciesFacadeDriver (L6)\n\nPure data access for the policies facade. Contains all SQL queries\npreviously embedded in the legacy PoliciesFacade class.\n\nMethods return raw dicts/scalars \u2014 the L5 facade maps to result types.",
        "functions": [],
        "classes": [
          {
            "name": "PoliciesFacadeDriver",
            "docstring": "L6 driver for policies facade SQL operations.",
            "methods": [
              "fetch_policy_rules",
              "fetch_policy_rule_detail",
              "fetch_limits",
              "fetch_limit_detail",
              "fetch_policy_requests",
              "fetch_budgets",
              "count_pending_drafts"
            ],
            "line": 37
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitBreach",
              "LimitIntegrity",
              "PolicyEnforcement",
              "PolicyRule",
              "PolicyRuleIntegrity"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_approval_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_approval_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 525,
        "module_docstring": "Policy Approval Driver (L6)\n\nPure data access layer for policy approval workflow operations.\nAll SQLAlchemy queries live here. No business logic.\n\nExtracted from hoc/api/cus/policies/policy.py to comply with\nL2 purity requirements (no session.execute in L2).",
        "functions": [
          {
            "name": "get_policy_approval_driver",
            "signature": "(session: AsyncSession) -> PolicyApprovalDriver",
            "docstring": "Factory function for PolicyApprovalDriver.",
            "is_async": false,
            "line": 517
          }
        ],
        "classes": [
          {
            "name": "PolicyApprovalDriver",
            "docstring": "Data access operations for policy approval workflow.",
            "methods": [
              "__init__",
              "get_approval_level_config",
              "_config_to_dict",
              "create_approval_request",
              "get_approval_request",
              "get_approval_request_for_action",
              "get_approval_request_for_reject",
              "update_approval_request_status",
              "update_approval_request_approved",
              "update_approval_request_escalated",
              "list_approval_requests",
              "list_pending_for_escalation",
              "count_active_policy_rules",
              "list_policy_rules",
              "get_policy_rule_detail",
              "list_limits",
              "get_limit_detail"
            ],
            "line": 38
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 33
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyApprovalDriver",
          "get_policy_approval_driver"
        ]
      },
      {
        "file_name": "policy_enforcement_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_enforcement_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 173,
        "module_docstring": "Policy Enforcement Read Driver (PIN-519)\n\nProvides async read operations for policy enforcement records.\nUsed by L4 coordinators to gather policy evaluations for runs.\n\nINVARIANTS:\n- Read-only operations (no INSERT, UPDATE, DELETE)\n- Queries are tenant-scoped\n- Returns enforcement records with rule details",
        "functions": [
          {
            "name": "get_policy_enforcement_read_driver",
            "signature": "(session: AsyncSession) -> PolicyEnforcementReadDriver",
            "docstring": "Get a PolicyEnforcementReadDriver instance.\n\nArgs:\n    session: Async database session\n\nReturns:\n    PolicyEnforcementReadDriver instance",
            "is_async": false,
            "line": 151
          }
        ],
        "classes": [
          {
            "name": "PolicyEnforcementReadDriver",
            "docstring": "Async driver for reading policy enforcement records.\n\nL6 CONTRACT:\n- Pure database reads, no business logic\n- All methods are async (for use with AsyncSession)\n- Queries happen within caller's transaction",
            "methods": [
              "__init__",
              "fetch_policy_evaluations_for_run",
              "fetch_enforcement_by_id"
            ],
            "line": 44
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "select"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "PolicyEnforcement",
              "PolicyRule"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyEnforcementReadDriver",
          "get_policy_enforcement_read_driver"
        ]
      },
      {
        "file_name": "policy_enforcement_write_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_enforcement_write_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 216,
        "module_docstring": "Policy Enforcement Write Driver\n\nProvides async write operations for policy enforcement records.\nRecords when policy rules trigger STOP/KILL/BLOCK actions.\n\nINVARIANTS:\n- Append-only writes (no UPDATE, DELETE)\n- All writes are tenant-scoped\n- Records include rule_id, run_id, action_taken, details\n\nPIN-412: Enforcements are append-only history.\nUsed for trigger_count_30d and last_triggered_at derivations.",
        "functions": [
          {
            "name": "_generate_enforcement_id",
            "signature": "() -> str",
            "docstring": "Generate a unique enforcement ID.",
            "is_async": false,
            "line": 48
          },
          {
            "name": "_utc_now",
            "signature": "() -> datetime",
            "docstring": "Get current UTC timestamp.",
            "is_async": false,
            "line": 53
          },
          {
            "name": "get_policy_enforcement_write_driver",
            "signature": "(session: AsyncSession) -> PolicyEnforcementWriteDriver",
            "docstring": "Get a PolicyEnforcementWriteDriver instance.\n\nArgs:\n    session: Async database session\n\nReturns:\n    PolicyEnforcementWriteDriver instance",
            "is_async": false,
            "line": 194
          }
        ],
        "classes": [
          {
            "name": "PolicyEnforcementWriteDriver",
            "docstring": "Async driver for writing policy enforcement records.\n\nL6 CONTRACT:\n- Pure database writes, no business logic\n- All methods are async (for use with AsyncSession)\n- Writes happen within caller's transaction (caller owns commit)\n- Append-only: no updates or deletes",
            "methods": [
              "__init__",
              "record_enforcement",
              "record_enforcement_batch"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "PolicyEnforcement"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyEnforcementWriteDriver",
          "get_policy_enforcement_write_driver"
        ]
      },
      {
        "file_name": "policy_engine_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_engine_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 1911,
        "module_docstring": "Policy Engine Driver (L6)\n\nPure data access for PolicyEngine operations.\nNo business logic - only DB operations.\n\nAuthority: POLICY_ENGINE_PERSISTENCE\nTables:\n  - policy.evaluations (write)\n  - policy.violations (read/write)\n  - policy.ethical_constraints (read)\n  - policy.risk_ceilings (read/write)\n  - policy.safety_rules (read/write)\n  - policy.business_rules (read)\n  - policy.policy_versions (read/write)\n  - policy.policy_provenance (read/write)\n  - policy.policy_dependencies (read/write)\n  - policy.policy_conflicts (read/write)\n  - policy.temporal_policies (read/write)\n  - policy.temporal_metric_events (read/write)\n  - policy.temporal_metric_windows (read/write)",
        "functions": [
          {
            "name": "get_policy_engine_driver",
            "signature": "(db_url: str) -> PolicyEngineDriver",
            "docstring": "Factory function for PolicyEngineDriver.",
            "is_async": false,
            "line": 1903
          }
        ],
        "classes": [
          {
            "name": "PolicyEngineDriver",
            "docstring": "L6 driver for PolicyEngine data access.\n\nINVARIANTS (L6):\n- No business branching\n- No validation\n- No cross-domain calls\n- Pure persistence operations only",
            "methods": [
              "__init__",
              "_get_engine",
              "get_engine",
              "fetch_ethical_constraints",
              "fetch_risk_ceilings",
              "fetch_safety_rules",
              "fetch_business_rules",
              "insert_evaluation",
              "insert_violation",
              "fetch_violations",
              "fetch_violation_by_id",
              "update_violation_acknowledged",
              "update_risk_ceiling",
              "reset_risk_ceiling",
              "update_safety_rule",
              "fetch_policy_versions",
              "fetch_current_active_version",
              "fetch_policy_version_by_id",
              "fetch_policy_version_by_id_or_version",
              "deactivate_all_versions",
              "insert_policy_version",
              "fetch_version_for_rollback",
              "mark_version_rolled_back",
              "activate_version",
              "insert_provenance",
              "fetch_provenance",
              "fetch_dependencies",
              "fetch_dependency_edges",
              "fetch_dependency_edges_with_type",
              "insert_dependency",
              "fetch_conflicts",
              "fetch_unresolved_conflicts",
              "resolve_conflict",
              "fetch_temporal_policies",
              "insert_temporal_policy",
              "fetch_temporal_policy_for_utilization",
              "fetch_temporal_metric_sum",
              "delete_old_temporal_events",
              "compact_temporal_events",
              "cap_temporal_events",
              "fetch_temporal_stats",
              "fetch_temporal_storage_stats",
              "fetch_active_policies_for_integrity",
              "fetch_temporal_policies_for_integrity",
              "fetch_ethical_constraints_for_integrity",
              "managed_connection",
              "_conn",
              "_write_conn",
              "fetch_ethical_constraints_auto",
              "fetch_risk_ceilings_auto",
              "fetch_safety_rules_auto",
              "fetch_business_rules_auto",
              "fetch_violations_auto",
              "fetch_violation_by_id_auto",
              "fetch_policy_versions_auto",
              "fetch_current_active_version_auto",
              "fetch_policy_version_by_id_auto",
              "fetch_policy_version_by_id_or_version_auto",
              "fetch_version_for_rollback_auto",
              "fetch_provenance_auto",
              "fetch_dependencies_auto",
              "fetch_dependency_edges_auto",
              "fetch_dependency_edges_with_type_auto",
              "fetch_conflicts_auto",
              "fetch_unresolved_conflicts_auto",
              "fetch_temporal_policies_auto",
              "fetch_temporal_policy_for_utilization_auto",
              "fetch_temporal_metric_sum_auto",
              "fetch_temporal_stats_auto",
              "fetch_temporal_storage_stats_auto",
              "fetch_active_policies_for_integrity_auto",
              "fetch_temporal_policies_for_integrity_auto",
              "fetch_ethical_constraints_for_integrity_auto",
              "insert_evaluation_committed",
              "insert_violation_committed",
              "update_violation_acknowledged_committed",
              "update_risk_ceiling_committed",
              "reset_risk_ceiling_committed",
              "update_safety_rule_committed",
              "deactivate_all_versions_committed",
              "insert_policy_version_committed",
              "mark_version_rolled_back_committed",
              "activate_version_committed",
              "insert_provenance_committed",
              "insert_dependency_committed",
              "resolve_conflict_committed",
              "insert_temporal_policy_committed",
              "delete_old_temporal_events_committed",
              "compact_temporal_events_committed",
              "cap_temporal_events_committed",
              "fetch_snapshot_by_id",
              "fetch_snapshot_by_id_auto",
              "insert_snapshot",
              "insert_snapshot_committed"
            ],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "contextlib",
            "names": [
              "contextmanager"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "sqlalchemy",
            "names": [
              "create_engine",
              "text"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "sqlalchemy.engine",
            "names": [
              "Connection",
              "Engine"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyEngineDriver",
          "get_policy_engine_driver"
        ]
      },
      {
        "file_name": "policy_graph_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_graph_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 226,
        "module_docstring": "Policy Graph Driver (L6 Data Access)\n\nHandles database operations for policy graph computation:\n- Fetching policies for conflict detection\n- Fetching limits for threshold analysis\n- Fetching resolved conflict pairs\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_policy_graph_driver",
            "signature": "(session: AsyncSession) -> PolicyGraphDriver",
            "docstring": "Get a PolicyGraphDriver instance.",
            "is_async": false,
            "line": 224
          }
        ],
        "classes": [
          {
            "name": "PolicyGraphDriver",
            "docstring": "L6 Driver for policy graph data operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (conflict detection, graph computation) stay in L5.",
            "methods": [
              "__init__",
              "fetch_active_policies",
              "fetch_all_policies",
              "fetch_active_limits",
              "fetch_all_limits",
              "fetch_resolved_conflicts"
            ],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_proposal_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_proposal_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 201,
        "module_docstring": "Policy Proposal Read Driver (L6)\n\nPure data access layer for policy proposal read operations.\nNo business logic - only query execution and data retrieval.",
        "functions": [
          {
            "name": "get_policy_proposal_read_driver",
            "signature": "(session: AsyncSession) -> PolicyProposalReadDriver",
            "docstring": "Factory function for PolicyProposalReadDriver.",
            "is_async": false,
            "line": 193
          }
        ],
        "classes": [
          {
            "name": "PolicyProposalReadDriver",
            "docstring": "Read operations for policy proposals.",
            "methods": [
              "__init__",
              "fetch_unacknowledged_feedback",
              "fetch_proposal_by_id",
              "fetch_proposal_status",
              "count_versions_for_proposal",
              "fetch_proposals",
              "check_rule_exists",
              "fetch_rule_by_id"
            ],
            "line": 34
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select",
              "text"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.models.feedback",
            "names": [
              "PatternFeedback"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyProposal",
              "PolicyVersion"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyProposalReadDriver",
          "get_policy_proposal_read_driver"
        ]
      },
      {
        "file_name": "policy_proposal_write_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_proposal_write_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 228,
        "module_docstring": "Policy Proposal Write Driver (L6)\n\nPure data access layer for policy proposal write operations.\nNo business logic - only persistence and mutations.",
        "functions": [
          {
            "name": "get_policy_proposal_write_driver",
            "signature": "(session: AsyncSession) -> PolicyProposalWriteDriver",
            "docstring": "Factory function for PolicyProposalWriteDriver.",
            "is_async": false,
            "line": 218
          }
        ],
        "classes": [
          {
            "name": "PolicyProposalWriteDriver",
            "docstring": "Write operations for policy proposals.",
            "methods": [
              "__init__",
              "create_proposal",
              "update_proposal_status",
              "create_version",
              "create_policy_rule",
              "delete_policy_rule"
            ],
            "line": 35
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyProposal",
              "PolicyVersion"
            ],
            "is_relative": false,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyProposalWriteDriver",
          "get_policy_proposal_write_driver"
        ]
      },
      {
        "file_name": "policy_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 243,
        "module_docstring": "Policy Read Driver (L6)\n\nPure data access layer for customer policy read operations.\nNo business logic - only query construction and data retrieval.\n\nArchitecture:\n    L3 (Adapter) \u2192 L4 (Engine) \u2192 L6 (this driver) \u2192 Database\n\nOperations:\n- Query tenant settings\n- Query usage totals (ProxyCall sum)\n- Query guardrails\n- No mutations (read-only)\n\nReference: PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_policy_read_driver",
            "signature": "(session: Session) -> PolicyReadDriver",
            "docstring": "Get PolicyReadDriver instance.\n\nArgs:\n    session: SQLModel session\n\nReturns:\n    PolicyReadDriver instance",
            "is_async": false,
            "line": 219
          }
        ],
        "classes": [
          {
            "name": "TenantBudgetDataDTO",
            "docstring": "Raw tenant budget settings from database.",
            "methods": [],
            "line": 68
          },
          {
            "name": "UsageSumDTO",
            "docstring": "Raw usage sum from database.",
            "methods": [],
            "line": 76
          },
          {
            "name": "GuardrailDTO",
            "docstring": "Raw guardrail data from database.",
            "methods": [],
            "line": 82
          },
          {
            "name": "PolicyReadDriver",
            "docstring": "L6 driver for customer policy read operations.\n\nPure data access - no business logic.\nAll methods provide raw database data for L4 engine to process.",
            "methods": [
              "__init__",
              "get_tenant_budget_settings",
              "get_usage_sum_since",
              "get_guardrail_by_id",
              "list_all_guardrails",
              "_to_guardrail_dto"
            ],
            "line": 99
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "DefaultGuardrail",
              "ProxyCall"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.models.tenant",
            "names": [
              "Tenant"
            ],
            "is_relative": false,
            "line": 60
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyReadDriver",
          "get_policy_read_driver",
          "TenantBudgetDataDTO",
          "UsageSumDTO",
          "GuardrailDTO"
        ]
      },
      {
        "file_name": "policy_rules_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_rules_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 149,
        "module_docstring": "Policy Rules Driver\n\nPure data access for policy rules table.\nNo business logic - only DB operations.\n\nAuthority: RULE_PERSISTENCE\nTables: policy_rules, policy_rule_integrity",
        "functions": [
          {
            "name": "get_policy_rules_driver",
            "signature": "(session: AsyncSession) -> PolicyRulesDriver",
            "docstring": "Factory function for PolicyRulesDriver.",
            "is_async": false,
            "line": 147
          }
        ],
        "classes": [
          {
            "name": "PolicyRulesDriver",
            "docstring": "Data access driver for policy rules.\n\nINVARIANTS (L6):\n- No business branching\n- No validation\n- No cross-domain calls\n- Pure persistence operations only",
            "methods": [
              "__init__",
              "fetch_rule_by_id",
              "add_rule",
              "add_integrity",
              "create_rule",
              "create_integrity",
              "flush"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_rules_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_rules_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 255,
        "module_docstring": "Policy Rules Read Driver (L6)\n\nPure data access layer for policy rules read operations.\nAll SQLAlchemy queries live here. No business logic.",
        "functions": [
          {
            "name": "get_policy_rules_read_driver",
            "signature": "(session: AsyncSession) -> PolicyRulesReadDriver",
            "docstring": "Factory function for PolicyRulesReadDriver.",
            "is_async": false,
            "line": 247
          }
        ],
        "classes": [
          {
            "name": "PolicyRulesReadDriver",
            "docstring": "Read operations for policy rules.",
            "methods": [
              "__init__",
              "fetch_policy_rules",
              "fetch_policy_rule_by_id",
              "count_policy_rules"
            ],
            "line": 38
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "PolicyEnforcement",
              "PolicyRule",
              "PolicyRuleIntegrity"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyRulesReadDriver",
          "get_policy_rules_read_driver"
        ]
      },
      {
        "file_name": "proposals_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/proposals_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 413,
        "module_docstring": "Proposals Read Driver (L6)\n\nPure data access layer for policy proposals read operations (list view).\nThis driver is for the \"Proposals\" tab in the policies domain.\n\nNote: This is separate from policy_proposal_read_driver.py which handles\nthe proposal lifecycle engine operations.\n\nAll SQLAlchemy queries live here. No business logic.",
        "functions": [
          {
            "name": "get_proposals_read_driver",
            "signature": "(session: AsyncSession) -> ProposalsReadDriver",
            "docstring": "Factory function for ProposalsReadDriver.",
            "is_async": false,
            "line": 405
          }
        ],
        "classes": [
          {
            "name": "ProposalsReadDriver",
            "docstring": "Read operations for policy proposals (list view).",
            "methods": [
              "__init__",
              "fetch_proposals",
              "fetch_proposal_by_id",
              "count_draft_proposals",
              "list_proposals_paginated",
              "get_proposal_stats",
              "get_proposal_detail",
              "list_proposal_versions"
            ],
            "line": 38
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyProposal"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": [
          "ProposalsReadDriver",
          "get_proposals_read_driver"
        ]
      },
      {
        "file_name": "rbac_audit_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/rbac_audit_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 252,
        "module_docstring": "RBAC Audit Driver (L6)\n\nPure data access layer for RBAC audit log operations.\nHandles DB queries and cleanup for system.rbac_audit table.\n\nOperations:\n- query_audit_logs: Query audit entries with filters\n- cleanup_audit_logs: Delete old audit entries (L4 owns commit)\n\nArchitecture:\n    L2 (rbac_api.py) -> L4 (registry dispatch) -> L6 (this driver) -> Database",
        "functions": [
          {
            "name": "get_rbac_audit_driver",
            "signature": "(session: Session) -> RbacAuditDriver",
            "docstring": "Get RbacAuditDriver instance.\n\nArgs:\n    session: SQLModel session (sync)\n\nReturns:\n    RbacAuditDriver instance",
            "is_async": false,
            "line": 228
          }
        ],
        "classes": [
          {
            "name": "AuditEntryDTO",
            "docstring": "Raw audit entry data from database.",
            "methods": [],
            "line": 50
          },
          {
            "name": "AuditQueryResultDTO",
            "docstring": "Query result containing entries and total count.",
            "methods": [],
            "line": 67
          },
          {
            "name": "AuditCleanupResultDTO",
            "docstring": "Cleanup operation result.",
            "methods": [],
            "line": 74
          },
          {
            "name": "RbacAuditDriver",
            "docstring": "L6 driver for RBAC audit log operations.\n\nPure data access - no business logic.\nHandles DB queries and cleanup for RBAC audit logs.\n\nTransaction ownership:\n- query_audit_logs: Read-only, no commit needed\n- cleanup_audit_logs: NO COMMIT \u2014 L4 handler owns commit/rollback",
            "methods": [
              "__init__",
              "query_audit_logs",
              "cleanup_audit_logs"
            ],
            "line": 85
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "RbacAuditDriver",
          "get_rbac_audit_driver",
          "AuditEntryDTO",
          "AuditQueryResultDTO",
          "AuditCleanupResultDTO"
        ]
      },
      {
        "file_name": "recovery_matcher.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/recovery_matcher.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 1011,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "MatchResult",
            "docstring": "Result from matching a failure to a recovery suggestion.",
            "methods": [],
            "line": 80
          },
          {
            "name": "RecoveryMatcher",
            "docstring": "Matches failures to recovery suggestions using pattern matching\nand confidence scoring.\n\nTransaction Boundary: L6 drivers DO NOT commit.\nThe caller (L5 engine or L4 coordinator) owns the transaction.\nThis driver only calls session.add()/session.execute() \u2014 never session.commit().",
            "methods": [
              "__init__",
              "_normalize_error",
              "_calculate_time_weight",
              "_compute_confidence",
              "_generate_suggestion",
              "_find_similar_failures",
              "_count_occurrences",
              "_get_cached_recovery",
              "_set_cached_recovery",
              "_find_similar_by_embedding",
              "_escalate_to_llm",
              "suggest_hybrid",
              "_upsert_candidate",
              "suggest",
              "get_candidates",
              "count_candidates",
              "count_by_status",
              "approve_candidate"
            ],
            "line": 93
          }
        ],
        "imports": [
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "math",
            "names": [
              "math"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.security.sanitize",
            "names": [
              "sanitize_error_message"
            ],
            "is_relative": false,
            "line": 60
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 32
          },
          {
            "name": "RETRY_POLICY",
            "line": 33
          },
          {
            "name": "HALF_LIFE_DAYS",
            "line": 68
          },
          {
            "name": "EMBEDDING_SIMILARITY_THRESHOLD",
            "line": 69
          },
          {
            "name": "LLM_ESCALATION_THRESHOLD",
            "line": 70
          },
          {
            "name": "CACHE_TTL_SECONDS",
            "line": 71
          },
          {
            "name": "LAMBDA",
            "line": 72
          },
          {
            "name": "ALPHA",
            "line": 73
          },
          {
            "name": "MIN_CONFIDENCE_THRESHOLD",
            "line": 74
          },
          {
            "name": "NO_HISTORY_CONFIDENCE",
            "line": 75
          },
          {
            "name": "EXACT_MATCH_CONFIDENCE",
            "line": 76
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "recovery_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/recovery_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 329,
        "module_docstring": "Recovery Read Driver - DB read operations for Recovery APIs.\n\nExtracted from hoc/api/cus/recovery/recovery.py to achieve L2 first-principles purity.\n\nConstraints (enforced by PIN-250):\n- Read-only: No write operations, no policy logic\n- No cross-service calls\n- SQL text preserved exactly (no changes)\n- L6 drivers DO NOT COMMIT",
        "functions": [],
        "classes": [
          {
            "name": "RecoveryReadDriver",
            "docstring": "Sync DB read operations for Recovery APIs.\n\nRead-only driver. No writes, no policy logic.\nRaw SQL preserved exactly as extracted from API files.",
            "methods": [
              "__init__",
              "get_candidate_detail",
              "get_selected_action",
              "get_suggestion_inputs",
              "get_suggestion_provenance",
              "candidate_exists",
              "list_actions"
            ],
            "line": 42
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "recovery_write_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/recovery_write_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 265,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "RecoveryWriteService",
            "docstring": "Sync DB write operations for Recovery APIs.\n\nWrite-only facade. No policy logic, no branching beyond DB operations.\nRaw SQL preserved exactly as extracted from API files.",
            "methods": [
              "__init__",
              "upsert_recovery_candidate",
              "get_candidate_by_idempotency_key",
              "enqueue_evaluation_db_fallback",
              "update_recovery_candidate",
              "insert_suggestion_provenance"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 30
          },
          {
            "name": "RETRY_POLICY",
            "line": 31
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "replay_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/replay_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 277,
        "module_docstring": "Replay Read Driver (L6)\n\nPure data access layer for replay UX read operations.\nNo business logic - only query construction and data retrieval.\n\nArchitecture:\n    L2 (API) -> L4 (Handler) -> L6 (this driver) -> Database\n\nOperations:\n- get_incident: Fetch incident by ID with tenant isolation\n- get_proxy_calls_in_window: Fetch proxy calls by IDs within time window\n- get_incident_events_in_window: Fetch incident events within time window\n- get_proxy_calls_for_timeline: Fetch all proxy calls for incident timeline\n- get_all_incident_events: Fetch all events for an incident\n- get_proxy_call_by_id: Fetch single proxy call\n- get_incident_event_by_id: Fetch single incident event for an incident\n\nReference: Replay UX API (H1) - READ-ONLY slice and timeline endpoints",
        "functions": [
          {
            "name": "get_replay_read_driver",
            "signature": "(session: Session) -> ReplayReadDriver",
            "docstring": "Factory function to get ReplayReadDriver instance.",
            "is_async": false,
            "line": 269
          }
        ],
        "classes": [
          {
            "name": "ReplayReadDriver",
            "docstring": "L6 driver for replay UX read operations.\n\nPure data access - no business logic.\nAll incident access requires tenant_id for isolation.",
            "methods": [
              "__init__",
              "get_incident",
              "get_incident_no_tenant_check",
              "get_proxy_calls_in_window",
              "get_incident_events_in_window",
              "get_proxy_calls_for_timeline",
              "get_all_incident_events",
              "get_proxy_call_by_id",
              "get_incident_event_by_id"
            ],
            "line": 50
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": [
          "ReplayReadDriver",
          "get_replay_read_driver"
        ]
      },
      {
        "file_name": "scope_resolver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/scope_resolver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 259,
        "module_docstring": "Scope Resolver Engine\n\nResolves which policies apply to a run based on:\n- Tenant ID (always required)\n- Agent ID (for AGENT scope)\n- API Key ID (for API_KEY scope)\n- Human Actor ID (for HUMAN_ACTOR scope)\n\nResolution happens BEFORE run starts and the result is frozen\ninto the policy snapshot for audit purposes.",
        "functions": [
          {
            "name": "get_scope_resolver",
            "signature": "() -> ScopeResolver",
            "docstring": "Get or create ScopeResolver singleton.",
            "is_async": false,
            "line": 254
          }
        ],
        "classes": [
          {
            "name": "RunContext",
            "docstring": "Context for scope resolution.",
            "methods": [],
            "line": 48
          },
          {
            "name": "ScopeResolutionResult",
            "docstring": "Result of scope resolution.",
            "methods": [
              "to_snapshot"
            ],
            "line": 59
          },
          {
            "name": "ScopeResolver",
            "docstring": "Resolves which policies apply to a given run context.\n\nThe resolver evaluates all active policy scopes for a tenant\nand returns the list of policies that match the run context.",
            "methods": [
              "__init__",
              "resolve_applicable_policies",
              "_load_scopes",
              "matches_scope",
              "get_scope_for_policy",
              "_get_scope"
            ],
            "line": 97
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.db",
            "names": [
              "engine"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.models.policy_scope",
            "names": [
              "PolicyScope",
              "ScopeType"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "symbol_table.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/symbol_table.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 309,
        "module_docstring": "Symbol table for PLang v2.0 compilation.\n\nFeatures:\n- Hierarchical scoping (global, policy, rule, block)\n- Category-aware symbol lookup\n- Governance metadata tracking\n- M19 policy reference resolution",
        "functions": [],
        "classes": [
          {
            "name": "SymbolType",
            "docstring": "Types of symbols in PLang.",
            "methods": [],
            "line": 41
          },
          {
            "name": "Symbol",
            "docstring": "A symbol in the symbol table.\n\nRepresents named entities in PLang: policies, rules, variables, etc.",
            "methods": [
              "__repr__"
            ],
            "line": 54
          },
          {
            "name": "Scope",
            "docstring": "A scope in the symbol table.\n\nScopes form a hierarchy: global -> policy -> rule -> block",
            "methods": [
              "define",
              "lookup",
              "lookup_by_category",
              "get_all_symbols"
            ],
            "line": 79
          },
          {
            "name": "SymbolTable",
            "docstring": "Symbol table for PLang compilation.\n\nManages scopes and symbol resolution with M19 category awareness.",
            "methods": [
              "__init__",
              "_define_builtins",
              "enter_scope",
              "exit_scope",
              "define",
              "lookup",
              "lookup_policy",
              "lookup_rule",
              "get_symbols_by_category",
              "get_policies",
              "get_rules",
              "add_reference",
              "get_unreferenced_symbols",
              "__str__"
            ],
            "line": 131
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "workers_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/workers_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 285,
        "module_docstring": "Workers Read Driver (L6)\n\nProvides async DB read operations for worker domain data.\nExtracted from L2 workers.py to enforce L2 first-principles purity\n(zero session.execute() calls in L2).\n\nAll methods accept an AsyncSession and return plain dicts or primitives.",
        "functions": [
          {
            "name": "get_workers_read_driver",
            "signature": "(session: AsyncSession) -> WorkersReadDriver",
            "docstring": "Factory function to create a WorkersReadDriver instance.",
            "is_async": false,
            "line": 283
          }
        ],
        "classes": [
          {
            "name": "WorkersReadDriver",
            "docstring": "Async DB read operations for workers domain.",
            "methods": [
              "__init__",
              "verify_run_exists",
              "get_run",
              "list_runs",
              "count_runs",
              "get_active_tenant_budget",
              "get_daily_spend",
              "get_existing_advisory",
              "count_advisories",
              "get_run_for_retry",
              "insert_retry_run"
            ],
            "line": 32
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select",
              "text"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 127,
    "violation_count": 0,
    "gap_count": 1
  },
  "controls": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/controls.py",
    "l2_apis": [
      {
        "file_name": "controls.py",
        "file_path": "backend/app/hoc/api/cus/controls/controls.py",
        "layer": "L2_api",
        "domain": "controls",
        "lines": 271,
        "module_docstring": "Controls API (L2)\n\nProvides control operations:\n- GET /controls (list controls)\n- GET /controls/status (overall status)\n- GET /controls/{id} (get control)\n- PUT /controls/{id} (update control)\n- POST /controls/{id}/enable (enable control)\n- POST /controls/{id}/disable (disable control)\n\nThis is the ONLY facade for control operations.\nAll controls APIs flow through this router.",
        "functions": [
          {
            "name": "list_controls",
            "signature": "(control_type: Optional[str] = Query(None, description='Filter by type'), state: Optional[str] = Query(None, description='Filter by state'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('controls.read')))",
            "docstring": "List controls (GAP-123).\n\nReturns all controls for the tenant.",
            "is_async": true,
            "line": 70
          },
          {
            "name": "get_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('controls.read')))",
            "docstring": "Get overall control status.\n\nReturns summary including killswitch and maintenance mode state.",
            "is_async": true,
            "line": 112
          },
          {
            "name": "get_control",
            "signature": "(control_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('controls.read')))",
            "docstring": "Get a specific control.",
            "is_async": true,
            "line": 139
          },
          {
            "name": "update_control",
            "signature": "(control_id: str, request: UpdateControlRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('controls.write')))",
            "docstring": "Update a control.",
            "is_async": true,
            "line": 168
          },
          {
            "name": "enable_control",
            "signature": "(control_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('controls.admin')))",
            "docstring": "Enable a control.\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 203
          },
          {
            "name": "disable_control",
            "signature": "(control_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('controls.admin')))",
            "docstring": "Disable a control.\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 239
          }
        ],
        "classes": [
          {
            "name": "UpdateControlRequest",
            "docstring": "Request to update a control.",
            "methods": [],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l4_spine": [],
    "l5_engines": [
      {
        "file_name": "cb_sync_wrapper_engine.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/cb_sync_wrapper_engine.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 170,
        "module_docstring": "Thread-safe sync wrapper for async circuit breaker functions.\n\nThis module provides sync-compatible wrappers that safely execute\nasync circuit breaker functions from sync contexts, including when\nan event loop is already running.\n\nWhy this exists:\n- The async circuit breaker functions use asyncpg which requires an event loop\n- Some callers may be sync (e.g., middleware, legacy code)\n- Calling asyncio.run() from a running event loop raises RuntimeError\n- The naive workaround of returning True (disabled) is too conservative\n  and causes false-positive V2 disables\n\nUsage:\n    from app.costsim.cb_sync_wrapper import is_v2_disabled_sync, get_state_sync\n\n    # Safe from any context (sync or async)\n    if is_v2_disabled_sync():\n        return use_v1_only()",
        "functions": [
          {
            "name": "_get_executor",
            "signature": "() -> concurrent.futures.ThreadPoolExecutor",
            "docstring": "Get or create the shared thread pool executor.",
            "is_async": false,
            "line": 55
          },
          {
            "name": "_run_async_in_thread",
            "signature": "(coro, timeout: float = 5.0)",
            "docstring": "Run an async coroutine in a separate thread with its own event loop.\n\nThis is safe to call from any context, including:\n- Sync functions with no event loop\n- Sync functions called from within an async context\n- The main thread of an async application\n\nArgs:\n    coro: The coroutine to run\n    timeout: Maximum time to wait for result\n\nReturns:\n    The result of the coroutine\n\nRaises:\n    TimeoutError: If the operation times out\n    Exception: Any exception raised by the coroutine",
            "is_async": false,
            "line": 63
          },
          {
            "name": "is_v2_disabled_sync",
            "signature": "(timeout: float = 5.0) -> bool",
            "docstring": "Sync wrapper for is_v2_disabled().\n\nSafe to call from any context. Runs the async function in a\nseparate thread with its own event loop.\n\nArgs:\n    timeout: Maximum time to wait for DB query\n\nReturns:\n    True if V2 is disabled, False otherwise\n\nNote:\n    On error, returns False (V2 enabled) to avoid false-positive\n    disables. This is the opposite of the previous conservative\n    approach which returned True on error.",
            "is_async": false,
            "line": 97
          },
          {
            "name": "get_state_sync",
            "signature": "(timeout: float = 5.0)",
            "docstring": "Sync wrapper for get_state().\n\nSafe to call from any context.\n\nArgs:\n    timeout: Maximum time to wait for DB query\n\nReturns:\n    CircuitBreakerState or None on error",
            "is_async": false,
            "line": 136
          },
          {
            "name": "shutdown_executor",
            "signature": "()",
            "docstring": "Shutdown the thread pool executor gracefully.",
            "is_async": false,
            "line": 165
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "concurrent.futures",
            "names": [
              "concurrent.futures"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "controls_facade.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/controls_facade.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 438,
        "module_docstring": "Controls Facade (L4 Domain Logic)\n\nThis facade provides the external interface for control operations.\nAll control APIs MUST use this facade instead of directly importing\ninternal control modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes killswitch and control logic\n- Provides unified access to system controls\n- Single point for audit emission\n\nL2 API Routes (GAP-123):\n- GET /api/v1/controls (list controls)\n- GET /api/v1/controls/{id} (get control)\n- PUT /api/v1/controls/{id} (update control)\n- POST /api/v1/controls/{id}/enable (enable control)\n- POST /api/v1/controls/{id}/disable (disable control)\n- GET /api/v1/controls/status (overall status)\n\nUsage:\n    from app.hoc.cus.controls.L5_engines.controls_facade import get_controls_facade\n\n    facade = get_controls_facade()\n\n    # Get control status\n    status = await facade.get_status(tenant_id=\"...\")",
        "functions": [
          {
            "name": "get_controls_facade",
            "signature": "() -> ControlsFacade",
            "docstring": "Get the controls facade instance.\n\nThis is the recommended way to access control operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    ControlsFacade instance",
            "is_async": false,
            "line": 425
          }
        ],
        "classes": [
          {
            "name": "ControlType",
            "docstring": "Types of controls.",
            "methods": [],
            "line": 60
          },
          {
            "name": "ControlState",
            "docstring": "Control state.",
            "methods": [],
            "line": 69
          },
          {
            "name": "ControlConfig",
            "docstring": "Control configuration.",
            "methods": [
              "to_dict"
            ],
            "line": 77
          },
          {
            "name": "ControlStatusSummary",
            "docstring": "Overall control status summary.",
            "methods": [
              "to_dict"
            ],
            "line": 115
          },
          {
            "name": "ControlsFacade",
            "docstring": "Facade for control operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ncontrol services.\n\nLayer: L4 (Domain Logic)\nCallers: controls.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "_ensure_default_controls",
              "list_controls",
              "get_control",
              "update_control",
              "enable_control",
              "disable_control",
              "get_status"
            ],
            "line": 140
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 55
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "threshold_engine.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/threshold_engine.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 694,
        "module_docstring": "Threshold Decision Engine (L5)\n\nProvides:\n- ThresholdParams: Validated threshold configuration (decision contract)\n- LLMRunThresholdResolver: Resolves effective params using precedence rules\n- LLMRunEvaluator: Evaluates runs against thresholds, determines signals\n- Signal helpers: Create and collect threshold signal records\n\nThis engine owns the DECISION logic:\n- Precedence rules (AGENT > PROJECT > TENANT > GLOBAL)\n- Threshold evaluation (compare metrics to limits)\n- Signal determination (which signals to emit)\n\nThe engine does NOT own:\n- Database queries (delegated to ThresholdDriver in L6)\n- Signal persistence (delegated to L6)\n\nReference: ACTIVITY_PHASE2.5_IMPLEMENTATION_PLAN.md",
        "functions": [
          {
            "name": "create_threshold_signal_record",
            "signature": "(tenant_id: str, run_id: str, state: str, signal: ThresholdSignal, params_used: dict) -> ThresholdSignalRecord",
            "docstring": "Create a threshold signal record for activity domain.\n\nThis creates a record that surfaces in:\n- Activity \u2192 LLM Runs \u2192 Live \u2192 Signals\n- Activity \u2192 LLM Runs \u2192 Completed \u2192 Signals\n\nArgs:\n    tenant_id: Tenant identifier\n    run_id: Run identifier\n    state: Run state (live or completed)\n    signal: The threshold signal triggered\n    params_used: The params that were evaluated against\n\nReturns:\n    ThresholdSignalRecord for persistence/emission",
            "is_async": false,
            "line": 624
          },
          {
            "name": "collect_signals_from_evaluation",
            "signature": "(evaluation: ThresholdEvaluationResult, tenant_id: str, state: str) -> list[ThresholdSignalRecord]",
            "docstring": "Collect all signals from an evaluation result into records.\n\nArgs:\n    evaluation: The evaluation result\n    tenant_id: Tenant identifier\n    state: Run state (live or completed)\n\nReturns:\n    List of ThresholdSignalRecord for persistence",
            "is_async": false,
            "line": 667
          }
        ],
        "classes": [
          {
            "name": "ThresholdParams",
            "docstring": "Validated threshold parameters for LLM run governance.\n\nValidation Rules (Hard Stop):\n- max_execution_time_ms: 1000-300000 (1s to 5min)\n- max_tokens: 256-200000\n- max_cost_usd: 0.01-100.00\n- failure_signal: boolean\n\nNo partial garbage. No unknown keys. No absurd values.",
            "methods": [
              "coerce_decimal_to_float"
            ],
            "line": 84
          },
          {
            "name": "ThresholdParamsUpdate",
            "docstring": "Partial update for threshold params.\nAll fields optional - only provided fields are updated.",
            "methods": [],
            "line": 131
          },
          {
            "name": "ThresholdDriverProtocol",
            "docstring": "Protocol defining the interface for threshold drivers.",
            "methods": [
              "get_active_threshold_limits"
            ],
            "line": 166
          },
          {
            "name": "ThresholdDriverSyncProtocol",
            "docstring": "Protocol defining the interface for sync threshold drivers.",
            "methods": [
              "get_active_threshold_limits"
            ],
            "line": 176
          },
          {
            "name": "LLMRunThresholdResolver",
            "docstring": "Resolves effective threshold params for an LLM run\nusing Policy \u2192 Limit \u2192 Threshold precedence.\n\nResolution order (highest to lowest precedence):\n1. Agent-scoped threshold (scope=AGENT, scope_id=agent_id)\n2. Project-scoped threshold (scope=PROJECT, scope_id=project_id)\n3. Tenant-scoped threshold (scope=TENANT)\n4. Global defaults (DEFAULT_LLM_RUN_PARAMS)\n\nProperties:\n- Deterministic\n- Merge-based (higher precedence overrides)\n- Safe if nothing exists\n\nL4 CONTRACT: This class contains ONLY precedence logic.\nDB queries are delegated to the ThresholdDriver (L6).",
            "methods": [
              "__init__",
              "resolve"
            ],
            "line": 191
          },
          {
            "name": "LLMRunEvaluator",
            "docstring": "Evaluates LLM runs against threshold params.\n\nSupports:\n- Live run evaluation (execution time, tokens)\n- Completed run evaluation (all metrics + failure)\n\nSignals are determined but evaluation is non-blocking.\n\nL4 CONTRACT: Pure evaluation logic, no DB operations.",
            "methods": [
              "__init__",
              "evaluate_live_run",
              "evaluate_completed_run"
            ],
            "line": 291
          },
          {
            "name": "LLMRunThresholdResolverSync",
            "docstring": "Sync version of LLMRunThresholdResolver for worker context.\n\nUses ThresholdDriverSync for DB access since the worker runs\nin a ThreadPoolExecutor which doesn't support async.\n\nL4 CONTRACT: Same precedence logic as async version.",
            "methods": [
              "__init__",
              "resolve"
            ],
            "line": 451
          },
          {
            "name": "LLMRunEvaluatorSync",
            "docstring": "Sync version of LLMRunEvaluator for worker context.\n\nUses LLMRunThresholdResolverSync instead of the async resolver.\n\nL4 CONTRACT: Pure evaluation logic, no DB operations.",
            "methods": [
              "__init__",
              "evaluate_completed_run"
            ],
            "line": 527
          },
          {
            "name": "ThresholdSignalRecord",
            "docstring": "Record of a threshold signal for activity domain.\n\nThis structure is used for:\n- Activity \u2192 LLM Runs \u2192 Live \u2192 Signals\n- Activity \u2192 LLM Runs \u2192 Completed \u2192 Signals",
            "methods": [],
            "line": 607
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional",
              "Protocol"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.threshold_signals",
            "names": [
              "ThresholdEvaluationResult",
              "ThresholdSignal"
            ],
            "is_relative": false,
            "line": 155
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_LLM_RUN_PARAMS",
            "line": 71
          }
        ],
        "all_exports": null
      }
    ],
    "l5_schemas": [
      {
        "file_name": "override_types.py",
        "file_path": "backend/app/hoc/cus/controls/L5_schemas/override_types.py",
        "layer": "L5_schemas",
        "domain": "controls",
        "lines": 47,
        "module_docstring": "Override Types\n\nError classes for limit override operations.\nLives in L5_schemas so L2 can import without violating L2\u2192L6 rules.",
        "functions": [],
        "classes": [
          {
            "name": "LimitOverrideServiceError",
            "docstring": "Base exception for limit override service.",
            "methods": [],
            "line": 16
          },
          {
            "name": "LimitNotFoundError",
            "docstring": "Raised when the target limit does not exist.",
            "methods": [],
            "line": 21
          },
          {
            "name": "OverrideNotFoundError",
            "docstring": "Raised when the override does not exist.",
            "methods": [],
            "line": 26
          },
          {
            "name": "OverrideValidationError",
            "docstring": "Raised when override request validation fails.",
            "methods": [],
            "line": 31
          },
          {
            "name": "StackingAbuseError",
            "docstring": "Raised when attempting to stack overrides on same limit.",
            "methods": [],
            "line": 36
          }
        ],
        "imports": [],
        "constants": [],
        "all_exports": [
          "LimitOverrideServiceError",
          "LimitNotFoundError",
          "OverrideNotFoundError",
          "OverrideValidationError",
          "StackingAbuseError"
        ]
      },
      {
        "file_name": "overrides.py",
        "file_path": "backend/app/hoc/cus/controls/L5_schemas/overrides.py",
        "layer": "L5_schemas",
        "domain": "controls",
        "lines": 188,
        "module_docstring": "Limit Override Schemas (PIN-LIM-05)\n\nRequest and response models for temporary limit increases.\nOverrides allow customers to request and apply temporary limit increases\nwith proper audit trail.",
        "functions": [],
        "classes": [
          {
            "name": "OverrideStatus",
            "docstring": "Override lifecycle status.",
            "methods": [],
            "line": 29
          },
          {
            "name": "LimitOverrideRequest",
            "docstring": "Request model for requesting a temporary limit override.",
            "methods": [
              "validate_override_value"
            ],
            "line": 39
          },
          {
            "name": "LimitOverrideResponse",
            "docstring": "Response model for limit override operations.",
            "methods": [],
            "line": 81
          },
          {
            "name": "OverrideApprovalRequest",
            "docstring": "Request model for approving/rejecting an override.",
            "methods": [
              "validate_rejection_reason"
            ],
            "line": 146
          },
          {
            "name": "OverrideListResponse",
            "docstring": "Response model for listing overrides.",
            "methods": [],
            "line": 176
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_limits.py",
        "file_path": "backend/app/hoc/cus/controls/L5_schemas/policy_limits.py",
        "layer": "L5_schemas",
        "domain": "controls",
        "lines": 190,
        "module_docstring": "Policy Limits Schemas (PIN-LIM-01)\n\nRequest and response models for policy limit CRUD operations.\nEnforces schema contract between API and service layer.",
        "functions": [],
        "classes": [
          {
            "name": "LimitCategoryEnum",
            "docstring": "Limit categories.",
            "methods": [],
            "line": 28
          },
          {
            "name": "LimitScopeEnum",
            "docstring": "Limit scope levels.",
            "methods": [],
            "line": 35
          },
          {
            "name": "LimitEnforcementEnum",
            "docstring": "Limit enforcement behaviors.",
            "methods": [],
            "line": 44
          },
          {
            "name": "ResetPeriodEnum",
            "docstring": "Budget limit reset periods.",
            "methods": [],
            "line": 54
          },
          {
            "name": "CreatePolicyLimitRequest",
            "docstring": "Request model for creating a policy limit.",
            "methods": [
              "validate_reset_period",
              "validate_window_seconds"
            ],
            "line": 62
          },
          {
            "name": "UpdatePolicyLimitRequest",
            "docstring": "Request model for updating a policy limit.",
            "methods": [],
            "line": 131
          },
          {
            "name": "PolicyLimitResponse",
            "docstring": "Response model for policy limit operations.",
            "methods": [],
            "line": 170
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 25
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "simulation.py",
        "file_path": "backend/app/hoc/cus/controls/L5_schemas/simulation.py",
        "layer": "L5_schemas",
        "domain": "controls",
        "lines": 217,
        "module_docstring": "Limit Simulation Schemas (PIN-LIM-04)\n\nRequest and response models for pre-execution limit checks.\nThe simulation endpoint allows dry-run verification against all limits\nbefore actually executing a run.",
        "functions": [],
        "classes": [
          {
            "name": "SimulationDecision",
            "docstring": "Simulation outcome decision.",
            "methods": [],
            "line": 28
          },
          {
            "name": "MessageCode",
            "docstring": "Standardized message codes (no free-text messages).",
            "methods": [],
            "line": 35
          },
          {
            "name": "LimitSimulationRequest",
            "docstring": "Request model for limit simulation (pre-execution check).",
            "methods": [],
            "line": 60
          },
          {
            "name": "LimitCheckResult",
            "docstring": "Result of a single limit check.",
            "methods": [],
            "line": 108
          },
          {
            "name": "HeadroomInfo",
            "docstring": "Remaining headroom before hitting limits.",
            "methods": [],
            "line": 141
          },
          {
            "name": "LimitWarning",
            "docstring": "Warning for soft limit approaching.",
            "methods": [],
            "line": 158
          },
          {
            "name": "LimitSimulationResponse",
            "docstring": "Response model for limit simulation.",
            "methods": [],
            "line": 176
          }
        ],
        "imports": [
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 25
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "threshold_signals.py",
        "file_path": "backend/app/hoc/cus/controls/L5_schemas/threshold_signals.py",
        "layer": "L5_schemas",
        "domain": "controls",
        "lines": 49,
        "module_docstring": "Threshold Signal Types (L5 Schema)\n\nPure types for threshold signal operations.\nExtracted from controls/L5_engines/threshold_engine.py (PIN-507 Law 1)\nso L6 drivers can import types without reaching up to L5 engines.\n\nThese are contracts (types), not policy (logic).",
        "functions": [],
        "classes": [
          {
            "name": "ThresholdSignal",
            "docstring": "Signals emitted when runs breach thresholds.\nThese appear in Activity \u2192 LLM Runs \u2192 Signal panels.",
            "methods": [],
            "line": 24
          },
          {
            "name": "ThresholdEvaluationResult",
            "docstring": "Result of threshold evaluation.",
            "methods": [],
            "line": 37
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 21
          }
        ],
        "constants": [],
        "all_exports": [
          "ThresholdSignal",
          "ThresholdEvaluationResult"
        ]
      }
    ],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "budget_enforcement_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/budget_enforcement_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 124,
        "module_docstring": "Budget Enforcement Driver (L6 Data Access)\n\nHandles database operations for budget enforcement:\n- Fetching halted runs that lack decision records\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_budget_enforcement_driver",
            "signature": "(db_url: Optional[str] = None) -> BudgetEnforcementDriver",
            "docstring": "Get a BudgetEnforcementDriver instance.",
            "is_async": false,
            "line": 122
          }
        ],
        "classes": [
          {
            "name": "BudgetEnforcementDriver",
            "docstring": "L6 Driver for budget enforcement data operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (parsing, emit logic) stay in L4.",
            "methods": [
              "__init__",
              "_get_engine",
              "fetch_pending_budget_halts",
              "dispose"
            ],
            "line": 45
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlalchemy",
            "names": [
              "create_engine",
              "text"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "circuit_breaker_async_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/circuit_breaker_async_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 1079,
        "module_docstring": null,
        "functions": [
          {
            "name": "_get_config",
            "signature": "()",
            "docstring": null,
            "is_async": false,
            "line": 89
          },
          {
            "name": "_get_metrics",
            "signature": "()",
            "docstring": null,
            "is_async": false,
            "line": 94
          },
          {
            "name": "_get_executor",
            "signature": "() -> concurrent.futures.ThreadPoolExecutor",
            "docstring": "Get or create the shared thread pool executor for sync wrappers.",
            "is_async": false,
            "line": 105
          },
          {
            "name": "_run_async_in_thread",
            "signature": "(coro, timeout: float = 5.0)",
            "docstring": "Run an async coroutine in a separate thread with its own event loop.",
            "is_async": false,
            "line": 113
          },
          {
            "name": "_is_v2_disabled_sync",
            "signature": "(timeout: float = 5.0) -> bool",
            "docstring": "Sync wrapper for is_v2_disabled().\n\nSafe to call from any context. Returns False on error to avoid false-positive disables.",
            "is_async": false,
            "line": 128
          },
          {
            "name": "_get_or_create_state",
            "signature": "(session: AsyncSession, lock: bool = False) -> CostSimCBStateModel",
            "docstring": "Get or create circuit breaker state row.\n\nArgs:\n    session: Async database session\n    lock: If True, use SELECT FOR UPDATE to lock the row\n\nReturns:\n    CostSimCBStateModel instance",
            "is_async": true,
            "line": 218
          },
          {
            "name": "is_v2_disabled",
            "signature": "(session: Optional[AsyncSession] = None) -> bool",
            "docstring": "Check if V2 is disabled.\n\nNon-blocking async check that also handles TTL-based auto-recovery.\n\nReturns True if:\n- disabled=True AND disabled_until is None (permanent disable)\n- disabled=True AND disabled_until > now (TTL not expired)\n\nReturns False if:\n- disabled=False\n- disabled=True AND disabled_until <= now (TTL expired, auto-recover)\n\nArgs:\n    session: Async session (L4-owned). Creates temporary read session if None.\n\nReturns:\n    True if V2 is disabled",
            "is_async": true,
            "line": 256
          },
          {
            "name": "_try_auto_recover",
            "signature": "(session: AsyncSession, state_id: int) -> bool",
            "docstring": "Attempt auto-recovery with proper locking to avoid TOCTOU race.\n\nUses SELECT FOR UPDATE to ensure only one worker performs recovery.\nReturns True if recovery was performed (or already done by another worker).\n\nTransaction Boundary: L4 owns begin/commit (PIN-520).\n\nArgs:\n    session: L4-owned async session (already in transaction)\n    state_id: ID of the state row to recover\n\nReturns:\n    True if recovered (or already recovered), False if still disabled",
            "is_async": true,
            "line": 317
          },
          {
            "name": "_auto_recover",
            "signature": "(session: AsyncSession, state: CostSimCBStateModel) -> None",
            "docstring": "Legacy auto-recover function (deprecated).\n\nUse _try_auto_recover() instead for proper locking.",
            "is_async": true,
            "line": 409
          },
          {
            "name": "get_state",
            "signature": "() -> CircuitBreakerState",
            "docstring": "Get current circuit breaker state.",
            "is_async": true,
            "line": 456
          },
          {
            "name": "report_drift",
            "signature": "(session: AsyncSession, drift_score: float, sample_count: int = 1, details: Optional[Dict[str, Any]] = None) -> Optional[Incident]",
            "docstring": "Report drift observation.\n\nIf drift exceeds threshold, trips the circuit breaker.\n\nTransaction Boundary: L4 owns begin/commit (PIN-520).\n\nArgs:\n    session: L4-owned async session (already in transaction)\n    drift_score: Observed drift score (0.0 - 1.0)\n    sample_count: Number of samples in observation\n    details: Additional details\n\nReturns:\n    Incident if circuit breaker tripped, None otherwise",
            "is_async": true,
            "line": 476
          },
          {
            "name": "report_schema_error",
            "signature": "(session: AsyncSession, error_count: int = 1, details: Optional[Dict[str, Any]] = None) -> Optional[Incident]",
            "docstring": "Report schema validation errors.\n\nTransaction Boundary: L4 owns begin/commit (PIN-520).\n\nArgs:\n    session: L4-owned async session (already in transaction)\n    error_count: Number of schema errors\n    details: Error details\n\nReturns:\n    Incident if threshold exceeded, None otherwise",
            "is_async": true,
            "line": 540
          },
          {
            "name": "disable_v2",
            "signature": "(session: AsyncSession, reason: str, disabled_by: str, disabled_until: Optional[datetime] = None) -> Tuple[bool, Optional[Incident]]",
            "docstring": "Manually disable CostSim V2.\n\nIdempotent: returns False if already disabled with same params.\n\nTransaction Boundary: L4 owns begin/commit (PIN-520).\n\nArgs:\n    session: L4-owned async session (already in transaction)\n    reason: Reason for disabling\n    disabled_by: Who disabled (user_id, system, etc.)\n    disabled_until: Optional TTL (None = use default from config)\n\nReturns:\n    Tuple of (state_changed, incident)",
            "is_async": true,
            "line": 580
          },
          {
            "name": "enable_v2",
            "signature": "(session: AsyncSession, enabled_by: str, reason: Optional[str] = None) -> bool",
            "docstring": "Manually enable CostSim V2.\n\nIdempotent: returns False if already enabled.\n\nTransaction Boundary: L4 owns begin/commit (PIN-520).\n\nArgs:\n    session: L4-owned async session (already in transaction)\n    enabled_by: Who enabled (user_id, system, etc.)\n    reason: Optional reason for enabling\n\nReturns:\n    True if state changed, False otherwise",
            "is_async": true,
            "line": 623
          },
          {
            "name": "_trip",
            "signature": "(session: AsyncSession, state: CostSimCBStateModel, reason: str, drift_score: float, sample_count: int, details: Optional[Dict[str, Any]] = None, severity: str = 'P1', disabled_by: str = 'circuit_breaker', disabled_until: Optional[datetime] = None) -> Incident",
            "docstring": "Trip the circuit breaker.\n\nArgs:\n    session: Database session\n    state: Circuit breaker state model\n    reason: Reason for tripping\n    drift_score: Drift score that triggered trip\n    sample_count: Number of samples\n    details: Additional details\n    severity: Alert severity (P1, P2, P3)\n    disabled_by: Who disabled\n    disabled_until: Optional TTL\n\nReturns:\n    Created Incident",
            "is_async": true,
            "line": 696
          },
          {
            "name": "_resolve_incident",
            "signature": "(session: AsyncSession, incident_id: str, resolved_by: str, resolution_notes: str) -> None",
            "docstring": "Resolve an incident.",
            "is_async": true,
            "line": 792
          },
          {
            "name": "get_incidents",
            "signature": "(include_resolved: bool = False, limit: int = 10) -> List[Incident]",
            "docstring": "Get recent incidents.\n\nArgs:\n    include_resolved: Include resolved incidents\n    limit: Maximum incidents to return\n\nReturns:\n    List of incidents",
            "is_async": true,
            "line": 810
          },
          {
            "name": "_enqueue_alert",
            "signature": "(session: AsyncSession, alert_type: str, payload: List[Dict[str, Any]], incident_id: Optional[str] = None) -> None",
            "docstring": "Enqueue alert for reliable delivery.\n\nArgs:\n    session: Database session\n    alert_type: Type of alert (disable, enable, canary_fail)\n    payload: Alertmanager payload\n    incident_id: Associated incident ID",
            "is_async": true,
            "line": 860
          },
          {
            "name": "_build_disable_alert_payload",
            "signature": "(incident: Incident, disabled_until: Optional[datetime]) -> List[Dict[str, Any]]",
            "docstring": "Build Alertmanager payload for disable alert.",
            "is_async": false,
            "line": 888
          },
          {
            "name": "_build_enable_alert_payload",
            "signature": "(enabled_by: str, reason: Optional[str] = None) -> List[Dict[str, Any]]",
            "docstring": "Build Alertmanager payload for enable/resolved alert.",
            "is_async": false,
            "line": 920
          },
          {
            "name": "get_async_circuit_breaker",
            "signature": "() -> AsyncCircuitBreaker",
            "docstring": "Get the global async circuit breaker instance.",
            "is_async": false,
            "line": 1070
          }
        ],
        "classes": [
          {
            "name": "CircuitBreakerState",
            "docstring": "Current state of the circuit breaker.",
            "methods": [
              "to_dict"
            ],
            "line": 152
          },
          {
            "name": "Incident",
            "docstring": "Incident record for circuit breaker trip.",
            "methods": [
              "to_dict"
            ],
            "line": 179
          },
          {
            "name": "AsyncCircuitBreaker",
            "docstring": "Async circuit breaker class for compatibility with existing code.\n\nProvides the same interface as the sync CircuitBreaker but uses\nasync operations internally.",
            "methods": [
              "__init__",
              "is_disabled",
              "is_open",
              "is_closed",
              "get_state",
              "report_drift",
              "report_schema_error",
              "disable_v2",
              "enable_v2",
              "reset",
              "reset_v2",
              "get_incidents"
            ],
            "line": 950
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "concurrent.futures",
            "names": [
              "concurrent.futures"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 73
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "app.db_async",
            "names": [
              "AsyncSessionLocal",
              "async_session_context"
            ],
            "is_relative": false,
            "line": 78
          },
          {
            "module": "app.models.costsim_cb",
            "names": [
              "CostSimAlertQueueModel",
              "CostSimCBIncidentModel",
              "CostSimCBStateModel"
            ],
            "is_relative": false,
            "line": 79
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 28
          },
          {
            "name": "RETRY_POLICY",
            "line": 29
          },
          {
            "name": "CB_NAME",
            "line": 148
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "circuit_breaker_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/circuit_breaker_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 990,
        "module_docstring": null,
        "functions": [
          {
            "name": "_get_config",
            "signature": "()",
            "docstring": null,
            "is_async": false,
            "line": 93
          },
          {
            "name": "create_circuit_breaker",
            "signature": "(session: Session, failure_threshold: Optional[int] = None, drift_threshold: Optional[float] = None, name: str = CB_NAME) -> CircuitBreaker",
            "docstring": "Create CircuitBreaker with required session.\n\nL6 drivers are NOT singletons \u2014 each operation gets its own instance\nbecause the caller owns the session/transaction lifecycle.\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    failure_threshold: Consecutive failures to trip breaker (default from config)\n    drift_threshold: Override drift threshold (default from config)\n    name: Circuit breaker name (default: costsim_v2)\n\nReturns:\n    CircuitBreaker instance bound to the provided session",
            "is_async": false,
            "line": 924
          },
          {
            "name": "is_v2_disabled",
            "signature": "(session: Session) -> bool",
            "docstring": "Check if CostSim V2 is disabled.",
            "is_async": true,
            "line": 959
          },
          {
            "name": "disable_v2",
            "signature": "(session: Session, reason: str, disabled_by: str, disabled_until: Optional[datetime] = None) -> Tuple[bool, Optional[Incident]]",
            "docstring": "Disable CostSim V2.",
            "is_async": true,
            "line": 965
          },
          {
            "name": "enable_v2",
            "signature": "(session: Session, enabled_by: str, reason: Optional[str] = None) -> bool",
            "docstring": "Enable CostSim V2.",
            "is_async": true,
            "line": 980
          }
        ],
        "classes": [
          {
            "name": "CircuitBreakerState",
            "docstring": "Current state of the circuit breaker (in-memory representation).",
            "methods": [
              "to_dict"
            ],
            "line": 103
          },
          {
            "name": "Incident",
            "docstring": "Incident record for circuit breaker trip.",
            "methods": [
              "to_dict"
            ],
            "line": 130
          },
          {
            "name": "CircuitBreaker",
            "docstring": "DB-backed circuit breaker for CostSim V2 auto-disable.\n\nUses PostgreSQL for centralized state management across replicas.\nSends alerts to Alertmanager when state changes.\n\nTransaction Boundary: L6 drivers DO NOT commit.\nThe caller (L5 engine or L4 coordinator) owns the transaction.\nThis driver only calls session.add() \u2014 never session.commit().\n\nUsage:\n    breaker = create_circuit_breaker(session=session)\n\n    # Check before running V2\n    if not await breaker.is_disabled():\n        result = await v2_adapter.simulate(plan)\n\n    # Report drift after comparison\n    incident = await breaker.report_drift(\n        drift_score=0.25,\n        sample_count=100,\n        details={\"kl_divergence\": 0.3}\n    )\n\n    # Manual reset\n    await breaker.reset(reason=\"Fixed V2 model coefficients\", reset_by=\"admin\")",
            "methods": [
              "__init__",
              "_get_or_create_state",
              "is_disabled",
              "_auto_recover",
              "is_open",
              "is_closed",
              "get_state",
              "report_drift",
              "report_schema_error",
              "disable_v2",
              "enable_v2",
              "reset",
              "_trip",
              "_resolve_incident_db",
              "_save_incident_file",
              "get_incidents",
              "_send_alert_disable",
              "_send_alert_enable",
              "_post_alertmanager"
            ],
            "line": 166
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 73
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple",
              "cast"
            ],
            "is_relative": false,
            "line": 78
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 80
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 81
          },
          {
            "module": "app.db",
            "names": [
              "CostSimCBIncident",
              "CostSimCBState",
              "log_status_change"
            ],
            "is_relative": false,
            "line": 83
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 29
          },
          {
            "name": "RETRY_POLICY",
            "line": 30
          },
          {
            "name": "CB_NAME",
            "line": 99
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "killswitch_ops_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/killswitch_ops_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 486,
        "module_docstring": "Killswitch Operations Driver (L6)\n\nPure data access layer for killswitch endpoint operations.\nProvides read operations for:\n- Tenant verification\n- API key verification\n- Killswitch state queries\n- Default guardrails listing\n- Incident listing and detail\n- Incident events (timeline)\n- Proxy call lookup\n\nWrite operations delegate to existing GuardWriteDriver.\n\nReference: PIN-511 (no HOC <-> services imports)",
        "functions": [
          {
            "name": "get_killswitch_ops_driver",
            "signature": "(session: Session) -> KillswitchOpsDriver",
            "docstring": "Get KillswitchOpsDriver instance.\n\nArgs:\n    session: SQLModel session from FastAPI DI\n\nReturns:\n    KillswitchOpsDriver instance",
            "is_async": false,
            "line": 457
          }
        ],
        "classes": [
          {
            "name": "TenantInfoDTO",
            "docstring": "Minimal tenant info for existence check.",
            "methods": [],
            "line": 55
          },
          {
            "name": "ApiKeyInfoDTO",
            "docstring": "API key info for existence check.",
            "methods": [],
            "line": 61
          },
          {
            "name": "KillswitchStateDTO",
            "docstring": "Killswitch state data transfer object.",
            "methods": [],
            "line": 67
          },
          {
            "name": "GuardrailDTO",
            "docstring": "Default guardrail summary.",
            "methods": [],
            "line": 81
          },
          {
            "name": "IncidentSummaryDTO",
            "docstring": "Incident list item.",
            "methods": [],
            "line": 92
          },
          {
            "name": "IncidentDetailDTO",
            "docstring": "Full incident detail with timeline.",
            "methods": [],
            "line": 106
          },
          {
            "name": "IncidentEventDTO",
            "docstring": "Timeline event.",
            "methods": [],
            "line": 123
          },
          {
            "name": "ProxyCallDTO",
            "docstring": "Proxy call data for replay/detail.",
            "methods": [],
            "line": 133
          },
          {
            "name": "KillswitchOpsDriver",
            "docstring": "L6 driver for killswitch endpoint operations.\n\nPure data access - no business logic.\nSync operations for use with sync session from FastAPI.",
            "methods": [
              "__init__",
              "verify_tenant_exists",
              "verify_api_key_exists",
              "get_killswitch_state",
              "get_key_states_for_tenant",
              "list_active_guardrails",
              "list_incidents",
              "get_incident_detail",
              "get_incident_events",
              "_parse_event_data",
              "get_proxy_call"
            ],
            "line": 160
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "select",
              "text"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "DefaultGuardrail",
              "Incident",
              "IncidentEvent",
              "KillSwitchState",
              "ProxyCall"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "KillswitchOpsDriver",
          "get_killswitch_ops_driver",
          "TenantInfoDTO",
          "ApiKeyInfoDTO",
          "KillswitchStateDTO",
          "GuardrailDTO",
          "IncidentSummaryDTO",
          "IncidentDetailDTO",
          "IncidentEventDTO",
          "ProxyCallDTO"
        ]
      },
      {
        "file_name": "killswitch_read_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/killswitch_read_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 236,
        "module_docstring": "Killswitch Read Driver (L6)\n\nPure data access layer for killswitch read operations.\nNo business logic - only query construction and data retrieval.\n\nArchitecture:\n    L3 (Adapter) \u2192 L4 (Engine) \u2192 L6 (this driver) \u2192 Database\n\nOperations:\n- Query killswitch state for tenant\n- Query active guardrails\n- Query incident statistics\n- No mutations (read-only)\n\nReference: PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_killswitch_read_driver",
            "signature": "(session: Optional[Session] = None) -> KillswitchReadDriver",
            "docstring": "Get KillswitchReadDriver instance.\n\nArgs:\n    session: Optional SQLModel session. If not provided, creates one internally.\n\nReturns:\n    KillswitchReadDriver instance",
            "is_async": false,
            "line": 205
          }
        ],
        "classes": [
          {
            "name": "KillswitchStateDTO",
            "docstring": "Killswitch state information.",
            "methods": [],
            "line": 53
          },
          {
            "name": "GuardrailInfoDTO",
            "docstring": "Active guardrail information.",
            "methods": [],
            "line": 61
          },
          {
            "name": "IncidentStatsDTO",
            "docstring": "Incident statistics for a tenant.",
            "methods": [],
            "line": 67
          },
          {
            "name": "KillswitchStatusDTO",
            "docstring": "Complete killswitch status information.",
            "methods": [],
            "line": 74
          },
          {
            "name": "KillswitchReadDriver",
            "docstring": "L6 driver for killswitch read operations.\n\nPure data access - no business logic.\nAll methods require tenant_id for isolation.",
            "methods": [
              "__init__",
              "_get_session",
              "get_killswitch_status",
              "_get_killswitch_state",
              "_get_active_guardrails",
              "_get_incident_stats"
            ],
            "line": 87
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.db",
            "names": [
              "get_session"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "DefaultGuardrail",
              "Incident",
              "KillSwitchState"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "KillswitchReadDriver",
          "get_killswitch_read_driver",
          "CustomerKillswitchReadService",
          "get_customer_killswitch_read_service",
          "KillswitchStateDTO",
          "GuardrailInfoDTO",
          "IncidentStatsDTO",
          "KillswitchStatusDTO"
        ]
      },
      {
        "file_name": "limits_read_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/limits_read_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 322,
        "module_docstring": "Limits Read Driver (L6)\n\nPure data access layer for limits read operations.\nAll SQLAlchemy queries live here. No business logic.",
        "functions": [
          {
            "name": "get_limits_read_driver",
            "signature": "(session: AsyncSession) -> LimitsReadDriver",
            "docstring": "Factory function for LimitsReadDriver.",
            "is_async": false,
            "line": 314
          }
        ],
        "classes": [
          {
            "name": "LimitsReadDriver",
            "docstring": "Read operations for limits.",
            "methods": [
              "__init__",
              "fetch_limits",
              "fetch_limit_by_id",
              "fetch_budget_limits",
              "fetch_limit_breaches_for_run"
            ],
            "line": 33
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitBreach",
              "LimitIntegrity"
            ],
            "is_relative": false,
            "line": 30
          }
        ],
        "constants": [],
        "all_exports": [
          "LimitsReadDriver",
          "get_limits_read_driver"
        ]
      },
      {
        "file_name": "override_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/override_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 295,
        "module_docstring": "Limit Override Driver (PIN-LIM-05)\n\nL6 driver for limit_overrides table. All persistence logic\nfor temporary limit overrides lives here.\n\nL6 contract:\n- Receives AsyncSession from caller (L5 or L4 coordinator)\n- NEVER commits \u2014 caller owns transaction\n- Returns domain objects (LimitOverrideResponse) or raises typed errors",
        "functions": [],
        "classes": [
          {
            "name": "LimitOverrideService",
            "docstring": "Driver for limit override lifecycle.\n\nINVARIANTS:\n- One override per limit (no stacking)\n- Override cannot exceed plan quota cap\n- Max 5 active overrides per tenant\n- All overrides require justification\n\nTransaction contract:\n- All methods receive an AsyncSession\n- No method calls session.commit()\n- Caller (L4 coordinator) owns commit authority",
            "methods": [
              "__init__",
              "request_override",
              "get_override",
              "list_overrides",
              "cancel_override",
              "_get_limit",
              "_to_response"
            ],
            "line": 59
          }
        ],
        "imports": [
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitOverride"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.overrides",
            "names": [
              "LimitOverrideRequest",
              "LimitOverrideResponse",
              "OverrideStatus"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.override_types",
            "names": [
              "LimitOverrideServiceError",
              "LimitNotFoundError",
              "OverrideNotFoundError",
              "OverrideValidationError",
              "StackingAbuseError"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_limits_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/policy_limits_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 131,
        "module_docstring": "Policy Limits Driver\n\nPure data access for policy limits table.\nNo business logic - only DB operations.\n\nAuthority: LIMIT_PERSISTENCE\nTables: limits, limit_integrity",
        "functions": [
          {
            "name": "get_policy_limits_driver",
            "signature": "(session: AsyncSession) -> PolicyLimitsDriver",
            "docstring": "Factory function for PolicyLimitsDriver.",
            "is_async": false,
            "line": 129
          }
        ],
        "classes": [
          {
            "name": "PolicyLimitsDriver",
            "docstring": "Data access driver for policy limits.\n\nINVARIANTS (L6):\n- No business branching\n- No validation\n- No cross-domain calls\n- Pure persistence operations only",
            "methods": [
              "__init__",
              "fetch_limit_by_id",
              "add_limit",
              "add_integrity",
              "create_limit",
              "create_integrity",
              "flush"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "scoped_execution_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/scoped_execution_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 697,
        "module_docstring": "M6: Scoped Execution Context Service (P2FC-4)\n\nPre-execution gate for MEDIUM+ risk recovery actions.\n\nCORE INVARIANT (M6):\n> \"No recovery action may execute without an explicit, bounded execution\n>  scope derived from incident context.\"\n\nThe Scoped Execution primitive provides:\n1. Scope creation with incident binding, cost ceiling, action limits, expiry\n2. Scope-gated execution (no execution without valid scope)\n3. Scope exhaustion tracking (single-use by default)\n4. Scope tampering detection (action must match scope)\n5. Audit trail for all scope operations\n\nScope Model MUST bind:\n- Action type (what can be done)\n- Target (agent / resource)\n- Cost ceiling (tokens / spend)\n- Duration / count limit\n- Intent (why this is allowed)\n\nRelated PINs:\n- PIN-148: Incident lifecycle\n- PIN-161: Evidence completeness (Replay feeds scope)\n- PIN-172: Scoped execution invariant",
        "functions": [
          {
            "name": "get_scope_store",
            "signature": "() -> ScopeStore",
            "docstring": "Get the global scope store.",
            "is_async": false,
            "line": 500
          },
          {
            "name": "create_recovery_scope",
            "signature": "(incident_id: str, action: str, intent: str = '', max_cost_usd: float = 0.5, max_attempts: int = 1, ttl_seconds: int = 300, target_agents: Optional[List[str]] = None, created_by: str = 'system') -> Dict[str, Any]",
            "docstring": "Create a bound execution scope for recovery action.\n\nThis is the gate step (Step A2 in test script).",
            "is_async": true,
            "line": 510
          },
          {
            "name": "execute_with_scope",
            "signature": "(scope_id: str, action: str, incident_id: str, parameters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]",
            "docstring": "Execute a recovery action within a valid scope.\n\nThis enforces all P2FC-4 gates:\n- Scope must exist\n- Scope must not be exhausted/expired\n- Action must match scope's allowed actions\n- Incident must match scope's bound incident",
            "is_async": true,
            "line": 545
          },
          {
            "name": "validate_scope_required",
            "signature": "(incident_id: str, action: str) -> None",
            "docstring": "Validate that execution without scope should fail.\n\nCalled by /recovery/execute when no scope_id provided.\nAlways raises ScopedExecutionRequired.",
            "is_async": true,
            "line": 602
          },
          {
            "name": "requires_scoped_execution",
            "signature": "(risk_threshold: RiskClass = RiskClass.MEDIUM)",
            "docstring": "Decorator to enforce scoped pre-execution for risky recovery actions.\n\nUsage:\n    @requires_scoped_execution(risk_threshold=RiskClass.MEDIUM)\n    async def execute_recovery(action: RecoveryAction):\n        ...\n\nThe decorated function must accept `skip_scope: bool = False` parameter.\nIf skip_scope=True and risk >= threshold, ScopedExecutionRequired is raised.",
            "is_async": false,
            "line": 619
          },
          {
            "name": "test_recovery_scope",
            "signature": "(action_id: str, action_name: str, action_type: str, risk_class: str, parameters: Dict[str, Any], scope_type: str = 'dry_run', scope_fraction: float = 0.1) -> Dict[str, Any]",
            "docstring": "Test a recovery action in scoped execution.\n\nReturns dict with execution result for API response.",
            "is_async": true,
            "line": 659
          }
        ],
        "classes": [
          {
            "name": "RiskClass",
            "docstring": "Risk classification for recovery actions.",
            "methods": [],
            "line": 67
          },
          {
            "name": "ExecutionScope",
            "docstring": "Type of scoped execution.",
            "methods": [],
            "line": 76
          },
          {
            "name": "ScopedExecutionResult",
            "docstring": "Result of a scoped execution test.",
            "methods": [],
            "line": 86
          },
          {
            "name": "RecoveryAction",
            "docstring": "A recovery action to be tested in scoped execution.",
            "methods": [],
            "line": 101
          },
          {
            "name": "ScopedExecutionContext",
            "docstring": "M6 Scoped Execution primitive.\n\nProvides pre-execution testing for recovery actions before global rollout.",
            "methods": [
              "__init__",
              "execute",
              "_dry_run_validate",
              "_execute_scoped",
              "_estimate_cost",
              "_elapsed_ms",
              "_compute_hash"
            ],
            "line": 113
          },
          {
            "name": "ScopedExecutionRequired",
            "docstring": "Raised when a MEDIUM+ risk action is attempted without scoped pre-execution.",
            "methods": [],
            "line": 263
          },
          {
            "name": "ScopeNotFound",
            "docstring": "Raised when a scope ID does not exist.",
            "methods": [],
            "line": 269
          },
          {
            "name": "ScopeExhausted",
            "docstring": "Raised when a scope has been fully consumed.",
            "methods": [],
            "line": 275
          },
          {
            "name": "ScopeExpired",
            "docstring": "Raised when a scope has expired.",
            "methods": [],
            "line": 281
          },
          {
            "name": "ScopeActionMismatch",
            "docstring": "Raised when action does not match scope's allowed actions.",
            "methods": [],
            "line": 287
          },
          {
            "name": "ScopeIncidentMismatch",
            "docstring": "Raised when execution targets a different incident than scope.",
            "methods": [],
            "line": 293
          },
          {
            "name": "BoundExecutionScope",
            "docstring": "A bound execution scope that gates recovery actions.\n\nThis is the core P2FC-4 primitive. Every recovery action MUST have\na valid scope before execution.",
            "methods": [
              "is_valid",
              "can_execute",
              "consume",
              "to_dict"
            ],
            "line": 305
          },
          {
            "name": "ScopeStore",
            "docstring": "Thread-safe in-memory store for execution scopes.\n\nIn production, this would be backed by Redis or PostgreSQL.",
            "methods": [
              "__new__",
              "create_scope",
              "get_scope",
              "get_scopes_for_incident",
              "revoke_scope",
              "cleanup_expired"
            ],
            "line": 405
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "secrets",
            "names": [
              "secrets"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "threading",
            "names": [
              "threading"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "functools",
            "names": [
              "wraps"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 62
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "threshold_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/threshold_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 332,
        "module_docstring": "Threshold Driver (L6)\n\nProvides:\n- LimitSnapshot: Immutable snapshot returned to engines\n- ThresholdDriver: Async DB operations for threshold limits\n- ThresholdDriverSync: Sync DB operations for worker context\n- Signal emission functions for dual console output\n\nThis driver owns the DATA ACCESS logic:\n- Query active threshold limits from database\n- Emit signals to ops_events table\n- Update run risk levels\n\nThe driver does NOT own:\n- Precedence resolution (delegated to L4 engine)\n- Threshold evaluation (delegated to L4 engine)\n- Signal determination (delegated to L4 engine)\n\nReference: ACTIVITY_PHASE2.5_IMPLEMENTATION_PLAN.md",
        "functions": [
          {
            "name": "emit_threshold_signal_sync",
            "signature": "(session: Any, tenant_id: str, run_id: str, state: str, signal: Any, params_used: dict) -> None",
            "docstring": "Emit a threshold signal to ops_events table (sync).\n\nFor use in sync contexts (e.g., worker callbacks).\n\nL6 CONTRACT: Pure DB write, no business logic.\n\nArgs:\n    session: Sync SQLAlchemy Session\n    tenant_id: Tenant identifier\n    run_id: Run identifier\n    state: Run state (live or completed)\n    signal: ThresholdSignal enum value\n    params_used: The params that were evaluated against",
            "is_async": false,
            "line": 259
          }
        ],
        "classes": [
          {
            "name": "LimitSnapshot",
            "docstring": "Immutable snapshot of a Limit record returned to engines.\n\nThis is the boundary contract between L6 (driver) and L5 (engine).\nEngines receive snapshots, not ORM models.\n\nNOTE: This DTO intentionally lives here to avoid L6 importing hoc_spine\n(T0 law tests: no cross-domain imports from L6).",
            "methods": [],
            "line": 69
          },
          {
            "name": "ThresholdDriver",
            "docstring": "Async database driver for threshold limit operations.\n\nL6 CONTRACT:\n- Pure data access, no business logic\n- Returns LimitSnapshot objects, not ORM models\n- No precedence resolution (that's L4)",
            "methods": [
              "__init__",
              "get_active_threshold_limits",
              "get_threshold_limit_by_scope"
            ],
            "line": 94
          },
          {
            "name": "ThresholdDriverSync",
            "docstring": "Sync database driver for threshold limit operations.\n\nUsed in worker context (ThreadPoolExecutor) which doesn't support async.\n\nL6 CONTRACT:\n- Pure data access, no business logic\n- Returns LimitSnapshot objects\n- Uses raw SQL for sync compatibility",
            "methods": [
              "__init__",
              "get_active_threshold_limits"
            ],
            "line": 194
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "uuid",
            "names": [
              "uuid_module"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "sqlmodel",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitCategory",
              "LimitStatus"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 19,
    "violation_count": 0,
    "gap_count": 1
  },
  "logs": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/logs.py",
    "l2_apis": [
      {
        "file_name": "cost_intelligence.py",
        "file_path": "backend/app/hoc/api/cus/logs/cost_intelligence.py",
        "layer": "L2_api",
        "domain": "logs",
        "lines": 903,
        "module_docstring": "M26 Cost Intelligence API\n\nCore Objective:\nEvery token spent is attributable to tenant -> user -> feature -> request.\nEvery anomaly must trigger an action, not a chart.\n\nThis is not reporting. This is CONTROL.\n\nL2 PURITY:\n- No session.execute() calls in this file\n- All DB operations routed through L4 bridge -> L5 engine -> L6 driver\n- L2 is thin: validation, response mapping, and routing only",
        "functions": [
          {
            "name": "_get_cost_write_service",
            "signature": "(session)",
            "docstring": "Get cost write service via L4 analytics bridge (PIN-520 compliance).",
            "is_async": false,
            "line": 51
          },
          {
            "name": "_get_cost_intelligence_engine",
            "signature": "(session)",
            "docstring": "Get cost intelligence engine via L4 logs bridge (L2 purity migration).",
            "is_async": false,
            "line": 57
          },
          {
            "name": "get_tenant_id",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID')) -> str",
            "docstring": "Extract tenant_id from query parameter.",
            "is_async": false,
            "line": 63
          },
          {
            "name": "create_feature_tag",
            "signature": "(data: FeatureTagCreate, tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> FeatureTagResponse",
            "docstring": "Register a new feature tag.\n\nFeature tags are MANDATORY for cost attribution.\nNo tag -> request defaulted to 'unclassified' (and flagged).",
            "is_async": true,
            "line": 306
          },
          {
            "name": "list_feature_tags",
            "signature": "(include_inactive: bool = False, tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> List[FeatureTagResponse]",
            "docstring": "List all feature tags for the tenant.",
            "is_async": true,
            "line": 355
          },
          {
            "name": "update_feature_tag",
            "signature": "(tag: str, data: FeatureTagUpdate, tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> FeatureTagResponse",
            "docstring": "Update a feature tag.",
            "is_async": true,
            "line": 381
          },
          {
            "name": "record_cost",
            "signature": "(data: CostRecordCreate, tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> dict",
            "docstring": "Record a cost entry.\n\nThis is called internally after each LLM invocation.\nFeature tag validation: if tag doesn't exist, default to 'unclassified'.",
            "is_async": true,
            "line": 424
          },
          {
            "name": "get_cost_dashboard",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostDashboard",
            "docstring": "Get complete cost dashboard.\n\nIf a CTO can't answer \"what burned money yesterday?\" in 10 seconds, this failed.",
            "is_async": true,
            "line": 469
          },
          {
            "name": "get_cost_summary",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostSummary",
            "docstring": "Get cost summary for the period.",
            "is_async": true,
            "line": 540
          },
          {
            "name": "get_costs_by_feature",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostByFeatureEnvelope",
            "docstring": "Get cost breakdown by feature tag.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 576
          },
          {
            "name": "get_costs_by_user",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostByUserEnvelope",
            "docstring": "Get cost breakdown by user with anomaly detection.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 611
          },
          {
            "name": "get_costs_by_model",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostByModelEnvelope",
            "docstring": "Get cost breakdown by model.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 646
          },
          {
            "name": "get_anomalies",
            "signature": "(days: int = Query(7, ge=1, le=90), include_resolved: bool = False, tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostAnomaliesEnvelope",
            "docstring": "Get detected cost anomalies.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 680
          },
          {
            "name": "get_projection",
            "signature": "(lookback_days: int = Query(7, ge=1, le=30), forecast_days: int = Query(7, ge=1, le=30), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostProjection",
            "docstring": "Get cost projection based on historical data.",
            "is_async": true,
            "line": 709
          },
          {
            "name": "create_or_update_budget",
            "signature": "(data: BudgetCreate, tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> BudgetResponse",
            "docstring": "Create or update a budget.",
            "is_async": true,
            "line": 727
          },
          {
            "name": "list_budgets",
            "signature": "(tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> List[BudgetResponse]",
            "docstring": "List all budgets for the tenant.",
            "is_async": true,
            "line": 784
          },
          {
            "name": "trigger_anomaly_detection",
            "signature": "(request: AnomalyDetectionRequest = AnomalyDetectionRequest(), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> AnomalyDetectionResponse",
            "docstring": "Trigger anomaly detection for this tenant.\n\nThis endpoint:\n1. Scans for USER_SPIKE, FEATURE_SPIKE, BUDGET_WARNING, BUDGET_EXCEEDED\n2. Persists detected anomalies to database\n3. Optionally escalates HIGH/CRITICAL anomalies to M25 incident loop\n\nM25 Integration:\nWhen escalate_to_m25=True (default), HIGH and CRITICAL anomalies are:\n- Converted to M25 incidents\n- Processed through the M25 loop (Pattern -> Recovery -> Policy -> Routing)\n- Resulting in automated policies to prevent future cost anomalies",
            "is_async": true,
            "line": 835
          }
        ],
        "classes": [
          {
            "name": "FeatureTagCreate",
            "docstring": "Create a new feature tag.",
            "methods": [],
            "line": 78
          },
          {
            "name": "FeatureTagResponse",
            "docstring": "Feature tag response.",
            "methods": [],
            "line": 87
          },
          {
            "name": "FeatureTagUpdate",
            "docstring": "Update a feature tag.",
            "methods": [],
            "line": 101
          },
          {
            "name": "CostRecordCreate",
            "docstring": "Record a cost entry.",
            "methods": [],
            "line": 110
          },
          {
            "name": "CostProvenance",
            "docstring": "Provenance metadata for cost interpretation panels.",
            "methods": [],
            "line": 124
          },
          {
            "name": "CostSummary",
            "docstring": "Cost summary for a period.",
            "methods": [],
            "line": 133
          },
          {
            "name": "CostByFeature",
            "docstring": "Cost breakdown by feature.",
            "methods": [],
            "line": 149
          },
          {
            "name": "CostByUser",
            "docstring": "Cost breakdown by user.",
            "methods": [],
            "line": 161
          },
          {
            "name": "CostByModel",
            "docstring": "Cost breakdown by model.",
            "methods": [],
            "line": 172
          },
          {
            "name": "CostProjection",
            "docstring": "Cost projection for upcoming period.",
            "methods": [],
            "line": 183
          },
          {
            "name": "CostAnomalyResponse",
            "docstring": "Cost anomaly response.",
            "methods": [],
            "line": 197
          },
          {
            "name": "AnalyticsProvenance",
            "docstring": "Provenance envelope for analytics interpretation panels.\n\nSDSR requires provenance metadata on all interpretation panels to ensure\nthe UI can correctly display how data was derived.",
            "methods": [],
            "line": 221
          },
          {
            "name": "CostByUserEnvelope",
            "docstring": "Envelope response for cost by user with provenance.",
            "methods": [],
            "line": 234
          },
          {
            "name": "CostByModelEnvelope",
            "docstring": "Envelope response for cost by model with provenance.",
            "methods": [],
            "line": 241
          },
          {
            "name": "CostByFeatureEnvelope",
            "docstring": "Envelope response for cost by feature with provenance.",
            "methods": [],
            "line": 248
          },
          {
            "name": "CostAnomaliesEnvelope",
            "docstring": "Envelope response for cost anomalies with provenance.",
            "methods": [],
            "line": 255
          },
          {
            "name": "CostDashboard",
            "docstring": "Complete cost dashboard data.",
            "methods": [],
            "line": 262
          },
          {
            "name": "BudgetCreate",
            "docstring": "Create or update a budget.",
            "methods": [],
            "line": 273
          },
          {
            "name": "BudgetResponse",
            "docstring": "Budget response.",
            "methods": [],
            "line": 284
          },
          {
            "name": "AnomalyDetectionRequest",
            "docstring": "Request to trigger anomaly detection.",
            "methods": [],
            "line": 819
          },
          {
            "name": "AnomalyDetectionResponse",
            "docstring": "Response from anomaly detection.",
            "methods": [],
            "line": 825
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_sync_session_dep"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges.analytics_bridge",
            "names": [
              "get_analytics_bridge"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges.logs_bridge",
            "names": [
              "get_logs_bridge"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard_logs.py",
        "file_path": "backend/app/hoc/api/cus/logs/guard_logs.py",
        "layer": "L2_api",
        "domain": "logs",
        "lines": 215,
        "module_docstring": "Guard Logs API - Customer Console Logs Endpoint\n\nThis router provides endpoints for the Customer Console (guard.agenticverz.com).\nFocused on LOG VISIBILITY - customers can see their execution audit trail.\n\nEndpoints:\n- GET  /guard/logs          - List customer logs (execution audit trail)\n- GET  /guard/logs/export   - Export logs (JSON or CSV)\n- GET  /guard/logs/{id}     - Log detail with steps\n\nPIN-281 Promotion:\n- L4\u2192L3: customer_logs_adapter.py (boundary adapter)\n- L3\u2192L2: This file (API route)\n\nRule: One adapter per route. No business logic here.",
        "functions": [
          {
            "name": "list_logs",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID (required)'), agent_id: Optional[str] = Query(None, description='Filter by agent ID'), status: Optional[str] = Query(None, description='Filter by status (running, completed, failed)'), from_date: Optional[str] = Query(None, description='Filter from date (ISO format)'), to_date: Optional[str] = Query(None, description='Filter to date (ISO format)'), limit: int = Query(50, le=100, description='Page size (max 100)'), offset: int = Query(0, ge=0, description='Pagination offset'))",
            "docstring": "List execution logs for customer.\n\nReturns paginated list of customer logs (execution audit trail).\nCustomer can only see their own tenant's logs (enforced by adapter).\n\nThis endpoint:\n- Shows what ran / is running\n- Provides step counts and status\n- Enables filtering by agent, status, date range\n- Supports pagination\n\nNo internal fields exposed (cost_cents, hashes, replay data).\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 67
          },
          {
            "name": "export_logs",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID (required)'), format: str = Query('json', description='Export format (json, csv)'), from_date: Optional[str] = Query(None, description='Filter from date (ISO format)'), to_date: Optional[str] = Query(None, description='Filter to date (ISO format)'), limit: int = Query(1000, le=10000, description='Max records (max 10000)'))",
            "docstring": "Export logs for customer.\n\nReturns logs in requested format (JSON or CSV).\nCustomer can only export their own tenant's logs (enforced by adapter).\n\nSupports:\n- JSON format (default)\n- CSV format for spreadsheet import\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 116
          },
          {
            "name": "get_log",
            "signature": "(log_id: str, tenant_id: str = Query(..., description='Tenant ID (required)'))",
            "docstring": "Get log detail with execution steps.\n\nReturns detailed view of a single log including all steps.\nCustomer can only see their own tenant's logs (enforced by adapter).\n\nThis endpoint:\n- Shows step-by-step execution trace\n- Shows outcome categories and codes\n- Shows duration per step\n- No cost or internal hash data\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 178
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi.responses",
            "names": [
              "StreamingResponse"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.adapters.customer_logs_adapter",
            "names": [
              "CustomerLogDetail",
              "CustomerLogListResponse",
              "get_customer_logs_adapter"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "verify_console_token"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "tenants.py",
        "file_path": "backend/app/hoc/api/cus/logs/tenants.py",
        "layer": "L2_api",
        "domain": "logs",
        "lines": 677,
        "module_docstring": "Tenant & API Key Management API (M21)\n\nProvides:\n- Tenant management endpoints\n- API key CRUD operations\n- Usage and quota queries\n- Worker registry endpoints",
        "functions": [
          {
            "name": "get_services",
            "signature": "(session = Depends(get_sync_session_dep))",
            "docstring": "Get worker registry and session for route handlers.",
            "is_async": false,
            "line": 52
          },
          {
            "name": "_tenant_op",
            "signature": "(session, tenant_id: str, method: str, **kwargs)",
            "docstring": "Execute a tenant operation via L4 registry (account.tenant).",
            "is_async": true,
            "line": 68
          },
          {
            "name": "_api_keys_op",
            "signature": "(session, tenant_id: str, method: str, **kwargs)",
            "docstring": "Execute an API keys operation via L4 registry (api_keys.write).",
            "is_async": true,
            "line": 81
          },
          {
            "name": "_maybe_advance_to_api_key_created",
            "signature": "(tenant_id: str) -> None",
            "docstring": "PIN-399: Trigger onboarding state transition on first API key creation.\n\nCalled after successful API key creation to potentially advance\na tenant from IDENTITY_VERIFIED to API_KEY_CREATED.\n\nTRIGGER: First successful API key creation.\n\nThis is idempotent - if tenant is already at or past API_KEY_CREATED,\nthis is a no-op.",
            "is_async": true,
            "line": 97
          },
          {
            "name": "get_current_tenant",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Get information about the current tenant (from API key).",
            "is_async": true,
            "line": 286
          },
          {
            "name": "get_tenant_usage",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Get usage summary for the current tenant.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 317
          },
          {
            "name": "check_run_quota",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Check if the tenant can create a new run.",
            "is_async": true,
            "line": 348
          },
          {
            "name": "check_token_quota",
            "signature": "(tokens_needed: int = Query(default=10000, ge=1), ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Check if the tenant has token budget for an operation.",
            "is_async": true,
            "line": 372
          },
          {
            "name": "list_api_keys",
            "signature": "(include_revoked: bool = False, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "List all API keys for the current tenant.\n\nRequires admin permission.",
            "is_async": true,
            "line": 400
          },
          {
            "name": "create_api_key",
            "signature": "(request: APIKeyCreateRequest, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Create a new API key for the current tenant.\n\n**Important:** The full API key is only shown once in this response.\nStore it securely!\n\nRequires admin permission.",
            "is_async": true,
            "line": 439
          },
          {
            "name": "revoke_api_key",
            "signature": "(key_id: str, reason: str = Query(default='Manual revocation'), ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Revoke an API key.\n\nThe key cannot be un-revoked. Create a new key instead.\n\nRequires admin permission.",
            "is_async": true,
            "line": 491
          },
          {
            "name": "list_workers",
            "signature": "(status: Optional[str] = None, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "List all available workers.",
            "is_async": true,
            "line": 522
          },
          {
            "name": "list_available_workers_for_tenant",
            "signature": "(include_disabled: bool = False, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "List workers available to the current tenant with their configurations.",
            "is_async": true,
            "line": 535
          },
          {
            "name": "get_worker_details",
            "signature": "(worker_id: str, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Get detailed information about a specific worker.",
            "is_async": true,
            "line": 551
          },
          {
            "name": "get_worker_config",
            "signature": "(worker_id: str, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Get the effective configuration for a worker (tenant overrides merged with defaults).",
            "is_async": true,
            "line": 567
          },
          {
            "name": "set_worker_config",
            "signature": "(worker_id: str, request: WorkerConfigRequest, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Set tenant-specific configuration for a worker.\n\nRequires admin permission.",
            "is_async": true,
            "line": 583
          },
          {
            "name": "list_runs",
            "signature": "(limit: int = Query(default=20, ge=1, le=100), offset: int = Query(default=0, ge=0), status: Optional[str] = None, worker_id: Optional[str] = None, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "List runs for the current tenant.",
            "is_async": true,
            "line": 623
          },
          {
            "name": "tenant_health",
            "signature": "()",
            "docstring": "Health check for tenant system.",
            "is_async": true,
            "line": 663
          }
        ],
        "classes": [
          {
            "name": "TenantResponse",
            "docstring": "Tenant information response.",
            "methods": [],
            "line": 140
          },
          {
            "name": "APIKeyCreateRequest",
            "docstring": "Request to create an API key.",
            "methods": [],
            "line": 159
          },
          {
            "name": "APIKeyResponse",
            "docstring": "API key information (without the actual key).",
            "methods": [],
            "line": 170
          },
          {
            "name": "APIKeyCreatedResponse",
            "docstring": "Response when creating an API key (includes the key once).",
            "methods": [],
            "line": 183
          },
          {
            "name": "AnalyticsProvenance",
            "docstring": "Provenance envelope for analytics interpretation panels.\n\nSDSR requires provenance metadata on all interpretation panels to ensure\nthe UI can correctly display how data was derived.",
            "methods": [],
            "line": 189
          },
          {
            "name": "UsageSummaryResponse",
            "docstring": "Usage summary for a tenant with provenance for SDSR ANALYTICS domain.",
            "methods": [],
            "line": 202
          },
          {
            "name": "WorkerSummaryResponse",
            "docstring": "Worker summary information.",
            "methods": [],
            "line": 212
          },
          {
            "name": "WorkerDetailResponse",
            "docstring": "Detailed worker information.",
            "methods": [],
            "line": 225
          },
          {
            "name": "WorkerConfigRequest",
            "docstring": "Request to configure a worker for a tenant.",
            "methods": [],
            "line": 236
          },
          {
            "name": "WorkerConfigResponse",
            "docstring": "Worker configuration response.",
            "methods": [],
            "line": 246
          },
          {
            "name": "RunHistoryItem",
            "docstring": "Run history item.",
            "methods": [],
            "line": 257
          },
          {
            "name": "QuotaCheckResponse",
            "docstring": "Quota check response.",
            "methods": [],
            "line": 272
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "status"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_sync_session_dep"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges",
            "names": [
              "get_integrations_driver_bridge"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict",
              "wrap_list"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "traces.py",
        "file_path": "backend/app/hoc/api/cus/logs/traces.py",
        "layer": "L2_api",
        "domain": "logs",
        "lines": 910,
        "module_docstring": "Trace Query API\nM8 Deliverable: Trace storage, indexing, and query endpoints\n\nProvides REST API for:\n- Listing and searching traces\n- Getting trace details\n- Finding traces by root_hash (for replay verification)\n- Comparing traces for determinism validation\n- RBAC-protected access via JWT/OIDC\n- PII redaction on storage",
        "functions": [
          {
            "name": "get_current_user",
            "signature": "(request: Request, token: TokenPayload = Depends(_jwt_auth)) -> User",
            "docstring": "Get current authenticated user from JWT token.\n\nSupports:\n- Bearer JWT tokens (OIDC/Keycloak)\n- X-API-Key header (legacy/backwards compatible)\n- Development tokens (dev:xxx prefix)",
            "is_async": true,
            "line": 115
          },
          {
            "name": "require_role",
            "signature": "(user: User, role: str) -> bool",
            "docstring": "Check if user has required role.",
            "is_async": false,
            "line": 127
          },
          {
            "name": "get_trace_store",
            "signature": "() -> TraceStoreType",
            "docstring": "Get the trace store instance.",
            "is_async": false,
            "line": 139
          },
          {
            "name": "list_traces",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant ID'), agent_id: Optional[str] = Query(None, description='Filter by agent ID'), status: Optional[str] = Query(None, description='Filter by status'), root_hash: Optional[str] = Query(None, description='Filter by root hash'), plan_hash: Optional[str] = Query(None, description='Filter by plan hash'), seed: Optional[int] = Query(None, description='Filter by random seed'), from_date: Optional[str] = Query(None, description='Filter from date (ISO8601)'), to_date: Optional[str] = Query(None, description='Filter to date (ISO8601)'), limit: int = Query(100, ge=1, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "List and search traces with optional filters.\n\nRBAC: Users can only see traces from their tenant unless admin.",
            "is_async": true,
            "line": 249
          },
          {
            "name": "store_trace",
            "signature": "(request: StoreTraceRequest, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Store a client-provided trace.\n\nApplies PII redaction before storage.",
            "is_async": true,
            "line": 316
          },
          {
            "name": "list_all_mismatches",
            "signature": "(window: Optional[str] = Query(None, description='Time window (e.g., 24h, 7d)'), status: Optional[str] = Query(None, regex='^(open|resolved)$', description='Filter by status'), limit: int = Query(100, le=500, description='Max results'))",
            "docstring": "List all trace mismatches across the system.\n\nREAD-ONLY endpoint for observability. No side effects.\nReturns mismatches with summary counts.\n\nAuth: OBSERVER-safe (SDSR compatible)",
            "is_async": true,
            "line": 368
          },
          {
            "name": "get_trace",
            "signature": "(run_id: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Get a complete trace by run ID.\n\nRBAC: Users can only access their tenant's traces.",
            "is_async": true,
            "line": 407
          },
          {
            "name": "get_trace_by_hash",
            "signature": "(root_hash: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Get a trace by its deterministic root hash.\n\nUseful for replay verification.",
            "is_async": true,
            "line": 465
          },
          {
            "name": "compare_traces",
            "signature": "(run_id1: str, run_id2: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Compare two traces for deterministic equality.\n\nCompares root_hash and step hashes to verify replay parity.",
            "is_async": true,
            "line": 521
          },
          {
            "name": "delete_trace",
            "signature": "(run_id: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Delete a trace by run ID.\n\nRBAC: Requires admin or operator role.",
            "is_async": true,
            "line": 626
          },
          {
            "name": "cleanup_old_traces",
            "signature": "(days: int = Query(30, ge=1, le=365, description='Delete traces older than N days'), store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Delete traces older than specified number of days.\n\nRBAC: Requires admin role.",
            "is_async": true,
            "line": 651
          },
          {
            "name": "check_idempotency",
            "signature": "(idempotency_key: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Check if an idempotency key has been executed.\n\nReturns execution status and output if found.",
            "is_async": true,
            "line": 677
          },
          {
            "name": "bulk_report_mismatches",
            "signature": "(mismatch_ids: List[str] = Query(..., description='List of mismatch IDs to link'), github_issue: bool = Query(True, description='Create a GitHub issue for all'), user: User = Depends(get_current_user))",
            "docstring": "Create a single GitHub issue for multiple mismatches.\n\nUseful when a replay causes multiple step mismatches that should be tracked together.\n\nRBAC: Requires admin or operator role.",
            "is_async": true,
            "line": 733
          },
          {
            "name": "report_mismatch",
            "signature": "(trace_id: str, payload: MismatchReport, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Report a replay mismatch for operator review.\n\nThis endpoint:\n1. Records the mismatch in the database\n2. Optionally creates a GitHub issue or sends a Slack notification\n3. Returns the mismatch ID for tracking\n\nRBAC: Requires authenticated user. Only allows reporting mismatches for user's tenant.",
            "is_async": true,
            "line": 777
          },
          {
            "name": "list_trace_mismatches",
            "signature": "(trace_id: str, user: User = Depends(get_current_user))",
            "docstring": "List all mismatches reported for a trace.",
            "is_async": true,
            "line": 835
          },
          {
            "name": "resolve_mismatch",
            "signature": "(trace_id: str, mismatch_id: str, resolution_note: Optional[str] = Query(None, description='Optional note about the resolution'), user: User = Depends(get_current_user))",
            "docstring": "Mark a mismatch as resolved.\n\nRBAC: Requires admin or operator role.",
            "is_async": true,
            "line": 871
          }
        ],
        "classes": [
          {
            "name": "User",
            "docstring": "User model for RBAC - wraps JWT TokenPayload for backwards compatibility.",
            "methods": [
              "__init__",
              "has_role",
              "from_token"
            ],
            "line": 83
          },
          {
            "name": "TraceSummaryResponse",
            "docstring": "Trace summary for list views.",
            "methods": [],
            "line": 155
          },
          {
            "name": "TraceStepResponse",
            "docstring": "Individual trace step.",
            "methods": [],
            "line": 175
          },
          {
            "name": "TraceDetailResponse",
            "docstring": "Full trace with all steps.",
            "methods": [],
            "line": 196
          },
          {
            "name": "TraceListResponse",
            "docstring": "Paginated trace list.",
            "methods": [],
            "line": 217
          },
          {
            "name": "TraceCompareResponse",
            "docstring": "Result of comparing two traces.",
            "methods": [],
            "line": 226
          },
          {
            "name": "StoreTraceRequest",
            "docstring": "Request to store a client-provided trace.",
            "methods": [],
            "line": 236
          },
          {
            "name": "MismatchReport",
            "docstring": "Report a replay mismatch for operator review.",
            "methods": [],
            "line": 711
          },
          {
            "name": "MismatchResponse",
            "docstring": "Response after reporting a mismatch.",
            "methods": [],
            "line": 721
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request",
              "Response",
              "status"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.jwt_auth",
            "names": [
              "JWTAuthDependency",
              "JWTConfig",
              "TokenPayload"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_async_session_context",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.traces.redact",
            "names": [
              "redact_trace_data"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.handlers.traces_handler",
            "names": [
              "register_traces_handlers"
            ],
            "is_relative": false,
            "line": 66
          }
        ],
        "constants": [
          {
            "name": "USE_POSTGRES",
            "line": 43
          }
        ],
        "all_exports": null
      }
    ],
    "l4_spine": [],
    "l5_engines": [
      {
        "file_name": "audit_evidence.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/audit_evidence.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 671,
        "module_docstring": "Module: audit_evidence\nPurpose: Emit compliance-grade audit for MCP tool calls.\n\nWires:\n    - Source: app/services/mcp/policy_mapper.py (policy decisions)\n    - Source: app/services/mcp/server_registry.py (server/tool info)\n    - Target: app/events (event bus) / audit storage\n\nThis module:\n    1. Emits audit events for all MCP tool invocations\n    2. Records policy decisions for compliance\n    3. Captures input/output for forensic analysis\n    4. Provides tamper-evident audit trail\n\nAcceptance Criteria:\n    - AC-143-01: All tool invocations are audited\n    - AC-143-02: Policy decisions are recorded\n    - AC-143-03: Audit events are tamper-evident\n    - AC-143-04: Sensitive data is redacted\n    - AC-143-05: Events include full context",
        "functions": [
          {
            "name": "_hash_value",
            "signature": "(value: Any) -> str",
            "docstring": "Hash a value for audit purposes.",
            "is_async": false,
            "line": 170
          },
          {
            "name": "_contains_sensitive",
            "signature": "(key: str) -> bool",
            "docstring": "Check if key name suggests sensitive data.",
            "is_async": false,
            "line": 178
          },
          {
            "name": "_redact_sensitive",
            "signature": "(data: Dict[str, Any]) -> Dict[str, Any]",
            "docstring": "Redact sensitive fields from data for logging.",
            "is_async": false,
            "line": 184
          },
          {
            "name": "get_mcp_audit_emitter",
            "signature": "() -> MCPAuditEmitter",
            "docstring": "Get or create the singleton MCPAuditEmitter.\n\nReturns:\n    MCPAuditEmitter instance",
            "is_async": false,
            "line": 628
          },
          {
            "name": "configure_mcp_audit_emitter",
            "signature": "(publisher: Optional[Any] = None) -> MCPAuditEmitter",
            "docstring": "Configure the singleton MCPAuditEmitter.\n\nArgs:\n    publisher: Event publisher to use\n\nReturns:\n    Configured MCPAuditEmitter",
            "is_async": false,
            "line": 644
          },
          {
            "name": "reset_mcp_audit_emitter",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 668
          }
        ],
        "classes": [
          {
            "name": "MCPAuditEventType",
            "docstring": "Types of MCP audit events.",
            "methods": [],
            "line": 56
          },
          {
            "name": "MCPAuditEvent",
            "docstring": "Compliance-grade audit event for MCP operations.\n\nContains full context for forensic analysis and compliance reporting.\nIncludes integrity hash for tamper detection.",
            "methods": [
              "__post_init__",
              "_compute_integrity_hash",
              "to_dict",
              "verify_integrity"
            ],
            "line": 72
          },
          {
            "name": "MCPAuditEmitter",
            "docstring": "Emitter for compliance-grade MCP audit events.\n\nThis service:\n1. Emits audit events to event bus\n2. Maintains chain of audit events (previous hash)\n3. Redacts sensitive data\n4. Provides forensic context\n\nINVARIANT: All tool invocations must be audited.",
            "methods": [
              "__init__",
              "_generate_event_id",
              "emit_tool_requested",
              "emit_tool_allowed",
              "emit_tool_denied",
              "emit_tool_started",
              "emit_tool_completed",
              "emit_tool_failed",
              "emit_server_registered",
              "emit_server_unregistered",
              "_emit",
              "_get_publisher"
            ],
            "line": 205
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [
          {
            "name": "SENSITIVE_PATTERNS",
            "line": 153
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "audit_ledger_engine.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/audit_ledger_engine.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 226,
        "module_docstring": "Audit Ledger Service (Sync)\n\nPURPOSE:\n    Provides sync methods to write governance events to the AuditLedger table.\n    This is the APPEND-ONLY immutable governance action log.\n\nIMPLEMENTATION NOTES:\n    Created as part of SWEEP-03 Batch 3 to provide sync audit ledger\n    operations for incident_write_engine.py which uses sync sessions.\n\nINVARIANTS:\n    - All writes are INSERT only (no UPDATE, no DELETE)\n    - Each write is atomic within the caller's transaction\n    - Events use canonical AuditEventType values",
        "functions": [
          {
            "name": "get_audit_ledger_service",
            "signature": "(session: 'Session') -> AuditLedgerService",
            "docstring": "Get an AuditLedgerService instance.\n\nArgs:\n    session: Sync database session\n\nReturns:\n    AuditLedgerService instance",
            "is_async": false,
            "line": 206
          }
        ],
        "classes": [
          {
            "name": "AuditLedgerService",
            "docstring": "Sync service for writing to the audit ledger.\n\nL5 CONTRACT:\n- Pure database writes, no business logic\n- All methods are sync (for use with sqlmodel Session)\n- Writes happen within caller's transaction",
            "methods": [
              "__init__",
              "_emit",
              "incident_acknowledged",
              "incident_resolved",
              "incident_manually_closed"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional",
              "TYPE_CHECKING"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.domain_enums",
            "names": [
              "ActorType",
              "AuditEntityType",
              "AuditEventType"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": [
          "AuditLedgerService",
          "get_audit_ledger_service"
        ]
      },
      {
        "file_name": "audit_reconciler.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/audit_reconciler.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 322,
        "module_docstring": "Audit Reconciler\n\nPerforms four-way validation of expectations vs acknowledgments:\n\n1. expected \u2212 acked \u2192 missing (audit alert)\n2. acked \u2212 expected \u2192 drift (unexpected action)\n3. missing finalization \u2192 stale run (liveness violation)\n4. expectations without deadline \u2192 invalid contract\n\nThis is the core of the Runtime Audit Contract (RAC).\n\nUsage:\n    reconciler = get_audit_reconciler()\n    result = reconciler.reconcile(run_id)\n\n    if not result.is_clean:\n        # Handle issues\n        if result.has_missing:\n            alert_missing_actions(result.missing_actions)\n        if result.stale_run:\n            alert_stale_run(run_id)",
        "functions": [
          {
            "name": "get_audit_reconciler",
            "signature": "(store: Optional[AuditStore] = None) -> AuditReconciler",
            "docstring": "Get the audit reconciler singleton.\n\nArgs:\n    store: Optional audit store (only used on first call)\n\nReturns:\n    AuditReconciler instance",
            "is_async": false,
            "line": 309
          }
        ],
        "classes": [
          {
            "name": "AuditReconciler",
            "docstring": "Reconciles expectations with acknowledgments.\n\nThis is the heart of the RAC system. It performs set operations\nto identify:\n- Missing actions (expected but not acked)\n- Drift actions (acked but not expected)\n- Stale runs (finalize_run never acked)\n\nLayer: L4 (Domain Logic)\nCallers: ROK (L5), Scheduler (L5)",
            "methods": [
              "__init__",
              "reconcile",
              "check_deadline_violations",
              "get_run_audit_summary",
              "_record_metrics"
            ],
            "line": 96
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Set",
              "Tuple"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "prometheus_client",
            "names": [
              "Counter",
              "Histogram"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.rac_models",
            "names": [
              "AuditAction",
              "AuditDomain",
              "AuditExpectation",
              "AuditStatus",
              "DomainAck",
              "ReconciliationResult"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.audit_store",
            "names": [
              "AuditStore",
              "get_audit_store"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [
          {
            "name": "RECONCILIATION_TOTAL",
            "line": 66
          },
          {
            "name": "MISSING_ACTIONS_TOTAL",
            "line": 72
          },
          {
            "name": "DRIFT_ACTIONS_TOTAL",
            "line": 78
          },
          {
            "name": "STALE_RUNS_TOTAL",
            "line": 84
          },
          {
            "name": "RECONCILIATION_DURATION",
            "line": 89
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "certificate.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/certificate.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 386,
        "module_docstring": "M23 Certificate Service - Cryptographic Evidence of Deterministic Replay\n\nUses M4 HMAC infrastructure to create signed certificates that prove:\n1. Policy decisions were evaluated at a specific time\n2. Replay validation passed at a specific determinism level\n3. No tampering occurred between original call and validation\n\nCertificate Structure:\n- Certificate ID (UUID)\n- Original call metadata\n- Replay validation result\n- HMAC signature (using M4 infrastructure)\n- Timestamp and expiry\n\nUsage:\n    from app.hoc.cus.logs.L5_engines.certificate import CertificateService, CertificateRequest\n\n    service = CertificateService()\n    cert = service.create_certificate(\n        call_id=\"abc123\",\n        validation_result=replay_result,\n        level=DeterminismLevel.LOGICAL,\n    )\n\n    # Verify later\n    is_valid = service.verify_certificate(cert)",
        "functions": [],
        "classes": [
          {
            "name": "CertificateType",
            "docstring": "Types of certificates that can be issued.",
            "methods": [],
            "line": 62
          },
          {
            "name": "CertificatePayload",
            "docstring": "The signed payload of a certificate.",
            "methods": [
              "to_dict",
              "canonical_json"
            ],
            "line": 71
          },
          {
            "name": "Certificate",
            "docstring": "A signed certificate proving deterministic replay or policy evaluation.",
            "methods": [
              "to_dict",
              "to_json",
              "from_dict"
            ],
            "line": 131
          },
          {
            "name": "CertificateService",
            "docstring": "Service for creating and verifying cryptographic certificates.\n\nUses M4 HMAC infrastructure (same secret as golden file signing).",
            "methods": [
              "__init__",
              "_sign",
              "_verify_signature",
              "create_replay_certificate",
              "create_policy_audit_certificate",
              "verify_certificate",
              "export_certificate"
            ],
            "line": 180
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.hoc.cus.logs.L5_engines.replay_determinism",
            "names": [
              "DeterminismLevel",
              "ReplayResult"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [],
        "all_exports": [
          "CertificateService",
          "Certificate",
          "CertificatePayload",
          "CertificateType"
        ]
      },
      {
        "file_name": "completeness_checker.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/completeness_checker.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 518,
        "module_docstring": "Module: completeness_checker\nPurpose: Validate evidence bundle completeness before PDF generation.\n\nEvidence PDF exports require specific fields for SOC2 compliance.\nThis module validates that all required fields are present and\nnon-empty before allowing PDF generation.\n\nRequired Fields (Standard):\n    - incident_id, tenant_id, run_id, trace_id\n    - policy_snapshot_id, termination_reason\n    - total_steps, total_tokens, total_cost_cents\n\nSOC2 Required Fields (Enhanced):\n    - control_mappings, attestation_statement\n    - compliance_period_start, compliance_period_end\n\nExports:\n    - EvidenceCompletenessError: Raised when evidence is incomplete\n    - EvidenceCompletenessChecker: Main checker class\n    - check_evidence_completeness: Quick helper function\n    - ensure_evidence_completeness: Helper that raises on incomplete",
        "functions": [
          {
            "name": "check_evidence_completeness",
            "signature": "(bundle: Any, export_type: str = 'evidence', validation_enabled: bool = True, strict_mode: bool = False) -> CompletenessCheckResponse",
            "docstring": "Quick helper to check evidence completeness.\n\nArgs:\n    bundle: Evidence bundle to check\n    export_type: Type of export\n    validation_enabled: Whether validation is enforced\n    strict_mode: Whether recommended fields are required\n\nReturns:\n    CompletenessCheckResponse with validation result",
            "is_async": false,
            "line": 471
          },
          {
            "name": "ensure_evidence_completeness",
            "signature": "(bundle: Any, export_type: str = 'evidence', validation_enabled: bool = True, strict_mode: bool = False) -> None",
            "docstring": "Quick helper to ensure evidence completeness or raise error.\n\nArgs:\n    bundle: Evidence bundle to validate\n    export_type: Type of export\n    validation_enabled: Whether validation is enforced\n    strict_mode: Whether recommended fields are required\n\nRaises:\n    EvidenceCompletenessError: If incomplete and validation enabled",
            "is_async": false,
            "line": 496
          }
        ],
        "classes": [
          {
            "name": "CompletenessCheckResult",
            "docstring": "Result of a completeness check.",
            "methods": [],
            "line": 47
          },
          {
            "name": "EvidenceCompletenessError",
            "docstring": "Raised when evidence bundle is incomplete for PDF generation.\n\nThis error indicates that required fields are missing\nand the PDF cannot be generated without them.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 89
          },
          {
            "name": "CompletenessCheckResponse",
            "docstring": "Response from a completeness check.",
            "methods": [
              "to_dict"
            ],
            "line": 121
          },
          {
            "name": "EvidenceCompletenessChecker",
            "docstring": "Checks evidence bundle completeness before PDF generation.\n\nGAP-027: Ensure evidence PDFs contain all required fields for SOC2.\n\nThe checker validates that all required fields are present\nand non-empty before allowing PDF generation.\n\nUsage:\n    checker = EvidenceCompletenessChecker(validation_enabled=True)\n\n    # Before generating PDF\n    checker.ensure_complete(bundle, \"evidence\")\n\n    # Or check without raising\n    response = checker.check(bundle, \"evidence\")\n    if not response.is_complete and response.validation_enabled:\n        handle_incomplete_evidence()",
            "methods": [
              "__init__",
              "from_governance_config",
              "validation_enabled",
              "strict_mode",
              "get_required_fields",
              "get_field_value",
              "is_field_present",
              "check",
              "ensure_complete",
              "should_allow_export",
              "get_completeness_summary"
            ],
            "line": 147
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "FrozenSet",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cost_intelligence_engine.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/cost_intelligence_engine.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 438,
        "module_docstring": "Cost Intelligence Engine (L5)\n\nBusiness logic for cost intelligence operations.\n\nResponsibilities:\n- Orchestrates L6 driver calls\n- Applies business logic (anomaly thresholds, trend analysis)\n- Computes derived metrics (percentages, projections)\n- NO direct database access (delegates to L6)\n\nOperations:\n- Get cost summary with budget calculations\n- Get cost breakdowns with percentages\n- Get anomalies\n- Get cost projections with trend analysis\n- Get current spend for budgets",
        "functions": [
          {
            "name": "get_cost_intelligence_engine",
            "signature": "(driver: CostIntelligenceSyncDriver) -> CostIntelligenceEngine",
            "docstring": "Get cost intelligence engine instance for the given (session-bound) driver.",
            "is_async": false,
            "line": 430
          }
        ],
        "classes": [
          {
            "name": "CostIntelligenceEngine",
            "docstring": "L5 engine for cost intelligence operations.\n\nContains business logic; delegates DB access to L6 driver.",
            "methods": [
              "__init__",
              "check_feature_tag_exists",
              "list_feature_tags",
              "get_feature_tag",
              "get_active_feature_tag",
              "update_feature_tag",
              "get_cost_summary",
              "get_total_cost",
              "get_costs_by_feature",
              "get_costs_by_user",
              "get_costs_by_model",
              "get_recent_anomalies",
              "get_cost_projection",
              "list_budgets",
              "get_budget_by_type",
              "create_budget",
              "update_budget",
              "get_current_spend"
            ],
            "line": 48
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.logs.L6_drivers.cost_intelligence_sync_driver",
            "names": [
              "CostIntelligenceSyncDriver"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [],
        "all_exports": [
          "CostIntelligenceEngine",
          "get_cost_intelligence_engine"
        ]
      },
      {
        "file_name": "evidence_facade.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/evidence_facade.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 570,
        "module_docstring": "Evidence Facade (L5 Domain Engine)\n\nThis facade provides the external interface for evidence chain and export operations.\nAll evidence APIs MUST use this facade instead of directly importing\ninternal evidence modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes evidence chain management\n- Provides unified access to evidence export\n- Single point for audit emission\n\nL2 API Routes (GAP-104, GAP-105):\n- GET /api/v1/evidence/chains (list evidence chains)\n- GET /api/v1/evidence/chains/{id} (get evidence chain)\n- POST /api/v1/evidence/chains (create evidence chain)\n- GET /api/v1/evidence/chains/{id}/verify (verify chain integrity)\n- POST /api/v1/evidence/export (export evidence)\n- GET /api/v1/evidence/exports/{id} (get export status)\n\nUsage:\n    from app.hoc.cus.logs.L5_engines.evidence_facade import get_evidence_facade\n\n    facade = get_evidence_facade()\n\n    # List evidence chains\n    chains = await facade.list_chains(tenant_id=\"...\")\n\n    # Export evidence\n    export = await facade.create_export(tenant_id=\"...\", chain_id=\"...\")",
        "functions": [
          {
            "name": "get_evidence_facade",
            "signature": "() -> EvidenceFacade",
            "docstring": "Get the evidence facade instance.\n\nThis is the recommended way to access evidence operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    EvidenceFacade instance",
            "is_async": false,
            "line": 557
          }
        ],
        "classes": [
          {
            "name": "EvidenceType",
            "docstring": "Evidence types.",
            "methods": [],
            "line": 66
          },
          {
            "name": "ExportFormat",
            "docstring": "Export formats.",
            "methods": [],
            "line": 75
          },
          {
            "name": "ExportStatus",
            "docstring": "Export status.",
            "methods": [],
            "line": 82
          },
          {
            "name": "EvidenceLink",
            "docstring": "A link in an evidence chain.",
            "methods": [
              "to_dict"
            ],
            "line": 91
          },
          {
            "name": "EvidenceChain",
            "docstring": "An evidence chain.",
            "methods": [
              "to_dict"
            ],
            "line": 113
          },
          {
            "name": "VerificationResult",
            "docstring": "Result of chain verification.",
            "methods": [
              "to_dict"
            ],
            "line": 139
          },
          {
            "name": "EvidenceExport",
            "docstring": "Evidence export request.",
            "methods": [
              "to_dict"
            ],
            "line": 157
          },
          {
            "name": "EvidenceFacade",
            "docstring": "Facade for evidence chain and export operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nevidence services.\n\nLayer: L4 (Domain Logic)\nCallers: evidence.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "list_chains",
              "get_chain",
              "create_chain",
              "add_evidence",
              "verify_chain",
              "_create_link",
              "_hash_data",
              "create_export",
              "get_export",
              "list_exports"
            ],
            "line": 184
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "evidence_report.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/evidence_report.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 1164,
        "module_docstring": "Evidence Report Generator - Legal-Grade PDF Export\n\nGenerates deterministic, verifiable PDF evidence reports for AI incidents.\nThis document must survive legal review, audit, and hostile questioning.\n\nFeatures:\n- Cover page with metadata\n- Executive summary for legal/leadership\n- Factual reconstruction (pure evidence)\n- Policy evaluation record\n- Decision timeline (deterministic trace)\n- Replay verification with hash matching\n- Counterfactual prevention proof\n- Remediation & controls\n- Legal attestation with verification signature",
        "functions": [
          {
            "name": "generate_evidence_report",
            "signature": "(incident_id: str, tenant_id: str, tenant_name: str, user_id: str, product_name: str, model_id: str, timestamp: str, user_input: str, context_data: Dict[str, Any], ai_output: str, policy_results: List[Dict[str, Any]], timeline_events: List[Dict[str, Any]], replay_result: Optional[Dict[str, Any]] = None, prevention_result: Optional[Dict[str, Any]] = None, root_cause: str = 'Policy enforcement gap: system asserted fact when required data was NULL.', impact_assessment: Optional[List[str]] = None, certificate: Optional[Dict[str, Any]] = None, severity: str = 'HIGH', status: str = 'RESOLVED', is_demo: bool = True) -> bytes",
            "docstring": "Convenience function to generate an evidence report.\n\nReturns:\n    PDF file as bytes",
            "is_async": false,
            "line": 1089
          }
        ],
        "classes": [
          {
            "name": "CertificateEvidence",
            "docstring": "M23: Certificate data for cryptographic proof.",
            "methods": [],
            "line": 60
          },
          {
            "name": "IncidentEvidence",
            "docstring": "Evidence data for an incident.",
            "methods": [],
            "line": 77
          },
          {
            "name": "EvidenceReportGenerator",
            "docstring": "Generates legal-grade PDF evidence reports.\n\nThe report is structured for:\n- Legal review\n- Audit compliance\n- Executive briefing\n- Technical verification",
            "methods": [
              "__init__",
              "_setup_custom_styles",
              "generate",
              "_add_footer",
              "_build_incident_snapshot",
              "_build_cover_page",
              "_build_executive_summary",
              "_build_factual_reconstruction",
              "_build_policy_evaluation",
              "_build_decision_timeline",
              "_build_replay_verification",
              "_build_certificate_section",
              "_build_prevention_proof",
              "_build_remediation",
              "_build_legal_attestation",
              "_compute_hash",
              "_compute_report_hash"
            ],
            "line": 101
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "io",
            "names": [
              "io"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "reportlab.lib",
            "names": [
              "colors"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "reportlab.lib.enums",
            "names": [
              "TA_CENTER"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "reportlab.lib.pagesizes",
            "names": [
              "letter"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "reportlab.lib.styles",
            "names": [
              "ParagraphStyle",
              "getSampleStyleSheet"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "reportlab.lib.units",
            "names": [
              "inch"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "reportlab.platypus",
            "names": [
              "HRFlowable",
              "PageBreak",
              "Paragraph",
              "SimpleDocTemplate",
              "Spacer",
              "Table",
              "TableStyle"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "logs_facade.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/logs_facade.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 1407,
        "module_docstring": "Logs Domain Facade (L5)\n\nUnified facade for all logs domain operations:\n- LLM_RUNS: envelope, trace, governance, replay, export\n- SYSTEM_LOGS: snapshot, telemetry, events, replay, audit\n- AUDIT: identity, authorization, access, integrity, exports\n\nAll responses include EvidenceMetadata per INV-LOG-META-001.\n\nL5 CONTRACT:\n- NO sqlalchemy imports\n- NO direct database queries\n- Delegates all data access to L6 LogsDomainStore",
        "functions": [
          {
            "name": "get_logs_facade",
            "signature": "() -> LogsFacade",
            "docstring": "Get the singleton LogsFacade instance.",
            "is_async": false,
            "line": 1356
          }
        ],
        "classes": [
          {
            "name": "SourceDomain",
            "docstring": "Source domain for evidence metadata.",
            "methods": [],
            "line": 64
          },
          {
            "name": "Origin",
            "docstring": "Origin of the record.",
            "methods": [],
            "line": 74
          },
          {
            "name": "EvidenceMetadataResult",
            "docstring": "Global metadata contract for all Logs responses.",
            "methods": [],
            "line": 90
          },
          {
            "name": "LLMRunRecordResult",
            "docstring": "Single LLM run record.",
            "methods": [],
            "line": 130
          },
          {
            "name": "LLMRunRecordsResult",
            "docstring": "Response envelope for LLM run records.",
            "methods": [],
            "line": 150
          },
          {
            "name": "TraceStepResult",
            "docstring": "Individual trace step.",
            "methods": [],
            "line": 160
          },
          {
            "name": "LLMRunEnvelopeResult",
            "docstring": "O1: Canonical immutable run record.",
            "methods": [],
            "line": 173
          },
          {
            "name": "LLMRunTraceResult",
            "docstring": "O2: Step-by-step trace.",
            "methods": [],
            "line": 194
          },
          {
            "name": "GovernanceEventResult",
            "docstring": "Policy interaction event.",
            "methods": [],
            "line": 205
          },
          {
            "name": "LLMRunGovernanceResult",
            "docstring": "O3: Policy interaction trace.",
            "methods": [],
            "line": 218
          },
          {
            "name": "ReplayEventResult",
            "docstring": "Replay window event.",
            "methods": [],
            "line": 228
          },
          {
            "name": "LLMRunReplayResult",
            "docstring": "O4: 60-second replay window.",
            "methods": [],
            "line": 239
          },
          {
            "name": "LLMRunExportResult",
            "docstring": "O5: Export metadata.",
            "methods": [],
            "line": 251
          },
          {
            "name": "SystemRecordResult",
            "docstring": "Single system record entry.",
            "methods": [],
            "line": 262
          },
          {
            "name": "SystemRecordsResult",
            "docstring": "Response envelope for system records.",
            "methods": [],
            "line": 277
          },
          {
            "name": "SystemSnapshotResult",
            "docstring": "O1: Environment snapshot.",
            "methods": [],
            "line": 287
          },
          {
            "name": "TelemetryStubResult",
            "docstring": "O2: Telemetry stub response.",
            "methods": [],
            "line": 301
          },
          {
            "name": "SystemEventResult",
            "docstring": "System event record.",
            "methods": [],
            "line": 314
          },
          {
            "name": "SystemEventsResult",
            "docstring": "O3: Infra events affecting run.",
            "methods": [],
            "line": 328
          },
          {
            "name": "SystemReplayResult",
            "docstring": "O4: Infra replay window.",
            "methods": [],
            "line": 338
          },
          {
            "name": "SystemAuditResult",
            "docstring": "O5: Infra attribution record.",
            "methods": [],
            "line": 349
          },
          {
            "name": "AuditLedgerItemResult",
            "docstring": "Single audit ledger entry.",
            "methods": [],
            "line": 358
          },
          {
            "name": "AuditLedgerDetailResult",
            "docstring": "Audit ledger entry with state snapshots.",
            "methods": [],
            "line": 372
          },
          {
            "name": "AuditLedgerListResult",
            "docstring": "Response envelope for audit ledger.",
            "methods": [],
            "line": 389
          },
          {
            "name": "IdentityEventResult",
            "docstring": "Identity lifecycle event.",
            "methods": [],
            "line": 399
          },
          {
            "name": "AuditIdentityResult",
            "docstring": "O1: Identity lifecycle.",
            "methods": [],
            "line": 410
          },
          {
            "name": "AuthorizationDecisionResult",
            "docstring": "Authorization decision record.",
            "methods": [],
            "line": 419
          },
          {
            "name": "AuditAuthorizationResult",
            "docstring": "O2: Access decisions.",
            "methods": [],
            "line": 432
          },
          {
            "name": "AccessEventResult",
            "docstring": "Log access event.",
            "methods": [],
            "line": 441
          },
          {
            "name": "AuditAccessResult",
            "docstring": "O3: Log access audit.",
            "methods": [],
            "line": 454
          },
          {
            "name": "IntegrityCheckResult",
            "docstring": "Integrity verification record.",
            "methods": [],
            "line": 463
          },
          {
            "name": "AuditIntegrityResult",
            "docstring": "O4: Tamper detection.",
            "methods": [],
            "line": 473
          },
          {
            "name": "ExportRecordResult",
            "docstring": "Export record.",
            "methods": [],
            "line": 481
          },
          {
            "name": "AuditExportsResult",
            "docstring": "O5: Compliance exports.",
            "methods": [],
            "line": 495
          },
          {
            "name": "LogsFacade",
            "docstring": "Unified facade for all Logs domain operations.\n\nL4 CONTRACT:\n- Composition only - delegates to L6 driver\n- NO sqlalchemy imports\n- NO direct DB queries",
            "methods": [
              "__init__",
              "list_llm_run_records",
              "get_llm_run_envelope",
              "get_llm_run_trace",
              "get_llm_run_governance",
              "get_llm_run_replay",
              "get_llm_run_export",
              "list_system_records",
              "get_system_snapshot",
              "get_system_telemetry",
              "get_system_events",
              "get_system_replay",
              "get_system_audit",
              "list_audit_entries",
              "get_audit_entry",
              "get_audit_identity",
              "get_audit_authorization",
              "get_audit_access",
              "get_audit_integrity",
              "get_audit_exports",
              "_snapshot_to_record_result"
            ],
            "line": 508
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.logs.L6_drivers.logs_domain_store",
            "names": [
              "AuditLedgerSnapshot",
              "LLMRunSnapshot",
              "LogsDomainStore",
              "LogExportSnapshot",
              "QueryResult",
              "SystemRecordSnapshot",
              "TraceStepSnapshot",
              "get_logs_domain_store"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": [
          "LogsFacade",
          "get_logs_facade",
          "SourceDomain",
          "Origin",
          "EvidenceMetadataResult",
          "LLMRunRecordResult",
          "LLMRunRecordsResult",
          "TraceStepResult",
          "LLMRunEnvelopeResult",
          "LLMRunTraceResult",
          "GovernanceEventResult",
          "LLMRunGovernanceResult",
          "ReplayEventResult",
          "LLMRunReplayResult",
          "LLMRunExportResult",
          "SystemRecordResult",
          "SystemRecordsResult",
          "SystemSnapshotResult",
          "TelemetryStubResult",
          "SystemEventResult",
          "SystemEventsResult",
          "SystemReplayResult",
          "SystemAuditResult",
          "AuditLedgerItemResult",
          "AuditLedgerDetailResult",
          "AuditLedgerListResult",
          "IdentityEventResult",
          "AuditIdentityResult",
          "AuthorizationDecisionResult",
          "AuditAuthorizationResult",
          "AccessEventResult",
          "AuditAccessResult",
          "IntegrityCheckResult",
          "AuditIntegrityResult",
          "ExportRecordResult",
          "AuditExportsResult"
        ]
      },
      {
        "file_name": "logs_read_engine.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/logs_read_engine.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 215,
        "module_docstring": "Logs Read Engine (L5)\n\nThis service provides all READ operations for the Logs/Traces domain.\nIt sits between L3 (CustomerLogsAdapter) and L6 (PostgresTraceStore).\n\nL3 (Adapter) \u2192 L4 (this service) \u2192 L6 (PostgresTraceStore)\n\nResponsibilities:\n- Query traces with tenant isolation\n- Get trace details\n- Get trace counts\n- Search traces with filters\n- No write operations (writes go through runtime)\n\nReference: PIN-281 (L3 Adapter Closure - PHASE 1)",
        "functions": [
          {
            "name": "get_logs_read_service",
            "signature": "() -> LogsReadService",
            "docstring": "Factory function to get LogsReadService instance.\n\nThis is the ONLY way L3 should obtain a logs read service.",
            "is_async": false,
            "line": 200
          }
        ],
        "classes": [
          {
            "name": "LogsReadService",
            "docstring": "L4 service for logs/trace read operations.\n\nProvides tenant-scoped, bounded reads for the Logs domain.\nAll L3 adapters must use this service for log reads.",
            "methods": [
              "__init__",
              "_get_store",
              "search_traces",
              "get_trace",
              "get_trace_count",
              "get_trace_by_root_hash",
              "list_traces"
            ],
            "line": 51
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.logs.L5_engines.traces_models",
            "names": [
              "TraceRecord",
              "TraceSummary"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.logs.L6_drivers.pg_store",
            "names": [
              "PostgresTraceStore",
              "get_postgres_trace_store"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": [
          "LogsReadService",
          "get_logs_read_service"
        ]
      },
      {
        "file_name": "mapper.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/mapper.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 273,
        "module_docstring": "Module: mapper\nPurpose: Map incidents and evidence to SOC2 controls.\n\nProvides intelligent mapping of incident categories and evidence\nto the appropriate SOC2 Trust Service Criteria controls.\n\nExports:\n    - SOC2ControlMapper: Maps incidents to controls\n    - get_control_mappings_for_incident: Main entry point",
        "functions": [
          {
            "name": "get_control_mappings_for_incident",
            "signature": "(incident_category: str, incident_data: dict[str, Any]) -> list[dict[str, Any]]",
            "docstring": "Get SOC2 control mappings for an incident (GAP-025 main entry point).\n\nThis is the primary function for obtaining SOC2 control mappings\nfor incident exports and compliance reporting.\n\nArgs:\n    incident_category: Category of the incident\n    incident_data: Incident data dict\n\nReturns:\n    List of control mapping dicts suitable for API responses",
            "is_async": false,
            "line": 254
          }
        ],
        "classes": [
          {
            "name": "SOC2ControlMapper",
            "docstring": "Maps incidents to relevant SOC2 controls.\n\nProvides intelligent mapping based on incident category,\nseverity, and available evidence.\n\nGAP-025: Complete SOC2 control objective mapping.",
            "methods": [
              "__init__",
              "map_incident_to_controls",
              "_create_mapping",
              "_determine_compliance_status",
              "get_all_applicable_controls"
            ],
            "line": 87
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.control_registry",
            "names": [
              "SOC2ComplianceStatus",
              "SOC2Control",
              "SOC2ControlMapping",
              "SOC2ControlRegistry",
              "get_control_registry"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "pdf_renderer.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/pdf_renderer.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 683,
        "module_docstring": "PDF Renderer Engine\n\nRenders export bundles to PDF format for compliance exports,\nexecutive debriefs, and evidence documentation.\n\nKey Responsibilities:\n1. Render EvidenceBundle to detailed PDF\n2. Render SOC2Bundle with control attestations\n3. Render ExecutiveDebriefBundle for leadership\n\nUses reportlab for PDF generation (same library as evidence_report.py).",
        "functions": [
          {
            "name": "get_pdf_renderer",
            "signature": "() -> PDFRenderer",
            "docstring": "Get or create PDFRenderer singleton.",
            "is_async": false,
            "line": 678
          }
        ],
        "classes": [
          {
            "name": "PDFRenderer",
            "docstring": "Render export bundles to PDF format.",
            "methods": [
              "__init__",
              "_setup_styles",
              "render_evidence_pdf",
              "render_soc2_pdf",
              "render_executive_debrief_pdf",
              "_build_evidence_cover",
              "_build_evidence_summary",
              "_build_trace_timeline",
              "_build_policy_section",
              "_build_integrity_section",
              "_build_soc2_cover",
              "_build_control_mappings",
              "_build_attestation",
              "_build_exec_cover",
              "_build_exec_summary",
              "_build_recommendations",
              "_build_exec_metrics"
            ],
            "line": 59
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "io",
            "names": [
              "io"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "reportlab.lib",
            "names": [
              "colors"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "reportlab.lib.enums",
            "names": [
              "TA_CENTER",
              "TA_LEFT"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "reportlab.lib.pagesizes",
            "names": [
              "letter"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "reportlab.lib.styles",
            "names": [
              "ParagraphStyle",
              "getSampleStyleSheet"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "reportlab.lib.units",
            "names": [
              "inch"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "reportlab.platypus",
            "names": [
              "HRFlowable",
              "PageBreak",
              "Paragraph",
              "SimpleDocTemplate",
              "Spacer",
              "Table",
              "TableStyle"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "redact.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/redact.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 267,
        "module_docstring": "PII Redaction Utility for Trace Storage\nM8 Deliverable: Secure trace storage with PII masking\n\nRedacts sensitive data from traces before storage:\n- Passwords, API keys, tokens\n- Credit card numbers\n- Email addresses\n- Custom patterns via configuration",
        "functions": [
          {
            "name": "redact_json_string",
            "signature": "(json_str: str) -> str",
            "docstring": "Apply PII redaction patterns to a JSON string.\n\nArgs:\n    json_str: JSON string to redact\n\nReturns:\n    Redacted JSON string",
            "is_async": false,
            "line": 108
          },
          {
            "name": "redact_dict",
            "signature": "(data: dict[str, Any], depth: int = 0, max_depth: int = 20) -> dict[str, Any]",
            "docstring": "Recursively redact sensitive fields in a dictionary.\n\nArgs:\n    data: Dictionary to redact\n    depth: Current recursion depth\n    max_depth: Maximum recursion depth\n\nReturns:\n    Redacted dictionary (new copy)",
            "is_async": false,
            "line": 124
          },
          {
            "name": "redact_list",
            "signature": "(data: list[Any], depth: int = 0, max_depth: int = 20) -> list[Any]",
            "docstring": "Recursively redact sensitive fields in a list.",
            "is_async": false,
            "line": 157
          },
          {
            "name": "redact_string_value",
            "signature": "(value: str) -> str",
            "docstring": "Redact sensitive patterns in a string value.",
            "is_async": false,
            "line": 176
          },
          {
            "name": "redact_trace_data",
            "signature": "(trace: dict[str, Any]) -> dict[str, Any]",
            "docstring": "Redact PII from a complete trace object.\n\nThis is the main entry point for trace redaction.\nCreates a deep copy to avoid modifying the original.\n\nArgs:\n    trace: Trace object to redact\n\nReturns:\n    Redacted trace (new copy)",
            "is_async": false,
            "line": 200
          },
          {
            "name": "is_sensitive_field",
            "signature": "(field_name: str) -> bool",
            "docstring": "Check if a field name indicates sensitive data.",
            "is_async": false,
            "line": 255
          },
          {
            "name": "add_sensitive_field",
            "signature": "(field_name: str) -> None",
            "docstring": "Add a custom field name to the sensitive fields set.",
            "is_async": false,
            "line": 260
          },
          {
            "name": "add_redaction_pattern",
            "signature": "(pattern: str, replacement: str) -> None",
            "docstring": "Add a custom redaction pattern.",
            "is_async": false,
            "line": 265
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "copy",
            "names": [
              "copy"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [
          {
            "name": "PII_PATTERNS",
            "line": 44
          },
          {
            "name": "SENSITIVE_FIELD_NAMES",
            "line": 79
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "replay_determinism.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/replay_determinism.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 498,
        "module_docstring": "Replay Determinism Service - Defines and Enforces Determinism Semantics\n\nWatchpoint #2: Replay Determinism Across Model Versions\n\nThis service addresses the fundamental tension between:\n- \"Logical Determinism\": Same policy decision given same context\n- \"Byte-for-byte Determinism\": Exact same output bytes\n\nKey Insight: As upstream LLM models drift (model updates, temperature changes),\nwe cannot guarantee byte-for-byte determinism. However, we CAN guarantee:\n\n1. Policy decisions are deterministic (same rules -> same enforcement)\n2. Replay validates logical equivalence, not exact match\n3. Version tracking allows audit trail of what ran when\n\nDeterminism Levels:\n- STRICT: Byte-for-byte match required (only for local/cached responses)\n- LOGICAL: Policy decision match required (default for LLM calls)\n- SEMANTIC: Meaning-equivalent match (for content validation)\n\nUsage:\n    from app.hoc.cus.logs.L5_engines.replay_determinism import (\n        ReplayValidator,\n        DeterminismLevel,\n        ReplayResult\n    )\n\n    validator = ReplayValidator()\n    result = validator.validate_replay(\n        original_call=original,\n        replayed_call=replayed,\n        level=DeterminismLevel.LOGICAL\n    )",
        "functions": [],
        "classes": [
          {
            "name": "ModelVersion",
            "docstring": "Track the model version used for a call.",
            "methods": [
              "to_dict",
              "from_dict"
            ],
            "line": 75
          },
          {
            "name": "PolicyDecision",
            "docstring": "Record of a policy enforcement decision.",
            "methods": [
              "to_dict"
            ],
            "line": 108
          },
          {
            "name": "ReplayMatch",
            "docstring": "Result of replay comparison.",
            "methods": [],
            "line": 132
          },
          {
            "name": "ReplayResult",
            "docstring": "Result of replay validation.",
            "methods": [
              "to_dict"
            ],
            "line": 142
          },
          {
            "name": "CallRecord",
            "docstring": "Record of a call for replay validation.",
            "methods": [
              "to_dict"
            ],
            "line": 183
          },
          {
            "name": "ReplayValidator",
            "docstring": "Validates replay determinism at configurable levels.\n\nThe key insight is that LLM outputs will drift over time as models\nare updated. We don't try to fight this - instead we:\n\n1. Track model versions explicitly\n2. Define determinism in terms of POLICY DECISIONS, not raw output\n3. Provide clear audit trails when drift is detected\n4. Allow operators to choose their determinism level",
            "methods": [
              "__init__",
              "validate_replay",
              "_detect_model_drift",
              "_compare_policies",
              "_semantic_equivalent",
              "_level_meets_requirement",
              "hash_content"
            ],
            "line": 221
          },
          {
            "name": "ReplayContextBuilder",
            "docstring": "Builds replay context from API calls.\n\nUsed to capture all information needed for replay validation:\n- Request details\n- Response details\n- Model version\n- Policy decisions",
            "methods": [
              "__init__",
              "build_call_record"
            ],
            "line": 413
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.hoc.cus.logs.L5_schemas.determinism_types",
            "names": [
              "DeterminismLevel"
            ],
            "is_relative": false,
            "line": 68
          }
        ],
        "constants": [],
        "all_exports": [
          "DeterminismLevel",
          "ModelVersion",
          "PolicyDecision",
          "ReplayMatch",
          "ReplayResult",
          "CallRecord",
          "ReplayValidator",
          "ReplayContextBuilder"
        ]
      },
      {
        "file_name": "trace_mismatch_engine.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/trace_mismatch_engine.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 583,
        "module_docstring": "Trace Mismatch Engine (L5)\n\nBusiness logic for trace mismatch operations.\n\nThis engine:\n- Validates inputs and enforces tenant isolation\n- Delegates DB operations to L6 driver\n- Handles notifications (GitHub issues, Slack)\n- Returns structured results for L4 handler\n\nUsage:\n    from app.hoc.cus.logs.L5_engines.trace_mismatch_engine import get_trace_mismatch_engine\n\n    engine = get_trace_mismatch_engine(session)\n    result = await engine.list_all_mismatches(window=\"24h\", status=\"open\", limit=100)",
        "functions": [
          {
            "name": "get_trace_mismatch_engine",
            "signature": "(driver: TraceMismatchDriver) -> TraceMismatchEngine",
            "docstring": "Get trace mismatch engine instance for the given (session-bound) driver.",
            "is_async": false,
            "line": 581
          }
        ],
        "classes": [
          {
            "name": "MismatchReportInput",
            "docstring": "Input for reporting a mismatch.",
            "methods": [],
            "line": 52
          },
          {
            "name": "NotificationResult",
            "docstring": "Result of notification attempt.",
            "methods": [],
            "line": 63
          },
          {
            "name": "TraceMismatchEngine",
            "docstring": "L5 engine for trace mismatch business logic.\n\nHandles:\n- Input validation\n- Tenant isolation enforcement\n- Notification dispatch (GitHub, Slack)\n- Result structuring",
            "methods": [
              "__init__",
              "list_all_mismatches",
              "list_trace_mismatches",
              "report_mismatch",
              "resolve_mismatch",
              "bulk_report_mismatches",
              "_send_notification",
              "_create_bulk_github_issue",
              "_comment_on_github_issue"
            ],
            "line": 70
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.logs.L6_drivers.trace_mismatch_driver",
            "names": [
              "TraceMismatchDriver"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "traces_models.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/traces_models.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 51,
        "module_docstring": "Trace Models for AOS - BACKWARD COMPATIBILITY RE-EXPORTS\n\nPIN-521 Migration:\n- Canonical home is now L5_schemas/traces_models.py\n- This file re-exports for backward compatibility\n- L6 drivers MUST import from L5_schemas (not here)\n- New code SHOULD import from L5_schemas\n\nTo migrate existing imports:\n    OLD: from app.hoc.cus.logs.L5_engines.traces_models import TraceRecord\n    NEW: from app.hoc.cus.logs.L5_schemas.traces_models import TraceRecord",
        "functions": [],
        "classes": [],
        "imports": [
          {
            "module": "app.hoc.cus.logs.L5_schemas.traces_models",
            "names": [
              "ParityResult",
              "TraceRecord",
              "TraceStatus",
              "TraceStep",
              "TraceSummary",
              "_normalize_for_determinism",
              "compare_traces"
            ],
            "is_relative": false,
            "line": 33
          }
        ],
        "constants": [],
        "all_exports": [
          "TraceStatus",
          "TraceStep",
          "TraceSummary",
          "TraceRecord",
          "ParityResult",
          "compare_traces",
          "_normalize_for_determinism"
        ]
      }
    ],
    "l5_schemas": [
      {
        "file_name": "determinism_types.py",
        "file_path": "backend/app/hoc/cus/logs/L5_schemas/determinism_types.py",
        "layer": "L5_schemas",
        "domain": "logs",
        "lines": 34,
        "module_docstring": "Determinism Types\n\nShared enum definitions for replay determinism levels.\nLives in L5_schemas so L2 can import without violating L2\u2192L5 rules.",
        "functions": [],
        "classes": [
          {
            "name": "DeterminismLevel",
            "docstring": "Determinism level for replay validation.\n\nSTRICT: Byte-for-byte exact match\nLOGICAL: Policy decision equivalence (default for LLM)\nSEMANTIC: Meaning-equivalent match",
            "methods": [],
            "line": 18
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 15
          }
        ],
        "constants": [],
        "all_exports": [
          "DeterminismLevel"
        ]
      },
      {
        "file_name": "traces_models.py",
        "file_path": "backend/app/hoc/cus/logs/L5_schemas/traces_models.py",
        "layer": "L5_schemas",
        "domain": "logs",
        "lines": 435,
        "module_docstring": "Trace Models for AOS\nM6 Deliverable: Run traces with correlation IDs\n\nThese models define the structure of execution traces used for:\n- Debugging and inspection\n- Replay verification\n- Determinism testing\n\nDeterminism Invariant (PIN-126):\n- Given the same trace input, replay must produce identical output hash\n- Or fail loudly with a classified reason\n\nPIN-521 Migration:\n- Extracted from L5_engines/traces_models.py to L5_schemas\n- L6 drivers import from here (not L5_engines)\n- L5_engines re-exports for backward compatibility",
        "functions": [
          {
            "name": "_normalize_for_determinism",
            "signature": "(value: Any) -> Any",
            "docstring": "Normalize a value for deterministic hashing.\n\nHandles:\n- Floats: Round to 6 decimal places to avoid precision drift\n- Dicts: Recursively normalize values\n- Lists: Recursively normalize elements\n- Other types: Pass through unchanged",
            "is_async": false,
            "line": 45
          },
          {
            "name": "compare_traces",
            "signature": "(original: TraceRecord, replay: TraceRecord) -> ParityResult",
            "docstring": "Compare two traces to verify replay parity.\n\nChecks:\n- Same number of steps\n- Same skill calls in same order\n- Same parameters\n- Same status (success/failure)\n- Same retry counts\n\nDoes NOT check:\n- outcome_data (external responses vary)\n- timestamps (always different)\n- duration_ms (timing varies)\n- cost_cents (may vary with pricing changes)",
            "is_async": false,
            "line": 356
          }
        ],
        "classes": [
          {
            "name": "TraceStatus",
            "docstring": "Status of a trace step.",
            "methods": [],
            "line": 64
          },
          {
            "name": "TraceStep",
            "docstring": "A single step in an execution trace.\n\nCaptures everything needed to replay and verify determinism.",
            "methods": [
              "to_dict",
              "from_dict",
              "determinism_hash"
            ],
            "line": 74
          },
          {
            "name": "TraceSummary",
            "docstring": "Summary of a trace for listing purposes.\n\nInflection Fields (BACKEND_REMEDIATION_PLAN GAP-003):\n- violation_step_index: Step where policy violation occurred\n- violation_timestamp: When the violation was detected\n- violation_policy_id: ID of the violated policy\n- violation_reason: Human-readable violation description",
            "methods": [
              "to_dict"
            ],
            "line": 155
          },
          {
            "name": "TraceRecord",
            "docstring": "Complete trace record with all steps.\n\nUsed for replay verification and debugging.\n\nv1.1 Determinism fields:\n- seed: Random seed for deterministic simulation\n- frozen_timestamp: Frozen time for deterministic context\n- root_hash: Merkle root of deterministic fields (for replay verification)\n\nv1.2 Schema versioning (PIN-126):\n- SCHEMA_VERSION: Version of trace format for compatibility checks\n- schema_version in to_dict(): Included in serialization\n- checksum: determinism_signature() for integrity verification",
            "methods": [
              "total_cost_cents",
              "total_duration_ms",
              "success_count",
              "failure_count",
              "to_dict",
              "from_dict",
              "to_summary",
              "determinism_signature"
            ],
            "line": 209
          },
          {
            "name": "ParityResult",
            "docstring": "Result of comparing two traces for replay parity.",
            "methods": [
              "to_dict"
            ],
            "line": 336
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "ClassVar"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "TraceStatus",
          "TraceStep",
          "TraceSummary",
          "TraceRecord",
          "ParityResult",
          "compare_traces",
          "_normalize_for_determinism"
        ]
      }
    ],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "audit_ledger_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/audit_ledger_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 397,
        "module_docstring": "Audit Ledger Service (Async)\n\nProvides async methods to write governance events to the AuditLedger table.\nThis is the APPEND-ONLY immutable governance action log.\n\nINVARIANTS:\n- All writes are INSERT only (no UPDATE, no DELETE)\n- Each write is atomic within the caller's transaction\n- Events use canonical AuditEventType values",
        "functions": [
          {
            "name": "get_audit_ledger_service_async",
            "signature": "(session: AsyncSession) -> AuditLedgerServiceAsync",
            "docstring": "Get an AuditLedgerServiceAsync instance.\n\nArgs:\n    session: Async database session\n\nReturns:\n    AuditLedgerServiceAsync instance",
            "is_async": false,
            "line": 377
          }
        ],
        "classes": [
          {
            "name": "AuditLedgerServiceAsync",
            "docstring": "Async service for writing to the audit ledger.\n\nL6 CONTRACT:\n- Pure database writes, no business logic\n- All methods are async (for use with AsyncSession)\n- Writes happen within caller's transaction",
            "methods": [
              "__init__",
              "_emit",
              "limit_created",
              "limit_updated",
              "limit_breached",
              "policy_rule_created",
              "policy_rule_modified",
              "policy_rule_retired",
              "policy_proposal_approved",
              "policy_proposal_rejected",
              "signal_acknowledged",
              "signal_suppressed",
              "signal_escalated"
            ],
            "line": 49
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "ActorType",
              "AuditEntityType",
              "AuditEventType",
              "AuditLedger"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": [
          "AuditLedgerServiceAsync",
          "get_audit_ledger_service_async"
        ]
      },
      {
        "file_name": "audit_ledger_read_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/audit_ledger_read_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 243,
        "module_docstring": "Audit Ledger Read Driver (PIN-519)\n\nProvides async read operations for the AuditLedger table.\nThis complements the write-only AuditLedgerServiceAsync.\n\nINVARIANTS:\n- Read-only operations (no INSERT, UPDATE, DELETE)\n- Queries are tenant-scoped\n- Returns signal feedback status from audit events",
        "functions": [
          {
            "name": "get_audit_ledger_read_driver",
            "signature": "(session: AsyncSession) -> AuditLedgerReadDriver",
            "docstring": "Get an AuditLedgerReadDriver instance.\n\nArgs:\n    session: Async database session\n\nReturns:\n    AuditLedgerReadDriver instance",
            "is_async": false,
            "line": 223
          }
        ],
        "classes": [
          {
            "name": "AuditLedgerReadDriver",
            "docstring": "Async driver for reading from the audit ledger.\n\nL6 CONTRACT:\n- Pure database reads, no business logic\n- All methods are async (for use with AsyncSession)\n- Queries happen within caller's transaction",
            "methods": [
              "__init__",
              "get_signal_feedback",
              "get_audit_entries_for_entity",
              "get_signal_events_for_run"
            ],
            "line": 49
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "select"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "AuditEntityType",
              "AuditEventType",
              "AuditLedger"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": [
          "AuditLedgerReadDriver",
          "get_audit_ledger_read_driver"
        ]
      },
      {
        "file_name": "audit_ledger_write_driver_sync.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/audit_ledger_write_driver_sync.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 95,
        "module_docstring": "Audit Ledger Sync Write Driver (L6)\n\nORM construction for audit ledger entries. Mirrors the async driver\n(audit_ledger_driver.py) but uses sync sqlmodel Session.\n\nPIN-520 No-Exemptions Phase 3: Moves AuditLedger ORM construction out of\nthe L5 engine so L5 has zero runtime app.models imports.\n\nL6 Contract:\n    - Session REQUIRED (passed from L4 handler via L5 engine)\n    - L6 does NOT commit (L4 owns transaction boundary)\n    - All writes are INSERT only (append-only governance log)",
        "functions": [
          {
            "name": "get_audit_ledger_write_driver_sync",
            "signature": "(session: Session) -> AuditLedgerWriteDriverSync",
            "docstring": "Factory for AuditLedgerWriteDriverSync.",
            "is_async": false,
            "line": 93
          }
        ],
        "classes": [
          {
            "name": "AuditLedgerWriteDriverSync",
            "docstring": "L6 sync driver for constructing and persisting AuditLedger ORM rows.",
            "methods": [
              "__init__",
              "emit_entry"
            ],
            "line": 49
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "AuditLedger"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "bridges_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/bridges_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 123,
        "module_docstring": "M25 Bridges Driver\n\nDatabase operations for integration bridge audit trails.\n\nL6 Contract:\n    - Session REQUIRED (passed from L4 handler)\n    - L6 does NOT commit (L4 owns transaction boundary)\n\nUNFROZEN: 2026-02-06 (PIN-520 L6 purity compliance)",
        "functions": [
          {
            "name": "record_policy_activation",
            "signature": "(session: AsyncSession, policy_id: str, source_pattern_id: str, source_recovery_id: str, confidence: float, approval_path: str, loop_trace_id: str, tenant_id: str) -> PolicyActivationAudit",
            "docstring": "Record policy activation for audit trail.\n\nEvery ACTIVE policy must have an audit record.\n\nArgs:\n    session: AsyncSession from L4 handler (required)\n    policy_id: Policy being activated\n    source_pattern_id: Source pattern ID\n    source_recovery_id: Source recovery ID\n    confidence: Confidence score at activation\n    approval_path: Approval workflow path\n    loop_trace_id: Loop trace correlation ID\n    tenant_id: Tenant scope\n\nReturns:\n    PolicyActivationAudit record\n\nNote:\n    L6 does NOT commit \u2014 L4 handler owns transaction boundary.",
            "is_async": true,
            "line": 48
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "schemas.audit_schemas",
            "names": [
              "PolicyActivationAudit"
            ],
            "is_relative": true,
            "line": 42
          },
          {
            "module": "schemas.loop_events",
            "names": [
              "ConfidenceCalculator"
            ],
            "is_relative": true,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "capture_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/capture_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 870,
        "module_docstring": "Taxonomy Evidence Capture Service (v1.1)\n\nSingle entry point for all governance taxonomy evidence writes (Classes B-J).\n\nTransaction Boundary: L6 drivers DO NOT commit.\nThe caller (L5 engine or L4 coordinator) owns the transaction.\nAll functions receive session from caller and only call session.execute().\n\nRules:\n- All taxonomy writes go through this file\n- All functions require ExecutionContext (except integrity)\n- All functions require Session (caller owns transaction)\n- No context \u2192 No evidence (hard failure, not best-effort)\n- No business logic - thin DB writes only\n- No inference - fields must be provided explicitly\n- Best-effort semantics for DB writes - failures logged, not blocking\n\nArchitecture:\n- Layer 1 (Operational): contracts.decision_records, routing_decisions, etc.\n- Layer 2 (Governance): activity_evidence, policy_decisions, provider_evidence, etc.\n- Layer 3 (Integrity): integrity_evidence (terminal-only seal)\n\nThis file serves Layer 2 and Layer 3.\n\nv1.1 Changes:\n- compute_integrity() now delegates to compute_integrity_v2() (split architecture)\n- IntegrityAssembler gathers facts, IntegrityEvaluator applies policy\n- Backward compatible: returns same dict structure with extra fields\n\nv1.2 Changes (HOC Authority Enforcement):\n- All functions now require session parameter (caller owns transaction)\n- Removed all conn.commit() / session.commit() calls\n- Removed create_engine usage (session provided by caller)",
        "functions": [
          {
            "name": "_assert_context_exists",
            "signature": "(ctx: ExecutionContext, evidence_type: str) -> None",
            "docstring": "Hard guard: Fail fast if context is None.\n\nPhase-1 Closure (PIN-405):\nThis guard closes the evidence forgery vector by ensuring no evidence\ncan be captured without valid execution context.\n\nRaises:\n    EvidenceContextError: If ctx is None (blocks execution)",
            "is_async": false,
            "line": 103
          },
          {
            "name": "_record_capture_failure",
            "signature": "(session: Session, run_id: str, evidence_type: str, failure_reason: str, error_message: Optional[str] = None, resolution: Optional[str] = None) -> None",
            "docstring": "Record an evidence capture failure for later integrity reporting.\n\nWatch-out #3: Best-effort evidence failures must surface in integrity.\n\nCategory C3: Failures have resolution semantics:\n- transient: May recover with retry\n- permanent: Cannot recover\n- superseded: Later capture succeeded\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    run_id: Run identifier (scope)\n    evidence_type: Evidence class (B/D/G/H/I scope)\n    failure_reason: Why capture failed\n    error_message: Detailed error for debugging\n    resolution: Override default resolution (transient/permanent/superseded)\n\nThis is a fire-and-forget operation - failures here are logged but don't\npropagate.",
            "is_async": false,
            "line": 182
          },
          {
            "name": "_hash_content",
            "signature": "(content: str) -> str",
            "docstring": "Generate SHA256 fingerprint of content.",
            "is_async": false,
            "line": 250
          },
          {
            "name": "capture_environment_evidence",
            "signature": "(session: Session, ctx: ExecutionContext) -> Optional[str]",
            "docstring": "Capture environment evidence (Class H) at run creation.\n\nCalled once per run, immediately after run is persisted.\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    ctx: ExecutionContext (required)\n    sdk_mode: SDK invocation mode (inline, async, degraded, offline)\n    execution_environment: Environment context (prod, staging, dev, sandbox)\n    sdk_version: SDK version string\n    telemetry_delivery_status: Telemetry status (sent, dropped, buffered, unknown)\n    capture_confidence_score: Confidence in evidence capture (0.0-1.0)\n\nReturns:\n    Evidence ID if successful, None on failure\n\nRaises:\n    EvidenceContextError: If ctx is None (Phase-1 guardrail)",
            "is_async": false,
            "line": 260
          },
          {
            "name": "capture_activity_evidence",
            "signature": "(session: Session, ctx: ExecutionContext) -> Optional[str]",
            "docstring": "Capture activity evidence (Class B) before/after LLM calls.\n\nTAXONOMY RULE: Activity evidence is only for externally consequential\nactions (LLM calls, HTTP calls, tool invocations). Pure transforms\ndo not require activity evidence.\n\nCalled BEFORE each LLM/tool invocation (with prompt info),\nand optionally updated AFTER with response info.\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    ctx: ExecutionContext (required)\n    skill_id: Skill identifier\n    model_name: LLM model name\n    prompt_fingerprint: SHA256 hash of canonical prompt\n    prompt_token_length: Token count of prompt\n    response_fingerprint: SHA256 hash of response (optional, after call)\n    response_token_length: Token count of response (optional)\n\nReturns:\n    Evidence ID if successful, None on failure\n\nRaises:\n    EvidenceContextError: If ctx is None (Phase-1 guardrail)",
            "is_async": false,
            "line": 382
          },
          {
            "name": "capture_provider_evidence",
            "signature": "(session: Session, ctx: ExecutionContext) -> Optional[str]",
            "docstring": "Capture provider evidence (Class G) after LLM provider response.\n\nCalled AFTER each provider interaction.\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    ctx: ExecutionContext (required)\n    provider_name: Provider identifier (anthropic, openai, etc.)\n    model_name: Model name used\n    input_tokens: Input token count\n    output_tokens: Output token count\n    provider_latency_ms: Provider response latency in milliseconds\n\nReturns:\n    Evidence ID if successful, None on failure\n\nRaises:\n    EvidenceContextError: If ctx is None (Phase-1 guardrail)",
            "is_async": false,
            "line": 507
          },
          {
            "name": "capture_policy_decision_evidence",
            "signature": "(session: Session, ctx: ExecutionContext) -> Optional[str]",
            "docstring": "Capture policy decision evidence (Class D) during policy evaluation.\n\nThis bridges operational decision records to governance taxonomy.\nCalled whenever a policy/guardrail is evaluated.\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    ctx: ExecutionContext (required)\n    policy_type: Type of policy (budget, rate_limit, capability, permission)\n    decision: Decision outcome (GRANTED, DENIED, PENDING_APPROVAL)\n    policies_evaluated: List of policy IDs evaluated\n    policy_results: Aggregated result (pass, warn, fail, skip)\n\nReturns:\n    Evidence ID if successful, None on failure\n\nRaises:\n    EvidenceContextError: If ctx is None (Phase-1 guardrail)",
            "is_async": false,
            "line": 634
          },
          {
            "name": "compute_integrity",
            "signature": "(run_id: str) -> Dict[str, Any]",
            "docstring": "Compute integrity payload by examining evidence tables.\n\nv1.1: Delegates to compute_integrity_v2 which uses the split architecture\n(IntegrityAssembler + IntegrityEvaluator).\n\nWatch-out #3: Checks for recorded capture failures and includes them\nin missing_reasons with specific failure codes.\n\nReturns dictionary with expected/observed/missing artifacts and integrity score.\nBackward compatible - same dict structure as v1.0, with optional extra fields.",
            "is_async": false,
            "line": 751
          },
          {
            "name": "capture_integrity_evidence",
            "signature": "(session: Session, run_id: str) -> Optional[str]",
            "docstring": "Capture integrity evidence (Class J) at terminal state.\n\nCalled EXACTLY ONCE when run reaches terminal state.\nThis is the truth seal - computed from all observed evidence.\n\nNOTE: This function does NOT require ExecutionContext by design.\nIntegrity is computed from run_id after execution ends.\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    run_id: Run identifier\n    is_synthetic: Whether this is SDSR execution\n    synthetic_scenario_id: SDSR scenario ID if synthetic\n\nReturns:\n    Evidence ID if successful, None on failure",
            "is_async": false,
            "line": 775
          },
          {
            "name": "hash_prompt",
            "signature": "(prompt: str) -> str",
            "docstring": "Generate SHA256 fingerprint of prompt content.",
            "is_async": false,
            "line": 868
          }
        ],
        "classes": [
          {
            "name": "EvidenceContextError",
            "docstring": "Hard failure when evidence capture is attempted without ExecutionContext.\n\nPhase-1 Closure Guardrail (PIN-405):\n- Evidence capture REQUIRES execution context\n- No context = no evidence (by force, not convention)\n- This closes the evidence forgery vector permanently\n\nThis is a blocking exception - callers must handle it explicitly.\nIt is NOT a best-effort failure that gets logged and ignored.",
            "methods": [
              "__init__"
            ],
            "line": 84
          },
          {
            "name": "CaptureFailureReason",
            "docstring": "Standard failure reasons for integrity evidence.\n\nResolution Semantics (Category C3):\n- TRANSIENT: Temporary failure, may recover (network blip, retry possible)\n- PERMANENT: Unrecoverable failure (schema mismatch, invalid data)\n- SUPERSEDED: Later capture succeeded, this failure can be ignored\n\nMapping to default resolution:\n- capture_failed \u2192 transient\n- provider_timeout \u2192 transient\n- pre_attach \u2192 permanent (context doesn't exist yet)\n- network_partition \u2192 transient\n- database_error \u2192 transient\n- context_invalid \u2192 permanent",
            "methods": [],
            "line": 138
          },
          {
            "name": "FailureResolution",
            "docstring": "Resolution semantics for capture failures.",
            "methods": [],
            "line": 164
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "sqlalchemy.exc",
            "names": [
              "SQLAlchemyError"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "app.core.execution_context",
            "names": [
              "ExecutionContext"
            ],
            "is_relative": false,
            "line": 74
          }
        ],
        "constants": [
          {
            "name": "_FAILURE_RESOLUTION_MAP",
            "line": 172
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "cost_intelligence_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/cost_intelligence_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 545,
        "module_docstring": "Cost Intelligence Driver (L6)\n\nPure database operations for cost intelligence reads.\n\nAll methods are pure DB operations \u2014 no business logic.\nBusiness decisions (anomaly detection thresholds, trend analysis) stay in L5 engine.\n\nOperations:\n- Fetch cost summary for a period\n- Fetch costs by feature, user, model\n- Fetch cost anomalies\n- Fetch cost projections (daily cost data)\n- Fetch current spend for budget tracking\n- Fetch feature tags for a tenant\n- Fetch and manage budgets",
        "functions": [
          {
            "name": "get_cost_intelligence_driver",
            "signature": "(session: AsyncSession) -> CostIntelligenceDriver",
            "docstring": "Get cost intelligence driver instance.",
            "is_async": false,
            "line": 543
          }
        ],
        "classes": [
          {
            "name": "CostIntelligenceDriver",
            "docstring": "L6 driver for cost intelligence read operations.\n\nPure database access \u2014 no business logic.",
            "methods": [
              "__init__",
              "fetch_cost_summary",
              "fetch_tenant_budget",
              "fetch_total_cost",
              "fetch_costs_by_feature",
              "fetch_costs_by_user",
              "fetch_costs_by_model",
              "fetch_recent_anomalies",
              "fetch_daily_costs",
              "fetch_month_spend",
              "fetch_current_spend",
              "fetch_feature_tags",
              "fetch_feature_tag_by_tag",
              "fetch_active_feature_tag",
              "fetch_budgets",
              "fetch_budget_by_type"
            ],
            "line": 48
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cost_intelligence_sync_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/cost_intelligence_sync_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 673,
        "module_docstring": "Cost Intelligence Sync Driver (L6)\n\nPure synchronous database operations for cost intelligence reads.\n\nAll methods are pure DB operations \u2014 no business logic.\nBusiness decisions (anomaly detection thresholds, trend analysis) stay in L5 engine.\n\nOperations:\n- Fetch cost summary for a period\n- Fetch costs by feature, user, model\n- Fetch cost anomalies\n- Fetch cost projections (daily cost data)\n- Fetch current spend for budget tracking\n- Fetch feature tags for a tenant\n- Fetch and manage budgets",
        "functions": [
          {
            "name": "get_cost_intelligence_sync_driver",
            "signature": "(session: Session) -> CostIntelligenceSyncDriver",
            "docstring": "Get cost intelligence sync driver instance.",
            "is_async": false,
            "line": 665
          }
        ],
        "classes": [
          {
            "name": "CostIntelligenceSyncDriver",
            "docstring": "L6 sync driver for cost intelligence read operations.\n\nPure database access \u2014 no business logic.",
            "methods": [
              "__init__",
              "check_feature_tag_exists",
              "fetch_feature_tags",
              "fetch_feature_tag_by_tag",
              "fetch_active_feature_tag",
              "update_feature_tag",
              "fetch_cost_summary",
              "fetch_tenant_budget",
              "fetch_total_cost",
              "fetch_costs_by_feature",
              "fetch_costs_by_user",
              "fetch_costs_by_model",
              "fetch_recent_anomalies",
              "fetch_daily_costs",
              "fetch_month_spend",
              "fetch_budgets",
              "fetch_budget_by_type",
              "create_budget",
              "update_budget",
              "fetch_current_spend"
            ],
            "line": 49
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": [
          "CostIntelligenceSyncDriver",
          "get_cost_intelligence_sync_driver"
        ]
      },
      {
        "file_name": "export_bundle_store.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/export_bundle_store.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 245,
        "module_docstring": "Export Bundle Store (L6)\n\nDatabase driver for export bundle data access:\n- Incidents\n- Runs\n- Trace summaries and steps\n\nAll methods return immutable snapshots, never ORM models.",
        "functions": [
          {
            "name": "get_export_bundle_store",
            "signature": "() -> ExportBundleStore",
            "docstring": "Get the singleton ExportBundleStore instance.",
            "is_async": false,
            "line": 230
          }
        ],
        "classes": [
          {
            "name": "IncidentSnapshot",
            "docstring": "Immutable snapshot of incident.",
            "methods": [],
            "line": 56
          },
          {
            "name": "RunSnapshot",
            "docstring": "Immutable snapshot of run.",
            "methods": [],
            "line": 70
          },
          {
            "name": "TraceSummarySnapshot",
            "docstring": "Immutable snapshot of trace summary.",
            "methods": [],
            "line": 85
          },
          {
            "name": "TraceStepSnapshot",
            "docstring": "Immutable snapshot of trace step.",
            "methods": [],
            "line": 96
          },
          {
            "name": "ExportBundleStore",
            "docstring": "L6 Database Driver for export bundle data.\n\nAll methods:\n- Use sync Session (for sqlmodel compatibility)\n- Return immutable snapshots\n- Contain NO business logic",
            "methods": [
              "__init__",
              "trace_store",
              "get_incident",
              "get_run_by_run_id",
              "get_trace_summary",
              "get_trace_steps"
            ],
            "line": 114
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.db",
            "names": [
              "Run",
              "engine"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.traces.store",
            "names": [
              "TraceStore"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": [
          "ExportBundleStore",
          "get_export_bundle_store",
          "IncidentSnapshot",
          "RunSnapshot",
          "TraceSummarySnapshot",
          "TraceStepSnapshot"
        ]
      },
      {
        "file_name": "idempotency_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/idempotency_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 399,
        "module_docstring": "Redis Idempotency Store for AOS Traces\n\nM8 Deliverable: Atomic idempotency enforcement using Redis + Lua scripts.\n\nFeatures:\n- Atomic check-and-set with Lua scripts\n- Configurable TTL per key\n- Conflict detection with hash comparison\n- Async Redis support",
        "functions": [
          {
            "name": "_load_lua_script",
            "signature": "() -> str",
            "docstring": "Load Lua script from file.",
            "is_async": false,
            "line": 80
          },
          {
            "name": "canonical_json",
            "signature": "(obj: Any) -> str",
            "docstring": "Produce canonical JSON (sorted keys, compact format).",
            "is_async": false,
            "line": 131
          },
          {
            "name": "hash_request",
            "signature": "(data: Dict[str, Any]) -> str",
            "docstring": "Hash request data for idempotency comparison.",
            "is_async": false,
            "line": 136
          },
          {
            "name": "get_idempotency_store",
            "signature": "() -> Any",
            "docstring": "Get or create idempotency store based on environment.",
            "is_async": true,
            "line": 375
          }
        ],
        "classes": [
          {
            "name": "IdempotencyResult",
            "docstring": "Result of idempotency check.",
            "methods": [],
            "line": 46
          },
          {
            "name": "IdempotencyResponse",
            "docstring": "Response from idempotency check.",
            "methods": [
              "is_new",
              "is_duplicate",
              "is_conflict"
            ],
            "line": 55
          },
          {
            "name": "RedisIdempotencyStore",
            "docstring": "Redis-backed idempotency store with Lua script for atomicity.\n\nUsage:\n    store = RedisIdempotencyStore(redis_client)\n    response = await store.check(\"my-key\", request_data, tenant_id=\"acme\")\n\n    if response.is_new:\n        # Process request\n        await store.mark_completed(\"my-key\", trace_id)\n    elif response.is_duplicate:\n        # Return cached response\n        pass\n    elif response.is_conflict:\n        # Reject with 409 Conflict\n        raise HTTPException(409, \"Idempotency conflict\")",
            "methods": [
              "__init__",
              "_make_key",
              "_ensure_script_loaded",
              "check",
              "mark_completed",
              "mark_failed",
              "delete",
              "get_status"
            ],
            "line": 142
          },
          {
            "name": "InMemoryIdempotencyStore",
            "docstring": "In-memory idempotency store for testing and development.\n\nNot suitable for production (no persistence, no distributed support).",
            "methods": [
              "__init__",
              "_make_key",
              "check",
              "mark_completed",
              "mark_failed",
              "delete",
              "get_status"
            ],
            "line": 300
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [
          {
            "name": "_LUA_SCRIPT_PATH",
            "line": 76
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "integrity_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/integrity_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 524,
        "module_docstring": "Integrity Computation Module (v1.1)\n\nSeparated concerns for integrity evidence:\n- IntegrityAssembler: Gathers facts from evidence tables\n- IntegrityEvaluator: Applies policy to compute state/grade\n- IntegritySerializer: Persists integrity evidence\n\nDesign rationale (Category C2 fix):\n    compute_integrity() was becoming a god function.\n    Split responsibilities enable:\n    - Policy-driven integrity (enterprise tiers)\n    - Explainable integrity decisions\n    - Testable components\n\nState Model (Category B2 fix):\n    Execution Status: SUCCEEDED | FAILED | ABORTED (run outcome)\n    Integrity State:  PENDING | SEALED (evidence completeness)\n    Integrity Grade:  PASS | WARN | FAIL (quality judgment)\n\n    These are distinct axes - do not collapse them.",
        "functions": [
          {
            "name": "compute_integrity_v2",
            "signature": "(run_id: str) -> Dict[str, Any]",
            "docstring": "Compute integrity using the new split architecture.\n\nReturns dict compatible with the original compute_integrity().",
            "is_async": false,
            "line": 501
          }
        ],
        "classes": [
          {
            "name": "IntegrityState",
            "docstring": "Evidence completeness state.\n\nThis is about WHETHER we have evidence, not quality.",
            "methods": [],
            "line": 68
          },
          {
            "name": "IntegrityGrade",
            "docstring": "Quality judgment on the evidence.\n\nThis is about HOW GOOD the evidence is.",
            "methods": [],
            "line": 78
          },
          {
            "name": "EvidenceClass",
            "docstring": "Taxonomy of evidence classes.\n\nActivity Evidence (B) Scope Rule:\n    Activity evidence is required only for externally consequential actions\n    (e.g., LLM calls, tool invocations), not pure transforms.\n\n    - llm_invoke: REQUIRES activity evidence (decision-bearing)\n    - http_call: REQUIRES activity evidence (external effect)\n    - json_transform: NO activity evidence (pure transform)\n    - postgres_query: OPTIONAL (depends on mutation)",
            "methods": [],
            "line": 94
          },
          {
            "name": "FailureResolution",
            "docstring": "Resolution semantics for capture failures.\n\nFormalizes how to interpret a capture failure for integrity grading.",
            "methods": [],
            "line": 138
          },
          {
            "name": "CaptureFailure",
            "docstring": "Structured representation of an evidence capture failure.",
            "methods": [
              "to_dict"
            ],
            "line": 150
          },
          {
            "name": "IntegrityFacts",
            "docstring": "Raw facts gathered from evidence tables.\n\nThis is pure data gathering - no policy applied.",
            "methods": [
              "has_required_evidence",
              "has_capture_failures",
              "unresolved_failures"
            ],
            "line": 174
          },
          {
            "name": "IntegrityAssembler",
            "docstring": "Gathers facts from evidence tables.\n\nThis class only collects data - it does not apply policy.",
            "methods": [
              "__init__",
              "gather",
              "_count_evidence",
              "_gather_failures",
              "_resolve_superseded",
              "_table_to_class",
              "_string_to_class"
            ],
            "line": 204
          },
          {
            "name": "IntegrityEvaluation",
            "docstring": "Result of integrity policy evaluation.",
            "methods": [
              "integrity_status"
            ],
            "line": 348
          },
          {
            "name": "IntegrityEvaluator",
            "docstring": "Applies policy to integrity facts.\n\nThis class makes quality judgments based on collected facts.\nPolicy can be customized for enterprise tiers.",
            "methods": [
              "evaluate",
              "_find_failure",
              "_compute_grade",
              "_build_explanation"
            ],
            "line": 370
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "sqlalchemy",
            "names": [
              "create_engine",
              "text"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "sqlalchemy.exc",
            "names": [
              "SQLAlchemyError"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [
          {
            "name": "DATABASE_URL",
            "line": 60
          },
          {
            "name": "REQUIRED_EVIDENCE",
            "line": 119
          },
          {
            "name": "EXPECTED_EVIDENCE",
            "line": 126
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "job_execution_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/job_execution_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 881,
        "module_docstring": "Module: job_execution\nPurpose: Job execution support services.\n\nProvides:\n    - GAP-156: Retry logic with exponential backoff\n    - GAP-157: Progress reporting and tracking\n    - GAP-158: Audit evidence emission\n\nAcceptance Criteria:\n    - AC-156-01: Exponential backoff with jitter\n    - AC-156-02: Max retries respected\n    - AC-156-03: Retry history recorded\n    - AC-157-01: Progress percentage tracked\n    - AC-157-02: Progress events emitted\n    - AC-157-03: ETA calculation\n    - AC-158-01: Job lifecycle audited\n    - AC-158-02: Audit events are tamper-evident\n    - AC-158-03: Audit includes execution context",
        "functions": [
          {
            "name": "_hash_value",
            "signature": "(value: Any) -> str",
            "docstring": "Hash a value for audit purposes.",
            "is_async": false,
            "line": 653
          },
          {
            "name": "get_job_retry_manager",
            "signature": "() -> JobRetryManager",
            "docstring": "Get the singleton JobRetryManager.",
            "is_async": false,
            "line": 852
          },
          {
            "name": "get_job_progress_tracker",
            "signature": "() -> JobProgressTracker",
            "docstring": "Get the singleton JobProgressTracker.",
            "is_async": false,
            "line": 860
          },
          {
            "name": "get_job_audit_emitter",
            "signature": "() -> JobAuditEmitter",
            "docstring": "Get the singleton JobAuditEmitter.",
            "is_async": false,
            "line": 868
          },
          {
            "name": "reset_job_execution_services",
            "signature": "() -> None",
            "docstring": "Reset all singletons (for testing).",
            "is_async": false,
            "line": 876
          }
        ],
        "classes": [
          {
            "name": "RetryStrategy",
            "docstring": "Retry strategy types.",
            "methods": [],
            "line": 68
          },
          {
            "name": "RetryConfig",
            "docstring": "Configuration for job retry.",
            "methods": [],
            "line": 78
          },
          {
            "name": "RetryAttempt",
            "docstring": "Record of a retry attempt.",
            "methods": [],
            "line": 90
          },
          {
            "name": "JobRetryManager",
            "docstring": "Manages job retry logic with configurable strategies.\n\nGAP-156: Job Retry Logic\n\nSupports:\n- Exponential backoff with jitter\n- Configurable max retries\n- Retry history tracking\n- Error classification",
            "methods": [
              "__init__",
              "should_retry",
              "calculate_delay",
              "record_retry",
              "get_retry_history",
              "clear_history"
            ],
            "line": 101
          },
          {
            "name": "ProgressStage",
            "docstring": "Standard progress stages.",
            "methods": [],
            "line": 270
          },
          {
            "name": "ProgressUpdate",
            "docstring": "A progress update for a job.",
            "methods": [
              "to_dict"
            ],
            "line": 283
          },
          {
            "name": "JobProgressTracker",
            "docstring": "Tracks and reports job progress.\n\nGAP-157: Job Progress Reporting\n\nProvides:\n- Percentage tracking\n- Step-based progress\n- ETA calculation\n- Progress event emission",
            "methods": [
              "__init__",
              "start",
              "update",
              "complete",
              "fail",
              "get_progress",
              "register_callback",
              "_calculate_eta",
              "_emit_progress",
              "_get_publisher"
            ],
            "line": 313
          },
          {
            "name": "JobAuditEventType",
            "docstring": "Types of job audit events.",
            "methods": [],
            "line": 574
          },
          {
            "name": "JobAuditEvent",
            "docstring": "Audit event for job execution.\n\nProvides tamper-evident audit trail for compliance.",
            "methods": [
              "__post_init__",
              "_compute_integrity_hash",
              "to_dict",
              "verify_integrity"
            ],
            "line": 589
          },
          {
            "name": "JobAuditEmitter",
            "docstring": "Emits audit events for job execution.\n\nGAP-158: Job Audit Evidence\n\nProvides:\n- Compliance-grade audit trail\n- Tamper-evident event chain\n- Execution context capture",
            "methods": [
              "__init__",
              "_generate_event_id",
              "emit_created",
              "emit_started",
              "emit_completed",
              "emit_failed",
              "emit_retried",
              "_emit",
              "_get_publisher"
            ],
            "line": 661
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "random",
            "names": [
              "random"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "logs_domain_store.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/logs_domain_store.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 673,
        "module_docstring": "Logs Domain Store (L6)\n\nDatabase driver for all Logs domain data access:\n- LLM Run Records\n- System Records\n- Audit Ledger\n- Log Exports\n\nAll methods return immutable snapshots, never ORM models.",
        "functions": [
          {
            "name": "get_logs_domain_store",
            "signature": "() -> LogsDomainStore",
            "docstring": "Get the singleton LogsDomainStore instance.",
            "is_async": false,
            "line": 655
          }
        ],
        "classes": [
          {
            "name": "LLMRunSnapshot",
            "docstring": "Immutable snapshot of LLM run record.",
            "methods": [],
            "line": 56
          },
          {
            "name": "SystemRecordSnapshot",
            "docstring": "Immutable snapshot of system record.",
            "methods": [],
            "line": 77
          },
          {
            "name": "AuditLedgerSnapshot",
            "docstring": "Immutable snapshot of audit ledger entry.",
            "methods": [],
            "line": 93
          },
          {
            "name": "LogExportSnapshot",
            "docstring": "Immutable snapshot of log export record.",
            "methods": [],
            "line": 111
          },
          {
            "name": "TraceStepSnapshot",
            "docstring": "Immutable snapshot of trace step.",
            "methods": [],
            "line": 126
          },
          {
            "name": "QueryResult",
            "docstring": "Generic query result with pagination info.",
            "methods": [],
            "line": 139
          },
          {
            "name": "LogsDomainStore",
            "docstring": "L6 Database Driver for Logs domain.\n\nAll methods:\n- Accept AsyncSession as parameter\n- Return immutable snapshots\n- Contain NO business logic",
            "methods": [
              "list_llm_runs",
              "get_llm_run",
              "_to_llm_run_snapshot",
              "get_trace_id_for_run",
              "get_trace_steps",
              "get_replay_window_events",
              "list_system_records",
              "get_system_record_by_correlation",
              "get_system_records_in_window",
              "_to_system_record_snapshot",
              "list_audit_entries",
              "get_audit_entry",
              "get_governance_events",
              "_to_audit_snapshot",
              "list_log_exports",
              "_to_export_snapshot"
            ],
            "line": 152
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select",
              "text"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "AuditLedger"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.log_exports",
            "names": [
              "LogExport"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.models.logs_records",
            "names": [
              "LLMRunRecord",
              "SystemRecord"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": [
          "LogsDomainStore",
          "get_logs_domain_store",
          "LLMRunSnapshot",
          "SystemRecordSnapshot",
          "AuditLedgerSnapshot",
          "LogExportSnapshot",
          "TraceStepSnapshot",
          "QueryResult"
        ]
      },
      {
        "file_name": "panel_consistency_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/panel_consistency_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 251,
        "module_docstring": "Panel Consistency Checker \u2014 Cross-slot consistency rules\n\nChecks that output signals across slots in a panel are consistent.\nInconsistencies are violations, not warnings.",
        "functions": [
          {
            "name": "create_consistency_checker",
            "signature": "(rules: Optional[List[Dict[str, Any]]] = None) -> PanelConsistencyChecker",
            "docstring": "Create consistency checker with optional custom rules.",
            "is_async": false,
            "line": 247
          }
        ],
        "classes": [
          {
            "name": "ConsistencyViolation",
            "docstring": "A consistency violation between slots.",
            "methods": [],
            "line": 38
          },
          {
            "name": "ConsistencyCheckResult",
            "docstring": "Result of consistency checking.",
            "methods": [],
            "line": 49
          },
          {
            "name": "PanelConsistencyChecker",
            "docstring": "Checks cross-slot consistency within a panel.\n\nUsage:\n    checker = PanelConsistencyChecker(rules)\n    result = checker.check(panel_id, slot_results)",
            "methods": [
              "__init__",
              "_default_rules",
              "check",
              "_check_rule",
              "_evaluate_condition",
              "_eval_expr"
            ],
            "line": 57
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "panel_types",
            "names": [
              "PanelSlotResult"
            ],
            "is_relative": true,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "pg_store.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/pg_store.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 769,
        "module_docstring": "PostgreSQL Trace Store for AOS\nM8 Deliverable: Production-grade trace storage with PostgreSQL\n\nProvides:\n- Async PostgreSQL storage with connection pooling\n- RBAC-aware trace access\n- PII redaction before storage\n- Efficient indexing for query API\n\nFROZEN SEMANTICS (PIN-198, S6 Trace Integrity Truth):\n- All trace INSERTs use ON CONFLICT DO NOTHING (Invariant #15: First Truth Wins)\n- No UPDATE on aos_trace_steps (Invariant #13: Trace Ledger Semantics)\n- Only status/completed_at UPDATE allowed on aos_traces\n- DELETE requires archive-first (Invariant #13)\nSee LESSONS_ENFORCED.md Invariants #13, #15",
        "functions": [
          {
            "name": "_status_to_level",
            "signature": "(status: str) -> str",
            "docstring": "Derive log level from step status.\n\nMapping per PIN-378 (Canonical Logs System):\n- success \u2192 INFO\n- skipped \u2192 INFO\n- retry \u2192 WARN\n- failure \u2192 ERROR",
            "is_async": false,
            "line": 55
          },
          {
            "name": "get_postgres_trace_store",
            "signature": "() -> PostgresTraceStore",
            "docstring": "Get singleton PostgreSQL trace store.",
            "is_async": false,
            "line": 764
          }
        ],
        "classes": [
          {
            "name": "PostgresTraceStore",
            "docstring": "PostgreSQL-based trace storage for production.\n\nUses asyncpg for async database operations.\nSupports multi-tenant isolation and RBAC.",
            "methods": [
              "__init__",
              "_get_pool",
              "close",
              "start_trace",
              "record_step",
              "complete_trace",
              "mark_trace_aborted",
              "store_trace",
              "get_trace",
              "get_trace_by_root_hash",
              "search_traces",
              "list_traces",
              "delete_trace",
              "get_trace_count",
              "cleanup_old_traces",
              "check_idempotency_key"
            ],
            "line": 74
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "models",
            "names": [
              "TraceRecord",
              "TraceStatus",
              "TraceStep",
              "TraceSummary"
            ],
            "is_relative": true,
            "line": 51
          },
          {
            "module": "redact",
            "names": [
              "redact_trace_data"
            ],
            "is_relative": true,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "replay_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/replay_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 330,
        "module_docstring": "Server-Side Replay Enforcement\nM8 Deliverable: Enforce replay_behavior during trace execution\n\nProvides:\n- Replay behavior enforcement (execute, skip, check)\n- Idempotency key validation\n- Output verification for \"check\" mode\n- Replay mismatch detection",
        "functions": [
          {
            "name": "hash_output",
            "signature": "(data: Any) -> str",
            "docstring": "Compute hash of output data for comparison.",
            "is_async": false,
            "line": 87
          },
          {
            "name": "get_replay_enforcer",
            "signature": "(use_redis: bool = False) -> ReplayEnforcer",
            "docstring": "Get singleton replay enforcer.",
            "is_async": false,
            "line": 321
          }
        ],
        "classes": [
          {
            "name": "ReplayBehavior",
            "docstring": "Replay behavior options.",
            "methods": [],
            "line": 39
          },
          {
            "name": "ReplayMismatchError",
            "docstring": "Raised when replay output doesn't match original.",
            "methods": [
              "__init__"
            ],
            "line": 47
          },
          {
            "name": "IdempotencyViolationError",
            "docstring": "Raised when idempotency key is violated.",
            "methods": [
              "__init__"
            ],
            "line": 63
          },
          {
            "name": "ReplayResult",
            "docstring": "Result of a replay operation.",
            "methods": [],
            "line": 76
          },
          {
            "name": "ReplayEnforcer",
            "docstring": "Server-side replay behavior enforcer.\n\nEnsures that:\n- \"skip\" steps are not re-executed\n- \"check\" steps verify output matches\n- Idempotency keys are respected",
            "methods": [
              "__init__",
              "enforce_step",
              "enforce_trace"
            ],
            "line": 95
          },
          {
            "name": "IdempotencyStore",
            "docstring": "Abstract base for idempotency storage.",
            "methods": [
              "get",
              "set",
              "delete"
            ],
            "line": 235
          },
          {
            "name": "InMemoryIdempotencyStore",
            "docstring": "In-memory idempotency store for testing.",
            "methods": [
              "__init__",
              "_make_key",
              "get",
              "set",
              "delete",
              "clear"
            ],
            "line": 248
          },
          {
            "name": "RedisIdempotencyStore",
            "docstring": "Redis-based idempotency store for production.",
            "methods": [
              "__init__",
              "_get_client",
              "_make_key",
              "get",
              "set",
              "delete"
            ],
            "line": 277
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Awaitable",
              "Callable",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "trace_mismatch_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/trace_mismatch_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 316,
        "module_docstring": "Trace Mismatch Driver (L6)\n\nPure database operations for trace mismatch management.\n\nAll methods are pure DB operations \u2014 no business logic.\nNo GitHub/Slack notification logic \u2014 that stays in L5 engine.\n\nOperations:\n- Query mismatches with filtering\n- Verify trace tenant ownership\n- Insert mismatch records\n- Update mismatch records (resolve, set issue URL)\n- Bulk query mismatches by IDs",
        "functions": [
          {
            "name": "get_trace_mismatch_driver",
            "signature": "(session: AsyncSession) -> TraceMismatchDriver",
            "docstring": "Get trace mismatch driver instance.",
            "is_async": false,
            "line": 314
          }
        ],
        "classes": [
          {
            "name": "TraceMismatchDriver",
            "docstring": "L6 driver for trace mismatch data access.\n\nPure database access \u2014 no business logic.",
            "methods": [
              "__init__",
              "fetch_trace_tenant",
              "insert_mismatch",
              "update_mismatch_issue_url",
              "update_mismatch_notification",
              "resolve_mismatch",
              "fetch_mismatches_for_trace",
              "fetch_all_mismatches",
              "fetch_mismatches_by_ids",
              "bulk_update_issue_url"
            ],
            "line": 45
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 38,
    "violation_count": 0,
    "gap_count": 1
  },
  "analytics": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/analytics.py",
    "l2_apis": [
      {
        "file_name": "costsim.py",
        "file_path": "backend/app/hoc/api/cus/analytics/costsim.py",
        "layer": "L2_api",
        "domain": "analytics",
        "lines": 1010,
        "module_docstring": "API endpoints for CostSim V2 sandbox.\n\nEndpoints:\n- POST /costsim/v2/simulate - Run V2 simulation (sandbox mode)\n- GET /costsim/v2/status - Get V2 sandbox status\n- POST /costsim/v2/reset - Reset circuit breaker\n- GET /costsim/divergence - Get divergence report\n- POST /costsim/canary/run - Trigger canary run\n- GET /costsim/canary/reports - Get canary reports\n\nM7 Enhancements:\n- Memory context injection for simulations\n- Post-execution memory updates via rules engine\n- Drift detection between baseline and memory-enabled runs",
        "functions": [
          {
            "name": "get_memory_context",
            "signature": "(tenant_id: str, workflow_id: Optional[str] = None, agent_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Retrieve memory context for simulation.\n\nFetches relevant memory pins for the tenant, workflow, and agent.\nReturns empty dict if memory service unavailable (fail-open).",
            "is_async": true,
            "line": 258
          },
          {
            "name": "apply_post_execution_updates",
            "signature": "(tenant_id: str, workflow_id: Optional[str], agent_id: Optional[str], simulation_result: Dict[str, Any]) -> int",
            "docstring": "Apply deterministic post-execution memory updates.\n\nUses the update rules engine to apply memory updates based on\nsimulation results. Returns count of updates applied.",
            "is_async": true,
            "line": 314
          },
          {
            "name": "detect_simulation_drift",
            "signature": "(baseline_result: Dict[str, Any], memory_result: Dict[str, Any], workflow_id: Optional[str]) -> tuple[bool, float]",
            "docstring": "Detect drift between baseline and memory-enabled simulation.\n\nCompares results to identify if memory context significantly\nchanged the simulation outcome.",
            "is_async": true,
            "line": 385
          },
          {
            "name": "get_sandbox_status",
            "signature": "(session = Depends(get_session_dep))",
            "docstring": "Get current V2 sandbox status.\n\nReturns information about:\n- Whether sandbox is enabled (feature flag)\n- Whether circuit breaker is open (auto-disabled due to drift)\n- Current model version\n- Drift thresholds\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 443
          },
          {
            "name": "simulate_v2",
            "signature": "(request: SimulateRequest, session = Depends(get_session_dep))",
            "docstring": "Run simulation through V2 sandbox.\n\nThis endpoint always runs V1 for production results.\nIf sandbox is enabled, also runs V2 in shadow mode\nand returns comparison metrics.\n\nThe V1 result is always the authoritative result.\nV2 is for validation only.\n\nM7 Enhancements:\n- Memory context injection for simulations\n- Post-execution memory updates via rules engine\n- Drift detection between baseline and memory-enabled runs\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 477
          },
          {
            "name": "reset_circuit_breaker",
            "signature": "(reason: Optional[str] = Query(None, description='Reason for reset'), session = Depends(get_session_dep))",
            "docstring": "Reset the V2 circuit breaker.\n\nThis re-enables V2 sandbox after it was auto-disabled due to drift.\nShould only be called after investigating and fixing the drift cause.\n\nReturns success status and updated circuit breaker state.\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 658
          },
          {
            "name": "get_incidents",
            "signature": "(include_resolved: bool = Query(False, description='Include resolved incidents'), limit: int = Query(10, ge=1, le=100, description='Max incidents to return'), session = Depends(get_session_dep))",
            "docstring": "Get circuit breaker incidents.\n\nReturns recent incidents that caused circuit breaker trips.\nUseful for investigating drift causes.\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 689
          },
          {
            "name": "get_divergence_report",
            "signature": "(start_date: Optional[datetime] = Query(None, description='Start of analysis period'), end_date: Optional[datetime] = Query(None, description='End of analysis period'), tenant_id: Optional[str] = Query(None, description='Filter by tenant'), days: int = Query(7, ge=1, le=90, description='Days to analyze (if start_date not provided)'), session = Depends(get_session_dep))",
            "docstring": "Get cost divergence report between V1 and V2.\n\nReturns metrics:\n- delta_p50: Median cost delta\n- delta_p90: 90th percentile cost delta\n- kl_divergence: KL divergence between distributions\n- outlier_count: Number of outlier samples\n- fail_ratio: Ratio of major drift samples\n- matching_rate: Ratio of matching samples\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 720
          },
          {
            "name": "trigger_canary_run",
            "signature": "(sample_count: int = Query(100, ge=10, le=1000, description='Number of samples'), drift_threshold: float = Query(0.2, ge=0.0, le=1.0, description='Drift threshold'), session = Depends(get_session_dep))",
            "docstring": "Trigger a canary run on-demand.\n\nThe canary run:\n1. Loads samples from recent provenance logs\n2. Runs both V1 and V2 on each sample\n3. Computes drift metrics\n4. Returns pass/fail verdict\n\nNote: Daily canary runs are automatic via systemd timer.\nThis endpoint is for manual testing.\n\nPIN-520 Phase 3: Routes through L4 registry (analytics.canary).",
            "is_async": true,
            "line": 771
          },
          {
            "name": "get_canary_reports",
            "signature": "(limit: int = Query(10, ge=1, le=100, description='Max reports to return'), status: Optional[str] = Query(None, description='Filter by status (pass, fail, error, skipped)'), passed: Optional[bool] = Query(None, description='Filter by passed status'), session = Depends(get_session_dep))",
            "docstring": "Get recent canary run reports.\n\nReturns summaries of recent canary runs.\nFull artifacts are available at the artifact_paths.\n\nRoutes through L4 handler for policy/audit compliance.",
            "is_async": true,
            "line": 818
          },
          {
            "name": "list_datasets",
            "signature": "(session = Depends(get_session_dep))",
            "docstring": "List all available reference datasets.\n\nReference datasets are used to validate V2 accuracy:\n- low_variance: Simple, predictable plans\n- high_variance: Complex, variable plans\n- mixed_city: Real-world mixed workloads\n- noise_injected: Edge cases and invalid inputs\n- historical: Real production patterns\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 887
          },
          {
            "name": "get_dataset_info",
            "signature": "(dataset_id: str, session = Depends(get_session_dep))",
            "docstring": "Get information about a specific dataset.\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 924
          },
          {
            "name": "validate_against_dataset",
            "signature": "(dataset_id: str, session = Depends(get_session_dep))",
            "docstring": "Validate V2 against a specific reference dataset.\n\nRuns V2 on all samples in the dataset and compares\nagainst expected values. Returns metrics and verdict.\n\nVerdict is \"acceptable\" if all metrics are within thresholds.\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 946
          },
          {
            "name": "validate_all",
            "signature": "(session = Depends(get_session_dep))",
            "docstring": "Validate V2 against ALL reference datasets.\n\nThis is a comprehensive validation that runs all 5 datasets.\nUse for pre-release validation or debugging.\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 986
          }
        ],
        "classes": [
          {
            "name": "SimulationStep",
            "docstring": "A single step in a simulation plan.",
            "methods": [],
            "line": 112
          },
          {
            "name": "SimulateRequest",
            "docstring": "Request for V2 simulation.",
            "methods": [],
            "line": 120
          },
          {
            "name": "SimulationStepResult",
            "docstring": "Result for a single step.",
            "methods": [],
            "line": 133
          },
          {
            "name": "V2SimulationResponse",
            "docstring": "Response from V2 simulation.",
            "methods": [],
            "line": 143
          },
          {
            "name": "ComparisonResponse",
            "docstring": "Comparison between V1 and V2.",
            "methods": [],
            "line": 159
          },
          {
            "name": "SideEffectDisclosure",
            "docstring": "PIN-254 Phase C Fix (C5 Implicit Side-Effect): Explicit disclosure of side effects.\n\nThe /simulate endpoint can trigger memory writes when MEMORY_POST_UPDATE=true.\nThis violates the implicit contract that \"simulation\" is side-effect-free.\n\nThis disclosure makes the side-effect conditions explicit in the response.",
            "methods": [],
            "line": 171
          },
          {
            "name": "SandboxSimulateResponse",
            "docstring": "Response from sandbox simulation.",
            "methods": [],
            "line": 187
          },
          {
            "name": "SandboxStatusResponse",
            "docstring": "Status of V2 sandbox.",
            "methods": [],
            "line": 213
          },
          {
            "name": "DivergenceReportResponse",
            "docstring": "Divergence report response.",
            "methods": [],
            "line": 224
          },
          {
            "name": "CanaryRunResponse",
            "docstring": "Canary run response.",
            "methods": [],
            "line": 240
          },
          {
            "name": "DatasetInfo",
            "docstring": "Dataset information.",
            "methods": [],
            "line": 860
          },
          {
            "name": "ValidationResultResponse",
            "docstring": "Validation result response.",
            "methods": [],
            "line": 870
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [
          {
            "name": "MEMORY_CONTEXT_INJECTION",
            "line": 49
          },
          {
            "name": "MEMORY_POST_UPDATE",
            "line": 50
          },
          {
            "name": "DRIFT_DETECTION_ENABLED",
            "line": 51
          },
          {
            "name": "MEMORY_FAIL_OPEN_OVERRIDE",
            "line": 53
          },
          {
            "name": "MEMORY_POST_UPDATE_SYNC",
            "line": 55
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "feedback.py",
        "file_path": "backend/app/hoc/api/cus/analytics/feedback.py",
        "layer": "L2_api",
        "domain": "analytics",
        "lines": 221,
        "module_docstring": "PB-S3 Pattern Feedback API (READ-ONLY)\n\nExposes pattern_feedback data for observability without modification.\n\nPB-S3 Contract:\n- Feedback observes but never mutates\n- Provenance references runs (read-only)\n- No execution data modification allowed\n\nREAD_ONLY = True\n\nO1: API endpoint exists \u2713\nO2: List visible with pagination \u2713\nO3: Detail accessible \u2713\nO4: Execution unchanged \u2713 (no POST/PUT/DELETE)",
        "functions": [
          {
            "name": "list_feedback",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), pattern_type: Optional[str] = Query(None, description='Filter by pattern type'), severity: Optional[str] = Query(None, description='Filter by severity'), acknowledged: Optional[bool] = Query(None, description='Filter by acknowledgement status'), limit: int = Query(50, ge=1, le=200, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), _: str = Depends(verify_api_key))",
            "docstring": "List pattern feedback records (PB-S3).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 107
          },
          {
            "name": "get_feedback",
            "signature": "(feedback_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Get detailed feedback record by ID (PB-S3).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 160
          },
          {
            "name": "get_feedback_stats",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), _: str = Depends(verify_api_key))",
            "docstring": "Get feedback statistics summary (PB-S3).\n\nREAD-ONLY: This endpoint only reads aggregated data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 195
          }
        ],
        "classes": [
          {
            "name": "FeedbackSummaryResponse",
            "docstring": "Summary of a feedback record.",
            "methods": [],
            "line": 54
          },
          {
            "name": "FeedbackListResponse",
            "docstring": "Paginated list of feedback records.",
            "methods": [],
            "line": 69
          },
          {
            "name": "FeedbackDetailResponse",
            "docstring": "Detailed feedback record.",
            "methods": [],
            "line": 80
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth",
            "names": [
              "verify_api_key"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_async_session_context",
              "get_operation_registry",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "predictions.py",
        "file_path": "backend/app/hoc/api/cus/analytics/predictions.py",
        "layer": "L2_api",
        "domain": "analytics",
        "lines": 300,
        "module_docstring": "PB-S5 Predictions API (READ-ONLY)\n\nExposes prediction_events data for observability without modification.\n\nPB-S5 Contract:\n- Predictions are advisory only\n- Predictions have zero side-effects\n- Predictions never modify execution, scheduling, or history\n- Rule: Advise, don't influence\n\nREAD_ONLY = True\n\nO1: API endpoint exists \u2713\nO2: List visible with pagination \u2713\nO3: Detail accessible \u2713\nO4: Execution unchanged \u2713 (no POST/PUT/DELETE)",
        "functions": [
          {
            "name": "list_predictions",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), prediction_type: Optional[str] = Query(None, description='Filter by type (failure_likelihood/cost_overrun)'), subject_type: Optional[str] = Query(None, description='Filter by subject type (worker/run/tenant)'), subject_id: Optional[str] = Query(None, description='Filter by subject ID'), include_expired: bool = Query(False, description='Include expired predictions'), limit: int = Query(50, ge=1, le=200, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), session = Depends(get_session_dep), auth: AuthorityResult = Depends(require_predictions_read))",
            "docstring": "List prediction events (PB-S5).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.\nAll predictions are ADVISORY only.",
            "is_async": true,
            "line": 105
          },
          {
            "name": "get_prediction",
            "signature": "(prediction_id: str, session = Depends(get_session_dep), auth: AuthorityResult = Depends(require_predictions_read))",
            "docstring": "Get detailed prediction by ID (PB-S5).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.\nThis prediction is ADVISORY only.",
            "is_async": true,
            "line": 175
          },
          {
            "name": "get_predictions_for_subject",
            "signature": "(subject_type: str, subject_id: str, include_expired: bool = Query(False, description='Include expired predictions'), limit: int = Query(20, ge=1, le=100, description='Maximum results'), session = Depends(get_session_dep), auth: AuthorityResult = Depends(require_predictions_read))",
            "docstring": "Get all predictions for a specific subject (PB-S5).\n\nREAD-ONLY: This endpoint only reads data.\nReturns all advisory predictions for a worker/run/tenant.",
            "is_async": true,
            "line": 229
          },
          {
            "name": "get_prediction_stats",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), include_expired: bool = Query(False, description='Include expired predictions'), session = Depends(get_session_dep), auth: AuthorityResult = Depends(require_predictions_read))",
            "docstring": "Get prediction statistics (PB-S5).\n\nREAD-ONLY: This endpoint only reads aggregated data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 269
          }
        ],
        "classes": [
          {
            "name": "PredictionSummaryResponse",
            "docstring": "Summary of a prediction event.",
            "methods": [],
            "line": 55
          },
          {
            "name": "PredictionListResponse",
            "docstring": "Paginated list of predictions.",
            "methods": [],
            "line": 70
          },
          {
            "name": "PredictionDetailResponse",
            "docstring": "Detailed prediction event record.",
            "methods": [],
            "line": 81
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "emit_authority_audit",
              "require_predictions_read"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_operation_registry",
              "get_session_dep",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "scenarios.py",
        "file_path": "backend/app/hoc/api/cus/analytics/scenarios.py",
        "layer": "L2_api",
        "domain": "analytics",
        "lines": 525,
        "module_docstring": "Scenario-based Cost Simulation API (H2)\n\nREAD-ONLY simulation endpoints for scenario planning.\n\nINVARIANTS:\n- Pure computation ONLY - no real budget changes\n- No side effects - no database writes for simulation results\n- Advisory only - results are informational, not actionable\n- Scenarios can be stored for re-use (stored in-memory for v1)\n\nEndpoints:\n- GET /scenarios - List available scenarios\n- POST /scenarios - Create new scenario\n- GET /scenarios/{id} - Get scenario details\n- DELETE /scenarios/{id} - Delete scenario\n- POST /scenarios/{id}/simulate - Run simulation (pure computation)\n- POST /scenarios/simulate-adhoc - Run one-off simulation without saving\n\nReference: Phase H2 - Cost Simulation v1",
        "functions": [
          {
            "name": "_init_default_scenarios",
            "signature": "()",
            "docstring": "Initialize default template scenarios for quick access.",
            "is_async": false,
            "line": 168
          },
          {
            "name": "_simulate_plan",
            "signature": "(plan: List[SimulationStepInput], budget_cents: int) -> SimulationResult",
            "docstring": "Run pure simulation on a plan.\n\nINVARIANT: This function has NO side effects.\n- No database writes\n- No external API calls\n- No budget mutations\n- Pure computation only",
            "is_async": false,
            "line": 220
          },
          {
            "name": "list_scenarios",
            "signature": "(include_templates: bool = Query(True, description='Include template scenarios'))",
            "docstring": "List all available scenarios.\n\nReturns both user-created scenarios and template scenarios.\nTemplates are pre-defined common scenarios for quick testing.",
            "is_async": true,
            "line": 338
          },
          {
            "name": "create_scenario",
            "signature": "(request: ScenarioCreate)",
            "docstring": "Create a new scenario.\n\nScenarios are stored in-memory for v1 (session-ephemeral).\nThis ensures no persistent side-effects from scenario creation.",
            "is_async": true,
            "line": 368
          },
          {
            "name": "get_scenario",
            "signature": "(scenario_id: str)",
            "docstring": "Get a specific scenario by ID.",
            "is_async": true,
            "line": 407
          },
          {
            "name": "delete_scenario",
            "signature": "(scenario_id: str)",
            "docstring": "Delete a scenario.\n\nTemplate scenarios cannot be deleted.",
            "is_async": true,
            "line": 428
          },
          {
            "name": "simulate_scenario",
            "signature": "(scenario_id: str, budget_override: Optional[int] = Query(None, ge=0, le=1000000, description='Override budget'))",
            "docstring": "Run simulation for a saved scenario.\n\nINVARIANT: Pure computation only.\n- No database writes\n- No budget mutations\n- No external side-effects\n- Results are advisory only",
            "is_async": true,
            "line": 451
          },
          {
            "name": "simulate_adhoc",
            "signature": "(request: AdhocSimulationRequest)",
            "docstring": "Run ad-hoc simulation without saving scenario.\n\nUse this for quick one-off simulations.\n\nINVARIANT: Pure computation only.\n- No database writes\n- No budget mutations\n- No external side-effects\n- Results are advisory only",
            "is_async": true,
            "line": 480
          },
          {
            "name": "get_immutability_info",
            "signature": "()",
            "docstring": "Get information about the immutability guarantees.\n\nThis endpoint documents the READ-ONLY nature of scenario simulations.",
            "is_async": true,
            "line": 507
          }
        ],
        "classes": [
          {
            "name": "SimulationStepInput",
            "docstring": "A single step in a simulation plan.",
            "methods": [],
            "line": 62
          },
          {
            "name": "ScenarioCreate",
            "docstring": "Request to create a new scenario.",
            "methods": [],
            "line": 70
          },
          {
            "name": "ScenarioModel",
            "docstring": "Stored scenario model.",
            "methods": [],
            "line": 79
          },
          {
            "name": "ScenarioResponse",
            "docstring": "Response for scenario operations.",
            "methods": [],
            "line": 92
          },
          {
            "name": "StepEstimate",
            "docstring": "Cost estimate for a single step.",
            "methods": [],
            "line": 105
          },
          {
            "name": "SimulationResult",
            "docstring": "Result of a scenario simulation (advisory only).",
            "methods": [],
            "line": 116
          },
          {
            "name": "AdhocSimulationRequest",
            "docstring": "Request for ad-hoc simulation without saving scenario.",
            "methods": [],
            "line": 156
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "verify_fops_token"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l4_spine": [],
    "l5_engines": [
      {
        "file_name": "analytics_facade.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/analytics_facade.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 628,
        "module_docstring": "Analytics Facade (L5)\n\nProvides unified access to analytics domain operations.\nThis is the single entry point for all analytics business logic.\n\nOperations:\n- get_usage_statistics: Get usage statistics for a time window\n- get_cost_statistics: Get cost statistics for a time window\n- get_status: Get analytics domain capability status\n\nSignal Sources:\n- cost_records (cost attribution)\n- llm.usage (LLM runs)\n- worker.execution (trace execution)\n- gateway.metrics (API gateway)\n\nReference: Analytics Domain Declaration v1",
        "functions": [
          {
            "name": "get_analytics_facade",
            "signature": "() -> AnalyticsFacade",
            "docstring": "Get the singleton AnalyticsFacade instance.",
            "is_async": false,
            "line": 623
          }
        ],
        "classes": [
          {
            "name": "TimeWindowResult",
            "docstring": "Time window specification.",
            "methods": [],
            "line": 73
          },
          {
            "name": "UsageTotalsResult",
            "docstring": "Aggregate usage totals.",
            "methods": [],
            "line": 82
          },
          {
            "name": "UsageDataPointResult",
            "docstring": "Single data point in usage time series.",
            "methods": [],
            "line": 91
          },
          {
            "name": "SignalSourceResult",
            "docstring": "Signal source metadata.",
            "methods": [],
            "line": 101
          },
          {
            "name": "UsageStatisticsResult",
            "docstring": "Usage statistics result.",
            "methods": [],
            "line": 109
          },
          {
            "name": "CostTotalsResult",
            "docstring": "Aggregate cost totals.",
            "methods": [],
            "line": 119
          },
          {
            "name": "CostDataPointResult",
            "docstring": "Single data point in cost time series.",
            "methods": [],
            "line": 130
          },
          {
            "name": "CostByModelResult",
            "docstring": "Cost breakdown by model.",
            "methods": [],
            "line": 141
          },
          {
            "name": "CostByFeatureResult",
            "docstring": "Cost breakdown by feature tag.",
            "methods": [],
            "line": 153
          },
          {
            "name": "CostStatisticsResult",
            "docstring": "Cost statistics result.",
            "methods": [],
            "line": 163
          },
          {
            "name": "TopicStatusResult",
            "docstring": "Status of a topic within a subdomain.",
            "methods": [],
            "line": 175
          },
          {
            "name": "AnalyticsStatusResult",
            "docstring": "Analytics domain status.",
            "methods": [],
            "line": 184
          },
          {
            "name": "SignalAdapter",
            "docstring": "Signal adapters for fetching data from various sources.\n\nFacade owns:\n- Time alignment\n- Cardinality control\n- Cross-signal reconciliation\n- Forward compatibility",
            "methods": [
              "fetch_cost_metrics",
              "fetch_llm_usage",
              "fetch_worker_execution",
              "fetch_cost_spend",
              "fetch_cost_by_model",
              "fetch_cost_by_feature"
            ],
            "line": 197
          },
          {
            "name": "AnalyticsFacade",
            "docstring": "Unified facade for Analytics domain operations.\n\nThis class provides a single entry point for all analytics business logic.",
            "methods": [
              "__init__",
              "get_usage_statistics",
              "get_cost_statistics",
              "get_status",
              "_calculate_freshness",
              "_calculate_freshness_from_cost"
            ],
            "line": 318
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.hoc.cus.analytics.L6_drivers.analytics_read_driver",
            "names": [
              "get_analytics_read_driver"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.analytics.L5_schemas.query_types",
            "names": [
              "ResolutionType",
              "ScopeType"
            ],
            "is_relative": false,
            "line": 64
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "canary_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/canary_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 716,
        "module_docstring": "Daily canary runner for CostSim V2 validation.\n\nThe canary runner:\n1. Acquires leader lock (only one instance runs at a time)\n2. Loads a sample of historical simulation requests\n3. Runs both V1 and V2 on each sample\n4. Computes drift metrics (KL divergence, percentiles, outliers)\n5. Compares V2 against golden reference datasets\n6. Produces a CanaryReport with pass/fail verdict\n7. Triggers circuit breaker if drift exceeds thresholds\n\nRuns daily via systemd timer or cron.\n\nLeader Election:\n    Only one replica should run the canary at a time. The runner uses\n    PostgreSQL advisory locks to ensure single execution across replicas.\n    If another instance holds the lock, run() returns immediately with\n    a skip status.",
        "functions": [
          {
            "name": "run_canary",
            "signature": "(sample_count: int = 100, drift_threshold: float = 0.2, session: Any = None) -> CanaryReport",
            "docstring": "Convenience function to run canary.\n\nArgs:\n    sample_count: Number of samples to test\n    drift_threshold: Maximum acceptable drift\n    session: Optional async session (from L4 coordinator, for DB persistence)\n\nReturns:\n    CanaryReport",
            "is_async": true,
            "line": 695
          }
        ],
        "classes": [
          {
            "name": "CanarySample",
            "docstring": "A single canary test sample.",
            "methods": [],
            "line": 76
          },
          {
            "name": "CanaryRunConfig",
            "docstring": "Configuration for a canary run.",
            "methods": [],
            "line": 87
          },
          {
            "name": "CanaryRunner",
            "docstring": "Daily canary runner for V2 validation.\n\nUsage:\n    runner = CanaryRunner()\n    report = await runner.run()\n\n    if report.passed:\n        print(\"Canary passed!\")\n    else:\n        print(f\"Canary failed: {report.failure_reasons}\")",
            "methods": [
              "__init__",
              "run",
              "_run_internal",
              "_load_samples",
              "_generate_synthetic_samples",
              "_run_single",
              "_calculate_metrics",
              "_approximate_kl_divergence",
              "_compare_with_golden",
              "_evaluate_results",
              "_persist_report_to_db",
              "_save_artifacts"
            ],
            "line": 112
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "math",
            "names": [
              "math"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.cross_domain_gateway",
            "names": [
              "get_circuit_breaker"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.cross_domain_gateway",
            "names": [
              "report_drift"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.config_engine",
            "names": [
              "get_config"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.hoc.cus.analytics.L6_drivers.leader_driver",
            "names": [
              "LOCK_CANARY_RUNNER",
              "leader_election"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.costsim_models",
            "names": [
              "CanaryReport",
              "ComparisonResult",
              "ComparisonVerdict",
              "DiffResult"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.provenance",
            "names": [
              "get_provenance_logger"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.v2_adapter",
            "names": [
              "CostSimV2Adapter"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "app.worker.simulate",
            "names": [
              "CostSimulator"
            ],
            "is_relative": false,
            "line": 70
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "config_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/config_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 48,
        "module_docstring": "CostSim V2 Configuration - BACKWARD COMPATIBILITY RE-EXPORTS\n\nPIN-521 Migration:\n- Canonical home is now hoc_spine/services/costsim_config.py\n- This file re-exports for backward compatibility\n- L6 drivers MUST import from hoc_spine (not here)\n- New code SHOULD import from hoc_spine/services\n\nTo migrate existing imports:\n    OLD: from app.hoc.cus.analytics.L5_engines.config_engine import get_config\n    NEW: from app.hoc.cus.hoc_spine.services.costsim_config import get_config",
        "functions": [],
        "classes": [],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.services.costsim_config",
            "names": [
              "CostSimConfig",
              "get_commit_sha",
              "get_config",
              "is_v2_disabled_by_drift",
              "is_v2_sandbox_enabled"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": [
          "CostSimConfig",
          "get_config",
          "is_v2_sandbox_enabled",
          "is_v2_disabled_by_drift",
          "get_commit_sha"
        ]
      },
      {
        "file_name": "cost_anomaly_detector_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/cost_anomaly_detector_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 990,
        "module_docstring": "M29 Cost Anomaly Detector - Aligned Rules\n\nCategory 4 Anomaly Rules:\n1. Absolute spike: daily_spend > baseline * 1.4 FOR 2 consecutive daily intervals\n2. Sustained drift: 7d rolling avg > baseline_7d * 1.25 FOR >= 3 days\n3. Severity: LOW +15-25%, MEDIUM +25-40%, HIGH >40%\n\nTHE INVARIANT: Every anomaly triggers an action, not a chart.\n\nDetection Types:\n- ABSOLUTE_SPIKE: Consecutive daily breaches (user, feature, tenant)\n- SUSTAINED_DRIFT: Rolling average above baseline for multiple days\n- BUDGET_WARNING: Projected overrun (warn threshold)\n- BUDGET_EXCEEDED: Hard stop (budget exhausted)",
        "functions": [
          {
            "name": "classify_severity",
            "signature": "(deviation_pct: float) -> AnomalySeverity",
            "docstring": "Classify severity based on percentage deviation.\n\nPlan alignment:\n- LOW: +15% to +25%\n- MEDIUM: +25% to +40%\n- HIGH: >40%\n\nNote: Below 15% is not an anomaly.",
            "is_async": false,
            "line": 140
          },
          {
            "name": "run_anomaly_detection",
            "signature": "(session, tenant_id: str) -> List[PersistedAnomaly]",
            "docstring": "Run anomaly detection and persist results.",
            "is_async": true,
            "line": 905
          },
          {
            "name": "_run_anomaly_detection_with_facts",
            "signature": "(session, tenant_id: str) -> dict",
            "docstring": "Run anomaly detection and emit CostAnomalyFact for HIGH anomalies.\n\nR1 RESOLUTION: Analytics no longer creates incidents directly.\nThis function returns pure facts that callers can pass to the\nincidents domain bridge for incident creation.\n\nAuthority model:\n- Analytics: Detect anomalies, compute severity/confidence (this function)\n- Incidents: Decide if anomaly warrants incident creation (bridge)\n\nReturns:\n    {\n        \"detected\": [PersistedAnomaly, ...],\n        \"facts\": [CostAnomalyFact, ...],  # Pure facts for HIGH+ anomalies\n    }\n\nNote:\n    Callers that need incident creation should use:\n    # PIN-510: Deprecated \u2014 use AnomalyIncidentCoordinator instead\n    from app.hoc.cus.incidents.L5_engines.anomaly_bridge import AnomalyIncidentBridge\n    bridge = AnomalyIncidentBridge(session)\n    for fact in result[\"facts\"]:\n        incident_id = bridge.ingest(fact)",
            "is_async": true,
            "line": 921
          }
        ],
        "classes": [
          {
            "name": "AnomalyType",
            "docstring": "Cost anomaly types - minimal set.",
            "methods": [],
            "line": 61
          },
          {
            "name": "AnomalySeverity",
            "docstring": "Aligned severity bands per plan.",
            "methods": [],
            "line": 70
          },
          {
            "name": "DerivedCause",
            "docstring": "Deterministic cause derivation.",
            "methods": [],
            "line": 78
          },
          {
            "name": "DetectedAnomaly",
            "docstring": "A detected cost anomaly.",
            "methods": [],
            "line": 119
          },
          {
            "name": "CostAnomalyDetector",
            "docstring": "Detects cost anomalies with aligned rules.\n\nPhase-2.5A Extraction: DB operations delegated to CostAnomalyDriver (L6).\nThis engine (L4) retains:\n- Threshold comparisons\n- Severity classification\n- Anomaly type decisions\n\nRules:\n1. ABSOLUTE_SPIKE: daily > baseline * 1.4 for 2 consecutive intervals\n2. SUSTAINED_DRIFT: 7d rolling avg > baseline_7d * 1.25 for >= 3 days\n3. BUDGET_WARNING: spend > warn_threshold_pct of budget\n4. BUDGET_EXCEEDED: spend >= 100% of budget",
            "methods": [
              "__init__",
              "detect_all",
              "detect_absolute_spikes",
              "_detect_entity_spikes",
              "_detect_tenant_spike",
              "detect_sustained_drift",
              "detect_budget_issues",
              "_check_budget_threshold",
              "_record_breach_and_get_consecutive_count",
              "_reset_breach_history",
              "_update_drift_tracking",
              "_reset_drift_tracking",
              "_derive_cause",
              "_format_spike_message",
              "persist_anomalies"
            ],
            "line": 167
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.analytics.L5_schemas.cost_anomaly_dtos",
            "names": [
              "PersistedAnomaly"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [
          {
            "name": "ABSOLUTE_SPIKE_THRESHOLD",
            "line": 94
          },
          {
            "name": "CONSECUTIVE_INTERVALS_REQUIRED",
            "line": 97
          },
          {
            "name": "SUSTAINED_DRIFT_THRESHOLD",
            "line": 100
          },
          {
            "name": "DRIFT_DAYS_REQUIRED",
            "line": 103
          },
          {
            "name": "SEVERITY_BANDS",
            "line": 106
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "cost_model.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/cost_model.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 455,
        "module_docstring": "L4 Cost Model Engine - Domain Authority for Cost/Risk Estimation\n\nB02 FIX: Moved from L3 CostSimV2Adapter to L4 domain engine.\nThis engine is the authoritative source for:\n- Cost model coefficients (per-skill pricing)\n- Risk estimation logic\n- Feasibility determination\n- Drift classification\n\nL3 adapters must delegate all domain decisions to this engine.",
        "functions": [
          {
            "name": "get_skill_coefficients",
            "signature": "(skill_id: str) -> Dict[str, float]",
            "docstring": "Get cost model coefficients for a skill (L4 domain function).\n\nArgs:\n    skill_id: Skill identifier\n\nReturns:\n    Coefficient dictionary",
            "is_async": false,
            "line": 193
          },
          {
            "name": "estimate_step_cost",
            "signature": "(step_index: int, skill_id: str, params: Dict[str, Any]) -> StepCostEstimate",
            "docstring": "Estimate cost and latency for a single step (L4 domain function).\n\nL3 adapters must NOT implement their own estimation logic.\n\nArgs:\n    step_index: Step position in plan\n    skill_id: Skill identifier\n    params: Step parameters\n\nReturns:\n    StepCostEstimate with cost, latency, confidence, and risks",
            "is_async": false,
            "line": 206
          },
          {
            "name": "calculate_cumulative_risk",
            "signature": "(risks: List[Dict[str, float]]) -> float",
            "docstring": "Calculate cumulative risk from individual risk factors (L4 domain function).\n\nUses probability complement formula: 1 - prod(1 - p_i)\n\nArgs:\n    risks: List of risk factor dictionaries\n\nReturns:\n    Cumulative risk probability (0.0 to 1.0)",
            "is_async": false,
            "line": 301
          },
          {
            "name": "check_feasibility",
            "signature": "(estimated_cost_cents: int, budget_cents: int, permission_gaps: List[str], cumulative_risk: float, risk_threshold: float = DEFAULT_RISK_THRESHOLD) -> FeasibilityResult",
            "docstring": "Check if a plan is feasible (L4 domain function).\n\nL3 adapters must NOT implement feasibility logic.\n\nArgs:\n    estimated_cost_cents: Estimated total cost\n    budget_cents: Available budget\n    permission_gaps: Skills without permission\n    cumulative_risk: Cumulative risk probability\n    risk_threshold: Maximum acceptable risk\n\nReturns:\n    FeasibilityResult with decision and reasons",
            "is_async": false,
            "line": 320
          },
          {
            "name": "classify_drift",
            "signature": "(v1_cost_cents: int, v2_cost_cents: int, v1_feasible: bool, v2_feasible: bool) -> DriftAnalysis",
            "docstring": "Classify drift between V1 and V2 simulation results (L4 domain function).\n\nL3 adapters must NOT implement drift classification.\n\nArgs:\n    v1_cost_cents: V1 estimated cost\n    v2_cost_cents: V2 estimated cost\n    v1_feasible: V1 feasibility\n    v2_feasible: V2 feasibility\n\nReturns:\n    DriftAnalysis with verdict and details",
            "is_async": false,
            "line": 366
          },
          {
            "name": "is_significant_risk",
            "signature": "(probability: float) -> bool",
            "docstring": "Check if a risk factor is significant enough to report (L4 domain function).",
            "is_async": false,
            "line": 424
          }
        ],
        "classes": [
          {
            "name": "DriftVerdict",
            "docstring": "Classification of drift between V1 and V2 simulation results.",
            "methods": [],
            "line": 128
          },
          {
            "name": "StepCostEstimate",
            "docstring": "Enhanced step estimate with confidence (L4 domain output).",
            "methods": [],
            "line": 159
          },
          {
            "name": "FeasibilityResult",
            "docstring": "Result of feasibility check (L4 domain output).",
            "methods": [],
            "line": 171
          },
          {
            "name": "DriftAnalysis",
            "docstring": "Result of drift analysis between V1 and V2 (L4 domain output).",
            "methods": [],
            "line": 183
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [
          {
            "name": "DRIFT_THRESHOLD_MATCH",
            "line": 138
          },
          {
            "name": "DRIFT_THRESHOLD_MINOR",
            "line": 139
          },
          {
            "name": "DRIFT_THRESHOLD_MAJOR",
            "line": 140
          },
          {
            "name": "DEFAULT_RISK_THRESHOLD",
            "line": 148
          },
          {
            "name": "SIGNIFICANT_RISK_THRESHOLD",
            "line": 151
          },
          {
            "name": "CONFIDENCE_DEGRADATION_LONG_PROMPT",
            "line": 154
          },
          {
            "name": "CONFIDENCE_DEGRADATION_VERY_LONG_PROMPT",
            "line": 155
          }
        ],
        "all_exports": [
          "SKILL_COST_COEFFICIENTS",
          "UNKNOWN_SKILL_COEFFICIENTS",
          "DEFAULT_RISK_THRESHOLD",
          "SIGNIFICANT_RISK_THRESHOLD",
          "DRIFT_THRESHOLD_MATCH",
          "DRIFT_THRESHOLD_MINOR",
          "DRIFT_THRESHOLD_MAJOR",
          "DriftVerdict",
          "StepCostEstimate",
          "FeasibilityResult",
          "DriftAnalysis",
          "get_skill_coefficients",
          "estimate_step_cost",
          "calculate_cumulative_risk",
          "check_feasibility",
          "classify_drift",
          "is_significant_risk"
        ]
      },
      {
        "file_name": "cost_snapshots_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/cost_snapshots_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 409,
        "module_docstring": "M27 Cost Snapshots - Deterministic Enforcement Barrier\n\nThis module provides the snapshot layer between async cost ingestion\nand synchronous anomaly detection.\n\nTHE INVARIANT:\n  Anomaly detection reads ONLY from complete snapshots, never from live data.\n\nArchitecture:\n  cost_records (streaming, async)\n         \u2193\n  SnapshotComputer.compute_snapshot()\n         \u2193\n  cost_snapshots (status='complete')\n         \u2193\n  CostAnomalyDetector.evaluate_from_snapshot()\n\nUsage:\n  # Scheduled job (e.g., every hour)\n  driver = get_cost_snapshots_driver(session)\n  computer = SnapshotComputer(driver)\n  snapshot = await computer.compute_hourly_snapshot(tenant_id)\n\n  # Anomaly detection (only reads complete snapshots)\n  detector = SnapshotAnomalyDetector(driver)\n  anomalies = await detector.evaluate_from_snapshot(snapshot.id)",
        "functions": [
          {
            "name": "run_hourly_snapshot_job",
            "signature": "(driver: CostSnapshotsDriverProtocol, tenant_ids: list[str]) -> dict",
            "docstring": "Run hourly snapshot job for multiple tenants.\n\nSchedule this via cron/systemd timer every hour at :05.\nPIN-508: Accepts driver Protocol, not session.",
            "is_async": true,
            "line": 352
          },
          {
            "name": "run_daily_snapshot_and_baseline_job",
            "signature": "(driver: CostSnapshotsDriverProtocol, tenant_ids: list[str]) -> dict",
            "docstring": "Run daily snapshot and baseline computation for multiple tenants.\n\nSchedule this via cron/systemd timer daily at 00:30.\nPIN-508: Accepts driver Protocol, not session.",
            "is_async": true,
            "line": 374
          }
        ],
        "classes": [
          {
            "name": "SnapshotComputer",
            "docstring": "Computes cost snapshots from raw cost_records.\n\nPIN-508: Accepts CostSnapshotsDriverProtocol \u2014 no session parameter.\n\nUsage:\n    driver = get_cost_snapshots_driver(session)\n    computer = SnapshotComputer(driver)\n    snapshot = await computer.compute_hourly_snapshot(tenant_id)",
            "methods": [
              "__init__",
              "compute_hourly_snapshot",
              "compute_daily_snapshot",
              "_compute_snapshot"
            ],
            "line": 81
          },
          {
            "name": "BaselineComputer",
            "docstring": "Computes rolling baselines from historical snapshots.\n\nPIN-508: Accepts CostSnapshotsDriverProtocol \u2014 no session parameter.",
            "methods": [
              "__init__",
              "compute_baselines"
            ],
            "line": 207
          },
          {
            "name": "SnapshotAnomalyDetector",
            "docstring": "Detects anomalies from complete snapshots only.\n\nTHE INVARIANT:\n  This detector NEVER reads from cost_records.\n  It ONLY reads from complete snapshots.\n\nPIN-508: Accepts CostSnapshotsDriverProtocol \u2014 no session parameter.",
            "methods": [
              "__init__",
              "evaluate_snapshot"
            ],
            "line": 251
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "L5_schemas.cost_snapshot_schemas",
            "names": [
              "SEVERITY_THRESHOLDS",
              "AnomalyEvaluation",
              "CostSnapshot",
              "CostSnapshotsDriverProtocol",
              "EntityType",
              "SnapshotAggregate",
              "SnapshotBaseline",
              "SnapshotStatus",
              "SnapshotType"
            ],
            "is_relative": true,
            "line": 55
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cost_write.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/cost_write.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 49,
        "module_docstring": "Cost Write Engine (L5)\n\nThin L5 facade over the L6 CostWriteDriver. Provides backwards-compatible\nCostWriteService class that cost_intelligence.py expects.\n\nPIN-520 Phase 1: This file enables the migration path for cost_intelligence.py\nto eventually route through L4 registry.",
        "functions": [
          {
            "name": "get_cost_write_service",
            "signature": "(session: Session) -> CostWriteService",
            "docstring": "Get cost write service instance.\n\nBackwards-compatible accessor that delegates to L6 driver.",
            "is_async": false,
            "line": 38
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "app.hoc.cus.analytics.L6_drivers.cost_write_driver",
            "names": [
              "CostWriteDriver",
              "get_cost_write_driver"
            ],
            "is_relative": false,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": [
          "CostWriteService",
          "get_cost_write_service"
        ]
      },
      {
        "file_name": "costsim_models.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/costsim_models.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 306,
        "module_docstring": "Data models for CostSim V2 sandbox evaluation.",
        "functions": [],
        "classes": [
          {
            "name": "V2SimulationStatus",
            "docstring": "V2 simulation result status.",
            "methods": [],
            "line": 34
          },
          {
            "name": "ComparisonVerdict",
            "docstring": "Verdict from V1 vs V2 comparison.",
            "methods": [],
            "line": 43
          },
          {
            "name": "V2SimulationResult",
            "docstring": "Result from CostSim V2 simulation.",
            "methods": [
              "to_dict",
              "compute_output_hash"
            ],
            "line": 53
          },
          {
            "name": "ComparisonResult",
            "docstring": "Result of comparing V2 vs V1 simulation.",
            "methods": [
              "to_dict"
            ],
            "line": 110
          },
          {
            "name": "DiffResult",
            "docstring": "Detailed diff between two simulation results.",
            "methods": [
              "to_dict"
            ],
            "line": 151
          },
          {
            "name": "CanaryReport",
            "docstring": "Report from daily canary run.",
            "methods": [
              "to_dict"
            ],
            "line": 183
          },
          {
            "name": "DivergenceReport",
            "docstring": "Cost divergence report between V1 and V2.",
            "methods": [
              "to_dict"
            ],
            "line": 234
          },
          {
            "name": "ValidationResult",
            "docstring": "Result of validating V2 against a reference dataset.",
            "methods": [
              "to_dict"
            ],
            "line": 271
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "datasets_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/datasets_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 724,
        "module_docstring": "Reference datasets for V2 validation.\n\nRequired datasets (5):\n1. low_variance - Simple, predictable plans\n2. high_variance - Complex, high-variance plans\n3. mixed_city - Mixed workload patterns\n4. noise_injected - Plans with deliberate noise\n5. historical - Real historical data samples\n\nEach dataset provides:\n- Sample plans for testing\n- Expected V2 behavior\n- Validation metrics thresholds",
        "functions": [
          {
            "name": "get_dataset_validator",
            "signature": "() -> DatasetValidator",
            "docstring": "Get the global dataset validator.",
            "is_async": false,
            "line": 707
          },
          {
            "name": "validate_dataset",
            "signature": "(dataset_id: str) -> ValidationResult",
            "docstring": "Convenience function to validate a dataset.",
            "is_async": true,
            "line": 715
          },
          {
            "name": "validate_all_datasets",
            "signature": "() -> Dict[str, ValidationResult]",
            "docstring": "Convenience function to validate all datasets.",
            "is_async": true,
            "line": 721
          }
        ],
        "classes": [
          {
            "name": "DatasetSample",
            "docstring": "A single sample in a reference dataset.",
            "methods": [],
            "line": 51
          },
          {
            "name": "ReferenceDataset",
            "docstring": "A reference dataset for validation.",
            "methods": [
              "to_dict"
            ],
            "line": 64
          },
          {
            "name": "DatasetValidator",
            "docstring": "Validator for V2 against reference datasets.\n\nUsage:\n    validator = DatasetValidator()\n    result = await validator.validate_dataset(\"low_variance\")",
            "methods": [
              "__init__",
              "_build_datasets",
              "_build_low_variance_dataset",
              "_build_high_variance_dataset",
              "_build_mixed_city_dataset",
              "_build_noise_injected_dataset",
              "_build_historical_dataset",
              "list_datasets",
              "get_dataset",
              "validate_dataset",
              "_calculate_drift_score",
              "validate_all"
            ],
            "line": 84
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "math",
            "names": [
              "math"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "random",
            "names": [
              "random"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.costsim_models",
            "names": [
              "ValidationResult"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.v2_adapter",
            "names": [
              "CostSimV2Adapter"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "detection_facade.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/detection_facade.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 615,
        "module_docstring": "Detection Facade (L5 Domain Engine)\n\nThis facade provides the external interface for anomaly detection operations.\nAll detection APIs MUST use this facade instead of directly importing\ninternal detection modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes anomaly detection logic\n- Provides unified access to cost, behavioral, and policy anomalies\n- Single point for audit emission\n\nWrapped Services:\n- CostAnomalyDetector: Cost anomaly detection (GAP-066)\n- (Future) BehavioralDetector: Behavioral anomaly detection\n- (Future) DriftDetector: Model drift detection\n\nL2 API Routes (GAP-102):\n- POST /api/v1/detection/run (run detection on demand)\n- GET /api/v1/detection/anomalies (list anomalies)\n- GET /api/v1/detection/anomalies/{id} (get anomaly)\n- POST /api/v1/detection/anomalies/{id}/resolve (resolve anomaly)\n- GET /api/v1/detection/status (detection engine status)\n\nUsage:\n    from app.hoc.cus.analytics.L5_engines.detection_facade import get_detection_facade\n\n    facade = get_detection_facade()\n\n    # Run detection\n    result = await facade.run_detection(tenant_id=\"...\", detection_type=\"cost\")\n\n    # List anomalies\n    anomalies = await facade.list_anomalies(tenant_id=\"...\")",
        "functions": [
          {
            "name": "get_detection_facade",
            "signature": "(anomaly_coordinator: Optional[AnomalyCoordinatorPort] = None) -> DetectionFacade",
            "docstring": "Get the detection facade instance.\n\nThis is the recommended way to access detection operations\nfrom L2 APIs and the SDK.\n\nPIN-520: L4 callers must inject anomaly_coordinator.\nL5 must not import from hoc_spine.\n\nArgs:\n    anomaly_coordinator: Optional coordinator for cost anomaly detection.\n                         Required for cost detection to work (injected by L4 caller).\n\nReturns:\n    DetectionFacade instance",
            "is_async": false,
            "line": 590
          }
        ],
        "classes": [
          {
            "name": "AnomalyCoordinatorPort",
            "docstring": "Protocol for anomaly detection + incident ingestion (PIN-520 L5 purity).\n\nL5 declares what it needs; L4 provides the implementation via bridge.\nThis removes the L5 \u2192 L4 orchestrator import violation.",
            "methods": [
              "detect_and_ingest"
            ],
            "line": 72
          },
          {
            "name": "DetectionType",
            "docstring": "Types of anomaly detection.",
            "methods": [],
            "line": 87
          },
          {
            "name": "AnomalyStatus",
            "docstring": "Anomaly resolution status.",
            "methods": [],
            "line": 102
          },
          {
            "name": "DetectionResult",
            "docstring": "Result of a detection run.",
            "methods": [
              "to_dict"
            ],
            "line": 111
          },
          {
            "name": "AnomalyInfo",
            "docstring": "Anomaly information.",
            "methods": [
              "to_dict"
            ],
            "line": 137
          },
          {
            "name": "DetectionStatusInfo",
            "docstring": "Detection engine status.",
            "methods": [
              "to_dict"
            ],
            "line": 181
          },
          {
            "name": "DetectionFacade",
            "docstring": "Facade for anomaly detection operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ndetection services.\n\nLayer: L5 (Domain Engine)\nCallers: detection.py (L2), aos_sdk, Worker\n\nPIN-520: anomaly_coordinator is now injected via L4 bridge instead of\nbeing imported directly from L4 orchestrator.",
            "methods": [
              "__init__",
              "cost_detector",
              "run_detection",
              "_run_cost_detection",
              "list_anomalies",
              "get_anomaly",
              "resolve_anomaly",
              "acknowledge_anomaly",
              "get_detection_status"
            ],
            "line": 198
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Protocol"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.cost_anomaly_detector_engine",
            "names": [
              "AnomalySeverity"
            ],
            "is_relative": false,
            "line": 97
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "divergence_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/divergence_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 366,
        "module_docstring": "Cost divergence reporting between V1 and V2.\n\nProvides:\n- delta_p50: Median cost delta\n- delta_p90: 90th percentile cost delta\n- kl_divergence: KL divergence between cost distributions\n- outlier_count: Number of outlier samples\n- fail_ratio: Ratio of major drift samples\n- matching_rate: Ratio of matching samples\n\nReports can be generated:\n- On-demand via API\n- Automatically by canary runner\n- Scheduled via cron/systemd timer",
        "functions": [
          {
            "name": "generate_divergence_report",
            "signature": "(start_date: Optional[datetime] = None, end_date: Optional[datetime] = None, tenant_id: Optional[str] = None) -> DivergenceReport",
            "docstring": "Convenience function to generate a divergence report.\n\nArgs:\n    start_date: Start of analysis period\n    end_date: End of analysis period\n    tenant_id: Filter by tenant\n\nReturns:\n    DivergenceReport",
            "is_async": true,
            "line": 345
          }
        ],
        "classes": [
          {
            "name": "DivergenceSample",
            "docstring": "A single sample for divergence analysis.",
            "methods": [],
            "line": 53
          },
          {
            "name": "DivergenceAnalyzer",
            "docstring": "Analyzer for V1 vs V2 cost divergence.\n\nUsage:\n    analyzer = DivergenceAnalyzer()\n    report = await analyzer.generate_report(\n        start_date=datetime.now() - timedelta(days=7),\n        end_date=datetime.now(),\n    )",
            "methods": [
              "__init__",
              "generate_report",
              "_load_samples",
              "_parse_provenance_log",
              "_calculate_metrics",
              "_calculate_kl_divergence"
            ],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "math",
            "names": [
              "math"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.config_engine",
            "names": [
              "get_config"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.costsim_models",
            "names": [
              "DivergenceReport"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.provenance",
            "names": [
              "ProvenanceLog",
              "get_provenance_logger"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "feedback_read_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/feedback_read_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 181,
        "module_docstring": "Feedback Read Engine (L5)\n\nBusiness logic for pattern feedback read operations (PB-S3 compliant).\nDelegates all DB access to L6 FeedbackReadDriver.\n\nOperations:\n- list_feedback: Paginated list with aggregation\n- get_feedback: Single record detail\n- get_feedback_stats: Summary statistics",
        "functions": [
          {
            "name": "get_feedback_read_engine",
            "signature": "() -> FeedbackReadEngine",
            "docstring": "Get feedback read engine singleton.",
            "is_async": false,
            "line": 176
          }
        ],
        "classes": [
          {
            "name": "FeedbackReadEngine",
            "docstring": "L5 engine for feedback read operations.\n\nBusiness logic (aggregation, formatting) lives here.\nDB access delegated to L6 driver.",
            "methods": [
              "list_feedback",
              "get_feedback",
              "get_feedback_stats"
            ],
            "line": 39
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.analytics.L6_drivers.feedback_read_driver",
            "names": [
              "get_feedback_read_driver"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "metrics_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/metrics_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 107,
        "module_docstring": "CostSim V2 Prometheus Metrics - BACKWARD COMPATIBILITY RE-EXPORTS\n\nPIN-521 Migration:\n- Canonical home is now hoc_spine/services/costsim_metrics.py\n- This file re-exports for backward compatibility\n- L6 drivers MUST import from hoc_spine (not here)\n- New code SHOULD import from hoc_spine/services\n\nTo migrate existing imports:\n    OLD: from app.hoc.cus.analytics.L5_engines.metrics_engine import get_metrics\n    NEW: from app.hoc.cus.hoc_spine.services.costsim_metrics import get_metrics",
        "functions": [
          {
            "name": "get_alert_rules",
            "signature": "() -> str",
            "docstring": "Get Prometheus alert rules YAML.",
            "is_async": false,
            "line": 94
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "app.hoc.cus.hoc_spine.services.costsim_metrics",
            "names": [
              "COST_DELTA_BUCKETS",
              "DRIFT_SCORE_BUCKETS",
              "DURATION_BUCKETS",
              "CostSimMetrics",
              "get_metrics"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [
          {
            "name": "ALERT_RULES_YAML",
            "line": 43
          }
        ],
        "all_exports": [
          "CostSimMetrics",
          "get_metrics",
          "DRIFT_SCORE_BUCKETS",
          "COST_DELTA_BUCKETS",
          "DURATION_BUCKETS",
          "ALERT_RULES_YAML",
          "get_alert_rules"
        ]
      },
      {
        "file_name": "prediction_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/prediction_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 473,
        "module_docstring": "Prediction Service (PB-S5)\n\nGenerates predictions WITHOUT affecting execution behavior.\n\nPhase-2.5A Extraction:\n- PERSISTENCE: Delegated to PredictionDriver (L6)\n- DECISIONS: Retained in this engine (L4)\n\nPB-S5 Contract:\n- Advise \u2192 Observe \u2192 Do Nothing\n- Predictions are advisory only\n- Predictions have zero side-effects\n- Predictions never modify execution, scheduling, or history\n\nRule: Advise, don't influence.",
        "functions": [
          {
            "name": "predict_failure_likelihood",
            "signature": "(driver: 'PredictionDriver', tenant_id: Optional[UUID] = None, worker_id: Optional[str] = None) -> list[dict]",
            "docstring": "Predict likelihood of failure for upcoming runs.\n\nPhase-2.5A: Data fetching delegated to driver (L6).\n\nPB-S5: This function calculates predictions only. No modifications.\nPredictions are advisory and have ZERO side-effects.\n\nReturns list of predictions with:\n- subject_id: worker or tenant being predicted\n- confidence_score: likelihood of failure (0.0-1.0)\n- contributing_factors: signals used for prediction",
            "is_async": true,
            "line": 76
          },
          {
            "name": "predict_cost_overrun",
            "signature": "(driver: 'PredictionDriver', tenant_id: Optional[UUID] = None, worker_id: Optional[str] = None) -> list[dict]",
            "docstring": "Predict likelihood of cost overrun for upcoming runs.\n\nPhase-2.5A: Data fetching delegated to driver (L6).\n\nPB-S5: This function calculates predictions only. No modifications.\nPredictions are advisory and have ZERO side-effects.\n\nReturns list of predictions with:\n- subject_id: worker or tenant being predicted\n- confidence_score: likelihood of overrun (0.0-1.0)\n- projected_cost: expected cost\n- contributing_factors: signals used for prediction",
            "is_async": true,
            "line": 175
          },
          {
            "name": "emit_prediction",
            "signature": "(driver: 'PredictionDriver', tenant_id: str, prediction_type: str, subject_type: str, subject_id: str, confidence_score: float, prediction_value: dict, contributing_factors: list, notes: Optional[str] = None, valid_until: Optional['datetime'] = None) -> 'PredictionEvent'",
            "docstring": "Emit a prediction event.\n\nPhase-2.5A: Persistence delegated to driver (L6).\n\nPB-S5: This creates a NEW record in prediction_events.\nIt does NOT modify any execution data. Predictions are advisory only.",
            "is_async": true,
            "line": 274
          },
          {
            "name": "run_prediction_cycle",
            "signature": "(tenant_id: Optional[UUID] = None, session: 'AsyncSession | None' = None) -> dict",
            "docstring": "Run full prediction cycle.\n\nPhase-2.5A: Data access delegated to driver (L6).\nThis method orchestrates the prediction flow (L4 DECISION).\n\nPB-S5: Generates predictions. No execution modifications.\n\nArgs:\n    tenant_id: Optional tenant filter.\n    session: AsyncSession provided by L4 handler (PIN-520 Phase 4).\n\nReturns summary of generated predictions.",
            "is_async": true,
            "line": 326
          },
          {
            "name": "get_prediction_summary",
            "signature": "(tenant_id: Optional[UUID] = None, prediction_type: Optional[str] = None, include_expired: bool = False, limit: int = 50, session: 'AsyncSession | None' = None) -> dict",
            "docstring": "Get prediction summary for ops visibility.\n\nPhase-2.5A: Data fetching delegated to driver (L6).\n\nPB-S5: Read-only query of predictions table.\n\nArgs:\n    session: AsyncSession provided by L4 handler (PIN-520 Phase 4).",
            "is_async": true,
            "line": 414
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "datetime",
            "names": [
              "timedelta"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 66
          }
        ],
        "constants": [
          {
            "name": "FAILURE_CONFIDENCE_THRESHOLD",
            "line": 71
          },
          {
            "name": "COST_OVERRUN_THRESHOLD_PERCENT",
            "line": 72
          },
          {
            "name": "PREDICTION_VALIDITY_HOURS",
            "line": 73
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "prediction_read_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/prediction_read_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 240,
        "module_docstring": "Prediction Read Engine (L5)\n\nBusiness logic for prediction event read operations (PB-S5 compliant).\nDelegates all DB access to L6 PredictionReadDriver.\n\nOperations:\n- list_predictions: Paginated list with aggregation\n- get_prediction: Single record detail\n- get_predictions_for_subject: All predictions for a subject\n- get_prediction_stats: Summary statistics with advisory compliance",
        "functions": [
          {
            "name": "get_prediction_read_engine",
            "signature": "() -> PredictionReadEngine",
            "docstring": "Get prediction read engine singleton.",
            "is_async": false,
            "line": 235
          }
        ],
        "classes": [
          {
            "name": "PredictionReadEngine",
            "docstring": "L5 engine for prediction read operations.\n\nBusiness logic (aggregation, compliance check, formatting) lives here.\nDB access delegated to L6 driver.",
            "methods": [
              "list_predictions",
              "get_prediction",
              "get_predictions_for_subject",
              "get_prediction_stats"
            ],
            "line": 41
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.hoc.cus.analytics.L6_drivers.prediction_read_driver",
            "names": [
              "get_prediction_read_driver"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "provenance.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/provenance.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 413,
        "module_docstring": "Full provenance logging for CostSim V2 sandbox.\n\nLogs:\n- input_hash: SHA256 of input\n- output_hash: SHA256 of output\n- input_json: Full input (optionally compressed)\n- output_json: Full output (optionally compressed)\n- model_version: V2 model version\n- adapter_version: Adapter version\n- commit_sha: Git commit\n- runtime_ms: Execution time\n- status: success/error/schema_error\n- tenant_id: Tenant if present",
        "functions": [
          {
            "name": "compute_hash",
            "signature": "(data: Any) -> str",
            "docstring": "Compute SHA256 hash of data.",
            "is_async": false,
            "line": 143
          },
          {
            "name": "compress_json",
            "signature": "(data: Any) -> str",
            "docstring": "Compress JSON data to base64-encoded gzip.",
            "is_async": false,
            "line": 152
          },
          {
            "name": "get_provenance_logger",
            "signature": "() -> ProvenanceLogger",
            "docstring": "Get the global provenance logger.",
            "is_async": false,
            "line": 408
          }
        ],
        "classes": [
          {
            "name": "ProvenanceLog",
            "docstring": "Single provenance log entry.",
            "methods": [
              "to_dict",
              "from_dict",
              "get_decompressed_input",
              "get_decompressed_output"
            ],
            "line": 56
          },
          {
            "name": "ProvenanceLogger",
            "docstring": "Logger for CostSim V2 provenance.\n\nStores provenance logs for every V2 simulation for:\n- Audit trail\n- Debugging\n- Drift analysis\n- Replay capability",
            "methods": [
              "__init__",
              "log",
              "_store",
              "_flush",
              "_write_to_file",
              "_write_to_db",
              "close",
              "query"
            ],
            "line": 159
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "base64",
            "names": [
              "base64"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "gzip",
            "names": [
              "gzip"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.config_engine",
            "names": [
              "get_commit_sha",
              "get_config"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "sandbox_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/sandbox_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 308,
        "module_docstring": "Sandbox routing layer for CostSim V1 vs V2.\n\nFeature flag controlled routing:\n- COSTSIM_V2_SANDBOX=false (default): Only V1, no V2\n- COSTSIM_V2_SANDBOX=true: Run both V1 and V2, log comparison\n\nThe sandbox NEVER changes production behavior. V1 is always\nthe source of truth. V2 runs in shadow mode for validation.",
        "functions": [
          {
            "name": "simulate_with_sandbox",
            "signature": "(plan: List[Dict[str, Any]], budget_cents: int = 1000, allowed_skills: Optional[List[str]] = None, tenant_id: Optional[str] = None, run_id: Optional[str] = None) -> SandboxResult",
            "docstring": "Convenience function for sandbox simulation.\n\nArgs:\n    plan: List of steps\n    budget_cents: Available budget\n    allowed_skills: Optional skill allowlist\n    tenant_id: Tenant identifier\n    run_id: Run identifier\n\nReturns:\n    SandboxResult",
            "is_async": true,
            "line": 245
          },
          {
            "name": "get_sandbox",
            "signature": "(budget_cents: int = 1000, tenant_id: Optional[str] = None) -> CostSimSandbox",
            "docstring": "Get a sandbox instance.\n\nNote: For tenant isolation, always create a new instance\nwith the correct tenant_id rather than using the global.\n\nArgs:\n    budget_cents: Available budget\n    tenant_id: Tenant identifier\n\nReturns:\n    CostSimSandbox instance",
            "is_async": false,
            "line": 278
          }
        ],
        "classes": [
          {
            "name": "SandboxResult",
            "docstring": "Result from sandbox routing.",
            "methods": [
              "production_result"
            ],
            "line": 55
          },
          {
            "name": "CostSimSandbox",
            "docstring": "Sandbox router for CostSim V1 vs V2.\n\nUsage:\n    sandbox = CostSimSandbox(budget_cents=1000)\n    result = await sandbox.simulate(plan)\n\n    # Production code uses v1_result\n    if result.v1_result.feasible:\n        execute_plan(plan)\n\n    # V2 comparison logged for validation\n    if result.comparison:\n        logger.info(f\"V2 drift: {result.comparison.drift_score}\")",
            "methods": [
              "__init__",
              "_get_v2_adapter",
              "simulate",
              "_log_comparison"
            ],
            "line": 77
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.cross_domain_gateway",
            "names": [
              "is_v2_disabled",
              "report_drift"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.config_engine",
            "names": [
              "is_v2_sandbox_enabled"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.costsim_models",
            "names": [
              "ComparisonResult",
              "ComparisonVerdict",
              "V2SimulationResult"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.v2_adapter",
            "names": [
              "CostSimV2Adapter"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.worker.simulate",
            "names": [
              "CostSimulator",
              "SimulationResult"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "v2_adapter.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/v2_adapter.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 434,
        "module_docstring": "CostSim V2 Adapter - Enhanced simulation with confidence scoring.\n\nB02 FIX: Cost modeling logic moved to L4 CostModelEngine.\nThis adapter now delegates domain decisions to L4:\n- Step cost estimation \u2192 L4 estimate_step_cost()\n- Feasibility checks \u2192 L4 check_feasibility()\n- Drift classification \u2192 L4 classify_drift()\n\nL5 responsibility: shape, transport, provenance, context binding.\n\nThis adapter wraps V1 CostSimulator and adds:\n1. Confidence scoring (delegated to L4)\n2. V2-specific model calculations (delegated to L4)\n3. Provenance logging integration\n4. Comparison with V1 results",
        "functions": [
          {
            "name": "simulate_v2",
            "signature": "(plan: List[Dict[str, Any]], budget_cents: int = 1000, allowed_skills: Optional[List[str]] = None, tenant_id: Optional[str] = None, run_id: Optional[str] = None) -> V2SimulationResult",
            "docstring": "Convenience function for V2 simulation.\n\nArgs:\n    plan: List of steps\n    budget_cents: Available budget\n    allowed_skills: Optional skill allowlist\n    tenant_id: Tenant identifier\n    run_id: Run identifier\n\nReturns:\n    V2SimulationResult",
            "is_async": true,
            "line": 385
          },
          {
            "name": "simulate_v2_with_comparison",
            "signature": "(plan: List[Dict[str, Any]], budget_cents: int = 1000, allowed_skills: Optional[List[str]] = None) -> tuple[V2SimulationResult, ComparisonResult]",
            "docstring": "Convenience function for V2 simulation with V1 comparison.\n\nArgs:\n    plan: List of steps\n    budget_cents: Available budget\n    allowed_skills: Optional skill allowlist\n\nReturns:\n    Tuple of (V2SimulationResult, ComparisonResult)",
            "is_async": true,
            "line": 414
          }
        ],
        "classes": [
          {
            "name": "V2StepEstimate",
            "docstring": "Enhanced step estimate with confidence.",
            "methods": [],
            "line": 62
          },
          {
            "name": "CostSimV2Adapter",
            "docstring": "CostSim V2 Adapter with enhanced modeling.\n\nUsage:\n    adapter = CostSimV2Adapter(budget_cents=1000)\n    result = await adapter.simulate(plan)\n\n    # Or with V1 comparison\n    result, comparison = await adapter.simulate_with_comparison(plan)",
            "methods": [
              "__init__",
              "_get_coefficients",
              "_estimate_step_v2",
              "simulate",
              "simulate_with_comparison",
              "_compare_results"
            ],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.config_engine",
            "names": [
              "get_commit_sha",
              "get_config"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.costsim_models",
            "names": [
              "ComparisonResult",
              "ComparisonVerdict",
              "V2SimulationResult",
              "V2SimulationStatus"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.provenance",
            "names": [
              "get_provenance_logger"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.worker.simulate",
            "names": [
              "CostSimulator",
              "SimulationResult"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [
      {
        "file_name": "cost_anomaly_dtos.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_schemas/cost_anomaly_dtos.py",
        "layer": "L5_schemas",
        "domain": "analytics",
        "lines": 44,
        "module_docstring": "Cost Anomaly Persistence DTOs\n\nReplaces direct CostAnomaly ORM usage in the L5 engine.\nL6 driver constructs/updates ORM objects and returns these DTOs.",
        "functions": [],
        "classes": [
          {
            "name": "PersistedAnomaly",
            "docstring": "DTO returned by L6 after persisting a CostAnomaly ORM row.\n\nContains only the fields the L5 engine needs to read back.",
            "methods": [],
            "line": 26
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 22
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cost_anomaly_schemas.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_schemas/cost_anomaly_schemas.py",
        "layer": "L5_schemas",
        "domain": "analytics",
        "lines": 52,
        "module_docstring": "Cost Anomaly Schemas (PIN-511 Phase 1.2)\n\nDefines the CostAnomalyReadProtocol that L5 engines depend on.\nL6 drivers implement this Protocol \u2014 engine never knows about Session.",
        "functions": [],
        "classes": [
          {
            "name": "CostAnomalyReadProtocol",
            "docstring": "Protocol for cost anomaly read/persist operations.\n\nImplemented by: CostAnomalyReadDriver (L6)\nConsumed by: CostAnomalyDetector (L5 engine)",
            "methods": [
              "fetch_active_budgets",
              "find_existing_anomaly",
              "persist_anomaly",
              "flush_and_refresh"
            ],
            "line": 24
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 14
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 16
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 17
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cost_snapshot_schemas.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_schemas/cost_snapshot_schemas.py",
        "layer": "L5_schemas",
        "domain": "analytics",
        "lines": 302,
        "module_docstring": "M27 Cost Snapshot Schemas\n\nDataclasses and enums for the cost snapshot system.",
        "functions": [],
        "classes": [
          {
            "name": "SnapshotType",
            "docstring": null,
            "methods": [],
            "line": 32
          },
          {
            "name": "SnapshotStatus",
            "docstring": null,
            "methods": [],
            "line": 37
          },
          {
            "name": "EntityType",
            "docstring": null,
            "methods": [],
            "line": 44
          },
          {
            "name": "CostSnapshot",
            "docstring": "Point-in-time cost snapshot definition.",
            "methods": [
              "create",
              "to_dict"
            ],
            "line": 66
          },
          {
            "name": "SnapshotAggregate",
            "docstring": "Aggregated cost data for an entity within a snapshot.",
            "methods": [
              "create"
            ],
            "line": 119
          },
          {
            "name": "SnapshotBaseline",
            "docstring": "Rolling baseline for an entity (used for anomaly threshold).",
            "methods": [
              "create"
            ],
            "line": 170
          },
          {
            "name": "AnomalyEvaluation",
            "docstring": "Audit record for an anomaly evaluation.",
            "methods": [],
            "line": 227
          },
          {
            "name": "CostSnapshotsDriverProtocol",
            "docstring": "Typed boundary contract for cost snapshot database operations.\n\nPIN-508 Gap 1: L5\u2194L6 boundary enforced by Protocol, not convention.\nL5 engines accept this Protocol \u2014 they never see a session.",
            "methods": [
              "insert_snapshot",
              "update_snapshot",
              "insert_aggregate",
              "get_current_baseline",
              "aggregate_cost_records",
              "insert_baseline",
              "get_snapshot",
              "get_aggregates_with_baseline",
              "insert_evaluation",
              "insert_anomaly",
              "compute_baselines"
            ],
            "line": 252
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [
          {
            "name": "SEVERITY_THRESHOLDS",
            "line": 52
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "feedback_schemas.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_schemas/feedback_schemas.py",
        "layer": "L5_schemas",
        "domain": "analytics",
        "lines": 44,
        "module_docstring": "Pattern feedback DTO mirror.\n\nMirrors app.models.feedback.PatternFeedbackCreate so that L5 engines\nnever need a runtime import of app.models. Fields MUST stay in sync\nwith the L7 original.\n\nCanonical source: app/models/feedback.py",
        "functions": [],
        "classes": [
          {
            "name": "PatternFeedbackCreate",
            "docstring": "Input model for creating pattern feedback.\n\nMirror of app.models.feedback.PatternFeedbackCreate.",
            "methods": [],
            "line": 29
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "query_types.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_schemas/query_types.py",
        "layer": "L5_schemas",
        "domain": "analytics",
        "lines": 36,
        "module_docstring": "Analytics Query Types\n\nShared enum definitions for analytics query parameters.\nLives in L5_schemas so L2 can import without violating L2\u2192L5 rules.",
        "functions": [],
        "classes": [
          {
            "name": "ResolutionType",
            "docstring": "Time resolution for analytics data.",
            "methods": [],
            "line": 18
          },
          {
            "name": "ScopeType",
            "docstring": "Scope of analytics aggregation.",
            "methods": [],
            "line": 25
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 15
          }
        ],
        "constants": [],
        "all_exports": [
          "ResolutionType",
          "ScopeType"
        ]
      }
    ],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "analytics_read_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/analytics_read_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 376,
        "module_docstring": "Analytics Read Driver (L6 Data Access)\n\nHandles database operations for analytics queries:\n- Fetching cost metrics from cost_records\n- Fetching LLM usage from runs\n- Fetching worker execution from aos_traces\n- Fetching cost breakdowns by model and feature\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_analytics_read_driver",
            "signature": "(session: AsyncSession) -> AnalyticsReadDriver",
            "docstring": "Get an AnalyticsReadDriver instance.",
            "is_async": false,
            "line": 374
          }
        ],
        "classes": [
          {
            "name": "AnalyticsReadDriver",
            "docstring": "L6 Driver for analytics read operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (time alignment, reconciliation) stay in L5.",
            "methods": [
              "__init__",
              "fetch_cost_metrics",
              "fetch_llm_usage",
              "fetch_worker_execution",
              "fetch_cost_spend",
              "fetch_cost_by_model",
              "fetch_cost_by_feature"
            ],
            "line": 49
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "canary_report_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/canary_report_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 203,
        "module_docstring": "Canary Report Driver for CostSim V2.\n\nHandles database operations for canary validation reports. Separated from\nprovenance_driver.py (PIN-518 Gap 2) because canary reports have different:\n- Write pattern: low-volume, atomic (vs high-volume buffered)\n- Retention: medium (vs long)\n- Query pattern: dashboard-style (vs audit-style)\n- Failure tolerance: must-succeed (vs best-effort)\n\nUsage:\n    from app.hoc.cus.analytics.L6_drivers.canary_report_driver import (\n        write_canary_report,\n        query_canary_reports,\n        get_canary_report_by_run_id,\n    )\n\n    # Write report\n    report_id = await write_canary_report(\n        run_id=\"canary_20260203_120000\",\n        timestamp=datetime.now(timezone.utc),\n        status=\"pass\",\n        ...\n    )\n\n    # Query reports\n    reports = await query_canary_reports(status=\"fail\", limit=10)\n\n    # Get by run ID\n    report = await get_canary_report_by_run_id(\"canary_20260203_120000\")",
        "functions": [
          {
            "name": "write_canary_report",
            "signature": "(session: AsyncSession, run_id: str, timestamp: datetime, status: str, total_samples: int, matching_samples: int, minor_drift_samples: int, major_drift_samples: int, median_cost_diff: Optional[float] = None, p90_cost_diff: Optional[float] = None, kl_divergence: Optional[float] = None, outlier_count: Optional[int] = None, passed: bool = True, failure_reasons: Optional[List[str]] = None, artifact_paths: Optional[List[str]] = None, golden_comparison: Optional[Dict[str, Any]] = None) -> int",
            "docstring": "Write a canary report to the database.\n\nL6 Contract:\n    - Session REQUIRED (passed from L4 coordinator)\n    - L6 does NOT commit (L4 owns transaction boundary)\n\nArgs:\n    session: Async session (required, from L4 coordinator)\n    run_id: Unique run identifier\n    timestamp: Run timestamp\n    status: Run status (pass, fail, error, skipped)\n    total_samples: Total samples tested\n    matching_samples: Samples with matching V1/V2 results\n    minor_drift_samples: Samples with minor drift\n    major_drift_samples: Samples with major drift\n    median_cost_diff: Median cost difference\n    p90_cost_diff: 90th percentile cost difference\n    kl_divergence: KL divergence score\n    outlier_count: Number of outliers\n    passed: Whether canary passed\n    failure_reasons: List of failure reasons\n    artifact_paths: List of artifact file paths\n    golden_comparison: Golden comparison results\n\nReturns:\n    ID of created record",
            "is_async": true,
            "line": 68
          },
          {
            "name": "query_canary_reports",
            "signature": "(status: Optional[str] = None, passed: Optional[bool] = None, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None, limit: int = 10, offset: int = 0) -> List[Dict[str, Any]]",
            "docstring": "Query canary reports from the database.\n\nArgs:\n    status: Filter by status (pass, fail, error, skipped)\n    passed: Filter by passed status\n    start_date: Start of time range\n    end_date: End of time range\n    limit: Maximum records to return\n    offset: Pagination offset\n\nReturns:\n    List of canary reports as dictionaries",
            "is_async": true,
            "line": 142
          },
          {
            "name": "get_canary_report_by_run_id",
            "signature": "(run_id: str) -> Optional[Dict[str, Any]]",
            "docstring": "Get a canary report by run ID.\n\nArgs:\n    run_id: Run identifier\n\nReturns:\n    Canary report as dictionary or None if not found",
            "is_async": true,
            "line": 188
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "select"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.db_async",
            "names": [
              "async_session_context"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.models.costsim_cb",
            "names": [
              "CostSimCanaryReportModel"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "coordination_audit_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/coordination_audit_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 166,
        "module_docstring": null,
        "functions": [
          {
            "name": "_now_utc",
            "signature": "() -> datetime",
            "docstring": "Get current UTC timestamp.",
            "is_async": false,
            "line": 53
          },
          {
            "name": "persist_audit_record",
            "signature": "(db: Session, audit_id: str, envelope_id: str, envelope_class: str, decision: str, reason: str, decision_timestamp: datetime, conflicting_envelope_id: Optional[str] = None, preempting_envelope_id: Optional[str] = None, active_envelopes_count: int = 0, tenant_id: Optional[str] = None, emit_traces: bool = True) -> bool",
            "docstring": "Persist a coordination audit record to the database.\n\nThis function is the ONLY legal path to write audit records.\n\nArgs:\n    db: Database session\n    audit_id: UUID of the audit record\n    envelope_id: ID of the envelope being coordinated\n    envelope_class: SAFETY, RELIABILITY, COST, or PERFORMANCE\n    decision: APPLIED, REJECTED, or PREEMPTED\n    reason: Human-readable reason for decision\n    decision_timestamp: When the decision was made\n    conflicting_envelope_id: For REJECTED, the conflicting envelope\n    preempting_envelope_id: For PREEMPTED, the preempting envelope\n    active_envelopes_count: Count of active envelopes at decision time\n    tenant_id: Optional tenant identifier\n    emit_traces: If False, skip persistence (replay mode)\n\nReturns:\n    True if persisted successfully, False otherwise",
            "is_async": false,
            "line": 81
          }
        ],
        "classes": [
          {
            "name": "CoordinationAuditRecordDB",
            "docstring": "SQLModel for coordination_audit_records table.\n\nThis is a read-only reflection of the table created by migration\n063_c4_coordination_audit.py. The model is for persistence only.",
            "methods": [],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "sqlmodel",
            "names": [
              "Field",
              "Session",
              "SQLModel"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 28
          },
          {
            "name": "RETRY_POLICY",
            "line": 29
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "cost_anomaly_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/cost_anomaly_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 992,
        "module_docstring": "Cost Anomaly Driver (L6)\n\nPure database operations for cost anomaly detection.\nAll business logic stays in L4 engine.\n\nOperations:\n- Read baseline/today aggregations for spike detection\n- Read rolling/baseline averages for drift detection\n- Read/write breach history for consecutive tracking\n- Read/write drift tracking state\n- Read cost metrics for cause derivation\n- Persist CostAnomaly records\n\nNO business logic:\n- NO threshold comparisons (L4)\n- NO severity classification (L4)\n- NO anomaly type decisions (L4)\n\nReference: Phase-2.5A Analytics Extraction",
        "functions": [
          {
            "name": "get_cost_anomaly_driver",
            "signature": "(session: Session) -> CostAnomalyDriver",
            "docstring": "Factory function to get CostAnomalyDriver instance.",
            "is_async": false,
            "line": 984
          }
        ],
        "classes": [
          {
            "name": "CostAnomalyDriver",
            "docstring": "L6 driver for cost anomaly detection data access.\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "fetch_entity_baseline",
              "fetch_entity_today_spend",
              "fetch_tenant_baseline",
              "fetch_tenant_today_spend",
              "fetch_rolling_avg",
              "fetch_baseline_avg",
              "fetch_daily_spend",
              "fetch_monthly_spend",
              "fetch_breach_exists_today",
              "insert_breach_history",
              "fetch_consecutive_breaches",
              "fetch_drift_tracking",
              "update_drift_tracking",
              "insert_drift_tracking",
              "reset_drift_tracking",
              "fetch_retry_comparison",
              "fetch_prompt_comparison",
              "fetch_feature_concentration",
              "fetch_request_comparison"
            ],
            "line": 95
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime"
            ],
            "is_relative": false,
            "line": 88
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 89
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 91
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 92
          }
        ],
        "constants": [],
        "all_exports": [
          "CostAnomalyDriver",
          "get_cost_anomaly_driver"
        ]
      },
      {
        "file_name": "cost_anomaly_read_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/cost_anomaly_read_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 191,
        "module_docstring": "Cost Anomaly Read Driver (PIN-511 Phase 1.2)\n\nExtracts transitional ORM reads from cost_anomaly_detector_engine.py:\n- Budget loading (was line ~521)\n- Anomaly deduplication (was line ~878)\n- Anomaly persistence (upsert + flush)\n\nThese were previously inline in the L5 engine with TRANSITIONAL_READ_OK markers.",
        "functions": [
          {
            "name": "get_cost_anomaly_read_driver",
            "signature": "(session: Session) -> CostAnomalyReadDriver",
            "docstring": "Factory for CostAnomalyReadDriver.",
            "is_async": false,
            "line": 189
          }
        ],
        "classes": [
          {
            "name": "CostAnomalyReadDriver",
            "docstring": "L6 driver for budget reads and anomaly deduplication/persistence.\n\nImplements CostAnomalyReadProtocol (L5_schemas).",
            "methods": [
              "__init__",
              "fetch_active_budgets",
              "find_existing_anomaly",
              "persist_anomaly",
              "flush_and_refresh",
              "upsert_anomaly"
            ],
            "line": 44
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.db",
            "names": [
              "CostAnomaly",
              "CostBudget"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.analytics.L5_schemas.cost_anomaly_dtos",
            "names": [
              "PersistedAnomaly"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cost_snapshots_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/cost_snapshots_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 474,
        "module_docstring": "Cost Snapshots Driver (L6)\n\nPure database operations for cost snapshot system.\nExtracted from cost_snapshots_engine.py per PIN-508 Phase 1A.\n\nImplements CostSnapshotsDriverProtocol for typed L5\u2194L6 boundary.\nNO business logic \u2014 only DB operations.\nNO session.commit() \u2014 L4 coordinator owns transaction boundary.",
        "functions": [
          {
            "name": "get_cost_snapshots_driver",
            "signature": "(session: AsyncSession) -> CostSnapshotsDriver",
            "docstring": "Factory function to get CostSnapshotsDriver instance.",
            "is_async": false,
            "line": 466
          }
        ],
        "classes": [
          {
            "name": "CostSnapshotsDriver",
            "docstring": "L6 driver for cost snapshot database operations.\n\nImplements CostSnapshotsDriverProtocol.\nPure data access \u2014 no business logic.",
            "methods": [
              "__init__",
              "insert_snapshot",
              "update_snapshot",
              "insert_aggregate",
              "get_current_baseline",
              "aggregate_cost_records",
              "insert_baseline",
              "get_snapshot",
              "get_aggregates_with_baseline",
              "insert_evaluation",
              "insert_anomaly",
              "compute_baselines"
            ],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "L5_schemas.cost_snapshot_schemas",
            "names": [
              "AnomalyEvaluation",
              "CostSnapshot",
              "EntityType",
              "SnapshotAggregate",
              "SnapshotBaseline",
              "SnapshotStatus",
              "SnapshotType"
            ],
            "is_relative": true,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": [
          "CostSnapshotsDriver",
          "get_cost_snapshots_driver"
        ]
      },
      {
        "file_name": "cost_write_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/cost_write_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 250,
        "module_docstring": "Cost Write Driver (L6)\n\nPure database write operations for Cost Intelligence.\n\nL4 (CostWriteService) \u2192 L6 (this driver)\n\nResponsibilities:\n- Persist FeatureTag records\n- Persist CostRecord records\n- Persist CostBudget records\n- NO business logic (L4 responsibility)\n\nReference: PIN-250, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_cost_write_driver",
            "signature": "(session: Session) -> CostWriteDriver",
            "docstring": "Factory function to get CostWriteDriver instance.",
            "is_async": false,
            "line": 242
          }
        ],
        "classes": [
          {
            "name": "CostWriteDriver",
            "docstring": "L6 driver for cost write operations.\n\nPure database access - no business logic.",
            "methods": [
              "__init__",
              "create_feature_tag",
              "update_feature_tag",
              "create_cost_record",
              "create_or_update_budget"
            ],
            "line": 52
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.db",
            "names": [
              "CostBudget",
              "CostRecord",
              "FeatureTag"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": [
          "CostWriteDriver",
          "get_cost_write_driver"
        ]
      },
      {
        "file_name": "feedback_read_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/feedback_read_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 121,
        "module_docstring": "Feedback Read Driver (L6)\n\nPure database read operations for PatternFeedback (PB-S3).\n\nAll methods are pure DB operations \u2014 no business logic.\nBusiness decisions stay in L5 engine.\n\nOperations:\n- Fetch feedback list with filters and pagination\n- Fetch single feedback by ID\n- Fetch feedback stats",
        "functions": [
          {
            "name": "get_feedback_read_driver",
            "signature": "(session: AsyncSession) -> FeedbackReadDriver",
            "docstring": "Get feedback read driver instance.",
            "is_async": false,
            "line": 119
          }
        ],
        "classes": [
          {
            "name": "FeedbackReadDriver",
            "docstring": "L6 driver for feedback read operations.\n\nPure database access \u2014 no business logic.\nREAD-ONLY: No write operations.",
            "methods": [
              "__init__",
              "fetch_feedback_list",
              "fetch_feedback_by_id",
              "fetch_feedback_stats"
            ],
            "line": 46
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.models.feedback",
            "names": [
              "PatternFeedback"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "leader_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/leader_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 360,
        "module_docstring": "Leader election using PostgreSQL advisory locks.\n\nThis module provides a simple leader election mechanism for scenarios where\nonly one instance should run a task (e.g., daily canary runs). Uses\npg_try_advisory_lock() which is session-scoped and automatically released\nwhen the connection closes.\n\nUsage:\n    from app.costsim.leader import try_acquire_leader_lock, LeaderContext\n\n    # Simple check\n    async with AsyncSessionLocal() as session:\n        if await try_acquire_leader_lock(session, LOCK_CANARY_RUNNER):\n            # We are the leader - run the task\n            await run_canary()\n            # Lock is released when session closes\n\n    # Or with context manager for cleaner code\n    async with LeaderContext(LOCK_CANARY_RUNNER) as is_leader:\n        if is_leader:\n            await run_canary()\n\nLock IDs:\n    - LOCK_CANARY_RUNNER (7001): Daily canary execution\n    - LOCK_ALERT_WORKER (7002): Alert queue processor\n    - LOCK_PROVENANCE_ARCHIVER (7003): Provenance data archival\n\nNote:\n    Advisory locks are session-scoped. They are automatically released when:\n    - The session/connection is closed\n    - The transaction is rolled back (for xact-level locks)\n    - Explicitly released with pg_advisory_unlock()\n\n    For long-running processes, ensure the connection stays alive or\n    use heartbeat mechanisms.",
        "functions": [
          {
            "name": "try_acquire_leader_lock",
            "signature": "(session: AsyncSession, lock_id: int) -> bool",
            "docstring": "Try to acquire an advisory lock (non-blocking).\n\nUses pg_try_advisory_lock() which returns immediately with true/false.\nLock is held until the session is closed.\n\nArgs:\n    session: Async database session\n    lock_id: Unique lock identifier (use constants above)\n\nReturns:\n    True if lock acquired (we are the leader), False otherwise",
            "is_async": true,
            "line": 81
          },
          {
            "name": "release_leader_lock",
            "signature": "(session: AsyncSession, lock_id: int) -> bool",
            "docstring": "Explicitly release an advisory lock.\n\nUsually not needed since locks are released when session closes,\nbut useful for releasing early in long-running sessions.\n\nArgs:\n    session: Async database session\n    lock_id: Lock identifier to release\n\nReturns:\n    True if lock was released, False if we didn't hold it",
            "is_async": true,
            "line": 113
          },
          {
            "name": "is_lock_held",
            "signature": "(session: AsyncSession, lock_id: int) -> bool",
            "docstring": "Check if a lock is currently held by any session.\n\nNote: This is informational only. The lock state could change\nimmediately after this check returns.\n\nArgs:\n    session: Async database session\n    lock_id: Lock identifier to check\n\nReturns:\n    True if lock is held by any session",
            "is_async": true,
            "line": 145
          },
          {
            "name": "leader_election",
            "signature": "(lock_id: int, timeout_seconds: float = 5.0) -> AsyncGenerator[bool, None]",
            "docstring": "Context manager for leader election.\n\nAlternative to LeaderContext class, using a function-based approach.\n\nUsage:\n    async with leader_election(LOCK_CANARY_RUNNER) as is_leader:\n        if is_leader:\n            await run_canary()\n\nArgs:\n    lock_id: Advisory lock ID\n    timeout_seconds: Timeout for lock acquisition\n\nYields:\n    True if we are the leader, False otherwise",
            "is_async": true,
            "line": 262
          },
          {
            "name": "with_leader_lock",
            "signature": "(lock_id: int, callback, *args, **kwargs)",
            "docstring": "Execute callback only if we can acquire leadership.\n\nConvenience function for fire-and-forget leader tasks.\n\nArgs:\n    lock_id: Advisory lock ID\n    callback: Async function to execute if we become leader\n    *args: Arguments for callback\n    timeout_seconds: Lock acquisition timeout\n    **kwargs: Keyword arguments for callback\n\nReturns:\n    Result of callback if we were leader, None otherwise\n\nExample:\n    # Run canary only if we're the leader\n    result = await with_leader_lock(\n        LOCK_CANARY_RUNNER,\n        run_canary,\n        samples=100,\n    )",
            "is_async": true,
            "line": 311
          },
          {
            "name": "with_canary_lock",
            "signature": "(callback, *args, **kwargs)",
            "docstring": "Execute callback with canary runner lock.",
            "is_async": true,
            "line": 348
          },
          {
            "name": "with_alert_worker_lock",
            "signature": "(callback, *args, **kwargs)",
            "docstring": "Execute callback with alert worker lock.",
            "is_async": true,
            "line": 353
          },
          {
            "name": "with_archiver_lock",
            "signature": "(callback, *args, **kwargs)",
            "docstring": "Execute callback with provenance archiver lock.",
            "is_async": true,
            "line": 358
          }
        ],
        "classes": [
          {
            "name": "LeaderContext",
            "docstring": "Async context manager for leader election.\n\nAcquires a leader lock on entry, releases on exit. The context\nvariable indicates whether we successfully became the leader.\n\nUsage:\n    async with LeaderContext(LOCK_CANARY_RUNNER) as is_leader:\n        if is_leader:\n            # We won the election\n            await run_canary()\n        else:\n            # Another instance is the leader\n            logger.info(\"Not the leader, skipping\")\n\nThe lock is held for the duration of the context and automatically\nreleased when the context exits (via session close).",
            "methods": [
              "__init__",
              "__aenter__",
              "__aexit__",
              "is_leader"
            ],
            "line": 178
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "contextlib",
            "names": [
              "asynccontextmanager"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "AsyncGenerator",
              "Optional"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.db_async",
            "names": [
              "AsyncSessionLocal"
            ],
            "is_relative": false,
            "line": 68
          }
        ],
        "constants": [
          {
            "name": "LOCK_CANARY_RUNNER",
            "line": 75
          },
          {
            "name": "LOCK_ALERT_WORKER",
            "line": 76
          },
          {
            "name": "LOCK_PROVENANCE_ARCHIVER",
            "line": 77
          },
          {
            "name": "LOCK_BASELINE_BACKFILL",
            "line": 78
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "pattern_detection_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/pattern_detection_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 209,
        "module_docstring": "Pattern Detection Driver (L6 Data Access)\n\nHandles all database operations for pattern detection:\n- Fetching failed runs for pattern analysis\n- Fetching completed runs for cost spike detection\n- Inserting pattern feedback records\n- Querying feedback summaries\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_pattern_detection_driver",
            "signature": "(session: AsyncSession) -> PatternDetectionDriver",
            "docstring": "Get a PatternDetectionDriver instance.",
            "is_async": false,
            "line": 207
          }
        ],
        "classes": [
          {
            "name": "PatternDetectionDriver",
            "docstring": "L6 Driver for pattern detection data operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (threshold checks, pattern grouping) stay in L5.",
            "methods": [
              "__init__",
              "fetch_failed_runs",
              "fetch_completed_runs_with_costs",
              "insert_feedback",
              "fetch_feedback_records"
            ],
            "line": 53
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.models.feedback",
            "names": [
              "PatternFeedback"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "prediction_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/prediction_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 319,
        "module_docstring": "Prediction Driver (L6)\n\nPure database operations for prediction management.\nAll business logic stays in L4 engine.\n\nOperations:\n- Read failure patterns from feedback\n- Read failed runs and totals\n- Read cost data for projections\n- Read prediction events\n- Insert new prediction events\n\nNO business logic:\n- NO prediction math (L4)\n- NO confidence calculations (L4)\n- NO threshold comparisons (L4)\n\nReference: Phase-2.5A Analytics Extraction",
        "functions": [
          {
            "name": "get_prediction_driver",
            "signature": "(session: AsyncSession) -> PredictionDriver",
            "docstring": "Factory function to get PredictionDriver instance.",
            "is_async": false,
            "line": 311
          }
        ],
        "classes": [
          {
            "name": "PredictionDriver",
            "docstring": "L6 driver for prediction data access.\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "fetch_failure_patterns",
              "fetch_failed_runs",
              "fetch_run_totals",
              "fetch_cost_runs",
              "fetch_predictions",
              "insert_prediction"
            ],
            "line": 75
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.models.feedback",
            "names": [
              "PatternFeedback"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "app.models.prediction",
            "names": [
              "PredictionEvent"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 72
          }
        ],
        "constants": [],
        "all_exports": [
          "PredictionDriver",
          "get_prediction_driver"
        ]
      },
      {
        "file_name": "prediction_read_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/prediction_read_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 161,
        "module_docstring": "Prediction Read Driver (L6)\n\nPure database read operations for PredictionEvent (PB-S5).\n\nAll methods are pure DB operations \u2014 no business logic.\nBusiness decisions stay in L5 engine.\n\nOperations:\n- Fetch prediction list with filters and pagination\n- Fetch single prediction by ID\n- Fetch predictions by subject\n- Fetch prediction stats",
        "functions": [
          {
            "name": "get_prediction_read_driver",
            "signature": "(session: AsyncSession) -> PredictionReadDriver",
            "docstring": "Get prediction read driver instance.",
            "is_async": false,
            "line": 159
          }
        ],
        "classes": [
          {
            "name": "PredictionReadDriver",
            "docstring": "L6 driver for prediction read operations.\n\nPure database access \u2014 no business logic.\nREAD-ONLY: No write operations.",
            "methods": [
              "__init__",
              "fetch_prediction_list",
              "fetch_prediction_by_id",
              "fetch_predictions_for_subject",
              "fetch_prediction_stats"
            ],
            "line": 48
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.models.prediction",
            "names": [
              "PredictionEvent"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "provenance_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/provenance_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 476,
        "module_docstring": "Async provenance logging for CostSim V2.\n\nThis module provides non-blocking database access for writing provenance\nrecords. Use this instead of the sync provenance.py for all async code paths.\n\nFeatures:\n- Non-blocking DB operations (won't hang event loop)\n- Batch writing support for high-throughput scenarios\n- Deduplication via input_hash\n- V1 baseline backfill support\n\nUsage:\n    from app.costsim.provenance_async import (\n        write_provenance,\n        write_provenance_batch,\n        query_provenance,\n    )\n\n    # Write single record\n    await write_provenance(\n        run_id=\"run_123\",\n        tenant_id=\"tenant_abc\",\n        variant_slug=\"v2\",\n        v1_cost=100.0,\n        v2_cost=105.0,\n        input_hash=\"abc123\",\n    )\n\n    # Batch write\n    records = [...]\n    await write_provenance_batch(records)\n\n    # Query records\n    records = await query_provenance(\n        tenant_id=\"tenant_abc\",\n        variant_slug=\"v2\",\n        start_date=start,\n        end_date=end,\n    )",
        "functions": [
          {
            "name": "write_provenance",
            "signature": "(run_id: Optional[str] = None, tenant_id: Optional[str] = None, variant_slug: str = 'v2', source: str = 'sandbox', model_version: Optional[str] = None, adapter_version: Optional[str] = None, commit_sha: Optional[str] = None, input_hash: Optional[str] = None, output_hash: Optional[str] = None, v1_cost: Optional[float] = None, v2_cost: Optional[float] = None, payload: Optional[Dict[str, Any]] = None, runtime_ms: Optional[int] = None, session: Optional[AsyncSession] = None) -> int",
            "docstring": "Write a single provenance record.\n\nArgs:\n    run_id: Run identifier\n    tenant_id: Tenant identifier\n    variant_slug: v1, v2, or canary\n    source: sandbox, canary, manual, backfill\n    model_version: Cost model version\n    adapter_version: Adapter version\n    commit_sha: Git commit SHA\n    input_hash: Hash of input for deduplication\n    output_hash: Hash of output\n    v1_cost: V1 simulation cost\n    v2_cost: V2 simulation cost\n    payload: Full simulation payload\n    runtime_ms: Execution time in milliseconds\n    session: Optional async session (creates new if None)\n\nReturns:\n    ID of created record",
            "is_async": true,
            "line": 80
          },
          {
            "name": "write_provenance_batch",
            "signature": "(records: List[Dict[str, Any]], session: Optional[AsyncSession] = None) -> List[int]",
            "docstring": "Write multiple provenance records in a single transaction.\n\nMore efficient than individual writes for high-throughput scenarios.\n\nArgs:\n    records: List of record dictionaries (same keys as write_provenance)\n    session: Optional async session\n\nReturns:\n    List of created record IDs",
            "is_async": true,
            "line": 164
          },
          {
            "name": "query_provenance",
            "signature": "(tenant_id: Optional[str] = None, variant_slug: Optional[str] = None, source: Optional[str] = None, input_hash: Optional[str] = None, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None, limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]",
            "docstring": "Query provenance records.\n\nArgs:\n    tenant_id: Filter by tenant\n    variant_slug: Filter by variant (v1, v2, canary)\n    source: Filter by source (sandbox, canary, manual, backfill)\n    input_hash: Filter by input hash (for deduplication check)\n    start_date: Start of time range\n    end_date: End of time range\n    limit: Maximum records to return\n    offset: Pagination offset\n\nReturns:\n    List of provenance records as dictionaries",
            "is_async": true,
            "line": 235
          },
          {
            "name": "count_provenance",
            "signature": "(tenant_id: Optional[str] = None, variant_slug: Optional[str] = None, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None) -> int",
            "docstring": "Count provenance records matching filters.\n\nArgs:\n    tenant_id: Filter by tenant\n    variant_slug: Filter by variant\n    start_date: Start of time range\n    end_date: End of time range\n\nReturns:\n    Count of matching records",
            "is_async": true,
            "line": 289
          },
          {
            "name": "get_drift_stats",
            "signature": "(start_date: Optional[datetime] = None, end_date: Optional[datetime] = None) -> Dict[str, Any]",
            "docstring": "Get drift statistics between V1 and V2 costs.\n\nArgs:\n    start_date: Start of time range\n    end_date: End of time range\n\nReturns:\n    Dictionary with drift statistics",
            "is_async": true,
            "line": 328
          },
          {
            "name": "check_duplicate",
            "signature": "(input_hash: str) -> bool",
            "docstring": "Check if a record with this input hash already exists.\n\nArgs:\n    input_hash: Hash to check\n\nReturns:\n    True if duplicate exists",
            "is_async": true,
            "line": 382
          },
          {
            "name": "compute_input_hash",
            "signature": "(payload: Dict[str, Any]) -> str",
            "docstring": "Compute deterministic hash of input payload.\n\nArgs:\n    payload: Input dictionary\n\nReturns:\n    SHA-256 hash string (first 16 chars)",
            "is_async": false,
            "line": 399
          },
          {
            "name": "backfill_v1_baseline",
            "signature": "(records: List[Dict[str, Any]], batch_size: int = 100) -> Dict[str, int]",
            "docstring": "Backfill V1 baseline records from historical data.\n\nArgs:\n    records: List of historical V1 simulation records\n    batch_size: Number of records per batch\n\nReturns:\n    Dictionary with counts (inserted, skipped, errors)",
            "is_async": true,
            "line": 419
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "app.db_async",
            "names": [
              "AsyncSessionLocal",
              "async_session_context"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "app.models.costsim_cb",
            "names": [
              "CostSimProvenanceModel"
            ],
            "is_relative": false,
            "line": 75
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 40,
    "violation_count": 0,
    "gap_count": 1
  },
  "integrations": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/integrations.py",
    "l2_apis": [
      {
        "file_name": "cus_telemetry.py",
        "file_path": "backend/app/hoc/api/cus/integrations/cus_telemetry.py",
        "layer": "L2_api",
        "domain": "integrations",
        "lines": 391,
        "module_docstring": "Customer LLM Telemetry Ingestion API\n\nPURPOSE:\n    Receives telemetry data from customer SDKs reporting LLM usage.\n    This is the DATA PLANE ingestion surface - it records facts about\n    what happened during LLM calls.\n\nENDPOINTS:\n    POST /telemetry/llm-usage     - Single call telemetry\n    POST /telemetry/llm-usage/batch - Batch telemetry (up to 100 records)\n    GET  /telemetry/usage-summary  - Usage summary for dashboard\n\nSEMANTIC:\n    - Append-only: Telemetry records are never updated or deleted\n    - Idempotent: call_id prevents duplicate ingestion\n    - Tenant-isolated: All data scoped to authenticated tenant\n\nAUTHENTICATION:\n    Uses integration API key (X-CUS-Integration-Key header) to identify\n    both the tenant and the specific integration being reported.",
        "functions": [
          {
            "name": "get_integration_context",
            "signature": "(request: Request, x_cus_integration_key: Optional[str] = Header(None, alias='X-CUS-Integration-Key')) -> dict",
            "docstring": "Extract and validate integration context from request.\n\nThe integration key encodes both tenant_id and integration_id,\nallowing SDK to authenticate and route telemetry.\n\nReturns:\n    dict with tenant_id and integration_id",
            "is_async": true,
            "line": 63
          },
          {
            "name": "ingest_llm_usage",
            "signature": "(payload: CusLLMUsageIngest, ctx: dict = Depends(get_integration_context))",
            "docstring": "Ingest a single LLM usage telemetry record.\n\nPURPOSE:\n    SDK calls this endpoint after each LLM call to report:\n    - Token counts (input/output)\n    - Cost calculation\n    - Latency measurement\n    - Policy enforcement result\n\nIDEMPOTENCY:\n    The call_id field serves as an idempotency key. If a record\n    with the same call_id already exists, this is a no-op.\n\nArgs:\n    payload: Telemetry data from SDK\n\nReturns:\n    Envelope with ingestion result",
            "is_async": true,
            "line": 110
          },
          {
            "name": "ingest_llm_usage_batch",
            "signature": "(payload: CusLLMUsageBatchIngest, ctx: dict = Depends(get_integration_context))",
            "docstring": "Ingest a batch of LLM usage telemetry records.\n\nPURPOSE:\n    SDK may buffer telemetry and send in batches for efficiency.\n    Maximum 100 records per batch.\n\nIDEMPOTENCY:\n    Each record's call_id is checked. Duplicates are silently ignored.\n\nArgs:\n    payload: Batch of telemetry records\n\nReturns:\n    Envelope with batch ingestion result (accepted/duplicates counts)",
            "is_async": true,
            "line": 172
          },
          {
            "name": "get_usage_summary",
            "signature": "(request: Request, integration_id: Optional[str] = Query(None, description='Filter by integration'), start_date: Optional[date] = Query(None, description='Period start (default: 30 days ago)'), end_date: Optional[date] = Query(None, description='Period end (default: today)'), ctx: dict = Depends(get_integration_context))",
            "docstring": "Get aggregated usage summary for dashboard.\n\nPURPOSE:\n    Provides rolled-up usage statistics for a tenant's integrations.\n    Used by dashboard to show cost, token, and call totals.\n\nArgs:\n    integration_id: Optional filter for specific integration\n    start_date: Period start (default: 30 days ago)\n    end_date: Period end (default: today)\n\nReturns:\n    CusUsageSummary with aggregated metrics",
            "is_async": true,
            "line": 225
          },
          {
            "name": "get_usage_history",
            "signature": "(request: Request, integration_id: Optional[str] = Query(None, description='Filter by integration'), limit: int = Query(50, ge=1, le=1000, description='Max records to return'), offset: int = Query(0, ge=0, description='Offset for pagination'), ctx: dict = Depends(get_integration_context))",
            "docstring": "Get detailed usage history records.\n\nPURPOSE:\n    Detailed view of individual LLM calls for audit and debugging.\n    Paginated for large datasets.\n\nArgs:\n    integration_id: Optional filter for specific integration\n    limit: Max records per page (default 50, max 1000)\n    offset: Pagination offset\n\nReturns:\n    List of CusLLMUsageResponse records",
            "is_async": true,
            "line": 282
          },
          {
            "name": "get_daily_aggregates",
            "signature": "(request: Request, integration_id: Optional[str] = Query(None, description='Filter by integration'), start_date: Optional[date] = Query(None, description='Period start'), end_date: Optional[date] = Query(None, description='Period end'), ctx: dict = Depends(get_integration_context))",
            "docstring": "Get daily aggregated usage for charts.\n\nPURPOSE:\n    Pre-computed daily aggregates for time-series visualization.\n    More efficient than computing from raw usage records.\n\nArgs:\n    integration_id: Optional filter for specific integration\n    start_date: Period start (default: 30 days ago)\n    end_date: Period end (default: today)\n\nReturns:\n    List of daily aggregate records",
            "is_async": true,
            "line": 338
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "date",
              "timedelta"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "Header",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.cus_schemas",
            "names": [
              "CusLLMUsageBatchIngest",
              "CusLLMUsageIngest",
              "CusLLMUsageResponse",
              "CusUsageSummary"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict",
              "wrap_error",
              "wrap_list"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "mcp_servers.py",
        "file_path": "backend/app/hoc/api/cus/integrations/mcp_servers.py",
        "layer": "L2_api",
        "domain": "integrations",
        "lines": 748,
        "module_docstring": "MCP Servers API (L2)\n\nCustomer-facing endpoints for MCP server lifecycle management.\nEnables customers to register MCP servers, discover tools, and monitor health.\n\nEndpoints:\n- POST   /integrations/mcp-servers              \u2192 Register a new MCP server\n- GET    /integrations/mcp-servers              \u2192 List MCP servers for tenant\n- GET    /integrations/mcp-servers/{server_id}  \u2192 Get server details\n- POST   /integrations/mcp-servers/{server_id}/discover \u2192 Discover tools\n- GET    /integrations/mcp-servers/{server_id}/health   \u2192 Health check\n- DELETE /integrations/mcp-servers/{server_id}  \u2192 Soft-delete server\n- GET    /integrations/mcp-servers/{server_id}/tools    \u2192 List server tools\n- GET    /integrations/mcp-servers/{server_id}/invocations \u2192 List invocations",
        "functions": [
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 192
          },
          {
            "name": "register_mcp_server",
            "signature": "(request: Request, body: McpServerRegisterRequest, session = Depends(get_session_dep)) -> McpRegistrationResponse",
            "docstring": "Register a new MCP server. Tenant-scoped.",
            "is_async": true,
            "line": 230
          },
          {
            "name": "list_mcp_servers",
            "signature": "(request: Request, include_disabled: Annotated[bool, Query(description='Include disabled servers')] = False, session = Depends(get_session_dep)) -> McpServerListResponse",
            "docstring": "List MCP servers. Tenant-scoped.",
            "is_async": true,
            "line": 288
          },
          {
            "name": "get_mcp_server",
            "signature": "(request: Request, server_id: str, session = Depends(get_session_dep)) -> McpServerResponse",
            "docstring": "Get MCP server details. Tenant-scoped.",
            "is_async": true,
            "line": 343
          },
          {
            "name": "discover_mcp_tools",
            "signature": "(request: Request, server_id: str, session = Depends(get_session_dep)) -> McpDiscoveryResponse",
            "docstring": "Discover tools from MCP server. Tenant-scoped.",
            "is_async": true,
            "line": 400
          },
          {
            "name": "check_mcp_health",
            "signature": "(request: Request, server_id: str, session = Depends(get_session_dep)) -> McpHealthResponse",
            "docstring": "Health check MCP server. Tenant-scoped.",
            "is_async": true,
            "line": 454
          },
          {
            "name": "delete_mcp_server",
            "signature": "(request: Request, server_id: str, session = Depends(get_session_dep)) -> McpDeleteResponse",
            "docstring": "Delete MCP server. Tenant-scoped.",
            "is_async": true,
            "line": 511
          },
          {
            "name": "list_mcp_tools",
            "signature": "(request: Request, server_id: str, session = Depends(get_session_dep)) -> McpToolListResponse",
            "docstring": "List tools for MCP server. Tenant-scoped.",
            "is_async": true,
            "line": 565
          },
          {
            "name": "list_mcp_invocations",
            "signature": "(request: Request, server_id: str, limit: Annotated[int, Query(ge=1, le=100, description='Max items')] = 50, offset: Annotated[int, Query(ge=0, description='Items to skip')] = 0, session = Depends(get_session_dep)) -> McpInvocationListResponse",
            "docstring": "List invocations for MCP server. Tenant-scoped.",
            "is_async": true,
            "line": 622
          },
          {
            "name": "invoke_mcp_tool",
            "signature": "(request: Request, server_id: str, tool_id: str, body: McpInvokeRequest, session = Depends(get_session_dep)) -> McpInvokeResponse",
            "docstring": "Invoke an MCP tool with governance. Tenant-scoped.",
            "is_async": true,
            "line": 691
          }
        ],
        "classes": [
          {
            "name": "McpServerRegisterRequest",
            "docstring": "Request body for registering a new MCP server.",
            "methods": [],
            "line": 51
          },
          {
            "name": "McpServerResponse",
            "docstring": "Response for a single MCP server.",
            "methods": [],
            "line": 61
          },
          {
            "name": "McpServerSummary",
            "docstring": "Summary view of an MCP server for list endpoint.",
            "methods": [],
            "line": 75
          },
          {
            "name": "McpServerListResponse",
            "docstring": "Response for listing MCP servers.",
            "methods": [],
            "line": 85
          },
          {
            "name": "McpRegistrationResponse",
            "docstring": "Response for server registration.",
            "methods": [],
            "line": 91
          },
          {
            "name": "McpDiscoveryResponse",
            "docstring": "Response for tool discovery.",
            "methods": [],
            "line": 99
          },
          {
            "name": "McpHealthResponse",
            "docstring": "Response for health check.",
            "methods": [],
            "line": 107
          },
          {
            "name": "McpDeleteResponse",
            "docstring": "Response for server deletion.",
            "methods": [],
            "line": 115
          },
          {
            "name": "McpToolResponse",
            "docstring": "Response for a single tool.",
            "methods": [],
            "line": 120
          },
          {
            "name": "McpToolListResponse",
            "docstring": "Response for listing tools.",
            "methods": [],
            "line": 130
          },
          {
            "name": "McpInvocationSummary",
            "docstring": "Summary of a tool invocation.",
            "methods": [],
            "line": 136
          },
          {
            "name": "McpInvocationListResponse",
            "docstring": "Response for listing invocations.",
            "methods": [],
            "line": 146
          },
          {
            "name": "McpInvokeRequest",
            "docstring": "Request body for invoking an MCP tool.",
            "methods": [],
            "line": 152
          },
          {
            "name": "McpInvokeResponse",
            "docstring": "Response for tool invocation.",
            "methods": [],
            "line": 162
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "protection_dependencies.py",
        "file_path": "backend/app/hoc/api/cus/integrations/protection_dependencies.py",
        "layer": "L2_api",
        "domain": "integrations",
        "lines": 243,
        "module_docstring": "Phase-7 Protection Dependencies \u2014 FastAPI Integration\n\nProvides dependencies for protection checks in API endpoints.\n\nENFORCEMENT SURFACE:\n    Protection applies to:\n    - SDK endpoints\n    - Runtime execution paths\n    - Background workers\n\n    Protection does NOT apply to:\n    - Onboarding endpoints\n    - Auth endpoints\n    - Founder endpoints\n    - Internal ops endpoints\n\nDESIGN INVARIANTS:\n- ABUSE-001: Protection does not affect onboarding, roles, or billing state\n- ABUSE-002: All enforcement outcomes are explicit (no silent failure)\n- ABUSE-003: Anomaly detection never blocks user traffic",
        "functions": [
          {
            "name": "is_exempt_endpoint",
            "signature": "(path: str) -> bool",
            "docstring": "Check if an endpoint is exempt from protection.",
            "is_async": false,
            "line": 89
          },
          {
            "name": "check_protection",
            "signature": "(request: Request) -> ProtectionContext",
            "docstring": "FastAPI dependency: Run protection checks for current request.\n\nReturns ProtectionContext with decision and any anomaly signals.\nDoes NOT raise exceptions - caller decides how to handle.\n\nUsage:\n    @router.post(\"/runs\")\n    async def create_run(\n        protection: ProtectionContext = Depends(check_protection),\n    ):\n        if protection.result.decision == Decision.REJECT:\n            raise HTTPException(status_code=429, detail=protection.result.to_error_response())\n        ...",
            "is_async": false,
            "line": 94
          },
          {
            "name": "require_protection_allow",
            "signature": "(request: Request) -> ProtectionContext",
            "docstring": "FastAPI dependency: Require protection checks to pass.\n\nRaises HTTP 429 if protection rejects the request.\nRaises HTTP 503 if protection throttles (with Retry-After header).\n\nUsage:\n    @router.post(\"/runs\")\n    async def create_run(\n        protection: ProtectionContext = Depends(require_protection_allow),\n    ):\n        # Protection checks passed\n        ...",
            "is_async": false,
            "line": 176
          },
          {
            "name": "emit_protection_event",
            "signature": "(context: ProtectionContext) -> dict",
            "docstring": "Emit a structured protection event for observability.\n\nPer Phase-7 design Section 7.9, all rejections emit structured events.\n\nReturns:\n    Event dict suitable for logging/dashboards",
            "is_async": false,
            "line": 212
          }
        ],
        "classes": [
          {
            "name": "ProtectionContext",
            "docstring": "Protection context for a request.\n\nAttributes:\n    tenant_id: The tenant identifier\n    endpoint: The endpoint being accessed\n    operation: The operation being performed\n    result: Result of protection checks\n    anomaly: Anomaly signal if detected (non-blocking)\n    is_exempt: True if endpoint is exempt from protection",
            "methods": [],
            "line": 68
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "fastapi",
            "names": [
              "Request",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.protection.decisions",
            "names": [
              "Decision",
              "ProtectionResult",
              "AnomalySignal",
              "allow"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.protection.provider",
            "names": [
              "get_protection_provider"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.onboarding_state",
            "names": [
              "OnboardingState"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [
          {
            "name": "EXEMPT_PREFIXES",
            "line": 55
          }
        ],
        "all_exports": [
          "ProtectionContext",
          "check_protection",
          "require_protection_allow",
          "emit_protection_event",
          "is_exempt_endpoint",
          "EXEMPT_PREFIXES"
        ]
      },
      {
        "file_name": "session_context.py",
        "file_path": "backend/app/hoc/api/cus/integrations/session_context.py",
        "layer": "L2_api",
        "domain": "integrations",
        "lines": 155,
        "module_docstring": "Session Context API\n\nPIN-409: Provides verified session context to frontend.\n\nThis endpoint replaces frontend-derived authorization facts (isFounder, audience)\nwith backend-verified context. The frontend reads, never infers.\n\nEndpoint:\n    GET /session/context - Get current session context\n\nResponse:\n    {\n        \"actor_type\": \"customer\" | \"founder\" | \"machine\",\n        \"tenant_id\": \"...\",\n        \"capabilities\": [...],  // for machine clients only\n        \"lifecycle_state\": \"ACTIVE\" | \"SUSPENDED\" | \"TERMINATED\" | \"ARCHIVED\",\n        \"onboarding_state\": \"CREATED\" | \"IDENTITY_VERIFIED\" | ... | \"COMPLETE\"\n    }\n\nRULE-AUTH-UI-001: Frontend never decides 'who I am' beyond signed-in vs not.\nThis endpoint is the single source of truth for authorization facts.",
        "functions": [
          {
            "name": "get_session_context",
            "signature": "(request: Request) -> Dict[str, Any]",
            "docstring": "Get verified session context for the current authenticated user.\n\nThis endpoint returns authorization facts derived from the verified\nbackend context. The frontend should use these values instead of\nderiving them locally.\n\nReturns:\n    actor_type: \"customer\" | \"founder\" | \"machine\"\n    tenant_id: Tenant ID if applicable (null for founders)\n    capabilities: List of scopes for machine clients (empty for humans)\n    lifecycle_state: Current tenant lifecycle state (for tenant-scoped actors)\n    onboarding_state: Current onboarding state (for tenant-scoped actors)\n\nRaises:\n    401: Not authenticated",
            "is_async": true,
            "line": 57
          },
          {
            "name": "_fetch_lifecycle_state_name",
            "signature": "(tenant_id: str) -> str",
            "docstring": "Fetch lifecycle state name from DB (Tenant.status).",
            "is_async": true,
            "line": 132
          },
          {
            "name": "_get_onboarding_state",
            "signature": "(tenant_id: str) -> str",
            "docstring": "Fetch onboarding state name from DB (Tenant.onboarding_state).",
            "is_async": true,
            "line": 145
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Request",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.contexts",
            "names": [
              "FounderAuthContext",
              "HumanAuthContext",
              "MachineCapabilityContext"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_async_session_context",
              "sql_text"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.tenant_lifecycle_enums",
            "names": [
              "normalize_status"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "v1_proxy.py",
        "file_path": "backend/app/hoc/api/cus/integrations/v1_proxy.py",
        "layer": "L2_api",
        "domain": "integrations",
        "lines": 1256,
        "module_docstring": "M22 KillSwitch MVP - OpenAI-Compatible Proxy API\n\nDrop-in replacement for OpenAI API with:\n- KillSwitch enforcement (423 Locked if frozen)\n- Budget enforcement (402 Payment Required if exceeded)\n- Default guardrails (429 for rate limit, 400 for blocked)\n- Full call logging for replay\n- SSE streaming support\n\nEndpoints:\n- POST /v1/chat/completions - Chat completions (90% of usage)\n- POST /v1/embeddings - Embeddings\n\nHTTP Status Codes:\n- 200: Success\n- 400: Bad Request (validation, blocked content)\n- 401: Unauthorized (invalid API key)\n- 402: Payment Required (budget exceeded)\n- 423: Locked (killswitch frozen)\n- 429: Too Many Requests (rate limited)\n- 500: Internal Server Error\n- 503: Service Unavailable (upstream error)",
        "functions": [
          {
            "name": "get_auth_context",
            "signature": "(authorization: Optional[str] = Header(None), x_api_key: Optional[str] = Header(None, alias='X-API-Key'), session = Depends(get_sync_session_dep)) -> Dict[str, Any]",
            "docstring": "Authenticate request and return tenant/key context.\n\nSupports:\n- Authorization: Bearer <key>\n- X-API-Key: <key>",
            "is_async": true,
            "line": 167
          },
          {
            "name": "record_usage_after_killswitch",
            "signature": "(auth: Dict[str, Any], session) -> None",
            "docstring": "Record API key usage ONLY after kill switch passes.\n\nThis ensures absolute kill switch semantics:\n- Frozen = zero side effects\n- No retries, no queued executions, no async spillover\n- Not even a usage counter increment",
            "is_async": true,
            "line": 287
          },
          {
            "name": "check_killswitch",
            "signature": "(tenant_id: str, api_key_id: str, session) -> Optional[Dict[str, Any]]",
            "docstring": "Check if tenant or API key is frozen.\nReturns error dict if frozen, None if OK.",
            "is_async": true,
            "line": 317
          },
          {
            "name": "evaluate_guardrails",
            "signature": "(request_body: Dict[str, Any], session) -> tuple[bool, List[Dict[str, Any]]]",
            "docstring": "Evaluate default guardrails against request.\nReturns (passed, decisions) where passed=False means blocked.",
            "is_async": true,
            "line": 388
          },
          {
            "name": "_evaluate_guardrail",
            "signature": "(guardrail, context: Dict[str, Any]) -> tuple[bool, Optional[str]]",
            "docstring": "Evaluate a guardrail dict against context.\nReturns (passed, reason) where passed=False means violation.",
            "is_async": false,
            "line": 459
          },
          {
            "name": "calculate_cost",
            "signature": "(model: str, input_tokens: int, output_tokens: int) -> Decimal",
            "docstring": "Calculate cost in cents.",
            "is_async": false,
            "line": 505
          },
          {
            "name": "estimate_tokens",
            "signature": "(text: str) -> int",
            "docstring": "Estimate token count.",
            "is_async": false,
            "line": 513
          },
          {
            "name": "get_openai_client",
            "signature": "()",
            "docstring": "Get OpenAI client (lazy loaded).",
            "is_async": false,
            "line": 523
          },
          {
            "name": "log_proxy_call",
            "signature": "(session, tenant_id: str, api_key_id: str, endpoint: str, request_body: Dict[str, Any], response_body: Optional[Dict[str, Any]], status_code: int, error_code: Optional[str], input_tokens: int, output_tokens: int, cost_cents: Decimal, latency_ms: int, upstream_latency_ms: Optional[int], was_blocked: bool, block_reason: Optional[str], policy_decisions: List[Dict[str, Any]], user_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Log a proxy call for replay and analysis via L4 registry dispatch.",
            "is_async": true,
            "line": 543
          },
          {
            "name": "chat_completions",
            "signature": "(request: ChatCompletionRequest, auth: Dict[str, Any] = Depends(get_auth_context), session = Depends(get_sync_session_dep))",
            "docstring": "OpenAI-compatible chat completions endpoint.\n\nStatus codes:\n- 200: Success\n- 400: Bad request or content blocked\n- 401: Unauthorized\n- 402: Budget exceeded\n- 423: Tenant/key frozen\n- 429: Rate limited\n- 503: Upstream error",
            "is_async": true,
            "line": 622
          },
          {
            "name": "stream_chat_completion",
            "signature": "(client, openai_request: Dict[str, Any], request_body: Dict[str, Any], auth: Dict[str, Any], session, start_time: float, decisions: List[Dict[str, Any]], user_id: Optional[str] = None) -> StreamingResponse",
            "docstring": "Handle streaming chat completion.",
            "is_async": true,
            "line": 832
          },
          {
            "name": "embeddings",
            "signature": "(request: EmbeddingRequest, auth: Dict[str, Any] = Depends(get_auth_context), session = Depends(get_sync_session_dep))",
            "docstring": "OpenAI-compatible embeddings endpoint.",
            "is_async": true,
            "line": 936
          },
          {
            "name": "proxy_status",
            "signature": "(authorization: Optional[str] = Header(None), x_api_key: Optional[str] = Header(None, alias='X-API-Key'), session = Depends(get_sync_session_dep))",
            "docstring": "Protection status endpoint - the pulse of your safety net.\n\nReturns:\n- System status and features\n- Enforcement latency (p95)\n- Last incident timestamp\n- Current freeze status\n- Incidents blocked count\n\nWhen authenticated, shows tenant-specific protection metrics.\nWhen unauthenticated, shows global system health.",
            "is_async": true,
            "line": 1080
          }
        ],
        "classes": [
          {
            "name": "ChatMessage",
            "docstring": null,
            "methods": [],
            "line": 95
          },
          {
            "name": "ChatCompletionRequest",
            "docstring": null,
            "methods": [],
            "line": 101
          },
          {
            "name": "ChatCompletionChoice",
            "docstring": null,
            "methods": [],
            "line": 116
          },
          {
            "name": "Usage",
            "docstring": null,
            "methods": [],
            "line": 122
          },
          {
            "name": "ChatCompletionResponse",
            "docstring": null,
            "methods": [],
            "line": 128
          },
          {
            "name": "EmbeddingRequest",
            "docstring": null,
            "methods": [],
            "line": 137
          },
          {
            "name": "EmbeddingData",
            "docstring": null,
            "methods": [],
            "line": 145
          },
          {
            "name": "EmbeddingResponse",
            "docstring": null,
            "methods": [],
            "line": 151
          },
          {
            "name": "ErrorResponse",
            "docstring": null,
            "methods": [],
            "line": 158
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "AsyncGenerator",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "Header",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "fastapi.responses",
            "names": [
              "StreamingResponse"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_sync_session_dep",
              "get_operation_registry",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [
          {
            "name": "COST_MODELS",
            "line": 70
          },
          {
            "name": "DEFAULT_MODEL",
            "line": 87
          }
        ],
        "all_exports": null
      }
    ],
    "l4_spine": [],
    "l5_engines": [
      {
        "file_name": "connectors_facade.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/connectors_facade.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 439,
        "module_docstring": "Connectors Facade (L4 Domain Logic)\n\nThis facade provides the external interface for connector operations.\nAll connector APIs MUST use this facade instead of directly importing\ninternal connector modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes connector management logic\n- Provides unified access to HTTP, SQL, MCP connectors\n- Single point for audit emission\n\nWrapped Services:\n- ConnectorRegistry: Connector registration and management\n- HTTPConnector: HTTP/REST connector (GAP-059)\n- SQLConnector: SQL database connector (GAP-060)\n- MCPConnector: MCP protocol connector (GAP-063)\n\nL2 API Routes (GAP-093):\n- GET /api/v1/connectors (list connectors)\n- POST /api/v1/connectors (register connector)\n- GET /api/v1/connectors/{id} (get connector)\n- PUT /api/v1/connectors/{id} (update connector)\n- DELETE /api/v1/connectors/{id} (delete connector)\n- POST /api/v1/connectors/{id}/test (test connector)\n\nUsage:\n    # L5 engine import (migrated to HOC per SWEEP-13)\n    from app.hoc.cus.integrations.L5_engines.connectors_facade import get_connectors_facade\n\n    facade = get_connectors_facade()\n\n    # List connectors\n    connectors = await facade.list_connectors(tenant_id=\"...\")\n\n    # Register a new connector\n    connector = await facade.register_connector(...)\n\n    # Test connection\n    result = await facade.test_connector(connector_id=\"...\")",
        "functions": [
          {
            "name": "get_connectors_facade",
            "signature": "() -> ConnectorsFacade",
            "docstring": "Get the connectors facade instance.\n\nThis is the recommended way to access connector operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    ConnectorsFacade instance",
            "is_async": false,
            "line": 426
          }
        ],
        "classes": [
          {
            "name": "ConnectorInfo",
            "docstring": "Connector information.",
            "methods": [
              "to_dict"
            ],
            "line": 73
          },
          {
            "name": "TestResult",
            "docstring": "Result of connector test.",
            "methods": [
              "to_dict"
            ],
            "line": 107
          },
          {
            "name": "ConnectorsFacade",
            "docstring": "Facade for connector operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nconnector services.\n\nLayer: L4 (Domain Logic)\nCallers: connectors.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "registry",
              "list_connectors",
              "get_connector",
              "register_connector",
              "update_connector",
              "delete_connector",
              "test_connector",
              "_get_capabilities_for_type"
            ],
            "line": 126
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "protocol.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/credentials/protocol.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 63,
        "module_docstring": "CredentialService Protocol \u2014 Canonical Definition\n\nThis is the CANONICAL and ONLY authoritative definition of the\nCredentialService protocol used by connector services.\n\nHistory:\n    Previously duplicated in:\n    - http_connector.py (lines 106-112)\n    - mcp_connector.py (lines 97-103)\n    - sql_gateway.py (lines 121-127)\n\n    Consolidated here per INT-DUP-002 quarantine resolution.",
        "functions": [],
        "classes": [
          {
            "name": "CredentialService",
            "docstring": "Protocol for credential service.\n\nDefines the contract for services that retrieve credentials\nfrom a vault or other secure storage. Connector services\ndepend on this protocol for authentication.\n\nImplementations:\n    - CusCredentialService (vault/engines/cus_credential_service.py)\n    - Any vault adapter that provides credential retrieval",
            "methods": [
              "get"
            ],
            "line": 40
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.types",
            "names": [
              "Credential"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_health_engine.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/cus_health_engine.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 542,
        "module_docstring": "Customer Health Engine\n\nPURPOSE:\n    Provider reachability and credential validation for customer LLM integrations.\n    Performs lightweight health checks without consuming significant quota.\n\nRESPONSIBILITIES:\n    - Test provider connectivity\n    - Validate credentials are still valid\n    - Measure response latency\n    - Update health state in integrations\n\nHEALTH STATES:\n    - UNKNOWN: Never checked or no recent data\n    - HEALTHY: Last check successful\n    - DEGRADED: Slow or partial responses\n    - UNHEALTHY: Check failed\n\nCHECK STRATEGY:\n    - OpenAI: GET /models endpoint (lightweight, no tokens)\n    - Anthropic: POST /messages with max_tokens=1 (minimal cost)\n    - Google: GET /models endpoint\n    - Others: Provider-specific lightweight calls\n\nRATE LIMITING:\n    - Maximum one check per integration per minute\n    - Batch checks spread over time\n    - Failed integrations checked less frequently",
        "functions": [],
        "classes": [
          {
            "name": "CusHealthService",
            "docstring": "Service for health checking customer LLM integrations.\n\nPhase 4: Provider reachability and credential validation.",
            "methods": [
              "__init__",
              "_get_driver",
              "check_health",
              "_perform_health_check",
              "check_all_integrations",
              "get_health_summary",
              "_calculate_overall_health"
            ],
            "line": 72
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "contextlib",
            "names": [
              "contextmanager"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.integrations.L5_schemas.cus_enums",
            "names": [
              "CusHealthState"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.cus_credential_engine",
            "names": [
              "CusCredentialService"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.hoc.cus.integrations.L6_drivers.cus_health_driver",
            "names": [
              "CusHealthDriver",
              "HealthIntegrationRow",
              "cus_health_driver_session"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_integration_engine.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/cus_integration_engine.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 478,
        "module_docstring": "Customer Integration Engine\n\nL4 engine for customer integration decisions.\n\nDecides: Integration creation, lifecycle transitions, limit calculations\nDelegates: All persistence to CusIntegrationDriver",
        "functions": [
          {
            "name": "get_cus_integration_engine",
            "signature": "(session) -> CusIntegrationEngine",
            "docstring": "Get engine instance with driver configured for session.\n\nArgs:\n    session: Database session from L4 handler (required)\n\nReturns:\n    CusIntegrationEngine instance\n\nNote:\n    Session is REQUIRED. L4 handler owns transaction boundary.",
            "is_async": false,
            "line": 464
          }
        ],
        "classes": [
          {
            "name": "EnableResult",
            "docstring": "Result of enable operation.",
            "methods": [],
            "line": 31
          },
          {
            "name": "DeleteResult",
            "docstring": "Result of delete operation.",
            "methods": [],
            "line": 40
          },
          {
            "name": "HealthCheckResult",
            "docstring": "Result of health check operation.",
            "methods": [],
            "line": 48
          },
          {
            "name": "CusIntegrationEngine",
            "docstring": "L4 engine for customer integration decisions.\n\nDecides: Validation, lifecycle transitions, limit calculations\nDelegates: All persistence to CusIntegrationDriver",
            "methods": [
              "__init__",
              "create_integration",
              "get_integration",
              "list_integrations",
              "update_integration",
              "delete_integration",
              "enable_integration",
              "disable_integration",
              "test_credentials",
              "get_limits_status"
            ],
            "line": 57
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 12
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 13
          },
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 14
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 15
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 16
          },
          {
            "module": "app.schemas.cus_schemas",
            "names": [
              "CusLimitsStatus"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "app.hoc.cus.integrations.L6_drivers.cus_integration_driver",
            "names": [
              "CusIntegrationDriver",
              "get_cus_integration_driver"
            ],
            "is_relative": false,
            "line": 19
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "datasources_facade.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/datasources_facade.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 451,
        "module_docstring": "DataSources Facade (L4 Domain Logic)\n\nThis facade provides the external interface for data source operations.\nAll data source APIs MUST use this facade instead of directly importing\ninternal datasource modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes data source management\n- Provides unified access to source configuration\n- Single point for audit emission\n\nL2 API Routes (GAP-113):\n- POST /api/v1/datasources (create source)\n- GET /api/v1/datasources (list sources)\n- GET /api/v1/datasources/{id} (get source)\n- PUT /api/v1/datasources/{id} (update source)\n- DELETE /api/v1/datasources/{id} (delete source)\n- POST /api/v1/datasources/{id}/test (test connection)\n- POST /api/v1/datasources/{id}/activate (activate source)\n- POST /api/v1/datasources/{id}/deactivate (deactivate source)\n- GET /api/v1/datasources/stats (statistics)\n\nUsage:\n    from app.hoc.cus.integrations.L5_engines.datasources_facade import get_datasources_facade\n\n    facade = get_datasources_facade()\n\n    # Register data source\n    source = await facade.register_source(\n        tenant_id=\"...\",\n        name=\"Production DB\",\n        source_type=\"database\",\n        config={...},\n    )",
        "functions": [
          {
            "name": "get_datasources_facade",
            "signature": "() -> DataSourcesFacade",
            "docstring": "Get the data sources facade instance.\n\nThis is the recommended way to access data source operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    DataSourcesFacade instance",
            "is_async": false,
            "line": 438
          }
        ],
        "classes": [
          {
            "name": "TestConnectionResult",
            "docstring": "Result of testing a data source connection.",
            "methods": [
              "to_dict"
            ],
            "line": 75
          },
          {
            "name": "DataSourcesFacade",
            "docstring": "Facade for data source operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ndata source services.\n\nLayer: L4 (Domain Logic)\nCallers: datasources.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "registry",
              "register_source",
              "list_sources",
              "get_source",
              "update_source",
              "delete_source",
              "test_connection",
              "activate_source",
              "deactivate_source",
              "get_statistics"
            ],
            "line": 92
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.integrations.L5_schemas.datasource_model",
            "names": [
              "CustomerDataSource",
              "DataSourceConfig",
              "DataSourceRegistry",
              "DataSourceStats",
              "DataSourceStatus",
              "DataSourceType",
              "get_datasource_registry"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "integrations_facade.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/integrations_facade.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 506,
        "module_docstring": "Integrations Domain Facade (L4)\n\nUnified facade for LLM integration management (BYOK - Bring Your Own Key).\n\nProvides:\n- CRUD: list, get, create, update, delete integrations\n- Lifecycle: enable, disable\n- Health: get health status, test credentials\n- Limits: get usage vs limits\n\nThis facade wraps the CusIntegrationEngine and provides dataclass result types\nfor consistency with other domain facades.",
        "functions": [
          {
            "name": "get_integrations_facade",
            "signature": "(session) -> IntegrationsFacade",
            "docstring": "Get an IntegrationsFacade instance.\n\nArgs:\n    session: Database session from L4 handler (required)\n\nReturns:\n    IntegrationsFacade instance\n\nNote:\n    Session is REQUIRED. L4 handler owns transaction boundary.\n    Not a singleton \u2014 each request creates a new facade with its session.",
            "is_async": false,
            "line": 477
          }
        ],
        "classes": [
          {
            "name": "IntegrationSummaryResult",
            "docstring": "Integration summary for list view.",
            "methods": [],
            "line": 53
          },
          {
            "name": "IntegrationListResult",
            "docstring": "Integration list response.",
            "methods": [],
            "line": 66
          },
          {
            "name": "IntegrationDetailResult",
            "docstring": "Integration detail response.",
            "methods": [],
            "line": 74
          },
          {
            "name": "IntegrationLifecycleResult",
            "docstring": "Result of enable/disable operation.",
            "methods": [],
            "line": 95
          },
          {
            "name": "IntegrationDeleteResult",
            "docstring": "Result of delete operation.",
            "methods": [],
            "line": 104
          },
          {
            "name": "HealthCheckResult",
            "docstring": "Health check result.",
            "methods": [],
            "line": 112
          },
          {
            "name": "HealthStatusResult",
            "docstring": "Cached health status.",
            "methods": [],
            "line": 123
          },
          {
            "name": "LimitsStatusResult",
            "docstring": "Usage vs limits status.",
            "methods": [],
            "line": 133
          },
          {
            "name": "IntegrationsFacade",
            "docstring": "Unified facade for LLM integration management.\n\nProvides:\n- CRUD: list, get, create, update, delete integrations\n- Lifecycle: enable, disable\n- Health: get health status, test credentials\n- Limits: get usage vs limits\n\nAll operations are tenant-scoped for isolation.",
            "methods": [
              "__init__",
              "list_integrations",
              "get_integration",
              "create_integration",
              "update_integration",
              "delete_integration",
              "enable_integration",
              "disable_integration",
              "get_health_status",
              "test_credentials",
              "get_limits_status"
            ],
            "line": 155
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.cus_integration_engine",
            "names": [
              "CusIntegrationEngine",
              "get_cus_integration_engine"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "IntegrationsFacade",
          "get_integrations_facade",
          "IntegrationSummaryResult",
          "IntegrationListResult",
          "IntegrationDetailResult",
          "IntegrationLifecycleResult",
          "IntegrationDeleteResult",
          "HealthCheckResult",
          "HealthStatusResult",
          "LimitsStatusResult"
        ]
      },
      {
        "file_name": "mcp_server_engine.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/mcp_server_engine.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 761,
        "module_docstring": "MCP Server Engine \u2014 Server lifecycle orchestration.\n\nHandles:\n- Server registration with credential vault integration\n- Tool discovery via real MCP protocol (initialize, tools/list)\n- Health checks via MCP ping\n- Server status management (pending \u2192 active \u2192 degraded \u2192 offline)\n\nPIN-516 Phase 2 Deliverable.\n\nProtocol Implementation:\n- MCP initialize: Discover server capabilities and protocol version\n- MCP tools/list: Discover available tools with schemas\n- MCP ping: Health check (if supported)\n\nSecurity Model:\n- Credentials stored by reference only (vault)\n- All HTTP calls use credential service for auth\n- Tenant isolation enforced at driver level",
        "functions": [],
        "classes": [
          {
            "name": "McpServerStatus",
            "docstring": "Server status values.",
            "methods": [],
            "line": 73
          },
          {
            "name": "McpDiscoveryResult",
            "docstring": "Result of server discovery (capabilities + tools).",
            "methods": [],
            "line": 89
          },
          {
            "name": "McpHealthResult",
            "docstring": "Result of health check.",
            "methods": [],
            "line": 101
          },
          {
            "name": "McpRegistrationResult",
            "docstring": "Result of server registration.",
            "methods": [],
            "line": 111
          },
          {
            "name": "McpServerEngine",
            "docstring": "L5 Engine for MCP server lifecycle management.\n\nResponsibilities:\n- Server registration with credential validation\n- Tool discovery via MCP protocol\n- Health monitoring\n- Status transitions\n\nPIN-516 Phase 2 Invariants:\n- All persistence via L6 McpDriver (never direct DB access)\n- Credentials via CredentialService protocol (never stored in engine)\n- HTTP calls isolated in private methods",
            "methods": [
              "__init__",
              "__aenter__",
              "__aexit__",
              "register_server",
              "discover_tools",
              "health_check",
              "get_server",
              "list_servers",
              "update_server",
              "disable_server",
              "get_tools",
              "enable_tool",
              "disable_tool",
              "set_tool_risk_level",
              "_mcp_initialize",
              "_mcp_list_tools",
              "_mcp_ping",
              "_assess_tool_risk",
              "_compute_capabilities_hash"
            ],
            "line": 125
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.credentials",
            "names": [
              "Credential",
              "CredentialService"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.integrations.L6_drivers.mcp_driver",
            "names": [
              "McpDriver",
              "McpServerRow",
              "McpToolRow",
              "compute_input_hash"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [
          {
            "name": "MCP_PROTOCOL_VERSION",
            "line": 68
          },
          {
            "name": "DEFAULT_TIMEOUT_SECONDS",
            "line": 69
          },
          {
            "name": "MAX_HEALTH_CHECK_FAILURES",
            "line": 70
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "mcp_tool_invocation_engine.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/mcp_tool_invocation_engine.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 789,
        "module_docstring": "MCP Tool Invocation Engine \u2014 Governed tool execution.\n\nOrchestrates MCP tool invocations with full monitoring integration:\n- Policy validation before execution\n- Audit trail emission for compliance\n- Actual tool execution via JSON-RPC\n- Incident creation on failures\n\nPIN-516 Phase 4 Deliverable.\n\nMonitoring Integration:\n- Policy: Validates tool calls against tenant policies\n- Audit: Emits compliance-grade events via MCPAuditEmitter\n- Incidents: Creates incidents for failed invocations\n- Activity: Records invocations for analytics\n\nSecurity Model:\n- All invocations are recorded (append-only)\n- Policy decisions are captured in audit trail\n- Failures trigger incident creation",
        "functions": [],
        "classes": [
          {
            "name": "McpPolicyChecker",
            "docstring": "Protocol for MCP tool invocation policy checking.",
            "methods": [
              "check_tool_invocation"
            ],
            "line": 82
          },
          {
            "name": "PolicyCheckResult",
            "docstring": "Result of policy check for tool invocation.",
            "methods": [],
            "line": 104
          },
          {
            "name": "McpInvocationResult",
            "docstring": "Result of MCP tool invocation.",
            "methods": [],
            "line": 118
          },
          {
            "name": "DefaultMcpPolicyChecker",
            "docstring": "Default policy checker that allows all invocations.\n\nProduction deployments should inject a real policy checker\nthat validates against tenant policies.",
            "methods": [
              "check_tool_invocation"
            ],
            "line": 139
          },
          {
            "name": "McpToolInvocationEngine",
            "docstring": "L5 Engine for governed MCP tool invocations.\n\nResponsibilities:\n- Policy validation before execution\n- Audit trail emission\n- Tool execution via JSON-RPC\n- Incident creation on failure\n- Invocation recording for analytics\n\nPIN-516 Phase 4 Invariants:\n- All invocations recorded (append-only via driver)\n- Policy decisions captured in audit trail\n- Failures trigger incident creation\n- No direct DB access (via L6 driver)",
            "methods": [
              "__init__",
              "_get_default_audit_emitter",
              "__aenter__",
              "__aexit__",
              "invoke_tool",
              "_record_error",
              "_execute_tool",
              "_create_incident"
            ],
            "line": 177
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.credentials",
            "names": [
              "Credential",
              "CredentialService"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.integrations.L6_drivers.mcp_driver",
            "names": [
              "McpDriver",
              "McpServerRow",
              "McpToolRow",
              "compute_input_hash",
              "compute_output_hash"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.protocols",
            "names": [
              "MCPAuditEmitterPort"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_TIMEOUT_SECONDS",
            "line": 72
          },
          {
            "name": "MCP_PROTOCOL_VERSION",
            "line": 73
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "prevention_contract.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/prevention_contract.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 206,
        "module_docstring": "M25 Prevention Contract Enforcement\n\n# =============================================================================\n# M25_FROZEN - DO NOT MODIFY\n# =============================================================================\n# Any changes here require explicit M25 reopen approval.\n# Changes invalidate all prior graduation evidence.\n# See PIN-140 for freeze rationale.\n# PREVENTION_CONTRACT_VERSION = \"1.0.0\"\n# =============================================================================\n\nFrom PIN-136, prevention records can ONLY be written when:\n1. Same pattern signature matches\n2. Same tenant\n3. Same feature path\n4. Policy is ACTIVE (not SHADOW, not PENDING)\n5. No incident is created (blocked before INSERT)\n6. Prevention record is written (append-only, immutable)\n\nThis module enforces these rules programmatically.",
        "functions": [
          {
            "name": "validate_prevention_candidate",
            "signature": "(candidate: PreventionCandidate) -> None",
            "docstring": "Validate that a prevention candidate satisfies the contract.\n\nRaises PreventionContractViolation if any rule is violated.\n\nRules (from PIN-136):\n1. Policy must be ACTIVE\n2. No incident created\n3. Pattern signature matches\n4. Same tenant\n5. Prevention records are append-only (handled at DB level)",
            "is_async": false,
            "line": 85
          },
          {
            "name": "assert_prevention_immutable",
            "signature": "(record_id: str, existing_record: dict[str, Any]) -> None",
            "docstring": "Assert that a prevention record has not been modified.\n\nPrevention records are append-only and immutable.\nThis should be called before any UPDATE attempt.",
            "is_async": false,
            "line": 142
          },
          {
            "name": "assert_no_deletion",
            "signature": "(record_id: str) -> None",
            "docstring": "Assert that a prevention record cannot be deleted.\n\nPrevention records are append-only and immutable.",
            "is_async": false,
            "line": 159
          },
          {
            "name": "validate_prevention_for_graduation",
            "signature": "(prevention_record: dict[str, Any], policy_activated_at: datetime) -> bool",
            "docstring": "Validate that a prevention record counts toward graduation.\n\nFor Gate 1 (Prevention) to pass:\n- Prevention must be real (is_simulated = False)\n- Prevention must be after policy activation\n- Policy must have been active at time of prevention",
            "is_async": false,
            "line": 175
          }
        ],
        "classes": [
          {
            "name": "PreventionContractViolation",
            "docstring": "Raised when a prevention record would violate the contract.",
            "methods": [
              "__init__"
            ],
            "line": 55
          },
          {
            "name": "PreventionCandidate",
            "docstring": "Candidate for prevention record creation.\n\nMust pass all contract checks before writing to prevention_records.",
            "methods": [],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [
          {
            "name": "PREVENTION_CONTRACT_VERSION",
            "line": 51
          },
          {
            "name": "PREVENTION_CONTRACT_FROZEN_AT",
            "line": 52
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "sql_gateway.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/sql_gateway.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 429,
        "module_docstring": "Module: sql_gateway\nPurpose: Template-based SQL queries (NO raw SQL from LLM).\n\nKey Difference from PostgresQuerySkill:\n    - PostgresQuerySkill: LLM provides SQL string (DANGEROUS)\n    - SqlGatewayService: LLM selects template ID, machine fills parameters\n\nSecurity Invariant: LLM NEVER sees or constructs SQL.\nThe SQL comes from pre-registered, audited templates.\n\nImports (Dependencies):\n    - None (credential service passed via constructor)\n\nExports (Provides):\n    - SqlGatewayService: Governed SQL access\n    - SqlGatewayConfig: Configuration dataclass\n    - QueryTemplate: SQL template definition\n\nWiring Points:\n    - Called from: RetrievalMediator\n    - Registered in: ConnectorRegistry\n\nAcceptance Criteria:\n    - [x] AC-060-01: No raw SQL from LLM\n    - [x] AC-060-02: Template ID required\n    - [x] AC-060-03: Parameters validated\n    - [x] AC-060-04: Read-only enforced\n    - [x] AC-060-05: SQL injection prevented\n    - [x] AC-060-06: Max rows enforced\n    - [x] AC-060-07: Tenant isolation (INV-003)\n    - [x] AC-060-08: Max result bytes enforced\n    - [x] AC-060-09: Query timeout enforced",
        "functions": [],
        "classes": [
          {
            "name": "ParameterType",
            "docstring": "Supported parameter types for validation.",
            "methods": [],
            "line": 83
          },
          {
            "name": "ParameterSpec",
            "docstring": "Specification for a query parameter.",
            "methods": [],
            "line": 97
          },
          {
            "name": "QueryTemplate",
            "docstring": "Definition of a SQL query template.",
            "methods": [],
            "line": 110
          },
          {
            "name": "SqlGatewayConfig",
            "docstring": "Configuration for SQL gateway.",
            "methods": [],
            "line": 123
          },
          {
            "name": "SqlGatewayError",
            "docstring": "Error from SQL gateway.",
            "methods": [],
            "line": 143
          },
          {
            "name": "SqlInjectionAttemptError",
            "docstring": "Potential SQL injection detected.",
            "methods": [],
            "line": 148
          },
          {
            "name": "SqlGatewayService",
            "docstring": "Governed SQL gateway.\n\nMachine controls:\n- SQL query templates (pre-registered)\n- Parameter validation\n- Connection credentials\n- Read-only enforcement\n- Row limits\n\nLLM controls:\n- Template selection (by ID from allowlist)\n- Parameter values (validated against spec)\n\nImplements Connector protocol for use with RetrievalMediator.",
            "methods": [
              "__init__",
              "id",
              "execute",
              "_resolve_template",
              "_validate_parameters",
              "_coerce_parameter",
              "_check_sql_injection",
              "_get_connection_string"
            ],
            "line": 153
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "TYPE_CHECKING"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.credentials",
            "names": [
              "Credential",
              "CredentialService"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.hoc.cus.integrations.L5_schemas.sql_gateway_protocol",
            "names": [
              "SqlQueryRequest",
              "SqlQueryResult"
            ],
            "is_relative": false,
            "line": 65
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_MAX_ROWS",
            "line": 78
          },
          {
            "name": "DEFAULT_MAX_RESULT_BYTES",
            "line": 79
          },
          {
            "name": "DEFAULT_TIMEOUT_SECONDS",
            "line": 80
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "types.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/types.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 56,
        "module_docstring": "Credential Type \u2014 Canonical Definition\n\nThis is the CANONICAL and ONLY authoritative definition of the\nCredential dataclass used by connector services.\n\nHistory:\n    Previously duplicated in:\n    - http_connector.py (lines 99-103)\n    - mcp_connector.py (lines 90-94)\n    - sql_gateway.py (lines 114-118)\n\n    Consolidated here per INT-DUP-001 quarantine resolution.",
        "functions": [],
        "classes": [
          {
            "name": "Credential",
            "docstring": "Credential from vault.\n\nA simple container for credential values retrieved from\nthe credential service. Used by connector services to\nauthenticate with external systems.\n\nAttributes:\n    value: The credential value (e.g., API key, token)\n    expires_at: Optional expiration timestamp",
            "methods": [],
            "line": 42
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [
      {
        "file_name": "audit_schemas.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/audit_schemas.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 59,
        "module_docstring": "M25 Audit Schemas\n\nDataclasses for audit records in the integration bridges.\n\nFROZEN: 2025-12-23\nDo NOT modify without explicit approval.",
        "functions": [],
        "classes": [
          {
            "name": "PolicyActivationAudit",
            "docstring": "Audit record for policy activation.\n\nRequired for:\n- Rollback\n- Blame tracking\n- Trust verification",
            "methods": [
              "to_dict"
            ],
            "line": 28
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_enums.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/cus_enums.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 72,
        "module_docstring": "Customer integration enum mirrors.\n\nThese mirror the canonical enums in app.models.cus_models so that\nL5 engines and L5 schemas never need a runtime import of app.models.\nValues MUST stay in sync with the L7 originals.\n\nCanonical source: app/models/cus_models.py",
        "functions": [],
        "classes": [
          {
            "name": "CusProviderType",
            "docstring": "Supported LLM provider types.\n\nMirror of app.models.cus_models.CusProviderType.",
            "methods": [],
            "line": 27
          },
          {
            "name": "CusIntegrationStatus",
            "docstring": "Integration lifecycle status.\n\nMirror of app.models.cus_models.CusIntegrationStatus.",
            "methods": [],
            "line": 40
          },
          {
            "name": "CusHealthState",
            "docstring": "Integration health state.\n\nMirror of app.models.cus_models.CusHealthState.",
            "methods": [],
            "line": 52
          },
          {
            "name": "CusPolicyResult",
            "docstring": "Policy enforcement result for LLM calls.\n\nMirror of app.models.cus_models.CusPolicyResult.",
            "methods": [],
            "line": 64
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_schemas.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/cus_schemas.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 498,
        "module_docstring": "Customer Integrations API Schemas\n\nPURPOSE:\n    Pydantic request/response models for the Customer Integrations API surface.\n    These schemas define the contract between SDK/clients and the backend.\n\nSCHEMAS:\n    Request Schemas:\n    - CusIntegrationCreate: Create a new integration\n    - CusIntegrationUpdate: Update integration settings\n    - CusLLMUsageIngest: Telemetry ingestion from SDK\n\n    Response Schemas:\n    - CusIntegrationResponse: Full integration details\n    - CusIntegrationSummary: List view integration\n    - CusUsageSummary: Aggregated usage statistics\n    - CusLimitsStatus: Current usage vs limits\n\nVALIDATION:\n    - All credential_ref values are validated as non-raw (no bare API keys)\n    - Provider types are constrained to supported enum values\n    - Token/cost values must be non-negative",
        "functions": [],
        "classes": [
          {
            "name": "CusIntegrationCreate",
            "docstring": "Request schema for creating a new integration.\n\nPURPOSE:\n    Captures all required information to create a customer LLM integration.\n    Credential handling is secure - we never accept raw API keys directly.\n\nVALIDATION:\n    - name is required, 1-255 chars\n    - provider_type must be a supported provider\n    - credential_ref must not look like a raw API key",
            "methods": [
              "validate_not_raw_key"
            ],
            "line": 55
          },
          {
            "name": "CusIntegrationUpdate",
            "docstring": "Request schema for updating an integration.\n\nPURPOSE:\n    Partial update - only provided fields are changed.\n    Status changes should use dedicated enable/disable endpoints.",
            "methods": [
              "validate_not_raw_key"
            ],
            "line": 133
          },
          {
            "name": "CusLLMUsageIngest",
            "docstring": "Request schema for SDK telemetry ingestion.\n\nPURPOSE:\n    SDK sends telemetry for each LLM call. This schema validates\n    the payload before persisting to cus_llm_usage.\n\nSEMANTIC:\n    This is DATA PLANE ingestion - append-only facts about what happened.\n    call_id provides idempotency for at-least-once delivery.",
            "methods": [],
            "line": 192
          },
          {
            "name": "CusLLMUsageBatchIngest",
            "docstring": "Request schema for batch telemetry ingestion.\n\nPURPOSE:\n    SDK may buffer and send multiple telemetry records at once\n    for efficiency. Max batch size is 100.",
            "methods": [],
            "line": 273
          },
          {
            "name": "CusIntegrationResponse",
            "docstring": "Full integration details response.\n\nPURPOSE:\n    Complete integration information including health state\n    and current limits. Used for detail view.",
            "methods": [],
            "line": 294
          },
          {
            "name": "CusIntegrationSummary",
            "docstring": "Integration summary for list views.\n\nPURPOSE:\n    Lightweight representation for list endpoints.\n    Excludes detailed config and health messages.",
            "methods": [],
            "line": 330
          },
          {
            "name": "CusLimitsStatus",
            "docstring": "Current usage vs configured limits.\n\nPURPOSE:\n    Dashboard view showing how much of each limit has been used.\n    Enables proactive budget and capacity management.",
            "methods": [],
            "line": 350
          },
          {
            "name": "CusUsageSummary",
            "docstring": "Aggregated usage statistics.\n\nPURPOSE:\n    Summary view of usage across integrations.\n    Used for dashboard totals and reports.",
            "methods": [],
            "line": 396
          },
          {
            "name": "CusIntegrationUsage",
            "docstring": "Usage for a single integration within a period.\n\nPURPOSE:\n    Per-integration breakdown within CusUsageSummary.",
            "methods": [],
            "line": 428
          },
          {
            "name": "CusLLMUsageResponse",
            "docstring": "Individual usage record response.\n\nPURPOSE:\n    Detailed view of a single LLM call for audit/debugging.",
            "methods": [],
            "line": 445
          },
          {
            "name": "CusHealthCheckResponse",
            "docstring": "Response from integration health check.\n\nPURPOSE:\n    Result of testing integration connectivity and credentials.",
            "methods": [],
            "line": 480
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.integrations.L5_schemas.cus_enums",
            "names": [
              "CusHealthState",
              "CusIntegrationStatus",
              "CusPolicyResult",
              "CusProviderType"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "datasource_model.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/datasource_model.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 584,
        "module_docstring": "CustomerDataSource - Customer data source models and registry.\n\nProvides data source abstraction for:\n- Database connections\n- File storage\n- API endpoints\n- Vector stores\n- Custom connectors",
        "functions": [
          {
            "name": "get_datasource_registry",
            "signature": "() -> DataSourceRegistry",
            "docstring": "Get the singleton registry instance.",
            "is_async": false,
            "line": 539
          },
          {
            "name": "_reset_registry",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 547
          },
          {
            "name": "create_datasource",
            "signature": "(tenant_id: str, name: str, source_type: DataSourceType, config: Optional[DataSourceConfig] = None) -> CustomerDataSource",
            "docstring": "Create a new data source using the singleton registry.",
            "is_async": false,
            "line": 556
          },
          {
            "name": "get_datasource",
            "signature": "(source_id: str) -> Optional[CustomerDataSource]",
            "docstring": "Get a data source by ID using the singleton registry.",
            "is_async": false,
            "line": 572
          },
          {
            "name": "list_datasources",
            "signature": "(tenant_id: Optional[str] = None, source_type: Optional[DataSourceType] = None) -> list[CustomerDataSource]",
            "docstring": "List data sources using the singleton registry.",
            "is_async": false,
            "line": 578
          }
        ],
        "classes": [
          {
            "name": "DataSourceType",
            "docstring": "Types of data sources.",
            "methods": [],
            "line": 24
          },
          {
            "name": "DataSourceStatus",
            "docstring": "Status of a data source.",
            "methods": [],
            "line": 36
          },
          {
            "name": "DataSourceConfig",
            "docstring": "Configuration for a data source.",
            "methods": [
              "to_dict",
              "get_connection_url"
            ],
            "line": 48
          },
          {
            "name": "CustomerDataSource",
            "docstring": "Representation of a customer data source.",
            "methods": [
              "record_connection",
              "record_error",
              "activate",
              "deactivate",
              "deprecate",
              "update_config",
              "add_tag",
              "remove_tag",
              "grant_access",
              "revoke_access",
              "has_access",
              "to_dict"
            ],
            "line": 128
          },
          {
            "name": "DataSourceError",
            "docstring": "Exception for data source errors.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 259
          },
          {
            "name": "DataSourceStats",
            "docstring": "Statistics for data sources.",
            "methods": [
              "to_dict"
            ],
            "line": 283
          },
          {
            "name": "DataSourceRegistry",
            "docstring": "Registry for managing customer data sources.\n\nFeatures:\n- CRUD operations for data sources\n- Status management\n- Tenant isolation\n- Access control",
            "methods": [
              "__init__",
              "register",
              "get",
              "get_by_name",
              "list",
              "update",
              "activate",
              "deactivate",
              "delete",
              "get_statistics",
              "clear_tenant",
              "reset"
            ],
            "line": 313
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 17
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 21
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "loop_events.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/loop_events.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 968,
        "module_docstring": "M25 Integration Loop Events\n\n# =============================================================================\n# M25_FROZEN - DO NOT MODIFY\n# =============================================================================\n# Any changes here require explicit M25 reopen approval.\n# Changes invalidate all prior graduation evidence.\n# See PIN-140 for freeze rationale.\n# =============================================================================\n\nEnhanced with:\n- Confidence bands (strong/weak/novel) instead of binary matching\n- Loop failure states for unhappy paths\n- Policy shadow mode support\n- Human checkpoint controls\n- Routing guardrails\n\nFROZEN: 2025-12-23\nGRADUATION_RULES_VERSION = \"1.0.0\"",
        "functions": [
          {
            "name": "ensure_json_serializable",
            "signature": "(obj: Any, path: str = 'root') -> Any",
            "docstring": "Guard function to ensure all objects stored in details are JSON-serializable.\n\nRaises TypeError with clear path if non-serializable object found.",
            "is_async": false,
            "line": 133
          }
        ],
        "classes": [
          {
            "name": "ConfidenceCalculator",
            "docstring": "Centralized confidence calculation.\n\nFROZEN: All confidence logic must go through this class.\nVersion is logged with every confidence value for audit.",
            "methods": [
              "calculate_recovery_confidence",
              "should_auto_apply",
              "get_confirmation_level"
            ],
            "line": 55
          },
          {
            "name": "ConfidenceBand",
            "docstring": "Confidence classification for pattern matching.\n\n- STRONG_MATCH: High confidence (>0.85) - Safe for auto-apply\n- WEAK_MATCH: Medium confidence (0.6-0.85) - Requires review\n- NOVEL: Low confidence (<0.6) - New pattern, needs investigation",
            "methods": [
              "from_confidence",
              "allows_auto_apply",
              "requires_human_review"
            ],
            "line": 166
          },
          {
            "name": "LoopStage",
            "docstring": "Stages in the integration feedback loop.",
            "methods": [],
            "line": 205
          },
          {
            "name": "LoopFailureState",
            "docstring": "Explicit failure states for when the loop doesn't complete.\n\nCritical for debugging and trust - the unhappy path matters more\nthan the happy path.",
            "methods": [],
            "line": 216
          },
          {
            "name": "PolicyMode",
            "docstring": "Policy activation modes for safety.\n\nShadow mode allows observation without enforcement.",
            "methods": [],
            "line": 238
          },
          {
            "name": "HumanCheckpointType",
            "docstring": "Types of human intervention points.",
            "methods": [],
            "line": 251
          },
          {
            "name": "LoopEvent",
            "docstring": "Base event for integration loop.\n\nAll events flow through the dispatcher and are persisted for durability.",
            "methods": [
              "create",
              "is_success",
              "is_blocked",
              "to_dict"
            ],
            "line": 267
          },
          {
            "name": "PatternMatchResult",
            "docstring": "Result of Bridge 1: Incident \u2192 Failure Catalog.\n\nEnhanced with confidence bands instead of binary matching.",
            "methods": [
              "from_match",
              "no_match",
              "should_auto_proceed",
              "to_dict"
            ],
            "line": 342
          },
          {
            "name": "RecoverySuggestion",
            "docstring": "Result of Bridge 2: Pattern \u2192 Recovery.\n\nEnhanced with template vs generated distinction and confidence scoring.",
            "methods": [
              "create",
              "none_available",
              "add_confirmation",
              "to_dict"
            ],
            "line": 415
          },
          {
            "name": "PolicyRule",
            "docstring": "Result of Bridge 3: Recovery \u2192 Policy.\n\nEnhanced with:\n- Shadow mode for safe observation\n- Confirmation requirements\n- Policy regret tracking",
            "methods": [
              "create",
              "record_shadow_evaluation",
              "add_confirmation",
              "record_regret",
              "shadow_block_rate",
              "to_dict"
            ],
            "line": 509
          },
          {
            "name": "RoutingAdjustment",
            "docstring": "Result of Bridge 4: Policy \u2192 CARE Routing.\n\nEnhanced with guardrails:\n- Max delta per adjustment\n- Decay window\n- Rollback on KPI regression",
            "methods": [
              "create",
              "check_kpi_regression",
              "rollback",
              "effective_magnitude",
              "to_dict"
            ],
            "line": 636
          },
          {
            "name": "HumanCheckpoint",
            "docstring": "Human intervention point in the loop.\n\nSupports: approve, simulate, revert actions.",
            "methods": [
              "create",
              "resolve",
              "is_pending"
            ],
            "line": 771
          },
          {
            "name": "LoopStatus",
            "docstring": "Complete status of an integration loop instance.\n\nUsed for console display and debugging.",
            "methods": [
              "completion_pct",
              "to_console_display",
              "_generate_narrative",
              "to_dict"
            ],
            "line": 835
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Literal",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [
          {
            "name": "LOOP_MECHANICS_VERSION",
            "line": 46
          },
          {
            "name": "LOOP_MECHANICS_FROZEN_AT",
            "line": 47
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "sql_gateway_protocol.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/sql_gateway_protocol.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 52,
        "module_docstring": "SQL Gateway Protocol & DTOs\n\nDefines the interface contract between L5 (sql_gateway.py) and L6\n(sql_gateway_driver.py). L5 builds a SqlQueryRequest; L6 executes it\nagainst an external database via asyncpg and returns SqlQueryResult.",
        "functions": [],
        "classes": [
          {
            "name": "SqlQueryRequest",
            "docstring": "Immutable request DTO passed from L5 to L6.",
            "methods": [],
            "line": 27
          },
          {
            "name": "SqlQueryResult",
            "docstring": "Result DTO returned from L6 to L5.",
            "methods": [],
            "line": 39
          },
          {
            "name": "SqlGatewayDriverProtocol",
            "docstring": "Protocol that L6 sql_gateway_driver must implement.",
            "methods": [
              "execute_query"
            ],
            "line": 49
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 23
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_other": [
      {
        "file_name": "channel_engine.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_notifications/engines/channel_engine.py",
        "layer": "L5_other",
        "domain": "integrations",
        "lines": 1102,
        "module_docstring": "Module: channel_engine\nPurpose: Configurable notification channels for alerts and events.\n\nGAP-017: Notify channels must be configurable per tenant/policy.\nThis service provides:\n    - Channel configuration (enable/disable per channel type)\n    - Channel validation (test connectivity)\n    - Delivery tracking (success/failure metrics)\n    - Retry logic for failed deliveries\n\nExports:\n    - NotifyChannel: Enum of available channels\n    - NotifyEventType: Enum of event types\n    - NotifyChannelConfig: Channel configuration\n    - NotifyChannelService: Main service class\n    - NotifyDeliveryResult: Delivery result tracking\n    - NotifyChannelError: Error for channel failures\n    - Helper functions for quick access",
        "functions": [
          {
            "name": "get_notify_service",
            "signature": "() -> NotifyChannelService",
            "docstring": "Get or create the notification service singleton.",
            "is_async": false,
            "line": 1032
          },
          {
            "name": "_reset_notify_service",
            "signature": "() -> None",
            "docstring": "Reset the notification service (for testing).",
            "is_async": false,
            "line": 1040
          },
          {
            "name": "get_channel_config",
            "signature": "(tenant_id: str, channel: NotifyChannel) -> Optional[NotifyChannelConfig]",
            "docstring": "Quick helper to get channel configuration.\n\nArgs:\n    tenant_id: Tenant identifier\n    channel: Channel type\n\nReturns:\n    NotifyChannelConfig or None",
            "is_async": false,
            "line": 1049
          },
          {
            "name": "send_notification",
            "signature": "(tenant_id: str, event_type: NotifyEventType, payload: Dict[str, Any], channels: Optional[List[NotifyChannel]] = None) -> List[NotifyDeliveryResult]",
            "docstring": "Quick helper to send notification.\n\nArgs:\n    tenant_id: Tenant identifier\n    event_type: Type of event\n    payload: Notification payload\n    channels: Optional specific channels\n\nReturns:\n    List of delivery results",
            "is_async": true,
            "line": 1067
          },
          {
            "name": "check_channel_health",
            "signature": "(tenant_id: str) -> Dict[NotifyChannel, Dict[str, Any]]",
            "docstring": "Quick helper to check channel health.\n\nArgs:\n    tenant_id: Tenant identifier\n\nReturns:\n    Dictionary of channel health status",
            "is_async": true,
            "line": 1089
          }
        ],
        "classes": [
          {
            "name": "NotifyChannel",
            "docstring": "Available notification channels.",
            "methods": [],
            "line": 49
          },
          {
            "name": "NotifyEventType",
            "docstring": "Types of events that can trigger notifications.",
            "methods": [],
            "line": 60
          },
          {
            "name": "NotifyChannelStatus",
            "docstring": "Status of a notification channel.",
            "methods": [],
            "line": 75
          },
          {
            "name": "NotifyChannelError",
            "docstring": "Raised when notification channel operation fails.\n\nThis error indicates that a notification could not be sent\nthrough the configured channel.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 84
          },
          {
            "name": "NotifyDeliveryResult",
            "docstring": "Result of a notification delivery attempt.",
            "methods": [
              "to_dict"
            ],
            "line": 116
          },
          {
            "name": "NotifyChannelConfig",
            "docstring": "Configuration for a notification channel.",
            "methods": [
              "is_event_enabled",
              "is_configured",
              "record_success",
              "record_failure",
              "to_dict"
            ],
            "line": 145
          },
          {
            "name": "NotifyChannelConfigResponse",
            "docstring": "Response from channel configuration operations.",
            "methods": [
              "to_dict"
            ],
            "line": 232
          },
          {
            "name": "NotificationSender",
            "docstring": "Protocol for notification sender implementations.",
            "methods": [
              "send"
            ],
            "line": 252
          },
          {
            "name": "NotifyChannelService",
            "docstring": "Service for managing notification channels.\n\nGAP-017: Provides configurable notification channels for\nalerts, incidents, and policy events.\n\nUsage:\n    service = NotifyChannelService()\n\n    # Configure a channel\n    config = service.configure_channel(\n        tenant_id=\"tenant-1\",\n        channel=NotifyChannel.WEBHOOK,\n        webhook_url=\"https://example.com/webhook\"\n    )\n\n    # Send notification\n    result = await service.send(\n        tenant_id=\"tenant-1\",\n        event_type=NotifyEventType.INCIDENT_CREATED,\n        payload={\"incident_id\": \"inc-123\", ...}\n    )\n\n    # Check channel health\n    health = await service.check_health(tenant_id=\"tenant-1\")",
            "methods": [
              "__init__",
              "configure_channel",
              "get_channel_config",
              "get_all_configs",
              "get_enabled_channels",
              "enable_channel",
              "disable_channel",
              "set_event_filter",
              "send",
              "_send_via_channel",
              "_send_ui_notification",
              "_send_webhook_notification",
              "_send_email_notification",
              "_send_slack_notification",
              "_send_pagerduty_notification",
              "_send_teams_notification",
              "check_health",
              "get_delivery_history"
            ],
            "line": 265
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Protocol",
              "Set"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "vault.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_vault/drivers/vault.py",
        "layer": "L5_other",
        "domain": "integrations",
        "lines": 1050,
        "module_docstring": "Credential Vault Abstraction (GAP-171)\n\nSupports multiple vault providers:\n- HashiCorp Vault (production)\n- AWS Secrets Manager (production)\n- Environment variables (development only)",
        "functions": [
          {
            "name": "create_credential_vault",
            "signature": "() -> CredentialVault",
            "docstring": "Factory function to create appropriate vault based on scope and configuration.\n\nPIN-517: Authority split between system and customer scopes.\n\nArgs:\n    scope: Trust zone - \"system\" (dev/infra) or \"customer\" (SDK-visible)\n\nReturns:\n    CredentialVault instance\n\nRaises:\n    ValueError: If customer scope with env provider (forbidden)\n    ValueError: If required credentials missing for production vault",
            "is_async": false,
            "line": 991
          }
        ],
        "classes": [
          {
            "name": "VaultProvider",
            "docstring": "Supported vault providers.",
            "methods": [],
            "line": 49
          },
          {
            "name": "CredentialType",
            "docstring": "Types of credentials.",
            "methods": [],
            "line": 57
          },
          {
            "name": "CredentialMetadata",
            "docstring": "Metadata about a stored credential (without secret values).",
            "methods": [],
            "line": 71
          },
          {
            "name": "CredentialData",
            "docstring": "Full credential including secret values.",
            "methods": [
              "credential_id",
              "tenant_id"
            ],
            "line": 91
          },
          {
            "name": "CredentialVault",
            "docstring": "Abstract credential vault interface.",
            "methods": [
              "store_credential",
              "get_credential",
              "get_metadata",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential"
            ],
            "line": 106
          },
          {
            "name": "HashiCorpVault",
            "docstring": "HashiCorp Vault implementation.",
            "methods": [
              "__init__",
              "store_credential",
              "get_credential",
              "get_metadata",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential"
            ],
            "line": 266
          },
          {
            "name": "EnvCredentialVault",
            "docstring": "Environment variable credential vault (development only).\n\nCredentials are stored in memory with secrets read from environment.",
            "methods": [
              "__init__",
              "store_credential",
              "get_credential",
              "get_metadata",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential"
            ],
            "line": 562
          },
          {
            "name": "AwsSecretsManagerVault",
            "docstring": "AWS Secrets Manager implementation (PIN-517 FIX 3).\n\nUses boto3 for AWS Secrets Manager operations.",
            "methods": [
              "__init__",
              "_get_client",
              "_secret_id",
              "store_credential",
              "get_credential",
              "get_metadata",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential"
            ],
            "line": 729
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Literal"
            ],
            "is_relative": false,
            "line": 988
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "service.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_vault/engines/service.py",
        "layer": "L5_other",
        "domain": "integrations",
        "lines": 551,
        "module_docstring": "Credential Service (GAP-171)\n\nHigh-level service for credential management with:\n- Input validation\n- Audit logging\n- Expiration checking\n- Rotation scheduling",
        "functions": [],
        "classes": [
          {
            "name": "CredentialAccessRecord",
            "docstring": "Record of credential access for auditing.",
            "methods": [],
            "line": 45
          },
          {
            "name": "CredentialService",
            "docstring": "High-level credential service.\n\nFeatures:\n- Credential CRUD with validation\n- Expiration checking\n- Access auditing\n- Rotation support",
            "methods": [
              "__init__",
              "store_credential",
              "get_credential",
              "get_secret_value",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential",
              "get_expiring_credentials",
              "get_rotatable_credentials",
              "get_access_log",
              "_audit",
              "_validate_tenant_id",
              "_validate_name",
              "_validate_secret_data"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "drivers.vault",
            "names": [
              "CredentialData",
              "CredentialMetadata",
              "CredentialType",
              "CredentialVault"
            ],
            "is_relative": true,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "vault_rule_check.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_vault/engines/vault_rule_check.py",
        "layer": "L5_other",
        "domain": "integrations",
        "lines": 118,
        "module_docstring": "Credential Access Rule Checker (PIN-517 FIX 4.1)\n\nDefines the protocol for credential access rule validation.\nRule checking is ASYNC and happens at L4 orchestrator\nBEFORE entering the sync vault path.\n\nImplementations:\n- DefaultCredentialAccessRuleChecker: Permissive (system scope)\n- DenyAllRuleChecker: Fail-closed (for testing)",
        "functions": [],
        "classes": [
          {
            "name": "CredentialAccessResult",
            "docstring": "Result of credential access rule check.",
            "methods": [],
            "line": 37
          },
          {
            "name": "CredentialAccessRuleChecker",
            "docstring": "Protocol for credential access rule validation.",
            "methods": [
              "check_credential_access"
            ],
            "line": 46
          },
          {
            "name": "DefaultCredentialAccessRuleChecker",
            "docstring": "Default rule checker - allows all access.\n\nUse for SYSTEM scope where permissive access is acceptable.\nNOT for customer credentials without explicit rules.",
            "methods": [
              "check_credential_access"
            ],
            "line": 73
          },
          {
            "name": "DenyAllRuleChecker",
            "docstring": "Fail-closed rule checker - denies all access.\n\nUse as default for customer scope when no rules configured.\nForces explicit rule configuration.",
            "methods": [
              "check_credential_access"
            ],
            "line": 97
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 33
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l6_drivers": [
      {
        "file_name": "bridges_driver.py",
        "file_path": "backend/app/hoc/cus/integrations/L6_drivers/bridges_driver.py",
        "layer": "L6_drivers",
        "domain": "integrations",
        "lines": 114,
        "module_docstring": "M25 Bridges Driver\n\nDatabase operations for integration bridge audit trails.\n\nL6 Contract:\n    - Session REQUIRED (passed from L4 handler)\n    - L6 does NOT commit (L4 owns transaction boundary)\n\nUNFROZEN: 2026-02-06 (PIN-520 L6 purity compliance)",
        "functions": [
          {
            "name": "record_policy_activation",
            "signature": "(session: AsyncSession, policy_id: str, source_pattern_id: str, source_recovery_id: str, confidence: float, approval_path: str, loop_trace_id: str, tenant_id: str) -> PolicyActivationAudit",
            "docstring": "Record policy activation for audit trail.\n\nEvery ACTIVE policy must have an audit record.\n\nArgs:\n    session: AsyncSession from L4 handler (required)\n    policy_id: Policy being activated\n    source_pattern_id: Source pattern ID\n    source_recovery_id: Source recovery ID\n    confidence: Confidence score at activation\n    approval_path: Approval workflow path\n    loop_trace_id: Loop trace correlation ID\n    tenant_id: Tenant scope\n\nReturns:\n    PolicyActivationAudit record\n\nNote:\n    L6 does NOT commit \u2014 L4 handler owns transaction boundary.",
            "is_async": true,
            "line": 39
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.hoc.cus.integrations.L5_schemas.audit_schemas",
            "names": [
              "PolicyActivationAudit"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.hoc.cus.integrations.L5_schemas.loop_events",
            "names": [
              "ConfidenceCalculator"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "connector_registry_driver.py",
        "file_path": "backend/app/hoc/cus/integrations/L6_drivers/connector_registry_driver.py",
        "layer": "L6_drivers",
        "domain": "integrations",
        "lines": 839,
        "module_docstring": "ConnectorRegistry - Connector management and registration.\n\nProvides a unified registry for:\n- Connector type registration\n- Connector instance management\n- Capability discovery\n- Status monitoring",
        "functions": [
          {
            "name": "get_connector_registry",
            "signature": "() -> ConnectorRegistry",
            "docstring": "Get the singleton registry instance.",
            "is_async": false,
            "line": 804
          },
          {
            "name": "_reset_registry",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 812
          },
          {
            "name": "register_connector",
            "signature": "(connector: BaseConnector) -> BaseConnector",
            "docstring": "Register a connector using the singleton registry.",
            "is_async": false,
            "line": 821
          },
          {
            "name": "get_connector",
            "signature": "(connector_id: str) -> Optional[BaseConnector]",
            "docstring": "Get a connector by ID using the singleton registry.",
            "is_async": false,
            "line": 827
          },
          {
            "name": "list_connectors",
            "signature": "(tenant_id: Optional[str] = None, connector_type: Optional[ConnectorType] = None) -> list[BaseConnector]",
            "docstring": "List connectors using the singleton registry.",
            "is_async": false,
            "line": 833
          }
        ],
        "classes": [
          {
            "name": "ConnectorType",
            "docstring": "Types of connectors.",
            "methods": [],
            "line": 39
          },
          {
            "name": "ConnectorStatus",
            "docstring": "Status of a connector.",
            "methods": [],
            "line": 52
          },
          {
            "name": "ConnectorCapability",
            "docstring": "Capabilities a connector may have.",
            "methods": [],
            "line": 64
          },
          {
            "name": "ConnectorConfig",
            "docstring": "Base configuration for connectors.",
            "methods": [
              "to_dict"
            ],
            "line": 78
          },
          {
            "name": "ConnectorError",
            "docstring": "Exception for connector errors.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 119
          },
          {
            "name": "BaseConnector",
            "docstring": "Abstract base class for all connectors.",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "health_check",
              "record_connection",
              "record_error",
              "to_dict"
            ],
            "line": 144
          },
          {
            "name": "VectorConnector",
            "docstring": "Connector for vector databases (GAP-061).\n\nSupports:\n- Vector storage and retrieval\n- Similarity search\n- Metadata filtering",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "health_check",
              "upsert_vectors",
              "search",
              "delete_vectors",
              "to_dict"
            ],
            "line": 227
          },
          {
            "name": "FileConnector",
            "docstring": "Connector for file storage (GAP-062).\n\nSupports:\n- File upload/download\n- Directory listing\n- Metadata operations",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "health_check",
              "list_files",
              "read_file",
              "write_file",
              "delete_file",
              "to_dict"
            ],
            "line": 346
          },
          {
            "name": "ServerlessConnector",
            "docstring": "Connector for serverless functions (GAP-064).\n\nSupports:\n- Function invocation\n- Async execution\n- Result retrieval",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "health_check",
              "invoke",
              "list_functions",
              "get_result",
              "to_dict"
            ],
            "line": 471
          },
          {
            "name": "ConnectorStats",
            "docstring": "Statistics for connectors.",
            "methods": [
              "to_dict"
            ],
            "line": 588
          },
          {
            "name": "ConnectorRegistry",
            "docstring": "Registry for managing connectors (GAP-057).\n\nFeatures:\n- Connector registration and lookup\n- Type-based filtering\n- Status management\n- Tenant isolation",
            "methods": [
              "__init__",
              "register",
              "create_vector_connector",
              "create_file_connector",
              "create_serverless_connector",
              "get",
              "get_by_name",
              "list",
              "delete",
              "get_statistics",
              "clear_tenant",
              "reset"
            ],
            "line": 616
          }
        ],
        "imports": [
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_health_driver.py",
        "file_path": "backend/app/hoc/cus/integrations/L6_drivers/cus_health_driver.py",
        "layer": "L6_drivers",
        "domain": "integrations",
        "lines": 258,
        "module_docstring": "Customer Health Driver\n\nL6 driver for health-check-specific data access operations.\n\nPure persistence - no business logic.\nAll methods accept a Session from the caller (L4 or L5 via L4 session).\n\nL6 Contract:\n    - Session REQUIRED (passed from L4 handler / coordinator)\n    - L6 does NOT commit (L4 owns transaction boundary)",
        "functions": [
          {
            "name": "_to_row",
            "signature": "(integration: CusIntegration) -> HealthIntegrationRow",
            "docstring": "Convert ORM model to frozen DTO.",
            "is_async": false,
            "line": 57
          },
          {
            "name": "get_cus_health_driver",
            "signature": "(session: Session) -> CusHealthDriver",
            "docstring": "Get driver instance.\n\nArgs:\n    session: Session from L4 handler (required)\n\nReturns:\n    CusHealthDriver instance\n\nNote:\n    Session is REQUIRED. L4 handler owns transaction boundary.",
            "is_async": false,
            "line": 225
          },
          {
            "name": "cus_health_driver_session",
            "signature": "() -> Generator[CusHealthDriver, None, None]",
            "docstring": "Context manager that creates a Session-bound CusHealthDriver.\n\nUse this when no L4 session is available (e.g., CLI callers,\nscheduler triggers). The session is created and closed automatically.\n\nYields:\n    CusHealthDriver bound to a fresh Session\n\nNote:\n    The session is NOT committed \u2014 the caller or L4 handler must\n    commit if writes are intended.",
            "is_async": false,
            "line": 241
          }
        ],
        "classes": [
          {
            "name": "HealthIntegrationRow",
            "docstring": "Immutable data transfer object for health-relevant integration data.\n\nRepresents raw database row fields needed by health engine \u2014 no business\ninterpretation.",
            "methods": [],
            "line": 38
          },
          {
            "name": "CusHealthDriver",
            "docstring": "L6 driver for health-check data access.\n\nPure persistence - no business logic.\nL6 does NOT commit \u2014 L4 handler owns transaction boundary.",
            "methods": [
              "__init__",
              "fetch_integration_for_health_check",
              "fetch_stale_enabled_integrations",
              "fetch_all_integrations_for_tenant",
              "update_health_state"
            ],
            "line": 77
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "contextlib",
            "names": [
              "contextmanager"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Generator",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.models.cus_models",
            "names": [
              "CusHealthState",
              "CusIntegration"
            ],
            "is_relative": false,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_integration_driver.py",
        "file_path": "backend/app/hoc/cus/integrations/L6_drivers/cus_integration_driver.py",
        "layer": "L6_drivers",
        "domain": "integrations",
        "lines": 466,
        "module_docstring": "Customer Integration Driver\n\nL6 driver for customer integration data access.\n\nPure persistence - no business logic.\nAll methods accept primitive parameters and return raw facts.\n\nL6 Contract:\n    - Session REQUIRED (passed from L4 handler)\n    - L6 does NOT commit (L4 owns transaction boundary)",
        "functions": [
          {
            "name": "get_cus_integration_driver",
            "signature": "(session: Session) -> CusIntegrationDriver",
            "docstring": "Get driver instance.\n\nArgs:\n    session: Session from L4 handler (required)\n\nReturns:\n    CusIntegrationDriver instance\n\nNote:\n    Session is REQUIRED. L4 handler owns transaction boundary.",
            "is_async": false,
            "line": 454
          }
        ],
        "classes": [
          {
            "name": "IntegrationRow",
            "docstring": "Immutable data transfer object.\n\nRepresents raw database row - no business interpretation.",
            "methods": [],
            "line": 38
          },
          {
            "name": "UsageAggregate",
            "docstring": "Immutable usage aggregate row.",
            "methods": [],
            "line": 64
          },
          {
            "name": "CusIntegrationDriver",
            "docstring": "L6 driver for customer integration data access.\n\nPure persistence - no business logic.\nL6 does NOT commit \u2014 L4 handler owns transaction boundary.",
            "methods": [
              "__init__",
              "fetch_by_id",
              "fetch_by_name",
              "fetch_list",
              "fetch_monthly_usage",
              "fetch_current_rpm",
              "create",
              "update_fields",
              "update_status",
              "update_config",
              "update_health"
            ],
            "line": 71
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "uuid",
            "names": [
              "UUID",
              "uuid4"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "col",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "app.models.cus_models",
            "names": [
              "CusHealthState",
              "CusIntegration",
              "CusIntegrationStatus",
              "CusLLMUsage",
              "CusUsageDaily"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "mcp_driver.py",
        "file_path": "backend/app/hoc/cus/integrations/L6_drivers/mcp_driver.py",
        "layer": "L6_drivers",
        "domain": "integrations",
        "lines": 754,
        "module_docstring": "MCP Driver - Pure persistence layer for MCP servers and tools.\n\nL6 driver for MCP server data access.\n\nPure persistence - no business logic, no protocol calls.\nAll methods accept primitive parameters and return raw facts.\n\nPIN-516 Invariants:\n- INV-2: Pure CRUD only (no HTTP, no MCP protocol, no health checks)\n- INV-3: Credentials stored by reference only",
        "functions": [
          {
            "name": "compute_input_hash",
            "signature": "(params: Dict[str, Any]) -> str",
            "docstring": "Compute SHA256 hash of input parameters.\n\nArgs:\n    params: Input parameters dict.\n\nReturns:\n    Hex-encoded SHA256 hash.",
            "is_async": false,
            "line": 727
          },
          {
            "name": "compute_output_hash",
            "signature": "(output: Any) -> str",
            "docstring": "Compute SHA256 hash of output.\n\nArgs:\n    output: Output value (any JSON-serializable type).\n\nReturns:\n    Hex-encoded SHA256 hash.",
            "is_async": false,
            "line": 742
          }
        ],
        "classes": [
          {
            "name": "McpServerRow",
            "docstring": "Immutable DTO for MCP server database row.",
            "methods": [],
            "line": 42
          },
          {
            "name": "McpToolRow",
            "docstring": "Immutable DTO for MCP tool database row.",
            "methods": [],
            "line": 73
          },
          {
            "name": "McpInvocationRow",
            "docstring": "Immutable DTO for MCP tool invocation database row.",
            "methods": [],
            "line": 96
          },
          {
            "name": "McpDriver",
            "docstring": "L6 driver for MCP persistence.\n\nPure CRUD operations only. No protocol logic.\n\nPIN-516 INV-2 Enforcement:\n- NO HTTP calls\n- NO MCP protocol logic\n- NO health checks\n- NO JSON-RPC parsing",
            "methods": [
              "__init__",
              "create_server",
              "get_server",
              "get_server_by_url",
              "list_servers",
              "update_server",
              "soft_delete_server",
              "upsert_tools",
              "get_tools",
              "get_tool",
              "update_tool",
              "record_invocation",
              "get_invocations",
              "get_invocation",
              "get_invocations_by_tenant",
              "_server_to_row",
              "_tool_to_row",
              "_invocation_to_row",
              "_compute_tool_hash"
            ],
            "line": 130
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 17
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "select",
              "update"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.models.mcp_models",
            "names": [
              "McpServer",
              "McpTool",
              "McpToolInvocation"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "proxy_driver.py",
        "file_path": "backend/app/hoc/cus/integrations/L6_drivers/proxy_driver.py",
        "layer": "L6_drivers",
        "domain": "integrations",
        "lines": 526,
        "module_docstring": "Proxy Driver - Pure persistence layer for OpenAI proxy operations.\n\nL6 driver for proxy-related database operations.\n\nPure persistence - no business logic, no HTTP calls.\nAll methods accept primitive parameters and return raw facts.\n\nEncapsulates all session.execute() calls that were previously in v1_proxy.py (L2).",
        "functions": [
          {
            "name": "get_proxy_driver",
            "signature": "(session: Session) -> ProxyDriver",
            "docstring": "Get ProxyDriver instance.\n\nArgs:\n    session: SQLModel sync session.\n\nReturns:\n    ProxyDriver instance.",
            "is_async": false,
            "line": 517
          }
        ],
        "classes": [
          {
            "name": "ApiKeyRow",
            "docstring": "Immutable DTO for API key database row.",
            "methods": [],
            "line": 51
          },
          {
            "name": "TenantRow",
            "docstring": "Immutable DTO for tenant database row.",
            "methods": [],
            "line": 68
          },
          {
            "name": "KillSwitchStateRow",
            "docstring": "Immutable DTO for killswitch state database row.",
            "methods": [],
            "line": 80
          },
          {
            "name": "GuardrailRow",
            "docstring": "Immutable DTO for default guardrail database row.",
            "methods": [],
            "line": 88
          },
          {
            "name": "LatencyStats",
            "docstring": "Immutable DTO for latency statistics.",
            "methods": [],
            "line": 102
          },
          {
            "name": "IncidentRow",
            "docstring": "Immutable DTO for incident database row.",
            "methods": [],
            "line": 111
          },
          {
            "name": "ProxyDriver",
            "docstring": "L6 driver for OpenAI proxy persistence.\n\nPure CRUD operations only. No business logic.\n\nProvides all database operations needed by v1_proxy.py:\n- API key lookup and usage recording\n- Tenant lookup\n- KillSwitch state checks\n- Guardrails fetch\n- Proxy call logging\n- Status endpoint queries (latency stats, blocked counts, incidents)",
            "methods": [
              "__init__",
              "get_api_key_by_hash",
              "get_api_key_id_and_tenant",
              "record_api_key_usage",
              "get_tenant_by_id",
              "get_killswitch_state",
              "get_enabled_guardrails",
              "log_proxy_call",
              "get_latency_stats",
              "get_blocked_call_count",
              "get_last_incident"
            ],
            "line": 126
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "sql_gateway_driver.py",
        "file_path": "backend/app/hoc/cus/integrations/L6_drivers/sql_gateway_driver.py",
        "layer": "L6_drivers",
        "domain": "integrations",
        "lines": 108,
        "module_docstring": "SQL Gateway Driver (L6)\n\nOwns the asyncpg import and external database connection lifecycle.\nExecutes parameterized SQL templates provided by the L5 engine.\n\nL6 Contract:\n    - Accepts SqlQueryRequest from L5 (connection_string, sql, params)\n    - Opens/closes asyncpg connection per query\n    - Enforces max_rows and max_result_bytes caps\n    - Returns SqlQueryResult DTO to L5\n    - Does NOT commit (read-only by design; external DB)",
        "functions": [
          {
            "name": "get_sql_gateway_driver",
            "signature": "() -> SqlGatewayDriver",
            "docstring": "Factory for L4/L5 callers.",
            "is_async": false,
            "line": 106
          }
        ],
        "classes": [
          {
            "name": "SqlGatewayDriver",
            "docstring": "L6 driver: executes parameterized SQL against external databases.",
            "methods": [
              "execute_query"
            ],
            "line": 49
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "asyncpg",
            "names": [
              "asyncpg"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.hoc.cus.integrations.L5_schemas.sql_gateway_protocol",
            "names": [
              "SqlQueryRequest",
              "SqlQueryResult"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "worker_registry_driver.py",
        "file_path": "backend/app/hoc/cus/integrations/L6_drivers/worker_registry_driver.py",
        "layer": "L6_drivers",
        "domain": "integrations",
        "lines": 424,
        "module_docstring": "Worker Registry Driver (L6)\n\nProvides:\n- Dynamic worker discovery from database\n- Worker status and capability queries\n- Per-tenant worker configuration\n- Worker availability checks",
        "functions": [
          {
            "name": "get_worker_registry_service",
            "signature": "(session: Session) -> WorkerRegistryService",
            "docstring": "Get a WorkerRegistryService instance.",
            "is_async": false,
            "line": 413
          }
        ],
        "classes": [
          {
            "name": "WorkerRegistryError",
            "docstring": "Base exception for worker registry errors.",
            "methods": [],
            "line": 47
          },
          {
            "name": "WorkerNotFoundError",
            "docstring": "Raised when a worker is not found.",
            "methods": [],
            "line": 53
          },
          {
            "name": "WorkerUnavailableError",
            "docstring": "Raised when a worker is not available.",
            "methods": [],
            "line": 59
          },
          {
            "name": "WorkerRegistryService",
            "docstring": "Service for worker registry operations.",
            "methods": [
              "__init__",
              "get_worker",
              "get_worker_or_raise",
              "list_workers",
              "list_available_workers",
              "is_worker_available",
              "get_worker_details",
              "get_worker_summary",
              "list_worker_summaries",
              "register_worker",
              "update_worker_status",
              "deprecate_worker",
              "get_tenant_worker_config",
              "set_tenant_worker_config",
              "list_tenant_worker_configs",
              "get_effective_worker_config",
              "is_worker_enabled_for_tenant",
              "get_workers_for_tenant"
            ],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerConfig",
              "WorkerRegistry"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "WorkerRegistryService",
          "WorkerRegistryError",
          "WorkerNotFoundError",
          "WorkerUnavailableError",
          "get_worker_registry_service"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 34,
    "violation_count": 0,
    "gap_count": 1
  },
  "apis": {
    "l2_1_facade": null,
    "l2_apis": [],
    "l4_spine": [],
    "l5_engines": [],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "keys_driver.py",
        "file_path": "backend/app/hoc/cus/apis/L6_drivers/keys_driver.py",
        "layer": "L6_drivers",
        "domain": "apis",
        "lines": 196,
        "module_docstring": "Keys Driver (L6)\n\nPure data access for API keys.\nNo business logic - only DB operations.\n\nAuthority: KEY_PERSISTENCE\nTables: api_keys, proxy_calls (read-only for usage)",
        "functions": [
          {
            "name": "get_keys_driver",
            "signature": "(session: Session) -> KeysDriver",
            "docstring": "Factory function for KeysDriver.",
            "is_async": false,
            "line": 188
          }
        ],
        "classes": [
          {
            "name": "KeysDriver",
            "docstring": "L6 driver for API key data access.\n\nINVARIANTS (L6):\n- No business branching\n- No validation\n- No cross-domain calls\n- Pure persistence operations only",
            "methods": [
              "__init__",
              "fetch_keys_paginated",
              "fetch_key_by_id",
              "fetch_key_usage_today",
              "update_key_frozen"
            ],
            "line": 55
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "ProxyCall"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.models.tenant",
            "names": [
              "APIKey"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": [
          "KeysDriver",
          "get_keys_driver"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 1,
    "violation_count": 0,
    "gap_count": 2
  },
  "account": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/account.py",
    "l2_apis": [
      {
        "file_name": "memory_pins.py",
        "file_path": "backend/app/hoc/api/cus/account/memory_pins.py",
        "layer": "L2_api",
        "domain": "account",
        "lines": 363,
        "module_docstring": "Memory Pins API - M7 Implementation\n\nProvides REST API for managing memory pins (structured key-value storage).\n\nFeatures:\n- Tenant-isolated storage\n- JSONB values for flexible schema\n- Optional TTL for expiring entries\n- RBAC enforcement (when enabled)\n- Prometheus metrics (via L5 engine)\n\nEndpoints:\n- POST /memory/pins - Create or upsert a pin\n- GET /memory/pins/{key} - Get a pin by key\n- GET /memory/pins - List pins for tenant\n- DELETE /memory/pins/{key} - Delete a pin\n- POST /memory/pins/cleanup - Clean up expired pins\n\nAll DB access routed through L4 operation registry \u2192 L5 engine \u2192 L6 driver.",
        "functions": [
          {
            "name": "extract_tenant_from_request",
            "signature": "(request: Request, tenant_id: Optional[str] = None) -> str",
            "docstring": "Extract tenant ID from request or parameter.",
            "is_async": false,
            "line": 116
          },
          {
            "name": "_pin_row_to_response",
            "signature": "(pin: Any) -> MemoryPinResponse",
            "docstring": "Convert a MemoryPinRow dataclass to response model.",
            "is_async": false,
            "line": 126
          },
          {
            "name": "create_or_upsert_pin",
            "signature": "(pin: MemoryPinCreate, request: Request, session = Depends(get_session_dep))",
            "docstring": "Create or upsert a memory pin.\n\nIf a pin with the same (tenant_id, key) exists, it will be updated.\nOtherwise, a new pin is created.\n\nRequires RBAC permission: memory_pin:write",
            "is_async": true,
            "line": 147
          },
          {
            "name": "get_pin",
            "signature": "(key: str, request: Request, tenant_id: str = Query(default='global', description='Tenant ID'), session = Depends(get_session_dep))",
            "docstring": "Get a memory pin by key.\n\nReturns 404 if not found or expired.\n\nRequires RBAC permission: memory_pin:read",
            "is_async": true,
            "line": 192
          },
          {
            "name": "list_pins",
            "signature": "(request: Request, tenant_id: str = Query(default='global', description='Tenant ID'), prefix: Optional[str] = Query(default=None, description='Key prefix filter'), limit: int = Query(default=100, ge=1, le=1000, description='Max results'), offset: int = Query(default=0, ge=0, description='Offset for pagination'), include_expired: bool = Query(default=False, description='Include expired pins'), session = Depends(get_session_dep))",
            "docstring": "List memory pins for a tenant.\n\nSupports filtering by key prefix and pagination.\n\nRequires RBAC permission: memory_pin:read",
            "is_async": true,
            "line": 234
          },
          {
            "name": "delete_pin",
            "signature": "(key: str, request: Request, tenant_id: str = Query(default='global', description='Tenant ID'), session = Depends(get_session_dep))",
            "docstring": "Delete a memory pin by key.\n\nReturns 404 if not found.\n\nRequires RBAC permission: memory_pin:delete",
            "is_async": true,
            "line": 283
          },
          {
            "name": "cleanup_expired_pins",
            "signature": "(request: Request, tenant_id: Optional[str] = Query(default=None, description='Limit to specific tenant'), session = Depends(get_session_dep))",
            "docstring": "Clean up expired memory pins.\n\nTypically called by a cron job. Deletes all pins where expires_at < now().\n\nRequires RBAC permission: memory_pin:admin",
            "is_async": true,
            "line": 325
          }
        ],
        "classes": [
          {
            "name": "MemoryPinCreate",
            "docstring": "Schema for creating/upserting a memory pin.",
            "methods": [
              "validate_key"
            ],
            "line": 58
          },
          {
            "name": "MemoryPinResponse",
            "docstring": "Schema for memory pin response.",
            "methods": [],
            "line": 77
          },
          {
            "name": "MemoryPinListResponse",
            "docstring": "Schema for listing memory pins.",
            "methods": [],
            "line": 94
          },
          {
            "name": "MemoryPinDeleteResponse",
            "docstring": "Schema for delete response.",
            "methods": [],
            "line": 103
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l4_spine": [],
    "l5_engines": [
      {
        "file_name": "accounts_facade.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/accounts_facade.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 1135,
        "module_docstring": "Accounts Domain Facade (L5)\n\nUnified facade for all accounts domain operations:\n- Projects: list, detail\n- Users: list, detail, invite, remove, update role\n- Profile: get, update\n- Billing: summary, invoices\n- Support: contact, tickets\n\nGOVERNANCE NOTE:\nAccount is NOT a domain - it manages who, what, and billing (not what happened).\nAccount pages MUST NOT display executions, incidents, policies, or logs.",
        "functions": [
          {
            "name": "get_accounts_facade",
            "signature": "() -> AccountsFacade",
            "docstring": "Get the singleton AccountsFacade instance.",
            "is_async": false,
            "line": 1096
          }
        ],
        "classes": [
          {
            "name": "ProjectSummaryResult",
            "docstring": "Project summary for list view.",
            "methods": [],
            "line": 66
          },
          {
            "name": "ProjectsListResult",
            "docstring": "Projects list response.",
            "methods": [],
            "line": 79
          },
          {
            "name": "ProjectDetailResult",
            "docstring": "Project detail response.",
            "methods": [],
            "line": 89
          },
          {
            "name": "UserSummaryResult",
            "docstring": "User summary for list view.",
            "methods": [],
            "line": 122
          },
          {
            "name": "UsersListResult",
            "docstring": "Users list response.",
            "methods": [],
            "line": 135
          },
          {
            "name": "UserDetailResult",
            "docstring": "User detail response.",
            "methods": [],
            "line": 145
          },
          {
            "name": "TenantUserResult",
            "docstring": "User in tenant.",
            "methods": [],
            "line": 170
          },
          {
            "name": "TenantUsersListResult",
            "docstring": "List of tenant users.",
            "methods": [],
            "line": 181
          },
          {
            "name": "ProfileResult",
            "docstring": "User profile response.",
            "methods": [],
            "line": 194
          },
          {
            "name": "ProfileUpdateResult",
            "docstring": "Profile update response.",
            "methods": [],
            "line": 209
          },
          {
            "name": "BillingSummaryResult",
            "docstring": "Billing summary response.",
            "methods": [],
            "line": 226
          },
          {
            "name": "InvoiceSummaryResult",
            "docstring": "Invoice summary.",
            "methods": [],
            "line": 244
          },
          {
            "name": "InvoiceListResult",
            "docstring": "Invoice list response.",
            "methods": [],
            "line": 256
          },
          {
            "name": "SupportContactResult",
            "docstring": "Support contact info.",
            "methods": [],
            "line": 270
          },
          {
            "name": "SupportTicketResult",
            "docstring": "Support ticket response.",
            "methods": [],
            "line": 279
          },
          {
            "name": "SupportTicketListResult",
            "docstring": "Support ticket list response.",
            "methods": [],
            "line": 295
          },
          {
            "name": "InvitationResult",
            "docstring": "Invitation response.",
            "methods": [],
            "line": 308
          },
          {
            "name": "InvitationListResult",
            "docstring": "Invitation list response.",
            "methods": [],
            "line": 321
          },
          {
            "name": "AcceptInvitationResult",
            "docstring": "Invitation acceptance result.",
            "methods": [],
            "line": 329
          },
          {
            "name": "AccountsFacade",
            "docstring": "Unified facade for all Accounts domain operations.\n\nProvides:\n- Projects: list, detail\n- Users: list, detail, invite, remove, update role\n- Profile: get, update\n- Billing: summary, invoices\n- Support: contact, tickets\n\nGOVERNANCE NOTE:\nAccount is NOT a domain - it manages who, what, and billing (not what happened).\n\nLAYER COMPLIANCE (Phase 2.5B):\nThis L4 facade delegates all DB operations to AccountsFacadeDriver (L6).\nBusiness logic (validation, permissions) remains here.",
            "methods": [
              "__init__",
              "list_projects",
              "get_project_detail",
              "list_users",
              "get_user_detail",
              "list_tenant_users",
              "update_user_role",
              "remove_user",
              "get_profile",
              "update_profile",
              "get_billing_summary",
              "get_billing_invoices",
              "get_support_contact",
              "create_support_ticket",
              "list_support_tickets",
              "invite_user",
              "list_invitations",
              "accept_invitation"
            ],
            "line": 352
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "secrets",
            "names": [
              "secrets"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.account.L6_drivers.accounts_facade_driver",
            "names": [
              "AccountsFacadeDriver",
              "get_accounts_facade_driver"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.result_types",
            "names": [
              "AccountsErrorResult"
            ],
            "is_relative": false,
            "line": 344
          }
        ],
        "constants": [],
        "all_exports": [
          "AccountsFacade",
          "get_accounts_facade",
          "ProjectSummaryResult",
          "ProjectsListResult",
          "ProjectDetailResult",
          "UserSummaryResult",
          "UsersListResult",
          "UserDetailResult",
          "TenantUserResult",
          "TenantUsersListResult",
          "ProfileResult",
          "ProfileUpdateResult",
          "BillingSummaryResult",
          "InvoiceSummaryResult",
          "InvoiceListResult",
          "SupportContactResult",
          "SupportTicketResult",
          "SupportTicketListResult",
          "InvitationResult",
          "InvitationListResult",
          "AcceptInvitationResult",
          "AccountsErrorResult"
        ]
      },
      {
        "file_name": "billing_provider_engine.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/billing_provider_engine.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 252,
        "module_docstring": "Phase-6 Billing Provider \u2014 Interface and Mock Implementation\n\nPIN-399 Phase-6: Mock provider must satisfy same interface as real provider.\n\nDESIGN INVARIANTS (LOCKED):\n- BILLING-005: Mock provider must satisfy same interface as real provider\n\nIMPLEMENTATION CONSTRAINTS:\n- Hardcoded plan assignment\n- Hardcoded limits\n- Deterministic behavior\n- No network calls\n- No external dependencies\n\nThis ensures zero refactor when Stripe/etc is added later.",
        "functions": [
          {
            "name": "get_billing_provider",
            "signature": "() -> BillingProvider",
            "docstring": "Get the billing provider instance.\n\nReturns MockBillingProvider by default.\nCan be replaced for testing or production.",
            "is_async": false,
            "line": 224
          },
          {
            "name": "set_billing_provider",
            "signature": "(provider: BillingProvider) -> None",
            "docstring": "Set the billing provider instance.\n\nUsed for testing or to swap in a real provider.",
            "is_async": false,
            "line": 237
          }
        ],
        "classes": [
          {
            "name": "BillingProvider",
            "docstring": "Phase-6 Billing Provider Protocol.\n\nAll billing providers (mock and real) must implement this interface.\n\nThis protocol is LOCKED per BILLING-005.",
            "methods": [
              "get_billing_state",
              "get_plan",
              "get_limits",
              "is_limit_exceeded"
            ],
            "line": 48
          },
          {
            "name": "MockBillingProvider",
            "docstring": "Phase-6 Mock Billing Provider.\n\nImplements BillingProvider protocol with hardcoded, deterministic behavior.\n\nIMPLEMENTATION CONSTRAINTS:\n- No network calls\n- No database access (uses in-memory state)\n- Deterministic results\n- Static configuration\n\nThis mock is behavior-compatible with future real providers.",
            "methods": [
              "__init__",
              "get_billing_state",
              "get_plan",
              "get_limits",
              "is_limit_exceeded",
              "set_billing_state",
              "set_plan",
              "reset"
            ],
            "line": 112
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Protocol",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.billing.state",
            "names": [
              "BillingState"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.billing.plan",
            "names": [
              "Plan",
              "DEFAULT_PLAN",
              "PLAN_FREE",
              "PLAN_PRO",
              "PLAN_ENTERPRISE"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.billing.limits",
            "names": [
              "Limits",
              "derive_limits"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": [
          "BillingProvider",
          "MockBillingProvider",
          "get_billing_provider",
          "set_billing_provider"
        ]
      },
      {
        "file_name": "memory_pins_engine.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/memory_pins_engine.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 321,
        "module_docstring": "Memory Pins Engine (L5)\n\nBusiness logic for memory pin operations.\nHandles: feature flag check, validation, metrics recording, audit trail.\nDelegates all DB access to L6 memory_pins_driver.",
        "functions": [
          {
            "name": "get_memory_pins_engine",
            "signature": "() -> MemoryPinsEngine",
            "docstring": "Get or create the singleton MemoryPinsEngine.",
            "is_async": false,
            "line": 316
          }
        ],
        "classes": [
          {
            "name": "MemoryPinsDisabledError",
            "docstring": "Raised when memory pins feature is disabled.",
            "methods": [],
            "line": 59
          },
          {
            "name": "MemoryPinResult",
            "docstring": "Result of a memory pin operation.",
            "methods": [],
            "line": 64
          },
          {
            "name": "MemoryPinsDriverPort",
            "docstring": "Port for L6 driver methods used by MemoryPinsEngine.",
            "methods": [
              "upsert_pin",
              "get_pin",
              "list_pins",
              "delete_pin",
              "cleanup_expired",
              "write_audit"
            ],
            "line": 79
          },
          {
            "name": "MemoryPinsEngine",
            "docstring": "Business logic for memory pin operations.",
            "methods": [
              "_check_enabled",
              "upsert_pin",
              "get_pin",
              "list_pins",
              "delete_pin",
              "cleanup_expired"
            ],
            "line": 146
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Protocol"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.hoc.cus.account.L6_drivers.memory_pins_driver",
            "names": [
              "MemoryPinRow"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.utils.metrics_helpers",
            "names": [
              "get_or_create_counter",
              "get_or_create_histogram"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [
          {
            "name": "MEMORY_PINS_ENABLED",
            "line": 44
          },
          {
            "name": "MEMORY_PINS_OPERATIONS",
            "line": 46
          },
          {
            "name": "MEMORY_PINS_LATENCY",
            "line": 51
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "notifications_facade.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/notifications_facade.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 480,
        "module_docstring": "Notifications Facade (L5 Domain Engine)\n\nThis facade provides the external interface for notification operations.\nAll notification APIs MUST use this facade instead of directly importing\ninternal notification modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes notification delivery logic\n- Provides unified access to multiple notification channels\n- Single point for audit emission\n\nL2 API Routes (GAP-109):\n- POST /api/v1/notifications (send notification)\n- GET /api/v1/notifications (list notifications)\n- GET /api/v1/notifications/{id} (get notification)\n- POST /api/v1/notifications/{id}/read (mark as read)\n- GET /api/v1/notifications/channels (list channels)\n- PUT /api/v1/notifications/preferences (update preferences)\n\nUsage:\n    from app.hoc.cus.account.L5_engines import get_notifications_facade\n\n    facade = get_notifications_facade()\n\n    # Send notification\n    result = await facade.send_notification(\n        tenant_id=\"...\",\n        channel=\"email\",\n        recipient=\"...\",\n        message=\"...\",\n    )",
        "functions": [
          {
            "name": "get_notifications_facade",
            "signature": "() -> NotificationsFacade",
            "docstring": "Get the notifications facade instance.\n\nThis is the recommended way to access notification operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    NotificationsFacade instance",
            "is_async": false,
            "line": 467
          }
        ],
        "classes": [
          {
            "name": "NotificationChannel",
            "docstring": "Notification channels.",
            "methods": [],
            "line": 67
          },
          {
            "name": "NotificationPriority",
            "docstring": "Notification priorities.",
            "methods": [],
            "line": 76
          },
          {
            "name": "NotificationStatus",
            "docstring": "Notification delivery status.",
            "methods": [],
            "line": 84
          },
          {
            "name": "NotificationInfo",
            "docstring": "Notification information.",
            "methods": [
              "to_dict"
            ],
            "line": 94
          },
          {
            "name": "ChannelInfo",
            "docstring": "Notification channel information.",
            "methods": [
              "to_dict"
            ],
            "line": 128
          },
          {
            "name": "NotificationPreferences",
            "docstring": "User notification preferences.",
            "methods": [
              "to_dict"
            ],
            "line": 148
          },
          {
            "name": "NotificationsFacade",
            "docstring": "Facade for notification operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nnotification services.\n\nLayer: L4 (Domain Logic)\nCallers: notifications.py (L2), aos_sdk, Worker",
            "methods": [
              "__init__",
              "send_notification",
              "list_notifications",
              "get_notification",
              "mark_as_read",
              "list_channels",
              "get_channel",
              "get_preferences",
              "update_preferences"
            ],
            "line": 165
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 62
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "onboarding_engine.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/onboarding_engine.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 144,
        "module_docstring": "Onboarding Engine (L5)\n\nBusiness logic for onboarding state transitions.\nMonotonic, idempotent state machine.\n\nINVARIANTS:\n- ONBOARD-TRANS-001: Transitions are idempotent (repeated calls are no-ops)\n- ONBOARD-TRANS-002: Transitions are monotonic (forward-only, never regress)\n\nNO COMMIT \u2014 L4 coordinator owns transaction boundary.\nNo sqlalchemy/sqlmodel imports (L5 purity).",
        "functions": [
          {
            "name": "get_onboarding_engine",
            "signature": "(driver) -> OnboardingEngine",
            "docstring": "Get an OnboardingEngine instance.",
            "is_async": false,
            "line": 136
          }
        ],
        "classes": [
          {
            "name": "OnboardingEngine",
            "docstring": "L5 Engine for onboarding state transitions.\n\nDriver is injected (duck-typed: needs fetch_onboarding_state, write_onboarding_state).",
            "methods": [
              "__init__",
              "get_state",
              "advance"
            ],
            "line": 45
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.onboarding_state",
            "names": [
              "ONBOARDING_STATUS_NAMES",
              "is_complete"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.onboarding_dtos",
            "names": [
              "OnboardingStateSnapshot",
              "OnboardingTransitionResult"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": [
          "OnboardingEngine",
          "get_onboarding_engine"
        ]
      },
      {
        "file_name": "tenant_engine.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/tenant_engine.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 583,
        "module_docstring": "Tenant Engine (L5)\n\nBusiness logic for tenant operations.\n\nProvides:\n- Tenant creation with plan quotas\n- Plan upgrades/downgrades\n- Quota enforcement (runs per day, tokens per month, concurrent runs)\n- API key management with limits\n- Run lifecycle with quota checks\n- Usage tracking\n\nAll DB operations are delegated to TenantDriver (L6).",
        "functions": [
          {
            "name": "get_tenant_engine",
            "signature": "(session: Session) -> TenantEngine",
            "docstring": "Get a TenantEngine instance.",
            "is_async": false,
            "line": 573
          }
        ],
        "classes": [
          {
            "name": "TenantEngineError",
            "docstring": "Base exception for tenant engine errors.",
            "methods": [],
            "line": 66
          },
          {
            "name": "QuotaExceededError",
            "docstring": "Raised when a quota limit is exceeded.",
            "methods": [
              "__init__"
            ],
            "line": 71
          },
          {
            "name": "TenantEngine",
            "docstring": "L4 Engine for tenant business logic.\n\nHandles:\n- Quota decisions\n- Plan logic\n- Status validation\n- Temporal logic (daily counter reset)\n\nDelegates all DB operations to TenantDriver (L6).",
            "methods": [
              "__init__",
              "create_tenant",
              "get_tenant",
              "get_tenant_by_slug",
              "update_plan",
              "suspend",
              "create_membership_with_default",
              "create_api_key",
              "list_api_keys",
              "revoke_api_key",
              "check_run_quota",
              "check_token_quota",
              "increment_usage",
              "_maybe_reset_daily_counter",
              "record_usage",
              "get_usage_summary",
              "create_run",
              "complete_run",
              "list_runs"
            ],
            "line": 86
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "timedelta"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.account.L6_drivers.tenant_driver",
            "names": [
              "TenantDriver",
              "get_tenant_driver"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.plan_quotas",
            "names": [
              "PLAN_QUOTAS"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": [
          "TenantEngine",
          "TenantEngineError",
          "QuotaExceededError",
          "get_tenant_engine"
        ]
      },
      {
        "file_name": "tenant_lifecycle_engine.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/tenant_lifecycle_engine.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 195,
        "module_docstring": "Tenant Lifecycle Engine (L5)\n\nBusiness logic for tenant lifecycle transitions.\nDriver is injected (duck-typed), not imported at module level.\nNO COMMIT \u2014 L4 handler owns transaction boundary.\n\nEnforces:\n- OFFBOARD-001: Monotonic transitions (via is_valid_transition)\n- OFFBOARD-002: TERMINATED irreversible\n- OFFBOARD-003: ARCHIVED unreachable from ACTIVE",
        "functions": [
          {
            "name": "_action_name",
            "signature": "(to_status: TenantLifecycleStatus) -> str",
            "docstring": "Map target status to action name.",
            "is_async": false,
            "line": 177
          },
          {
            "name": "get_tenant_lifecycle_engine",
            "signature": "(driver) -> TenantLifecycleEngine",
            "docstring": "Get a TenantLifecycleEngine instance with injected driver.",
            "is_async": false,
            "line": 187
          }
        ],
        "classes": [
          {
            "name": "TenantLifecycleEngine",
            "docstring": "L5 Engine for tenant lifecycle business logic.\n\nDriver is injected via constructor (duck-typed).\nAll methods return pure DTOs \u2014 no ORM objects.\nNO COMMIT \u2014 L4 handler owns transaction boundary.",
            "methods": [
              "__init__",
              "get_state",
              "transition",
              "suspend",
              "resume",
              "terminate",
              "archive"
            ],
            "line": 53
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.tenant_lifecycle_enums",
            "names": [
              "TenantLifecycleStatus",
              "VALID_TRANSITIONS",
              "normalize_status",
              "is_valid_transition",
              "allows_sdk_execution",
              "allows_writes",
              "allows_reads",
              "allows_new_api_keys",
              "allows_token_refresh",
              "is_terminal"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.lifecycle_dtos",
            "names": [
              "LifecycleActorContext",
              "LifecycleTransitionResult",
              "LifecycleStateSnapshot"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": [
          "TenantLifecycleEngine",
          "get_tenant_lifecycle_engine"
        ]
      }
    ],
    "l5_schemas": [
      {
        "file_name": "crm_validator_types.py",
        "file_path": "backend/app/hoc/cus/account/L5_schemas/crm_validator_types.py",
        "layer": "L5_schemas",
        "domain": "account",
        "lines": 145,
        "module_docstring": "CRM Validator Types (L5 Schemas)\n\nSchema-only types for the CRM validator and its consumers (e.g., policies\neligibility). These types are intentionally separated from L5 engine logic\nto avoid cross-domain engine imports.",
        "functions": [],
        "classes": [
          {
            "name": "IssueType",
            "docstring": "Issue type classification.\n\nReference: VALIDATOR_LOGIC.md Issue Type Classification",
            "methods": [],
            "line": 27
          },
          {
            "name": "Severity",
            "docstring": "Issue severity classification.\n\nReference: VALIDATOR_LOGIC.md Severity Classification",
            "methods": [],
            "line": 41
          },
          {
            "name": "RecommendedAction",
            "docstring": "Recommended action from validator.\n\nReference: VALIDATOR_LOGIC.md Recommended Action Logic",
            "methods": [],
            "line": 54
          },
          {
            "name": "IssueSource",
            "docstring": "Issue source for confidence weighting.",
            "methods": [],
            "line": 67
          },
          {
            "name": "ValidatorInput",
            "docstring": "Input to the validator.\n\nReference: VALIDATOR_LOGIC.md Validator Input",
            "methods": [],
            "line": 78
          },
          {
            "name": "ValidatorVerdict",
            "docstring": "Output from the validator.\n\nReference: VALIDATOR_LOGIC.md Validator Output (Verdict)",
            "methods": [],
            "line": 95
          },
          {
            "name": "ValidatorErrorType",
            "docstring": "Error types for validator failures.",
            "methods": [],
            "line": 113
          },
          {
            "name": "ValidatorError",
            "docstring": "Error from validator with fallback verdict.\n\nReference: VALIDATOR_LOGIC.md Error Handling",
            "methods": [],
            "line": 123
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 17
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [],
        "all_exports": [
          "IssueType",
          "Severity",
          "RecommendedAction",
          "IssueSource",
          "ValidatorInput",
          "ValidatorVerdict",
          "ValidatorErrorType",
          "ValidatorError"
        ]
      },
      {
        "file_name": "lifecycle_dtos.py",
        "file_path": "backend/app/hoc/cus/account/L5_schemas/lifecycle_dtos.py",
        "layer": "L5_schemas",
        "domain": "account",
        "lines": 84,
        "module_docstring": "Lifecycle DTOs\n\nPure-stdlib dataclasses for lifecycle operations.\nNo DB dependencies \u2014 used by L5 engine and L4 handler.",
        "functions": [],
        "classes": [
          {
            "name": "LifecycleActorType",
            "docstring": "Who initiated the lifecycle action.",
            "methods": [],
            "line": 27
          },
          {
            "name": "LifecycleActorContext",
            "docstring": "Context about who is performing the lifecycle action.",
            "methods": [],
            "line": 35
          },
          {
            "name": "LifecycleTransitionResult",
            "docstring": "Result of a lifecycle transition attempt.\n\nReturned by L5 engine, consumed by L4 handler \u2192 L2 API.",
            "methods": [],
            "line": 44
          },
          {
            "name": "LifecycleStateSnapshot",
            "docstring": "Read-only snapshot of a tenant's lifecycle state.\n\nReturned by L5 engine for query operations.",
            "methods": [],
            "line": 60
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [],
        "all_exports": [
          "LifecycleActorType",
          "LifecycleActorContext",
          "LifecycleTransitionResult",
          "LifecycleStateSnapshot"
        ]
      },
      {
        "file_name": "onboarding_dtos.py",
        "file_path": "backend/app/hoc/cus/account/L5_schemas/onboarding_dtos.py",
        "layer": "L5_schemas",
        "domain": "account",
        "lines": 50,
        "module_docstring": "Onboarding DTOs (L5 Schema)\n\nPure data transfer objects for onboarding state transitions.\nNo DB or ORM imports.",
        "functions": [],
        "classes": [
          {
            "name": "OnboardingTransitionResult",
            "docstring": "Result of an onboarding state transition attempt.",
            "methods": [],
            "line": 25
          },
          {
            "name": "OnboardingStateSnapshot",
            "docstring": "Current onboarding state for a tenant.",
            "methods": [],
            "line": 38
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 21
          }
        ],
        "constants": [],
        "all_exports": [
          "OnboardingTransitionResult",
          "OnboardingStateSnapshot"
        ]
      },
      {
        "file_name": "onboarding_state.py",
        "file_path": "backend/app/hoc/cus/account/L5_schemas/onboarding_state.py",
        "layer": "L5_schemas",
        "domain": "account",
        "lines": 108,
        "module_docstring": "Onboarding State Machine \u2014 Canonical (HOC)\n\nPIN-399: Linear, monotonic onboarding state machine.\n\nStates:\n    CREATED \u2192 IDENTITY_VERIFIED \u2192 API_KEY_CREATED \u2192 SDK_CONNECTED \u2192 COMPLETE\n\nDesign Invariants (from ONBOARDING_STATE_MACHINE_V1.md):\n- ONBOARD-001: Onboarding state is the sole authority for bootstrap permissions\n- ONBOARD-002: Roles and plans do not apply before COMPLETE\n- ONBOARD-003: Founders and customers follow identical state transitions\n- ONBOARD-004: No endpoint may infer onboarding progress\n- ONBOARD-005: API keys are onboarding artifacts, not permissions\n\nThis module is the single source of truth for onboarding states in HOC.",
        "functions": [
          {
            "name": "is_at_or_past",
            "signature": "(current: int, target: int) -> bool",
            "docstring": null,
            "is_async": false,
            "line": 67
          },
          {
            "name": "is_complete",
            "signature": "(state: int) -> bool",
            "docstring": null,
            "is_async": false,
            "line": 71
          }
        ],
        "classes": [
          {
            "name": "OnboardingState",
            "docstring": "Monotonic onboarding state machine (forward-only).",
            "methods": [
              "from_string",
              "default"
            ],
            "line": 37
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "enum",
            "names": [
              "IntEnum"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [
          {
            "name": "STATE_TRANSITIONS",
            "line": 76
          }
        ],
        "all_exports": [
          "OnboardingState",
          "OnboardingStatus",
          "ONBOARDING_STATUS_NAMES",
          "STATE_TRANSITIONS",
          "is_at_or_past",
          "is_complete"
        ]
      },
      {
        "file_name": "plan_quotas.py",
        "file_path": "backend/app/hoc/cus/account/L5_schemas/plan_quotas.py",
        "layer": "L5_schemas",
        "domain": "account",
        "lines": 46,
        "module_docstring": "Plan quota constants mirror.\n\nMirrors PLAN_QUOTAS from app.models.tenant so that L5 engines\nnever need a runtime import of app.models for business-logic constants.\nValues MUST stay in sync with the L7 original.\n\nCanonical source: app/models/tenant.py",
        "functions": [],
        "classes": [],
        "imports": [],
        "constants": [
          {
            "name": "PLAN_QUOTAS",
            "line": 24
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "result_types.py",
        "file_path": "backend/app/hoc/cus/account/L5_schemas/result_types.py",
        "layer": "L5_schemas",
        "domain": "account",
        "lines": 25,
        "module_docstring": "Account Result Types (L5 Schemas)\n\nShared data types for account domain results.\nExtracted from accounts_facade.py so L2 can import without pulling in L5 engine code.",
        "functions": [],
        "classes": [
          {
            "name": "AccountsErrorResult",
            "docstring": "Error result for accounts operations.",
            "methods": [],
            "line": 20
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 16
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "tenant_lifecycle_enums.py",
        "file_path": "backend/app/hoc/cus/account/L5_schemas/tenant_lifecycle_enums.py",
        "layer": "L5_schemas",
        "domain": "account",
        "lines": 151,
        "module_docstring": "Tenant Lifecycle Status Enums\n\nPure-stdlib enum mirroring TenantLifecycleState (IntEnum) but using the\nVARCHAR values stored in `Tenant.status`. Maps legacy \"churned\" \u2192 \"terminated\".\n\nDESIGN INVARIANTS (LOCKED):\n- OFFBOARD-001: Lifecycle transitions are monotonic\n- OFFBOARD-002: TERMINATED is irreversible\n- OFFBOARD-003: ARCHIVED is unreachable from ACTIVE",
        "functions": [
          {
            "name": "normalize_status",
            "signature": "(raw: Optional[str]) -> TenantLifecycleStatus",
            "docstring": "Normalize a raw DB status string to TenantLifecycleStatus.\n\nHandles legacy values (e.g. \"churned\" \u2192 TERMINATED) and defaults\nto ACTIVE for None/unknown values.",
            "is_async": false,
            "line": 68
          },
          {
            "name": "is_valid_transition",
            "signature": "(from_status: TenantLifecycleStatus, to_status: TenantLifecycleStatus) -> bool",
            "docstring": "Check if a lifecycle transition is valid.\n\nEnforces:\n- OFFBOARD-001: Monotonic transitions (except SUSPENDED -> ACTIVE)\n- OFFBOARD-002: TERMINATED is irreversible\n- OFFBOARD-003: ARCHIVED is unreachable from ACTIVE",
            "is_async": false,
            "line": 85
          },
          {
            "name": "allows_sdk_execution",
            "signature": "(status: TenantLifecycleStatus) -> bool",
            "docstring": "Check if SDK execution is allowed in this status.",
            "is_async": false,
            "line": 100
          },
          {
            "name": "allows_writes",
            "signature": "(status: TenantLifecycleStatus) -> bool",
            "docstring": "Check if data writes are allowed in this status.",
            "is_async": false,
            "line": 105
          },
          {
            "name": "allows_reads",
            "signature": "(status: TenantLifecycleStatus) -> bool",
            "docstring": "Check if data reads are allowed in this status.",
            "is_async": false,
            "line": 110
          },
          {
            "name": "allows_new_api_keys",
            "signature": "(status: TenantLifecycleStatus) -> bool",
            "docstring": "Check if new API keys can be created in this status.",
            "is_async": false,
            "line": 118
          },
          {
            "name": "allows_token_refresh",
            "signature": "(status: TenantLifecycleStatus) -> bool",
            "docstring": "Check if auth token refresh is allowed in this status.",
            "is_async": false,
            "line": 123
          },
          {
            "name": "is_terminal",
            "signature": "(status: TenantLifecycleStatus) -> bool",
            "docstring": "Check if this is a terminal status (no return to ACTIVE).",
            "is_async": false,
            "line": 131
          }
        ],
        "classes": [
          {
            "name": "TenantLifecycleStatus",
            "docstring": "Tenant lifecycle status values (matches DB VARCHAR).\n\nThese are the canonical string values stored in Tenant.status.",
            "methods": [],
            "line": 30
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": [
          "TenantLifecycleStatus",
          "LEGACY_STATUS_MAP",
          "VALID_TRANSITIONS",
          "normalize_status",
          "is_valid_transition",
          "allows_sdk_execution",
          "allows_writes",
          "allows_reads",
          "allows_new_api_keys",
          "allows_token_refresh",
          "is_terminal"
        ]
      },
      {
        "file_name": "tenant_lifecycle_state.py",
        "file_path": "backend/app/hoc/cus/account/L5_schemas/tenant_lifecycle_state.py",
        "layer": "L5_schemas",
        "domain": "account",
        "lines": 130,
        "module_docstring": "Tenant Lifecycle State (IntEnum)\n\nCanonical location for the Phase-9 tenant lifecycle *state machine API surface*.\n\nSingle source of truth:\n- Transition validity is derived from `tenant_lifecycle_enums.VALID_TRANSITIONS`\n  (the canonical status/DB-value representation). This module provides an\n  IntEnum view without duplicating transition rules.",
        "functions": [
          {
            "name": "_to_status",
            "signature": "(state: TenantLifecycleState) -> TenantLifecycleStatus",
            "docstring": null,
            "is_async": false,
            "line": 74
          },
          {
            "name": "_to_state",
            "signature": "(status: TenantLifecycleStatus) -> TenantLifecycleState",
            "docstring": null,
            "is_async": false,
            "line": 78
          },
          {
            "name": "is_valid_transition",
            "signature": "(from_state: TenantLifecycleState, to_state: TenantLifecycleState) -> bool",
            "docstring": null,
            "is_async": false,
            "line": 88
          },
          {
            "name": "get_valid_transitions",
            "signature": "(from_state: TenantLifecycleState) -> Set[TenantLifecycleState]",
            "docstring": null,
            "is_async": false,
            "line": 92
          },
          {
            "name": "get_action_for_transition",
            "signature": "(from_state: TenantLifecycleState, to_state: TenantLifecycleState) -> str | None",
            "docstring": null,
            "is_async": false,
            "line": 114
          }
        ],
        "classes": [
          {
            "name": "TenantLifecycleState",
            "docstring": null,
            "methods": [
              "allows_sdk_execution",
              "allows_writes",
              "allows_reads",
              "allows_new_api_keys",
              "allows_token_refresh",
              "is_terminal",
              "is_reversible"
            ],
            "line": 37
          },
          {
            "name": "LifecycleAction",
            "docstring": null,
            "methods": [],
            "line": 96
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "enum",
            "names": [
              "IntEnum"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "typing",
            "names": [
              "Set",
              "Tuple"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.tenant_lifecycle_enums",
            "names": [
              "TenantLifecycleStatus",
              "VALID_TRANSITIONS",
              "is_valid_transition"
            ],
            "is_relative": false,
            "line": 30
          }
        ],
        "constants": [
          {
            "name": "_STATUS_TO_STATE",
            "line": 65
          },
          {
            "name": "_STATE_TO_STATUS",
            "line": 71
          }
        ],
        "all_exports": [
          "TenantLifecycleState",
          "LifecycleAction",
          "VALID_TRANSITIONS",
          "ACTION_TRANSITIONS",
          "is_valid_transition",
          "get_valid_transitions",
          "get_action_for_transition"
        ]
      }
    ],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "accounts_facade_driver.py",
        "file_path": "backend/app/hoc/cus/account/L6_drivers/accounts_facade_driver.py",
        "layer": "L6_drivers",
        "domain": "account",
        "lines": 954,
        "module_docstring": "Accounts Facade Driver (L6)\n\nPure data access layer for accounts domain operations.\n\nProvides:\n- Tenant/Project queries\n- User queries\n- Membership queries\n- Profile queries\n- Billing queries\n- Support ticket queries\n- Invitation queries\n\nAll methods return snapshot dataclasses, not ORM models.\nBusiness logic belongs in the facade (L4), not here.",
        "functions": [
          {
            "name": "get_accounts_facade_driver",
            "signature": "() -> AccountsFacadeDriver",
            "docstring": "Get the singleton AccountsFacadeDriver instance.",
            "is_async": false,
            "line": 932
          }
        ],
        "classes": [
          {
            "name": "TenantSnapshot",
            "docstring": "Tenant data from DB for list view.",
            "methods": [],
            "line": 72
          },
          {
            "name": "TenantDetailSnapshot",
            "docstring": "Detailed tenant data from DB.",
            "methods": [],
            "line": 84
          },
          {
            "name": "UserSnapshot",
            "docstring": "User data from DB for list view.",
            "methods": [],
            "line": 106
          },
          {
            "name": "UserDetailSnapshot",
            "docstring": "Detailed user data from DB.",
            "methods": [],
            "line": 118
          },
          {
            "name": "MembershipSnapshot",
            "docstring": "Tenant membership data from DB.",
            "methods": [],
            "line": 139
          },
          {
            "name": "ProfileSnapshot",
            "docstring": "User profile data from DB.",
            "methods": [],
            "line": 149
          },
          {
            "name": "SubscriptionSnapshot",
            "docstring": "Subscription data from DB.",
            "methods": [],
            "line": 163
          },
          {
            "name": "InvitationSnapshot",
            "docstring": "Invitation data from DB.",
            "methods": [],
            "line": 173
          },
          {
            "name": "TicketSnapshot",
            "docstring": "Support ticket data from DB.",
            "methods": [],
            "line": 187
          },
          {
            "name": "AccountsFacadeDriver",
            "docstring": "L6 Driver for accounts domain data access.\n\nAll methods are pure data access - no business logic.\nReturns snapshot dataclasses, not ORM models.",
            "methods": [
              "fetch_tenant",
              "fetch_tenants",
              "count_tenants",
              "fetch_tenant_detail",
              "fetch_users",
              "count_users",
              "fetch_user_detail",
              "fetch_tenant_memberships",
              "fetch_membership",
              "fetch_membership_with_user",
              "update_membership_role",
              "delete_membership",
              "fetch_profile",
              "fetch_user_by_id",
              "update_user_profile",
              "fetch_subscription",
              "insert_support_ticket",
              "fetch_support_tickets",
              "fetch_invitation_by_email",
              "insert_invitation",
              "fetch_invitations",
              "fetch_invitation_by_id_and_token",
              "fetch_user_by_email",
              "insert_user",
              "insert_membership",
              "update_invitation_accepted",
              "update_invitation_expired"
            ],
            "line": 206
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.models.tenant",
            "names": [
              "Invitation",
              "Subscription",
              "SupportTicket",
              "Tenant",
              "TenantMembership",
              "User",
              "generate_uuid",
              "utc_now"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": [
          "AccountsFacadeDriver",
          "get_accounts_facade_driver",
          "TenantSnapshot",
          "TenantDetailSnapshot",
          "UserSnapshot",
          "UserDetailSnapshot",
          "MembershipSnapshot",
          "ProfileSnapshot",
          "SubscriptionSnapshot",
          "InvitationSnapshot",
          "TicketSnapshot"
        ]
      },
      {
        "file_name": "memory_pins_driver.py",
        "file_path": "backend/app/hoc/cus/account/L6_drivers/memory_pins_driver.py",
        "layer": "L6_drivers",
        "domain": "account",
        "lines": 294,
        "module_docstring": "Memory Pins Driver (L6)\n\nPure data access layer for memory pin operations.\nDriver instances are session-bound and return raw data.\nNo business logic \u2014 validation, feature flags, and metrics belong in L5.",
        "functions": [
          {
            "name": "get_memory_pins_driver",
            "signature": "(session: AsyncSession) -> MemoryPinsDriver",
            "docstring": "Create a session-bound MemoryPinsDriver instance.",
            "is_async": false,
            "line": 292
          }
        ],
        "classes": [
          {
            "name": "MemoryPinRow",
            "docstring": "Snapshot of a memory pin row.",
            "methods": [],
            "line": 45
          },
          {
            "name": "MemoryPinsDriver",
            "docstring": "Pure data access for system.memory_pins table.",
            "methods": [
              "__init__",
              "upsert_pin",
              "get_pin",
              "list_pins",
              "delete_pin",
              "cleanup_expired",
              "write_audit",
              "_row_to_snapshot"
            ],
            "line": 59
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "onboarding_driver.py",
        "file_path": "backend/app/hoc/cus/account/L6_drivers/onboarding_driver.py",
        "layer": "L6_drivers",
        "domain": "account",
        "lines": 88,
        "module_docstring": "Onboarding Driver (L6)\n\nPure data access layer for tenant onboarding state operations.\nFollows tenant_lifecycle_driver.py pattern.\n\nAll methods are pure data access \u2014 no business logic.\nNO COMMIT \u2014 L4 coordinator owns transaction boundary.",
        "functions": [
          {
            "name": "get_onboarding_driver",
            "signature": "(session: Session) -> OnboardingDriver",
            "docstring": "Get an OnboardingDriver instance.",
            "is_async": false,
            "line": 80
          }
        ],
        "classes": [
          {
            "name": "OnboardingDriver",
            "docstring": "L6 Driver for tenant onboarding state operations.\n\nAll methods are pure data access \u2014 no business logic.",
            "methods": [
              "__init__",
              "fetch_onboarding_state",
              "write_onboarding_state"
            ],
            "line": 37
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": [
          "OnboardingDriver",
          "get_onboarding_driver"
        ]
      },
      {
        "file_name": "tenant_driver.py",
        "file_path": "backend/app/hoc/cus/account/L6_drivers/tenant_driver.py",
        "layer": "L6_drivers",
        "domain": "account",
        "lines": 573,
        "module_docstring": "Tenant Driver (L6)\n\nPure data access layer for tenant operations.\n\nProvides:\n- Tenant CRUD\n- Membership CRUD\n- API key CRUD\n- Usage record CRUD\n- Run CRUD\n- Audit logging\n\nAll methods are pure data access - no business logic.\nReturns snapshot dataclasses or ORM models for mutations.\nBusiness logic belongs in the engine (L4).",
        "functions": [
          {
            "name": "get_tenant_driver",
            "signature": "(session: Session) -> TenantDriver",
            "docstring": "Get a TenantDriver instance.",
            "is_async": false,
            "line": 559
          }
        ],
        "classes": [
          {
            "name": "TenantCoreSnapshot",
            "docstring": "Core tenant data for engine operations.",
            "methods": [],
            "line": 71
          },
          {
            "name": "RunCountSnapshot",
            "docstring": "Running count for quota checks.",
            "methods": [],
            "line": 92
          },
          {
            "name": "APIKeySnapshot",
            "docstring": "API key data snapshot.",
            "methods": [],
            "line": 98
          },
          {
            "name": "UsageRecordSnapshot",
            "docstring": "Usage record data.",
            "methods": [],
            "line": 115
          },
          {
            "name": "RunSnapshot",
            "docstring": "Worker run snapshot.",
            "methods": [],
            "line": 127
          },
          {
            "name": "TenantDriver",
            "docstring": "L6 Driver for tenant data access.\n\nAll methods are pure data access - no business logic.\nReturns snapshots or ORM models for mutations.",
            "methods": [
              "__init__",
              "fetch_tenant_by_id",
              "fetch_tenant_by_slug",
              "fetch_tenant_snapshot",
              "insert_tenant",
              "update_tenant_plan",
              "update_tenant_status",
              "update_tenant_usage",
              "increment_tenant_usage",
              "insert_membership",
              "count_active_api_keys",
              "insert_api_key",
              "fetch_api_keys",
              "fetch_api_key_by_id",
              "update_api_key_revoked",
              "count_running_runs",
              "insert_run",
              "fetch_run_by_id",
              "update_run_completed",
              "fetch_runs",
              "insert_usage_record",
              "fetch_usage_records",
              "insert_audit_log"
            ],
            "line": 147
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional",
              "cast"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.models.tenant",
            "names": [
              "APIKey",
              "AuditLog",
              "Tenant",
              "TenantMembership",
              "UsageRecord",
              "User",
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": [
          "TenantDriver",
          "get_tenant_driver",
          "TenantCoreSnapshot",
          "RunCountSnapshot",
          "APIKeySnapshot",
          "UsageRecordSnapshot",
          "RunSnapshot"
        ]
      },
      {
        "file_name": "tenant_lifecycle_driver.py",
        "file_path": "backend/app/hoc/cus/account/L6_drivers/tenant_lifecycle_driver.py",
        "layer": "L6_drivers",
        "domain": "account",
        "lines": 98,
        "module_docstring": "Tenant Lifecycle Driver (L6)\n\nPure data access layer for tenant lifecycle status operations.\nFollows tenant_driver.py pattern exactly.\n\nAll methods are pure data access \u2014 no business logic.\nNO COMMIT \u2014 L4 coordinator owns transaction boundary.",
        "functions": [
          {
            "name": "get_tenant_lifecycle_driver",
            "signature": "(session: Session) -> TenantLifecycleDriver",
            "docstring": "Get a TenantLifecycleDriver instance.",
            "is_async": false,
            "line": 90
          }
        ],
        "classes": [
          {
            "name": "TenantLifecycleDriver",
            "docstring": "L6 Driver for tenant lifecycle status operations.\n\nAll methods are pure data access \u2014 no business logic.",
            "methods": [
              "__init__",
              "fetch_tenant_status",
              "update_lifecycle_status"
            ],
            "line": 43
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.models.tenant",
            "names": [
              "Tenant"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": [
          "TenantLifecycleDriver",
          "get_tenant_lifecycle_driver"
        ]
      },
      {
        "file_name": "user_write_driver.py",
        "file_path": "backend/app/hoc/cus/account/L6_drivers/user_write_driver.py",
        "layer": "L6_drivers",
        "domain": "account",
        "lines": 137,
        "module_docstring": "User Write Driver (L6)\n\nPure database write operations for User management.\n\nL4 (UserWriteService) \u2192 L6 (this driver)\n\nResponsibilities:\n- Create user records\n- Update user login timestamps\n- Convert user to dict (DTO transformation)\n- NO business logic (L4 responsibility)\n\nReference: PIN-250, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_user_write_driver",
            "signature": "(session: Session) -> UserWriteDriver",
            "docstring": "Factory function to get UserWriteDriver instance.",
            "is_async": false,
            "line": 129
          }
        ],
        "classes": [
          {
            "name": "UserWriteDriver",
            "docstring": "L6 driver for user write operations.\n\nPure database access - no business logic.",
            "methods": [
              "__init__",
              "create_user",
              "update_user_login",
              "user_to_dict"
            ],
            "line": 51
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.models.tenant",
            "names": [
              "User"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": [
          "UserWriteDriver",
          "get_user_write_driver"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 22,
    "violation_count": 0,
    "gap_count": 1
  },
  "agent": {
    "l2_1_facade": null,
    "l2_apis": [],
    "l4_spine": [],
    "l5_engines": [],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "discovery_stats_driver.py",
        "file_path": "backend/app/hoc/cus/agent/L6_drivers/discovery_stats_driver.py",
        "layer": "L6_drivers",
        "domain": "agent",
        "lines": 119,
        "module_docstring": "Discovery Stats Driver (L6)\n\nPure data access layer for discovery statistics operations.\nAll methods accept a Session and return raw data.\nNo business logic \u2014 that belongs in L5.",
        "functions": [
          {
            "name": "get_discovery_stats_driver",
            "signature": "() -> DiscoveryStatsDriver",
            "docstring": "Get or create the singleton DiscoveryStatsDriver.",
            "is_async": false,
            "line": 114
          }
        ],
        "classes": [
          {
            "name": "DiscoveryStatsDriver",
            "docstring": "Pure data access for discovery_ledger statistics.",
            "methods": [
              "get_stats",
              "_get_by_artifact",
              "_get_by_signal_type",
              "_get_by_status"
            ],
            "line": 41
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "platform_driver.py",
        "file_path": "backend/app/hoc/cus/agent/L6_drivers/platform_driver.py",
        "layer": "L6_drivers",
        "domain": "agent",
        "lines": 196,
        "module_docstring": "Platform Driver (L6)\n\nPure data access layer for platform health and capability queries.\nNo business logic - only query construction and data retrieval.\n\nOperations:\n    - get_blca_status: Query BLCA governance status\n    - get_lifecycle_coherence: Query lifecycle qualifier coherence\n    - get_blocked_scopes: Query all blocked scopes\n    - get_capability_signals: Query signals for a specific capability\n    - count_blocked_for_capability: Count blocking signals for a capability\n\nAll methods use raw SQL via sqlalchemy text() for performance.",
        "functions": [
          {
            "name": "get_platform_driver",
            "signature": "(session: Optional[Session] = None) -> PlatformDriver",
            "docstring": "Get PlatformDriver instance.\n\nArgs:\n    session: Optional SQLModel session. If not provided, creates one internally.\n\nReturns:\n    PlatformDriver instance.",
            "is_async": false,
            "line": 180
          }
        ],
        "classes": [
          {
            "name": "PlatformDriver",
            "docstring": "L6 driver for platform health queries.\n\nPure data access - no business logic.\nUses raw SQL for lightweight, efficient queries.",
            "methods": [
              "__init__",
              "_get_session",
              "get_blca_status",
              "get_lifecycle_coherence",
              "get_blocked_scopes",
              "get_capability_signals",
              "count_blocked_for_capability"
            ],
            "line": 38
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set",
              "Tuple"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.db",
            "names": [
              "get_session"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": [
          "PlatformDriver",
          "get_platform_driver"
        ]
      },
      {
        "file_name": "routing_driver.py",
        "file_path": "backend/app/hoc/cus/agent/L6_drivers/routing_driver.py",
        "layer": "L6_drivers",
        "domain": "agent",
        "lines": 186,
        "module_docstring": "Routing Driver (L6)\n\nPure data access layer for routing decisions and agent strategy.\nNo business logic - only query construction and data retrieval.\n\nOperations:\n    - get_routing_stats: Aggregate stats from routing.routing_decisions\n    - get_routing_decision: Single routing decision by request_id\n    - update_agent_sba: Update agent SBA JSONB in agents.agent_registry",
        "functions": [
          {
            "name": "get_routing_driver",
            "signature": "(session: AsyncSession) -> RoutingDriver",
            "docstring": "Get RoutingDriver instance.\n\nArgs:\n    session: AsyncSession for database operations\n\nReturns:\n    RoutingDriver instance",
            "is_async": false,
            "line": 170
          }
        ],
        "classes": [
          {
            "name": "RoutingDriver",
            "docstring": "L6 driver for routing and agent strategy DB operations.\n\nPure data access - no business logic.\nUses raw SQL for performance.",
            "methods": [
              "__init__",
              "get_routing_stats",
              "get_routing_decision",
              "update_agent_sba"
            ],
            "line": 33
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 30
          }
        ],
        "constants": [],
        "all_exports": [
          "RoutingDriver",
          "get_routing_driver"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 3,
    "violation_count": 0,
    "gap_count": 2
  },
  "api_keys": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/api_keys.py",
    "l2_apis": [
      {
        "file_name": "auth_helpers.py",
        "file_path": "backend/app/hoc/api/cus/api_keys/auth_helpers.py",
        "layer": "L2_api",
        "domain": "api_keys",
        "lines": 78,
        "module_docstring": "API Auth Helpers - Console Authentication\n\nPIN-148: M29 Auth Boundary Verification\n\nProvides API key verification for Guard and Ops console endpoints.\nThese endpoints previously had frontend-only auth which could be bypassed.\n\nUsage:\n    from app.api.auth_helpers import verify_console_api_key\n\n    router = APIRouter(dependencies=[Depends(verify_console_api_key)])\n\n    # Or per-endpoint:\n    @router.get(\"/status\")\n    async def get_status(_: str = Depends(verify_console_api_key)):\n        ...",
        "functions": [
          {
            "name": "verify_console_api_key",
            "signature": "(x_api_key: Optional[str] = Header(None, alias='X-API-Key')) -> str",
            "docstring": "Verify API key for console endpoints.\n\nAccepts X-API-Key header (matching frontend client.ts).\nReturns the validated API key.\n\nRaises:\n    HTTPException 401: If API key is missing or invalid\n    HTTPException 500: If AOS_API_KEY not configured",
            "is_async": true,
            "line": 41
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "Header",
              "HTTPException",
              "status"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [
          {
            "name": "AOS_API_KEY",
            "line": 38
          }
        ],
        "all_exports": [
          "verify_console_api_key"
        ]
      },
      {
        "file_name": "embedding.py",
        "file_path": "backend/app/hoc/api/cus/api_keys/embedding.py",
        "layer": "L2_api",
        "domain": "api_keys",
        "lines": 513,
        "module_docstring": "API endpoints for embedding operations and quota management.\nPIN-047: P2 - Quota Status API Endpoint\nPIN-082: IAEC v3.0 - Instruction-Aware Embedding Composer",
        "functions": [
          {
            "name": "get_embedding_quota",
            "signature": "(_api_key: str = Depends(verify_api_key)) -> EmbeddingQuotaResponse",
            "docstring": "Get current embedding quota status.\n\nReturns:\n    - daily_quota: Maximum embeddings per day (0 = unlimited)\n    - current_count: Number of embeddings used today\n    - remaining: Embeddings remaining (-1 if unlimited)\n    - exceeded: Whether quota has been exceeded\n    - reset_at: When quota resets (midnight UTC)\n    - vector_search_enabled: Whether vector search is active\n    - fallback_enabled: Whether keyword fallback is enabled",
            "is_async": true,
            "line": 65
          },
          {
            "name": "get_embedding_config",
            "signature": "(_api_key: str = Depends(verify_api_key)) -> EmbeddingConfigResponse",
            "docstring": "Get embedding configuration.\n\nReturns current embedding provider settings including backup provider.",
            "is_async": true,
            "line": 102
          },
          {
            "name": "embedding_health",
            "signature": "() -> dict",
            "docstring": "Quick health check for embedding subsystem.\n\nNo authentication required - used for monitoring.",
            "is_async": true,
            "line": 134
          },
          {
            "name": "embedding_cache_stats",
            "signature": "(_api_key: str = Depends(verify_api_key)) -> dict",
            "docstring": "Get embedding cache statistics.\n\nReturns cache configuration and entry count.",
            "is_async": true,
            "line": 151
          },
          {
            "name": "clear_embedding_cache",
            "signature": "(_api_key: str = Depends(verify_api_key)) -> dict",
            "docstring": "Clear all embedding cache entries.\n\nReturns number of entries cleared.",
            "is_async": true,
            "line": 166
          },
          {
            "name": "compose_embedding",
            "signature": "(request: IAECComposeRequest, _api_key: str = Depends(verify_api_key)) -> IAECComposeResponse",
            "docstring": "Compose an instruction-aware embedding using IAEC v3.0.\n\nIAEC creates structured composite embeddings with 4 slots:\n- Instruction: what kind of task (summarize, extract, analyze, etc.)\n- Query: what the user wants\n- Context: what the system knows\n- Temporal + Policy: version/governance metadata (v3.0)\n\nModes:\n- \"segmented\": Best for routing - splits vector into regions\n- \"weighted\": Best for search - uses learned weights per instruction\n- \"hybrid\": Returns weighted, stores segmented metadata\n\nv3.0 Features:\n- Reversible decomposition (weighted mode)\n- Temporal signature for drift control\n- Deep embedding-based mismatch detection\n- Policy slot encoding for governance\n- Slot integrity verification\n\nSupported instructions: summarize, extract, analyze, rewrite, qa,\ncompare, classify, generate, route, default",
            "is_async": true,
            "line": 298
          },
          {
            "name": "decompose_embedding",
            "signature": "(request: IAECDecomposeRequest, _api_key: str = Depends(verify_api_key)) -> IAECDecomposeResponse",
            "docstring": "Decompose an IAEC embedding back into its constituent slots (v3.0).\n\nFor segmented mode embeddings: Direct extraction from dimensional regions\nFor raw vectors: Assumes segmented layout\n\nNote: For full reversibility of weighted mode embeddings, the original\nCompositeEmbedding with slot_basis must be preserved.\n\nReturns all 5 slots:\n- instruction_slot: Task type encoding\n- query_slot: User intent encoding\n- context_slot: System context encoding\n- temporal_slot: Version/epoch signature (32 dims)\n- policy_slot: Governance encoding (32 dims)",
            "is_async": true,
            "line": 393
          },
          {
            "name": "get_iaec_instructions",
            "signature": "(_api_key: str = Depends(verify_api_key)) -> dict",
            "docstring": "Get available IAEC instruction types and their weights.",
            "is_async": true,
            "line": 435
          },
          {
            "name": "get_iaec_segment_info",
            "signature": "(_api_key: str = Depends(verify_api_key)) -> dict",
            "docstring": "Get IAEC v3.0 segmentation configuration.\n\nReturns slot layout, dimensions, and temporal signature info.",
            "is_async": true,
            "line": 460
          },
          {
            "name": "check_mismatch",
            "signature": "(instruction: str, query: str, _api_key: str = Depends(verify_api_key)) -> dict",
            "docstring": "Check instruction-query semantic compatibility (v3.1).\n\nUses both keyword-based and embedding-based detection.\n\nv3.1: Includes corrective_action with confidence for M18/M19 governance.\n\nReturns:\n- score: Keyword-based mismatch score (0-1)\n- deep_score: Embedding-based mismatch score (0-1)\n- suggested_instruction: Better instruction if mismatch detected\n- detection_method: \"keyword\", \"embedding\", or \"none\"\n- message: Human-readable guidance\n- corrective_action: Prescriptive action with confidence (v3.1)",
            "is_async": true,
            "line": 475
          }
        ],
        "classes": [
          {
            "name": "EmbeddingQuotaResponse",
            "docstring": "Response schema for embedding quota status.",
            "methods": [],
            "line": 38
          },
          {
            "name": "EmbeddingConfigResponse",
            "docstring": "Response schema for embedding configuration.",
            "methods": [],
            "line": 50
          },
          {
            "name": "IAECComposeRequest",
            "docstring": "Request schema for IAEC composition (v3.0).",
            "methods": [],
            "line": 186
          },
          {
            "name": "TemporalSignatureResponse",
            "docstring": "Temporal signature for drift control.",
            "methods": [],
            "line": 199
          },
          {
            "name": "PolicyEncodingResponse",
            "docstring": "Policy slot encoding.",
            "methods": [],
            "line": 209
          },
          {
            "name": "IAECComposeResponse",
            "docstring": "Response schema for IAEC composition (v3.2).",
            "methods": [],
            "line": 217
          },
          {
            "name": "IAECDecomposeRequest",
            "docstring": "Request schema for IAEC decomposition.",
            "methods": [],
            "line": 253
          },
          {
            "name": "IAECDecomposeResponse",
            "docstring": "Response schema for IAEC decomposition (v3.0).",
            "methods": [],
            "line": 260
          },
          {
            "name": "IAECVerifyRequest",
            "docstring": "Request for integrity verification.",
            "methods": [],
            "line": 274
          },
          {
            "name": "IAECVerifyResponse",
            "docstring": "Response for integrity verification.",
            "methods": [],
            "line": 285
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "app.auth",
            "names": [
              "verify_api_key"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "app.memory.embedding_metrics",
            "names": [
              "EMBEDDING_DAILY_QUOTA",
              "VECTOR_SEARCH_ENABLED",
              "VECTOR_SEARCH_FALLBACK",
              "get_embedding_quota_status"
            ],
            "is_relative": false,
            "line": 28
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l4_spine": [],
    "l5_engines": [
      {
        "file_name": "api_keys_facade.py",
        "file_path": "backend/app/hoc/cus/api_keys/L5_engines/api_keys_facade.py",
        "layer": "L5_engines",
        "domain": "api_keys",
        "lines": 237,
        "module_docstring": "API Keys Domain Engine (L5)\n\nUnified facade for API key management operations.\n\nProvides:\n- List API keys (O2)\n- Get API key detail (O3)\n\nAPI keys are used for:\n- SDK authentication\n- Programmatic access to AOS APIs\n- RBAC-controlled permissions\n\nAll DB access is delegated to APIKeysFacadeDriver (L6).\nThis facade only contains business logic composition.",
        "functions": [
          {
            "name": "get_api_keys_facade",
            "signature": "() -> APIKeysFacade",
            "docstring": "Get the singleton APIKeysFacade instance.",
            "is_async": false,
            "line": 221
          }
        ],
        "classes": [
          {
            "name": "APIKeySummaryResult",
            "docstring": "API key summary for list view.",
            "methods": [],
            "line": 66
          },
          {
            "name": "APIKeysListResult",
            "docstring": "API keys list response.",
            "methods": [],
            "line": 80
          },
          {
            "name": "APIKeyDetailResult",
            "docstring": "API key detail response.",
            "methods": [],
            "line": 90
          },
          {
            "name": "APIKeysFacade",
            "docstring": "Unified facade for API key management.\n\nProvides:\n- List API keys (O2)\n- Get API key detail (O3)\n\nAll operations are tenant-scoped for isolation.\nSynthetic keys are excluded from customer view.\n\nAll DB access is delegated to APIKeysFacadeDriver (L6).",
            "methods": [
              "__init__",
              "list_api_keys",
              "get_api_key_detail"
            ],
            "line": 117
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.api_keys.L6_drivers.api_keys_facade_driver",
            "names": [
              "APIKeysFacadeDriver"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": [
          "APIKeysFacade",
          "get_api_keys_facade",
          "APIKeySummaryResult",
          "APIKeysListResult",
          "APIKeyDetailResult"
        ]
      },
      {
        "file_name": "keys_engine.py",
        "file_path": "backend/app/hoc/cus/api_keys/L5_engines/keys_engine.py",
        "layer": "L5_engines",
        "domain": "api_keys",
        "lines": 234,
        "module_docstring": "Keys Engine (L4 Domain Logic)\n\nThis engine provides business logic for API key operations.\nAll DB access is delegated to KeysDriver (L6).\n\nL3 (Adapter) \u2192 L4 (this engine) \u2192 L6 (Driver) \u2192 DB\n\nResponsibilities:\n- Validate key operations\n- Freeze/unfreeze key decisions\n- Delegate persistence to driver\n- No direct exposure to L2",
        "functions": [
          {
            "name": "get_keys_read_engine",
            "signature": "(session: Session) -> KeysReadEngine",
            "docstring": "Factory function to get KeysReadEngine instance.",
            "is_async": false,
            "line": 212
          },
          {
            "name": "get_keys_write_engine",
            "signature": "(session: Session) -> KeysWriteEngine",
            "docstring": "Factory function to get KeysWriteEngine instance.",
            "is_async": false,
            "line": 217
          }
        ],
        "classes": [
          {
            "name": "KeysReadEngine",
            "docstring": "L4 engine for API key read operations.\n\nProvides tenant-scoped, bounded reads for the Keys domain.\nAll DB access is delegated to KeysDriver.",
            "methods": [
              "__init__",
              "list_keys",
              "get_key",
              "get_key_usage_today"
            ],
            "line": 67
          },
          {
            "name": "KeysWriteEngine",
            "docstring": "L4 engine for API key write operations.\n\nProvides tenant-scoped mutations for the Keys domain.\nAll DB access is delegated to KeysDriver.",
            "methods": [
              "__init__",
              "freeze_key",
              "unfreeze_key"
            ],
            "line": 135
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.api_keys.L6_drivers.keys_driver",
            "names": [
              "KeysDriver",
              "KeySnapshot",
              "KeyUsageSnapshot",
              "get_keys_driver"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [],
        "all_exports": [
          "KeysReadEngine",
          "KeysWriteEngine",
          "get_keys_read_engine",
          "get_keys_write_engine",
          "KeySnapshot",
          "KeyUsageSnapshot"
        ]
      }
    ],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "api_keys_facade_driver.py",
        "file_path": "backend/app/hoc/cus/api_keys/L6_drivers/api_keys_facade_driver.py",
        "layer": "L6_drivers",
        "domain": "api_keys",
        "lines": 209,
        "module_docstring": "API Keys Facade Driver (L6 Data Access)\n\nThis driver contains all database queries for the API keys facade.\nIt returns snapshot dataclasses to the facade (L4) for business logic composition.\n\nARCHITECTURAL RULE:\n- This driver ONLY performs data access\n- NO business logic (no status decisions, no permission checks)\n- Returns raw query results as typed snapshots\n- The facade composes business results from these snapshots",
        "functions": [],
        "classes": [
          {
            "name": "APIKeySnapshot",
            "docstring": "Raw API key data from DB for list view.",
            "methods": [],
            "line": 55
          },
          {
            "name": "APIKeyDetailSnapshot",
            "docstring": "Detailed API key data from DB.",
            "methods": [],
            "line": 70
          },
          {
            "name": "APIKeysFacadeDriver",
            "docstring": "API Keys Facade Driver - Pure data access layer.\n\nAll methods execute DB queries and return snapshot dataclasses.\nNo business logic or status decisions.",
            "methods": [
              "fetch_api_keys",
              "count_api_keys",
              "fetch_api_key_by_id"
            ],
            "line": 94
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.models.tenant",
            "names": [
              "APIKey"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": [
          "APIKeysFacadeDriver",
          "APIKeySnapshot",
          "APIKeyDetailSnapshot"
        ]
      },
      {
        "file_name": "keys_driver.py",
        "file_path": "backend/app/hoc/cus/api_keys/L6_drivers/keys_driver.py",
        "layer": "L6_drivers",
        "domain": "api_keys",
        "lines": 297,
        "module_docstring": "Keys Driver (L6 Data Access)\n\nThis driver contains all database queries and mutations for the keys engine.\nIt returns snapshot dataclasses to the engine (L4) for business logic.\n\nARCHITECTURAL RULE:\n- This driver ONLY performs data access\n- NO business logic (no validation, no freeze decisions)\n- Returns raw query results as typed snapshots\n- Accepts pre-computed values from engine for mutations",
        "functions": [
          {
            "name": "get_keys_driver",
            "signature": "(session: Session) -> KeysDriver",
            "docstring": "Factory function to get KeysDriver instance.",
            "is_async": false,
            "line": 275
          }
        ],
        "classes": [
          {
            "name": "KeySnapshot",
            "docstring": "API key snapshot for engine operations.",
            "methods": [],
            "line": 57
          },
          {
            "name": "KeyUsageSnapshot",
            "docstring": "Key usage statistics from DB.",
            "methods": [],
            "line": 74
          },
          {
            "name": "KeysDriver",
            "docstring": "Keys Driver - Pure data access layer.\n\nAll methods execute DB queries/mutations and return snapshot dataclasses.\nNo business logic or validation decisions.",
            "methods": [
              "__init__",
              "fetch_keys",
              "count_keys",
              "fetch_key_by_id",
              "fetch_key_usage",
              "fetch_key_for_update",
              "update_key_frozen",
              "update_key_unfrozen"
            ],
            "line": 86
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "ProxyCall"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.models.tenant",
            "names": [
              "APIKey"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": [
          "KeysDriver",
          "get_keys_driver",
          "get_keys_read_driver",
          "get_keys_write_driver",
          "KeySnapshot",
          "KeyUsageSnapshot"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 6,
    "violation_count": 0,
    "gap_count": 1
  },
  "ops": {
    "l2_1_facade": null,
    "l2_apis": [],
    "l4_spine": [],
    "l5_engines": [
      {
        "file_name": "cost_ops_engine.py",
        "file_path": "backend/app/hoc/cus/ops/L5_engines/cost_ops_engine.py",
        "layer": "L5_engines",
        "domain": "ops",
        "lines": 644,
        "module_docstring": "Cost Ops Engine (L5)\n\nBusiness logic for founder cost intelligence.\nDelegates DB queries to L6 cost_read_driver, performs:\n- Trend computation\n- Budget projections\n- Cost driver analysis\n- Anomaly pattern detection\n\nOperations:\n- get_overview: Global cost overview with anomaly summary\n- get_anomalies: Cross-tenant anomaly aggregation\n- get_tenants: Per-tenant cost drilldown\n- get_customer_drilldown: Deep-dive cost analysis for a single customer",
        "functions": [
          {
            "name": "_compute_snapshot_status",
            "signature": "(last_snapshot_at: datetime | None) -> tuple[int, str]",
            "docstring": "Compute snapshot freshness status.",
            "is_async": false,
            "line": 241
          },
          {
            "name": "_compute_trend",
            "signature": "(daily_costs: list[float]) -> str",
            "docstring": "Compute trend from daily cost values.",
            "is_async": false,
            "line": 258
          },
          {
            "name": "get_cost_ops_engine",
            "signature": "() -> CostOpsEngine",
            "docstring": "Get the CostOpsEngine singleton.",
            "is_async": false,
            "line": 635
          }
        ],
        "classes": [
          {
            "name": "CostReadDriverPort",
            "docstring": null,
            "methods": [
              "fetch_global_spend_summary",
              "fetch_anomaly_summary",
              "fetch_largest_deviation",
              "fetch_last_snapshot_time",
              "fetch_daily_cost_series",
              "fetch_anomalies",
              "fetch_tenant_cost_rollup",
              "fetch_distinct_tenant_count",
              "check_tenant_has_data",
              "fetch_tenant_name",
              "fetch_tenant_spend_summary",
              "fetch_tenant_baseline",
              "fetch_tenant_budget",
              "fetch_tenant_daily_breakdown",
              "fetch_tenant_cost_by_feature",
              "fetch_tenant_cost_by_user",
              "fetch_tenant_anomalous_users",
              "fetch_tenant_cost_by_model",
              "fetch_tenant_anomaly_history",
              "fetch_tenant_last_activity"
            ],
            "line": 40
          },
          {
            "name": "CostOverviewResult",
            "docstring": "Global cost overview.",
            "methods": [],
            "line": 69
          },
          {
            "name": "AnomalyItem",
            "docstring": "Single anomaly item.",
            "methods": [],
            "line": 87
          },
          {
            "name": "CostAnomalyListResult",
            "docstring": "Anomaly list result.",
            "methods": [],
            "line": 110
          },
          {
            "name": "TenantCostItem",
            "docstring": "Single tenant cost item.",
            "methods": [],
            "line": 120
          },
          {
            "name": "CostTenantListResult",
            "docstring": "Tenant list result.",
            "methods": [],
            "line": 139
          },
          {
            "name": "DailyBreakdownItem",
            "docstring": "Daily cost breakdown item.",
            "methods": [],
            "line": 149
          },
          {
            "name": "FeatureCostItem",
            "docstring": "Cost by feature item.",
            "methods": [],
            "line": 159
          },
          {
            "name": "UserCostItem",
            "docstring": "Cost by user item.",
            "methods": [],
            "line": 169
          },
          {
            "name": "ModelCostItem",
            "docstring": "Cost by model item.",
            "methods": [],
            "line": 180
          },
          {
            "name": "AnomalyHistoryItem",
            "docstring": "Anomaly history item.",
            "methods": [],
            "line": 192
          },
          {
            "name": "CustomerDrilldownResult",
            "docstring": "Customer cost drilldown result.",
            "methods": [],
            "line": 206
          },
          {
            "name": "CostOpsEngine",
            "docstring": "L5 Engine for founder cost intelligence.\n\nAll database access is via L6 CostReadDriver.\nThis engine owns business logic only.",
            "methods": [
              "get_overview",
              "get_anomalies",
              "get_tenants",
              "get_customer_drilldown"
            ],
            "line": 283
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Protocol"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "cost_read_driver.py",
        "file_path": "backend/app/hoc/cus/ops/L6_drivers/cost_read_driver.py",
        "layer": "L6_drivers",
        "domain": "ops",
        "lines": 549,
        "module_docstring": "Cost Read Driver (L6 Data Access)\n\nHandles database operations for founder cost intelligence:\n- Global spend aggregation\n- Anomaly queries\n- Tenant cost rollups\n- Customer drilldown queries\n\nAll methods are pure DB operations \u2014 no business logic.",
        "functions": [
          {
            "name": "get_cost_read_driver",
            "signature": "(session: AsyncSession) -> CostReadDriver",
            "docstring": "Get a CostReadDriver instance.",
            "is_async": false,
            "line": 547
          }
        ],
        "classes": [
          {
            "name": "CostReadDriver",
            "docstring": "L6 Driver for cost intelligence read operations.\n\nAll methods are pure DB operations \u2014 no business logic.\nBusiness computations (trends, projections) stay in L5.",
            "methods": [
              "__init__",
              "fetch_global_spend_summary",
              "fetch_anomaly_summary",
              "fetch_largest_deviation",
              "fetch_last_snapshot_time",
              "fetch_daily_cost_series",
              "fetch_anomalies",
              "fetch_tenant_cost_rollup",
              "fetch_distinct_tenant_count",
              "check_tenant_has_data",
              "fetch_tenant_name",
              "fetch_tenant_spend_summary",
              "fetch_tenant_baseline",
              "fetch_tenant_budget",
              "fetch_tenant_daily_breakdown",
              "fetch_tenant_cost_by_feature",
              "fetch_tenant_cost_by_user",
              "fetch_tenant_anomalous_users",
              "fetch_tenant_cost_by_model",
              "fetch_tenant_anomaly_history",
              "fetch_tenant_last_activity"
            ],
            "line": 37
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 2,
    "violation_count": 0,
    "gap_count": 2
  }
}