{
  "general": {
    "l2_1_facade": null,
    "l2_apis": [],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [],
    "l7_models": [],
    "total_files": 0,
    "violation_count": 0,
    "gap_count": 0
  },
  "overview": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/overview.py",
    "l2_apis": [
      {
        "file_name": "overview.py",
        "file_path": "backend/app/hoc/api/cus/overview/overview.py",
        "layer": "L2_api",
        "domain": "overview",
        "lines": 561,
        "module_docstring": "Unified Overview API (L2)\n\nCustomer-facing endpoints for system overview and health.\nAll requests are tenant-scoped via auth_context.\n\nEndpoints:\n- GET /overview/highlights      \u2192 O1 system pulse & domain counts (Activity, Incidents, Policies)\n- GET /overview/decisions       \u2192 O2 pending decisions queue\n- GET /overview/decisions/count \u2192 O2 decisions count summary\n- GET /overview/costs           \u2192 O2 cost intelligence summary\n- GET /overview/recovery-stats  \u2192 O3 recovery statistics\n\nThis is the ONLY facade for overview operations.\nAll overview APIs flow through this router.",
        "functions": [
          {
            "name": "require_preflight",
            "signature": "() -> None",
            "docstring": "Guard for preflight-only endpoints (O4, O5).",
            "is_async": false,
            "line": 64
          },
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 222
          },
          {
            "name": "get_highlights",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> HighlightsResponse",
            "docstring": "System pulse and domain counts. Tenant-scoped.",
            "is_async": true,
            "line": 260
          },
          {
            "name": "get_decisions",
            "signature": "(request: Request, source_domain: Annotated[str | None, Query(description='Filter by source: INCIDENT, POLICY', pattern='^(INCIDENT|POLICY)$')] = None, priority: Annotated[str | None, Query(description='Filter by priority: CRITICAL, HIGH, MEDIUM, LOW', pattern='^(CRITICAL|HIGH|MEDIUM|LOW)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max items')] = 50, offset: Annotated[int, Query(ge=0, description='Items to skip')] = 0, session = Depends(get_session_dep)) -> DecisionsResponse",
            "docstring": "Pending decisions from incidents and policy proposals. Tenant-scoped.",
            "is_async": true,
            "line": 324
          },
          {
            "name": "get_costs",
            "signature": "(request: Request, period_days: Annotated[int, Query(ge=1, le=365, description='Period in days')] = 30, session = Depends(get_session_dep)) -> CostsResponse",
            "docstring": "Cost intelligence summary. Tenant-scoped.",
            "is_async": true,
            "line": 410
          },
          {
            "name": "get_decisions_count",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> DecisionsCountResponse",
            "docstring": "Decisions count by domain and priority. Tenant-scoped.",
            "is_async": true,
            "line": 476
          },
          {
            "name": "get_recovery_stats",
            "signature": "(request: Request, period_days: Annotated[int, Query(ge=1, le=365, description='Period in days')] = 30, session = Depends(get_session_dep)) -> RecoveryStatsResponse",
            "docstring": "Recovery statistics from incidents. Tenant-scoped.",
            "is_async": true,
            "line": 525
          }
        ],
        "classes": [
          {
            "name": "DomainCount",
            "docstring": "Count for a specific domain.",
            "methods": [],
            "line": 81
          },
          {
            "name": "SystemPulse",
            "docstring": "System health pulse summary.",
            "methods": [],
            "line": 89
          },
          {
            "name": "HighlightsResponse",
            "docstring": "GET /highlights response (O1).",
            "methods": [],
            "line": 99
          },
          {
            "name": "DecisionItem",
            "docstring": "A pending decision requiring human action.",
            "methods": [],
            "line": 111
          },
          {
            "name": "Pagination",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 122
          },
          {
            "name": "DecisionsResponse",
            "docstring": "GET /decisions response (O2).",
            "methods": [],
            "line": 129
          },
          {
            "name": "CostPeriod",
            "docstring": "Time period for cost calculation.",
            "methods": [],
            "line": 143
          },
          {
            "name": "CostActuals",
            "docstring": "Actual costs incurred.",
            "methods": [],
            "line": 149
          },
          {
            "name": "LimitCostItem",
            "docstring": "Single limit with cost status.",
            "methods": [],
            "line": 154
          },
          {
            "name": "CostViolations",
            "docstring": "Cost violation summary.",
            "methods": [],
            "line": 165
          },
          {
            "name": "CostsResponse",
            "docstring": "GET /costs response (O2).",
            "methods": [],
            "line": 171
          },
          {
            "name": "DecisionsCountResponse",
            "docstring": "GET /decisions/count response.",
            "methods": [],
            "line": 185
          },
          {
            "name": "RecoveryStatsResponse",
            "docstring": "GET /recovery-stats response.",
            "methods": [],
            "line": 197
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [
          {
            "name": "_CURRENT_ENVIRONMENT",
            "line": 61
          }
        ],
        "all_exports": null
      }
    ],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "overview_facade.py",
        "file_path": "backend/app/hoc/cus/overview/L5_engines/overview_facade.py",
        "layer": "L5_engines",
        "domain": "overview",
        "lines": 619,
        "module_docstring": "Overview Engine (L5 Domain Logic)\n\nThis facade provides the external interface for overview operations.\nAll overview APIs MUST use this facade instead of directly importing\nmodels or executing queries in L2.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L6 layer violations (direct model imports)\n- Centralizes overview aggregation logic\n- Single point for tenant-scoped queries\n- Maintains projection-only architecture\n\nARCHITECTURAL RULE:\n- Overview DOES NOT own any tables\n- Overview aggregates/projects from existing domains\n- All operations are READ-ONLY\n- All DB access is delegated to overview_facade_driver.py (L6)\n\nL2 API Routes:\n- GET /api/v1/overview/highlights      \u2192 O1 system pulse & domain counts\n- GET /api/v1/overview/decisions       \u2192 O2 pending decisions queue\n- GET /api/v1/overview/decisions/count \u2192 O2 decisions count summary\n- GET /api/v1/overview/costs           \u2192 O2 cost intelligence summary\n- GET /api/v1/overview/recovery-stats  \u2192 O3 recovery statistics\n\nUsage:\n    from app.hoc.cus.overview.L5_engines.overview_facade import get_overview_facade\n\n    facade = get_overview_facade()\n\n    # Get system highlights\n    highlights = await facade.get_highlights(session, tenant_id)",
        "functions": [
          {
            "name": "get_overview_facade",
            "signature": "() -> OverviewFacade",
            "docstring": "Get the singleton OverviewFacade instance.",
            "is_async": false,
            "line": 596
          }
        ],
        "classes": [
          {
            "name": "SystemPulse",
            "docstring": "System health pulse summary.",
            "methods": [
              "to_dict"
            ],
            "line": 85
          },
          {
            "name": "DomainCount",
            "docstring": "Count for a specific domain.",
            "methods": [
              "to_dict"
            ],
            "line": 107
          },
          {
            "name": "HighlightsResult",
            "docstring": "Result from get_highlights.",
            "methods": [
              "to_dict"
            ],
            "line": 125
          },
          {
            "name": "DecisionItem",
            "docstring": "A pending decision requiring human action.",
            "methods": [
              "to_dict"
            ],
            "line": 141
          },
          {
            "name": "DecisionsResult",
            "docstring": "Result from get_decisions.",
            "methods": [
              "to_dict"
            ],
            "line": 165
          },
          {
            "name": "CostPeriod",
            "docstring": "Time period for cost calculation.",
            "methods": [
              "to_dict"
            ],
            "line": 183
          },
          {
            "name": "LimitCostItem",
            "docstring": "Single limit with cost status.",
            "methods": [
              "to_dict"
            ],
            "line": 197
          },
          {
            "name": "CostsResult",
            "docstring": "Result from get_costs.",
            "methods": [
              "to_dict"
            ],
            "line": 221
          },
          {
            "name": "DecisionsCountResult",
            "docstring": "Result from get_decisions_count.",
            "methods": [
              "to_dict"
            ],
            "line": 245
          },
          {
            "name": "RecoveryStatsResult",
            "docstring": "Result from get_recovery_stats.",
            "methods": [
              "to_dict"
            ],
            "line": 261
          },
          {
            "name": "OverviewFacade",
            "docstring": "Overview Facade - Centralized access to overview domain operations.\n\nThis facade aggregates data from multiple domains:\n- Activity (WorkerRun)\n- Incidents (Incident)\n- Policies (PolicyProposal, Limit, LimitBreach)\n- Logs (AuditLedger)\n\nAll DB access is delegated to OverviewFacadeDriver (L6).\nThis facade only contains business logic composition.",
            "methods": [
              "__init__",
              "get_highlights",
              "get_decisions",
              "get_costs",
              "get_decisions_count",
              "get_recovery_stats"
            ],
            "line": 287
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.hoc.cus.overview.L6_drivers.overview_facade_driver",
            "names": [
              "OverviewFacadeDriver"
            ],
            "is_relative": false,
            "line": 69
          }
        ],
        "constants": [],
        "all_exports": [
          "OverviewFacade",
          "get_overview_facade",
          "SystemPulse",
          "DomainCount",
          "HighlightsResult",
          "DecisionItem",
          "DecisionsResult",
          "CostPeriod",
          "LimitCostItem",
          "CostsResult",
          "DecisionsCountResult",
          "RecoveryStatsResult"
        ]
      }
    ],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "overview_facade_driver.py",
        "file_path": "backend/app/hoc/cus/overview/L6_drivers/overview_facade_driver.py",
        "layer": "L6_drivers",
        "domain": "overview",
        "lines": 517,
        "module_docstring": "Overview Facade Driver (L6 Data Access)\n\nThis driver contains all database queries for the overview domain.\nIt returns snapshot dataclasses to the facade (L4) for business logic composition.\n\nARCHITECTURAL RULE:\n- This driver ONLY performs data access\n- NO business logic (no severity thresholds, no status calculations)\n- Returns raw query results as typed snapshots\n- The facade composes business results from these snapshots",
        "functions": [],
        "classes": [
          {
            "name": "IncidentCountSnapshot",
            "docstring": "Raw incident count data from DB.",
            "methods": [],
            "line": 63
          },
          {
            "name": "ProposalCountSnapshot",
            "docstring": "Raw policy proposal count data from DB.",
            "methods": [],
            "line": 72
          },
          {
            "name": "BreachCountSnapshot",
            "docstring": "Raw limit breach count data from DB.",
            "methods": [],
            "line": 80
          },
          {
            "name": "RunCountSnapshot",
            "docstring": "Raw worker run count data from DB.",
            "methods": [],
            "line": 87
          },
          {
            "name": "AuditCountSnapshot",
            "docstring": "Raw audit count data from DB.",
            "methods": [],
            "line": 96
          },
          {
            "name": "IncidentSnapshot",
            "docstring": "Snapshot of a single incident for decisions projection.",
            "methods": [],
            "line": 103
          },
          {
            "name": "ProposalSnapshot",
            "docstring": "Snapshot of a single policy proposal for decisions projection.",
            "methods": [],
            "line": 114
          },
          {
            "name": "LimitSnapshot",
            "docstring": "Snapshot of a single limit for cost projection.",
            "methods": [],
            "line": 124
          },
          {
            "name": "RunCostSnapshot",
            "docstring": "Snapshot of run cost data from DB.",
            "methods": [],
            "line": 135
          },
          {
            "name": "BreachStatsSnapshot",
            "docstring": "Snapshot of breach statistics from DB.",
            "methods": [],
            "line": 142
          },
          {
            "name": "IncidentDecisionCountSnapshot",
            "docstring": "Snapshot of incident counts by severity for decisions count.",
            "methods": [],
            "line": 150
          },
          {
            "name": "RecoverySnapshot",
            "docstring": "Snapshot of incident recovery data from DB.",
            "methods": [],
            "line": 160
          },
          {
            "name": "OverviewFacadeDriver",
            "docstring": "Overview Facade Driver - Pure data access layer.\n\nAll methods execute DB queries and return snapshot dataclasses.\nNo business logic or status calculations.",
            "methods": [
              "fetch_incident_counts",
              "fetch_proposal_counts",
              "fetch_breach_counts",
              "fetch_run_counts",
              "fetch_last_activity",
              "fetch_pending_incidents",
              "fetch_pending_proposals",
              "fetch_run_cost",
              "fetch_budget_limits",
              "fetch_breach_stats",
              "fetch_incident_decision_counts",
              "fetch_proposal_count",
              "fetch_recovery_stats"
            ],
            "line": 174
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "case",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "AuditLedger"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentLifecycleState"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyProposal"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitBreach",
              "LimitCategory"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": [
          "OverviewFacadeDriver",
          "IncidentCountSnapshot",
          "ProposalCountSnapshot",
          "BreachCountSnapshot",
          "RunCountSnapshot",
          "AuditCountSnapshot",
          "IncidentSnapshot",
          "ProposalSnapshot",
          "LimitSnapshot",
          "RunCostSnapshot",
          "BreachStatsSnapshot",
          "IncidentDecisionCountSnapshot",
          "RecoverySnapshot"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 3,
    "violation_count": 0,
    "gap_count": 2
  },
  "activity": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/activity.py",
    "l2_apis": [
      {
        "file_name": "activity.py",
        "file_path": "backend/app/hoc/api/cus/activity/activity.py",
        "layer": "L2_api",
        "domain": "activity",
        "lines": 2293,
        "module_docstring": null,
        "functions": [
          {
            "name": "require_preflight",
            "signature": "() -> None",
            "docstring": "Guard for preflight-only endpoints (O4, O5).",
            "is_async": false,
            "line": 86
          },
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 746
          },
          {
            "name": "list_runs",
            "signature": "(request: Request, project_id: Annotated[str | None, Query(description='Project scope')] = None, state: Annotated[RunState | None, Query(description='Run lifecycle state')] = None, status: Annotated[list[str] | None, Query(description='Run status (multiple)')] = None, risk: Annotated[bool, Query(description='If true, returns runs with risk signals')] = False, risk_level: Annotated[list[RiskLevel] | None, Query(description='Filter by risk level')] = None, latency_bucket: Annotated[list[LatencyBucket] | None, Query(description='Filter by latency')] = None, evidence_health: Annotated[list[EvidenceHealth] | None, Query(description='Filter by evidence health')] = None, integrity_status: Annotated[list[IntegrityStatus] | None, Query(description='Filter by integrity')] = None, source: Annotated[list[RunSource] | None, Query(description='Filter by run source')] = None, provider_type: Annotated[list[ProviderType] | None, Query(description='Filter by LLM provider')] = None, is_synthetic: Annotated[bool | None, Query(description='Filter by synthetic data flag')] = None, started_after: Annotated[datetime | None, Query(description='Filter runs started after')] = None, started_before: Annotated[datetime | None, Query(description='Filter runs started before')] = None, completed_after: Annotated[datetime | None, Query(description='Filter runs completed after')] = None, completed_before: Annotated[datetime | None, Query(description='Filter runs completed before')] = None, limit: Annotated[int, Query(ge=1, le=200, description='Max runs to return')] = 50, offset: Annotated[int, Query(ge=0, description='Number of runs to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.STARTED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session = Depends(get_session_dep)) -> RunListResponse",
            "docstring": "List runs with unified query filters. READ-ONLY from v_runs_o2 view.",
            "is_async": true,
            "line": 797
          },
          {
            "name": "get_run_detail",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> RunDetailResponse",
            "docstring": "Get run detail (O3). Tenant isolation enforced.",
            "is_async": true,
            "line": 929
          },
          {
            "name": "get_run_evidence",
            "signature": "(request: Request, run_id: str) -> dict[str, Any]",
            "docstring": "Get run evidence (O4). Preflight console only.",
            "is_async": true,
            "line": 990
          },
          {
            "name": "get_run_proof",
            "signature": "(request: Request, run_id: str, include_payloads: bool = False) -> dict[str, Any]",
            "docstring": "Get run proof (O5). Preflight console only.",
            "is_async": true,
            "line": 1017
          },
          {
            "name": "get_summary_by_status",
            "signature": "(request: Request, state: Annotated[RunState | None, Query(description='Filter by run state')] = None, session = Depends(get_session_dep)) -> StatusSummaryResponse",
            "docstring": "Get run summary by status (COMP-O3). READ-ONLY from v_runs_o2.",
            "is_async": true,
            "line": 1054
          },
          {
            "name": "_get_runs_by_dimension_internal",
            "signature": "(session, tenant_id: str, dim: DimensionValue, state: RunState, limit: int = 20) -> DimensionBreakdownResponse",
            "docstring": "Internal helper for dimension breakdown with HARDCODED state binding.\n\nThis function is called by topic-scoped endpoints only.\nState is injected by the endpoint, never from caller.\n\nPolicy: TOPIC-SCOPED-ENDPOINT-001",
            "is_async": true,
            "line": 1102
          },
          {
            "name": "get_live_runs_by_dimension",
            "signature": "(request: Request, dim: Annotated[DimensionValue, Query(description='Dimension to group by')], limit: Annotated[int, Query(ge=1, le=100, description='Max groups to return')] = 20, session = Depends(get_session_dep)) -> DimensionBreakdownResponse",
            "docstring": "Get LIVE runs grouped by dimension. State=LIVE is hardcoded.",
            "is_async": true,
            "line": 1172
          },
          {
            "name": "get_completed_runs_by_dimension",
            "signature": "(request: Request, dim: Annotated[DimensionValue, Query(description='Dimension to group by')], limit: Annotated[int, Query(ge=1, le=100, description='Max groups to return')] = 20, session = Depends(get_session_dep)) -> DimensionBreakdownResponse",
            "docstring": "Get COMPLETED runs grouped by dimension. State=COMPLETED is hardcoded.",
            "is_async": true,
            "line": 1208
          },
          {
            "name": "get_runs_by_dimension",
            "signature": "(request: Request, dim: Annotated[DimensionValue, Query(description='Dimension to group by')], state: Annotated[RunState | None, Query(description='Filter by run state')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max groups to return')] = 20, session = Depends(get_session_dep)) -> DimensionBreakdownResponse",
            "docstring": "[INTERNAL] Get runs grouped by dimension with optional state. NOT FOR PANELS.",
            "is_async": true,
            "line": 1246
          },
          {
            "name": "get_patterns",
            "signature": "(request: Request, window_hours: Annotated[int, Query(ge=1, le=168, description='Hours to look back')] = 24, limit: Annotated[int, Query(ge=1, le=50, description='Max patterns per type')] = 10, session = Depends(get_session_dep)) -> PatternDetectionResponse",
            "docstring": "Detect instability patterns (SIG-O3). READ-ONLY from aos_traces/aos_trace_steps.",
            "is_async": true,
            "line": 1305
          },
          {
            "name": "get_cost_analysis",
            "signature": "(request: Request, baseline_days: Annotated[int, Query(ge=1, le=30, description='Days for baseline')] = 7, anomaly_threshold: Annotated[float, Query(ge=1.0, le=5.0, description='Threshold percentage')] = 50.0, session = Depends(get_session_dep)) -> CostAnalysisResponse",
            "docstring": "Analyze cost anomalies (SIG-O4). READ-ONLY from runs table.",
            "is_async": true,
            "line": 1371
          },
          {
            "name": "get_attention_queue",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100, description='Max items to return')] = 20, session = Depends(get_session_dep)) -> AttentionQueueResponse",
            "docstring": "Get attention queue (SIG-O5). READ-ONLY from v_runs_o2.",
            "is_async": true,
            "line": 1437
          },
          {
            "name": "get_risk_signals",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> RiskSignalsResponse",
            "docstring": "Returns aggregated risk signal counts.\n\nSupports: activity.risk_signals capability\nConsumers: Overview panels, Activity summary panels",
            "is_async": true,
            "line": 1515
          },
          {
            "name": "_extract_policy_context",
            "signature": "(row: dict) -> PolicyContext",
            "docstring": "Extract PolicyContext from a v_runs_o2 row (V2 schema).\n\nThe v_runs_o2 view includes policy context fields from migration 107.\nThis helper converts DB row to PolicyContext model.\n\nCross-Domain Navigation (PIN-447):\n- facade_ref: Always populated if policy_id exists\n- threshold_ref: Populated if limit_id exists\n- violation_ref: Populated if violation_id exists",
            "is_async": false,
            "line": 1555
          },
          {
            "name": "_policy_context_from_l5",
            "signature": "(pc: Any) -> PolicyContext",
            "docstring": "Convert L5 PolicyContextResult dataclass to L2 PolicyContext Pydantic model.",
            "is_async": false,
            "line": 1597
          },
          {
            "name": "_run_summary_v2_from_l5",
            "signature": "(item: Any) -> RunSummaryV2",
            "docstring": "Convert L5 RunSummaryV2Result dataclass to L2 RunSummaryV2 Pydantic model.",
            "is_async": false,
            "line": 1617
          },
          {
            "name": "_row_to_run_summary_v2",
            "signature": "(row: dict) -> RunSummaryV2",
            "docstring": "Convert a v_runs_o2 row to RunSummaryV2.\n\nIncludes policy_context extraction.",
            "is_async": false,
            "line": 1646
          },
          {
            "name": "list_live_runs",
            "signature": "(request: Request, project_id: Annotated[str | None, Query(description='Project scope')] = None, risk_level: Annotated[list[RiskLevel] | None, Query(description='Filter by risk level')] = None, evidence_health: Annotated[list[EvidenceHealth] | None, Query(description='Filter by evidence health')] = None, source: Annotated[list[RunSource] | None, Query(description='Filter by run source')] = None, provider_type: Annotated[list[ProviderType] | None, Query(description='Filter by LLM provider')] = None, limit: Annotated[int, Query(ge=1, le=200, description='Max runs to return')] = 50, offset: Annotated[int, Query(ge=0, description='Number of runs to skip')] = 0, session = Depends(get_session_dep)) -> LiveRunsResponse",
            "docstring": "List LIVE runs with policy context.\n\nState=LIVE is HARDCODED - cannot be overridden.\nThis is the canonical endpoint for the LIVE topic.",
            "is_async": true,
            "line": 1707
          },
          {
            "name": "list_completed_runs",
            "signature": "(request: Request, project_id: Annotated[str | None, Query(description='Project scope')] = None, status: Annotated[list[str] | None, Query(description='Run status (multiple)')] = None, risk_level: Annotated[list[RiskLevel] | None, Query(description='Filter by risk level')] = None, completed_after: Annotated[datetime | None, Query(description='Filter runs completed after')] = None, completed_before: Annotated[datetime | None, Query(description='Filter runs completed before')] = None, limit: Annotated[int, Query(ge=1, le=200, description='Max runs to return')] = 50, offset: Annotated[int, Query(ge=0, description='Number of runs to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.COMPLETED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session = Depends(get_session_dep)) -> CompletedRunsResponse",
            "docstring": "List COMPLETED runs with policy context.\n\nState=COMPLETED is HARDCODED - cannot be overridden.\nThis is the canonical endpoint for the COMPLETED topic.",
            "is_async": true,
            "line": 1790
          },
          {
            "name": "list_signals",
            "signature": "(request: Request, project_id: Annotated[str | None, Query(description='Project scope')] = None, signal_type: Annotated[str | None, Query(description='Filter by signal type')] = None, severity: Annotated[str | None, Query(description='Filter by severity (HIGH, MEDIUM, LOW)')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max signals to return')] = 20, session = Depends(get_session_dep)) -> SignalsResponse",
            "docstring": "List activity signals (V2 projection).\n\nSynthesizes signals from runs with attention-worthy conditions.\nSIGNALS is NOT a run state - it's a computed projection.",
            "is_async": true,
            "line": 1879
          },
          {
            "name": "get_activity_metrics",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> MetricsResponse",
            "docstring": "Get aggregated activity metrics (V2).\n\nProvides counts for:\n- Risk levels\n- Topic (LIVE vs COMPLETED)\n- Evidence health\n- Risk types",
            "is_async": true,
            "line": 1966
          },
          {
            "name": "get_threshold_signals",
            "signature": "(request: Request, risk_type: Annotated[RiskType | None, Query(description='Filter by risk type')] = None, evaluation_outcome: Annotated[EvaluationOutcome | None, Query(description='Filter by evaluation outcome')] = None, state: Annotated[RunState | None, Query(description='Filter by run state')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max signals to return')] = 20, session = Depends(get_session_dep)) -> ThresholdSignalsResponse",
            "docstring": "Get threshold proximity signals (V2).\n\nReturns runs with threshold evaluation data.\nCan be filtered by risk_type (COST, TIME, TOKENS, RATE).",
            "is_async": true,
            "line": 2030
          },
          {
            "name": "acknowledge_signal",
            "signature": "(request: Request, signal_fingerprint: Annotated[str, Path(description='Canonical signal fingerprint (sig-{hash})')], body: SignalAckRequest, session = Depends(get_session_dep)) -> SignalAckResponse",
            "docstring": "Acknowledge a signal.\n\nRecords acknowledgment in the audit_ledger.\nThe signal remains visible but receives a ranking dampener (0.6x).",
            "is_async": true,
            "line": 2118
          },
          {
            "name": "suppress_signal",
            "signature": "(request: Request, signal_fingerprint: Annotated[str, Path(description='Canonical signal fingerprint (sig-{hash})')], body: SignalSuppressRequest, session = Depends(get_session_dep)) -> SignalSuppressResponse",
            "docstring": "Suppress a signal temporarily.\n\nRecords suppression in the audit_ledger with a suppress_until timestamp.\nThe signal is excluded from the attention queue until expiry.",
            "is_async": true,
            "line": 2201
          },
          {
            "name": "get_actor_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract actor ID from request auth context.\n\nFalls back to 'unknown' if not available (should not happen in production).",
            "is_async": false,
            "line": 2284
          }
        ],
        "classes": [
          {
            "name": "RunState",
            "docstring": "Run lifecycle state.",
            "methods": [],
            "line": 103
          },
          {
            "name": "RunStatus",
            "docstring": "Run execution status.",
            "methods": [],
            "line": 110
          },
          {
            "name": "RiskLevel",
            "docstring": "Risk classification.",
            "methods": [],
            "line": 121
          },
          {
            "name": "LatencyBucket",
            "docstring": "Latency classification.",
            "methods": [],
            "line": 130
          },
          {
            "name": "EvidenceHealth",
            "docstring": "Evidence capture health.",
            "methods": [],
            "line": 138
          },
          {
            "name": "IntegrityStatus",
            "docstring": "Integrity verification status.",
            "methods": [],
            "line": 146
          },
          {
            "name": "RunSource",
            "docstring": "Run initiator type.",
            "methods": [],
            "line": 155
          },
          {
            "name": "ProviderType",
            "docstring": "LLM provider.",
            "methods": [],
            "line": 163
          },
          {
            "name": "SortField",
            "docstring": "Allowed sort fields.",
            "methods": [],
            "line": 171
          },
          {
            "name": "SortOrder",
            "docstring": "Sort direction.",
            "methods": [],
            "line": 180
          },
          {
            "name": "EvaluationOutcome",
            "docstring": "Policy evaluation outcome.",
            "methods": [],
            "line": 187
          },
          {
            "name": "PolicyScope",
            "docstring": "Policy/limit scope.",
            "methods": [],
            "line": 197
          },
          {
            "name": "RiskType",
            "docstring": "Risk type classification for panels.",
            "methods": [],
            "line": 207
          },
          {
            "name": "PolicyContext",
            "docstring": "Policy context for a run (V2).\n\nAdvisory metadata showing why a run is at-risk.\nDerived at query time from limits table via v_runs_o2 view.\n\nCross-Domain Navigation (PIN-447):\n- facade_ref: Links to /policy/active/{policy_id}\n- threshold_ref: Links to /policy/thresholds/{id} (if limit-based)\n- violation_ref: Links to /policy/violations/{id} (if violation exists)\n\nReference: ACTIVITY_DOMAIN_V2_MIGRATION_PLAN.md, CROSS_DOMAIN_POLICY_CONTRACT.md",
            "methods": [],
            "line": 227
          },
          {
            "name": "RunSummaryV2",
            "docstring": "Run summary with policy context (V2).\n\nExtends RunSummary with mandatory policy_context field.\nUsed by topic-scoped endpoints: /live, /completed.\n\nReference: ACTIVITY_DOMAIN_CONTRACT.md (V2 sections)",
            "methods": [],
            "line": 260
          },
          {
            "name": "Pagination",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 309
          },
          {
            "name": "LiveRunsResponse",
            "docstring": "GET /activity/live response (V2).\n\nTopic-scoped endpoint - hardcoded state=LIVE.\nEvery run includes policy_context.\n\nPanels: LIVE-O1, LIVE-O3, LIVE-O5",
            "methods": [],
            "line": 317
          },
          {
            "name": "CompletedRunsResponse",
            "docstring": "GET /activity/completed response (V2).\n\nTopic-scoped endpoint - hardcoded state=COMPLETED.\nEvery run includes policy_context.\n\nPanels: COMP-O2, COMP-O5",
            "methods": [],
            "line": 334
          },
          {
            "name": "SignalFeedbackModel",
            "docstring": "Feedback state for a signal.\n\nINVARIANTS:\n- ATTN-DAMP-001: Acknowledgement dampening is idempotent (apply once, 0.6x)\n- SIGNAL-SUPPRESS-001: Suppression is temporary (15-1440 minutes)\n- SIGNAL-ACK-001: Acknowledgement records responsibility, doesn't hide signals",
            "methods": [],
            "line": 351
          },
          {
            "name": "SignalProjection",
            "docstring": "A signal projection (V2).\n\nSIGNALS is NOT a run state - it's a computed projection over LIVE + COMPLETED.\nEach signal includes policy_context for the underlying run.\n\nReference: ACTIVITY_DOMAIN_V2_MIGRATION_PLAN.md",
            "methods": [],
            "line": 367
          },
          {
            "name": "SignalsResponse",
            "docstring": "GET /activity/signals response (V2).\n\nProjection endpoint - synthesizes signals from LIVE + COMPLETED runs.\nReturns SignalProjection[], NOT runs.\n\nPanels: SIG-O1",
            "methods": [],
            "line": 388
          },
          {
            "name": "MetricsResponse",
            "docstring": "GET /activity/metrics response (V2).\n\nExtends /risk-signals with topic-aware counts.\n\nPanels: LIVE-O1, LIVE-O2, LIVE-O4, COMP-O1, COMP-O3",
            "methods": [],
            "line": 403
          },
          {
            "name": "ThresholdSignal",
            "docstring": "A threshold proximity signal (V2).\n\nUsed for runs approaching or exceeding limits.",
            "methods": [],
            "line": 436
          },
          {
            "name": "ThresholdSignalsResponse",
            "docstring": "GET /activity/threshold-signals response (V2).\n\nReturns runs with typed threshold proximity.\n\nPanels: LIVE-O2, COMP-O4, SIG-O2",
            "methods": [],
            "line": 450
          },
          {
            "name": "SignalAckRequest",
            "docstring": "POST /activity/signals/{signal_fingerprint}/ack request.\n\nINVARIANT (SIGNAL-ID-001): The signal_fingerprint in the path MUST match\nthe server-computed fingerprint. Clients provide identifying info for\nserver-side validation.",
            "methods": [],
            "line": 470
          },
          {
            "name": "SignalAckResponse",
            "docstring": "POST /activity/signals/{signal_fingerprint}/ack response.",
            "methods": [],
            "line": 485
          },
          {
            "name": "SignalSuppressRequest",
            "docstring": "POST /activity/signals/{signal_fingerprint}/suppress request.\n\nINVARIANT (SIGNAL-SUPPRESS-001): duration_minutes must be 15-1440 (max 24 hours).",
            "methods": [],
            "line": 496
          },
          {
            "name": "SignalSuppressResponse",
            "docstring": "POST /activity/signals/{signal_fingerprint}/suppress response.",
            "methods": [],
            "line": 510
          },
          {
            "name": "RunSummary",
            "docstring": "Run summary for list view (O2).",
            "methods": [],
            "line": 519
          },
          {
            "name": "RunListResponse",
            "docstring": "GET /runs response.",
            "methods": [],
            "line": 558
          },
          {
            "name": "RunDetailResponse",
            "docstring": "GET /runs/{run_id} response (O3).",
            "methods": [],
            "line": 568
          },
          {
            "name": "StatusBucket",
            "docstring": "A bucket in status summary.",
            "methods": [],
            "line": 606
          },
          {
            "name": "StatusSummaryResponse",
            "docstring": "GET /summary/by-status response (COMP-O3).",
            "methods": [],
            "line": 614
          },
          {
            "name": "DimensionValue",
            "docstring": "Allowed dimension values for grouping.",
            "methods": [],
            "line": 627
          },
          {
            "name": "DimensionGroup",
            "docstring": "A group in dimension breakdown.",
            "methods": [],
            "line": 637
          },
          {
            "name": "DimensionBreakdownResponse",
            "docstring": "GET /runs/by-dimension response (LIVE-O5).",
            "methods": [],
            "line": 645
          },
          {
            "name": "PatternMatchResponse",
            "docstring": "A detected pattern.",
            "methods": [],
            "line": 660
          },
          {
            "name": "PatternDetectionResponse",
            "docstring": "GET /patterns response (SIG-O3).",
            "methods": [],
            "line": 669
          },
          {
            "name": "AgentCostResponse",
            "docstring": "Cost analysis for a single agent.",
            "methods": [],
            "line": 683
          },
          {
            "name": "CostAnalysisResponse",
            "docstring": "GET /cost-analysis response (SIG-O4).",
            "methods": [],
            "line": 695
          },
          {
            "name": "AttentionItemResponse",
            "docstring": "An item in the attention queue.",
            "methods": [],
            "line": 710
          },
          {
            "name": "AttentionQueueResponse",
            "docstring": "GET /attention-queue response (SIG-O5).",
            "methods": [],
            "line": 721
          },
          {
            "name": "RiskSignalsResponse",
            "docstring": "GET /risk-signals response.",
            "methods": [],
            "line": 1487
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 17
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Path",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 74
          }
        ],
        "constants": [
          {
            "name": "_CURRENT_ENVIRONMENT",
            "line": 83
          }
        ],
        "all_exports": null
      }
    ],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "activity_enums.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/activity_enums.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 120,
        "module_docstring": "Activity Domain Enums\n\nCanonical enum definitions for the activity domain.\nThese are the single source of truth for categorical fields.\n\nRules (per ACT-DUP-006, ACTIVITY_DTO_RULES.md):\n- No free-text categorical fields in Activity\n- Signals are governance inputs - they must be enumerable\n- Engines own canonical enums, facades import them",
        "functions": [],
        "classes": [
          {
            "name": "SignalType",
            "docstring": "Canonical signal types for activity domain.\n\nSignals are governance inputs and must be enumerable.\nNo free-text signal types allowed.",
            "methods": [],
            "line": 34
          },
          {
            "name": "SeverityLevel",
            "docstring": "Canonical severity levels for display/UI.\n\nRule (per ACT-DUP-005):\n- Engines speak numbers (severity_score: float 0.0-1.0)\n- Facades render labels (severity_level: SeverityLevel)\n\nConversion:\n- HIGH: score >= 0.7\n- MEDIUM: score >= 0.4\n- LOW: score < 0.4",
            "methods": [
              "from_score",
              "from_risk_level"
            ],
            "line": 53
          },
          {
            "name": "RunState",
            "docstring": "Run lifecycle state.",
            "methods": [],
            "line": 90
          },
          {
            "name": "RiskType",
            "docstring": "Types of risk for threshold signals.",
            "methods": [],
            "line": 97
          },
          {
            "name": "EvidenceHealth",
            "docstring": "Evidence health status.",
            "methods": [],
            "line": 106
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "SignalType",
          "SeverityLevel",
          "RunState",
          "RiskType",
          "EvidenceHealth"
        ]
      },
      {
        "file_name": "activity_facade.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/activity_facade.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 1731,
        "module_docstring": "Activity Facade (L5)\n\nProvides unified access to activity domain operations.\nThis is the single entry point for all activity business logic.\n\nOperations:\n- get_runs: List runs with filters\n- get_run_detail: Get run details (O3)\n- get_run_evidence: Get run evidence context (O4)\n- get_run_proof: Get run integrity proof (O5)\n- get_status_summary: Get runs grouped by status\n- get_patterns: Pattern detection (SIG-O3)\n- get_cost_analysis: Cost anomalies (SIG-O4)\n- get_attention_queue: Attention ranking (SIG-O5)\n- get_live_runs: V2 live runs with policy context\n- get_completed_runs: V2 completed runs with policy context\n- get_signals: V2 synthesized signals\n- get_metrics: V2 activity metrics\n- get_threshold_signals: V2 threshold proximity signals\n- get_risk_signals: Risk signal aggregates\n- acknowledge_signal: Acknowledge a signal\n- suppress_signal: Suppress a signal\n\nReference: ACTIVITY_DOMAIN_V2_MIGRATION_PLAN.md",
        "functions": [
          {
            "name": "get_activity_facade",
            "signature": "(run_evidence_coordinator: RunEvidenceCoordinatorPort | None = None, run_proof_coordinator: RunProofCoordinatorPort | None = None, signal_feedback_coordinator: SignalFeedbackCoordinatorPort | None = None) -> ActivityFacade",
            "docstring": "Get the singleton ActivityFacade instance.\n\nPIN-520: L4 callers must inject coordinators. L5 must not import from hoc_spine.\n\nArgs:\n    run_evidence_coordinator: Coordinator for cross-domain evidence queries (injected by L4 caller).\n    run_proof_coordinator: Coordinator for integrity proof queries (injected by L4 caller).\n    signal_feedback_coordinator: Coordinator for signal feedback queries (injected by L4 caller).\n\nReturns:\n    ActivityFacade instance",
            "is_async": false,
            "line": 1699
          }
        ],
        "classes": [
          {
            "name": "RunEvidenceCoordinatorPort",
            "docstring": "Protocol for run evidence coordinator (PIN-520 L5 purity).",
            "methods": [
              "get_run_evidence"
            ],
            "line": 109
          },
          {
            "name": "RunProofCoordinatorPort",
            "docstring": "Protocol for run proof coordinator (PIN-520 L5 purity).",
            "methods": [
              "get_run_proof"
            ],
            "line": 119
          },
          {
            "name": "SignalFeedbackCoordinatorPort",
            "docstring": "Protocol for signal feedback coordinator (PIN-520 L5 purity).",
            "methods": [
              "get_signal_feedback"
            ],
            "line": 129
          },
          {
            "name": "PolicyContextResult",
            "docstring": "Policy context for a run.",
            "methods": [],
            "line": 145
          },
          {
            "name": "RunSummaryResult",
            "docstring": "Run summary for list view.",
            "methods": [],
            "line": 165
          },
          {
            "name": "RunSummaryV2Result",
            "docstring": "Run summary with policy context (V2).",
            "methods": [],
            "line": 193
          },
          {
            "name": "RunListResult",
            "docstring": "Result of listing runs.",
            "methods": [],
            "line": 200
          },
          {
            "name": "RunsResult",
            "docstring": "Unified result for getting runs (V2).\n\nConsolidates LiveRunsResult and CompletedRunsResult per ACT-DUP-003.\nThese were 100% structurally identical - only the name differed.\n\nRule: If structures are identical today, they will diverge accidentally tomorrow.",
            "methods": [],
            "line": 210
          },
          {
            "name": "RunDetailResult",
            "docstring": "Run detail (O3) - extends summary with additional fields.\n\nRefactored per ACT-DUP-002: Detail DTOs must extend summary DTOs,\nnever re-declare shared fields. This prevents field drift and\nguarantees backward compatibility.",
            "methods": [],
            "line": 233
          },
          {
            "name": "RunEvidenceResult",
            "docstring": "Run evidence context (O4).",
            "methods": [],
            "line": 247
          },
          {
            "name": "RunProofResult",
            "docstring": "Run integrity proof (O5).",
            "methods": [],
            "line": 258
          },
          {
            "name": "StatusCount",
            "docstring": "Status count item.",
            "methods": [],
            "line": 269
          },
          {
            "name": "StatusSummaryResult",
            "docstring": "Summary by status.",
            "methods": [],
            "line": 277
          },
          {
            "name": "SignalProjectionResult",
            "docstring": "A signal projection.",
            "methods": [],
            "line": 290
          },
          {
            "name": "SignalsResult",
            "docstring": "Result of getting signals (V2).",
            "methods": [],
            "line": 305
          },
          {
            "name": "MetricsResult",
            "docstring": "Activity metrics (V2).",
            "methods": [],
            "line": 314
          },
          {
            "name": "ThresholdSignalResult",
            "docstring": "A threshold proximity signal.",
            "methods": [],
            "line": 334
          },
          {
            "name": "ThresholdSignalsResult",
            "docstring": "Result of getting threshold signals (V2).",
            "methods": [],
            "line": 345
          },
          {
            "name": "RiskSignalsResult",
            "docstring": "Risk signal aggregates.\n\nNOTE (ACT-DUP-004): This is a DERIVED PROJECTION of MetricsResult.\nThe get_risk_signals() method extracts a subset from get_metrics().\nIf you need full metrics, use MetricsResult directly.\n\nRule: Derived views must be explicitly labeled as such.",
            "methods": [],
            "line": 355
          },
          {
            "name": "DimensionGroupResult",
            "docstring": "A dimension group with count and percentage.",
            "methods": [],
            "line": 374
          },
          {
            "name": "DimensionBreakdownResult",
            "docstring": "Dimension breakdown result.",
            "methods": [],
            "line": 383
          },
          {
            "name": "ActivityFacade",
            "docstring": "Unified facade for Activity domain operations.\n\nThis class provides a single entry point for all activity business logic,\ndelegating to specialized services where appropriate.\n\nNote: Services are instantiated per-request with the session, as they\nrequire the session in their constructors.\n\nPIN-520: Coordinators are now injected via L4 bridge instead of being\nimported directly from L4 orchestrator.",
            "methods": [
              "__init__",
              "_get_driver",
              "_get_pattern_service",
              "_get_cost_service",
              "_get_attention_service",
              "_get_feedback_service",
              "get_runs",
              "get_run_detail",
              "get_run_evidence",
              "get_run_proof",
              "get_status_summary",
              "get_live_runs",
              "get_completed_runs",
              "_get_runs_with_policy_context",
              "get_signals",
              "_get_signal_feedback",
              "_compute_signal_type",
              "_compute_severity",
              "_compute_signal_summary",
              "get_metrics",
              "get_threshold_signals",
              "get_risk_signals",
              "get_dimension_breakdown",
              "get_patterns",
              "get_cost_analysis",
              "get_attention_queue",
              "acknowledge_signal",
              "suppress_signal"
            ],
            "line": 412
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 73
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Protocol"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "app.hoc.cus.activity.L6_drivers.activity_read_driver",
            "names": [
              "get_activity_read_driver"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.attention_ranking",
            "names": [
              "AttentionRankingService"
            ],
            "is_relative": false,
            "line": 83
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.cost_analysis",
            "names": [
              "CostAnalysisService"
            ],
            "is_relative": false,
            "line": 84
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.pattern_detection",
            "names": [
              "PatternDetectionService"
            ],
            "is_relative": false,
            "line": 85
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.signal_feedback_engine",
            "names": [
              "SignalFeedbackService",
              "AcknowledgeResult",
              "SuppressResult",
              "SignalFeedbackStatus"
            ],
            "is_relative": false,
            "line": 86
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.signal_identity",
            "names": [
              "compute_signal_fingerprint_from_row"
            ],
            "is_relative": false,
            "line": 92
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.activity_enums",
            "names": [
              "SignalType",
              "SeverityLevel",
              "RunState"
            ],
            "is_relative": false,
            "line": 95
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.pattern_detection",
            "names": [
              "PatternDetectionResult",
              "DetectedPattern"
            ],
            "is_relative": false,
            "line": 393
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.cost_analysis",
            "names": [
              "CostAnalysisResult",
              "CostAnomaly"
            ],
            "is_relative": false,
            "line": 397
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.attention_ranking",
            "names": [
              "AttentionQueueResult",
              "AttentionSignal"
            ],
            "is_relative": false,
            "line": 401
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "signal_feedback_engine.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/signal_feedback_engine.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 140,
        "module_docstring": "Signal feedback engine for user interactions with signals.",
        "functions": [],
        "classes": [
          {
            "name": "AcknowledgeResult",
            "docstring": "Result of acknowledging a signal.",
            "methods": [],
            "line": 30
          },
          {
            "name": "SuppressResult",
            "docstring": "Result of suppressing a signal.",
            "methods": [],
            "line": 41
          },
          {
            "name": "SignalFeedbackStatus",
            "docstring": "Current feedback status for a signal.",
            "methods": [],
            "line": 54
          },
          {
            "name": "SignalFeedbackService",
            "docstring": "Service for managing user feedback on signals.\n\nProvides:\n- Acknowledge: Mark signal as seen/reviewed\n- Suppress: Temporarily hide signal from attention queue",
            "methods": [
              "__init__",
              "acknowledge_signal",
              "suppress_signal",
              "get_signal_feedback_status",
              "get_bulk_signal_feedback"
            ],
            "line": 64
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "signal_identity.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/signal_identity.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 79,
        "module_docstring": "Signal identity utilities for fingerprinting and deduplication.",
        "functions": [
          {
            "name": "compute_signal_fingerprint_from_row",
            "signature": "(row: dict[str, Any]) -> str",
            "docstring": "Compute a stable fingerprint for a signal row.\n\nUsed for:\n- Signal deduplication\n- Change detection\n- Idempotent signal creation\n\nArgs:\n    row: A dictionary containing signal data\n\nReturns:\n    A hex digest fingerprint string",
            "is_async": false,
            "line": 26
          },
          {
            "name": "compute_signal_fingerprint",
            "signature": "(signal_type: str, dimension: str, source: str, tenant_id: str) -> str",
            "docstring": "Compute a stable fingerprint for signal identity fields.\n\nArgs:\n    signal_type: Type of signal (e.g., \"pattern\", \"anomaly\")\n    dimension: Dimension being measured\n    source: Source of the signal\n    tenant_id: Tenant identifier\n\nReturns:\n    A hex digest fingerprint string",
            "is_async": false,
            "line": 56
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 23
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "activity_read_driver.py",
        "file_path": "backend/app/hoc/cus/activity/L6_drivers/activity_read_driver.py",
        "layer": "L6_drivers",
        "domain": "activity",
        "lines": 385,
        "module_docstring": "Activity Read Driver (L6 Data Access)\n\nHandles database operations for activity queries:\n- Fetching runs with filters\n- Fetching run details\n- Fetching metrics aggregates\n- Fetching threshold signals\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_activity_read_driver",
            "signature": "(session: AsyncSession) -> ActivityReadDriver",
            "docstring": "Get an ActivityReadDriver instance.",
            "is_async": false,
            "line": 383
          }
        ],
        "classes": [
          {
            "name": "ActivityReadDriver",
            "docstring": "L6 Driver for activity read operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (risk computation, signal synthesis) stay in L5.",
            "methods": [
              "__init__",
              "count_runs",
              "fetch_runs",
              "fetch_run_detail",
              "fetch_status_summary",
              "fetch_runs_with_policy_context",
              "fetch_at_risk_runs",
              "fetch_metrics",
              "fetch_threshold_signals",
              "fetch_dimension_breakdown"
            ],
            "line": 48
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 6,
    "violation_count": 0,
    "gap_count": 2
  },
  "incidents": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/incidents.py",
    "l2_apis": [
      {
        "file_name": "cost_guard.py",
        "file_path": "backend/app/hoc/api/cus/incidents/cost_guard.py",
        "layer": "L2_api",
        "domain": "incidents",
        "lines": 484,
        "module_docstring": "Guard Console Cost Visibility API - Customer Cost Transparency\n\nM29 Category 4: Cost Intelligence Completion\n\nThis router provides /guard/costs/* endpoints for the Customer Console.\nCustomers see their own cost data with calm vocabulary.\n\nTHE INVARIANT: All values derive from complete snapshots, never live data.\nCustomer sees ONLY their own tenant data - no cross-tenant leakage.\n\nEndpoints:\n- GET  /guard/costs/summary    - Cost summary with trend and projection\n- GET  /guard/costs/explained  - Why costs are what they are\n- GET  /guard/costs/incidents  - Cost-related incidents\n\nCRITICAL: Uses FROZEN DTOs from app.contracts.guard.\nNEVER expose founder-only fields (affected_tenants, churn_risk, etc.).\n\nREFACTORED: All session.execute() calls moved to L6 driver via L4 handler.\nL2 now uses registry dispatch for all DB operations.",
        "functions": [
          {
            "name": "_map_trend",
            "signature": "(deviation_pct: Optional[float]) -> tuple[Literal['normal', 'rising', 'spike'], str]",
            "docstring": "Map deviation to customer-friendly trend.",
            "is_async": false,
            "line": 73
          },
          {
            "name": "_map_severity_to_status",
            "signature": "(severity: str) -> Literal['protected', 'attention_needed', 'resolved']",
            "docstring": "Map internal severity to calm vocabulary.",
            "is_async": false,
            "line": 88
          },
          {
            "name": "_generate_summary",
            "signature": "(by_feature: List[CostBreakdownItemDTO], by_model: List[CostBreakdownItemDTO], total_spend: int) -> str",
            "docstring": "Generate a one-sentence summary of cost drivers.",
            "is_async": false,
            "line": 98
          },
          {
            "name": "_dispatch",
            "signature": "(session, tenant_id: str, method: str, **params)",
            "docstring": "Dispatch to L4 registry for cost_guard operations.",
            "is_async": true,
            "line": 124
          },
          {
            "name": "get_cost_summary",
            "signature": "(tenant_id: str = Query(..., description='Your tenant ID'), token: CustomerToken = Depends(verify_console_token), session = Depends(get_sync_session_dep)) -> CustomerCostSummaryDTO",
            "docstring": "GET /guard/costs/summary\n\nCustomer cost summary with trend and projection.\nUses calm vocabulary: normal, rising, spike (not critical/high/medium).\n\nShows:\n- Today spend, MTD spend, 7d spend\n- Budget usage (if configured)\n- Projected month-end\n- Trend with human-readable message",
            "is_async": true,
            "line": 144
          },
          {
            "name": "get_cost_explained",
            "signature": "(tenant_id: str = Query(..., description='Your tenant ID'), period: Literal['today', '7d', '30d'] = Query('7d'), token: CustomerToken = Depends(verify_console_token), session = Depends(get_sync_session_dep)) -> CustomerCostExplainedDTO",
            "docstring": "GET /guard/costs/explained\n\nExplains WHY costs are what they are.\nBreaks down by feature, model, and user.\n\nDoes NOT expose:\n- churn_risk_score (founder only)\n- affected_tenants (founder only)\n- stickiness_delta (founder only)",
            "is_async": true,
            "line": 232
          },
          {
            "name": "get_cost_incidents",
            "signature": "(tenant_id: str = Query(..., description='Your tenant ID'), include_resolved: bool = Query(False), limit: int = Query(20, ge=1, le=100), token: CustomerToken = Depends(verify_console_token), session = Depends(get_sync_session_dep)) -> CustomerCostIncidentListDTO",
            "docstring": "GET /guard/costs/incidents\n\nCost-related incidents visible to customer.\nUses calm vocabulary (protected, attention_needed).\nDoes NOT expose severity levels directly.",
            "is_async": true,
            "line": 388
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Literal",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "CustomerToken",
              "verify_console_token"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.contracts.guard",
            "names": [
              "CostBreakdownItemDTO",
              "CustomerCostExplainedDTO",
              "CustomerCostIncidentDTO",
              "CustomerCostIncidentListDTO",
              "CustomerCostSummaryDTO"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_operation_registry",
              "get_sync_session_dep",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incidents.py",
        "file_path": "backend/app/hoc/api/cus/incidents/incidents.py",
        "layer": "L2_api",
        "domain": "incidents",
        "lines": 1922,
        "module_docstring": "Unified Incidents API (L2)\n\nCustomer-facing endpoints for viewing incidents.\nAll requests are tenant-scoped via auth_context.\n\nEndpoints:\n- GET /incidents                        \u2192 O2 list with filters\n- GET /incidents/{incident_id}          \u2192 O3 detail\n- GET /incidents/{incident_id}/evidence \u2192 O4 context (preflight)\n- GET /incidents/{incident_id}/proof    \u2192 O5 raw (preflight)\n- GET /incidents/{incident_id}/learnings \u2192 O4 post-mortem learnings\n- GET /incidents/by-run/{run_id}        \u2192 Incidents linked to run\n- GET /incidents/patterns               \u2192 ACT-O5 pattern detection\n- GET /incidents/recurring              \u2192 HIST-O3 recurrence analysis\n- GET /incidents/cost-impact            \u2192 RES-O3 cost impact analysis\n\nArchitecture:\n- ONE facade for all INCIDENTS needs\n- Tenant isolation via auth_context (not header)\n- SDSR validates this same production API",
        "functions": [
          {
            "name": "require_preflight",
            "signature": "() -> None",
            "docstring": "Guard for preflight-only endpoints (O4, O5).",
            "is_async": false,
            "line": 67
          },
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 452
          },
          {
            "name": "list_incidents",
            "signature": "(request: Request, topic: Annotated[Topic | None, Query(description='UX Topic: ACTIVE or RESOLVED')] = None, lifecycle_state: Annotated[LifecycleState | None, Query(description='Direct lifecycle state filter')] = None, severity: Annotated[Severity | None, Query(description='Filter by severity')] = None, category: Annotated[str | None, Query(description='Filter by category')] = None, cause_type: Annotated[CauseType | None, Query(description='Filter by cause type')] = None, is_synthetic: Annotated[bool | None, Query(description='Filter by synthetic data flag')] = None, created_after: Annotated[datetime | None, Query(description='Filter incidents created after')] = None, created_before: Annotated[datetime | None, Query(description='Filter incidents created before')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max incidents to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of incidents to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.CREATED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session = Depends(get_session_dep)) -> IncidentListResponse",
            "docstring": "List incidents with unified query filters. Tenant-scoped.",
            "is_async": true,
            "line": 511
          },
          {
            "name": "get_incidents_for_run",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> IncidentsByRunResponse",
            "docstring": "Get all incidents linked to a specific run. Tenant-scoped.",
            "is_async": true,
            "line": 628
          },
          {
            "name": "detect_patterns",
            "signature": "(request: Request, window_hours: Annotated[int, Query(ge=1, le=168, description='Hours to look back (max 168 = 7 days)')] = 24, limit: Annotated[int, Query(ge=1, le=50, description='Max patterns per type')] = 10, session = Depends(get_session_dep)) -> PatternDetectionResponse",
            "docstring": "Detect incident patterns. Tenant-scoped.",
            "is_async": true,
            "line": 694
          },
          {
            "name": "analyze_recurrence",
            "signature": "(request: Request, baseline_days: Annotated[int, Query(ge=1, le=90, description='Days to analyze (max 90)')] = 30, recurrence_threshold: Annotated[int, Query(ge=2, le=100, description='Min occurrences to flag as recurring')] = 3, limit: Annotated[int, Query(ge=1, le=50, description='Max groups to return')] = 20, session = Depends(get_session_dep)) -> RecurrenceAnalysisResponse",
            "docstring": "Analyze recurring incident patterns. Tenant-scoped.",
            "is_async": true,
            "line": 751
          },
          {
            "name": "analyze_cost_impact",
            "signature": "(request: Request, baseline_days: Annotated[int, Query(ge=1, le=90, description='Days to analyze (max 90)')] = 30, limit: Annotated[int, Query(ge=1, le=50, description='Max categories to return')] = 20, session = Depends(get_session_dep)) -> CostImpactResponse",
            "docstring": "Analyze cost impact across incidents. Tenant-scoped.",
            "is_async": true,
            "line": 816
          },
          {
            "name": "list_active_incidents",
            "signature": "(request: Request, severity: Annotated[Severity | None, Query(description='Filter by severity')] = None, category: Annotated[str | None, Query(description='Filter by category')] = None, cause_type: Annotated[CauseType | None, Query(description='Filter by cause type')] = None, is_synthetic: Annotated[bool | None, Query(description='Filter by synthetic data flag')] = None, created_after: Annotated[datetime | None, Query(description='Filter incidents created after')] = None, created_before: Annotated[datetime | None, Query(description='Filter incidents created before')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max incidents to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of incidents to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.CREATED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session = Depends(get_session_dep)) -> IncidentListResponse",
            "docstring": "List ACTIVE incidents. Topic enforced at endpoint boundary.",
            "is_async": true,
            "line": 883
          },
          {
            "name": "list_resolved_incidents",
            "signature": "(request: Request, severity: Annotated[Severity | None, Query(description='Filter by severity')] = None, category: Annotated[str | None, Query(description='Filter by category')] = None, cause_type: Annotated[CauseType | None, Query(description='Filter by cause type')] = None, is_synthetic: Annotated[bool | None, Query(description='Filter by synthetic data flag')] = None, resolved_after: Annotated[datetime | None, Query(description='Filter incidents resolved after')] = None, resolved_before: Annotated[datetime | None, Query(description='Filter incidents resolved before')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max incidents to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of incidents to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.RESOLVED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session = Depends(get_session_dep)) -> IncidentListResponse",
            "docstring": "List RESOLVED incidents. Topic enforced at endpoint boundary.",
            "is_async": true,
            "line": 988
          },
          {
            "name": "list_historical_incidents",
            "signature": "(request: Request, retention_days: Annotated[int, Query(ge=7, le=365, description='Retention window in days')] = 30, severity: Annotated[Severity | None, Query(description='Filter by severity')] = None, category: Annotated[str | None, Query(description='Filter by category')] = None, cause_type: Annotated[CauseType | None, Query(description='Filter by cause type')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max incidents to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of incidents to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.RESOLVED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session = Depends(get_session_dep)) -> IncidentListResponse",
            "docstring": "List HISTORICAL incidents (resolved beyond retention). Topic enforced.",
            "is_async": true,
            "line": 1093
          },
          {
            "name": "get_incident_metrics",
            "signature": "(request: Request, window_days: Annotated[int, Query(ge=1, le=90, description='Window in days')] = 30, session = Depends(get_session_dep)) -> IncidentMetricsResponse",
            "docstring": "Get incident metrics. Backend-computed, deterministic.",
            "is_async": true,
            "line": 1194
          },
          {
            "name": "get_historical_trend",
            "signature": "(request: Request, window_days: Annotated[int, Query(ge=7, le=365, description='Window in days')] = 90, granularity: Annotated[str, Query(description='Aggregation granularity')] = 'week', session = Depends(get_session_dep)) -> HistoricalTrendResponse",
            "docstring": "Get historical trend. Backend-computed, deterministic.",
            "is_async": true,
            "line": 1251
          },
          {
            "name": "get_historical_distribution",
            "signature": "(request: Request, window_days: Annotated[int, Query(ge=7, le=365, description='Window in days')] = 90, session = Depends(get_session_dep)) -> HistoricalDistributionResponse",
            "docstring": "Get historical distribution. Backend-computed, deterministic.",
            "is_async": true,
            "line": 1316
          },
          {
            "name": "get_historical_cost_trend",
            "signature": "(request: Request, window_days: Annotated[int, Query(ge=7, le=365, description='Window in days')] = 90, granularity: Annotated[str, Query(description='Aggregation granularity')] = 'week', session = Depends(get_session_dep)) -> CostTrendResponse",
            "docstring": "Get historical cost trend. Backend-computed, deterministic.",
            "is_async": true,
            "line": 1376
          },
          {
            "name": "get_incident_detail",
            "signature": "(request: Request, incident_id: str, session = Depends(get_session_dep)) -> IncidentDetailResponse",
            "docstring": "Get incident detail (O3). Tenant isolation enforced.",
            "is_async": true,
            "line": 1437
          },
          {
            "name": "get_incident_evidence",
            "signature": "(request: Request, incident_id: str) -> dict[str, Any]",
            "docstring": "Get incident evidence (O4). Preflight console only.",
            "is_async": true,
            "line": 1499
          },
          {
            "name": "get_incident_proof",
            "signature": "(request: Request, incident_id: str) -> dict[str, Any]",
            "docstring": "Get incident proof (O5). Preflight console only.",
            "is_async": true,
            "line": 1526
          },
          {
            "name": "get_incident_learnings",
            "signature": "(request: Request, incident_id: str, session = Depends(get_session_dep)) -> LearningsResponse",
            "docstring": "Get post-mortem learnings for an incident. Tenant-scoped.",
            "is_async": true,
            "line": 1561
          },
          {
            "name": "export_evidence",
            "signature": "(request: Request, incident_id: str, export_request: ExportRequest) -> Any",
            "docstring": "Export incident evidence bundle.",
            "is_async": true,
            "line": 1660
          },
          {
            "name": "export_soc2",
            "signature": "(request: Request, incident_id: str, export_request: ExportRequest) -> Any",
            "docstring": "Export SOC2-compliant bundle as PDF.",
            "is_async": true,
            "line": 1753
          },
          {
            "name": "export_executive_debrief",
            "signature": "(request: Request, incident_id: str, export_request: ExportRequest) -> Any",
            "docstring": "Export executive debrief as PDF.",
            "is_async": true,
            "line": 1846
          }
        ],
        "classes": [
          {
            "name": "LifecycleState",
            "docstring": "Incident lifecycle state.",
            "methods": [],
            "line": 84
          },
          {
            "name": "Severity",
            "docstring": "Incident severity.",
            "methods": [],
            "line": 92
          },
          {
            "name": "CauseType",
            "docstring": "Incident cause type.",
            "methods": [],
            "line": 101
          },
          {
            "name": "Topic",
            "docstring": "UX topic for filtering.",
            "methods": [],
            "line": 109
          },
          {
            "name": "SortField",
            "docstring": "Allowed sort fields.",
            "methods": [],
            "line": 116
          },
          {
            "name": "SortOrder",
            "docstring": "Sort direction.",
            "methods": [],
            "line": 124
          },
          {
            "name": "IncidentSummary",
            "docstring": "Incident summary for list view (O2).",
            "methods": [],
            "line": 136
          },
          {
            "name": "Pagination",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 164
          },
          {
            "name": "IncidentListResponse",
            "docstring": "GET /incidents response.",
            "methods": [],
            "line": 172
          },
          {
            "name": "IncidentDetailResponse",
            "docstring": "GET /incidents/{incident_id} response (O3).",
            "methods": [],
            "line": 182
          },
          {
            "name": "IncidentsByRunResponse",
            "docstring": "GET /incidents/by-run/{run_id} response.",
            "methods": [],
            "line": 218
          },
          {
            "name": "PatternMatchResponse",
            "docstring": "A detected incident pattern.",
            "methods": [],
            "line": 231
          },
          {
            "name": "PatternDetectionResponse",
            "docstring": "GET /incidents/patterns response (ACT-O5).",
            "methods": [],
            "line": 241
          },
          {
            "name": "RecurrenceGroupResponse",
            "docstring": "A group of recurring incidents.",
            "methods": [],
            "line": 256
          },
          {
            "name": "RecurrenceAnalysisResponse",
            "docstring": "GET /incidents/recurring response (HIST-O3).",
            "methods": [],
            "line": 269
          },
          {
            "name": "CostImpactSummary",
            "docstring": "Cost impact summary for an incident category.",
            "methods": [],
            "line": 283
          },
          {
            "name": "CostImpactResponse",
            "docstring": "GET /incidents/cost-impact response (RES-O3).",
            "methods": [],
            "line": 293
          },
          {
            "name": "IncidentMetricsResponse",
            "docstring": "GET /incidents/metrics response - Dedicated metrics capability.",
            "methods": [],
            "line": 307
          },
          {
            "name": "HistoricalTrendDataPoint",
            "docstring": "A single data point in a historical trend.",
            "methods": [],
            "line": 340
          },
          {
            "name": "HistoricalTrendResponse",
            "docstring": "GET /incidents/historical/trend response.",
            "methods": [],
            "line": 349
          },
          {
            "name": "HistoricalDistributionEntry",
            "docstring": "A single entry in the distribution.",
            "methods": [],
            "line": 359
          },
          {
            "name": "HistoricalDistributionResponse",
            "docstring": "GET /incidents/historical/distribution response.",
            "methods": [],
            "line": 368
          },
          {
            "name": "CostTrendDataPoint",
            "docstring": "A single data point in the cost trend.",
            "methods": [],
            "line": 379
          },
          {
            "name": "CostTrendResponse",
            "docstring": "GET /incidents/historical/cost-trend response.",
            "methods": [],
            "line": 388
          },
          {
            "name": "LearningInsightResponse",
            "docstring": "A learning insight from incident analysis.",
            "methods": [],
            "line": 404
          },
          {
            "name": "ResolutionSummaryResponse",
            "docstring": "Summary of incident resolution.",
            "methods": [],
            "line": 413
          },
          {
            "name": "LearningsResponse",
            "docstring": "GET /incidents/{id}/learnings response (RES-O4).",
            "methods": [],
            "line": 426
          },
          {
            "name": "ExportFormat",
            "docstring": "Export format options.",
            "methods": [],
            "line": 1632
          },
          {
            "name": "ExportRequest",
            "docstring": "Request for export with optional parameters.",
            "methods": [],
            "line": 1639
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [
          {
            "name": "_CURRENT_ENVIRONMENT",
            "line": 64
          }
        ],
        "all_exports": null
      }
    ],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "hallucination_detector.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/hallucination_detector.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 467,
        "module_docstring": "Module: hallucination_detector\nPurpose: Detect potential hallucinations in LLM outputs.\n\nCRITICAL INVARIANT (INV-002 / HALLU-INV-001):\n    Hallucination detection is ALWAYS non-blocking by default.\n    This is because:\n    - Hallucination detection is PROBABILISTIC (60-90% confidence)\n    - Policy violations (cost, rate, PII) are DETERMINISTIC (facts)\n    - False positives on hallucination blocking destroy customer trust\n    - Blocking requires explicit customer opt-in\n\nImports (Dependencies):\n    - dataclasses: Detection result structures\n    - hashlib: Content hashing for evidence\n\nExports (Provides):\n    - HallucinationDetector: Main detection service\n    - HallucinationResult: Detection result dataclass\n    - HallucinationIndicator: Individual indicator dataclass\n    - HallucinationType: Type of hallucination detected\n\nWiring Points:\n    - Called from: worker/runner.py after step completion\n    - Calls: incident_engine.create_incident() with blocking=False",
        "functions": [
          {
            "name": "create_detector_for_tenant",
            "signature": "(tenant_config: Optional[dict[str, Any]] = None) -> HallucinationDetector",
            "docstring": "Create a detector configured for a specific tenant.\n\nArgs:\n    tenant_config: Optional tenant-specific configuration\n\nReturns:\n    Configured HallucinationDetector\n\nCRITICAL (INV-002): blocking_enabled requires explicit tenant opt-in.",
            "is_async": false,
            "line": 445
          }
        ],
        "classes": [
          {
            "name": "HallucinationType",
            "docstring": "Types of hallucination indicators.",
            "methods": [],
            "line": 56
          },
          {
            "name": "HallucinationSeverity",
            "docstring": "Severity levels for hallucination detections.",
            "methods": [],
            "line": 78
          },
          {
            "name": "HallucinationIndicator",
            "docstring": "Individual hallucination indicator.\n\nRepresents a single piece of evidence suggesting hallucination.\nMultiple indicators combine to form overall confidence.",
            "methods": [
              "to_dict"
            ],
            "line": 88
          },
          {
            "name": "HallucinationResult",
            "docstring": "Result of hallucination detection.\n\nContains overall assessment and individual indicators.",
            "methods": [
              "to_incident_data",
              "_derive_severity"
            ],
            "line": 116
          },
          {
            "name": "HallucinationConfig",
            "docstring": "Configuration for hallucination detection.\n\nINV-002 COMPLIANCE:\n    - blocking_enabled defaults to False\n    - blocking_enabled=True requires explicit customer opt-in",
            "methods": [],
            "line": 167
          },
          {
            "name": "HallucinationDetector",
            "docstring": "Hallucination detection service.\n\nCRITICAL INVARIANT (INV-002 / HALLU-INV-001):\n    This service MUST be non-blocking by default.\n    Hallucination detection is PROBABILISTIC, not DETERMINISTIC.\n    False positives on blocking destroy customer trust.\n\nDetection feeds OBSERVABILITY path, not SPINE.\nCustomer must explicitly opt-in for blocking behavior.",
            "methods": [
              "__init__",
              "detect",
              "_detect_suspicious_urls",
              "_detect_suspicious_citations",
              "_detect_contradictions",
              "_detect_temporal_issues",
              "_hash_content"
            ],
            "line": 195
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incident_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 910,
        "module_docstring": "Incident Engine (L4 Domain Logic)\n\nThis engine implements the SDSR cross-domain propagation contract:\n- Run failure (Activity domain) \u2192 Incident creation (Incidents domain)\n\nPer PIN-370 Rule 6 (Scenarios Inject Causes, Not Consequences):\n- Scenarios inject a failed run\n- This engine AUTOMATICALLY creates incidents\n- If incident doesn't appear, the ENGINE is broken, not the scenario\n\nDECISIONS (L4 - stay here):\n- Severity mapping from error codes\n- Category mapping from error codes\n- Policy suppression decision\n- Title generation\n- Policy proposal creation decision\n\nPERSISTENCE (L6 - delegated to driver):\n- INSERT into incidents\n- INSERT into prevention_records\n- INSERT into policy_proposals\n- UPDATE runs, aos_traces\n\nReference: PIN-370, PIN-468, INCIDENTS-EXEC-FAILURE-001",
        "functions": [
          {
            "name": "get_incident_engine",
            "signature": "(evidence_recorder: Any = None) -> IncidentEngine",
            "docstring": "Get or create singleton incident engine instance.\n\nArgs:\n    evidence_recorder: Optional evidence recorder (lessons coordinator).\n        If not provided, engine runs without evidence recording.\n        L4 callers should use incidents_bridge.evidence_recorder_capability()\n        to get the lessons coordinator implementation.\n\nPIN-520: Removed orchestrator import - L5 must not import L4 orchestrator.\nCallers that need evidence recording should inject via L4 bridge.",
            "is_async": false,
            "line": 894
          }
        ],
        "classes": [
          {
            "name": "IncidentEngine",
            "docstring": "L4 Domain Engine for incident creation.\n\nThis engine implements the SDSR cross-domain propagation:\nActivity (cause) \u2192 Incidents (reactive)\n\nSDSR Contract (PIN-370):\n- This engine is called when a run fails\n- It creates an incident record automatically\n- Incidents are NEVER created by scenarios directly\n- If incidents don't appear for failed runs, THIS ENGINE is broken\n\nCallers:\n- Worker runtime (on run failure)\n- inject_synthetic.py expectations validator\n\nPIN-468 Phase-2.5A:\n- All DB operations delegated to IncidentWriteDriver\n- Engine contains ONLY decision logic\n- No sqlalchemy/sqlmodel imports at runtime",
            "methods": [
              "__init__",
              "_get_driver",
              "_check_policy_suppression",
              "_write_prevention_record",
              "create_incident_for_run",
              "create_incident_for_failed_run",
              "_maybe_create_policy_proposal",
              "_generate_title",
              "check_and_create_incident",
              "create_incident_for_all_runs",
              "_extract_error_code",
              "get_incidents_for_run"
            ],
            "line": 158
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_write_driver",
            "names": [
              "IncidentWriteDriver",
              "get_incident_write_driver"
            ],
            "is_relative": false,
            "line": 76
          }
        ],
        "constants": [
          {
            "name": "INCIDENT_OUTCOME_SUCCESS",
            "line": 115
          },
          {
            "name": "INCIDENT_OUTCOME_FAILURE",
            "line": 116
          },
          {
            "name": "INCIDENT_OUTCOME_BLOCKED",
            "line": 117
          },
          {
            "name": "INCIDENT_OUTCOME_ABORTED",
            "line": 118
          },
          {
            "name": "SEVERITY_NONE",
            "line": 121
          },
          {
            "name": "FAILURE_SEVERITY_MAP",
            "line": 124
          },
          {
            "name": "FAILURE_CATEGORY_MAP",
            "line": 143
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "incident_read_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_read_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 153,
        "module_docstring": "Incident Read Service (L4)\n\nThis service provides all READ operations for the Incidents domain.\nIt delegates to IncidentReadDriver (L6) for all database access.\n\nL3 (Adapter) \u2192 L4 (this service) \u2192 L6 (IncidentReadDriver)\n\nResponsibilities:\n- Delegate to L6 driver for data access\n- Apply business rules (if any)\n- Maintain backward compatibility for callers\n\nReference: PIN-281, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_read_service",
            "signature": "(session: 'Session') -> IncidentReadService",
            "docstring": "Factory function to get IncidentReadService instance.",
            "is_async": false,
            "line": 145
          }
        ],
        "classes": [
          {
            "name": "IncidentReadService",
            "docstring": "L4 service for incident read operations.\n\nDelegates all database operations to IncidentReadDriver (L6).\nMaintains backward compatibility for existing callers.\n\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "list_incidents",
              "get_incident",
              "get_incident_events",
              "count_incidents_since",
              "get_last_incident"
            ],
            "line": 59
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_read_driver",
            "names": [
              "IncidentReadDriver",
              "get_incident_read_driver"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentReadService",
          "get_incident_read_service"
        ]
      },
      {
        "file_name": "incident_write_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_write_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 317,
        "module_docstring": "Incident Write Service (L4)\n\nThis service provides all WRITE operations for the Incidents domain.\nIt delegates DB access to IncidentWriteDriver (L6) and applies business logic.\n\nL3 (Adapter) \u2192 L4 (this service) \u2192 L6 (IncidentWriteDriver)\n\nResponsibilities:\n- Acknowledge incidents (audit emit + delegate DB to driver)\n- Resolve incidents (audit emit + delegate DB to driver)\n- Transaction orchestration (begin/commit/rollback)\n- Audit event emission (L4 responsibility)\n- NO direct DB access - driver calls only\n\nReference: PIN-281, PIN-413, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_write_service",
            "signature": "(session: 'Session', audit: Any = None) -> IncidentWriteService",
            "docstring": "Factory function to get IncidentWriteService instance.\n\nArgs:\n    session: SQLAlchemy sync Session\n    audit: Optional audit service (injected by L4 handler for cross-domain audit)",
            "is_async": false,
            "line": 303
          }
        ],
        "classes": [
          {
            "name": "IncidentWriteService",
            "docstring": "L5 engine for incident write operations.\n\nDelegates DB operations to IncidentWriteDriver (L6).\nMaintains business logic (audit events, transactions) in L5.\nAudit service is injected by L4 handler (PIN-504: no cross-domain imports).\n\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "acknowledge_incident",
              "resolve_incident",
              "manual_close_incident"
            ],
            "line": 64
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_write_driver",
            "names": [
              "IncidentWriteDriver",
              "get_incident_write_driver"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.domain_enums",
            "names": [
              "ActorType"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentWriteService",
          "get_incident_write_service"
        ]
      },
      {
        "file_name": "incidents_facade.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incidents_facade.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 1195,
        "module_docstring": "Incidents Domain Facade (L5)\n\nUnified facade for incident management operations.\n\nProvides:\n- List incidents: active, resolved, historical\n- Get incident detail\n- Get incidents by run\n- Pattern detection (ACT-O5)\n- Recurrence analysis (HIST-O3)\n- Cost impact analysis (RES-O3)\n- Metrics\n- Historical trend/distribution/cost-trend\n- Post-mortem learnings (RES-O4)\n\nAll operations are tenant-scoped for isolation.\n\nArchitecture:\n- Facade \u2192 Driver (L6) for DB operations\n- Facade \u2192 Engine (L4) for business logic delegation\n- No direct sqlalchemy imports",
        "functions": [
          {
            "name": "get_incidents_facade",
            "signature": "() -> IncidentsFacade",
            "docstring": "Get the singleton IncidentsFacade instance.",
            "is_async": false,
            "line": 1154
          }
        ],
        "classes": [
          {
            "name": "IncidentSummaryResult",
            "docstring": "Incident summary for list view (O2).",
            "methods": [],
            "line": 68
          },
          {
            "name": "PaginationResult",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 90
          },
          {
            "name": "IncidentListResult",
            "docstring": "Incidents list response.",
            "methods": [],
            "line": 99
          },
          {
            "name": "IncidentDetailResult",
            "docstring": "Incident detail response (O3).",
            "methods": [],
            "line": 115
          },
          {
            "name": "IncidentsByRunResult",
            "docstring": "Incidents by run response.",
            "methods": [],
            "line": 144
          },
          {
            "name": "PatternMatchResult",
            "docstring": "A detected incident pattern.",
            "methods": [],
            "line": 158
          },
          {
            "name": "PatternDetectionResult",
            "docstring": "Pattern detection response.",
            "methods": [],
            "line": 169
          },
          {
            "name": "RecurrenceGroupResult",
            "docstring": "A group of recurring incidents.",
            "methods": [],
            "line": 185
          },
          {
            "name": "RecurrenceAnalysisResult",
            "docstring": "Recurrence analysis response.",
            "methods": [],
            "line": 199
          },
          {
            "name": "CostImpactSummaryResult",
            "docstring": "Cost impact summary for an incident category.",
            "methods": [],
            "line": 214
          },
          {
            "name": "CostImpactResult",
            "docstring": "Cost impact analysis response.",
            "methods": [],
            "line": 225
          },
          {
            "name": "IncidentMetricsResult",
            "docstring": "Incident metrics response.",
            "methods": [],
            "line": 240
          },
          {
            "name": "HistoricalTrendDataPointResult",
            "docstring": "A single data point in a historical trend.",
            "methods": [],
            "line": 268
          },
          {
            "name": "HistoricalTrendResult",
            "docstring": "Historical trend response.",
            "methods": [],
            "line": 278
          },
          {
            "name": "HistoricalDistributionEntryResult",
            "docstring": "A single entry in the distribution.",
            "methods": [],
            "line": 289
          },
          {
            "name": "HistoricalDistributionResult",
            "docstring": "Historical distribution response.",
            "methods": [],
            "line": 299
          },
          {
            "name": "CostTrendDataPointResult",
            "docstring": "A single data point in the cost trend.",
            "methods": [],
            "line": 311
          },
          {
            "name": "CostTrendResult",
            "docstring": "Cost trend response.",
            "methods": [],
            "line": 321
          },
          {
            "name": "LearningInsightResult",
            "docstring": "A learning insight from incident analysis.",
            "methods": [],
            "line": 338
          },
          {
            "name": "ResolutionSummaryResult",
            "docstring": "Summary of incident resolution.",
            "methods": [],
            "line": 348
          },
          {
            "name": "LearningsResult",
            "docstring": "Incident learnings response.",
            "methods": [],
            "line": 362
          },
          {
            "name": "IncidentsFacade",
            "docstring": "Unified facade for incident management.\n\nProvides:\n- List incidents: active, resolved, historical\n- Get incident detail\n- Get incidents by run\n- Metrics\n- Cost impact analysis\n\nAll operations are tenant-scoped for isolation.\n\nArchitecture:\n- Delegates DB operations to IncidentsFacadeDriver (L6)\n- No direct sqlalchemy access",
            "methods": [
              "list_active_incidents",
              "list_resolved_incidents",
              "list_historical_incidents",
              "list_incidents",
              "get_incident_detail",
              "get_incidents_for_run",
              "get_metrics",
              "analyze_cost_impact",
              "get_historical_trend",
              "get_historical_distribution",
              "get_historical_cost_trend",
              "_snapshot_to_summary",
              "detect_patterns",
              "analyze_recurrence",
              "get_incident_learnings"
            ],
            "line": 377
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incidents_facade_driver",
            "names": [
              "IncidentsFacadeDriver",
              "IncidentSnapshot"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentsFacade",
          "get_incidents_facade",
          "IncidentSummaryResult",
          "PaginationResult",
          "IncidentListResult",
          "IncidentDetailResult",
          "IncidentsByRunResult",
          "PatternMatchResult",
          "PatternDetectionResult",
          "RecurrenceGroupResult",
          "RecurrenceAnalysisResult",
          "CostImpactSummaryResult",
          "CostImpactResult",
          "IncidentMetricsResult",
          "HistoricalTrendDataPointResult",
          "HistoricalTrendResult",
          "HistoricalDistributionEntryResult",
          "HistoricalDistributionResult",
          "CostTrendDataPointResult",
          "CostTrendResult",
          "LearningInsightResult",
          "ResolutionSummaryResult",
          "LearningsResult"
        ]
      },
      {
        "file_name": "incidents_types.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incidents_types.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 44,
        "module_docstring": "Incidents Domain Shared Types\n\nCanonical type aliases used across multiple engines in the incidents domain.\nThis file consolidates duplicated type definitions (INC-DUP-008).\n\nUsage:\n    from app.hoc.cus.incidents.L5_engines.incidents_types import (\n        UuidFn,\n        ClockFn,\n    )",
        "functions": [],
        "classes": [],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Callable"
            ],
            "is_relative": false,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": [
          "UuidFn",
          "ClockFn"
        ]
      },
      {
        "file_name": "policy_violation_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/policy_violation_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 725,
        "module_docstring": "Policy Violation Service - S3 Hardening for Phase A.5 Verification\n\nThis service implements the S3 truth model from PIN-195:\n1. Violation detection\n2. Violation fact persistence\n3. Incident creation (severity-bound)\n4. Evidence linking\n5. API + Console exposure\n\nCritical invariants (VERIFICATION_MODE):\n- No incident may exist without a persisted violation fact\n- Policy must be enabled for tenant\n- Evidence must exist before incident creation\n- One incident per (run_id, policy_id)\n- Cost and policy systems don't interfere\n\nSee PIN-195 for full acceptance criteria.",
        "functions": [
          {
            "name": "create_policy_evaluation_record",
            "signature": "(session: 'AsyncSession', run_id: str, tenant_id: str, outcome: str, policies_checked: int = 0, reason: str = '', draft_candidate: bool = False, is_synthetic: bool = False, synthetic_scenario_id: Optional[str] = None) -> str",
            "docstring": "Create a policy evaluation record for ANY run (PIN-407).\n\nEvery run MUST produce exactly one policy evaluation record.\nThis is NOT limited to violations - successful evaluations also get records.\n\nArgs:\n    session: Database session\n    run_id: Run ID\n    tenant_id: Tenant scope\n    outcome: Policy outcome (NO_VIOLATION, VIOLATION, ADVISORY, NOT_APPLICABLE)\n    policies_checked: Number of policies evaluated\n    reason: Human-readable reason\n    draft_candidate: If True, this run is a candidate for policy learning\n    is_synthetic: True if from SDSR scenario\n    synthetic_scenario_id: Scenario ID for traceability\n\nReturns:\n    policy_evaluation_id\n\nDECISION: Confidence calculation based on outcome (business rule).\nPERSISTENCE: Delegated to driver.",
            "is_async": true,
            "line": 471
          },
          {
            "name": "handle_policy_evaluation_for_run",
            "signature": "(session: 'AsyncSession', run_id: str, tenant_id: str, run_status: str, policies_checked: int = 0, is_synthetic: bool = False, synthetic_scenario_id: Optional[str] = None) -> str",
            "docstring": "Create a policy evaluation record for ANY run (PIN-407).\n\nThis is the NEW primary entry point for run \u2192 policy evaluation propagation.\nEvery run creates exactly one policy evaluation record with explicit outcome.\n\nArgs:\n    session: Database session\n    run_id: Run ID\n    tenant_id: Tenant scope\n    run_status: Run status (succeeded, failed, etc.)\n    policies_checked: Number of policies evaluated\n    is_synthetic: True if from SDSR scenario\n    synthetic_scenario_id: Scenario ID for traceability\n\nReturns:\n    policy_evaluation_id",
            "is_async": true,
            "line": 538
          },
          {
            "name": "handle_policy_violation",
            "signature": "(session: 'AsyncSession', run_id: str, tenant_id: str, policy_type: str, policy_id: str, violated_rule: str, reason: str, severity: str = 'medium', evidence: Optional[Dict[str, Any]] = None) -> Optional[ViolationIncident]",
            "docstring": "Handle a policy violation with S3 truth guarantees.\n\nThis is the main entry point for policy violation handling.\nCall this from workers.py when a policy violation is detected.\n\nReturns ViolationIncident if incident was created, None if skipped.",
            "is_async": true,
            "line": 595
          },
          {
            "name": "create_policy_evaluation_sync",
            "signature": "(run_id: str, tenant_id: str, run_status: str, policies_checked: int = 0, is_synthetic: bool = False, synthetic_scenario_id: Optional[str] = None) -> Optional[str]",
            "docstring": "Create a policy evaluation record for ANY run (PIN-407) - SYNC VERSION.\n\nThis is a synchronous wrapper for use in worker contexts where we don't\nhave an async session. Uses psycopg2 with L6 driver.\n\nArgs:\n    run_id: Run ID\n    tenant_id: Tenant scope\n    run_status: Run status (succeeded, failed, etc.)\n    policies_checked: Number of policies evaluated\n    is_synthetic: True if from SDSR scenario\n    synthetic_scenario_id: Scenario ID for traceability\n    conn: Pre-created psycopg2 connection from L4 handler.\n        L4 owns the connection lifecycle and commit. Required.\n\nReturns:\n    policy_evaluation_id if created, None if failed\n\nDECISION: Map run status to policy outcome (business rule).\nPERSISTENCE: Delegated to L6 driver. Transaction owned by L4 when conn provided.",
            "is_async": false,
            "line": 637
          }
        ],
        "classes": [
          {
            "name": "ViolationFact",
            "docstring": "Authoritative violation fact - must be persisted before incident creation.\n\nThis is the \"fact\" that PIN-195 AC-1 requires:\n- Linked to run_id\n- Linked to tenant_id\n- Linked to policy_id\n- Contains violated_rule\n- Contains evaluated_value\n- Contains threshold/condition\n- Contains timestamp",
            "methods": [],
            "line": 84
          },
          {
            "name": "ViolationIncident",
            "docstring": "Result of creating an incident from a violation.",
            "methods": [],
            "line": 114
          },
          {
            "name": "PolicyViolationService",
            "docstring": "Service for handling policy violations with S3 truth guarantees.\n\nUsage:\n    service = PolicyViolationService(session)\n\n    # Create violation fact first\n    violation = ViolationFact(\n        run_id=\"...\",\n        tenant_id=\"...\",\n        policy_id=\"content_accuracy_v1\",\n        violated_rule=\"CA001\",\n        ...\n\nNote: All DB operations are delegated to PolicyViolationDriver (L6).\nThis engine contains only business logic decisions.\n    )\n\n    # Persist and create incident\n    result = await service.persist_violation_and_create_incident(violation)",
            "methods": [
              "__init__",
              "persist_violation_fact",
              "check_violation_persisted",
              "check_policy_enabled",
              "persist_evidence",
              "check_incident_exists",
              "create_incident_from_violation",
              "persist_violation_and_create_incident",
              "verify_violation_truth"
            ],
            "line": 123
          },
          {
            "name": "PolicyEvaluationResult",
            "docstring": "Result of policy evaluation (PIN-407: Success as First-Class Data).\n\nEvery run MUST produce exactly one policy evaluation record.\nThis is NOT limited to violations - successful evaluations also get records.",
            "methods": [],
            "line": 453
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.policy_violation_driver",
            "names": [
              "PolicyViolationDriver",
              "get_policy_violation_driver"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.utils.runtime",
            "names": [
              "generate_uuid"
            ],
            "is_relative": false,
            "line": 75
          }
        ],
        "constants": [
          {
            "name": "VERIFICATION_MODE",
            "line": 80
          },
          {
            "name": "POLICY_OUTCOME_NO_VIOLATION",
            "line": 446
          },
          {
            "name": "POLICY_OUTCOME_VIOLATION",
            "line": 447
          },
          {
            "name": "POLICY_OUTCOME_ADVISORY",
            "line": 448
          },
          {
            "name": "POLICY_OUTCOME_NOT_APPLICABLE",
            "line": 449
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "recovery_rule_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/recovery_rule_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 802,
        "module_docstring": "Rule-based evaluation engine for recovery suggestions.\n\nEvaluates a set of rules against failure context and returns\nscored action recommendations.\n\nRules can be:\n1. Error code matching (exact or prefix)\n2. Historical pattern matching\n3. Skill-specific rules\n4. Tenant-specific overrides\n5. Time-based rules (e.g., different behavior during incidents)\n\nEnvironment Variables:\n- RECOVERY_RULE_DEBUG: Enable debug logging for rule evaluation",
        "functions": [
          {
            "name": "combine_confidences",
            "signature": "(rule_confidence: float, match_confidence: float) -> float",
            "docstring": "Combine rule and matcher confidence scores.\n\nThis is an L4 domain decision. L5 workers must NOT implement their own formulas.\n\nArgs:\n    rule_confidence: Confidence from rule evaluation (0.0 to 1.0)\n    match_confidence: Confidence from pattern matching (0.0 to 1.0)\n\nReturns:\n    Combined confidence score (0.0 to 1.0)\n\nReference: PIN-257 Phase E-4 Extraction #3",
            "is_async": false,
            "line": 613
          },
          {
            "name": "should_select_action",
            "signature": "(combined_confidence: float) -> bool",
            "docstring": "Determine if an action should be selected based on combined confidence.\n\nThis is an L4 domain decision. L5 workers must NOT hardcode thresholds.\n\nArgs:\n    combined_confidence: Combined confidence score (0.0 to 1.0)\n\nReturns:\n    True if confidence meets threshold for action selection\n\nReference: PIN-257 Phase E-4 Extraction #3",
            "is_async": false,
            "line": 631
          },
          {
            "name": "should_auto_execute",
            "signature": "(confidence: float) -> bool",
            "docstring": "Determine if a recovery action should be auto-executed based on confidence.\n\nThis is an L4 domain decision. L5 workers must NOT hardcode thresholds.\n\nArgs:\n    confidence: Combined confidence score (0.0 to 1.0)\n\nReturns:\n    True if confidence meets threshold for auto-execution",
            "is_async": false,
            "line": 648
          },
          {
            "name": "classify_error_category",
            "signature": "(error_codes: List[str]) -> str",
            "docstring": "Classify error codes into a category.\n\nThis is an L4 domain decision. L5 workers must NOT implement their own heuristics.\n\nArgs:\n    error_codes: List of error codes to classify\n\nReturns:\n    Category string (TRANSIENT, PERMISSION, RESOURCE, VALIDATION, INFRASTRUCTURE, PLANNER, PERMANENT)",
            "is_async": false,
            "line": 675
          },
          {
            "name": "suggest_recovery_mode",
            "signature": "(error_codes: List[str]) -> str",
            "docstring": "Suggest a recovery mode based on error codes.\n\nThis is an L4 domain decision. L5 workers must NOT implement their own heuristics.\n\nArgs:\n    error_codes: List of error codes to analyze\n\nReturns:\n    Recovery mode string (RETRY_EXPONENTIAL, RETRY_WITH_JITTER, ESCALATE, ABORT)",
            "is_async": false,
            "line": 706
          },
          {
            "name": "evaluate_rules",
            "signature": "(error_code: str, error_message: str, skill_id: Optional[str] = None, tenant_id: Optional[str] = None, occurrence_count: int = 1, historical_matches: Optional[List[Dict[str, Any]]] = None, custom_rules: Optional[List[Rule]] = None) -> EvaluationResult",
            "docstring": "Convenience function to evaluate rules against a failure.\n\nArgs:\n    error_code: The error code (e.g., \"TIMEOUT\", \"HTTP_503\")\n    error_message: The raw error message\n    skill_id: Optional skill ID\n    tenant_id: Optional tenant ID\n    occurrence_count: How many times this failure has occurred\n    historical_matches: Historical similar failures\n    custom_rules: Custom rules to add to evaluation\n\nReturns:\n    EvaluationResult with recommendation",
            "is_async": false,
            "line": 732
          }
        ],
        "classes": [
          {
            "name": "RuleContext",
            "docstring": "Context provided to rules for evaluation.",
            "methods": [
              "to_dict"
            ],
            "line": 56
          },
          {
            "name": "RuleResult",
            "docstring": "Result from evaluating a single rule.",
            "methods": [
              "to_dict"
            ],
            "line": 83
          },
          {
            "name": "EvaluationResult",
            "docstring": "Complete result from rule evaluation.",
            "methods": [
              "to_dict"
            ],
            "line": 109
          },
          {
            "name": "Rule",
            "docstring": "Base class for recovery rules.",
            "methods": [
              "__init__",
              "evaluate",
              "__repr__"
            ],
            "line": 135
          },
          {
            "name": "ErrorCodeRule",
            "docstring": "Match based on error code patterns.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 158
          },
          {
            "name": "HistoricalPatternRule",
            "docstring": "Match based on historical success patterns.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 193
          },
          {
            "name": "SkillSpecificRule",
            "docstring": "Rules specific to certain skills.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 267
          },
          {
            "name": "OccurrenceThresholdRule",
            "docstring": "Escalate based on occurrence count.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 297
          },
          {
            "name": "CompositeRule",
            "docstring": "Combine multiple rules with AND/OR logic.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 331
          },
          {
            "name": "RecoveryRuleEngine",
            "docstring": "Evaluates rules against failure context to recommend recovery actions.\n\nUsage:\n    engine = RecoveryRuleEngine()\n    result = engine.evaluate(context)\n    print(result.recommended_action)",
            "methods": [
              "__init__",
              "add_rule",
              "remove_rule",
              "evaluate"
            ],
            "line": 473
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [
          {
            "name": "DEBUG_MODE",
            "line": 47
          }
        ],
        "all_exports": [
          "Rule",
          "RuleContext",
          "RuleResult",
          "EvaluationResult",
          "ErrorCodeRule",
          "HistoricalPatternRule",
          "SkillSpecificRule",
          "OccurrenceThresholdRule",
          "CompositeRule",
          "RecoveryRuleEngine",
          "evaluate_rules",
          "DEFAULT_RULES",
          "AUTO_EXECUTE_CONFIDENCE_THRESHOLD",
          "should_auto_execute",
          "ERROR_CATEGORY_RULES",
          "classify_error_category",
          "RECOVERY_MODE_RULES",
          "suggest_recovery_mode",
          "ACTION_SELECTION_THRESHOLD",
          "combine_confidences",
          "should_select_action"
        ]
      },
      {
        "file_name": "semantic_failures.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/semantic_failures.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 298,
        "module_docstring": "Semantic Failures \u2014 Canonical failure taxonomy for two-phase validation.\n\nTwo Phases:\n- Phase A: Intent Guardrails (INT-*) \u2014 design-time, human-facing\n- Phase B: Semantic Reality (SEM-*) \u2014 proof-time, system-facing\n\nEach failure code has:\n- Name: Human-readable name\n- Class: INTENT_VIOLATION or SEMANTIC_VIOLATION\n- Severity: BLOCKING or WARNING\n- Fix Owner: Who is responsible for fixing\n- Fix Action: What action to take\n\nThis taxonomy ensures violations are actionable, not just noise.",
        "functions": [
          {
            "name": "get_failure_info",
            "signature": "(code: FailureCode) -> Dict[str, Any]",
            "docstring": "Get failure taxonomy info for a code (INT-* or SEM-*).",
            "is_async": false,
            "line": 267
          },
          {
            "name": "get_fix_owner",
            "signature": "(code: FailureCode) -> str",
            "docstring": "Get the fix owner for a failure code.",
            "is_async": false,
            "line": 280
          },
          {
            "name": "get_fix_action",
            "signature": "(code: FailureCode) -> str",
            "docstring": "Get the fix action for a failure code.",
            "is_async": false,
            "line": 285
          },
          {
            "name": "get_violation_class",
            "signature": "(code: FailureCode) -> ViolationClass",
            "docstring": "Get the violation class for a failure code.",
            "is_async": false,
            "line": 290
          },
          {
            "name": "format_violation_message",
            "signature": "(code: FailureCode, context_msg: str) -> str",
            "docstring": "Format a violation message with context.",
            "is_async": false,
            "line": 295
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Union"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "semantic_types",
            "names": [
              "FailureCode",
              "IntentFailureCode",
              "SemanticFailureCode",
              "SemanticSeverity",
              "ViolationClass"
            ],
            "is_relative": true,
            "line": 43
          }
        ],
        "constants": [
          {
            "name": "SEMANTIC_FAILURE_TAXONOMY",
            "line": 257
          },
          {
            "name": "INTENT_FAILURE_TAXONOMY",
            "line": 262
          }
        ],
        "all_exports": null
      }
    ],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "export_bundle_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/export_bundle_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 434,
        "module_docstring": "Export Bundle Service\n\nGenerates structured export bundles from incidents, runs, and traces\nfor evidence export, SOC2 compliance, and executive debriefs.\n\nKey Responsibilities:\n1. Load incident, run, and trace data\n2. Assemble EvidenceBundle with all cross-domain links\n3. Enhance for SOC2 compliance (control mappings)\n4. Generate executive summary (non-technical)",
        "functions": [
          {
            "name": "get_export_bundle_driver",
            "signature": "() -> ExportBundleDriver",
            "docstring": "Get or create ExportBundleDriver singleton.",
            "is_async": false,
            "line": 425
          }
        ],
        "classes": [
          {
            "name": "TraceStorePort",
            "docstring": null,
            "methods": [
              "get_trace_summary",
              "get_trace_steps"
            ],
            "line": 61
          },
          {
            "name": "ExportBundleDriver",
            "docstring": "Generate structured export bundles from incidents/traces.",
            "methods": [
              "__init__",
              "trace_store",
              "create_evidence_bundle",
              "create_soc2_bundle",
              "create_executive_debrief",
              "_compute_bundle_hash",
              "_generate_attestation",
              "_assess_risk_level",
              "_generate_incident_summary",
              "_assess_business_impact",
              "_generate_recommendations"
            ],
            "line": 69
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.db",
            "names": [
              "Run",
              "engine"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.models.export_bundles",
            "names": [
              "DEFAULT_SOC2_CONTROLS",
              "EvidenceBundle",
              "ExecutiveDebriefBundle",
              "PolicyContext",
              "SOC2Bundle",
              "TraceStepEvidence"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incident_aggregator.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_aggregator.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 614,
        "module_docstring": "Incident Aggregation Driver - Prevents Incident Explosion Under Load\n\nThis service implements intelligent incident grouping to prevent thousands of\nmicro-incidents during large outages. It uses a sliding window approach with\nconfigurable thresholds.\n\nKey Features:\n1. Time-window aggregation (default 5 minutes)\n2. Tenant + trigger_type grouping key\n3. Rate limiting (max 1 incident per key per window)\n4. Auto-escalation for high-volume windows\n5. Incident merging for related failures\n\nWatchpoint #1: Incident Explosion Under Load\n- During a 1000-request outage, we create 1 incident, not 1000\n- Related calls are added to the incident's related_call_ids\n- Severity auto-escalates based on affected call count\n\nARCHITECTURE RULE (LESSONS_ENFORCED.md Invariant #10):\n- This service MUST be constructed with explicit dependency injection\n- NO lazy service resolution (get_incident_aggregator is BANNED)\n- All collaborators (clock, uuid_fn) MUST be passed via constructor\n- Verification scripts and production MUST use the same constructor pattern",
        "functions": [
          {
            "name": "create_incident_aggregator",
            "signature": "(config: Optional[IncidentAggregatorConfig] = None) -> IncidentAggregator",
            "docstring": "Create an IncidentAggregator with canonical dependencies.\n\nThis is the ONLY sanctioned way to create an aggregator.\nUses generate_uuid and utc_now from app.utils.runtime.\n\nUsage:\n    aggregator = create_incident_aggregator()\n    # or with custom config:\n    aggregator = create_incident_aggregator(config=IncidentAggregatorConfig(...))",
            "is_async": false,
            "line": 596
          }
        ],
        "classes": [
          {
            "name": "IncidentAggregatorConfig",
            "docstring": "Configuration for incident aggregation behavior (L6 persistence config only).",
            "methods": [],
            "line": 80
          },
          {
            "name": "IncidentKey",
            "docstring": "Grouping key for incident aggregation.\n\nIncidents are grouped by:\n- tenant_id: Isolation between tenants\n- trigger_type: Type of failure (failure_spike, budget_breach, rate_limit)\n- window_start: 5-minute bucketed window",
            "methods": [
              "__hash__",
              "__eq__",
              "from_event"
            ],
            "line": 105
          },
          {
            "name": "IncidentAggregator",
            "docstring": "L6 Driver for intelligent incident aggregation.\n\nPrevents incident explosion by:\n1. Grouping related failures into single incidents\n2. Rate limiting incident creation per tenant\n3. Auto-escalating severity based on impact (delegated to L4 engine)\n4. Merging calls into existing open incidents\n\nINVARIANT #10: Explicit Dependency Injection Required\n- clock: Function that returns current UTC datetime\n- uuid_fn: Function that generates UUID strings\n- severity_engine: L4 engine for severity decisions (optional, defaults to standard)\n- These MUST be passed explicitly, not resolved lazily\n\nEXTRACTION NOTE (2026-01-24):\nSeverity logic extracted to incident_severity_engine.py (L4).\nThis driver delegates severity decisions to the engine.",
            "methods": [
              "__init__",
              "get_or_create_incident",
              "_find_open_incident",
              "_can_create_incident",
              "_get_rate_limit_incident",
              "_create_incident",
              "_add_call_to_incident",
              "_add_incident_event",
              "resolve_stale_incidents",
              "get_incident_stats"
            ],
            "line": 147
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "Optional",
              "Tuple",
              "cast"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "and_",
              "select"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.incidents.L5_schemas.severity_policy",
            "names": [
              "IncidentSeverityEngine",
              "SeverityConfig",
              "generate_incident_title"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentEvent",
              "IncidentSeverity",
              "IncidentStatus"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.utils.runtime",
            "names": [
              "generate_uuid",
              "utc_now"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incident_pattern_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_pattern_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 255,
        "module_docstring": "Incident Pattern Driver (L6)\n\nPure database operations for incident pattern detection.\nAll business logic stays in L4 engine.\n\nOperations:\n- Incident count queries\n- Category cluster aggregation\n- Severity spike detection\n- Cascade failure grouping\n\nNO business logic:\n- NO confidence calculation (L4)\n- NO threshold decisions (L4)\n- NO pattern type determination (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_pattern_driver",
            "signature": "(session: AsyncSession) -> IncidentPatternDriver",
            "docstring": "Factory function to get IncidentPatternDriver instance.",
            "is_async": false,
            "line": 247
          }
        ],
        "classes": [
          {
            "name": "IncidentPatternDriver",
            "docstring": "L6 driver for incident pattern detection operations (async).\n\nPure database access - no business logic.\nAll operations are READ-ONLY.",
            "methods": [
              "__init__",
              "fetch_incidents_count",
              "fetch_category_clusters",
              "fetch_severity_spikes",
              "fetch_cascade_failures"
            ],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 68
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentPatternDriver",
          "get_incident_pattern_driver"
        ]
      },
      {
        "file_name": "incident_read_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_read_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 212,
        "module_docstring": "Incident Read Driver (L6)\n\nPure data access layer for incident read operations.\nNo business logic - only query construction and data retrieval.\n\nArchitecture:\n    L3 (Adapter) \u2192 L4 (Engine) \u2192 L6 (this driver) \u2192 Database\n\nOperations:\n- Query incidents with tenant isolation\n- Query incident events\n- Count queries\n- No mutations (read-only)\n\nReference: PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_read_driver",
            "signature": "(session: Session) -> IncidentReadDriver",
            "docstring": "Factory function to get IncidentReadDriver instance.",
            "is_async": false,
            "line": 201
          }
        ],
        "classes": [
          {
            "name": "IncidentReadDriver",
            "docstring": "L6 driver for incident read operations.\n\nPure data access - no business logic.\nAll methods require tenant_id for isolation.",
            "methods": [
              "__init__",
              "list_incidents",
              "get_incident",
              "get_incident_events",
              "count_incidents_since",
              "get_last_incident"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentEvent"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentReadDriver",
          "get_incident_read_driver"
        ]
      },
      {
        "file_name": "incident_write_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_write_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 611,
        "module_docstring": "Incident Write Driver (L6)\n\nPure database write operations for incidents.\nAll business logic stays in L4 engine.\n\nOperations:\n- Create incidents from run failures/successes\n- Create prevention records (policy suppression)\n- Create policy proposals\n- Update incident state (acknowledge, resolve)\n- Update related tables (runs.incident_count, aos_traces.incident_id)\n- Create incident events (timeline)\n\nNO business logic:\n- NO severity/category mapping (L4)\n- NO policy suppression decisions (L4)\n- NO proposal creation decisions (L4)\n\nReference: PIN-281, PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_write_driver",
            "signature": "(session: Session) -> IncidentWriteDriver",
            "docstring": "Factory function to get IncidentWriteDriver instance.",
            "is_async": false,
            "line": 600
          }
        ],
        "classes": [
          {
            "name": "IncidentWriteDriver",
            "docstring": "L6 driver for incident write operations.\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "update_incident_acknowledged",
              "update_incident_resolved",
              "create_incident_event",
              "refresh_incident",
              "insert_incident",
              "update_run_incident_count",
              "update_trace_incident_id",
              "insert_prevention_record",
              "insert_policy_proposal",
              "fetch_suppressing_policy",
              "fetch_incidents_by_run_id",
              "insert_incident_from_anomaly"
            ],
            "line": 86
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 79
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 80
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentEvent",
              "IncidentStatus"
            ],
            "is_relative": false,
            "line": 83
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentWriteDriver",
          "get_incident_write_driver"
        ]
      },
      {
        "file_name": "incidents_facade_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incidents_facade_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 807,
        "module_docstring": "Incidents Facade Driver (L6)\n\nPure database access layer for the incidents facade.\nReturns snapshots (dicts/dataclasses), not ORM models.\n\nResponsibilities:\n- Execute queries against incidents table\n- Return data snapshots\n- NO business logic\n- NO result type composition (that's L4's job)\n\nThis driver was extracted from incidents_facade.py per HOC Layer Topology V1.",
        "functions": [],
        "classes": [
          {
            "name": "IncidentSnapshot",
            "docstring": "Raw incident data snapshot from database.",
            "methods": [],
            "line": 53
          },
          {
            "name": "IncidentListSnapshot",
            "docstring": "Paginated list of incident snapshots.",
            "methods": [],
            "line": 77
          },
          {
            "name": "MetricsSnapshot",
            "docstring": "Raw metrics aggregates from database.",
            "methods": [],
            "line": 85
          },
          {
            "name": "CostImpactRowSnapshot",
            "docstring": "Single row from cost impact query.",
            "methods": [],
            "line": 105
          },
          {
            "name": "HistoricalTrendRowSnapshot",
            "docstring": "Single row from historical trend query.",
            "methods": [],
            "line": 116
          },
          {
            "name": "HistoricalDistributionRowSnapshot",
            "docstring": "Single row from distribution query.",
            "methods": [],
            "line": 126
          },
          {
            "name": "CostTrendRowSnapshot",
            "docstring": "Single row from cost trend query.",
            "methods": [],
            "line": 135
          },
          {
            "name": "IncidentsFacadeDriver",
            "docstring": "L6 Database driver for incidents facade.\n\nPure data access - no business logic.\nReturns snapshots, not ORM models.",
            "methods": [
              "__init__",
              "fetch_active_incidents",
              "fetch_resolved_incidents",
              "fetch_historical_incidents",
              "fetch_incident_by_id",
              "fetch_incidents_by_run",
              "fetch_metrics_aggregates",
              "fetch_cost_impact_data",
              "fetch_all_incidents",
              "fetch_historical_trend",
              "fetch_historical_distribution",
              "fetch_historical_cost_trend",
              "_to_snapshot"
            ],
            "line": 148
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select",
              "text"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentsFacadeDriver",
          "IncidentSnapshot",
          "IncidentListSnapshot",
          "MetricsSnapshot",
          "CostImpactRowSnapshot",
          "HistoricalTrendRowSnapshot",
          "HistoricalDistributionRowSnapshot",
          "CostTrendRowSnapshot"
        ]
      },
      {
        "file_name": "lessons_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/lessons_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 649,
        "module_docstring": "Lessons Driver (L6)\n\nPure database operations for lessons_learned table.\nAll business logic stays in L4 engine.\n\nOperations:\n- Create lessons from various triggers\n- Query lessons with filters\n- Update lesson state (defer, dismiss, convert, reactivate)\n- Debounce checks\n- Scheduler support (expired deferred)\n\nNO business logic:\n- NO state machine validation (L4)\n- NO debounce decisions (L4)\n- NO severity mapping (L4)\n- NO description generation (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_lessons_driver",
            "signature": "(session: Session) -> LessonsDriver",
            "docstring": "Factory function to get LessonsDriver instance.",
            "is_async": false,
            "line": 641
          }
        ],
        "classes": [
          {
            "name": "LessonsDriver",
            "docstring": "L6 driver for lessons_learned operations.\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "insert_lesson",
              "fetch_lesson_by_id",
              "fetch_lessons_list",
              "fetch_lesson_stats",
              "update_lesson_deferred",
              "update_lesson_dismissed",
              "update_lesson_converted",
              "update_lesson_reactivated",
              "fetch_debounce_count",
              "fetch_expired_deferred",
              "insert_policy_proposal_from_lesson"
            ],
            "line": 83
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 79
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 80
          }
        ],
        "constants": [],
        "all_exports": [
          "LessonsDriver",
          "get_lessons_driver"
        ]
      },
      {
        "file_name": "llm_failure_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/llm_failure_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 331,
        "module_docstring": "LLM Failure Driver (L6)\n\nPure database operations for LLM failure handling.\nAll business logic stays in L4 engine.\n\nOperations:\n- Create failure facts\n- Create evidence records\n- Mark runs as failed\n- Contamination verification (read-only)\n\nNO business logic:\n- NO invariant checking (L4)\n- NO verification mode decisions (L4)\n- NO failure type validation (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_llm_failure_driver",
            "signature": "(session: AsyncSession) -> LLMFailureDriver",
            "docstring": "Factory function to get LLMFailureDriver instance.",
            "is_async": false,
            "line": 323
          }
        ],
        "classes": [
          {
            "name": "LLMFailureDriver",
            "docstring": "L6 driver for LLM failure operations (async).\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "insert_failure",
              "insert_evidence",
              "update_run_failed",
              "fetch_failure_by_run_id",
              "fetch_contamination_check"
            ],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 71
          }
        ],
        "constants": [],
        "all_exports": [
          "LLMFailureDriver",
          "get_llm_failure_driver"
        ]
      },
      {
        "file_name": "policy_violation_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/policy_violation_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 481,
        "module_docstring": "Policy Violation Driver (L6)\n\nPure database operations for policy violation handling.\nAll business logic stays in L4 engine.\n\nOperations:\n- Create violation facts\n- Check violation/policy existence\n- Create evidence events\n- Policy evaluation records (both async and sync patterns)\n\nNO business logic:\n- NO outcome mapping (L4)\n- NO verification mode decisions (L4)\n- NO validation decisions (L4)\n- NO severity mapping (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "insert_policy_evaluation_sync_with_cursor",
            "signature": "(cursor, evaluation_id: str, run_id: str, tenant_id: str, outcome: str, policies_checked: int, confidence: float, created_at: datetime, is_synthetic: bool, synthetic_scenario_id: Optional[str]) -> Optional[str]",
            "docstring": "Insert policy evaluation record using provided cursor.\n\nL6 Contract:\n    - Cursor REQUIRED (passed from L4 owner)\n    - L6 does NOT commit (L4 owns transaction boundary)\n\nArgs:\n    cursor: psycopg2 cursor from L4 owner\n    evaluation_id: Generated evaluation ID\n    run_id: Run being evaluated\n    tenant_id: Tenant scope\n    outcome: Policy outcome\n    policies_checked: Number of policies checked\n    confidence: Match confidence\n    created_at: Timestamp\n    is_synthetic: SDSR flag\n    synthetic_scenario_id: Scenario ID for SDSR\n\nReturns:\n    evaluation_id if inserted, None if conflict",
            "is_async": false,
            "line": 408
          },
          {
            "name": "get_policy_violation_driver",
            "signature": "(session: AsyncSession) -> PolicyViolationDriver",
            "docstring": "Factory function to get PolicyViolationDriver instance.",
            "is_async": false,
            "line": 472
          }
        ],
        "classes": [
          {
            "name": "PolicyViolationDriver",
            "docstring": "L6 driver for policy violation operations (async).\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "insert_violation_record",
              "fetch_violation_exists",
              "fetch_policy_enabled",
              "insert_evidence_event",
              "fetch_incident_by_violation",
              "fetch_violation_truth_check",
              "insert_policy_evaluation"
            ],
            "line": 82
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 73
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 77
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyViolationDriver",
          "get_policy_violation_driver",
          "insert_policy_evaluation_sync_with_cursor"
        ]
      },
      {
        "file_name": "postmortem_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/postmortem_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 316,
        "module_docstring": "Post-Mortem Driver (L6)\n\nPure database operations for post-mortem analytics.\nAll business logic stays in L4 engine.\n\nOperations:\n- Category statistics queries\n- Resolution method aggregation\n- Recurrence rate calculation\n- Similar incident lookup\n\nNO business logic:\n- NO insight generation (L4)\n- NO confidence calculation (L4)\n- NO pattern analysis (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_postmortem_driver",
            "signature": "(session: AsyncSession) -> PostMortemDriver",
            "docstring": "Factory function to get PostMortemDriver instance.",
            "is_async": false,
            "line": 308
          }
        ],
        "classes": [
          {
            "name": "PostMortemDriver",
            "docstring": "L6 driver for post-mortem analytics operations (async).\n\nPure database access - no business logic.\nAll operations are READ-ONLY.",
            "methods": [
              "__init__",
              "fetch_category_stats",
              "fetch_resolution_methods",
              "fetch_recurrence_data",
              "fetch_resolution_summary",
              "fetch_similar_incidents"
            ],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 68
          }
        ],
        "constants": [],
        "all_exports": [
          "PostMortemDriver",
          "get_postmortem_driver"
        ]
      },
      {
        "file_name": "recurrence_analysis_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/recurrence_analysis_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 213,
        "module_docstring": "Recurrence Analysis Driver (L6)\n\nPure database access layer for recurrence analysis.\nReturns snapshots (dicts/dataclasses), not ORM models.\n\nResponsibilities:\n- Execute queries against incidents table for recurrence patterns\n- Return data snapshots\n- NO business logic\n- NO threshold decisions (that's L4's job)\n\nThis driver was extracted from recurrence_analysis_service.py per HOC Layer Topology V1.",
        "functions": [],
        "classes": [
          {
            "name": "RecurrenceGroupSnapshot",
            "docstring": "Raw recurrence group data from database.",
            "methods": [],
            "line": 51
          },
          {
            "name": "RecurrenceAnalysisDriver",
            "docstring": "L6 Database driver for recurrence analysis.\n\nPure data access - no business logic.\nReturns snapshots, not computed analysis.",
            "methods": [
              "__init__",
              "fetch_recurrence_groups",
              "fetch_recurrence_for_category"
            ],
            "line": 69
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "RecurrenceAnalysisDriver",
          "RecurrenceGroupSnapshot"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 22,
    "violation_count": 0,
    "gap_count": 2
  },
  "policies": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/policies.py",
    "l2_apis": [
      {
        "file_name": "M25_integrations.py",
        "file_path": "backend/app/hoc/api/cus/policies/M25_integrations.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1384,
        "module_docstring": "M25 Integration API\n\nEndpoints for:\n- Loop status monitoring\n- Human checkpoint resolution\n- Integration statistics\n- Retry/revert operations\n- Graduation status (M25 learning proof)\n- Prevention timeline (Gate 3)",
        "functions": [
          {
            "name": "get_tenant_id_from_token",
            "signature": "(token: FounderToken = Depends(verify_fops_token)) -> str",
            "docstring": "Get tenant ID from founder token - PIN-318 secure implementation.",
            "is_async": false,
            "line": 55
          },
          {
            "name": "get_current_user_from_token",
            "signature": "(token: FounderToken = Depends(verify_fops_token)) -> dict",
            "docstring": "Get current user from founder token - PIN-318 secure implementation.",
            "is_async": false,
            "line": 61
          },
          {
            "name": "get_tenant_id",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID')) -> str",
            "docstring": "DEPRECATED: Get tenant ID from query parameter. Use get_tenant_id_from_token instead.",
            "is_async": false,
            "line": 67
          },
          {
            "name": "get_current_user",
            "signature": "(user_id: Optional[str] = Query(None, description='User ID')) -> Optional[dict]",
            "docstring": "DEPRECATED: Get current user from query parameter. Use get_current_user_from_token instead.",
            "is_async": false,
            "line": 72
          },
          {
            "name": "get_loop_status",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id)) -> LoopStatusResponse",
            "docstring": "Get current loop status for an incident.\n\nReturns the full loop state including:\n- Completed and failed stages\n- Pending human checkpoints\n- Narrative artifacts for storytelling",
            "is_async": true,
            "line": 188
          },
          {
            "name": "get_loop_stages",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id)) -> list[StageDetail]",
            "docstring": "Get detailed stage information for a loop.",
            "is_async": true,
            "line": 232
          },
          {
            "name": "stream_loop_status",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id))",
            "docstring": "SSE endpoint for live loop status updates.\n\nConnect to receive real-time updates as the loop progresses.",
            "is_async": true,
            "line": 269
          },
          {
            "name": "retry_loop_stage",
            "signature": "(incident_id: str, request: RetryStageRequest, tenant_id: str = Depends(get_tenant_id)) -> LoopStatusResponse",
            "docstring": "Retry a failed loop stage.",
            "is_async": true,
            "line": 316
          },
          {
            "name": "revert_loop",
            "signature": "(incident_id: str, request: RevertLoopRequest, tenant_id: str = Depends(get_tenant_id), user: dict = Depends(get_current_user)) -> dict",
            "docstring": "Revert all changes made by a loop.\n\nThis is the ultimate human override - use with caution.",
            "is_async": true,
            "line": 351
          },
          {
            "name": "list_pending_checkpoints",
            "signature": "(tenant_id: str = Depends(get_tenant_id)) -> list[CheckpointResponse]",
            "docstring": "List all pending human checkpoints for the tenant.",
            "is_async": true,
            "line": 386
          },
          {
            "name": "get_checkpoint",
            "signature": "(checkpoint_id: str, tenant_id: str = Depends(get_tenant_id)) -> CheckpointResponse",
            "docstring": "Get details of a specific checkpoint.",
            "is_async": true,
            "line": 416
          },
          {
            "name": "resolve_checkpoint",
            "signature": "(checkpoint_id: str, request: ResolveCheckpointRequest, tenant_id: str = Depends(get_tenant_id), user: dict = Depends(get_current_user)) -> dict",
            "docstring": "Resolve a pending checkpoint.\n\nAvailable resolutions depend on checkpoint type:\n- approve_policy: approve, reject, modify\n- approve_recovery: apply, reject, defer\n- simulate_routing: apply, cancel\n- revert_loop: confirm_revert, cancel",
            "is_async": true,
            "line": 459
          },
          {
            "name": "get_integration_stats",
            "signature": "(tenant_id: str = Depends(get_tenant_id), hours: int = Query(24, ge=1, le=720, description='Period in hours')) -> IntegrationStatsResponse",
            "docstring": "Get integration loop statistics for the specified period.",
            "is_async": true,
            "line": 500
          },
          {
            "name": "get_loop_narrative",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Get narrative artifacts for an incident loop.\n\nReturns storytelling elements:\n- before_after: Before vs After this incident\n- policy_origin: Policy born from this failure\n- agent_improvement: How agent behavior improved",
            "is_async": true,
            "line": 562
          },
          {
            "name": "get_graduation_status",
            "signature": "(tenant_id: str = Depends(get_tenant_id)) -> HardenedGraduationResponse",
            "docstring": "Get M25 graduation status (HARDENED).\n\nCRITICAL: This status is DERIVED from evidence, not manually set.\n\nReturns:\n- Derived graduation level (alpha/beta/candidate/complete/degraded)\n- Gate status with evidence\n- Capability gates (what's unlocked/blocked)\n- Simulation state (separate from real graduation)\n- Degradation info if status has regressed\n\nGraduation is computed from real evidence only:\n- Simulated records are excluded\n- Status is re-evaluated on each call\n- Degradation occurs when evidence regresses",
            "is_async": true,
            "line": 671
          },
          {
            "name": "simulate_prevention",
            "signature": "(request: SimulatePreventionRequest, tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Simulate a prevention event for demo/testing purposes.\n\nIMPORTANT: Simulated records are marked with is_simulated=true\nand DO NOT count toward real graduation.\n\nThis endpoint creates demo data for UI testing only.\nReal graduation requires real prevention evidence.",
            "is_async": true,
            "line": 848
          },
          {
            "name": "simulate_regret",
            "signature": "(request: SimulateRegretRequest, tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Simulate a regret event for demo/testing purposes.\n\nIMPORTANT: Simulated records are marked with is_simulated=true\nand DO NOT count toward real graduation.\n\nThis endpoint creates demo data for UI testing only.\nReal graduation requires real regret/demotion evidence.",
            "is_async": true,
            "line": 915
          },
          {
            "name": "simulate_timeline_view",
            "signature": "(incident_id: str = Query(..., description='Incident ID to mark as viewed in timeline'), tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Simulate viewing a prevention timeline for Gate 3.\n\nIMPORTANT: Simulated views are marked with is_simulated=true\nand DO NOT count toward real graduation.\n\nThis endpoint creates demo data for UI testing only.\nReal graduation requires real timeline views.",
            "is_async": true,
            "line": 972
          },
          {
            "name": "record_timeline_view",
            "signature": "(incident_id: str = Query(..., description='Incident ID viewed in timeline'), has_prevention: bool = Query(False, description='Timeline shows prevention event'), has_rollback: bool = Query(False, description='Timeline shows rollback event'), tenant_id: str = Depends(get_tenant_id), user: dict = Depends(get_current_user)) -> dict",
            "docstring": "Record a REAL timeline view for Gate 3 graduation.\n\nThis endpoint is called by the console when a user ACTUALLY views\nan incident's prevention timeline. This counts toward real graduation.\n\nCall this when:\n- User opens the prevention timeline UI\n- Timeline shows learning proof (prevention or rollback)",
            "is_async": true,
            "line": 1029
          },
          {
            "name": "trigger_graduation_re_evaluation",
            "signature": "(tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Trigger a re-evaluation of graduation status.\n\nThis recalculates graduation level from current evidence.\nUseful after:\n- New prevention/regret events\n- Timeline views recorded\n- Manual verification\n\nNote: Graduation is automatically re-evaluated on GET /graduation,\nbut this endpoint forces a fresh computation and stores history.",
            "is_async": true,
            "line": 1087
          },
          {
            "name": "get_prevention_timeline",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id)) -> PreventionTimelineResponse",
            "docstring": "Get the prevention timeline for an incident.\n\nThis is the Gate 3 UI - shows the learning loop in action:\n1. Original incident detected\n2. Pattern identified\n3. Policy born from failure\n4. (later) Similar incident detected\n5. Policy PREVENTED recurrence\n\nViewing this timeline with a prevention event proves Gate 3.",
            "is_async": true,
            "line": 1224
          }
        ],
        "classes": [
          {
            "name": "LoopStatusResponse",
            "docstring": "Response for loop status endpoint.",
            "methods": [],
            "line": 94
          },
          {
            "name": "StageDetail",
            "docstring": "Detail for a single stage.",
            "methods": [],
            "line": 112
          },
          {
            "name": "CheckpointResponse",
            "docstring": "Response for human checkpoint.",
            "methods": [],
            "line": 123
          },
          {
            "name": "ResolveCheckpointRequest",
            "docstring": "Request to resolve a checkpoint.",
            "methods": [],
            "line": 140
          },
          {
            "name": "IntegrationStatsResponse",
            "docstring": "Statistics for integration loop.",
            "methods": [],
            "line": 146
          },
          {
            "name": "RetryStageRequest",
            "docstring": "Request to retry a failed stage.",
            "methods": [],
            "line": 170
          },
          {
            "name": "RevertLoopRequest",
            "docstring": "Request to revert a loop.",
            "methods": [],
            "line": 176
          },
          {
            "name": "GateEvidenceResponse",
            "docstring": "Evidence for a graduation gate.",
            "methods": [],
            "line": 607
          },
          {
            "name": "CapabilityStatus",
            "docstring": "Status of a capability gate.",
            "methods": [],
            "line": 618
          },
          {
            "name": "SimulationStatus",
            "docstring": "Simulation mode status - separate from real graduation.",
            "methods": [],
            "line": 625
          },
          {
            "name": "HardenedGraduationResponse",
            "docstring": "Hardened graduation status response.\n\nKey differences from v1:\n- Status is DERIVED from evidence, not manually set\n- Includes capability gates (what's unlocked/blocked)\n- Includes simulation status (separate from real)\n- Includes degradation info",
            "methods": [],
            "line": 633
          },
          {
            "name": "SimulatePreventionRequest",
            "docstring": "Request to simulate a prevention event for demo/testing.",
            "methods": [],
            "line": 838
          },
          {
            "name": "SimulateRegretRequest",
            "docstring": "Request to simulate a regret event for demo/testing.",
            "methods": [],
            "line": 905
          },
          {
            "name": "TimelineEventResponse",
            "docstring": "A single event in the prevention timeline.",
            "methods": [],
            "line": 1201
          },
          {
            "name": "PreventionTimelineResponse",
            "docstring": "Response for prevention timeline endpoint.",
            "methods": [],
            "line": 1213
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "fastapi.responses",
            "names": [
              "StreamingResponse"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "FounderToken",
              "verify_fops_token"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_async_session_context",
              "get_operation_registry",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.integrations.events",
            "names": [
              "LoopStage"
            ],
            "is_relative": false,
            "line": 79
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "alerts.py",
        "file_path": "backend/app/hoc/api/cus/policies/alerts.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 446,
        "module_docstring": "Alerts API (L2)\n\nProvides alert operations:\n- POST /alerts/rules (create rule)\n- GET /alerts/rules (list rules)\n- GET /alerts/rules/{id} (get rule)\n- PUT /alerts/rules/{id} (update rule)\n- DELETE /alerts/rules/{id} (delete rule)\n- GET /alerts/history (alert history)\n- GET /alerts/history/{id} (get event)\n- POST /alerts/history/{id}/acknowledge (acknowledge)\n- POST /alerts/history/{id}/resolve (resolve)\n- POST /alerts/routes (create route)\n- GET /alerts/routes (list routes)\n- DELETE /alerts/routes/{id} (delete route)\n\nThis is the ONLY facade for alert operations.\nAll alert APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> AlertsFacade",
            "docstring": "Get the alerts facade.",
            "is_async": false,
            "line": 98
          },
          {
            "name": "create_rule",
            "signature": "(request: CreateRuleRequest, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.write')))",
            "docstring": "Create an alert rule (GAP-110).\n\n**Tier: REACT ($9)** - Alert configuration.\n\nCondition example:\n```json\n{\n    \"metric\": \"cost_daily\",\n    \"operator\": \"gt\",\n    \"threshold\": 1000\n}\n```",
            "is_async": true,
            "line": 109
          },
          {
            "name": "list_rules",
            "signature": "(severity: Optional[str] = Query(None, description='Filter by severity'), enabled_only: bool = Query(False, description='Only enabled rules'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "List alert rules.",
            "is_async": true,
            "line": 144
          },
          {
            "name": "get_rule",
            "signature": "(rule_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "Get a specific alert rule.",
            "is_async": true,
            "line": 173
          },
          {
            "name": "update_rule",
            "signature": "(rule_id: str, request: UpdateRuleRequest, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.write')))",
            "docstring": "Update an alert rule.",
            "is_async": true,
            "line": 194
          },
          {
            "name": "delete_rule",
            "signature": "(rule_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.write')))",
            "docstring": "Delete an alert rule.",
            "is_async": true,
            "line": 222
          },
          {
            "name": "list_history",
            "signature": "(rule_id: Optional[str] = Query(None, description='Filter by rule'), severity: Optional[str] = Query(None, description='Filter by severity'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "List alert history (GAP-111).\n\nReturns triggered alert events with status.",
            "is_async": true,
            "line": 248
          },
          {
            "name": "get_event",
            "signature": "(event_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "Get a specific alert event.",
            "is_async": true,
            "line": 281
          },
          {
            "name": "acknowledge_event",
            "signature": "(event_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.acknowledge')))",
            "docstring": "Acknowledge an alert event.",
            "is_async": true,
            "line": 302
          },
          {
            "name": "resolve_event",
            "signature": "(event_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.resolve')))",
            "docstring": "Resolve an alert event.",
            "is_async": true,
            "line": 326
          },
          {
            "name": "create_route",
            "signature": "(request: CreateRouteRequest, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.routes')))",
            "docstring": "Create an alert route (GAP-124).\n\n**Tier: PREVENT ($199)** - Alert routing configuration.\n\nRoutes determine where alerts are sent based on labels.",
            "is_async": true,
            "line": 355
          },
          {
            "name": "list_routes",
            "signature": "(enabled_only: bool = Query(False, description='Only enabled routes'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "List alert routes.",
            "is_async": true,
            "line": 381
          },
          {
            "name": "get_route",
            "signature": "(route_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "Get a specific alert route.",
            "is_async": true,
            "line": 408
          },
          {
            "name": "delete_route",
            "signature": "(route_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.routes')))",
            "docstring": "Delete an alert route.",
            "is_async": true,
            "line": 429
          }
        ],
        "classes": [
          {
            "name": "CreateRuleRequest",
            "docstring": "Request to create alert rule.",
            "methods": [],
            "line": 63
          },
          {
            "name": "UpdateRuleRequest",
            "docstring": "Request to update alert rule.",
            "methods": [],
            "line": 74
          },
          {
            "name": "CreateRouteRequest",
            "docstring": "Request to create alert route.",
            "methods": [],
            "line": 84
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.alerts_facade",
            "names": [
              "AlertsFacade",
              "get_alerts_facade"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "analytics.py",
        "file_path": "backend/app/hoc/api/cus/policies/analytics.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1128,
        "module_docstring": "Unified Analytics API (L2)\n\nCustomer-facing endpoints for viewing usage statistics.\nAll requests are tenant-scoped via auth_context.\n\nDomain: Analytics\nSubdomain: Statistics\nTopic v1: Usage\n\nEndpoints:\n- GET /analytics/statistics/usage             \u2192 Usage statistics\n- GET /analytics/statistics/usage/export.csv  \u2192 CSV export\n- GET /analytics/statistics/usage/export.json \u2192 JSON export\n- GET /analytics/_status                      \u2192 Capability probe\n\nArchitecture:\n- ONE facade for all ANALYTICS needs\n- Facade normalizes, aggregates, enforces contracts\n- Does NOT compute - delegates to signal adapters\n- Tenant isolation via auth_context (not header)\n- Export endpoints use SAME aggregator (bit-equivalent)",
        "functions": [
          {
            "name": "get_usage_statistics",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session = Depends(get_session_dep)) -> UsageStatisticsResponse",
            "docstring": "Get usage statistics for the specified time window.\n\nThis is the primary read endpoint for the Usage topic.\nREAD-ONLY customer facade - delegates to L4 AnalyticsFacade.",
            "is_async": true,
            "line": 239
          },
          {
            "name": "get_analytics_status",
            "signature": "() -> AnalyticsStatusResponse",
            "docstring": "Analytics capability probe.\n\nUsed by console/clients to discover available capabilities\nbefore attempting to render panels.\nREAD-ONLY customer facade - delegates to L4 operation registry.",
            "is_async": true,
            "line": 371
          },
          {
            "name": "get_cost_statistics",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session = Depends(get_session_dep)) -> CostStatisticsResponse",
            "docstring": "Get cost statistics for the specified time window.\n\nPrimary endpoint for the Cost topic.\nREAD-ONLY customer facade - delegates to L4 operation registry.",
            "is_async": true,
            "line": 438
          },
          {
            "name": "analytics_health",
            "signature": "()",
            "docstring": "Internal health check for analytics facade.",
            "is_async": true,
            "line": 592
          },
          {
            "name": "_get_usage_data",
            "signature": "(request: Request, from_ts: datetime, to_ts: datetime, resolution: ResolutionType, scope: ScopeType, session) -> UsageStatisticsResponse",
            "docstring": "Internal helper to get usage data (shared by read and export endpoints).\n\nEnsures export is bit-equivalent to read API - no alternate code paths.\nDelegates to L4 operation registry.",
            "is_async": true,
            "line": 602
          },
          {
            "name": "export_usage_csv",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session = Depends(get_session_dep)) -> Response",
            "docstring": "Export usage statistics as CSV.\n\nUses the same aggregation logic as the read API.\nDeterministic ordering. UTC only.",
            "is_async": true,
            "line": 722
          },
          {
            "name": "export_usage_json",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session = Depends(get_session_dep)) -> UsageStatisticsResponse",
            "docstring": "Export usage statistics as JSON.\n\nStructure matches the standard usage response.\nBit-equivalent to read API.",
            "is_async": true,
            "line": 808
          },
          {
            "name": "_get_cost_data",
            "signature": "(request: Request, from_ts: datetime, to_ts: datetime, resolution: ResolutionType, scope: ScopeType, session) -> CostStatisticsResponse",
            "docstring": "Internal helper to get cost data (shared by read and export endpoints).\n\nEnsures export is bit-equivalent to read API - no alternate code paths.\nDelegates to L4 operation registry.",
            "is_async": true,
            "line": 855
          },
          {
            "name": "export_cost_csv",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session = Depends(get_session_dep)) -> Response",
            "docstring": "Export cost statistics as CSV.\n\nUses the same aggregation logic as the read API.\nDeterministic ordering. UTC only.",
            "is_async": true,
            "line": 1002
          },
          {
            "name": "export_cost_json",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session = Depends(get_session_dep)) -> CostStatisticsResponse",
            "docstring": "Export cost statistics as JSON.\n\nStructure matches the standard cost response.\nBit-equivalent to read API.",
            "is_async": true,
            "line": 1089
          }
        ],
        "classes": [
          {
            "name": "ResolutionType",
            "docstring": "Time resolution for usage data.",
            "methods": [],
            "line": 73
          },
          {
            "name": "ScopeType",
            "docstring": "Scope of usage aggregation.",
            "methods": [],
            "line": 79
          },
          {
            "name": "TimeWindow",
            "docstring": "Generic time window specification (shared across topics).",
            "methods": [],
            "line": 91
          },
          {
            "name": "UsageWindow",
            "docstring": "Time window specification.",
            "methods": [],
            "line": 106
          },
          {
            "name": "UsageTotals",
            "docstring": "Aggregate usage totals.",
            "methods": [],
            "line": 116
          },
          {
            "name": "UsageDataPoint",
            "docstring": "Single data point in usage time series.",
            "methods": [],
            "line": 123
          },
          {
            "name": "UsageSignals",
            "docstring": "Signal source metadata for provenance.",
            "methods": [],
            "line": 131
          },
          {
            "name": "UsageStatisticsResponse",
            "docstring": "GET /analytics/statistics/usage response (contracted).",
            "methods": [],
            "line": 137
          },
          {
            "name": "CostTotals",
            "docstring": "Aggregate cost totals.",
            "methods": [],
            "line": 150
          },
          {
            "name": "CostDataPoint",
            "docstring": "Single data point in cost time series.",
            "methods": [],
            "line": 159
          },
          {
            "name": "CostByModel",
            "docstring": "Cost breakdown by model.",
            "methods": [],
            "line": 168
          },
          {
            "name": "CostByFeature",
            "docstring": "Cost breakdown by feature tag.",
            "methods": [],
            "line": 178
          },
          {
            "name": "CostSignals",
            "docstring": "Signal source metadata for cost provenance.",
            "methods": [],
            "line": 186
          },
          {
            "name": "CostStatisticsResponse",
            "docstring": "GET /analytics/statistics/cost response (contracted).",
            "methods": [],
            "line": 192
          },
          {
            "name": "TopicStatus",
            "docstring": "Status of a topic within a subdomain.",
            "methods": [],
            "line": 202
          },
          {
            "name": "AnalyticsStatusResponse",
            "docstring": "GET /analytics/_status response.",
            "methods": [],
            "line": 209
          }
        ],
        "imports": [
          {
            "module": "csv",
            "names": [
              "csv"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "io",
            "names": [
              "io"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Dict",
              "List"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "fastapi.responses",
            "names": [
              "Response"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "aos_accounts.py",
        "file_path": "backend/app/hoc/api/cus/policies/aos_accounts.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1475,
        "module_docstring": "Unified Accounts API (L2)\n\nCustomer-facing endpoints for account management: projects, users, profile, billing.\nAll requests are tenant-scoped via auth_context.\n\nIMPORTANT: Account is NOT a domain. It manages:\n- WHO (users, profile)\n- WHAT (projects)\n- BILLING (subscription, invoices)\n\nIt does NOT manage or display:\n- Executions\n- Incidents\n- Policies\n- Logs\n\nEndpoints:\n- GET /accounts/projects            \u2192 O2 list projects\n- GET /accounts/projects/{id}       \u2192 O3 project detail\n- GET /accounts/users               \u2192 O2 list users\n- GET /accounts/users/{id}          \u2192 O3 user detail\n- GET /accounts/profile             \u2192 Current user profile\n- PUT /accounts/profile             \u2192 Update profile\n- GET /accounts/billing             \u2192 Billing summary\n- GET /accounts/billing/invoices    \u2192 Invoice history\n\nArchitecture:\n- ONE facade for all ACCOUNTS needs\n- Tenant isolation via auth_context (not header)\n- SDSR validates this same production API",
        "functions": [
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 82
          },
          {
            "name": "get_user_id_from_auth",
            "signature": "(request: Request) -> str | None",
            "docstring": "Extract user_id from auth_context. Returns None if not available.",
            "is_async": false,
            "line": 106
          },
          {
            "name": "list_projects",
            "signature": "(request: Request, status: Annotated[Optional[str], Query(description='Filter by status: active, suspended', pattern='^(active|suspended)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max items to return')] = 50, offset: Annotated[int, Query(ge=0, description='Rows to skip')] = 0, session = Depends(get_session_dep)) -> ProjectsListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 276
          },
          {
            "name": "get_project_detail",
            "signature": "(request: Request, project_id: str, session = Depends(get_session_dep)) -> ProjectDetailResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 356
          },
          {
            "name": "list_users",
            "signature": "(request: Request, role: Annotated[Optional[str], Query(description='Filter by role: owner, admin, member, viewer', pattern='^(owner|admin|member|viewer)$')] = None, status: Annotated[Optional[str], Query(description='Filter by status: active, suspended', pattern='^(active|suspended)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max items to return')] = 50, offset: Annotated[int, Query(ge=0, description='Rows to skip')] = 0, session = Depends(get_session_dep)) -> UsersListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 431
          },
          {
            "name": "get_user_detail",
            "signature": "(request: Request, user_id: str, session = Depends(get_session_dep)) -> UserDetailResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 519
          },
          {
            "name": "get_profile",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> ProfileResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 589
          },
          {
            "name": "get_billing_summary",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> BillingSummaryResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 647
          },
          {
            "name": "update_profile",
            "signature": "(request: Request, update: ProfileUpdateRequest, session = Depends(get_session_dep)) -> ProfileUpdateResponse",
            "docstring": "WRITE customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 727
          },
          {
            "name": "get_billing_invoices",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> InvoiceListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 808
          },
          {
            "name": "get_support_contact",
            "signature": "() -> SupportContactResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": false,
            "line": 914
          },
          {
            "name": "create_support_ticket",
            "signature": "(request: Request, ticket: SupportTicketCreate, session = Depends(get_session_dep)) -> SupportTicketResponse",
            "docstring": "WRITE customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 942
          },
          {
            "name": "list_support_tickets",
            "signature": "(request: Request, status: Optional[str] = Query(None, description='Filter by status'), session = Depends(get_session_dep)) -> SupportTicketListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 997
          },
          {
            "name": "invite_user",
            "signature": "(request: Request, invite: InviteUserRequest, session = Depends(get_session_dep)) -> InvitationResponse",
            "docstring": "WRITE customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 1117
          },
          {
            "name": "list_invitations",
            "signature": "(request: Request, status: Optional[str] = Query(None, description='Filter by status'), session = Depends(get_session_dep)) -> InvitationListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 1173
          },
          {
            "name": "accept_invitation",
            "signature": "(invitation_id: str, accept: AcceptInvitationRequest, session = Depends(get_session_dep)) -> dict",
            "docstring": "Accept an invitation to join a tenant.\n\nThis is a public endpoint (no auth required) as the user\nmay not have an account yet.\n\nLayer: L2 (Product APIs) \u2014 delegates to L4 AccountsFacade",
            "is_async": true,
            "line": 1237
          },
          {
            "name": "list_tenant_users",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> TenantUserListResponse",
            "docstring": "List users in the current tenant.\n\nLayer: L2 (Product APIs) \u2014 delegates to L4 AccountsFacade",
            "is_async": true,
            "line": 1301
          },
          {
            "name": "update_user_role",
            "signature": "(request: Request, user_id: str, update: UpdateUserRoleRequest, session = Depends(get_session_dep)) -> TenantUserResponse",
            "docstring": "Update a user's role in the tenant.\n\nRequires: owner role.\n\nLayer: L2 (Product APIs) \u2014 delegates to L4 AccountsFacade",
            "is_async": true,
            "line": 1356
          },
          {
            "name": "remove_user",
            "signature": "(request: Request, user_id: str, session = Depends(get_session_dep)) -> dict",
            "docstring": "Remove a user from the tenant.\n\nRequires: owner or admin role.\n\nLayer: L2 (Product APIs) \u2014 delegates to L4 AccountsFacade",
            "is_async": true,
            "line": 1422
          }
        ],
        "classes": [
          {
            "name": "ProjectSummary",
            "docstring": "O2 Result Shape for projects.",
            "methods": [],
            "line": 121
          },
          {
            "name": "ProjectsListResponse",
            "docstring": "GET /projects response (O2).",
            "methods": [],
            "line": 133
          },
          {
            "name": "ProjectDetailResponse",
            "docstring": "GET /projects/{id} response (O3).",
            "methods": [],
            "line": 142
          },
          {
            "name": "UserSummary",
            "docstring": "O2 Result Shape for users.",
            "methods": [],
            "line": 174
          },
          {
            "name": "UsersListResponse",
            "docstring": "GET /users response (O2).",
            "methods": [],
            "line": 186
          },
          {
            "name": "UserDetailResponse",
            "docstring": "GET /users/{id} response (O3).",
            "methods": [],
            "line": 195
          },
          {
            "name": "ProfileResponse",
            "docstring": "GET /profile response.",
            "methods": [],
            "line": 224
          },
          {
            "name": "BillingSummaryResponse",
            "docstring": "GET /billing response.",
            "methods": [],
            "line": 243
          },
          {
            "name": "ProfileUpdateRequest",
            "docstring": "Request to update user profile preferences.",
            "methods": [],
            "line": 707
          },
          {
            "name": "ProfileUpdateResponse",
            "docstring": "Profile update response.",
            "methods": [],
            "line": 715
          },
          {
            "name": "InvoiceSummary",
            "docstring": "Invoice summary for billing history.",
            "methods": [],
            "line": 788
          },
          {
            "name": "InvoiceListResponse",
            "docstring": "List of invoices response.",
            "methods": [],
            "line": 799
          },
          {
            "name": "SupportTicketCreate",
            "docstring": "Create a support ticket.",
            "methods": [],
            "line": 874
          },
          {
            "name": "SupportTicketResponse",
            "docstring": "Support ticket response.",
            "methods": [],
            "line": 883
          },
          {
            "name": "SupportTicketListResponse",
            "docstring": "List of support tickets.",
            "methods": [],
            "line": 898
          },
          {
            "name": "SupportContactResponse",
            "docstring": "Support contact information.",
            "methods": [],
            "line": 905
          },
          {
            "name": "InviteUserRequest",
            "docstring": "Request to invite a user to the tenant.",
            "methods": [],
            "line": 1061
          },
          {
            "name": "InvitationResponse",
            "docstring": "Invitation response.",
            "methods": [],
            "line": 1068
          },
          {
            "name": "InvitationListResponse",
            "docstring": "List of invitations.",
            "methods": [],
            "line": 1080
          },
          {
            "name": "AcceptInvitationRequest",
            "docstring": "Request to accept an invitation.",
            "methods": [],
            "line": 1087
          },
          {
            "name": "UpdateUserRoleRequest",
            "docstring": "Request to update a user's role.",
            "methods": [],
            "line": 1093
          },
          {
            "name": "TenantUserResponse",
            "docstring": "User in tenant response.",
            "methods": [],
            "line": 1099
          },
          {
            "name": "TenantUserListResponse",
            "docstring": "List of users in tenant.",
            "methods": [],
            "line": 1109
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 60
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "aos_api_key.py",
        "file_path": "backend/app/hoc/api/cus/policies/aos_api_key.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 297,
        "module_docstring": "API Keys API (L2) - Connectivity Domain\n\nCustomer-facing endpoints for managing API keys.\nAll requests are tenant-scoped via auth_context.\n\nEndpoints:\n- GET /api-keys           \u2192 O2 list API keys\n- GET /api-keys/{id}      \u2192 O3 API key detail\n\nArchitecture:\n- ONE facade for API KEYS in Connectivity domain\n- Queries APIKey table\n- Tenant isolation via auth_context (not header)\n- SDSR validates this same production API",
        "functions": [
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 68
          },
          {
            "name": "list_api_keys",
            "signature": "(request: Request, status: Annotated[Optional[str], Query(description='Filter by status: active, revoked, expired', pattern='^(active|revoked|expired)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max items to return')] = 50, offset: Annotated[int, Query(ge=0, description='Rows to skip')] = 0, session = Depends(get_session_dep)) -> APIKeysListResponse",
            "docstring": "List API keys. READ-ONLY. Delegates to L4 operation registry.",
            "is_async": true,
            "line": 159
          },
          {
            "name": "get_api_key_detail",
            "signature": "(request: Request, key_id: str, session = Depends(get_session_dep)) -> APIKeyDetailResponse",
            "docstring": "Get API key detail (O3). Delegates to L4 operation registry.",
            "is_async": true,
            "line": 241
          }
        ],
        "classes": [
          {
            "name": "APIKeySummary",
            "docstring": "O2 Result Shape for API keys.",
            "methods": [],
            "line": 97
          },
          {
            "name": "APIKeysListResponse",
            "docstring": "GET /api-keys response (O2).",
            "methods": [],
            "line": 110
          },
          {
            "name": "APIKeyDetailResponse",
            "docstring": "GET /api-keys/{id} response (O3).",
            "methods": [],
            "line": 119
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "aos_cus_integrations.py",
        "file_path": "backend/app/hoc/api/cus/policies/aos_cus_integrations.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 673,
        "module_docstring": "Customer LLM Integration Management API\n\nPURPOSE:\n    CONTROL PLANE for customer LLM integrations. This API manages the lifecycle\n    of integrations - create, update, enable, disable, delete, health checks.\n\nENDPOINTS:\n    CRUD:\n        GET    /integrations           - List integrations (paginated)\n        GET    /integrations/{id}      - Get integration details\n        POST   /integrations           - Create new integration\n        PUT    /integrations/{id}      - Update integration\n        DELETE /integrations/{id}      - Delete integration (soft)\n\n    Lifecycle:\n        POST   /integrations/{id}/enable   - Enable integration\n        POST   /integrations/{id}/disable  - Disable integration\n\n    Health:\n        GET    /integrations/{id}/health   - Get health status\n        POST   /integrations/{id}/test     - Test credentials\n\n    Limits:\n        GET    /integrations/{id}/limits   - Get current usage vs limits\n\nSEMANTIC:\n    - Tenant-isolated: All operations scoped to authenticated tenant\n    - Status lifecycle: created -> enabled -> disabled\n    - Health checks are non-blocking\n    - Soft delete preserves telemetry references\n\nAUTHENTICATION:\n    Uses standard tenant authentication via gateway middleware.",
        "functions": [
          {
            "name": "get_user_id",
            "signature": "(request: Request) -> Optional[str]",
            "docstring": "Extract user_id from authenticated request.",
            "is_async": false,
            "line": 88
          },
          {
            "name": "list_integrations",
            "signature": "(request: Request, offset: int = Query(default=0, ge=0, description='Pagination offset'), limit: int = Query(default=20, ge=1, le=100, description='Page size'), status: Optional[str] = Query(default=None, description='Filter by status'), provider_type: Optional[str] = Query(default=None, description='Filter by provider'))",
            "docstring": "List all integrations for the tenant.\n\nReturns paginated list of integration summaries.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 102
          },
          {
            "name": "get_integration",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Get full details for a specific integration.\n\nIncludes health state, limits configuration, and timestamps.\nDoes NOT include credential_ref or sensitive config.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 160
          },
          {
            "name": "create_integration",
            "signature": "(payload: CusIntegrationCreate, request: Request)",
            "docstring": "Create a new LLM integration.\n\nThe integration starts in 'created' status. Use /enable to activate it.\nDelegates to L4 IntegrationsFacade.\n\nSECURITY:\n    - credential_ref must be a vault reference or encrypted value\n    - Raw API keys are rejected by schema validation",
            "is_async": true,
            "line": 225
          },
          {
            "name": "update_integration",
            "signature": "(integration_id: UUID, payload: CusIntegrationUpdate, request: Request)",
            "docstring": "Update an existing integration.\n\nPartial update - only provided fields are changed.\nStatus changes should use dedicated enable/disable endpoints.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 294
          },
          {
            "name": "delete_integration",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Delete an integration (soft delete).\n\nThe integration is marked as deleted but retained for telemetry references.\nTelemetry data is NOT deleted.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 364
          },
          {
            "name": "enable_integration",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Enable an integration.\n\nTransitions status from 'created' or 'disabled' to 'enabled'.\nSDK can only use enabled integrations.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 411
          },
          {
            "name": "disable_integration",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Disable an integration.\n\nTransitions status to 'disabled'. SDK calls will fail for disabled integrations.\nTelemetry continues to be accepted for in-flight calls.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 459
          },
          {
            "name": "get_integration_health",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Get current health status without running a new check.\n\nReturns cached health state from last check.\nUse POST /test to trigger a fresh health check.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 512
          },
          {
            "name": "test_integration_credentials",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Test integration credentials and update health status.\n\nPerforms a lightweight API call to the provider to verify:\n- Credentials are valid\n- Provider is reachable\n- Rate limits allow access\n\nThis is NON-BLOCKING but may take a few seconds.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 563
          },
          {
            "name": "get_integration_limits",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Get current usage against configured limits.\n\nReturns budget, token, and rate limit status with percentages.\nUsed by SDK to check limits before making calls (Phase 5).\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 622
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.auth.tenant_resolver",
            "names": [
              "resolve_tenant_id"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.schemas.cus_schemas",
            "names": [
              "CusHealthCheckResponse",
              "CusIntegrationCreate",
              "CusIntegrationResponse",
              "CusIntegrationSummary",
              "CusIntegrationUpdate"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict",
              "wrap_list"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 69
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "billing_dependencies.py",
        "file_path": "backend/app/hoc/api/cus/policies/billing_dependencies.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 203,
        "module_docstring": "Phase-6 Billing Dependencies \u2014 FastAPI Integration\n\nProvides dependencies for accessing billing context in API endpoints.\n\nAPPLICABILITY GATE:\n    Billing is evaluated ONLY when tenant.onboarding_state == COMPLETE.\n    Before COMPLETE, these dependencies return neutral placeholders.\n\nDESIGN INVARIANTS:\n- BILLING-001: Billing never blocks onboarding\n- BILLING-003: Billing state does not affect roles\n\nPIN-520 Phase 1: Routes billing provider access through L4 account bridge.",
        "functions": [
          {
            "name": "_get_billing_provider",
            "signature": "()",
            "docstring": "Get billing provider via L4 bridge (PIN-520 compliance).",
            "is_async": false,
            "line": 45
          },
          {
            "name": "get_billing_context",
            "signature": "(request: Request) -> BillingContext",
            "docstring": "FastAPI dependency: Get billing context for current request.\n\nAPPLICABILITY:\n- Returns neutral context if onboarding is not COMPLETE\n- Returns full billing context if onboarding is COMPLETE\n\nUsage:\n    @router.get(\"/billing/status\")\n    async def get_status(billing: BillingContext = Depends(get_billing_context)):\n        return {\"state\": billing.billing_state.value}",
            "is_async": false,
            "line": 80
          },
          {
            "name": "require_billing_active",
            "signature": "(request: Request) -> BillingContext",
            "docstring": "FastAPI dependency: Require billing state allows usage.\n\nRaises HTTP 402 if billing state is SUSPENDED.\n\nUsage:\n    @router.post(\"/runs\")\n    async def create_run(billing: BillingContext = Depends(require_billing_active)):\n        # Billing state is verified to allow usage\n        ...",
            "is_async": false,
            "line": 132
          },
          {
            "name": "check_limit",
            "signature": "(context: BillingContext, limit_name: str, current_value: float) -> Optional[dict]",
            "docstring": "Check if a specific limit is exceeded.\n\nReturns error dict if exceeded, None otherwise.\n\nArgs:\n    context: Billing context\n    limit_name: Name of limit attribute (e.g., \"max_requests_per_day\")\n    current_value: Current usage value\n\nReturns:\n    Error dict if limit exceeded, None otherwise",
            "is_async": false,
            "line": 159
          }
        ],
        "classes": [
          {
            "name": "BillingContext",
            "docstring": "Billing context for a request.\n\nProvides billing state, plan, and limits for the current tenant.\nReturns neutral values if onboarding is not complete.\n\nAttributes:\n    tenant_id: The tenant identifier\n    billing_state: Current billing state (TRIAL if not complete)\n    plan: Current plan (FREE if not complete)\n    limits: Derived limits\n    is_applicable: True if billing logic applies (onboarding complete)",
            "methods": [
              "allows_usage"
            ],
            "line": 52
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "Request",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.billing.state",
            "names": [
              "BillingState"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.billing.plan",
            "names": [
              "Plan",
              "DEFAULT_PLAN"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.billing.limits",
            "names": [
              "Limits",
              "DEFAULT_LIMITS"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges.account_bridge",
            "names": [
              "get_account_bridge"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.onboarding_state",
            "names": [
              "OnboardingState"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "BillingContext",
          "get_billing_context",
          "require_billing_active",
          "check_limit"
        ]
      },
      {
        "file_name": "compliance.py",
        "file_path": "backend/app/hoc/api/cus/policies/compliance.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 220,
        "module_docstring": "Compliance API (L2)\n\nProvides compliance verification operations:\n- POST /compliance/verify (run verification)\n- GET /compliance/reports (list reports)\n- GET /compliance/reports/{id} (get report)\n- GET /compliance/rules (list rules)\n- GET /compliance/rules/{id} (get rule)\n- GET /compliance/status (overall status)\n\nThis is the ONLY facade for compliance verification.\nAll compliance APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> ComplianceFacade",
            "docstring": "Get the compliance facade.",
            "is_async": false,
            "line": 70
          },
          {
            "name": "verify_compliance",
            "signature": "(request: VerifyComplianceRequest, ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.verify')))",
            "docstring": "Run compliance verification (GAP-103).\n\n**Tier: PREVENT ($199)** - Compliance verification.\n\nScopes:\n- all: Run all compliance checks\n- data: Data handling compliance\n- policy: Policy enforcement compliance\n- cost: Cost governance compliance\n- security: Security compliance",
            "is_async": true,
            "line": 81
          },
          {
            "name": "list_reports",
            "signature": "(scope: Optional[str] = Query(None, description='Filter by scope'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "List compliance reports.\n\nReturns compliance verification reports for the tenant.",
            "is_async": true,
            "line": 111
          },
          {
            "name": "get_report",
            "signature": "(report_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "Get a specific compliance report.",
            "is_async": true,
            "line": 142
          },
          {
            "name": "list_rules",
            "signature": "(scope: Optional[str] = Query(None, description='Filter by scope'), enabled_only: bool = Query(True, description='Only enabled rules'), ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "List compliance rules.\n\nReturns all compliance rules that are checked during verification.",
            "is_async": true,
            "line": 163
          },
          {
            "name": "get_rule",
            "signature": "(rule_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "Get a specific compliance rule.",
            "is_async": true,
            "line": 187
          },
          {
            "name": "get_compliance_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "Get overall compliance status.\n\nReturns the current compliance status including:\n- Overall status (compliant, non_compliant, partially_compliant)\n- Last verification timestamp\n- Rule counts\n- Pending violations",
            "is_async": true,
            "line": 205
          }
        ],
        "classes": [
          {
            "name": "VerifyComplianceRequest",
            "docstring": "Request to run compliance verification.",
            "methods": [],
            "line": 57
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.compliance_facade",
            "names": [
              "ComplianceFacade",
              "get_compliance_facade"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "connectors.py",
        "file_path": "backend/app/hoc/api/cus/policies/connectors.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 285,
        "module_docstring": "Connectors API (L2)\n\nProvides connector management operations:\n- GET /connectors (list connectors)\n- POST /connectors (register connector)\n- GET /connectors/{id} (get connector)\n- PUT /connectors/{id} (update connector)\n- DELETE /connectors/{id} (delete connector)\n- POST /connectors/{id}/test (test connector)\n\nThis is the ONLY facade for connector operations.\nAll connector APIs flow through this router.",
        "functions": [
          {
            "name": "list_connectors",
            "signature": "(connector_type: Optional[str] = Query(None, description='Filter by type'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('connectors.read')))",
            "docstring": "List connectors for the tenant.\n\nReturns all registered connectors with optional filtering.",
            "is_async": true,
            "line": 80
          },
          {
            "name": "register_connector",
            "signature": "(request: RegisterConnectorRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('connectors.write')))",
            "docstring": "Register a new connector.\n\nSupported types:\n- http: REST/HTTP APIs\n- sql: SQL databases\n- mcp: Model Context Protocol servers\n- vector: Vector databases\n- file: File storage\n- serverless: Serverless functions",
            "is_async": true,
            "line": 121
          },
          {
            "name": "get_connector",
            "signature": "(connector_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('connectors.read')))",
            "docstring": "Get a specific connector by ID.",
            "is_async": true,
            "line": 161
          },
          {
            "name": "update_connector",
            "signature": "(connector_id: str, request: UpdateConnectorRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('connectors.write')))",
            "docstring": "Update a connector.",
            "is_async": true,
            "line": 192
          },
          {
            "name": "delete_connector",
            "signature": "(connector_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('connectors.write')))",
            "docstring": "Delete a connector.",
            "is_async": true,
            "line": 228
          },
          {
            "name": "test_connector",
            "signature": "(connector_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('connectors.test')))",
            "docstring": "Test a connector connection.\n\nAttempts to establish a connection and returns the result.",
            "is_async": true,
            "line": 259
          }
        ],
        "classes": [
          {
            "name": "RegisterConnectorRequest",
            "docstring": "Request to register a new connector.",
            "methods": [],
            "line": 57
          },
          {
            "name": "UpdateConnectorRequest",
            "docstring": "Request to update a connector.",
            "methods": [],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_enforcement.py",
        "file_path": "backend/app/hoc/api/cus/policies/cus_enforcement.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 265,
        "module_docstring": "Customer LLM Enforcement API\n\nPURPOSE:\n    API endpoints for enforcement policy evaluation.\n    SDK calls these endpoints before making LLM calls.\n\nENDPOINTS:\n    POST   /enforcement/check    - Pre-flight enforcement check\n    GET    /enforcement/status   - Get current limits and usage\n    POST   /enforcement/batch    - Batch pre-flight checks\n\nSEMANTIC:\n    - Tenant-isolated: All operations scoped to authenticated tenant\n    - Read-only: These endpoints evaluate policies, they don't change them\n    - Idempotent: Same request always produces same decision (given same state)\n\nAUTHENTICATION:\n    Uses standard tenant authentication via gateway middleware.\n    SDK uses X-AOS-Key header.",
        "functions": [
          {
            "name": "get_tenant_id",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from authenticated request.",
            "is_async": false,
            "line": 80
          },
          {
            "name": "check_enforcement",
            "signature": "(payload: EnforcementCheckRequest, request: Request)",
            "docstring": "Check enforcement policy before making an LLM call.\n\nThis is the primary endpoint for SDK pre-flight checks. Returns a decision\nthat tells the SDK whether to proceed, warn, throttle, or block.\n\nThe decision includes:\n- result: allowed, warned, throttled, blocked, hard_blocked\n- reasons: Explainability data for why the decision was made\n- degraded: True if decision made with incomplete telemetry\n\nIMPORTANT: This endpoint is read-only and idempotent. Calling it multiple\ntimes with the same state will produce the same result.",
            "is_async": true,
            "line": 102
          },
          {
            "name": "get_enforcement_status",
            "signature": "(request: Request, integration_id: str = Query(..., description='Integration ID'))",
            "docstring": "Get current enforcement status for an integration.\n\nReturns current limits, usage, and remaining allowances. Useful for\ndisplaying in dashboards or for SDK to show users their current state.\n\nDoes NOT make an enforcement decision - use /check for that.",
            "is_async": true,
            "line": 168
          },
          {
            "name": "batch_enforcement_check",
            "signature": "(payload: EnforcementBatchRequest, request: Request)",
            "docstring": "Check enforcement for multiple requests at once.\n\nUseful for batch operations or when making multiple calls in sequence.\nReturns decisions in the same order as the requests.",
            "is_async": true,
            "line": 215
          }
        ],
        "classes": [
          {
            "name": "EnforcementCheckRequest",
            "docstring": "Request for enforcement check.",
            "methods": [],
            "line": 55
          },
          {
            "name": "EnforcementBatchRequest",
            "docstring": "Request for batch enforcement check.",
            "methods": [],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "List"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict",
              "wrap_list"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "customer_visibility.py",
        "file_path": "backend/app/hoc/api/cus/policies/customer_visibility.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 606,
        "module_docstring": "Phase 4C-2: Customer Visibility Endpoints\n\nCustomer-facing endpoints for predictability and accountability.\n\nRules:\n- Show effects, not mechanics\n- No decision records exposed\n- No governance internals\n- Predictability before execution\n- Accountability after execution",
        "functions": [
          {
            "name": "get_budget_mode",
            "signature": "() -> BudgetDeclaration",
            "docstring": "Determine budget enforcement mode from configuration.",
            "is_async": false,
            "line": 199
          },
          {
            "name": "get_policy_posture",
            "signature": "(strict_mode: bool = False) -> PolicyDeclaration",
            "docstring": "Determine policy posture from configuration.",
            "is_async": false,
            "line": 220
          },
          {
            "name": "get_memory_mode",
            "signature": "() -> MemoryDeclaration",
            "docstring": "Determine memory mode from configuration.",
            "is_async": false,
            "line": 236
          },
          {
            "name": "estimate_stages",
            "signature": "(agent_id: str, goal: str) -> List[StageDeclaration]",
            "docstring": "Estimate execution stages based on agent capabilities.\n\nThis is a simplified version - in production, this would\ncall the planner to generate a real plan.",
            "is_async": false,
            "line": 252
          },
          {
            "name": "estimate_cost",
            "signature": "(agent_id: str, goal: str, stages: List[StageDeclaration]) -> CostDeclaration",
            "docstring": "Estimate cost based on stages and historical data.",
            "is_async": false,
            "line": 272
          },
          {
            "name": "get_pre_run_declaration",
            "signature": "(agent_id: str, goal: str, strict_mode: bool = False, _: str = Depends(verify_api_key)) -> PreRunDeclaration",
            "docstring": "Get PRE-RUN declaration before execution.\n\nReturns all information needed for customer to make an informed decision:\n- Stages that will execute (ordered)\n- Estimated cost range\n- Budget enforcement mode\n- Policy posture\n- Memory mode\n\nCustomer must acknowledge before execution can proceed.",
            "is_async": true,
            "line": 313
          },
          {
            "name": "acknowledge_declaration",
            "signature": "(request: AcknowledgementRequest, _: str = Depends(verify_api_key)) -> AcknowledgementResponse",
            "docstring": "Acknowledge PRE-RUN declaration.\n\nCustomer must acknowledge to proceed with execution.\nThis creates an audit trail of informed consent.",
            "is_async": true,
            "line": 379
          },
          {
            "name": "get_outcome_reconciliation",
            "signature": "(run_id: str, request: Request, _: str = Depends(verify_api_key), session = Depends(get_session_dep)) -> OutcomeReconciliation",
            "docstring": "Get outcome reconciliation after execution.\n\nReturns decomposed results (never a single success flag):\n- Task completion status\n- Budget usage status\n- Policy compliance status\n- Recovery status",
            "is_async": true,
            "line": 435
          },
          {
            "name": "get_declaration",
            "signature": "(declaration_id: str, _: str = Depends(verify_api_key)) -> PreRunDeclaration",
            "docstring": "Retrieve a previously created PRE-RUN declaration.",
            "is_async": true,
            "line": 596
          }
        ],
        "classes": [
          {
            "name": "StageDeclaration",
            "docstring": "Single stage in the execution plan.",
            "methods": [],
            "line": 47
          },
          {
            "name": "CostDeclaration",
            "docstring": "Cost expectations before execution.",
            "methods": [],
            "line": 55
          },
          {
            "name": "BudgetDeclaration",
            "docstring": "Budget enforcement mode.",
            "methods": [],
            "line": 64
          },
          {
            "name": "PolicyDeclaration",
            "docstring": "Policy posture declaration.",
            "methods": [],
            "line": 72
          },
          {
            "name": "MemoryDeclaration",
            "docstring": "Memory mode declaration.",
            "methods": [],
            "line": 80
          },
          {
            "name": "EstimationMethodology",
            "docstring": "PIN-254 Phase C Fix (C3 Partial Truth): Explicit disclosure of estimation basis.\n\nEnsures API consumers know whether estimates are derived from:\n- Real planner output (planner_v1)\n- Hardcoded defaults (default_stages_v1)\n- Historical data (historical_avg)",
            "methods": [],
            "line": 87
          },
          {
            "name": "PreRunDeclaration",
            "docstring": "Complete PRE-RUN declaration for customer visibility.\n\nThis is what the customer sees BEFORE execution starts.\nExecution cannot proceed without acknowledgement.",
            "methods": [],
            "line": 103
          },
          {
            "name": "AcknowledgementRequest",
            "docstring": "Customer acknowledgement of PRE-RUN declaration.",
            "methods": [],
            "line": 138
          },
          {
            "name": "AcknowledgementResponse",
            "docstring": "Response after acknowledgement.",
            "methods": [],
            "line": 145
          },
          {
            "name": "OutcomeItem",
            "docstring": "Single outcome item.",
            "methods": [],
            "line": 159
          },
          {
            "name": "OutcomeReconciliation",
            "docstring": "Complete outcome reconciliation for customer visibility.\n\nThis is what the customer sees AFTER execution completes.\nDecomposed results, never a single success flag.",
            "methods": [],
            "line": 167
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_operation_registry",
              "get_session_dep",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "app.auth",
            "names": [
              "verify_api_key"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.middleware.tenancy",
            "names": [
              "get_tenant_id"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "datasources.py",
        "file_path": "backend/app/hoc/api/cus/policies/datasources.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 387,
        "module_docstring": "DataSources API (L2)\n\nProvides data source operations:\n- POST /datasources (create source)\n- GET /datasources (list sources)\n- GET /datasources/{id} (get source)\n- PUT /datasources/{id} (update source)\n- DELETE /datasources/{id} (delete source)\n- POST /datasources/{id}/test (test connection)\n- POST /datasources/{id}/activate (activate source)\n- POST /datasources/{id}/deactivate (deactivate source)\n- GET /datasources/stats (statistics)\n\nThis is the ONLY facade for data source operations.\nAll data source APIs flow through this router.",
        "functions": [
          {
            "name": "create_source",
            "signature": "(request: CreateSourceRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Create a data source (GAP-113).\n\n**Tier: REACT ($9)** - Data source management.\n\nSource types:\n- database: Relational databases (PostgreSQL, MySQL, etc.)\n- file: File storage (S3, GCS, local)\n- api: REST/GraphQL APIs\n- vector: Vector databases (Pinecone, Weaviate)\n- stream: Streaming sources (Kafka, etc.)\n- custom: Custom connectors",
            "is_async": true,
            "line": 84
          },
          {
            "name": "list_sources",
            "signature": "(source_type: Optional[str] = Query(None, description='Filter by type'), status: Optional[str] = Query(None, description='Filter by status'), tag: Optional[str] = Query(None, description='Filter by tag'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.read')))",
            "docstring": "List data sources.",
            "is_async": true,
            "line": 127
          },
          {
            "name": "get_statistics",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.read')))",
            "docstring": "Get data source statistics.",
            "is_async": true,
            "line": 168
          },
          {
            "name": "get_source",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.read')))",
            "docstring": "Get a specific data source.",
            "is_async": true,
            "line": 194
          },
          {
            "name": "update_source",
            "signature": "(source_id: str, request: UpdateSourceRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Update a data source.",
            "is_async": true,
            "line": 225
          },
          {
            "name": "delete_source",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Delete a data source.",
            "is_async": true,
            "line": 261
          },
          {
            "name": "test_connection",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.test')))",
            "docstring": "Test a data source connection.\n\nVerifies that the data source can be reached with the current configuration.",
            "is_async": true,
            "line": 292
          },
          {
            "name": "activate_source",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Activate a data source.\n\nMakes the data source available for use.",
            "is_async": true,
            "line": 325
          },
          {
            "name": "deactivate_source",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Deactivate a data source.\n\nTemporarily disables the data source.",
            "is_async": true,
            "line": 358
          }
        ],
        "classes": [
          {
            "name": "CreateSourceRequest",
            "docstring": "Request to create a data source.",
            "methods": [],
            "line": 60
          },
          {
            "name": "UpdateSourceRequest",
            "docstring": "Request to update a data source.",
            "methods": [],
            "line": 70
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "detection.py",
        "file_path": "backend/app/hoc/api/cus/policies/detection.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 319,
        "module_docstring": "Detection API (L2)\n\nProvides anomaly detection operations:\n- POST /detection/run (run detection on demand)\n- GET /detection/anomalies (list anomalies)\n- GET /detection/anomalies/{id} (get anomaly)\n- POST /detection/anomalies/{id}/resolve (resolve anomaly)\n- POST /detection/anomalies/{id}/acknowledge (acknowledge anomaly)\n- GET /detection/status (detection engine status)\n\nThis is the ONLY facade for anomaly detection operations.\nAll detection APIs flow through this router.",
        "functions": [
          {
            "name": "run_detection",
            "signature": "(request: RunDetectionRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('detection.run')))",
            "docstring": "Run anomaly detection on demand (GAP-102).\n\n**Tier: REACT ($9)** - Anomaly detection.\n\nDetection types:\n- cost: Cost anomalies (spikes, drift, budget issues)\n- behavioral: Behavioral anomalies (pattern changes)\n- drift: Model/data drift detection\n\nReturns detection results including anomalies found and incidents created.",
            "is_async": true,
            "line": 87
          },
          {
            "name": "list_anomalies",
            "signature": "(detection_type: Optional[str] = Query(None, description='Filter by type'), severity: Optional[str] = Query(None, description='Filter by severity'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('detection.read')))",
            "docstring": "List anomalies for the tenant.\n\nReturns detected anomalies with optional filtering.",
            "is_async": true,
            "line": 128
          },
          {
            "name": "get_anomaly",
            "signature": "(anomaly_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('detection.read')))",
            "docstring": "Get a specific anomaly by ID.",
            "is_async": true,
            "line": 174
          },
          {
            "name": "resolve_anomaly",
            "signature": "(anomaly_id: str, request: ResolveAnomalyRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('detection.resolve')))",
            "docstring": "Resolve an anomaly.\n\nResolution options:\n- resolved: Anomaly has been addressed\n- dismissed: Anomaly is not actionable (false positive)",
            "is_async": true,
            "line": 208
          },
          {
            "name": "acknowledge_anomaly",
            "signature": "(anomaly_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('detection.acknowledge')))",
            "docstring": "Acknowledge an anomaly.\n\nMarks the anomaly as seen but not yet resolved.",
            "is_async": true,
            "line": 252
          },
          {
            "name": "get_detection_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get detection engine status.\n\nReturns health status of detection engines:\n- cost: Cost anomaly detector\n- behavioral: Behavioral pattern detector\n- drift: Model/data drift detector",
            "is_async": true,
            "line": 291
          }
        ],
        "classes": [
          {
            "name": "RunDetectionRequest",
            "docstring": "Request to run anomaly detection.",
            "methods": [],
            "line": 57
          },
          {
            "name": "ResolveAnomalyRequest",
            "docstring": "Request to resolve an anomaly.",
            "methods": [],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "evidence.py",
        "file_path": "backend/app/hoc/api/cus/policies/evidence.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 376,
        "module_docstring": "Evidence API (L2)\n\nProvides evidence chain and export operations:\n- GET /evidence/chains (list chains)\n- POST /evidence/chains (create chain)\n- GET /evidence/chains/{id} (get chain)\n- POST /evidence/chains/{id}/evidence (add evidence)\n- GET /evidence/chains/{id}/verify (verify chain)\n- POST /evidence/export (create export)\n- GET /evidence/exports (list exports)\n- GET /evidence/exports/{id} (get export)\n\nThis is the ONLY facade for evidence operations.\nAll evidence APIs flow through this router.",
        "functions": [
          {
            "name": "list_chains",
            "signature": "(run_id: Optional[str] = Query(None, description='Filter by run'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.read')))",
            "docstring": "List evidence chains.\n\nReturns evidence chains for the tenant.",
            "is_async": true,
            "line": 88
          },
          {
            "name": "create_chain",
            "signature": "(request: CreateChainRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.write')))",
            "docstring": "Create an evidence chain (GAP-104).\n\n**Tier: REACT ($9)** - Evidence chain creation.\n\nCreates a new evidence chain, optionally with initial evidence.",
            "is_async": true,
            "line": 128
          },
          {
            "name": "get_chain",
            "signature": "(chain_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.read')))",
            "docstring": "Get a specific evidence chain.",
            "is_async": true,
            "line": 162
          },
          {
            "name": "add_evidence",
            "signature": "(chain_id: str, request: AddEvidenceRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.write')))",
            "docstring": "Add evidence to a chain.\n\nEvidence types:\n- execution: Run execution evidence\n- retrieval: Data retrieval evidence\n- policy: Policy decision evidence\n- cost: Cost event evidence\n- incident: Incident evidence",
            "is_async": true,
            "line": 194
          },
          {
            "name": "verify_chain",
            "signature": "(chain_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.verify')))",
            "docstring": "Verify chain integrity.\n\nVerifies that all links in the chain have valid hashes\nand proper linkage.",
            "is_async": true,
            "line": 236
          },
          {
            "name": "create_export",
            "signature": "(request: CreateExportRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.export')))",
            "docstring": "Create evidence export (GAP-105).\n\n**Tier: PREVENT ($199)** - Evidence export.\n\nExport formats:\n- json: JSON format with full chain data\n- csv: CSV format for spreadsheet import\n- pdf: PDF format for compliance reports",
            "is_async": true,
            "line": 273
          },
          {
            "name": "list_exports",
            "signature": "(chain_id: Optional[str] = Query(None, description='Filter by chain'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.read')))",
            "docstring": "List evidence exports.",
            "is_async": true,
            "line": 310
          },
          {
            "name": "get_export",
            "signature": "(export_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.read')))",
            "docstring": "Get export status.",
            "is_async": true,
            "line": 348
          }
        ],
        "classes": [
          {
            "name": "CreateChainRequest",
            "docstring": "Request to create evidence chain.",
            "methods": [],
            "line": 58
          },
          {
            "name": "AddEvidenceRequest",
            "docstring": "Request to add evidence to chain.",
            "methods": [],
            "line": 67
          },
          {
            "name": "CreateExportRequest",
            "docstring": "Request to create evidence export.",
            "methods": [],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "governance.py",
        "file_path": "backend/app/hoc/api/cus/policies/governance.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 315,
        "module_docstring": "Governance API (L2)\n\nProvides governance control operations:\n- POST /governance/kill-switch (GAP-090)\n- POST /governance/mode (GAP-091)\n- POST /governance/resolve-conflict (GAP-092)\n- GET /governance/boot-status (GAP-095)\n- GET /governance/state\n\nThis is the ONLY facade for governance control operations.\nAll governance APIs flow through this router.",
        "functions": [
          {
            "name": "get_governance_state",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get current governance state.\n\nReturns the current governance mode, whether enforcement is active,\nand details about the last state change.",
            "is_async": true,
            "line": 116
          },
          {
            "name": "toggle_kill_switch",
            "signature": "(request: KillSwitchRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('governance.kill_switch')))",
            "docstring": "Toggle the governance kill switch (GAP-090).\n\n**Tier: REACT ($9)** - Emergency governance control.\n\nWARNING: Enabling the kill switch disables ALL governance enforcement.\nThis is an emergency operation for incident response only.\n\n- enabled=true: Disable governance (emergency kill switch ON)\n- enabled=false: Re-enable governance (kill switch OFF)",
            "is_async": true,
            "line": 140
          },
          {
            "name": "set_governance_mode",
            "signature": "(request: ModeRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('governance.mode')))",
            "docstring": "Set governance mode (GAP-091).\n\n**Tier: REACT ($9)** - Emergency governance control.\n\nModes:\n- NORMAL: Full governance enforcement\n- DEGRADED: Limited enforcement, new runs blocked\n- KILL: All governance disabled (emergency)",
            "is_async": true,
            "line": 177
          },
          {
            "name": "resolve_conflict",
            "signature": "(request: ConflictResolutionRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('governance.resolve_conflict')))",
            "docstring": "Manually resolve a policy conflict (GAP-092).\n\n**Tier: PREVENT ($199)** - Policy management.\n\nResolution strategies:\n- accept_first: Accept the first policy in the conflict\n- accept_second: Accept the second policy in the conflict\n- merge: Attempt to merge conflicting policies\n- defer: Defer resolution to later",
            "is_async": true,
            "line": 223
          },
          {
            "name": "list_conflicts",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), status: Optional[str] = Query(None, description='Filter by status'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('governance.read')))",
            "docstring": "List policy conflicts.\n\nReturns pending and resolved policy conflicts.",
            "is_async": true,
            "line": 262
          },
          {
            "name": "get_boot_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get SPINE component health status (GAP-095).\n\nReturns health status of core governance components:\n- governance: Kill switch state\n- policy_engine: Policy evaluation engine\n- audit_store: Audit event storage\n- policy_facade: Policy facade availability",
            "is_async": true,
            "line": 292
          }
        ],
        "classes": [
          {
            "name": "KillSwitchRequest",
            "docstring": "Request to toggle kill switch.",
            "methods": [],
            "line": 56
          },
          {
            "name": "ModeRequest",
            "docstring": "Request to set governance mode.",
            "methods": [],
            "line": 62
          },
          {
            "name": "ConflictResolutionRequest",
            "docstring": "Request to resolve a policy conflict.",
            "methods": [],
            "line": 68
          },
          {
            "name": "GovernanceStateResponse",
            "docstring": "Governance state response.",
            "methods": [],
            "line": 75
          },
          {
            "name": "KillSwitchResponse",
            "docstring": "Kill switch operation response.",
            "methods": [],
            "line": 85
          },
          {
            "name": "BootStatusResponse",
            "docstring": "Boot status response.",
            "methods": [],
            "line": 96
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard.py",
        "file_path": "backend/app/hoc/api/cus/policies/guard.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 2484,
        "module_docstring": "Guard API - Customer Console Backend\n\nThis router provides endpoints for the Customer Console (guard.agenticverz.com).\nFocused on TRUST and CONTROL - customers can see what's protecting them and stop it if needed.\n\nEndpoints:\n- GET  /guard/status          - Protection status (am I safe?)\n- GET  /guard/snapshot/today  - Today's metrics\n- POST /guard/killswitch/activate   - Stop all traffic\n- POST /guard/killswitch/deactivate - Resume traffic\n- GET  /guard/incidents       - List incidents\n- GET  /guard/incidents/{id}  - Incident detail with timeline\n- POST /guard/incidents/{id}/acknowledge - Acknowledge incident\n- POST /guard/incidents/{id}/resolve     - Resolve incident\n- POST /guard/replay/{call_id} - Replay a call\n- GET  /guard/keys            - List API keys\n- POST /guard/keys/{id}/freeze   - Freeze key\n- POST /guard/keys/{id}/unfreeze - Unfreeze key\n- GET  /guard/settings        - Read-only settings",
        "functions": [
          {
            "name": "utc_now",
            "signature": "() -> datetime",
            "docstring": null,
            "is_async": false,
            "line": 271
          },
          {
            "name": "get_tenant_from_auth",
            "signature": "(session, tenant_id: str) -> dict",
            "docstring": "Get tenant or raise 404. Uses L4 registry dispatch for L2 first-principles purity.",
            "is_async": true,
            "line": 275
          },
          {
            "name": "get_guard_status",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Get protection status - \"Am I safe right now?\"\n\nReturns:\n- Freeze state\n- Active guardrails\n- 24h incident count\n- Last incident time\n\nCached for 5 seconds to reduce cross-region DB latency.",
            "is_async": true,
            "line": 300
          },
          {
            "name": "get_today_snapshot",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Get today's metrics - \"What did it cost/save me?\"\n\nCached for 10 seconds to reduce cross-region DB latency.",
            "is_async": true,
            "line": 393
          },
          {
            "name": "activate_killswitch",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Stop all traffic - Emergency kill switch.\n\nImmediate. All requests blocked until manually resumed.\n\nPIN-281: Uses L3 CustomerKillswitchAdapter for tenant-scoped operations.",
            "is_async": true,
            "line": 472
          },
          {
            "name": "deactivate_killswitch",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Resume traffic - Deactivate kill switch.\n\nGuardrails will continue protecting.\n\nPIN-281: Uses L3 CustomerKillswitchAdapter for tenant-scoped operations.",
            "is_async": true,
            "line": 501
          },
          {
            "name": "list_incidents",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), limit: int = Query(default=50, le=100), offset: int = Query(default=0), session = Depends(get_sync_session_dep))",
            "docstring": "List incidents - \"What did you stop for me?\"\n\nHuman narrative, not logs.\n\nPIN-281: Uses L3 CustomerIncidentsAdapter for tenant-scoped operations.",
            "is_async": true,
            "line": 532
          },
          {
            "name": "get_incident_detail",
            "signature": "(incident_id: str, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Get incident detail with timeline.\n\nOne-screen explanation readable at 2am.\n\nPIN-281: Uses L3 CustomerIncidentsAdapter with tenant isolation.",
            "is_async": true,
            "line": 578
          },
          {
            "name": "acknowledge_incident",
            "signature": "(incident_id: str, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Acknowledge an incident.\n\nPIN-281: Uses L3 CustomerIncidentsAdapter with tenant isolation.",
            "is_async": true,
            "line": 632
          },
          {
            "name": "resolve_incident",
            "signature": "(incident_id: str, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Resolve an incident.\n\nPIN-281: Uses L3 CustomerIncidentsAdapter with tenant isolation.",
            "is_async": true,
            "line": 653
          },
          {
            "name": "get_customer_incident_narrative",
            "signature": "(incident_id: str, token: CustomerToken = Depends(verify_console_token), session = Depends(get_sync_session_dep)) -> CustomerIncidentNarrativeDTO",
            "docstring": "GET /guard/incidents/{id}/narrative\n\nCustomer Incident Narrative - Calm, reassuring summary.\n\nM29 Category 5: Incident Console Contrast\n\nAnswers:\n- What happened? (plain language)\n- Did it affect me? (yes/no/some)\n- Is it fixed? (status + message)\n- Do I need to act? (only if necessary)\n\nIMPORTANT: Uses CALM vocabulary only.\n- No internal terminology (policy names, thresholds)\n- No cross-tenant data\n- No raw metrics that could cause panic",
            "is_async": true,
            "line": 679
          },
          {
            "name": "_generate_plain_title",
            "signature": "(incident: dict) -> str",
            "docstring": "Generate plain language title - no internal terminology.",
            "is_async": false,
            "line": 755
          },
          {
            "name": "_generate_calm_summary",
            "signature": "(incident: dict) -> str",
            "docstring": "Generate calm, reassuring summary - no internal terms.",
            "is_async": false,
            "line": 772
          },
          {
            "name": "_build_customer_impact",
            "signature": "(incident: dict) -> CustomerIncidentImpactDTO",
            "docstring": "Build impact assessment with calm vocabulary.",
            "is_async": false,
            "line": 796
          },
          {
            "name": "_build_customer_resolution",
            "signature": "(incident: dict) -> CustomerIncidentResolutionDTO",
            "docstring": "Build resolution status with reassuring message.",
            "is_async": false,
            "line": 834
          },
          {
            "name": "_build_customer_actions",
            "signature": "(incident: dict) -> list",
            "docstring": "Build customer actions - only if necessary.",
            "is_async": false,
            "line": 867
          },
          {
            "name": "replay_call",
            "signature": "(call_id: str, level: str = Query('logical', description='Determinism level: strict, logical, or semantic'), session = Depends(get_sync_session_dep), auth: AuthorityResult = Depends(require_replay_execute))",
            "docstring": "Replay a call - Trust builder.\n\nM23: Uses real ReplayValidator from replay_determinism.py\n\nDeterminism Levels:\n- strict: Byte-for-byte exact match (only works for cached/local)\n- logical: Policy decision equivalence (default - proves guardrails work)\n- semantic: Meaning-equivalent match (for content validation)\n\nShows:\n- Original outcome\n- Replay outcome\n- Policy decisions (same/different)\n- Model drift detection",
            "is_async": true,
            "line": 921
          },
          {
            "name": "list_api_keys",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "List API keys with status.\n\nCustomer can freeze/unfreeze individual keys.\n\nPIN-281: Uses L3 CustomerKeysAdapter for tenant-scoped operations.",
            "is_async": true,
            "line": 1247
          },
          {
            "name": "freeze_api_key",
            "signature": "(key_id: str, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Freeze an API key.\n\nPIN-281: Uses L3 CustomerKeysAdapter with tenant isolation.",
            "is_async": true,
            "line": 1286
          },
          {
            "name": "unfreeze_api_key",
            "signature": "(key_id: str, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Unfreeze an API key.\n\nPIN-281: Uses L3 CustomerKeysAdapter with tenant isolation.",
            "is_async": true,
            "line": 1307
          },
          {
            "name": "get_settings",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Get read-only settings.\n\nCustomers can see what's configured but can't change it.\nContact support to modify.\n\nIn demo mode (tenant_demo or non-existent tenant), returns demo defaults.",
            "is_async": true,
            "line": 1333
          },
          {
            "name": "search_incidents",
            "signature": "(request: IncidentSearchRequest, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "Search incidents with filters - M23 component map spec.\n\nSupports:\n- Free text search in title/description\n- Filter by user_id (from related calls)\n- Filter by policy status (passed/failed)\n- Filter by severity\n- Filter by time range\n- Filter by model",
            "is_async": true,
            "line": 1524
          },
          {
            "name": "get_decision_timeline",
            "signature": "(incident_id: str, session = Depends(get_sync_session_dep))",
            "docstring": "Get decision timeline - M23 component map spec.\n\nReturns step-by-step trace:\n1. INPUT_RECEIVED - What the user asked\n2. CONTEXT_RETRIEVED - What data was fetched\n3. POLICY_EVALUATED - Each policy check (PASS/FAIL/WARN)\n4. MODEL_CALLED - LLM invocation\n5. OUTPUT_GENERATED - Final response\n6. LOGGED - Audit trail\n\nPlus root cause identification if policy failed.",
            "is_async": true,
            "line": 1663
          },
          {
            "name": "export_incident_evidence",
            "signature": "(incident_id: str, tenant_id: str = Query(..., description='Tenant ID'), include_replay: bool = Query(True, description='Include replay verification'), include_prevention: bool = Query(True, description='Include prevention proof'), is_demo: bool = Query(True, description='Add demo watermark'), session = Depends(get_sync_session_dep))",
            "docstring": "Export incident as a legal-grade PDF evidence report.\n\nThis document is designed to survive:\n- Legal review\n- Audit compliance\n- Executive briefing\n- Hostile questioning\n\nSections included:\n1. Executive Summary (for lawyers/leadership)\n2. Factual Reconstruction (pure evidence)\n3. Policy Evaluation Record\n4. Decision Timeline (deterministic trace)\n5. Replay Verification (cryptographic proof)\n6. Prevention Proof (counterfactual)\n7. Remediation & Controls\n8. Legal Attestation\n\nReturns: PDF file with Content-Disposition header",
            "is_async": true,
            "line": 2024
          },
          {
            "name": "onboarding_verify",
            "signature": "(request: OnboardingVerifyRequest, tenant_id: str = Query(..., description='Tenant ID'), session = Depends(get_sync_session_dep))",
            "docstring": "REAL safety verification for onboarding.\n\nThis endpoint:\n1. Fires a REAL request through the proxy (not simulated)\n2. Uses a prompt designed to trigger a guardrail\n3. Creates a REAL incident if blocked\n4. Sends a REAL alert if configured\n\nThe user will see:\n- A real API call being made\n- Real tokens being consumed (minimal)\n- A real incident in their console\n- A real alert (if Slack/email configured)\n\nTest types:\n- guardrail_block: Triggers prompt injection guardrail (blocked, no cost)\n- killswitch_demo: Shows what happens when kill switch fires",
            "is_async": true,
            "line": 2293
          }
        ],
        "classes": [
          {
            "name": "GuardStatus",
            "docstring": "Protection status response.",
            "methods": [],
            "line": 114
          },
          {
            "name": "TodaySnapshot",
            "docstring": "Today's metrics snapshot.",
            "methods": [],
            "line": 125
          },
          {
            "name": "IncidentSummary",
            "docstring": "Incident list item.",
            "methods": [],
            "line": 135
          },
          {
            "name": "IncidentEventResponse",
            "docstring": "Timeline event.",
            "methods": [],
            "line": 153
          },
          {
            "name": "IncidentDetailResponse",
            "docstring": "Full incident detail with timeline.",
            "methods": [],
            "line": 163
          },
          {
            "name": "ApiKeyResponse",
            "docstring": "API key for customer console.",
            "methods": [],
            "line": 170
          },
          {
            "name": "PaginatedResponse",
            "docstring": "Generic paginated response.",
            "methods": [],
            "line": 183
          },
          {
            "name": "GuardrailConfig",
            "docstring": "Guardrail configuration for settings page.",
            "methods": [],
            "line": 192
          },
          {
            "name": "TenantSettings",
            "docstring": "Read-only tenant settings.",
            "methods": [],
            "line": 205
          },
          {
            "name": "PolicyDecision",
            "docstring": "Policy decision for replay.",
            "methods": [],
            "line": 221
          },
          {
            "name": "ReplayCallSnapshot",
            "docstring": "Call snapshot for replay comparison.",
            "methods": [],
            "line": 230
          },
          {
            "name": "ReplayCertificate",
            "docstring": "M23: Cryptographic certificate proving deterministic replay.",
            "methods": [],
            "line": 241
          },
          {
            "name": "ReplayResult",
            "docstring": "Replay result response.",
            "methods": [],
            "line": 253
          },
          {
            "name": "IncidentSearchRequest",
            "docstring": "Search incidents with filters.",
            "methods": [],
            "line": 1420
          },
          {
            "name": "IncidentSearchResult",
            "docstring": "Search result item matching component map spec.",
            "methods": [],
            "line": 1434
          },
          {
            "name": "IncidentSearchResponse",
            "docstring": "Search response.",
            "methods": [],
            "line": 1448
          },
          {
            "name": "TimelineEvent",
            "docstring": "Decision timeline event - step by step policy evaluation.",
            "methods": [],
            "line": 1457
          },
          {
            "name": "PolicyEvaluation",
            "docstring": "Individual policy evaluation result.",
            "methods": [],
            "line": 1466
          },
          {
            "name": "CARERoutingInfo",
            "docstring": "M17 CARE routing information for decision timeline.",
            "methods": [],
            "line": 1476
          },
          {
            "name": "FailureCatalogMatch",
            "docstring": "M9 Failure Catalog match information.",
            "methods": [],
            "line": 1491
          },
          {
            "name": "DecisionTimelineResponse",
            "docstring": "Full decision timeline for an incident/call.",
            "methods": [],
            "line": 1503
          },
          {
            "name": "EvidenceExportRequest",
            "docstring": "Request for evidence report export.",
            "methods": [],
            "line": 2014
          },
          {
            "name": "OnboardingVerifyRequest",
            "docstring": "Request for onboarding safety verification.",
            "methods": [],
            "line": 2269
          },
          {
            "name": "OnboardingVerifyResponse",
            "docstring": "Response from onboarding verification.",
            "methods": [],
            "line": 2276
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "cast"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.adapters.customer_incidents_adapter",
            "names": [
              "get_customer_incidents_adapter"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.adapters.customer_keys_adapter",
            "names": [
              "get_customer_keys_adapter"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.adapters.customer_killswitch_adapter",
            "names": [
              "get_customer_killswitch_adapter"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "emit_authority_audit",
              "require_replay_execute"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "CustomerToken",
              "verify_console_token"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.contracts.guard",
            "names": [
              "CustomerIncidentActionDTO",
              "CustomerIncidentImpactDTO",
              "CustomerIncidentNarrativeDTO",
              "CustomerIncidentResolutionDTO"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.domain_enums",
            "names": [
              "IncidentSeverity"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.hoc.cus.hoc_spine.drivers.guard_write_driver",
            "names": [
              "GuardWriteDriver"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "OperationResult",
              "get_operation_registry",
              "get_sync_session_dep"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "app.hoc.cus.logs.L5_schemas.determinism_types",
            "names": [
              "DeterminismLevel"
            ],
            "is_relative": false,
            "line": 83
          },
          {
            "module": "app.utils.guard_cache",
            "names": [
              "get_guard_cache"
            ],
            "is_relative": false,
            "line": 88
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 2006
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 2007
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard_policies.py",
        "file_path": "backend/app/hoc/api/cus/policies/guard_policies.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 128,
        "module_docstring": "Guard Policies API - Customer Console Policy Constraints Endpoint\n\nThis router provides endpoints for the Customer Console (guard.agenticverz.com).\nFocused on POLICY VISIBILITY - customers can see their constraints and limits.\n\nEndpoints:\n- GET  /guard/policies          - Policy constraints summary\n- GET  /guard/policies/guardrails/{id}  - Guardrail detail\n\nPIN-281 Promotion:\n- L4\u2192L3: customer_policies_adapter.py (boundary adapter)\n- L3\u2192L2: This file (API route)\n\nRule: One adapter per route. No business logic here.",
        "functions": [
          {
            "name": "get_policy_constraints",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID (required)'))",
            "docstring": "Get policy constraints for customer.\n\nReturns summary of:\n- Budget constraints (limit, usage, remaining)\n- Rate limits\n- Active guardrails\n\nCustomer can only see their own tenant's constraints (enforced by adapter).\n\nThis endpoint answers:\n- What are my limits?\n- How much have I used?\n- What protection is active?\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 57
          },
          {
            "name": "get_guardrail_detail",
            "signature": "(guardrail_id: str, tenant_id: str = Query(..., description='Tenant ID (required)'))",
            "docstring": "Get guardrail detail.\n\nReturns information about a specific guardrail:\n- Name and description\n- Whether it's enabled\n- Action on trigger (block, warn, log)\n\nNo threshold values exposed (internal implementation detail).\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 93
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.adapters.customer_policies_adapter",
            "names": [
              "CustomerGuardrail",
              "CustomerPolicyConstraints",
              "get_customer_policies_adapter"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "verify_console_token"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lifecycle.py",
        "file_path": "backend/app/hoc/api/cus/policies/lifecycle.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 401,
        "module_docstring": "Lifecycle API (L2)\n\nProvides lifecycle operations:\n- POST /lifecycle/agents (create agent)\n- GET /lifecycle/agents (list agents)\n- GET /lifecycle/agents/{id} (get agent)\n- POST /lifecycle/agents/{id}/start (start agent)\n- POST /lifecycle/agents/{id}/stop (stop agent)\n- POST /lifecycle/agents/{id}/terminate (terminate agent)\n- POST /lifecycle/runs (create run)\n- GET /lifecycle/runs (list runs)\n- GET /lifecycle/runs/{id} (get run)\n- POST /lifecycle/runs/{id}/pause (pause run)\n- POST /lifecycle/runs/{id}/resume (resume run)\n- POST /lifecycle/runs/{id}/cancel (cancel run)\n- GET /lifecycle/summary (lifecycle summary)\n\nThis is the ONLY facade for lifecycle operations.\nAll lifecycle APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> LifecycleFacade",
            "docstring": "Get the lifecycle facade.",
            "is_async": false,
            "line": 85
          },
          {
            "name": "create_agent",
            "signature": "(request: CreateAgentRequest, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.write')))",
            "docstring": "Create a new agent (GAP-131).",
            "is_async": true,
            "line": 96
          },
          {
            "name": "list_agents",
            "signature": "(state: Optional[str] = Query(None, description='Filter by state'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "List agents (GAP-131).\n\nReturns all agents for the tenant.",
            "is_async": true,
            "line": 116
          },
          {
            "name": "get_agent",
            "signature": "(agent_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "Get a specific agent (GAP-131).",
            "is_async": true,
            "line": 145
          },
          {
            "name": "start_agent",
            "signature": "(agent_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Start an agent (GAP-132).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 166
          },
          {
            "name": "stop_agent",
            "signature": "(agent_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Stop an agent (GAP-132).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 189
          },
          {
            "name": "terminate_agent",
            "signature": "(agent_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Terminate an agent (GAP-132).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 212
          },
          {
            "name": "create_run",
            "signature": "(request: CreateRunRequest, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.write')))",
            "docstring": "Create a new run (GAP-133).",
            "is_async": true,
            "line": 240
          },
          {
            "name": "list_runs",
            "signature": "(agent_id: Optional[str] = Query(None, description='Filter by agent'), state: Optional[str] = Query(None, description='Filter by state'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "List runs (GAP-133).\n\nReturns all runs for the tenant.",
            "is_async": true,
            "line": 263
          },
          {
            "name": "get_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "Get a specific run (GAP-133).",
            "is_async": true,
            "line": 294
          },
          {
            "name": "pause_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Pause a run (GAP-134).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 315
          },
          {
            "name": "resume_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Resume a paused run (GAP-135).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 338
          },
          {
            "name": "cancel_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Cancel a run (GAP-136).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 361
          },
          {
            "name": "get_summary",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "Get lifecycle summary.\n\nReturns summary of agents and runs for the tenant.",
            "is_async": true,
            "line": 389
          }
        ],
        "classes": [
          {
            "name": "CreateAgentRequest",
            "docstring": "Request to create an agent.",
            "methods": [],
            "line": 66
          },
          {
            "name": "CreateRunRequest",
            "docstring": "Request to create a run.",
            "methods": [],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.lifecycle_facade",
            "names": [
              "LifecycleFacade",
              "get_lifecycle_facade"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "logs.py",
        "file_path": "backend/app/hoc/api/cus/policies/logs.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1639,
        "module_docstring": "Unified Logs API (L2) - LOGS Domain V2\n\nCustomer-facing endpoints for viewing logs: audit ledger, LLM run records, and system records.\nAll requests are tenant-scoped via auth_context.\n\nTopics & O-Levels (per LOGS_DOMAIN_V2_CONTRACT.md):\n\nLLM_RUNS:\n- GET /logs/llm-runs                          \u2192 List runs\n- GET /logs/llm-runs/{run_id}/envelope        \u2192 O1 canonical record\n- GET /logs/llm-runs/{run_id}/trace           \u2192 O2 step-by-step trace\n- GET /logs/llm-runs/{run_id}/governance      \u2192 O3 policy interaction\n- GET /logs/llm-runs/{run_id}/replay          \u2192 O4 60-second window\n- GET /logs/llm-runs/{run_id}/export          \u2192 O5 evidence bundle\n\nSYSTEM_LOGS:\n- GET /logs/system                            \u2192 List events\n- GET /logs/system/{run_id}/snapshot          \u2192 O1 environment baseline\n- GET /logs/system/{run_id}/telemetry         \u2192 O2 (STUB)\n- GET /logs/system/{run_id}/events            \u2192 O3 infra events\n- GET /logs/system/{run_id}/replay            \u2192 O4 infra replay\n- GET /logs/system/audit                      \u2192 O5 infra attribution\n\nAUDIT:\n- GET /logs/audit                             \u2192 List entries\n- GET /logs/audit/identity                    \u2192 O1 identity lifecycle\n- GET /logs/audit/authorization               \u2192 O2 access decisions\n- GET /logs/audit/access                      \u2192 O3 log access audit\n- GET /logs/audit/integrity                   \u2192 O4 tamper detection\n- GET /logs/audit/exports                     \u2192 O5 compliance exports\n\nAll records are:\n- APPEND-ONLY (enforced by DB trigger)\n- WRITE-ONCE (no UPDATE, no DELETE)\n- Trust anchors for verification",
        "functions": [
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 132
          },
          {
            "name": "list_llm_run_records",
            "signature": "(request: Request, run_id: Annotated[Optional[str], Query(description='Filter by run ID')] = None, provider: Annotated[Optional[str], Query(description='Filter by provider')] = None, model: Annotated[Optional[str], Query(description='Filter by model')] = None, execution_status: Annotated[Optional[str], Query(description='Filter by status')] = None, is_synthetic: Annotated[Optional[bool], Query(description='Filter synthetic')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter created_at >=')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter created_at <=')] = None, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> LLMRunRecordsResponse",
            "docstring": "List LLM run records. READ-ONLY customer facade.",
            "is_async": true,
            "line": 516
          },
          {
            "name": "get_llm_run_envelope",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> LLMRunEnvelope",
            "docstring": "O1: Canonical immutable run record. READ-ONLY customer facade.",
            "is_async": true,
            "line": 593
          },
          {
            "name": "get_llm_run_trace",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> LLMRunTrace",
            "docstring": "O2: Step-by-step execution trace. READ-ONLY customer facade.",
            "is_async": true,
            "line": 656
          },
          {
            "name": "get_llm_run_governance",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> LLMRunGovernance",
            "docstring": "O3: Policy interaction trace. READ-ONLY customer facade.",
            "is_async": true,
            "line": 722
          },
          {
            "name": "get_llm_run_replay",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> LLMRunReplay",
            "docstring": "O4: 60-second replay window. READ-ONLY customer facade.",
            "is_async": true,
            "line": 783
          },
          {
            "name": "get_llm_run_export",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> LLMRunExport",
            "docstring": "O5: Export information. READ-ONLY customer facade.",
            "is_async": true,
            "line": 848
          },
          {
            "name": "list_system_records",
            "signature": "(request: Request, component: Annotated[Optional[str], Query(description='Filter by component')] = None, event_type: Annotated[Optional[str], Query(description='Filter by event type')] = None, severity: Annotated[Optional[str], Query(description='Filter by severity')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter created_at >=')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter created_at <=')] = None, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> SystemRecordsResponse",
            "docstring": "List system records. READ-ONLY customer facade.",
            "is_async": true,
            "line": 906
          },
          {
            "name": "get_system_snapshot",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> SystemSnapshot",
            "docstring": "O1: Environment baseline snapshot. READ-ONLY customer facade.",
            "is_async": true,
            "line": 974
          },
          {
            "name": "get_system_telemetry",
            "signature": "(request: Request, run_id: str) -> TelemetryStub",
            "docstring": "O2: Telemetry stub - producer not implemented. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1027
          },
          {
            "name": "get_system_events",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> SystemEvents",
            "docstring": "O3: Infra events affecting run. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1058
          },
          {
            "name": "get_system_replay",
            "signature": "(request: Request, run_id: str, session = Depends(get_session_dep)) -> SystemReplay",
            "docstring": "O4: Infra replay window. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1120
          },
          {
            "name": "get_system_audit",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> SystemAudit",
            "docstring": "O5: Infra attribution. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1183
          },
          {
            "name": "list_audit_entries",
            "signature": "(request: Request, event_type: Annotated[Optional[str], Query(description='Filter by event type')] = None, entity_type: Annotated[Optional[str], Query(description='Filter by entity type')] = None, actor_type: Annotated[Optional[str], Query(description='Filter by actor type')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter created_at >=')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter created_at <=')] = None, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> AuditLedgerResponse",
            "docstring": "List audit entries. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1249
          },
          {
            "name": "get_audit_entry",
            "signature": "(request: Request, entry_id: str, session = Depends(get_session_dep)) -> AuditLedgerDetailItem",
            "docstring": "Get audit entry detail. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1316
          },
          {
            "name": "get_audit_identity",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, session = Depends(get_session_dep)) -> AuditIdentity",
            "docstring": "O1: Identity lifecycle. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1364
          },
          {
            "name": "get_audit_authorization",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, session = Depends(get_session_dep)) -> AuditAuthorization",
            "docstring": "O2: Authorization decisions. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1421
          },
          {
            "name": "get_audit_access",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, session = Depends(get_session_dep)) -> AuditAccess",
            "docstring": "O3: Log access audit. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1480
          },
          {
            "name": "get_audit_integrity",
            "signature": "(request: Request) -> AuditIntegrity",
            "docstring": "O4: Tamper detection. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1539
          },
          {
            "name": "get_audit_exports",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> AuditExports",
            "docstring": "O5: Compliance exports. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1587
          }
        ],
        "classes": [
          {
            "name": "EvidenceMetadata",
            "docstring": "Global metadata contract for all Logs responses.\n\nPer LOGS_DOMAIN_V2_CONTRACT.md, every Logs response MUST include this.\nAbsence is a contract violation.",
            "methods": [],
            "line": 89
          },
          {
            "name": "LLMRunEnvelope",
            "docstring": "O1: Canonical immutable run record.",
            "methods": [],
            "line": 161
          },
          {
            "name": "TraceStep",
            "docstring": "Individual trace step.",
            "methods": [],
            "line": 182
          },
          {
            "name": "LLMRunTrace",
            "docstring": "O2: Step-by-step trace.",
            "methods": [],
            "line": 194
          },
          {
            "name": "GovernanceEvent",
            "docstring": "Policy interaction event.",
            "methods": [],
            "line": 204
          },
          {
            "name": "LLMRunGovernance",
            "docstring": "O3: Policy interaction trace.",
            "methods": [],
            "line": 216
          },
          {
            "name": "ReplayEvent",
            "docstring": "Replay window event.",
            "methods": [],
            "line": 225
          },
          {
            "name": "LLMRunReplay",
            "docstring": "O4: 60-second replay window.",
            "methods": [],
            "line": 235
          },
          {
            "name": "LLMRunExport",
            "docstring": "O5: Export metadata.",
            "methods": [],
            "line": 246
          },
          {
            "name": "LLMRunRecordItem",
            "docstring": "Single LLM run record entry (list view).",
            "methods": [],
            "line": 256
          },
          {
            "name": "LLMRunRecordsResponse",
            "docstring": "Response envelope for LLM run records.",
            "methods": [],
            "line": 275
          },
          {
            "name": "SystemSnapshot",
            "docstring": "O1: Environment snapshot.",
            "methods": [],
            "line": 289
          },
          {
            "name": "TelemetryStub",
            "docstring": "O2: Telemetry stub response.",
            "methods": [],
            "line": 302
          },
          {
            "name": "SystemEvent",
            "docstring": "System event record.",
            "methods": [],
            "line": 312
          },
          {
            "name": "SystemEvents",
            "docstring": "O3: Infra events affecting run.",
            "methods": [],
            "line": 325
          },
          {
            "name": "SystemReplay",
            "docstring": "O4: Infra replay window.",
            "methods": [],
            "line": 334
          },
          {
            "name": "SystemAudit",
            "docstring": "O5: Infra attribution record.",
            "methods": [],
            "line": 344
          },
          {
            "name": "SystemRecordItem",
            "docstring": "Single system record entry.",
            "methods": [],
            "line": 352
          },
          {
            "name": "SystemRecordsResponse",
            "docstring": "Response envelope for system records.",
            "methods": [],
            "line": 366
          },
          {
            "name": "AuditLedgerItem",
            "docstring": "Single audit ledger entry.",
            "methods": [],
            "line": 380
          },
          {
            "name": "AuditLedgerDetailItem",
            "docstring": "Audit ledger entry with state snapshots.",
            "methods": [],
            "line": 393
          },
          {
            "name": "AuditLedgerResponse",
            "docstring": "Response envelope for audit ledger.",
            "methods": [],
            "line": 401
          },
          {
            "name": "IdentityEvent",
            "docstring": "Identity lifecycle event.",
            "methods": [],
            "line": 410
          },
          {
            "name": "AuditIdentity",
            "docstring": "O1: Identity lifecycle.",
            "methods": [],
            "line": 420
          },
          {
            "name": "AuthorizationDecision",
            "docstring": "Authorization decision record.",
            "methods": [],
            "line": 428
          },
          {
            "name": "AuditAuthorization",
            "docstring": "O2: Access decisions.",
            "methods": [],
            "line": 440
          },
          {
            "name": "AccessEvent",
            "docstring": "Log access event.",
            "methods": [],
            "line": 448
          },
          {
            "name": "AuditAccess",
            "docstring": "O3: Log access audit.",
            "methods": [],
            "line": 460
          },
          {
            "name": "IntegrityCheck",
            "docstring": "Integrity verification record.",
            "methods": [],
            "line": 468
          },
          {
            "name": "AuditIntegrity",
            "docstring": "O4: Tamper detection.",
            "methods": [],
            "line": 477
          },
          {
            "name": "ExportRecord",
            "docstring": "Export record.",
            "methods": [],
            "line": 484
          },
          {
            "name": "AuditExports",
            "docstring": "O5: Compliance exports.",
            "methods": [],
            "line": 497
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Literal",
              "Optional"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "monitors.py",
        "file_path": "backend/app/hoc/api/cus/policies/monitors.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 298,
        "module_docstring": "Monitors API (L2)\n\nProvides monitoring operations:\n- POST /monitors (create monitor)\n- GET /monitors (list monitors)\n- GET /monitors/{id} (get monitor)\n- PUT /monitors/{id} (update monitor)\n- DELETE /monitors/{id} (delete monitor)\n- POST /monitors/{id}/check (run health check)\n- GET /monitors/{id}/history (check history)\n- GET /monitors/status (overall status)\n\nThis is the ONLY facade for monitoring operations.\nAll monitor APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> MonitorsFacade",
            "docstring": "Get the monitors facade.",
            "is_async": false,
            "line": 89
          },
          {
            "name": "create_monitor",
            "signature": "(request: CreateMonitorRequest, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.write')))",
            "docstring": "Create a monitor (GAP-121).\n\n**Tier: REACT ($9)** - Monitor configuration.\n\nMonitor types:\n- http: HTTP endpoint monitoring\n- tcp: TCP port monitoring\n- dns: DNS resolution monitoring\n- heartbeat: Passive heartbeat monitoring\n- custom: Custom check implementation",
            "is_async": true,
            "line": 100
          },
          {
            "name": "list_monitors",
            "signature": "(monitor_type: Optional[str] = Query(None, description='Filter by type'), status: Optional[str] = Query(None, description='Filter by status'), enabled_only: bool = Query(False, description='Only enabled monitors'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.read')))",
            "docstring": "List monitors.",
            "is_async": true,
            "line": 134
          },
          {
            "name": "get_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.read')))",
            "docstring": "Get overall monitoring status (GAP-120).\n\nReturns aggregate health status across all monitors.",
            "is_async": true,
            "line": 165
          },
          {
            "name": "get_monitor",
            "signature": "(monitor_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.read')))",
            "docstring": "Get a specific monitor.",
            "is_async": true,
            "line": 181
          },
          {
            "name": "update_monitor",
            "signature": "(monitor_id: str, request: UpdateMonitorRequest, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.write')))",
            "docstring": "Update a monitor.",
            "is_async": true,
            "line": 202
          },
          {
            "name": "delete_monitor",
            "signature": "(monitor_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.write')))",
            "docstring": "Delete a monitor.",
            "is_async": true,
            "line": 231
          },
          {
            "name": "run_check",
            "signature": "(monitor_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.check')))",
            "docstring": "Run a health check (GAP-120).\n\nManually triggers a health check for the monitor.",
            "is_async": true,
            "line": 252
          },
          {
            "name": "get_history",
            "signature": "(monitor_id: str, limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.read')))",
            "docstring": "Get health check history.",
            "is_async": true,
            "line": 275
          }
        ],
        "classes": [
          {
            "name": "CreateMonitorRequest",
            "docstring": "Request to create a monitor.",
            "methods": [],
            "line": 61
          },
          {
            "name": "UpdateMonitorRequest",
            "docstring": "Request to update a monitor.",
            "methods": [],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.monitors_facade",
            "names": [
              "MonitorsFacade",
              "get_monitors_facade"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "notifications.py",
        "file_path": "backend/app/hoc/api/cus/policies/notifications.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 304,
        "module_docstring": "Notifications API (L2)\n\nProvides notification operations:\n- POST /notifications (send notification)\n- GET /notifications (list notifications)\n- GET /notifications/{id} (get notification)\n- POST /notifications/{id}/read (mark as read)\n- GET /notifications/channels (list channels)\n- GET /notifications/preferences (get preferences)\n- PUT /notifications/preferences (update preferences)\n\nThis is the ONLY facade for notification operations.\nAll notification APIs flow through this router.",
        "functions": [
          {
            "name": "send_notification",
            "signature": "(request: SendNotificationRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('notifications.send')))",
            "docstring": "Send a notification (GAP-109).\n\n**Tier: REACT ($9)** - Notification sending.\n\nChannels:\n- email: Email notifications\n- slack: Slack messages\n- webhook: Webhook callbacks\n- in_app: In-app notifications\n- sms: SMS messages (requires configuration)",
            "is_async": true,
            "line": 79
          },
          {
            "name": "list_notifications",
            "signature": "(channel: Optional[str] = Query(None, description='Filter by channel'), status: Optional[str] = Query(None, description='Filter by status'), recipient: Optional[str] = Query(None, description='Filter by recipient'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('notifications.read')))",
            "docstring": "List notifications for the tenant.",
            "is_async": true,
            "line": 121
          },
          {
            "name": "list_channels",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "List available notification channels.",
            "is_async": true,
            "line": 162
          },
          {
            "name": "get_preferences",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('notifications.read')))",
            "docstring": "Get notification preferences for the current user.",
            "is_async": true,
            "line": 187
          },
          {
            "name": "update_preferences",
            "signature": "(request: UpdatePreferencesRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('notifications.write')))",
            "docstring": "Update notification preferences for the current user.",
            "is_async": true,
            "line": 215
          },
          {
            "name": "get_notification",
            "signature": "(notification_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('notifications.read')))",
            "docstring": "Get a specific notification.",
            "is_async": true,
            "line": 246
          },
          {
            "name": "mark_as_read",
            "signature": "(notification_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('notifications.write')))",
            "docstring": "Mark a notification as read.",
            "is_async": true,
            "line": 277
          }
        ],
        "classes": [
          {
            "name": "SendNotificationRequest",
            "docstring": "Request to send notification.",
            "methods": [],
            "line": 57
          },
          {
            "name": "UpdatePreferencesRequest",
            "docstring": "Request to update notification preferences.",
            "methods": [],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "override.py",
        "file_path": "backend/app/hoc/api/cus/policies/override.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 353,
        "module_docstring": "Limit Override API (PIN-LIM-05)\n\nTemporary limit override request endpoints.\n\nAllows authorized users to request temporary increases to limits,\nwith approval workflow and automatic expiry.\n\nEndpoints:\n    POST /limits/overrides         \u2192 Request new override\n    GET  /limits/overrides         \u2192 List overrides for tenant\n    GET  /limits/overrides/{id}    \u2192 Get specific override\n    DELETE /limits/overrides/{id}  \u2192 Cancel override",
        "functions": [
          {
            "name": "create_override",
            "signature": "(request: Request, body: CreateOverrideRequest, session = Depends(get_session_dep)) -> OverrideDetail",
            "docstring": "Request a temporary limit override.\n\n- Requires justification (reason)\n- Maximum 5 active overrides per tenant\n- Maximum duration: 168 hours (1 week)\n- Cannot stack multiple overrides on same limit",
            "is_async": true,
            "line": 122
          },
          {
            "name": "list_overrides",
            "signature": "(request: Request, status: Optional[str] = Query(default=None, description='Filter by status'), limit: int = Query(default=20, ge=1, le=100), offset: int = Query(default=0, ge=0), session = Depends(get_session_dep)) -> OverrideListResponse",
            "docstring": "List overrides for the tenant.",
            "is_async": true,
            "line": 186
          },
          {
            "name": "get_override",
            "signature": "(request: Request, override_id: str, session = Depends(get_session_dep)) -> OverrideDetail",
            "docstring": "Get override by ID.",
            "is_async": true,
            "line": 234
          },
          {
            "name": "cancel_override",
            "signature": "(request: Request, override_id: str, session = Depends(get_session_dep)) -> OverrideDetail",
            "docstring": "Cancel a pending or active override.",
            "is_async": true,
            "line": 274
          },
          {
            "name": "_to_detail",
            "signature": "(result: LimitOverrideResponse) -> OverrideDetail",
            "docstring": "Convert service response to API response.",
            "is_async": false,
            "line": 318
          },
          {
            "name": "_to_list_item",
            "signature": "(result: LimitOverrideResponse) -> OverrideListItem",
            "docstring": "Convert service response to list item.",
            "is_async": false,
            "line": 340
          }
        ],
        "classes": [
          {
            "name": "CreateOverrideRequest",
            "docstring": "Request to create a limit override.",
            "methods": [],
            "line": 54
          },
          {
            "name": "OverrideListItem",
            "docstring": "Override summary for list view.",
            "methods": [],
            "line": 65
          },
          {
            "name": "OverrideDetail",
            "docstring": "Full override details.",
            "methods": [],
            "line": 80
          },
          {
            "name": "OverrideListResponse",
            "docstring": "Response for override list.",
            "methods": [],
            "line": 101
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.schemas.limits.overrides",
            "names": [
              "LimitOverrideRequest",
              "LimitOverrideResponse",
              "OverrideStatus"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policies.py",
        "file_path": "backend/app/hoc/api/cus/policies/policies.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1658,
        "module_docstring": "Unified Policies API (L2)\n\nCustomer-facing endpoints for viewing policy rules and limits.\nAll requests are tenant-scoped via auth_context.\n\nEndpoints:\n- GET /policies/rules           \u2192 O2 list of policy rules\n- GET /policies/rules/{rule_id} \u2192 O3 rule detail\n- GET /policies/limits          \u2192 O2 list of limits\n- GET /policies/limits/{limit_id} \u2192 O3 limit detail\n\nArchitecture:\n- ONE facade for all POLICIES needs (rules + limits)\n- Queries PolicyRule, PolicyRuleIntegrity, Limit, LimitIntegrity tables\n- Tenant isolation via auth_context (not header)\n- SDSR validates this same production API",
        "functions": [
          {
            "name": "require_preflight",
            "signature": "() -> None",
            "docstring": "Guard for preflight-only endpoints (O4, O5).",
            "is_async": false,
            "line": 62
          },
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 202
          },
          {
            "name": "list_policy_rules",
            "signature": "(request: Request, status: Annotated[str, Query(description='Rule status: ACTIVE or RETIRED', pattern='^(ACTIVE|RETIRED)$')] = 'ACTIVE', enforcement_mode: Annotated[Optional[str], Query(description='Filter by enforcement mode: BLOCK, WARN, AUDIT, DISABLED', pattern='^(BLOCK|WARN|AUDIT|DISABLED)$')] = None, scope: Annotated[Optional[str], Query(description='Filter by scope: GLOBAL, TENANT, PROJECT, AGENT', pattern='^(GLOBAL|TENANT|PROJECT|AGENT)$')] = None, source: Annotated[Optional[str], Query(description='Filter by source: MANUAL, SYSTEM, LEARNED', pattern='^(MANUAL|SYSTEM|LEARNED)$')] = None, rule_type: Annotated[Optional[str], Query(description='Filter by rule type: SYSTEM, SAFETY, ETHICAL, TEMPORAL (PIN-411 Gap Closure)', pattern='^(SYSTEM|SAFETY|ETHICAL|TEMPORAL)$')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter by created_at >= value')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter by created_at <= value')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max rules to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of rules to skip')] = 0, session = Depends(get_session_dep)) -> RulesListResponse",
            "docstring": "List policy rules with unified query filters. READ-ONLY.",
            "is_async": true,
            "line": 241
          },
          {
            "name": "get_policy_rule_detail",
            "signature": "(request: Request, rule_id: str, session = Depends(get_session_dep)) -> PolicyRuleDetailResponse",
            "docstring": "Get policy rule detail (O3). Tenant isolation enforced.",
            "is_async": true,
            "line": 360
          },
          {
            "name": "list_limits",
            "signature": "(request: Request, category: Annotated[str, Query(alias='type', description='Limit category: BUDGET, RATE, or THRESHOLD', pattern='^(BUDGET|RATE|THRESHOLD)$')] = 'BUDGET', status: Annotated[str, Query(description='Limit status: ACTIVE or DISABLED', pattern='^(ACTIVE|DISABLED)$')] = 'ACTIVE', scope: Annotated[Optional[str], Query(description='Filter by scope: GLOBAL, TENANT, PROJECT, AGENT, PROVIDER', pattern='^(GLOBAL|TENANT|PROJECT|AGENT|PROVIDER)$')] = None, enforcement: Annotated[Optional[str], Query(description='Filter by enforcement: BLOCK, WARN, REJECT, QUEUE, DEGRADE, ALERT', pattern='^(BLOCK|WARN|REJECT|QUEUE|DEGRADE|ALERT)$')] = None, limit_type: Annotated[Optional[str], Query(description='Filter by limit_type. Supports prefix match, e.g. RUNS_*, TOKENS_*, RISK_CEILING, COOLDOWN (PIN-411 Gap Closure)')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter by created_at >= value')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter by created_at <= value')] = None, max_limit: Annotated[int, Query(ge=1, le=100, alias='limit', description='Max limits to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of limits to skip')] = 0, session = Depends(get_session_dep)) -> LimitsListResponse",
            "docstring": "List limits with unified query filters. READ-ONLY.",
            "is_async": true,
            "line": 432
          },
          {
            "name": "get_limit_detail",
            "signature": "(request: Request, limit_id: str, session = Depends(get_session_dep)) -> LimitDetailResponse",
            "docstring": "Get limit detail (O3). Tenant isolation enforced.",
            "is_async": true,
            "line": 555
          },
          {
            "name": "get_rule_evidence",
            "signature": "(request: Request, rule_id: str) -> dict[str, Any]",
            "docstring": "Get rule evidence (O4). Preflight console only.",
            "is_async": true,
            "line": 625
          },
          {
            "name": "get_limit_evidence",
            "signature": "(request: Request, limit_id: str) -> dict[str, Any]",
            "docstring": "Get limit evidence (O4). Preflight console only.",
            "is_async": true,
            "line": 651
          },
          {
            "name": "list_lessons",
            "signature": "(request: Request, lesson_type: Annotated[Optional[str], Query(description='Filter by type: failure, near_threshold, critical_success', pattern='^(failure|near_threshold|critical_success)$')] = None, status: Annotated[Optional[str], Query(description='Filter by status: pending, converted_to_draft, deferred, dismissed', pattern='^(pending|converted_to_draft|deferred|dismissed)$')] = None, severity: Annotated[Optional[str], Query(description='Filter by severity: CRITICAL, HIGH, MEDIUM, LOW', pattern='^(CRITICAL|HIGH|MEDIUM|LOW)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max lessons to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of lessons to skip')] = 0, session = Depends(get_session_dep)) -> LessonsListResponse",
            "docstring": "List lessons learned (O2). READ-ONLY customer facade.",
            "is_async": true,
            "line": 732
          },
          {
            "name": "get_lesson_stats",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> LessonStatsResponse",
            "docstring": "Get lesson statistics (O1). READ-ONLY customer facade.",
            "is_async": true,
            "line": 813
          },
          {
            "name": "get_lesson_detail",
            "signature": "(request: Request, lesson_id: str, session = Depends(get_session_dep)) -> LessonDetailResponse",
            "docstring": "Get lesson detail (O3). READ-ONLY customer facade.",
            "is_async": true,
            "line": 848
          },
          {
            "name": "get_policy_state",
            "signature": "(request: Request, session = Depends(get_session_dep)) -> PolicyStateResponse",
            "docstring": "Get policy layer state (ACT-O4). Customer facade.",
            "is_async": true,
            "line": 920
          },
          {
            "name": "get_policy_metrics",
            "signature": "(request: Request, hours: Annotated[int, Query(ge=1, le=720, description='Time window in hours')] = 24, session = Depends(get_session_dep)) -> PolicyMetricsResponse",
            "docstring": "Get policy metrics (ACT-O5). Customer facade.",
            "is_async": true,
            "line": 987
          },
          {
            "name": "list_policy_conflicts",
            "signature": "(request: Request, policy_id: Annotated[Optional[str], Query(description='Filter to conflicts involving this policy')] = None, severity: Annotated[Optional[str], Query(description='Filter by severity: BLOCKING, WARNING')] = None, include_resolved: Annotated[bool, Query(description='Include resolved conflicts')] = False, session = Depends(get_session_dep)) -> ConflictsListResponse",
            "docstring": "Detect policy conflicts (DFT-O4). Uses PolicyConflictEngine via facade.",
            "is_async": true,
            "line": 1078
          },
          {
            "name": "get_policy_dependencies",
            "signature": "(request: Request, policy_id: Annotated[Optional[str], Query(description='Filter to dependencies involving this policy')] = None, session = Depends(get_session_dep)) -> DependencyGraphResponse",
            "docstring": "Get policy dependency graph (DFT-O5). Uses PolicyDependencyEngine via facade.",
            "is_async": true,
            "line": 1214
          },
          {
            "name": "list_policy_violations",
            "signature": "(request: Request, violation_type: Annotated[Optional[str], Query(description='Filter by type: cost, quota, rate, temporal, safety, ethical', pattern='^(cost|quota|rate|temporal|safety|ethical)$')] = None, source: Annotated[Optional[str], Query(description='Filter by source: guard, sim, runtime, cost (PIN-411 Gap Closure)', pattern='^(guard|sim|runtime|cost)$')] = None, severity_min: Annotated[Optional[float], Query(ge=0.0, le=1.0, description='Minimum severity (0.0-1.0)')] = None, violation_kind: Annotated[Optional[str], Query(description='Filter by violation kind: STANDARD, ANOMALY, DIVERGENCE (PIN-411 Gap Closure)', pattern='^(STANDARD|ANOMALY|DIVERGENCE)$')] = None, hours: Annotated[int, Query(ge=1, le=720, description='Time window in hours')] = 24, include_synthetic: Annotated[bool, Query(description='Include synthetic/simulated')] = False, limit: Annotated[int, Query(ge=1, le=100, description='Max items')] = 50, offset: Annotated[int, Query(ge=0, description='Offset')] = 0, session = Depends(get_session_dep)) -> ViolationsListResponse",
            "docstring": "List policy violations (VIO-O1). Unified customer facade.",
            "is_async": true,
            "line": 1338
          },
          {
            "name": "list_budget_definitions",
            "signature": "(request: Request, scope: Annotated[Optional[str], Query(description='Filter by scope: GLOBAL, TENANT, PROJECT, AGENT', pattern='^(GLOBAL|TENANT|PROJECT|AGENT)$')] = None, status: Annotated[str, Query(description='Filter by status: ACTIVE, DISABLED', pattern='^(ACTIVE|DISABLED)$')] = 'ACTIVE', limit: Annotated[int, Query(ge=1, le=100)] = 20, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> BudgetsListResponse",
            "docstring": "List budget definitions (THR-O2). Customer facade.",
            "is_async": true,
            "line": 1466
          },
          {
            "name": "list_policy_requests",
            "signature": "(request: Request, status: Annotated[str, Query(description='Filter by status: draft, approved, rejected (default: draft)', pattern='^(draft|approved|rejected)$')] = 'draft', proposal_type: Annotated[Optional[str], Query(description='Filter by proposal type: rate_limit, cost_cap, retry_policy')] = None, days_old: Annotated[Optional[int], Query(ge=1, le=365, description='Filter to requests older than N days')] = None, include_synthetic: Annotated[bool, Query()] = False, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session = Depends(get_session_dep)) -> PolicyRequestsListResponse",
            "docstring": "List pending policy requests (ACT-O3). Customer facade.",
            "is_async": true,
            "line": 1578
          }
        ],
        "classes": [
          {
            "name": "PolicyRuleSummary",
            "docstring": "O2 Result Shape for policy rules.",
            "methods": [],
            "line": 79
          },
          {
            "name": "RulesListResponse",
            "docstring": "GET /rules response (O2).",
            "methods": [],
            "line": 96
          },
          {
            "name": "PolicyRuleDetailResponse",
            "docstring": "GET /rules/{rule_id} response (O3).",
            "methods": [],
            "line": 105
          },
          {
            "name": "LimitSummary",
            "docstring": "O2 Result Shape for limits.",
            "methods": [],
            "line": 132
          },
          {
            "name": "LimitsListResponse",
            "docstring": "GET /limits response (O2).",
            "methods": [],
            "line": 152
          },
          {
            "name": "LimitDetailResponse",
            "docstring": "GET /limits/{limit_id} response (O3).",
            "methods": [],
            "line": 161
          },
          {
            "name": "LessonSummaryResponse",
            "docstring": "O2 Result Shape for lessons.",
            "methods": [],
            "line": 673
          },
          {
            "name": "LessonsListResponse",
            "docstring": "GET /lessons response (O2).",
            "methods": [],
            "line": 686
          },
          {
            "name": "LessonDetailResponse",
            "docstring": "GET /lessons/{id} response (O3).",
            "methods": [],
            "line": 695
          },
          {
            "name": "LessonStatsResponse",
            "docstring": "Lesson statistics response.",
            "methods": [],
            "line": 715
          },
          {
            "name": "PolicyStateResponse",
            "docstring": "Policy layer state summary (ACT-O4).",
            "methods": [],
            "line": 899
          },
          {
            "name": "PolicyMetricsResponse",
            "docstring": "Policy enforcement metrics (ACT-O5).",
            "methods": [],
            "line": 965
          },
          {
            "name": "PolicyConflictResponse",
            "docstring": "Policy conflict summary (DFT-O4 spec).",
            "methods": [],
            "line": 1037
          },
          {
            "name": "ConflictsListResponse",
            "docstring": "GET /conflicts response (DFT-O4).",
            "methods": [],
            "line": 1051
          },
          {
            "name": "PolicyDependencyRelation",
            "docstring": "A dependency relationship detail.",
            "methods": [],
            "line": 1150
          },
          {
            "name": "PolicyNodeResponse",
            "docstring": "A node in the dependency graph (DFT-O5 spec).",
            "methods": [],
            "line": 1159
          },
          {
            "name": "PolicyDependencyEdge",
            "docstring": "A dependency edge in the graph.",
            "methods": [],
            "line": 1172
          },
          {
            "name": "DependencyGraphResponse",
            "docstring": "GET /dependencies response (DFT-O5).",
            "methods": [],
            "line": 1183
          },
          {
            "name": "PolicyViolationSummary",
            "docstring": "Policy violation summary (VIO-O1).",
            "methods": [],
            "line": 1305
          },
          {
            "name": "ViolationsListResponse",
            "docstring": "GET /violations response (VIO-O1).",
            "methods": [],
            "line": 1320
          },
          {
            "name": "BudgetDefinitionSummary",
            "docstring": "Budget definition summary (THR-O2).",
            "methods": [],
            "line": 1435
          },
          {
            "name": "BudgetsListResponse",
            "docstring": "GET /budgets response (THR-O2).",
            "methods": [],
            "line": 1449
          },
          {
            "name": "PolicyRequestSummary",
            "docstring": "Summary of a pending policy request (draft proposal).",
            "methods": [],
            "line": 1544
          },
          {
            "name": "PolicyRequestsListResponse",
            "docstring": "Response for policy requests list (ACT-O3).",
            "methods": [],
            "line": 1558
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [
          {
            "name": "_CURRENT_ENVIRONMENT",
            "line": 59
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "policy.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 2268,
        "module_docstring": "Policy API Endpoints (M5)\n\nProvides:\n1. Policy sandbox evaluation (/policy/eval)\n2. Approval workflow endpoints (/policy/requests/*)\n3. Webhook callbacks for async approvals\n\nIntegrates with:\n- PolicyEnforcer from workflow/policies.py\n- PolicyApprovalLevel and ApprovalRequest from db.py\n- Workflow metrics for observability\n- CostSim V2 for simulation\n\nNOTE: Policy subsystem MUST use AsyncSession - async endpoints + M17/M19 routing.\n      Do NOT import sync Session from sqlmodel. See test_m19_policy.py guardrail tests.\n\nTier Gating (M32 - PIN-158):\n- PREVENT ($199): Policy evaluation sandbox (pre-execution decisions)\n- ASSIST ($1.5k+): Approval workflows (advanced orchestration)",
        "functions": [
          {
            "name": "_get_policy_adapter",
            "signature": "()",
            "docstring": "Get the L3 policy adapter.\n\nThis is the ONLY way L2 should access policy functionality.\nF-P-RULE-1: Policy Decisions Live Only in L4.",
            "is_async": false,
            "line": 81
          },
          {
            "name": "_record_policy_decision",
            "signature": "(decision: str, policy_type: str) -> None",
            "docstring": "Record policy decision metric via L3 adapter.",
            "is_async": false,
            "line": 99
          },
          {
            "name": "_record_capability_violation",
            "signature": "(violation_type: str, skill_id: str, tenant_id: Optional[str] = None) -> None",
            "docstring": "Record capability violation metric via L3 adapter.",
            "is_async": false,
            "line": 105
          },
          {
            "name": "_record_budget_rejection",
            "signature": "(resource_type: str, skill_id: str) -> None",
            "docstring": "Record budget rejection metric via L3 adapter.",
            "is_async": false,
            "line": 111
          },
          {
            "name": "_record_approval_request_created",
            "signature": "(policy_type: str) -> None",
            "docstring": "Record approval request creation metric via L3 adapter.",
            "is_async": false,
            "line": 117
          },
          {
            "name": "_record_approval_action",
            "signature": "(result: str) -> None",
            "docstring": "Record approval action metric via L3 adapter.",
            "is_async": false,
            "line": 123
          },
          {
            "name": "_record_approval_escalation",
            "signature": "() -> None",
            "docstring": "Record approval escalation metric via L3 adapter.",
            "is_async": false,
            "line": 129
          },
          {
            "name": "_record_webhook_fallback",
            "signature": "() -> None",
            "docstring": "Record webhook fallback metric via L3 adapter.",
            "is_async": false,
            "line": 135
          },
          {
            "name": "_check_rate_limit",
            "signature": "(tenant_id: str, endpoint: str = 'policy') -> None",
            "docstring": "Check rate limit for tenant. Raises HTTPException if exceeded.\n\nArgs:\n    tenant_id: Tenant identifier for rate limiting\n    endpoint: Endpoint category for different limits\n\nRaises:\n    HTTPException: 429 if rate limit exceeded",
            "is_async": false,
            "line": 282
          },
          {
            "name": "_get_policy_version",
            "signature": "() -> str",
            "docstring": "Get current policy version.",
            "is_async": false,
            "line": 326
          },
          {
            "name": "_hash_webhook_secret",
            "signature": "(secret: str) -> str",
            "docstring": "Hash webhook secret for storage.",
            "is_async": false,
            "line": 331
          },
          {
            "name": "_get_approval_level_config",
            "signature": "(session, policy_type: PolicyType, tenant_id: str, agent_id: Optional[str] = None, skill_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Get approval level configuration from PolicyApprovalLevel table.\n\nUses L4 registry dispatch to maintain L2 purity (no session.execute).",
            "is_async": true,
            "line": 336
          },
          {
            "name": "_simulate_cost",
            "signature": "(skill_id: str, tenant_id: str, payload: Dict[str, Any]) -> Optional[int]",
            "docstring": "Simulate cost for a skill execution via L3 adapter.\n\nPhase F-3: This replaces the direct L5 CostSimulator import.\nF-P-RULE-4: No Dual Ownership - CostSimulator logic stays intact in L5.",
            "is_async": true,
            "line": 380
          },
          {
            "name": "_check_policy_violations",
            "signature": "(skill_id: str, tenant_id: str, agent_id: Optional[str], payload: Dict[str, Any], simulated_cost: Optional[int]) -> List[Dict[str, Any]]",
            "docstring": "Check for policy violations via L3 adapter.\n\nPhase F-3: This replaces the direct L5 PolicyEnforcer import.\nF-P-RULE-1: Policy Decisions Live Only in L4 - L4 handles enforcement.\nF-P-RULE-2: Metrics Are Effects - L4 emits metrics via L5.",
            "is_async": true,
            "line": 395
          },
          {
            "name": "_compute_webhook_signature",
            "signature": "(payload: str, secret: str) -> str",
            "docstring": "Compute HMAC-SHA256 signature for webhook.",
            "is_async": false,
            "line": 415
          },
          {
            "name": "_send_webhook",
            "signature": "(url: str, payload: Dict[str, Any], secret: Optional[str] = None, key_version: Optional[str] = None, retry_count: int = 0) -> bool",
            "docstring": "Send webhook callback with retry logic and key versioning.\n\nArgs:\n    url: Webhook endpoint URL\n    payload: JSON payload to send\n    secret: HMAC secret for signing\n    key_version: Version of the key used for signing (for rotation support)\n    retry_count: Current retry attempt\n\nReturns:\n    True if webhook delivered successfully",
            "is_async": true,
            "line": 422
          },
          {
            "name": "verify_webhook_signature",
            "signature": "(body: str, signature: str, key_version: str, secrets: Dict[str, str]) -> bool",
            "docstring": "Verify webhook signature with version support for rotation.\n\nDuring key rotation, accepts signatures from:\n1. Current key version\n2. Any version in grace period (WEBHOOK_KEY_GRACE_VERSIONS)\n\nArgs:\n    body: Raw request body\n    signature: Signature from X-Webhook-Signature header (sha256=...)\n    key_version: Version from X-Webhook-Key-Version header\n    secrets: Dict mapping version -> secret\n\nReturns:\n    True if signature is valid",
            "is_async": false,
            "line": 477
          },
          {
            "name": "evaluate_policy",
            "signature": "(request: PolicyEvalRequest, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('policy.audit'))) -> PolicyEvalResponse",
            "docstring": "Sandbox evaluation of policy for a skill execution.\n\n**Tier: PREVENT ($199)** - Pre-execution policy evaluation. \"You stop the fire.\"",
            "is_async": true,
            "line": 521
          },
          {
            "name": "create_approval_request",
            "signature": "(request: ApprovalRequestCreate, background_tasks: BackgroundTasks, session = Depends(get_session_dep)) -> ApprovalRequestResponse",
            "docstring": "Create a new approval request (persisted to DB).",
            "is_async": true,
            "line": 596
          },
          {
            "name": "get_approval_request",
            "signature": "(request_id: str, session = Depends(get_session_dep)) -> ApprovalStatusResponse",
            "docstring": "Get the current status of an approval request.",
            "is_async": true,
            "line": 687
          },
          {
            "name": "_check_approver_authorization",
            "signature": "(approver_id: str, level: int, tenant_id: Optional[str] = None) -> None",
            "docstring": "RBAC: Verify approver has permission to approve at the given level.\n\nUses the RBAC module when RBAC_ENABLED=true, otherwise allows all approvals.\n\nApproval Levels:\n- Level 1-2: Any authenticated user (team_member, engineer)\n- Level 3: Team lead, senior_engineer, tech_lead\n- Level 4: Manager, director, policy_admin\n- Level 5: Owner override (requires audit)\n\nRaises:\n    HTTPException: If approver lacks required permissions",
            "is_async": false,
            "line": 762
          },
          {
            "name": "approve_request",
            "signature": "(request_id: str, action: ApprovalAction, background_tasks: BackgroundTasks, session = Depends(get_session_dep)) -> ApprovalStatusResponse",
            "docstring": "Approve an approval request.",
            "is_async": true,
            "line": 836
          },
          {
            "name": "reject_request",
            "signature": "(request_id: str, action: ApprovalAction, background_tasks: BackgroundTasks, session = Depends(get_session_dep)) -> ApprovalStatusResponse",
            "docstring": "Reject an approval request.",
            "is_async": true,
            "line": 963
          },
          {
            "name": "list_approval_requests",
            "signature": "(status: Optional[ApprovalStatus] = None, tenant_id: Optional[str] = None, limit: int = 50, offset: int = 0, session = Depends(get_session_dep)) -> List[ApprovalStatusResponse]",
            "docstring": "List approval requests with optional filtering.",
            "is_async": true,
            "line": 1057
          },
          {
            "name": "run_escalation_check",
            "signature": "(session) -> int",
            "docstring": "Check for pending requests that need escalation.\nCalled by external scheduler (cron/celery).",
            "is_async": true,
            "line": 1154
          },
          {
            "name": "run_escalation_task",
            "signature": "()",
            "docstring": "Entry point for scheduled escalation check.\nCan be called from cron, celery, or APScheduler.",
            "is_async": false,
            "line": 1254
          },
          {
            "name": "_build_policy_metadata_from_rule",
            "signature": "(rule) -> PolicyMetadata",
            "docstring": "Build PolicyMetadata from a PolicyRule model instance.\n\nMaps available model fields to governance metadata schema.\nFields not in the model are left as None (to be populated when\nthe underlying schema evolves).",
            "is_async": false,
            "line": 1334
          },
          {
            "name": "_build_policy_metadata_from_limit",
            "signature": "(limit) -> PolicyMetadata",
            "docstring": "Build PolicyMetadata from a Limit model instance.\n\nMaps available model fields to governance metadata schema.",
            "is_async": false,
            "line": 1355
          },
          {
            "name": "_build_policy_metadata_from_violation",
            "signature": "(v) -> PolicyMetadata",
            "docstring": "Build PolicyMetadata from a violation object (from policy engine).\n\nViolations are system-generated enforcement events.",
            "is_async": false,
            "line": 1374
          },
          {
            "name": "_build_policy_metadata_from_lesson",
            "signature": "(lesson: dict) -> PolicyMetadata",
            "docstring": "Build PolicyMetadata from a lesson dict (from lessons_learned_engine).\n\nMaps available dict fields to governance metadata schema.",
            "is_async": false,
            "line": 1393
          },
          {
            "name": "get_active_policies",
            "signature": "(scope: Optional[str] = None, enforcement_mode: Optional[str] = None, limit: int = 50, offset: int = 0, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> ActivePoliciesResponse",
            "docstring": "V2 Facade: What governs execution now?",
            "is_async": true,
            "line": 1573
          },
          {
            "name": "get_active_policy_detail",
            "signature": "(policy_id: str, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> dict",
            "docstring": "V2 Facade: Policy detail for cross-domain navigation.",
            "is_async": true,
            "line": 1654
          },
          {
            "name": "get_policy_library",
            "signature": "(status: Optional[str] = None, rule_type: Optional[str] = None, limit: int = 50, offset: int = 0, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> PolicyLibraryResponse",
            "docstring": "V2 Facade: What patterns are available?",
            "is_async": true,
            "line": 1725
          },
          {
            "name": "get_policy_lessons",
            "signature": "(status: Optional[str] = None, lesson_type: Optional[str] = None, limit: int = 50, offset: int = 0, ctx: TenantContext = Depends(get_tenant_context)) -> LessonsResponse",
            "docstring": "V2 Facade: What governance emerged?",
            "is_async": true,
            "line": 1812
          },
          {
            "name": "get_policy_lesson_detail",
            "signature": "(lesson_id: str, ctx: TenantContext = Depends(get_tenant_context)) -> dict",
            "docstring": "V2 Facade: Lesson detail for cross-domain navigation.",
            "is_async": true,
            "line": 1898
          },
          {
            "name": "get_policy_thresholds",
            "signature": "(limit_category: Optional[str] = None, scope: Optional[str] = None, status: str = 'ACTIVE', limit: int = 50, offset: int = 0, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> ThresholdsResponse",
            "docstring": "V2 Facade: What limits are enforced?",
            "is_async": true,
            "line": 1973
          },
          {
            "name": "get_policy_threshold_detail",
            "signature": "(threshold_id: str, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> dict",
            "docstring": "V2 Facade: Threshold detail for cross-domain navigation.",
            "is_async": true,
            "line": 2054
          },
          {
            "name": "get_policy_violations_v2",
            "signature": "(violation_type: Optional[str] = None, severity_min: Optional[float] = None, hours: int = 24, limit: int = 50, offset: int = 0, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> ViolationsResponse",
            "docstring": "V2 Facade: What enforcement occurred?",
            "is_async": true,
            "line": 2129
          },
          {
            "name": "get_policy_violation_detail",
            "signature": "(violation_id: str, session = Depends(get_session_dep), ctx: TenantContext = Depends(get_tenant_context)) -> dict",
            "docstring": "V2 Facade: Violation detail for cross-domain navigation.",
            "is_async": true,
            "line": 2210
          }
        ],
        "classes": [
          {
            "name": "PolicyType",
            "docstring": "Types of policies that can be evaluated.",
            "methods": [],
            "line": 146
          },
          {
            "name": "ApprovalStatus",
            "docstring": "Status of an approval request.",
            "methods": [],
            "line": 155
          },
          {
            "name": "PolicyEvalRequest",
            "docstring": "Request for policy sandbox evaluation.",
            "methods": [],
            "line": 166
          },
          {
            "name": "PolicyEvalResponse",
            "docstring": "Response from policy sandbox evaluation.",
            "methods": [],
            "line": 177
          },
          {
            "name": "ApprovalRequestCreate",
            "docstring": "Request to create an approval request.",
            "methods": [],
            "line": 189
          },
          {
            "name": "ApprovalRequestResponse",
            "docstring": "Response when creating an approval request.",
            "methods": [],
            "line": 204
          },
          {
            "name": "ApprovalAction",
            "docstring": "Action to approve or reject a request.",
            "methods": [],
            "line": 215
          },
          {
            "name": "ApprovalStatusResponse",
            "docstring": "Full status of an approval request.",
            "methods": [],
            "line": 223
          },
          {
            "name": "PolicyMetadata",
            "docstring": "Governance metadata for policy artifacts (aos_sdk-grade).\n\nSTATUS: DECLARED (PARTIALLY MATERIALIZED)\nReference: docs/contracts/CROSS_DOMAIN_INVARIANTS.md Section IX\nMaturity: docs/contracts/METADATA_MATURITY.md\n\nProvides provenance, lifecycle, and accountability traceability\nfor cross-domain consumers per CROSS_DOMAIN_INVARIANTS.md.\n\nNULL SEMANTICS (INV-META-NULL-001):\n===================================\nA null field means \"NOT YET MATERIALIZED\", not \"NOT APPLICABLE\" or \"DENIED\".\nConsumers MUST NOT:\n- Branch on `field is None` to infer absence\n- Treat null as negative truth (e.g., null approved_by \u2260 rejected)\n- Auto-populate nulls with system actors\n\nFIELD CLASSIFICATION:\n=====================\nClass A (Immutable Provenance) \u2014 DB-backed, never changes once written:\n  - created_by, created_at, origin, source_proposal_id\n\nClass B (Governance Decisions) \u2014 Human-gated, requires workflow:\n  - approved_by, approved_at (null until proposal workflow is real)\n\nClass C (Temporal Validity) \u2014 Required before historical analytics:\n  - effective_from, effective_until (default: effective_from = created_at)",
            "methods": [],
            "line": 1285
          },
          {
            "name": "PolicyContextSummary",
            "docstring": "Summary of an active policy for cross-domain consumption.",
            "methods": [],
            "line": 1429
          },
          {
            "name": "ActivePoliciesResponse",
            "docstring": "GET /policy/active response \u2014 What governs execution now?",
            "methods": [],
            "line": 1445
          },
          {
            "name": "PolicyLibrarySummary",
            "docstring": "Summary of a policy rule in the library.",
            "methods": [],
            "line": 1455
          },
          {
            "name": "PolicyLibraryResponse",
            "docstring": "GET /policy/library response \u2014 What patterns are available?",
            "methods": [],
            "line": 1471
          },
          {
            "name": "PolicyLessonSummary",
            "docstring": "Summary of a lesson or draft for cross-domain consumption.",
            "methods": [],
            "line": 1479
          },
          {
            "name": "LessonsResponse",
            "docstring": "GET /policy/lessons response \u2014 What governance emerged?",
            "methods": [],
            "line": 1495
          },
          {
            "name": "ThresholdSummary",
            "docstring": "Summary of an enforced limit/threshold.",
            "methods": [],
            "line": 1505
          },
          {
            "name": "ThresholdsResponse",
            "docstring": "GET /policy/thresholds response \u2014 What limits are enforced?",
            "methods": [],
            "line": 1521
          },
          {
            "name": "ViolationSummary",
            "docstring": "Summary of a policy violation for cross-domain consumption.",
            "methods": [],
            "line": 1529
          },
          {
            "name": "ViolationsResponse",
            "docstring": "GET /policy/violations response \u2014 What enforcement occurred?",
            "methods": [],
            "line": 1546
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "BackgroundTasks",
              "Depends",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "TenantTier",
              "requires_feature",
              "requires_tier"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_async_session_context",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges",
            "names": [
              "get_policies_engine_bridge"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 69
          }
        ],
        "constants": [
          {
            "name": "WEBHOOK_MAX_RETRIES",
            "line": 252
          },
          {
            "name": "WEBHOOK_RETRY_DELAYS",
            "line": 253
          },
          {
            "name": "WEBHOOK_CURRENT_KEY_VERSION",
            "line": 262
          },
          {
            "name": "WEBHOOK_KEY_GRACE_VERSIONS",
            "line": 269
          },
          {
            "name": "WEBHOOK_KEY_GRACE_VERSIONS",
            "line": 270
          },
          {
            "name": "RATE_LIMIT_ENABLED",
            "line": 277
          },
          {
            "name": "RATE_LIMIT_DEFAULT_RPM",
            "line": 278
          },
          {
            "name": "RATE_LIMIT_BURST_RPM",
            "line": 279
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "policy_layer.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy_layer.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1876,
        "module_docstring": null,
        "functions": [
          {
            "name": "evaluate_action",
            "signature": "(request: EvaluateRequest, db = Depends(get_session_dep)) -> PolicyEvaluationResult",
            "docstring": "Evaluate a proposed action against all applicable policies.\n\nThis is the primary endpoint that agents MUST call before:\n- Routing decisions (CARE)\n- Task/skill execution\n- Strategy adaptation (SBA)\n- Escalation to humans\n- Self-modification\n- Agent spawning/invocation\n- Data access\n- External API calls\n\nReturns ALLOW, BLOCK, or MODIFY with detailed reasoning.",
            "is_async": true,
            "line": 139
          },
          {
            "name": "simulate_evaluation",
            "signature": "(request: SimulateRequest, db = Depends(get_session_dep)) -> PolicyEvaluationResult",
            "docstring": "Simulate policy evaluation without side effects.\n\nUseful for:\n- Testing policy configurations\n- Debugging why actions are blocked\n- Pre-flight checks before batch operations\n\nDoes NOT:\n- Record the evaluation\n- Update risk ceiling counters\n- Create violation records\n- Route to governor",
            "is_async": true,
            "line": 188
          },
          {
            "name": "get_policy_state",
            "signature": "(db = Depends(get_session_dep)) -> PolicyState",
            "docstring": "Get the current state of the policy layer.\n\nReturns summary of:\n- Active policies by category\n- Evaluation statistics\n- Violation counts\n- Risk ceiling status",
            "is_async": true,
            "line": 233
          },
          {
            "name": "reload_policies",
            "signature": "(db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Hot-reload policies from database.\n\nUse this after updating policies to apply changes immediately\nwithout restarting the service.",
            "is_async": true,
            "line": 261
          },
          {
            "name": "list_violations",
            "signature": "(violation_type: Optional[ViolationType] = None, agent_id: Optional[str] = None, tenant_id: Optional[str] = None, severity_min: Optional[float] = Query(None, ge=0.0, le=1.0), hours: int = Query(24, ge=1, le=720), limit: int = Query(100, ge=1, le=1000), db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "List policy violations with filtering.\n\nDefault: violations from last 24 hours.",
            "is_async": true,
            "line": 300
          },
          {
            "name": "get_violation",
            "signature": "(violation_id: str, db = Depends(get_session_dep)) -> PolicyViolation",
            "docstring": "Get a specific violation by ID.",
            "is_async": true,
            "line": 338
          },
          {
            "name": "acknowledge_violation",
            "signature": "(violation_id: str, notes: Optional[str] = None, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Acknowledge a violation (mark as reviewed).\n\nThis does NOT dismiss the violation - it records that\na human has reviewed it.",
            "is_async": true,
            "line": 361
          },
          {
            "name": "list_risk_ceilings",
            "signature": "(tenant_id: Optional[str] = None, include_inactive: bool = False, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "List all risk ceilings with current values.",
            "is_async": true,
            "line": 395
          },
          {
            "name": "get_risk_ceiling",
            "signature": "(ceiling_id: str, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get a specific risk ceiling with current utilization.",
            "is_async": true,
            "line": 432
          },
          {
            "name": "update_risk_ceiling",
            "signature": "(ceiling_id: str, update: RiskCeilingUpdate, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Update a risk ceiling configuration.",
            "is_async": true,
            "line": 469
          },
          {
            "name": "reset_risk_ceiling",
            "signature": "(ceiling_id: str, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Reset a risk ceiling's current value to 0.",
            "is_async": true,
            "line": 499
          },
          {
            "name": "list_safety_rules",
            "signature": "(tenant_id: Optional[str] = None, include_inactive: bool = False, db = Depends(get_session_dep)) -> List[Dict[str, Any]]",
            "docstring": "List all safety rules.",
            "is_async": true,
            "line": 528
          },
          {
            "name": "update_safety_rule",
            "signature": "(rule_id: str, update: SafetyRuleUpdate, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Update a safety rule configuration.",
            "is_async": true,
            "line": 563
          },
          {
            "name": "list_ethical_constraints",
            "signature": "(include_inactive: bool = False, db = Depends(get_session_dep)) -> List[Dict[str, Any]]",
            "docstring": "List all ethical constraints.",
            "is_async": true,
            "line": 597
          },
          {
            "name": "list_active_cooldowns",
            "signature": "(agent_id: Optional[str] = None, db = Depends(get_session_dep)) -> List[CooldownInfo]",
            "docstring": "List all active cooldowns.",
            "is_async": true,
            "line": 635
          },
          {
            "name": "clear_cooldowns",
            "signature": "(agent_id: str, rule_name: Optional[str] = None, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Clear cooldowns for an agent.\n\nUse with caution - bypasses safety cooldowns.",
            "is_async": true,
            "line": 656
          },
          {
            "name": "get_policy_metrics",
            "signature": "(hours: int = Query(24, ge=1, le=720), db = Depends(get_session_dep)) -> PolicyMetrics",
            "docstring": "Get policy engine metrics for the specified time window.",
            "is_async": true,
            "line": 687
          },
          {
            "name": "evaluate_batch",
            "signature": "(requests: List[EvaluateRequest], db = Depends(get_session_dep)) -> List[PolicyEvaluationResult]",
            "docstring": "Evaluate multiple actions in a single call.\n\nUseful for pre-flight checks on batch operations.\nLimited to 50 requests per batch.",
            "is_async": true,
            "line": 713
          },
          {
            "name": "list_policy_versions",
            "signature": "(limit: int = Query(20, ge=1, le=100), include_inactive: bool = False, db = Depends(get_session_dep)) -> List[Dict[str, Any]]",
            "docstring": "List all policy versions.\n\nReturns version history for audit and rollback purposes.",
            "is_async": true,
            "line": 777
          },
          {
            "name": "get_current_version",
            "signature": "(db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get the currently active policy version.\n\nThis is the version being used for all evaluations.",
            "is_async": true,
            "line": 803
          },
          {
            "name": "create_policy_version",
            "signature": "(request: CreateVersionRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Create a new policy version snapshot.\n\nThis captures the current state of all policies for audit\nand potential rollback.",
            "is_async": true,
            "line": 829
          },
          {
            "name": "rollback_to_version",
            "signature": "(request: RollbackRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Rollback to a previous policy version.\n\nThis restores all policies to the state captured in\nthe specified version.",
            "is_async": true,
            "line": 864
          },
          {
            "name": "get_version_provenance",
            "signature": "(version_id: str, db = Depends(get_session_dep)) -> List[Dict[str, Any]]",
            "docstring": "Get the provenance (change history) for a policy version.\n\nShows what changes were made and by whom.",
            "is_async": true,
            "line": 899
          },
          {
            "name": "get_dependency_graph",
            "signature": "(db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get the policy dependency graph.\n\nShows relationships and potential conflicts between policies.",
            "is_async": true,
            "line": 929
          },
          {
            "name": "list_conflicts",
            "signature": "(include_resolved: bool = False, db = Depends(get_session_dep)) -> List[Dict[str, Any]]",
            "docstring": "List policy conflicts.\n\nConflicts occur when policies have contradictory rules.",
            "is_async": true,
            "line": 980
          },
          {
            "name": "resolve_conflict",
            "signature": "(conflict_id: str, request: ResolveConflictRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Resolve a policy conflict.\n\nDocuments how the conflict should be handled during evaluation.",
            "is_async": true,
            "line": 1027
          },
          {
            "name": "list_temporal_policies",
            "signature": "(metric: Optional[str] = None, include_inactive: bool = False, db = Depends(get_session_dep)) -> List[Dict[str, Any]]",
            "docstring": "List temporal (sliding window) policies.\n\nThese policies track cumulative metrics over time windows.",
            "is_async": true,
            "line": 1082
          },
          {
            "name": "create_temporal_policy",
            "signature": "(request: TemporalPolicyCreate, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Create a new temporal policy.\n\nTemporal policies track cumulative metrics over sliding windows.",
            "is_async": true,
            "line": 1122
          },
          {
            "name": "get_temporal_utilization",
            "signature": "(policy_id: str, agent_id: Optional[str] = None, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get current utilization for a temporal policy.\n\nShows how much of the limit has been consumed in the current window.",
            "is_async": true,
            "line": 1152
          },
          {
            "name": "evaluate_with_context",
            "signature": "(request: ContextAwareEvaluateRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Context-aware policy evaluation (GAP 4).\n\nEvaluates with full agent/tenant context, action chain tracking,\nand temporal policy awareness. Returns updated context for\nuse in subsequent evaluations.",
            "is_async": true,
            "line": 1212
          },
          {
            "name": "validate_dependency_dag",
            "signature": "(db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Validate that policy dependencies form a valid DAG.\n\nChecks for cycles in the dependency graph. Cycles cause:\n- Infinite recursion in override resolution\n- Oscillation in dependency evaluation\n- Rule folding failures\n- MODIFY rule loops\n\nReturns:\n- is_dag: True if graph is acyclic\n- cycles: List of detected cycles (if any)\n- topological_order: Evaluation order (if DAG is valid)",
            "is_async": true,
            "line": 1295
          },
          {
            "name": "add_dependency_with_dag_check",
            "signature": "(request: AddDependencyRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Add a policy dependency with DAG validation.\n\nBlocks the addition if it would create a cycle in the\ndependency graph. This ensures the graph remains a\nvalid DAG (Directed Acyclic Graph).\n\nReturns:\n- success: True if added\n- error: Error message if blocked due to cycle\n- blocked: True if cycle detected\n- cycle_path: The path that would form a cycle",
            "is_async": true,
            "line": 1339
          },
          {
            "name": "get_evaluation_order",
            "signature": "(db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get the topological evaluation order for policies.\n\nReturns the order in which policies should be evaluated\nbased on their dependencies. Policies that depend on\nothers are evaluated after their dependencies.",
            "is_async": true,
            "line": 1392
          },
          {
            "name": "prune_temporal_metrics",
            "signature": "(request: PruneTemporalMetricsRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Prune and compact temporal metric events.\n\nThis prevents storage explosion by:\n1. Deleting events older than retention period\n2. Downsampling older events to hourly aggregates\n3. Capping maximum events per policy\n\nShould be run periodically (e.g., via cron job).",
            "is_async": true,
            "line": 1444
          },
          {
            "name": "get_temporal_storage_stats",
            "signature": "(db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get storage statistics for temporal metrics.\n\nUse this to monitor storage growth and determine\nwhen pruning is needed.",
            "is_async": true,
            "line": 1483
          },
          {
            "name": "activate_policy_version",
            "signature": "(request: ActivateVersionRequest, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Activate a policy version with pre-activation integrity checks.\n\nPerforms comprehensive checks before activation:\n1. Dependency closure - all dependencies exist\n2. Conflict scan - no unresolved critical conflicts\n3. DAG validation - no cycles\n4. Temporal integrity - valid window configurations\n5. Severity compatibility - escalation paths exist\n6. Simulation - dry-run against test cases\n\nUse dry_run=True to test without activating.\n\nReturns:\n- success: True if activated (or would be, for dry_run)\n- all_checks_passed: True if all integrity checks pass\n- checks: Detailed results of each check\n- activated_version: The version that was activated",
            "is_async": true,
            "line": 1521
          },
          {
            "name": "check_version_integrity",
            "signature": "(version_id: str, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Run integrity checks on a version without activating.\n\nShortcut for activate with dry_run=True.\nUseful for validating a version before scheduling activation.",
            "is_async": true,
            "line": 1578
          },
          {
            "name": "list_lessons",
            "signature": "(tenant_id: Optional[str] = None, lesson_type: Optional[str] = Query(None, description='Filter: failure, near_threshold, critical_success'), status: Optional[str] = Query(None, description='Filter: pending, converted_to_draft, deferred, dismissed'), severity: Optional[str] = Query(None, description='Filter: CRITICAL, HIGH, MEDIUM, LOW'), limit: int = Query(50, ge=1, le=500), offset: int = Query(0, ge=0), db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "List lessons learned.\n\nReturns lessons with optional filtering by type, status, and severity.\nThis endpoint is for the policy-layer (L3) - internal use.\n\nReference: PIN-411, POLICIES_DOMAIN_AUDIT.md Section 11",
            "is_async": true,
            "line": 1633
          },
          {
            "name": "get_lesson_stats",
            "signature": "(tenant_id: str, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get lesson statistics for a tenant.\n\nReturns counts by type and status.\n\nReference: PIN-411",
            "is_async": true,
            "line": 1687
          },
          {
            "name": "get_lesson",
            "signature": "(lesson_id: str, tenant_id: str, db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Get a specific lesson by ID.\n\nReturns detailed lesson information.\n\nReference: PIN-411",
            "is_async": true,
            "line": 1715
          },
          {
            "name": "convert_lesson_to_draft",
            "signature": "(lesson_id: str, request: LessonConvertRequest, tenant_id: str = Query(..., description='Tenant ID'), db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Convert a lesson to a draft policy proposal.\n\nCreates a new draft proposal and updates the lesson status.\nPB-S4 compliant: drafts require human approval.\n\nReference: PIN-411, PB-S4",
            "is_async": true,
            "line": 1749
          },
          {
            "name": "defer_lesson",
            "signature": "(lesson_id: str, request: LessonDeferRequest, tenant_id: str = Query(..., description='Tenant ID'), db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Defer a lesson until a future date.\n\nThe lesson will resurface for review after the defer date.\n\nReference: PIN-411",
            "is_async": true,
            "line": 1793
          },
          {
            "name": "dismiss_lesson",
            "signature": "(lesson_id: str, request: LessonDismissRequest, tenant_id: str = Query(..., description='Tenant ID'), db = Depends(get_session_dep)) -> Dict[str, Any]",
            "docstring": "Dismiss a lesson (mark as not actionable).\n\nDismissed lessons are preserved for audit but won't resurface.\n\nReference: PIN-411",
            "is_async": true,
            "line": 1836
          }
        ],
        "classes": [
          {
            "name": "EvaluateRequest",
            "docstring": "Request to evaluate an action against policies.",
            "methods": [],
            "line": 50
          },
          {
            "name": "SimulateRequest",
            "docstring": "Request to simulate policy evaluation (dry run).",
            "methods": [],
            "line": 66
          },
          {
            "name": "ViolationQuery",
            "docstring": "Query parameters for violations.",
            "methods": [],
            "line": 81
          },
          {
            "name": "RiskCeilingUpdate",
            "docstring": "Update for a risk ceiling.",
            "methods": [],
            "line": 92
          },
          {
            "name": "SafetyRuleUpdate",
            "docstring": "Update for a safety rule.",
            "methods": [],
            "line": 101
          },
          {
            "name": "CooldownInfo",
            "docstring": "Information about an active cooldown.",
            "methods": [],
            "line": 110
          },
          {
            "name": "PolicyMetrics",
            "docstring": "Metrics from the policy engine.",
            "methods": [],
            "line": 120
          },
          {
            "name": "CreateVersionRequest",
            "docstring": "Request to create a new policy version.",
            "methods": [],
            "line": 761
          },
          {
            "name": "RollbackRequest",
            "docstring": "Request to rollback to a previous version.",
            "methods": [],
            "line": 768
          },
          {
            "name": "ResolveConflictRequest",
            "docstring": "Request to resolve a policy conflict.",
            "methods": [],
            "line": 1019
          },
          {
            "name": "TemporalPolicyCreate",
            "docstring": "Request to create a temporal policy.",
            "methods": [],
            "line": 1066
          },
          {
            "name": "ContextAwareEvaluateRequest",
            "docstring": "Request for context-aware policy evaluation (GAP 4).",
            "methods": [],
            "line": 1182
          },
          {
            "name": "AddDependencyRequest",
            "docstring": "Request to add a policy dependency with DAG validation.",
            "methods": [],
            "line": 1327
          },
          {
            "name": "PruneTemporalMetricsRequest",
            "docstring": "Request to prune temporal metrics.",
            "methods": [],
            "line": 1435
          },
          {
            "name": "ActivateVersionRequest",
            "docstring": "Request to activate a policy version.",
            "methods": [],
            "line": 1512
          },
          {
            "name": "LessonConvertRequest",
            "docstring": "Request to convert a lesson to draft proposal.",
            "methods": [],
            "line": 1613
          },
          {
            "name": "LessonDeferRequest",
            "docstring": "Request to defer a lesson.",
            "methods": [],
            "line": 1619
          },
          {
            "name": "LessonDismissRequest",
            "docstring": "Request to dismiss a lesson.",
            "methods": [],
            "line": 1625
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "app.policy",
            "names": [
              "ActionType",
              "PolicyEvaluationRequest",
              "PolicyEvaluationResult",
              "PolicyState",
              "PolicyViolation",
              "ViolationType"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_limits_crud.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy_limits_crud.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 511,
        "module_docstring": "Policy Limits CRUD API (PIN-LIM-01)\n\nMutating endpoints for policy limits.\n\nExtends the read-only policies.py facade with write operations.\n\nEndpoints:\n    POST   /policies/limits              \u2192 Create limit\n    PUT    /policies/limits/{limit_id}   \u2192 Update limit\n    DELETE /policies/limits/{limit_id}   \u2192 Soft-delete limit",
        "functions": [
          {
            "name": "create_limit",
            "signature": "(request: Request, body: CreateLimitRequest, session = Depends(get_session_dep)) -> LimitDetail",
            "docstring": "Create a new policy limit.\n\n- Category and type are immutable after creation\n- BUDGET limits require reset_period\n- RATE limits require window_seconds",
            "is_async": true,
            "line": 162
          },
          {
            "name": "update_limit",
            "signature": "(request: Request, limit_id: str, body: UpdateLimitRequest, session = Depends(get_session_dep)) -> LimitDetail",
            "docstring": "Update an existing policy limit.\n\n- Category and type are immutable (cannot be changed)\n- Other fields can be updated",
            "is_async": true,
            "line": 228
          },
          {
            "name": "delete_limit",
            "signature": "(request: Request, limit_id: str, session = Depends(get_session_dep)) -> None",
            "docstring": "Soft-delete a policy limit.\n\nSets status to DISABLED. The limit is not actually removed.",
            "is_async": true,
            "line": 297
          },
          {
            "name": "get_threshold_params",
            "signature": "(request: Request, limit_id: str, session = Depends(get_session_dep)) -> ThresholdParamsResponse",
            "docstring": "Get threshold parameters for a limit.\n\nReturns both raw params and effective params (with defaults applied).\nOnly valid for limits with limit_category = THRESHOLD.",
            "is_async": true,
            "line": 350
          },
          {
            "name": "set_threshold_params",
            "signature": "(request: Request, limit_id: str, body: ThresholdParamsRequest, session = Depends(get_session_dep)) -> ThresholdParamsResponse",
            "docstring": "Set threshold parameters for a limit.\n\nThis is the authoritative input surface for:\n- Policies \u2192 Limits \u2192 Thresholds \u2192 Set Params panel\n\nThese params drive LLM run governance signals.\n\nValidation Rules (Hard Stop):\n- max_execution_time_ms: 1000-300000 (1s to 5min)\n- max_tokens: 256-200000\n- max_cost_usd: 0.01-100.00\n- failure_signal: boolean\n\nNo partial garbage. No unknown keys. No absurd values.",
            "is_async": true,
            "line": 411
          },
          {
            "name": "_to_detail",
            "signature": "(result: PolicyLimitResponse) -> LimitDetail",
            "docstring": "Convert service response to API response.",
            "is_async": false,
            "line": 493
          }
        ],
        "classes": [
          {
            "name": "CreateLimitRequest",
            "docstring": "API request to create a policy limit.",
            "methods": [],
            "line": 56
          },
          {
            "name": "UpdateLimitRequest",
            "docstring": "API request to update a policy limit.",
            "methods": [],
            "line": 71
          },
          {
            "name": "ThresholdParamsRequest",
            "docstring": "API request to set execution threshold parameters.\n\nUsed for: Policies \u2192 Limits \u2192 Thresholds \u2192 Set Params panel.\n\nThese params drive LLM run governance:\n- Activity \u2192 LLM Runs \u2192 Live \u2192 Signals\n- Activity \u2192 LLM Runs \u2192 Completed \u2192 Signals",
            "methods": [],
            "line": 83
          },
          {
            "name": "ThresholdParamsResponse",
            "docstring": "Response with effective threshold params.",
            "methods": [],
            "line": 120
          },
          {
            "name": "LimitDetail",
            "docstring": "Full limit response.",
            "methods": [],
            "line": 130
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.schemas.limits.policy_limits",
            "names": [
              "CreatePolicyLimitRequest",
              "LimitCategoryEnum",
              "LimitEnforcementEnum",
              "LimitScopeEnum",
              "PolicyLimitResponse",
              "ResetPeriodEnum",
              "UpdatePolicyLimitRequest"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_proposals.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy_proposals.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 523,
        "module_docstring": "PB-S4 Policy Proposals API\n\nExposes policy_proposals and policy_versions data with human-controlled approval.\n\nPB-S4 Contract:\n- Policies are proposed, never auto-enforced\n- Human approval is mandatory\n- Proposals have provenance to triggering feedback\n- Rejection preserved for audit trail\n\nO1: API endpoint exists \u2713\nO2: List visible with pagination \u2713\nO3: Detail accessible \u2713\nO4: Approve/Reject actions (human-controlled) \u2713 (PIN-373)\n\nPIN-513 L2 Purity:\n- All DB operations routed through L4 registry \u2192 L5 engine \u2192 L6 driver\n- Zero session.execute() calls in L2",
        "functions": [
          {
            "name": "list_proposals",
            "signature": "(request: Request, tenant_id: Optional[str] = Query(None, description='Filter by tenant'), status: Optional[str] = Query(None, description='Filter by status (draft/approved/rejected)'), proposal_type: Optional[str] = Query(None, description='Filter by proposal type'), limit: int = Query(50, ge=1, le=200, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'))",
            "docstring": "List policy proposals (PB-S4).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 124
          },
          {
            "name": "get_proposal_stats",
            "signature": "(request: Request, tenant_id: Optional[str] = Query(None, description='Filter by tenant'))",
            "docstring": "Get policy proposal statistics (PB-S4).\n\nREAD-ONLY: This endpoint only reads aggregated data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 190
          },
          {
            "name": "get_proposal",
            "signature": "(request: Request, proposal_id: str)",
            "docstring": "Get detailed policy proposal by ID (PB-S4).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 231
          },
          {
            "name": "list_proposal_versions",
            "signature": "(request: Request, proposal_id: str)",
            "docstring": "List all versions of a policy proposal (PB-S4).\n\nREAD-ONLY: This endpoint only reads data.\nShows the evolution of a policy through approvals.",
            "is_async": true,
            "line": 316
          },
          {
            "name": "approve_proposal",
            "signature": "(http_request: Request, proposal_id: str, request: ApproveRejectRequest, role: TenantRole = Depends(require_role(TenantRole.MEMBER, TenantRole.ADMIN, TenantRole.OWNER)))",
            "docstring": "Approve a policy proposal (PIN-373).\n\nHUMAN ACTION: This creates a policy_rules entry when approved.\nOnly draft proposals can be approved.\n\nPB-S4 Contract: Human approval is mandatory - system cannot auto-approve.",
            "is_async": true,
            "line": 387
          },
          {
            "name": "reject_proposal",
            "signature": "(http_request: Request, proposal_id: str, request: ApproveRejectRequest, role: TenantRole = Depends(require_role(TenantRole.MEMBER, TenantRole.ADMIN, TenantRole.OWNER)))",
            "docstring": "Reject a policy proposal (PIN-373).\n\nHUMAN ACTION: This marks the proposal as rejected.\nRejection is preserved for audit trail.\nOnly draft proposals can be rejected.\n\nPB-S4 Contract: Human decision is mandatory - system cannot auto-reject.",
            "is_async": true,
            "line": 456
          }
        ],
        "classes": [
          {
            "name": "ProposalSummaryResponse",
            "docstring": "Summary of a policy proposal.",
            "methods": [],
            "line": 60
          },
          {
            "name": "ProposalListResponse",
            "docstring": "Paginated list of policy proposals.",
            "methods": [],
            "line": 76
          },
          {
            "name": "ProposalDetailResponse",
            "docstring": "Detailed policy proposal record.",
            "methods": [],
            "line": 87
          },
          {
            "name": "VersionResponse",
            "docstring": "Policy version record.",
            "methods": [],
            "line": 106
          },
          {
            "name": "ApproveRejectRequest",
            "docstring": "Request body for approve/reject actions.",
            "methods": [],
            "line": 369
          },
          {
            "name": "ApprovalResponse",
            "docstring": "Response for approve/reject actions.",
            "methods": [],
            "line": 376
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.role_guard",
            "names": [
              "require_role"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.tenant_roles",
            "names": [
              "TenantRole"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_async_session_context",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_rules_crud.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy_rules_crud.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 264,
        "module_docstring": "Policy Rules CRUD API (PIN-LIM-02)\n\nMutating endpoints for policy rules.\n\nExtends the read-only policies.py facade with write operations.\n\nEndpoints:\n    POST /policies/rules              \u2192 Create rule\n    PUT  /policies/rules/{rule_id}    \u2192 Update rule\n\nRules are never deleted - they are retired with reason.",
        "functions": [
          {
            "name": "create_rule",
            "signature": "(request: Request, body: CreateRuleRequest, session = Depends(get_session_dep)) -> RuleDetail",
            "docstring": "Create a new policy rule.\n\nRules can be created from:\n- MANUAL: User-defined rules\n- SYSTEM: System-generated rules\n- LEARNED: ML/AI proposed rules (from policy proposals)",
            "is_async": true,
            "line": 114
          },
          {
            "name": "update_rule",
            "signature": "(request: Request, rule_id: str, body: UpdateRuleRequest, session = Depends(get_session_dep)) -> RuleDetail",
            "docstring": "Update an existing policy rule.\n\nTo retire a rule:\n- Set status to \"RETIRED\"\n- Provide retirement_reason (required)\n- Optionally set superseded_by\n\nRules are never deleted, only retired.",
            "is_async": true,
            "line": 175
          },
          {
            "name": "_to_detail",
            "signature": "(result: PolicyRuleResponse) -> RuleDetail",
            "docstring": "Convert service response to API response.",
            "is_async": false,
            "line": 242
          }
        ],
        "classes": [
          {
            "name": "CreateRuleRequest",
            "docstring": "API request to create a policy rule.",
            "methods": [],
            "line": 52
          },
          {
            "name": "UpdateRuleRequest",
            "docstring": "API request to update a policy rule.",
            "methods": [],
            "line": 66
          },
          {
            "name": "RuleDetail",
            "docstring": "Full rule response.",
            "methods": [],
            "line": 78
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.schemas.limits.policy_rules",
            "names": [
              "CreatePolicyRuleRequest",
              "PolicyRuleResponse",
              "UpdatePolicyRuleRequest"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "rate_limits.py",
        "file_path": "backend/app/hoc/api/cus/policies/rate_limits.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 278,
        "module_docstring": "Rate Limits API (L2) - GAP-122\n\nProvides rate limit and quota operations:\n- GET /rate-limits (list rate limits)\n- GET /rate-limits/usage (current usage)\n- GET /rate-limits/{id} (get rate limit)\n- PUT /rate-limits/{id} (update rate limit)\n- POST /rate-limits/check (check rate limit)\n- POST /rate-limits/{id}/reset (reset usage)\n\nThis is the ONLY facade for rate limit/quota operations.\nDistinct from PIN-LIM policy limits (app/api/limits/).",
        "functions": [
          {
            "name": "list_limits",
            "signature": "(limit_type: Optional[str] = Query(None, description='Filter by type'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('limits.read')))",
            "docstring": "List limits (GAP-122).\n\nReturns all configured limits for the tenant.",
            "is_async": true,
            "line": 77
          },
          {
            "name": "get_usage",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('limits.read')))",
            "docstring": "Get current usage summary.\n\nReturns usage across all limits with aggregated totals.",
            "is_async": true,
            "line": 116
          },
          {
            "name": "check_limit",
            "signature": "(request: CheckLimitRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('limits.check')))",
            "docstring": "Check if a limit allows an operation.\n\nIf allowed, increments the usage counter.",
            "is_async": true,
            "line": 142
          },
          {
            "name": "get_limit",
            "signature": "(limit_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('limits.read')))",
            "docstring": "Get a specific limit.",
            "is_async": true,
            "line": 173
          },
          {
            "name": "update_limit",
            "signature": "(limit_id: str, request: UpdateLimitRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('limits.write')))",
            "docstring": "Update a limit configuration.",
            "is_async": true,
            "line": 201
          },
          {
            "name": "reset_limit",
            "signature": "(limit_id: str, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('limits.admin')))",
            "docstring": "Reset a limit's usage counter.\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 236
          }
        ],
        "classes": [
          {
            "name": "UpdateLimitRequest",
            "docstring": "Request to update a limit.",
            "methods": [],
            "line": 58
          },
          {
            "name": "CheckLimitRequest",
            "docstring": "Request to check a limit.",
            "methods": [],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "rbac_api.py",
        "file_path": "backend/app/hoc/api/cus/policies/rbac_api.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 344,
        "module_docstring": "RBAC Management API\n\nProvides endpoints for managing RBAC policies:\n- GET /rbac/info - Get current policy info\n- POST /rbac/reload - Hot-reload policies from file\n- GET /rbac/matrix - Get current permission matrix\n- GET /rbac/audit - Query audit logs\n\nRequires RBAC permission: rbac:read or rbac:reload\n\nNOTE (PIN-310): Authorization now routes through M28 via authorization_choke.py.\nPolicy introspection (info, matrix, reload) still uses rbac_engine for admin functions.",
        "functions": [
          {
            "name": "_get_rbac_engine",
            "signature": "()",
            "docstring": "Get rbac_engine via L4 bridge to maintain L2 purity.",
            "is_async": false,
            "line": 49
          },
          {
            "name": "get_policy_info",
            "signature": "(request: Request)",
            "docstring": "Get current RBAC policy information.\n\nReturns version, hash, loaded timestamp, roles, and resources.\n\nRequires RBAC permission: rbac:read",
            "is_async": true,
            "line": 118
          },
          {
            "name": "reload_policies",
            "signature": "(request: Request)",
            "docstring": "Hot-reload RBAC policies from file.\n\nReloads the policy file and updates the in-memory policy matrix.\nReturns the previous and new policy hashes for verification.\n\nRequires RBAC permission: rbac:reload",
            "is_async": true,
            "line": 148
          },
          {
            "name": "get_permission_matrix",
            "signature": "(request: Request) -> Dict[str, Any]",
            "docstring": "Get current permission matrix.\n\nReturns the full role->resource->actions mapping.\n\nRequires RBAC permission: rbac:read",
            "is_async": true,
            "line": 198
          },
          {
            "name": "query_audit_logs",
            "signature": "(request: Request, resource: Optional[str] = Query(default=None, description='Filter by resource'), action: Optional[str] = Query(default=None, description='Filter by action'), allowed: Optional[bool] = Query(default=None, description='Filter by decision'), subject: Optional[str] = Query(default=None, description='Filter by subject'), tenant_id: Optional[str] = Query(default=None, description='Filter by tenant'), since: Optional[datetime] = Query(default=None, description='Filter since timestamp'), limit: int = Query(default=100, ge=1, le=1000), offset: int = Query(default=0, ge=0), db = Depends(get_sync_session_dep))",
            "docstring": "Query RBAC audit logs.\n\nSupports filtering by resource, action, decision, subject, tenant, and time.\n\nRequires RBAC permission: rbac:read",
            "is_async": true,
            "line": 221
          },
          {
            "name": "cleanup_audit_logs",
            "signature": "(request: Request, retention_days: int = Query(default=90, ge=1, le=365), db = Depends(get_sync_session_dep))",
            "docstring": "Clean up old audit logs.\n\nDeletes audit entries older than retention_days.\n\nRequires RBAC permission: rbac:reload (admin action)",
            "is_async": true,
            "line": 288
          }
        ],
        "classes": [
          {
            "name": "PolicyInfoResponse",
            "docstring": "Current policy information.",
            "methods": [],
            "line": 64
          },
          {
            "name": "ReloadResponse",
            "docstring": "Policy reload response.",
            "methods": [],
            "line": 76
          },
          {
            "name": "AuditEntry",
            "docstring": "Single audit log entry.",
            "methods": [],
            "line": 86
          },
          {
            "name": "AuditResponse",
            "docstring": "Audit log query response.",
            "methods": [],
            "line": 103
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.auth.authorization_choke",
            "names": [
              "check_permission_request"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_operation_registry",
              "get_sync_session_dep",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges",
            "names": [
              "get_account_bridge"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "replay.py",
        "file_path": "backend/app/hoc/api/cus/policies/replay.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 702,
        "module_docstring": "Replay UX API (H1)\n\nProvides READ-ONLY endpoints for replay visualization:\n- Time-windowed slice of incident data\n- Grouped view: inputs, decisions, actions, side-effects\n- Immutable, paginated responses\n\nINVARIANTS:\n1. All endpoints are READ-ONLY (no mutations)\n2. Uses existing RBAC v2 enforcement (require_replay_read)\n3. Tenant isolation enforced\n4. No execution or write capabilities\n5. All DB access via L4 registry dispatch (L2 first-principles purity)\n\nReference: Phase H1 - Replay UX Enablement",
        "functions": [
          {
            "name": "_parse_json_field",
            "signature": "(value) -> Any",
            "docstring": "Safely parse a JSON string field, returning empty dict/list on failure.",
            "is_async": false,
            "line": 134
          },
          {
            "name": "_get_policy_decisions",
            "signature": "(row: dict) -> list",
            "docstring": "Extract policy decisions from a proxy call row dict.",
            "is_async": false,
            "line": 146
          },
          {
            "name": "_get_related_call_ids",
            "signature": "(row: dict) -> list",
            "docstring": "Extract related call IDs from incident metadata.",
            "is_async": false,
            "line": 153
          },
          {
            "name": "_get_event_data",
            "signature": "(row: dict) -> dict",
            "docstring": "Extract data dict from incident event row.",
            "is_async": false,
            "line": 171
          },
          {
            "name": "_categorize_proxy_call_row",
            "signature": "(row: dict) -> ReplayCategory",
            "docstring": "Categorize a proxy call row into replay category.\n\nCategories:\n- INPUT: Request data, model selection\n- DECISION: Policy decisions, guardrail evaluations\n- ACTION: Actual API call execution\n- SIDE_EFFECT: Cost tracking, logging, notifications",
            "is_async": false,
            "line": 178
          },
          {
            "name": "_proxy_call_row_to_replay_item",
            "signature": "(row: dict) -> ReplayItem",
            "docstring": "Convert proxy call row dict to ReplayItem for visualization.",
            "is_async": false,
            "line": 198
          },
          {
            "name": "_incident_event_row_to_replay_item",
            "signature": "(row: dict) -> ReplayItem",
            "docstring": "Convert IncidentEvent row dict to ReplayItem for visualization.",
            "is_async": false,
            "line": 256
          },
          {
            "name": "_dispatch_replay",
            "signature": "(session, method: str, **kwargs) -> Any",
            "docstring": "Dispatch a replay operation through the L4 registry.",
            "is_async": true,
            "line": 288
          },
          {
            "name": "get_replay_slice",
            "signature": "(request: Request, incident_id: str, window: int = Query(30, ge=5, le=300, description='Time window in seconds (+-window from incident)'), center_time: Optional[str] = Query(None, description='Center time ISO8601 (default: incident start)'), page: int = Query(1, ge=1, description='Page number'), page_size: int = Query(50, ge=10, le=200, description='Items per page'), auth: AuthorityResult = Depends(require_replay_read), session = Depends(get_sync_session_dep))",
            "docstring": "Get time-windowed replay slice of an incident.\n\nReturns grouped, immutable data for replay visualization:\n- inputs: What the agent saw (requests, context)\n- decisions: Policy evaluations, guardrail checks\n- actions: Actual executions, API calls\n- side_effects: Cost tracking, notifications, logging\n\nThis endpoint is READ-ONLY and does not modify any data.\n\nRBAC: Requires read:replay permission\nTenant Isolation: Enforced",
            "is_async": true,
            "line": 308
          },
          {
            "name": "get_incident_summary",
            "signature": "(request: Request, incident_id: str, auth: AuthorityResult = Depends(require_replay_read), session = Depends(get_sync_session_dep))",
            "docstring": "Get incident summary for replay context.\n\nProvides high-level information about an incident before\ndiving into detailed replay visualization.\n\nThis endpoint is READ-ONLY.\n\nRBAC: Requires read:replay permission\nTenant Isolation: Enforced",
            "is_async": true,
            "line": 430
          },
          {
            "name": "get_replay_timeline",
            "signature": "(request: Request, incident_id: str, limit: int = Query(100, ge=10, le=500, description='Maximum items to return'), auth: AuthorityResult = Depends(require_replay_read), session = Depends(get_sync_session_dep))",
            "docstring": "Get full timeline for an incident (unpaginated for scrubbing UI).\n\nReturns all replay items in chronological order for\ntimeline scrubbing and playback visualization.\n\nThis endpoint is READ-ONLY.\n\nRBAC: Requires read:replay permission\nTenant Isolation: Enforced",
            "is_async": true,
            "line": 484
          },
          {
            "name": "explain_replay_item",
            "signature": "(request: Request, incident_id: str, item_id: str, auth: AuthorityResult = Depends(require_replay_read), session = Depends(get_sync_session_dep))",
            "docstring": "Get detailed explanation for a single replay item.\n\nProvides expanded context for:\n- What the agent saw (inputs)\n- Why it decided (decision rationale)\n- What it executed (action details)\n\nThis endpoint is READ-ONLY.\n\nRBAC: Requires read:replay permission\nTenant Isolation: Enforced via incident",
            "is_async": true,
            "line": 572
          }
        ],
        "classes": [
          {
            "name": "ReplayCategory",
            "docstring": "Categories for replay data grouping.",
            "methods": [],
            "line": 58
          },
          {
            "name": "ReplayItem",
            "docstring": "Single item in replay timeline.",
            "methods": [],
            "line": 67
          },
          {
            "name": "ReplaySliceResponse",
            "docstring": "Paginated, grouped replay slice response.",
            "methods": [],
            "line": 80
          },
          {
            "name": "IncidentSummaryResponse",
            "docstring": "Summary of incident for replay context.",
            "methods": [],
            "line": 113
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "require_replay_read",
              "verify_tenant_access"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_operation_registry",
              "get_sync_session_dep",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "retrieval.py",
        "file_path": "backend/app/hoc/api/cus/policies/retrieval.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 243,
        "module_docstring": "Retrieval API (L2)\n\nProvides mediated data retrieval operations:\n- POST /retrieval/access (mediated data access)\n- GET /retrieval/planes (list available planes)\n- POST /retrieval/planes (register plane)\n- GET /retrieval/planes/{id} (get plane)\n- GET /retrieval/evidence (list evidence records)\n- GET /retrieval/evidence/{id} (get evidence)\n\nThis is the ONLY facade for mediated data retrieval.\nAll data access from LLM-controlled code MUST flow through this router.\n\nINVARIANT: Deny-by-default. All access blocked unless explicitly allowed by policy.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> RetrievalFacade",
            "docstring": "Get the retrieval facade.",
            "is_async": false,
            "line": 80
          },
          {
            "name": "access_data",
            "signature": "(request: AccessDataRequest, ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.access')))",
            "docstring": "Mediated data access (GAP-094).\n\n**Tier: REACT ($9)** - Mediated data access.\n\nAll data access from LLM-controlled code MUST go through this endpoint.\nImplements deny-by-default policy enforcement.\n\nINVARIANT: Access is BLOCKED unless explicitly allowed by policy.",
            "is_async": true,
            "line": 91
          },
          {
            "name": "list_planes",
            "signature": "(connector_type: Optional[str] = Query(None, description='Filter by connector type'), status: Optional[str] = Query(None, description='Filter by status'), ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.read')))",
            "docstring": "List available knowledge planes.\n\nReturns all registered knowledge planes for the tenant.",
            "is_async": true,
            "line": 125
          },
          {
            "name": "register_plane",
            "signature": "(request: RegisterPlaneRequest, ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.write')))",
            "docstring": "Register a knowledge plane.\n\nRegisters a new knowledge plane that maps to a connector\nfor mediated data access.",
            "is_async": true,
            "line": 150
          },
          {
            "name": "get_plane",
            "signature": "(plane_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.read')))",
            "docstring": "Get a specific knowledge plane.",
            "is_async": true,
            "line": 174
          },
          {
            "name": "list_evidence",
            "signature": "(run_id: Optional[str] = Query(None, description='Filter by run'), plane_id: Optional[str] = Query(None, description='Filter by plane'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.evidence')))",
            "docstring": "List retrieval evidence records.\n\nReturns evidence of data accesses for audit and compliance.",
            "is_async": true,
            "line": 195
          },
          {
            "name": "get_evidence",
            "signature": "(evidence_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.evidence')))",
            "docstring": "Get a specific evidence record.",
            "is_async": true,
            "line": 226
          }
        ],
        "classes": [
          {
            "name": "AccessDataRequest",
            "docstring": "Request for mediated data access.",
            "methods": [],
            "line": 59
          },
          {
            "name": "RegisterPlaneRequest",
            "docstring": "Request to register a knowledge plane.",
            "methods": [],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.retrieval_facade",
            "names": [
              "RetrievalFacade",
              "get_retrieval_facade"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "runtime.py",
        "file_path": "backend/app/hoc/api/cus/policies/runtime.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 716,
        "module_docstring": "Machine-Native Runtime API Endpoints (M5.5)\n\nProvides REST API exposure for machine-native runtime primitives:\n1. POST /runtime/simulate - Pre-execution plan simulation\n2. POST /runtime/query - Runtime state queries\n3. GET /runtime/skills - List available skills\n4. GET /runtime/skills/{skill_id} - Describe a skill\n5. GET /runtime/capabilities - Get capabilities for an agent\n\nDesign Principles (from PIN-005):\n- Queryable state: Agent asks questions, gets structured answers\n- Capability awareness: Agent knows what it can do and what it costs\n- Pre-execution simulation: Evaluate plans before committing\n- Self-describing skills: Skills explain their behavior and constraints\n- Resource contracts: Boundaries declared upfront\n\nTier Gating (M32 - PIN-158):\n- OBSERVE ($0): Query, list skills, capabilities (observability)\n- PREVENT ($199): Simulate, replay (pre-execution decisions)",
        "functions": [
          {
            "name": "_get_cost_simulator",
            "signature": "()",
            "docstring": "Get CostSimulator instance.",
            "is_async": false,
            "line": 163
          },
          {
            "name": "_get_runtime_adapter",
            "signature": "()",
            "docstring": "Get RuntimeAdapter instance (L3).\n\nThis is the compliant way to access runtime functionality.\nL2 calls L3 (adapter), not L5 (worker).\n\nReference: PIN-258 Phase F-3 Runtime Cluster\n\nReturns:\n    RuntimeAdapter instance",
            "is_async": false,
            "line": 174
          },
          {
            "name": "_get_skill_registry",
            "signature": "()",
            "docstring": "Get skill registry.",
            "is_async": false,
            "line": 191
          },
          {
            "name": "simulate_plan",
            "signature": "(request: SimulateRequest, _http_request: Request = None, _rate_limited: bool = Depends(rate_limit_dependency), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('sdk.simulate.full')))",
            "docstring": "Simulate a plan before execution.\n\n**Tier: PREVENT ($199)** - Pre-execution simulation is the core \"decision tier\"\nfeature that lets you stop problems before they happen.\n\nReturns cost estimates, latency estimates, risk assessment, and feasibility check.\nThis allows agents to evaluate plans before committing resources.\n\nExample:\n```json\n{\n  \"plan\": [\n    {\"skill\": \"http_call\", \"params\": {\"url\": \"https://api.example.com/data\"}},\n    {\"skill\": \"llm_invoke\", \"params\": {\"prompt\": \"Summarize this data\"}}\n  ],\n  \"budget_cents\": 100\n}\n```",
            "is_async": true,
            "line": 212
          },
          {
            "name": "query_runtime",
            "signature": "(request: QueryRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('traces.read')))",
            "docstring": "Query runtime state.\n\n**Tier: OBSERVE ($0)** - Basic observability for all tiers.\n\nSupported query types:\n- remaining_budget_cents: Current budget status\n- what_did_i_try_already: Previous execution attempts\n- allowed_skills: List of available skills\n- last_step_outcome: Most recent execution result\n- skills_available_for_goal: Skills matching a goal\n\nExample:\n```json\n{\n  \"query_type\": \"remaining_budget_cents\",\n  \"params\": {}\n}\n```",
            "is_async": true,
            "line": 358
          },
          {
            "name": "list_available_skills",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "List all available skills.\n\n**Tier: OBSERVE ($0)** - Basic capability discovery.\n\nReturns skill IDs and basic descriptors for each skill.",
            "is_async": true,
            "line": 404
          },
          {
            "name": "describe_skill",
            "signature": "(skill_id: str, ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get detailed descriptor for a skill.\n\n**Tier: OBSERVE ($0)** - Basic capability discovery.\n\nReturns full metadata including:\n- Input/output schemas\n- Cost model\n- Failure modes with recovery hints\n- Constraints\n- Composition hints (what skills often precede/follow)",
            "is_async": true,
            "line": 441
          },
          {
            "name": "get_capabilities",
            "signature": "(agent_id: Optional[str] = Query(default=None, description='Agent ID'), tenant_id: Optional[str] = Query(default=None, description='Tenant ID'), ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get available capabilities for an agent/tenant.\n\n**Tier: OBSERVE ($0)** - Basic capability awareness.\n\nReturns:\n- Available skills with their current status\n- Budget information\n- Rate limit information\n- Permissions\n\nThis allows agents to know exactly what they can do before attempting.",
            "is_async": true,
            "line": 486
          },
          {
            "name": "get_resource_contract",
            "signature": "(resource_id: str)",
            "docstring": "Get resource contract for a specific resource.\n\nReturns budget, rate limits, and concurrency constraints.",
            "is_async": true,
            "line": 518
          },
          {
            "name": "replay_run",
            "signature": "(run_id: str, request: ReplayRequest = ReplayRequest(), _rate_limited: bool = Depends(rate_limit_dependency), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.replay')), auth: AuthorityResult = Depends(require_replay_execute))",
            "docstring": "Replay a stored plan and optionally verify determinism parity.\n\n**Tier: PREVENT ($199)** - Replay for evidence and compliance verification.\n**Authority: execute:replay** - RBAC v2 enforced.\n\nM6 Deliverable: Re-execute stored plans without re-planning.\n\nParity verification checks:\n- Same skill calls in same order\n- Same parameters to each skill\n- Same retry decisions\n- Same error classifications\n\nDoes NOT verify:\n- External API responses (vary between runs)\n- LLM output content (non-deterministic)\n- Timestamps (always different)\n- Execution duration (timing varies)\n\nArgs:\n    run_id: The original run ID to replay\n    request: Replay options\n\nReturns:\n    ReplayResponse with parity check result",
            "is_async": true,
            "line": 575
          },
          {
            "name": "list_traces",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), limit: int = Query(100, ge=1, le=1000, description='Max traces to return'), offset: int = Query(0, ge=0, description='Pagination offset'))",
            "docstring": "List stored traces for a tenant.\n\nM6 Deliverable: Access to execution traces for debugging and replay.\n\nArgs:\n    tenant_id: Filter by tenant (optional)\n    limit: Maximum traces to return\n    offset: Pagination offset\n\nReturns:\n    List of trace summaries",
            "is_async": true,
            "line": 642
          },
          {
            "name": "get_trace",
            "signature": "(run_id: str)",
            "docstring": "Get a specific trace by run ID.\n\nM6 Deliverable: Access to full execution trace for debugging.\n\nArgs:\n    run_id: The run ID to retrieve\n\nReturns:\n    Full trace record with all steps",
            "is_async": true,
            "line": 686
          }
        ],
        "classes": [
          {
            "name": "PlanStep",
            "docstring": "A single step in a plan to simulate.",
            "methods": [],
            "line": 67
          },
          {
            "name": "SimulateRequest",
            "docstring": "Request to simulate a plan before execution.",
            "methods": [],
            "line": 75
          },
          {
            "name": "SimulateResponse",
            "docstring": "Response from plan simulation.",
            "methods": [],
            "line": 88
          },
          {
            "name": "QueryRequest",
            "docstring": "Request to query runtime state.",
            "methods": [],
            "line": 108
          },
          {
            "name": "QueryResponse",
            "docstring": "Response from runtime query.",
            "methods": [],
            "line": 117
          },
          {
            "name": "SkillDescriptorResponse",
            "docstring": "Response describing a skill.",
            "methods": [],
            "line": 125
          },
          {
            "name": "SkillListResponse",
            "docstring": "Response listing available skills.",
            "methods": [],
            "line": 140
          },
          {
            "name": "CapabilitiesResponse",
            "docstring": "Response with agent capabilities.",
            "methods": [],
            "line": 148
          },
          {
            "name": "ReplayRequest",
            "docstring": "Request to replay a stored run.",
            "methods": [],
            "line": 555
          },
          {
            "name": "ReplayResponse",
            "docstring": "Response from replay operation.",
            "methods": [],
            "line": 563
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "require_replay_execute"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.middleware.rate_limit",
            "names": [
              "rate_limit_dependency"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.commands.runtime_command",
            "names": [
              "DEFAULT_SKILL_METADATA"
            ],
            "is_relative": false,
            "line": 204
          }
        ],
        "constants": [
          {
            "name": "AOS_WORKSPACE_ROOT",
            "line": 57
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "scheduler.py",
        "file_path": "backend/app/hoc/api/cus/policies/scheduler.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 341,
        "module_docstring": "Scheduler API (L2)\n\nProvides scheduled job operations:\n- POST /scheduler/jobs (create job)\n- GET /scheduler/jobs (list jobs)\n- GET /scheduler/jobs/{id} (get job)\n- PUT /scheduler/jobs/{id} (update job)\n- DELETE /scheduler/jobs/{id} (delete job)\n- POST /scheduler/jobs/{id}/trigger (trigger job)\n- POST /scheduler/jobs/{id}/pause (pause job)\n- POST /scheduler/jobs/{id}/resume (resume job)\n- GET /scheduler/jobs/{id}/runs (job runs)\n- GET /scheduler/runs/{id} (get run)\n\nThis is the ONLY facade for scheduler operations.\nAll scheduler APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> SchedulerFacade",
            "docstring": "Get the scheduler facade.",
            "is_async": false,
            "line": 85
          },
          {
            "name": "create_job",
            "signature": "(request: CreateJobRequest, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Create a scheduled job (GAP-112).\n\n**Tier: REACT ($9)** - Scheduled jobs.\n\nSchedule format: Standard cron expression\n- Minute (0-59)\n- Hour (0-23)\n- Day of month (1-31)\n- Month (1-12)\n- Day of week (0-7, 0 and 7 are Sunday)\n\nExample: \"0 9 * * *\" = Every day at 9:00 AM",
            "is_async": true,
            "line": 96
          },
          {
            "name": "list_jobs",
            "signature": "(status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.read')))",
            "docstring": "List scheduled jobs.",
            "is_async": true,
            "line": 130
          },
          {
            "name": "get_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.read')))",
            "docstring": "Get a specific scheduled job.",
            "is_async": true,
            "line": 157
          },
          {
            "name": "update_job",
            "signature": "(job_id: str, request: UpdateJobRequest, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Update a scheduled job.",
            "is_async": true,
            "line": 178
          },
          {
            "name": "delete_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Delete a scheduled job.",
            "is_async": true,
            "line": 205
          },
          {
            "name": "trigger_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.trigger')))",
            "docstring": "Trigger a job to run immediately.\n\nBypasses the schedule and runs the job now.",
            "is_async": true,
            "line": 226
          },
          {
            "name": "pause_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Pause a scheduled job.\n\nStops the job from running on schedule until resumed.",
            "is_async": true,
            "line": 249
          },
          {
            "name": "resume_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Resume a paused job.\n\nRestarts the job's schedule.",
            "is_async": true,
            "line": 272
          },
          {
            "name": "list_job_runs",
            "signature": "(job_id: str, status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.read')))",
            "docstring": "List job run history.",
            "is_async": true,
            "line": 295
          },
          {
            "name": "get_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.read')))",
            "docstring": "Get a specific job run.",
            "is_async": true,
            "line": 324
          }
        ],
        "classes": [
          {
            "name": "CreateJobRequest",
            "docstring": "Request to create scheduled job.",
            "methods": [],
            "line": 61
          },
          {
            "name": "UpdateJobRequest",
            "docstring": "Request to update scheduled job.",
            "methods": [],
            "line": 71
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.scheduler_facade",
            "names": [
              "SchedulerFacade",
              "get_scheduler_facade"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "simulate.py",
        "file_path": "backend/app/hoc/api/cus/policies/simulate.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 163,
        "module_docstring": "Limit Simulation API (PIN-LIM-04)\n\nPre-execution limit check endpoint.\n\nAllows callers to test whether an execution would be permitted\nbefore actually running it.\n\nEndpoint:\n    POST /limits/simulate\n\nReturns:\n    - decision: ALLOW | BLOCK | WARN\n    - blocking_limit_id (if blocked)\n    - headroom (remaining capacity)\n    - warnings (soft limit warnings)",
        "functions": [
          {
            "name": "simulate_execution",
            "signature": "(request: Request, body: SimulateRequest, session = Depends(get_session_dep)) -> SimulateResponse",
            "docstring": "Simulate an execution against all limits.\n\nThis endpoint allows callers to check whether an execution would be\npermitted BEFORE actually running it. Useful for:\n- SDK pre-checks\n- UI feedback on resource availability\n- Worker admission control",
            "is_async": true,
            "line": 91
          }
        ],
        "classes": [
          {
            "name": "SimulateRequest",
            "docstring": "Wrapper for simulation request.",
            "methods": [],
            "line": 53
          },
          {
            "name": "SimulateResponse",
            "docstring": "Simulation response with decision and details.",
            "methods": [],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.simulation",
            "names": [
              "LimitSimulationRequest",
              "LimitSimulationResponse",
              "SimulationDecision"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "status_history.py",
        "file_path": "backend/app/hoc/api/cus/policies/status_history.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 457,
        "module_docstring": "API endpoints for immutable status history audit trail.\n\nEndpoints:\n- GET /status_history - Query status history with filters\n- GET /status_history/{entity_type}/{entity_id} - Get history for specific entity\n- GET /status_history/export - Export to CSV/JSONL with signed URL\n- GET /status_history/stats - Get statistics for audit reporting\n\nSecurity:\n- Tenant isolation via tenant_id filter\n- Audit logging for all access\n- Signed URLs for exports (time-limited)",
        "functions": [
          {
            "name": "generate_signed_url",
            "signature": "(export_id: str, format: str) -> tuple[str, datetime]",
            "docstring": "Generate a signed URL for export download.\n\nArgs:\n    export_id: Export file identifier\n    format: Export format (csv/jsonl)\n\nReturns:\n    Tuple of (signed_url, expires_at)",
            "is_async": false,
            "line": 134
          },
          {
            "name": "verify_signed_url",
            "signature": "(export_id: str, format: str, expires_ts: int, signature: str) -> bool",
            "docstring": "Verify a signed URL signature.\n\nArgs:\n    export_id: Export file identifier\n    format: Export format\n    expires_ts: Expiration timestamp\n    signature: Provided signature\n\nReturns:\n    True if valid, False otherwise",
            "is_async": false,
            "line": 158
          },
          {
            "name": "query_status_history",
            "signature": "(entity_type: Optional[str] = Query(None, description='Filter by entity type'), entity_id: Optional[str] = Query(None, description='Filter by entity ID'), tenant_id: Optional[str] = Query(None, description='Filter by tenant'), actor_type: Optional[str] = Query(None, description='Filter by actor type'), new_status: Optional[str] = Query(None, description='Filter by new status'), start_time: Optional[datetime] = Query(None, description='Filter from this time'), end_time: Optional[datetime] = Query(None, description='Filter until this time'), limit: int = Query(100, ge=1, le=1000, description='Max results'), offset: int = Query(0, ge=0, description='Offset for pagination'), session = Depends(get_session_dep))",
            "docstring": "Query status history with filters.\n\nSupports filtering by:\n- entity_type: run, agent, approval, workflow, costsim\n- entity_id: Specific entity ID\n- tenant_id: Tenant scope (required in production)\n- actor_type: system, user, agent, scheduler\n- new_status: Target status\n- start_time/end_time: Time range",
            "is_async": true,
            "line": 184
          },
          {
            "name": "get_entity_history",
            "signature": "(entity_type: str, entity_id: str, limit: int = Query(100, ge=1, le=1000), session = Depends(get_session_dep))",
            "docstring": "Get complete status history for a specific entity.\n\nReturns all status transitions in chronological order.",
            "is_async": true,
            "line": 259
          },
          {
            "name": "create_export",
            "signature": "(request: ExportRequest, session = Depends(get_session_dep))",
            "docstring": "Create an export of status history records.\n\nReturns a signed URL for download that expires in 1 hour.\n\nSupported formats:\n- csv: Comma-separated values\n- jsonl: JSON Lines (one JSON object per line)",
            "is_async": true,
            "line": 316
          },
          {
            "name": "download_export",
            "signature": "(export_id: str, format: str = Query(..., description='Export format'), expires: int = Query(..., description='Expiration timestamp'), sig: str = Query(..., description='Signature'))",
            "docstring": "Download an exported file using signed URL.\n\nThis endpoint verifies the signature and expiration before\nreturning the file contents.",
            "is_async": true,
            "line": 386
          },
          {
            "name": "get_stats",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), session = Depends(get_session_dep))",
            "docstring": "Get statistics about status history records.\n\nUseful for audit reporting and monitoring.",
            "is_async": true,
            "line": 423
          }
        ],
        "classes": [
          {
            "name": "StatusHistoryQuery",
            "docstring": "Query parameters for status history.",
            "methods": [],
            "line": 59
          },
          {
            "name": "StatusHistoryResponse",
            "docstring": "Single status history record.",
            "methods": [],
            "line": 72
          },
          {
            "name": "StatusHistoryListResponse",
            "docstring": "Paginated list of status history records.",
            "methods": [],
            "line": 90
          },
          {
            "name": "ExportRequest",
            "docstring": "Request for status history export.",
            "methods": [],
            "line": 100
          },
          {
            "name": "ExportResponse",
            "docstring": "Response with signed URL for export download.",
            "methods": [],
            "line": 111
          },
          {
            "name": "StatsResponse",
            "docstring": "Statistics for audit reporting.",
            "methods": [],
            "line": 121
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "csv",
            "names": [
              "csv"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "cast"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Response"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [
          {
            "name": "EXPORT_DIR",
            "line": 53
          },
          {
            "name": "SIGNED_URL_SECRET",
            "line": 54
          },
          {
            "name": "SIGNED_URL_TTL_SECONDS",
            "line": 55
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "workers.py",
        "file_path": "backend/app/hoc/api/cus/policies/workers.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1595,
        "module_docstring": "API endpoints for Business Builder Worker.\n\nEndpoints:\n- POST /workers/business-builder/run - Execute the worker\n- POST /workers/business-builder/replay - Replay a previous execution\n- GET /workers/business-builder/runs/{run_id} - Get run details\n- GET /workers/business-builder/runs - List recent runs\n- POST /workers/business-builder/validate-brand - Validate brand schema\n- GET /workers/business-builder/stream/{run_id} - SSE stream for real-time updates\n\nAll endpoints require authentication via API key or Bearer token.",
        "functions": [
          {
            "name": "_get_workers_adapter",
            "signature": "()",
            "docstring": "Get the L3 workers adapter.\n\nThis is the ONLY way L2 should access worker functionality.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": false,
            "line": 76
          },
          {
            "name": "_calculate_cost_cents",
            "signature": "(model: str, input_tokens: int, output_tokens: int) -> int",
            "docstring": "Calculate LLM cost in cents via L3 adapter.\n\nPhase F-3: This replaces the direct L5 import.",
            "is_async": false,
            "line": 88
          },
          {
            "name": "_store_run",
            "signature": "(run_id: str, data: Dict[str, Any], tenant_id: str = 'default') -> None",
            "docstring": "Persist a run to PostgreSQL.\n\nP0-005 Fix: Database is the source of truth, not memory.",
            "is_async": true,
            "line": 256
          },
          {
            "name": "_insert_cost_record",
            "signature": "(run_id: str, tenant_id: str, model: str, input_tokens: int, output_tokens: int, cost_cents: int) -> None",
            "docstring": "Insert a cost record for a worker run.\n\nP0-006 Fix: Cost must be recorded as part of worker execution.\nThis creates the authoritative cost fact that S2 requires.",
            "is_async": true,
            "line": 302
          },
          {
            "name": "_check_and_emit_cost_advisory",
            "signature": "(run_id: str, tenant_id: str, cost_cents: int) -> Dict[str, Any]",
            "docstring": "Check if cost threshold is crossed and emit advisory if needed.\n\nS2 Advisory Invariant:\n- If threshold crossed AND hard_limit_enabled=false \u2192 exactly 1 advisory\n- If threshold NOT crossed \u2192 exactly 0 advisories\n- If hard_limit_enabled=true \u2192 this is an incident, not advisory (out of S2 scope)\n\nReturns dict with:\n- threshold_crossed: bool\n- advisory_emitted: bool\n- advisory_id: str | None\n- budget_id: str | None",
            "is_async": true,
            "line": 340
          },
          {
            "name": "_verify_advisory_invariant",
            "signature": "(run_id: str, tenant_id: str, advisory_result: Dict[str, Any]) -> None",
            "docstring": "Verify advisory emission invariant in VERIFICATION_MODE.\n\nS2 Invariant:\n- If threshold_crossed=true AND hard_limit_enabled=false \u2192 advisory_count must be 1\n- If threshold_crossed=false \u2192 advisory_count must be 0\n\nRaises RuntimeError if invariant violated.",
            "is_async": true,
            "line": 464
          },
          {
            "name": "_get_run",
            "signature": "(run_id: str) -> Optional[Dict[str, Any]]",
            "docstring": "Get a run from PostgreSQL via L4 registry.\n\nReturns dict format matching WorkerRunResponse for API compatibility.",
            "is_async": true,
            "line": 521
          },
          {
            "name": "_list_runs",
            "signature": "(limit: int = 20, tenant_id: Optional[str] = None) -> List[Dict[str, Any]]",
            "docstring": "List recent runs from PostgreSQL via L4 registry.",
            "is_async": true,
            "line": 543
          },
          {
            "name": "get_event_bus",
            "signature": "() -> WorkerEventBus",
            "docstring": "Get the global event bus instance.",
            "is_async": false,
            "line": 629
          },
          {
            "name": "_brand_request_to_schema",
            "signature": "(brand_req: BrandRequest)",
            "docstring": "Convert API request to BrandSchema via L3 adapter.\n\nPhase F-3: This replaces the direct L5 schema import.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": false,
            "line": 660
          },
          {
            "name": "_execute_worker_async",
            "signature": "(run_id: str, request: WorkerRunRequest) -> None",
            "docstring": "Execute worker in background and update run store.\n\nPhase F-3: Uses L3 adapter instead of direct L5 worker import.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": true,
            "line": 671
          },
          {
            "name": "run_worker",
            "signature": "(request: WorkerRunRequest, background_tasks: BackgroundTasks, _: str = Depends(verify_api_key))",
            "docstring": "Execute the Business Builder Worker.\n\nTakes a business idea and optionally brand constraints, produces a complete\nlaunch package including:\n- Market research\n- Brand strategy\n- Landing page copy\n- HTML/CSS assets\n- Replay token for deterministic reproduction\n\nIntegrates with:\n- M4: Golden replay (deterministic execution)\n- M9: Failure catalog (pattern detection)\n- M10: Recovery engine (auto-recovery)\n- M15: SBA (strategy-bound agents)\n- M17: CARE (complexity-aware routing)\n- M18: Drift detection\n- M19/M20: Policy governance",
            "is_async": true,
            "line": 807
          },
          {
            "name": "replay_execution_endpoint",
            "signature": "(request: ReplayRequest, auth: AuthorityResult = Depends(require_replay_execute))",
            "docstring": "Replay a previous execution using Golden Replay (M4).\n\nDeterministically reproduces the same outputs given the same replay token.\n\nPhase F-3: Uses L3 adapter instead of direct L5 worker import.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": true,
            "line": 1021
          },
          {
            "name": "get_run",
            "signature": "(run_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Get details of a worker run.\n\nUse this to poll for async run completion or inspect past runs.",
            "is_async": true,
            "line": 1068
          },
          {
            "name": "list_runs",
            "signature": "(limit: int = 20, tenant_id: Optional[str] = None, _: str = Depends(verify_api_key))",
            "docstring": "List recent worker runs.\n\nReturns summary information for recent executions.\nOptionally filter by tenant_id.",
            "is_async": true,
            "line": 1085
          },
          {
            "name": "retry_run",
            "signature": "(run_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Retry a completed or failed run - Phase-2.5.\n\nCreates a new run linked to the original via parent_run_id.\nThis is a lifecycle event, not execution - the run is queued only.\n\nRules:\n- Original run must be COMPLETED or FAILED\n- No agent execution triggered\n- DB write only, deterministic",
            "is_async": true,
            "line": 1114
          },
          {
            "name": "validate_brand",
            "signature": "(request: BrandRequest, _: str = Depends(verify_api_key))",
            "docstring": "Validate a brand schema without executing the worker.\n\nChecks:\n- Schema validity\n- Policy rules generation (M19)\n- Drift anchors extraction (M18)",
            "is_async": true,
            "line": 1192
          },
          {
            "name": "worker_health",
            "signature": "()",
            "docstring": "Health check for Business Builder Worker.\n\nReturns status of all integrated moats.\nPIN-520 Phase 1: Route L5 health checks through L4 registry.",
            "is_async": true,
            "line": 1243
          },
          {
            "name": "delete_run",
            "signature": "(run_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Delete a run from storage.\n\nNote: In production, this would require admin privileges.",
            "is_async": true,
            "line": 1306
          },
          {
            "name": "get_brand_schema",
            "signature": "()",
            "docstring": "Get the JSON schema for BrandRequest.\n\nUseful for clients to understand the expected format.",
            "is_async": true,
            "line": 1328
          },
          {
            "name": "get_run_schema",
            "signature": "()",
            "docstring": "Get the JSON schema for WorkerRunRequest.",
            "is_async": true,
            "line": 1338
          },
          {
            "name": "_sse_event_generator",
            "signature": "(run_id: str, queue: asyncio.Queue) -> AsyncGenerator[str, None]",
            "docstring": "Generate SSE events from the queue.",
            "is_async": true,
            "line": 1350
          },
          {
            "name": "stream_run_events",
            "signature": "(run_id: str, request: Request)",
            "docstring": "Stream real-time events for a worker run via Server-Sent Events (SSE).\n\nEvents include:\n- run_started: Worker execution began\n- stage_started/completed/failed: Stage lifecycle\n- log: Agent output logs\n- routing_decision: CARE routing decisions\n- policy_check/violation: M19 policy events\n- drift_detected: M18 drift detection\n- failure_detected: M9 failure pattern match\n- recovery_started/completed: M10 recovery actions\n- artifact_created: New artifact generated\n- run_completed/failed: Terminal state\n\nUsage (JavaScript):\n```js\nconst sse = new EventSource('/workers/business-builder/stream/{run_id}');\nsse.onmessage = (event) => console.log(JSON.parse(event.data));\nsse.addEventListener('stage_completed', (event) => { ... });\n```",
            "is_async": true,
            "line": 1383
          },
          {
            "name": "get_run_events",
            "signature": "(run_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Get all events for a run (non-streaming).\n\nUseful for replaying events or debugging.",
            "is_async": true,
            "line": 1429
          },
          {
            "name": "_execute_worker_with_events",
            "signature": "(run_id: str, request: WorkerRunRequest) -> None",
            "docstring": "Execute worker with REAL event emission from worker itself.\n\nv0.4: Worker is source of truth. PostgreSQL persistence. No in-memory storage.\n\nPhase F-3: Uses L3 adapter instead of direct L5 worker import.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": true,
            "line": 1451
          },
          {
            "name": "run_worker_streaming",
            "signature": "(request: WorkerRunRequest, background_tasks: BackgroundTasks, _: str = Depends(verify_api_key))",
            "docstring": "Execute the Business Builder Worker with real-time event streaming.\n\nReturns immediately with run_id. Connect to /stream/{run_id} for real-time events.\n\nThis is the preferred endpoint for UI-driven execution where you want to\nshow progress, routing decisions, and artifacts building in real-time.",
            "is_async": true,
            "line": 1548
          }
        ],
        "classes": [
          {
            "name": "ToneRuleRequest",
            "docstring": "Tone rule for brand.",
            "methods": [],
            "line": 106
          },
          {
            "name": "ForbiddenClaimRequest",
            "docstring": "Forbidden claim definition.",
            "methods": [],
            "line": 115
          },
          {
            "name": "VisualIdentityRequest",
            "docstring": "Visual identity for brand.",
            "methods": [],
            "line": 123
          },
          {
            "name": "BrandRequest",
            "docstring": "Brand schema for worker execution.",
            "methods": [],
            "line": 133
          },
          {
            "name": "WorkerRunRequest",
            "docstring": "Request to run the Business Builder Worker.",
            "methods": [],
            "line": 151
          },
          {
            "name": "PolicyStatusModel",
            "docstring": "Phase 5B: Policy pre-check status for PRE-RUN declaration.",
            "methods": [],
            "line": 170
          },
          {
            "name": "WorkerRunResponse",
            "docstring": "Response from worker execution.",
            "methods": [],
            "line": 181
          },
          {
            "name": "ReplayRequest",
            "docstring": "Request to replay a previous execution.",
            "methods": [],
            "line": 203
          },
          {
            "name": "BrandValidationResponse",
            "docstring": "Response from brand validation.",
            "methods": [],
            "line": 209
          },
          {
            "name": "RunListItem",
            "docstring": "Summary item for run listing.",
            "methods": [],
            "line": 219
          },
          {
            "name": "RunListResponse",
            "docstring": "Response for listing runs.",
            "methods": [],
            "line": 230
          },
          {
            "name": "RunRetryResponse",
            "docstring": "Response for run retry - Phase-2.5.",
            "methods": [],
            "line": 237
          },
          {
            "name": "WorkerEventBus",
            "docstring": "Event bus for real-time worker execution streaming.\n\nSupports multiple subscribers per run_id.\nEvents are JSON-serialized and sent as SSE.",
            "methods": [
              "__init__",
              "subscribe",
              "unsubscribe",
              "emit",
              "get_history",
              "cleanup"
            ],
            "line": 568
          },
          {
            "name": "EventType",
            "docstring": "Constants for SSE event types.",
            "methods": [],
            "line": 635
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "collections",
            "names": [
              "defaultdict"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "AsyncGenerator",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "BackgroundTasks",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "fastapi.responses",
            "names": [
              "StreamingResponse"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth",
            "names": [
              "verify_api_key"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "emit_authority_audit",
              "require_replay_execute"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.contracts.decisions",
            "names": [
              "emit_policy_precheck_decision"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_async_session_context",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.hoc.cus.hoc_spine.drivers.worker_write_driver_async",
            "names": [
              "WorkerWriteServiceAsync"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges",
            "names": [
              "get_policies_engine_bridge"
            ],
            "is_relative": false,
            "line": 64
          }
        ],
        "constants": [
          {
            "name": "VERIFICATION_MODE",
            "line": 250
          },
          {
            "name": "COST_ENFORCEMENT_ENABLED",
            "line": 253
          }
        ],
        "all_exports": null
      }
    ],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "ast.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/ast.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 381,
        "module_docstring": "Policy DSL Abstract Syntax Tree (AST) Definitions\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- All nodes are IMMUTABLE (frozen dataclasses)\n- No dynamic fields\n- No generic dicts (typed structures only)\n- No runtime evaluation logic\n- Must be serializable to JSON\n\nGOVERNANCE:\n- These types define the MEANING of policy structure\n- No authority, no execution, no side effects",
        "functions": [
          {
            "name": "is_predicate",
            "signature": "(condition: Condition) -> bool",
            "docstring": "Check if condition is a simple predicate.",
            "is_async": false,
            "line": 354
          },
          {
            "name": "is_exists_predicate",
            "signature": "(condition: Condition) -> bool",
            "docstring": "Check if condition is an exists predicate.",
            "is_async": false,
            "line": 359
          },
          {
            "name": "is_logical_condition",
            "signature": "(condition: Condition) -> bool",
            "docstring": "Check if condition is a compound logical condition.",
            "is_async": false,
            "line": 364
          },
          {
            "name": "is_warn_action",
            "signature": "(action: Action) -> bool",
            "docstring": "Check if action is a WARN action.",
            "is_async": false,
            "line": 369
          },
          {
            "name": "is_block_action",
            "signature": "(action: Action) -> bool",
            "docstring": "Check if action is a BLOCK action.",
            "is_async": false,
            "line": 374
          },
          {
            "name": "is_require_approval_action",
            "signature": "(action: Action) -> bool",
            "docstring": "Check if action is a REQUIRE_APPROVAL action.",
            "is_async": false,
            "line": 379
          }
        ],
        "classes": [
          {
            "name": "Scope",
            "docstring": "Policy scope determines visibility boundaries.",
            "methods": [],
            "line": 48
          },
          {
            "name": "Mode",
            "docstring": "Policy mode determines enforcement semantics.\n\nMONITOR: Can only WARN, cannot BLOCK or REQUIRE_APPROVAL\nENFORCE: Can WARN, BLOCK, or REQUIRE_APPROVAL",
            "methods": [],
            "line": 55
          },
          {
            "name": "Comparator",
            "docstring": "Comparison operators for predicates.",
            "methods": [],
            "line": 67
          },
          {
            "name": "LogicalOperator",
            "docstring": "Logical operators for compound conditions.",
            "methods": [],
            "line": 78
          },
          {
            "name": "WarnAction",
            "docstring": "Emit a warning message.\nAllowed in both MONITOR and ENFORCE modes.",
            "methods": [
              "to_dict"
            ],
            "line": 91
          },
          {
            "name": "BlockAction",
            "docstring": "Block execution.\nONLY allowed in ENFORCE mode (validated by validator.py).",
            "methods": [
              "to_dict"
            ],
            "line": 105
          },
          {
            "name": "RequireApprovalAction",
            "docstring": "Require human approval before proceeding.\nONLY allowed in ENFORCE mode (validated by validator.py).",
            "methods": [
              "to_dict"
            ],
            "line": 118
          },
          {
            "name": "Predicate",
            "docstring": "A simple comparison predicate.\n\nExample: cost_per_hour > 200",
            "methods": [
              "to_dict"
            ],
            "line": 140
          },
          {
            "name": "ExistsPredicate",
            "docstring": "Check if a metric exists.\n\nExample: exists(anomaly_flag)",
            "methods": [
              "to_dict"
            ],
            "line": 161
          },
          {
            "name": "LogicalCondition",
            "docstring": "A compound condition combining two conditions with AND/OR.\n\nExample: cost_per_hour > 200 AND error_rate > 0.1",
            "methods": [
              "to_dict"
            ],
            "line": 178
          },
          {
            "name": "Clause",
            "docstring": "A single when-then clause.\n\nStructure:\n    when <condition>\n    then <action>+",
            "methods": [
              "__post_init__",
              "to_dict"
            ],
            "line": 208
          },
          {
            "name": "PolicyMetadata",
            "docstring": "Policy metadata header.\n\nRequired fields per PIN-341:\n- name: Policy identifier\n- version: Version number (monotonically increasing)\n- scope: ORG or PROJECT\n- mode: MONITOR or ENFORCE",
            "methods": [
              "__post_init__",
              "to_dict"
            ],
            "line": 238
          },
          {
            "name": "PolicyAST",
            "docstring": "Root AST node for a complete policy.\n\nStructure:\n    policy <name>\n    version <n>\n    scope <ORG|PROJECT>\n    mode <MONITOR|ENFORCE>\n\n    when <condition>\n    then <action>+\n    [... more clauses ...]\n\nIMMUTABILITY: This entire structure is frozen.\nSERIALIZATION: Use to_dict() or to_json() for serialization.\nHASHING: Use compute_hash() for deterministic content hash.",
            "methods": [
              "__post_init__",
              "to_dict",
              "to_json",
              "compute_hash",
              "name",
              "version",
              "scope",
              "mode"
            ],
            "line": 277
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Literal",
              "Union"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "authority_checker.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/authority_checker.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 284,
        "module_docstring": "Module: authority_checker\nPurpose: Check override authority status for prevention engine.\n\nThe prevention engine must check override authority before enforcing\nany policy actions. If an override is active, enforcement is skipped.\n\nIntegration Flow:\n    1. Prevention engine receives policy ID\n    2. Calls OverrideAuthorityChecker.check()\n    3. If override is active, skip enforcement\n    4. If no override, proceed with enforcement\n\nExports:\n    - OverrideStatus: Enum of override states\n    - OverrideCheckResult: Result of an override check\n    - OverrideAuthorityChecker: Main integration class\n    - should_skip_enforcement: Quick helper function",
        "functions": [
          {
            "name": "should_skip_enforcement",
            "signature": "(override_authority: Any) -> bool",
            "docstring": "Quick helper to check if enforcement should be skipped.\n\nArgs:\n    override_authority: OverrideAuthority model instance or None\n\nReturns:\n    True if enforcement should be skipped, False otherwise",
            "is_async": false,
            "line": 272
          }
        ],
        "classes": [
          {
            "name": "OverrideStatus",
            "docstring": "Status of an override check.",
            "methods": [],
            "line": 46
          },
          {
            "name": "OverrideCheckResult",
            "docstring": "Result of an override authority check.\n\nContains the status and metadata about any active override.",
            "methods": [
              "to_dict"
            ],
            "line": 56
          },
          {
            "name": "OverrideAuthorityChecker",
            "docstring": "Checks override authority status for the prevention engine.\n\nThe prevention engine must call this before enforcing any\npolicy actions to respect active overrides.\n\nGAP-034: Wire OverrideAuthority to prevention.\n\nUsage:\n    checker = OverrideAuthorityChecker()\n    result = checker.check(override_authority)\n    if result.skip_enforcement:\n        # Skip policy enforcement\n        log.info(f\"Skipping enforcement: override by {result.override_by}\")\n    else:\n        # Proceed with enforcement\n        enforce_policy()",
            "methods": [
              "check",
              "_is_override_active",
              "check_from_dict"
            ],
            "line": 90
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "binding_moment_enforcer.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/binding_moment_enforcer.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 276,
        "module_docstring": "Module: binding_moment_enforcer\nPurpose: Ensures policies are evaluated at the correct binding moment.\n\nBinding moments define WHEN a policy is evaluated:\n- RUN_START: Evaluate once at run start (snapshot-based)\n- STEP_START: Evaluate before each step\n- STEP_END: Evaluate after each step\n- ON_CHANGE: Evaluate when specific fields change\n\nIf a policy has bind_at=RUN_START, it should NOT be re-evaluated mid-run.\n\nImports (Dependencies):\n    - None (standalone)\n\nExports (Provides):\n    - should_evaluate_policy(policy, context) -> bool\n    - BindingMoment: Enum\n    - get_binding_moment(policy) -> BindingMoment\n\nWiring Points:\n    - Called from: prevention_engine.py before evaluating each policy\n\nAcceptance Criteria:\n    - [x] AC-031-01: RUN_START binding respected\n    - [x] AC-031-02: STEP_START binding respected\n    - [x] AC-031-03: Mid-run re-eval blocked for RUN_START\n    - [x] AC-031-04: Binding moment logged",
        "functions": [
          {
            "name": "should_evaluate_policy",
            "signature": "(policy: Any, context: Dict[str, Any], evaluation_point: EvaluationPoint) -> BindingDecision",
            "docstring": "Determine if a policy should be evaluated at this point.\n\nRespects the policy's bind_at setting:\n- RUN_START: Only evaluate once per run, at initialization\n- STEP_START: Evaluate before each step\n- STEP_END: Evaluate after each step\n- ON_CHANGE: Evaluate only when monitored fields change\n- ALWAYS: Evaluate at every point\n\nArgs:\n    policy: Policy object with bind_at attribute\n    context: Evaluation context with run_id, step info, etc.\n    evaluation_point: Current point in execution\n\nReturns:\n    BindingDecision with should_evaluate and reason",
            "is_async": false,
            "line": 89
          },
          {
            "name": "get_binding_moment",
            "signature": "(policy: Any) -> BindingMoment",
            "docstring": "Get the binding moment for a policy.\n\nArgs:\n    policy: Policy object\n\nReturns:\n    BindingMoment enum value",
            "is_async": false,
            "line": 201
          },
          {
            "name": "clear_run_cache",
            "signature": "(run_id: str) -> None",
            "docstring": "Clear the evaluation cache for a run (call on run completion).",
            "is_async": false,
            "line": 242
          },
          {
            "name": "_mark_evaluated",
            "signature": "(run_id: str, policy_id: str) -> None",
            "docstring": "Mark a policy as evaluated for a run.",
            "is_async": false,
            "line": 248
          },
          {
            "name": "_was_evaluated",
            "signature": "(run_id: str, policy_id: str) -> bool",
            "docstring": "Check if a policy was already evaluated for a run.",
            "is_async": false,
            "line": 255
          },
          {
            "name": "_check_fields_changed",
            "signature": "(policy: Any, context: Dict[str, Any]) -> bool",
            "docstring": "Check if monitored fields changed (for ON_CHANGE binding).",
            "is_async": false,
            "line": 260
          }
        ],
        "classes": [
          {
            "name": "BindingMoment",
            "docstring": "When a policy should be evaluated.",
            "methods": [],
            "line": 58
          },
          {
            "name": "EvaluationPoint",
            "docstring": "Current point in execution where evaluation is requested.",
            "methods": [],
            "line": 67
          },
          {
            "name": "BindingDecision",
            "docstring": "Decision about whether to evaluate a policy.",
            "methods": [],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "Optional",
              "Any",
              "Dict",
              "Set"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "compiler_parser.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/compiler_parser.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 460,
        "module_docstring": "Parser for PLang v2.0 with M19 category support.\n\nProduces an AST from tokens, supporting:\n- Policy declarations with categories\n- Rule declarations with priorities\n- Condition blocks (when/then)\n- Action blocks (deny/allow/escalate/route)\n- Expression evaluation",
        "functions": [],
        "classes": [
          {
            "name": "ParseError",
            "docstring": "Error during parsing.",
            "methods": [
              "__init__"
            ],
            "line": 57
          },
          {
            "name": "Parser",
            "docstring": "Parser for PLang v2.0.\n\nConverts tokens into an AST with M19 governance metadata.",
            "methods": [
              "__init__",
              "from_source",
              "current",
              "peek",
              "advance",
              "expect",
              "match",
              "parse",
              "parse_policy_decl",
              "parse_category",
              "parse_policy_body",
              "parse_rule_decl",
              "parse_rule_body",
              "parse_rule_ref",
              "parse_condition_block",
              "parse_action_block",
              "parse_route_target",
              "parse_priority",
              "parse_import",
              "parse_expr",
              "parse_or_expr",
              "parse_and_expr",
              "parse_not_expr",
              "parse_comparison",
              "parse_value",
              "parse_func_call"
            ],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.policy.ast.nodes",
            "names": [
              "ActionBlockNode",
              "ASTNode",
              "AttrAccessNode",
              "BinaryOpNode",
              "ConditionBlockNode",
              "ExprNode",
              "FuncCallNode",
              "IdentNode",
              "ImportNode",
              "LiteralNode",
              "PolicyDeclNode",
              "PriorityNode",
              "ProgramNode",
              "RouteTargetNode",
              "RuleDeclNode",
              "RuleRefNode",
              "UnaryOpNode"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.policy.compiler.tokenizer",
            "names": [
              "Token",
              "Tokenizer",
              "TokenType"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "content_accuracy.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/content_accuracy.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 386,
        "module_docstring": null,
        "functions": [
          {
            "name": "validate_content_accuracy",
            "signature": "(output: str, context: Dict[str, Any], user_query: Optional[str] = None, strict_mode: bool = True) -> ContentAccuracyResult",
            "docstring": "Convenience function to validate content accuracy.\n\nUsage:\n    result = validate_content_accuracy(\n        output=\"Yes, your contract is set to auto-renew on January 1, 2026.\",\n        context={\"auto_renew\": None, \"customer_id\": \"cust_8372\"},\n        user_query=\"Is my contract auto-renewed?\"\n    )\n\n    if result.result == ValidationResult.FAIL:\n        # Block the response or create incident\n        pass",
            "is_async": false,
            "line": 344
          }
        ],
        "classes": [
          {
            "name": "AssertionType",
            "docstring": "Types of assertions detected in output.",
            "methods": [],
            "line": 36
          },
          {
            "name": "ValidationResult",
            "docstring": "Result of content accuracy validation.",
            "methods": [],
            "line": 45
          },
          {
            "name": "AssertionCheck",
            "docstring": "A single assertion check result.",
            "methods": [],
            "line": 54
          },
          {
            "name": "ContentAccuracyResult",
            "docstring": "Complete result of content accuracy validation.",
            "methods": [
              "to_dict"
            ],
            "line": 67
          },
          {
            "name": "ContentAccuracyValidator",
            "docstring": "Validates that LLM output does not make assertions about missing data.\n\nPrevention mechanism for the CONTENT_ACCURACY policy gap:\n- Detects when output makes definitive claims\n- Checks if the claimed data exists in context\n- Blocks/warns when assertions are made about NULL/missing fields",
            "methods": [
              "__init__",
              "validate",
              "_detect_assertion_type",
              "_get_nested_value",
              "_extract_claim",
              "_claims_affirmative"
            ],
            "line": 158
          }
        ],
        "imports": [
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          }
        ],
        "constants": [
          {
            "name": "DEFINITIVE_PATTERNS",
            "line": 104
          },
          {
            "name": "UNCERTAINTY_PATTERNS",
            "line": 119
          },
          {
            "name": "HEDGED_PATTERNS",
            "line": 135
          },
          {
            "name": "CONTRACT_TERMS",
            "line": 149
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "customer_policy_read_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/customer_policy_read_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 343,
        "module_docstring": "Customer Policy Read Service (L4)\n\nThis service provides all READ operations for the Policy domain.\nIt delegates DB access to PolicyReadDriver (L6) and applies business logic.\n\nL3 (Adapter) \u2192 L4 (this service) \u2192 L6 (PolicyReadDriver)\n\nResponsibilities:\n- Calculate period bounds (business logic)\n- Calculate budget remaining/percentage (business logic)\n- Assemble customer-safe DTOs\n- Rate limits defaults (business logic)\n- Delegate DB queries to driver\n\nBusiness Logic (stays in L4):\n- _calculate_period_bounds() - daily/weekly/monthly period calculation\n- Budget remaining calculation\n- Percentage calculation\n- Rate limit defaults\n\nReference: PIN-281, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_customer_policy_read_service",
            "signature": "(session: 'Session') -> CustomerPolicyReadService",
            "docstring": "Factory function for CustomerPolicyReadService.\n\nArgs:\n    session: SQLModel session (REQUIRED - must be provided by L3 adapter)\n\nReturns:\n    Configured CustomerPolicyReadService instance\n\nNote:\n    Session must be provided by caller. This engine does not create sessions.\n    Session creation is the responsibility of L3 adapters.",
            "is_async": false,
            "line": 329
          }
        ],
        "classes": [
          {
            "name": "BudgetConstraint",
            "docstring": "Customer-visible budget constraint.\n\nIMPORTANT: No internal threshold multipliers, no warning levels.\nThis is what customers see for their budget status.",
            "methods": [],
            "line": 67
          },
          {
            "name": "RateLimit",
            "docstring": "Customer-visible rate limit.\n\nIMPORTANT: No internal bucket configuration exposed.",
            "methods": [],
            "line": 84
          },
          {
            "name": "GuardrailSummary",
            "docstring": "Customer-visible guardrail summary.\n\nIMPORTANT: No threshold values, no rule_config, no priority.\nCustomers see what guardrails exist and their actions, not how they're implemented.",
            "methods": [],
            "line": 98
          },
          {
            "name": "PolicyConstraints",
            "docstring": "Customer-visible policy constraints summary.\n\nThis is the aggregate view of all constraints affecting a tenant.",
            "methods": [],
            "line": 115
          },
          {
            "name": "CustomerPolicyReadService",
            "docstring": "L4 service for policy constraint read operations.\n\nDelegates DB operations to PolicyReadDriver (L6).\nApplies business logic for period calculation, budget math, etc.\n\nINVARIANT: tenant_id is REQUIRED for budget operations.\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "get_policy_constraints",
              "get_guardrail_detail",
              "_get_budget_constraint",
              "_calculate_period_bounds",
              "_get_rate_limits",
              "_get_guardrails"
            ],
            "line": 129
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_read_driver",
            "names": [
              "PolicyReadDriver",
              "get_policy_read_driver"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "decorator.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/decorator.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 192,
        "module_docstring": "@governed Decorator - PIN-337 Optional Ergonomic Wrapper\n\nThis decorator provides convenient syntax for routing execution\nthrough the ExecutionKernel.\n\nIMPORTANT:\n- This decorator is OPTIONAL, not required\n- CI does NOT enforce decorator presence\n- CI enforces KERNEL usage (semantic), not syntax\n- The decorator is CONVENIENCE, the kernel is PHYSICS",
        "functions": [
          {
            "name": "governed",
            "signature": "(capability: str, execution_vector: str = 'HTTP', extract_tenant: Optional[Callable[..., str]] = None, extract_subject: Optional[Callable[..., str]] = None, reason: Optional[str] = None) -> Callable[[F], F]",
            "docstring": "Decorator that routes execution through the ExecutionKernel.\n\nUsage:\n    @governed(capability=\"CAP-019\", execution_vector=\"HTTP_ADMIN\")\n    @app.post(\"/admin/retry\")\n    async def retry_run(payload: RetryRequest):\n        # Business logic here\n        ...\n\nArgs:\n    capability: The capability ID (e.g., \"CAP-019\")\n    execution_vector: Where execution is coming from (HTTP, CLI, SDK, etc.)\n    extract_tenant: Optional callable to extract tenant_id from args/kwargs\n    extract_subject: Optional callable to extract subject from args/kwargs\n    reason: Optional reason for the execution\n\nReturns:\n    Decorated function that routes through kernel\n\nIMPORTANT:\n    - This decorator is OPTIONAL\n    - CI does not enforce decorator presence\n    - CI enforces kernel usage (semantic check)",
            "is_async": false,
            "line": 49
          },
          {
            "name": "_extract_tenant_id",
            "signature": "(args: tuple, kwargs: dict, extractor: Optional[Callable[..., str]]) -> str",
            "docstring": "Extract tenant_id from function arguments.",
            "is_async": false,
            "line": 139
          },
          {
            "name": "_extract_subject",
            "signature": "(args: tuple, kwargs: dict, extractor: Optional[Callable[..., str]]) -> str",
            "docstring": "Extract subject from function arguments.",
            "is_async": false,
            "line": 168
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "functools",
            "names": [
              "functools"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "inspect",
            "names": [
              "inspect"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Optional",
              "TypeVar"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.governance.kernel",
            "names": [
              "ExecutionKernel",
              "InvocationContext"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [
          {
            "name": "F",
            "line": 46
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "degraded_mode.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/degraded_mode.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 217,
        "module_docstring": "Degraded Mode - Graceful Governance Degradation\n\nWhen governance systems are partially unavailable, the system\ncan enter degraded mode:\n- New runs are blocked\n- Existing runs continue with WARN action\n- Telemetry and logging continue\n\nThis prevents cascading failures while maintaining visibility.",
        "functions": [
          {
            "name": "enter_degraded_mode",
            "signature": "(reason: str, entered_by: str, existing_runs_action: str = 'WARN') -> DegradedModeTransition",
            "docstring": "Enter degraded mode.\n\nNew runs will be blocked, existing runs continue with warnings.\n\nArgs:\n    reason: Why degraded mode is being entered\n    entered_by: Identifier of operator/system entering\n    existing_runs_action: Action for in-flight runs (WARN, ALLOW, BLOCK)\n\nReturns:\n    DegradedModeTransition result",
            "is_async": false,
            "line": 71
          },
          {
            "name": "exit_degraded_mode",
            "signature": "(exited_by: str = 'system') -> DegradedModeTransition",
            "docstring": "Exit degraded mode.\n\nRestores normal governance operation.\n\nArgs:\n    exited_by: Identifier of operator/system exiting\n\nReturns:\n    DegradedModeTransition result",
            "is_async": false,
            "line": 120
          },
          {
            "name": "is_degraded_mode_active",
            "signature": "() -> bool",
            "docstring": "Check if degraded mode is currently active.\n\nReturns:\n    True if system is in degraded mode",
            "is_async": false,
            "line": 159
          },
          {
            "name": "get_degraded_mode_status",
            "signature": "() -> DegradedModeStatus",
            "docstring": "Get current degraded mode status.\n\nReturns:\n    Current DegradedModeStatus",
            "is_async": false,
            "line": 170
          },
          {
            "name": "should_allow_new_run",
            "signature": "(run_id: str) -> bool",
            "docstring": "Check if a new run should be allowed.\n\nIn degraded mode, new runs are blocked.\n\nArgs:\n    run_id: ID of the run being started\n\nReturns:\n    True if run should be allowed, False to block",
            "is_async": false,
            "line": 185
          },
          {
            "name": "get_existing_run_action",
            "signature": "() -> str",
            "docstring": "Get action for existing/in-flight runs in degraded mode.\n\nReturns:\n    Action string: WARN, ALLOW, or BLOCK",
            "is_async": false,
            "line": 207
          }
        ],
        "classes": [
          {
            "name": "DegradedModeStatus",
            "docstring": "Current status of degraded mode.",
            "methods": [
              "get_inactive"
            ],
            "line": 47
          },
          {
            "name": "DegradedModeTransition",
            "docstring": "Result of degraded mode transition.",
            "methods": [],
            "line": 63
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "threading",
            "names": [
              "Lock"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "deterministic_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/deterministic_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 560,
        "module_docstring": "Deterministic execution engine for PLang v2.0.\n\nKey principles:\n- NO RANDOMNESS: Every execution is reproducible\n- GOVERNANCE-FIRST: Safety checks before any action\n- AUDITABLE: Full execution trace for debugging\n- DETERMINISTIC: Same input = same output\n\nIntegration points:\n- M18: Intent emission for execution\n- M19: Policy validation before actions\n- M4: Execution plan generation",
        "functions": [
          {
            "name": "safe_regex_match",
            "signature": "(input_str: str, pattern: str) -> bool",
            "docstring": "Safe regex match with length limits and ReDoS guards.\n\nReturns False on any failure (fail-closed).",
            "is_async": false,
            "line": 50
          }
        ],
        "classes": [
          {
            "name": "ExecutionStatus",
            "docstring": "Status of policy execution.",
            "methods": [],
            "line": 90
          },
          {
            "name": "ExecutionContext",
            "docstring": "Execution context for policy evaluation.\n\nContains all runtime state needed for deterministic execution.",
            "methods": [
              "__post_init__",
              "_generate_id",
              "get_variable",
              "set_variable",
              "push_call",
              "pop_call",
              "add_trace"
            ],
            "line": 101
          },
          {
            "name": "ExecutionResult",
            "docstring": "Result of policy execution.\n\nContains final decision, intents, and audit trail.",
            "methods": [
              "to_dict"
            ],
            "line": 184
          },
          {
            "name": "DeterministicEngine",
            "docstring": "Deterministic policy execution engine.\n\nExecutes compiled IR with:\n- No randomness (reproducible)\n- Governance validation\n- Intent emission\n- Full audit trail",
            "methods": [
              "__init__",
              "_register_builtins",
              "execute",
              "_execute_function",
              "_execute_instruction",
              "_eval_binary_op",
              "_eval_unary_op",
              "_eval_compare",
              "_call_function",
              "_action_to_intent_type"
            ],
            "line": 214
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.policies.L5_schemas.policy_check",
            "names": [
              "PolicyCheckValidator"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRAction",
              "IRBinaryOp",
              "IRCall",
              "IRCheckPolicy",
              "IRCompare",
              "IREmitIntent",
              "IRFunction",
              "IRInstruction",
              "IRJump",
              "IRJumpIf",
              "IRLoadConst",
              "IRLoadVar",
              "IRModule",
              "IRReturn",
              "IRStoreVar",
              "IRUnaryOp"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.intent",
            "names": [
              "Intent",
              "IntentEmitter",
              "IntentPayload",
              "IntentType"
            ],
            "is_relative": false,
            "line": 87
          }
        ],
        "constants": [
          {
            "name": "MAX_PATTERN_LEN",
            "line": 45
          },
          {
            "name": "MAX_INPUT_LEN",
            "line": 46
          },
          {
            "name": "_REDOS_PATTERN",
            "line": 47
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "dsl_parser.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/dsl_parser.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 523,
        "module_docstring": "Policy DSL Parser\n\nConverts DSL text into typed, immutable AST nodes.\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- Single-pass recursive descent parser\n- No external parser libraries (no PLY, no ANTLR)\n- All errors must be position-aware\n- Must produce valid AST or raise ParseError\n\nGRAMMAR (Simplified EBNF):\n    policy      := header clause+\n    header      := 'policy' NAME 'version' INT 'scope' SCOPE 'mode' MODE\n    clause      := 'when' condition 'then' action+\n    condition   := or_expr\n    or_expr     := and_expr ('OR' and_expr)*\n    and_expr    := atom ('AND' atom)*\n    atom        := predicate | exists_pred | '(' or_expr ')'\n    predicate   := METRIC comparator value\n    exists_pred := 'exists' '(' METRIC ')'\n    comparator  := '>' | '>=' | '<' | '<=' | '==' | '!='\n    value       := INT | FLOAT | STRING | BOOL\n    action      := 'WARN' STRING | 'BLOCK' | 'REQUIRE_APPROVAL'\n\nGOVERNANCE:\n- Pure parsing logic\n- No side effects\n- No I/O, no DB",
        "functions": [
          {
            "name": "parse",
            "signature": "(source: str) -> PolicyAST",
            "docstring": "Parse Policy DSL text into AST.\n\nArgs:\n    source: The DSL source text\n\nReturns:\n    PolicyAST: The parsed AST\n\nRaises:\n    ParseError: If the source is invalid\n\nExample:\n    >>> ast = parse('''\n    ... policy CostGuard\n    ... version 1\n    ... scope PROJECT\n    ... mode MONITOR\n    ...\n    ... when cost_per_hour > 200\n    ... then WARN \"Cost exceeded threshold\"\n    ... ''')\n    >>> ast.name\n    'CostGuard'",
            "is_async": false,
            "line": 467
          },
          {
            "name": "parse_condition",
            "signature": "(source: str) -> Condition",
            "docstring": "Parse a standalone condition expression.\n\nUseful for testing or building conditions programmatically.\n\nArgs:\n    source: The condition expression\n\nReturns:\n    Condition: The parsed condition\n\nExample:\n    >>> cond = parse_condition(\"cost > 100 AND error_rate > 0.1\")\n    >>> is_logical_condition(cond)\n    True",
            "is_async": false,
            "line": 499
          }
        ],
        "classes": [
          {
            "name": "ParseLocation",
            "docstring": "Source location for error reporting.",
            "methods": [
              "__str__"
            ],
            "line": 81
          },
          {
            "name": "ParseError",
            "docstring": "Raised when parsing fails.\n\nContains position information for helpful error messages.",
            "methods": [
              "__init__"
            ],
            "line": 91
          },
          {
            "name": "Token",
            "docstring": "A lexical token with position info.",
            "methods": [],
            "line": 113
          },
          {
            "name": "Lexer",
            "docstring": "Tokenizer for Policy DSL.\n\nProduces tokens from source text for the parser.",
            "methods": [
              "__init__",
              "tokenize",
              "_advance",
              "_convert_value"
            ],
            "line": 122
          },
          {
            "name": "Parser",
            "docstring": "Recursive descent parser for Policy DSL.\n\nConverts token stream to typed AST.",
            "methods": [
              "__init__",
              "current",
              "error",
              "expect",
              "accept",
              "parse",
              "_parse_header",
              "_parse_clauses",
              "_parse_clause",
              "_parse_condition",
              "_parse_or_expr",
              "_parse_and_expr",
              "_parse_atom",
              "_parse_predicate",
              "_parse_value",
              "_parse_actions",
              "_try_parse_action"
            ],
            "line": 244
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.dsl.ast",
            "names": [
              "Action",
              "BlockAction",
              "Clause",
              "Comparator",
              "Condition",
              "ExistsPredicate",
              "LogicalCondition",
              "LogicalOperator",
              "Mode",
              "PolicyAST",
              "PolicyMetadata",
              "Predicate",
              "RequireApprovalAction",
              "Scope",
              "WarnAction"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 2779,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_policy_engine",
            "signature": "() -> PolicyEngine",
            "docstring": "Get singleton policy engine with M18 Governor integration.",
            "is_async": false,
            "line": 2761
          }
        ],
        "classes": [
          {
            "name": "PolicyEngine",
            "docstring": "M19 Policy Engine - Constitutional Governance Layer.\n\nEvery agent decision must go through policy.evaluate() before execution.\n\nResponsibilities:\n- Enforce compliance rules\n- Enforce ethical constraints\n- Enforce risk ceilings\n- Enforce safety rules\n- Enforce business rules\n- Route violations to M18 Governor\n- Audit all evaluations",
            "methods": [
              "__init__",
              "driver",
              "evaluate",
              "pre_check",
              "_check_ethical_constraints",
              "_evaluate_ethical_constraint",
              "_extract_text_content",
              "_check_safety_rules",
              "_evaluate_safety_rule",
              "_check_cooldown",
              "_check_risk_ceilings",
              "_evaluate_risk_ceiling",
              "_get_windowed_value",
              "_add_windowed_value",
              "_check_compliance",
              "_evaluate_compliance_rule",
              "_check_business_rules",
              "_evaluate_business_rule",
              "_route_to_governor",
              "_load_policies",
              "_load_default_policies",
              "_is_cache_stale",
              "_persist_evaluation",
              "get_state",
              "reload_policies",
              "set_governor",
              "get_violations",
              "get_violation",
              "acknowledge_violation",
              "get_risk_ceilings",
              "get_risk_ceiling",
              "update_risk_ceiling",
              "reset_risk_ceiling",
              "get_safety_rules",
              "update_safety_rule",
              "get_ethical_constraints",
              "get_active_cooldowns",
              "clear_cooldowns",
              "get_metrics",
              "get_policy_versions",
              "get_current_version",
              "create_policy_version",
              "rollback_to_version",
              "get_version_provenance",
              "get_dependency_graph",
              "get_policy_conflicts",
              "resolve_conflict",
              "get_temporal_policies",
              "create_temporal_policy",
              "get_temporal_utilization",
              "evaluate_with_context",
              "_safe_dependency_count",
              "_compute_policy_hash",
              "_classify_severity",
              "_classify_recoverability",
              "validate_dependency_dag",
              "add_dependency_with_dag_check",
              "get_topological_evaluation_order",
              "prune_temporal_metrics",
              "get_temporal_storage_stats",
              "activate_policy_version"
            ],
            "line": 155
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 81
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 83
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 84
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 85
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 86
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 87
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 88
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 89
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 90
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 91
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_engine_driver",
            "names": [
              "PolicyEngineDriver",
              "get_policy_engine_driver"
            ],
            "is_relative": false,
            "line": 97
          },
          {
            "module": "app.policy.models",
            "names": [
              "ActionType",
              "BusinessRule",
              "BusinessRuleType",
              "EthicalConstraint",
              "EthicalConstraintType",
              "Policy",
              "PolicyCategory",
              "PolicyDecision",
              "PolicyEvaluationRequest",
              "PolicyEvaluationResult",
              "PolicyLoadResult",
              "PolicyModification",
              "PolicyRule",
              "PolicyState",
              "PolicyViolation",
              "RiskCeiling",
              "SafetyRule",
              "SafetyRuleType",
              "ViolationType"
            ],
            "is_relative": false,
            "line": 105
          },
          {
            "module": "app.contracts.decisions",
            "names": [
              "emit_policy_decision"
            ],
            "is_relative": false,
            "line": 130
          }
        ],
        "constants": [
          {
            "name": "POLICY_SIGNING_SECRET",
            "line": 137
          },
          {
            "name": "MAX_EVALUATION_TIME_MS",
            "line": 140
          },
          {
            "name": "CACHE_TTL_SECONDS",
            "line": 141
          },
          {
            "name": "DEFAULT_COST_CEILING_PER_HOUR",
            "line": 144
          },
          {
            "name": "DEFAULT_RETRY_CEILING_PER_MINUTE",
            "line": 145
          },
          {
            "name": "DEFAULT_CASCADE_DEPTH",
            "line": 146
          },
          {
            "name": "DEFAULT_CONCURRENT_AGENTS",
            "line": 147
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "failure_mode_handler.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/failure_mode_handler.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 296,
        "module_docstring": "Module: failure_mode_handler\nPurpose: Handles failure modes when policy evaluation fails or is uncertain.\n\nKey Principle: FAIL-CLOSED by default.\nIf policy evaluation fails, the system MUST block the action, not allow it.\n\nImports (Dependencies):\n    - app.hoc.cus.hoc_spine.authority.profile_policy_mode: get_governance_config\n\nExports (Provides):\n    - handle_policy_failure(error, context) -> FailureDecision\n    - FailureMode: Enum of failure modes\n    - FailureDecision: Decision when failure occurs\n\nWiring Points:\n    - Called from: prevention_engine.py when evaluation fails\n    - Logs: All failures for audit\n\nAcceptance Criteria:\n    - [x] AC-035-01: Default is fail-closed\n    - [x] AC-035-02: Missing policy = blocked\n    - [x] AC-035-03: Evaluation error = blocked\n    - [x] AC-035-04: All failures logged\n    - [x] AC-035-05: No hardcoded fail-open",
        "functions": [
          {
            "name": "set_governance_config_getter",
            "signature": "(getter: Callable[[], Any]) -> None",
            "docstring": "Set the governance config getter for L5 purity (PIN-520).\n\nPIN-520: L4 callers must inject the config getter at startup.\nL5 must not import from hoc_spine.\n\nArgs:\n    getter: Function that returns the governance config (injected by L4 caller).",
            "is_async": false,
            "line": 58
          },
          {
            "name": "get_failure_mode",
            "signature": "() -> FailureMode",
            "docstring": "Get configured failure mode.\n\nPIN-520: Uses injected governance config getter instead of importing from L4 authority.\nCall set_governance_config_getter() at startup to inject the config getter.\n\nReturns:\n    FailureMode from governance config, defaulting to FAIL_CLOSED",
            "is_async": false,
            "line": 105
          },
          {
            "name": "handle_policy_failure",
            "signature": "(error: Optional[Exception], context: Dict[str, Any], failure_type: FailureType = FailureType.UNKNOWN) -> FailureDecision",
            "docstring": "Handle a policy evaluation failure.\n\nThis function determines what action to take when policy evaluation\nfails. The default is FAIL-CLOSED (block the action).\n\nArgs:\n    error: The exception that occurred, if any\n    context: Evaluation context (run_id, tenant_id, etc.)\n    failure_type: Type of failure\n\nReturns:\n    FailureDecision with action to take",
            "is_async": false,
            "line": 145
          },
          {
            "name": "handle_missing_policy",
            "signature": "(context: Dict[str, Any]) -> FailureDecision",
            "docstring": "Handle case where no policy exists for the action.\n\nBy default, missing policy = BLOCK (fail-closed).\n\nArgs:\n    context: Evaluation context\n\nReturns:\n    FailureDecision",
            "is_async": false,
            "line": 244
          },
          {
            "name": "handle_evaluation_error",
            "signature": "(error: Exception, context: Dict[str, Any]) -> FailureDecision",
            "docstring": "Handle policy evaluation error.\n\nArgs:\n    error: The exception that occurred\n    context: Evaluation context\n\nReturns:\n    FailureDecision",
            "is_async": false,
            "line": 263
          },
          {
            "name": "handle_timeout",
            "signature": "(context: Dict[str, Any], timeout_seconds: float) -> FailureDecision",
            "docstring": "Handle policy evaluation timeout.\n\nArgs:\n    context: Evaluation context\n    timeout_seconds: How long before timeout\n\nReturns:\n    FailureDecision",
            "is_async": false,
            "line": 281
          }
        ],
        "classes": [
          {
            "name": "FailureMode",
            "docstring": "Failure mode for policy evaluation.",
            "methods": [],
            "line": 72
          },
          {
            "name": "FailureType",
            "docstring": "Type of failure encountered.",
            "methods": [],
            "line": 79
          },
          {
            "name": "FailureDecision",
            "docstring": "Decision made when failure occurs.",
            "methods": [],
            "line": 90
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Optional",
              "Any",
              "Dict",
              "Callable"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_FAILURE_MODE",
            "line": 102
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "folds.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/folds.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 403,
        "module_docstring": "IR optimizations for PLang v2.0.\n\nOptimizations:\n- Constant folding: Evaluate constant expressions at compile time\n- Dead code elimination: Remove unreachable code\n- Policy simplification: Merge compatible policies",
        "functions": [],
        "classes": [
          {
            "name": "FoldResult",
            "docstring": "Result of a folding operation.",
            "methods": [],
            "line": 50
          },
          {
            "name": "ConstantFolder",
            "docstring": "Constant folding optimization.\n\nEvaluates constant expressions at compile time without\naffecting governance semantics.",
            "methods": [
              "__init__",
              "fold_module",
              "fold_function",
              "fold_block",
              "try_fold",
              "_fold_binary_op",
              "_fold_unary_op",
              "_fold_compare"
            ],
            "line": 58
          },
          {
            "name": "DeadCodeEliminator",
            "docstring": "Dead code elimination.\n\nRemoves unreachable code and unused definitions while\npreserving governance-critical paths.",
            "methods": [
              "__init__",
              "eliminate",
              "_mark_governance_critical",
              "_eliminate_function",
              "_find_reachable_blocks",
              "_find_used_instructions"
            ],
            "line": 196
          },
          {
            "name": "PolicySimplifier",
            "docstring": "Policy-specific simplifications.\n\nMerges compatible policies based on governance rules\nwhile preserving semantic correctness.",
            "methods": [
              "__init__",
              "simplify",
              "_find_mergeable_policies",
              "_merge_policies"
            ],
            "line": 325
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRAction",
              "IRBinaryOp",
              "IRBlock",
              "IRCompare",
              "IRFunction",
              "IRInstruction",
              "IRJump",
              "IRJumpIf",
              "IRLoadConst",
              "IRModule",
              "IRUnaryOp"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "governance_facade.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/governance_facade.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 740,
        "module_docstring": "Governance Facade (L4 Domain Logic)\n\nThis facade provides the external interface for governance control operations.\nAll governance APIs MUST use this facade instead of directly importing\ninternal governance modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes governance control logic\n- Provides unified access to kill switch, degraded mode, conflict resolution\n- Single point for audit emission\n\nWrapped Services:\n- runtime_switch: Kill switch and degraded mode (GAP-069, GAP-070)\n- ConflictResolver: Policy conflict resolution (GAP-068)\n- BootGuard: SPINE component health (GAP-067)\n\nL2 API Routes (GAP-090 to GAP-095):\n- POST /api/v1/governance/kill-switch (GAP-090)\n- POST /api/v1/governance/mode (GAP-091)\n- POST /api/v1/governance/resolve-conflict (GAP-092)\n- GET /api/v1/governance/boot-status (GAP-095)\n\nUsage:\n    from app.hoc.cus.policies.L5_engines.governance_facade import get_governance_facade\n\n    facade = get_governance_facade()\n\n    # Check governance state\n    state = facade.get_governance_state()\n\n    # Enable kill switch\n    facade.enable_kill_switch(reason=\"Emergency\", actor=\"operator\")\n\n    # Enter degraded mode\n    facade.set_mode(mode=\"DEGRADED\", reason=\"High load\", actor=\"system\")",
        "functions": [
          {
            "name": "get_governance_facade",
            "signature": "(runtime_switch: Optional[ModuleType] = None) -> GovernanceFacade",
            "docstring": "Get the governance facade instance.\n\nThis is the recommended way to access governance control operations\nfrom L2 APIs and the SDK.\n\nPIN-520: L4 callers must inject runtime_switch. L5 must not import from hoc_spine.\n\nArgs:\n    runtime_switch: The runtime_switch module for governance state management (injected by L4 caller).\n\nReturns:\n    GovernanceFacade instance",
            "is_async": false,
            "line": 717
          }
        ],
        "classes": [
          {
            "name": "GovernanceMode",
            "docstring": "Governance operation modes.",
            "methods": [],
            "line": 64
          },
          {
            "name": "GovernanceStateResult",
            "docstring": "Result of governance state query.",
            "methods": [
              "to_dict"
            ],
            "line": 72
          },
          {
            "name": "KillSwitchResult",
            "docstring": "Result of kill switch operation.",
            "methods": [
              "to_dict"
            ],
            "line": 94
          },
          {
            "name": "ConflictResolutionResult",
            "docstring": "Result of conflict resolution.",
            "methods": [
              "to_dict"
            ],
            "line": 118
          },
          {
            "name": "BootStatusResult",
            "docstring": "Result of boot status check.",
            "methods": [
              "to_dict"
            ],
            "line": 142
          },
          {
            "name": "GovernanceFacade",
            "docstring": "Facade for governance control operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ngovernance control services.\n\nLayer: L5 (Domain Engine)\nCallers: governance.py (L2), aos_sdk\n\nPIN-520: runtime_switch is now injected via L4 bridge instead of being\nimported directly from L4 authority.",
            "methods": [
              "__init__",
              "enable_kill_switch",
              "disable_kill_switch",
              "set_mode",
              "get_governance_state",
              "resolve_conflict",
              "list_conflicts",
              "get_boot_status"
            ],
            "line": 159
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "types",
            "names": [
              "ModuleType"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 59
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "grammar.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/grammar.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 216,
        "module_docstring": "PLang v2.0 Grammar (EBNF):\n\nprogram         ::= statement*\nstatement       ::= policy_decl | rule_decl | import_stmt\npolicy_decl     ::= 'policy' IDENT ':' category '{' policy_body '}'\ncategory        ::= 'SAFETY' | 'PRIVACY' | 'OPERATIONAL' | 'ROUTING' | 'CUSTOM'\npolicy_body     ::= (rule_ref | condition_block | action_block)*\nrule_ref        ::= 'rule' IDENT\ncondition_block ::= 'when' expr 'then' action_block\naction_block    ::= 'deny' | 'allow' | 'escalate' | 'route' route_target\nroute_target    ::= 'to' IDENT\nexpr            ::= or_expr\nor_expr         ::= and_expr ('or' and_expr)*\nand_expr        ::= not_expr ('and' not_expr)*\nnot_expr        ::= 'not' not_expr | comparison\ncomparison      ::= value (comp_op value)?\ncomp_op         ::= '==' | '!=' | '<' | '>' | '<=' | '>='\nvalue           ::= IDENT | NUMBER | STRING | 'true' | 'false' | func_call | attr_access\nattr_access     ::= value '.' IDENT\nfunc_call       ::= IDENT '(' args? ')'\nargs            ::= expr (',' expr)*\nrule_decl       ::= 'rule' IDENT ':' category '{' rule_body '}'\nrule_body       ::= (priority_decl | condition_block | action_block)*\npriority_decl   ::= 'priority' NUMBER\nimport_stmt     ::= 'import' STRING",
        "functions": [],
        "classes": [
          {
            "name": "GrammarNodeType",
            "docstring": "Grammar node types for PLang v2.0.",
            "methods": [],
            "line": 55
          },
          {
            "name": "PolicyCategory",
            "docstring": "M19 Policy Categories.",
            "methods": [],
            "line": 86
          },
          {
            "name": "ActionType",
            "docstring": "Policy action types.",
            "methods": [],
            "line": 96
          },
          {
            "name": "GrammarProduction",
            "docstring": "A production rule in the grammar.",
            "methods": [],
            "line": 108
          },
          {
            "name": "PLangGrammar",
            "docstring": "PLang v2.0 Grammar Definition.",
            "methods": [
              "get_category_priority",
              "get_action_precedence",
              "is_keyword",
              "is_operator",
              "is_category",
              "is_action"
            ],
            "line": 118
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "List",
              "Set"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [
          {
            "name": "PLANG_GRAMMAR",
            "line": 216
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "intent.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/intent.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 405,
        "module_docstring": "Intent system for PLang v2.0 runtime.\n\nIntents are the bridge between policy decisions and M18 execution:\n- Policy compiler emits intents based on actions\n- M18 executes intents with governance constraints\n- M19 validates intents before execution\n\nIntent types:\n- ROUTE: Route to specific agent\n- ESCALATE: Escalate to higher authority\n- EXECUTE: Execute with constraints\n- DENY: Block execution with reason\n- ALLOW: Permit execution",
        "functions": [],
        "classes": [
          {
            "name": "IntentType",
            "docstring": "Types of intents emitted by policy runtime.",
            "methods": [],
            "line": 60
          },
          {
            "name": "IntentPayload",
            "docstring": "Payload data for an intent.\n\nContains all data needed for M18 to execute the intent.",
            "methods": [
              "to_dict",
              "from_dict"
            ],
            "line": 73
          },
          {
            "name": "Intent",
            "docstring": "An intent emitted by the policy runtime.\n\nRepresents a governance-validated action to be executed by M18.",
            "methods": [
              "__post_init__",
              "_generate_id",
              "to_dict",
              "from_dict"
            ],
            "line": 133
          },
          {
            "name": "IntentEmitter",
            "docstring": "Emits intents from policy runtime to M18.\n\nHandles:\n- Intent creation\n- M19 validation\n- M18 delivery\n- Audit logging",
            "methods": [
              "__init__",
              "create_intent",
              "validate_intent",
              "emit",
              "emit_all",
              "register_handler",
              "get_pending",
              "get_emitted",
              "clear"
            ],
            "line": 214
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Awaitable",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.hoc.cus.policies.L5_schemas.intent_validation",
            "names": [
              "PolicyIntentValidationResult",
              "PolicyIntentValidator"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [
          {
            "name": "_ENFORCEMENT_INTENT_TYPES",
            "line": 53
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "interpreter.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/interpreter.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 562,
        "module_docstring": "Policy DSL Interpreter\n\nPure evaluation of compiled IR against runtime facts.\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- PURE: No side effects, no I/O, no DB, no network\n- NO CONTEXT: No tenants, actors, permissions, time\n- DESCRIPTIVE OUTPUT: Returns what is true, not what to do\n- STACK-BASED: Explicit stack for condition evaluation\n- NO COERCION: Type mismatches raise errors\n\nINPUT:\n- PolicyIR: Compiled intermediate representation\n- Facts: dict[str, value] - runtime metric values\n\nOUTPUT:\n- EvaluationResult: Describes which clauses matched and what actions apply\n\nGOVERNANCE:\n- Interpreter output defines policy truth\n- IR compiler and future JIT must conform to this\n- Replay uses interpreter, always",
        "functions": [
          {
            "name": "evaluate",
            "signature": "(ir: PolicyIR, facts: dict[str, Any]) -> EvaluationResult",
            "docstring": "Evaluate policy IR against facts.\n\nThis is the CANONICAL evaluation function.\nAll other evaluation paths (JIT, cached, etc.) must produce\nidentical results.\n\nArgs:\n    ir: Compiled PolicyIR\n    facts: dict mapping metric names to values\n\nReturns:\n    EvaluationResult describing what matched\n\nRaises:\n    EvaluationError: On runtime errors\n\nExample:\n    >>> from app.dsl import parse, validate, compile_policy\n    >>> ast = parse('''\n    ... policy CostGuard\n    ... version 1\n    ... scope PROJECT\n    ... mode MONITOR\n    ...\n    ... when cost > 100\n    ... then WARN \"High cost\"\n    ... ''')\n    >>> ir = compile_policy(ast)\n    >>> result = evaluate(ir, {\"cost\": 150})\n    >>> result.any_matched\n    True\n    >>> result.all_actions[0].type\n    'WARN'",
            "is_async": false,
            "line": 447
          },
          {
            "name": "evaluate_policy",
            "signature": "(ir: PolicyIR, facts: dict[str, Any], strict: bool = True) -> EvaluationResult",
            "docstring": "Evaluate policy with optional strict mode.\n\nArgs:\n    ir: Compiled PolicyIR\n    facts: dict mapping metric names to values\n    strict: If True, missing metrics raise error.\n            If False, missing metrics treated as not-exists.\n\nReturns:\n    EvaluationResult describing what matched\n\nNote: strict=False is useful for partial evaluation,\n      but strict=True is required for audit-grade evaluation.",
            "is_async": false,
            "line": 490
          }
        ],
        "classes": [
          {
            "name": "EvaluationError",
            "docstring": "Raised when evaluation fails.\n\nThis is NOT a policy violation - it's a runtime error\n(e.g., type mismatch, missing required metric).",
            "methods": [
              "__init__"
            ],
            "line": 62
          },
          {
            "name": "TypeMismatchError",
            "docstring": "Raised when types are incompatible for comparison.",
            "methods": [],
            "line": 79
          },
          {
            "name": "MissingMetricError",
            "docstring": "Raised when a required metric is not in facts.",
            "methods": [],
            "line": 85
          },
          {
            "name": "ActionResult",
            "docstring": "A single action from evaluation.\n\nThis is DESCRIPTIVE - it says what action applies,\nnot what to do about it.",
            "methods": [
              "to_dict"
            ],
            "line": 97
          },
          {
            "name": "ClauseResult",
            "docstring": "Evaluation result for a single clause.\n\nDESCRIPTIVE: Says whether the clause matched and what actions apply.",
            "methods": [
              "to_dict"
            ],
            "line": 116
          },
          {
            "name": "EvaluationResult",
            "docstring": "Complete evaluation result for a policy.\n\nDESCRIPTIVE OUTPUT:\n- any_matched: Did any clause match?\n- clauses: Per-clause results\n- all_actions: Aggregated actions from all matching clauses\n\nThis tells you WHAT IS TRUE, not what to do about it.",
            "methods": [
              "to_dict",
              "has_block",
              "has_require_approval",
              "warnings"
            ],
            "line": 134
          },
          {
            "name": "Interpreter",
            "docstring": "Pure interpreter for Policy IR.\n\nPURITY GUARANTEE:\n- No side effects\n- No access to DB, time, network, globals\n- No knowledge of tenants, actors, permissions\n\nInput = IR + facts\nOutput = EvaluationResult",
            "methods": [
              "__init__",
              "evaluate",
              "_evaluate_clause",
              "_evaluate_condition",
              "_execute_instruction",
              "_compare",
              "_types_compatible",
              "_collect_actions"
            ],
            "line": 178
          },
          {
            "name": "_LenientInterpreter",
            "docstring": "Lenient interpreter that treats missing metrics as non-matching.\n\nNOT for audit-grade evaluation - only for previews/simulation.",
            "methods": [
              "_execute_instruction",
              "_compare"
            ],
            "line": 519
          },
          {
            "name": "_MissingSentinel",
            "docstring": "Sentinel value for missing metrics.",
            "methods": [],
            "line": 556
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.dsl.ir_compiler",
            "names": [
              "CompiledClause",
              "Instruction",
              "OpCode",
              "PolicyIR"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [
          {
            "name": "_MISSING_SENTINEL",
            "line": 562
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "ir_builder.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/ir_builder.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 408,
        "module_docstring": "IR Builder for PLang v2.0.\n\nTransforms AST nodes into IR with:\n- M19 category propagation\n- Symbol table population\n- Basic block construction\n- Governance metadata attachment",
        "functions": [],
        "classes": [
          {
            "name": "IRBuilder",
            "docstring": "Builds IR from PLang AST.\n\nTransforms AST into IR with governance metadata propagation.",
            "methods": [
              "__init__",
              "build",
              "_next_id",
              "_next_block_name",
              "_emit",
              "_new_block",
              "visit_program",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_import",
              "visit_rule_ref",
              "visit_priority",
              "visit_condition_block",
              "visit_action_block",
              "visit_route_target",
              "visit_binary_op",
              "visit_unary_op",
              "visit_ident",
              "visit_literal",
              "visit_func_call",
              "visit_attr_access"
            ],
            "line": 78
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.policy.ast.nodes",
            "names": [
              "ActionBlockNode",
              "AttrAccessNode",
              "BinaryOpNode",
              "ConditionBlockNode",
              "FuncCallNode",
              "IdentNode",
              "ImportNode",
              "LiteralNode",
              "PolicyDeclNode",
              "PriorityNode",
              "ProgramNode",
              "RouteTargetNode",
              "RuleDeclNode",
              "RuleRefNode",
              "UnaryOpNode"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.policy.ast.visitors",
            "names": [
              "BaseVisitor"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRAction",
              "IRBinaryOp",
              "IRBlock",
              "IRCall",
              "IRCompare",
              "IREmitIntent",
              "IRFunction",
              "IRGovernance",
              "IRInstruction",
              "IRJump",
              "IRJumpIf",
              "IRLoadConst",
              "IRLoadVar",
              "IRModule",
              "IRReturn",
              "IRType",
              "IRUnaryOp"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.policy.ir.symbol_table",
            "names": [
              "Symbol",
              "SymbolTable",
              "SymbolType"
            ],
            "is_relative": false,
            "line": 71
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "ir_compiler.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/ir_compiler.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 460,
        "module_docstring": "Policy DSL Intermediate Representation (IR) Compiler\n\nCompiles validated AST into deterministic bytecode for the interpreter.\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- CLOSED instruction set (exactly 10 opcodes)\n- Deterministic: Same AST \u2192 Same IR \u2192 Same hash\n- No evaluation logic (pure compilation)\n- No jumps, labels, or control flow\n- IR structure is hashable for audit identity\n\nINSTRUCTION SET (CLOSED - NO ADDITIONS):\n    LOAD_METRIC     - Load metric value onto stack\n    LOAD_CONST      - Load constant value onto stack\n    COMPARE         - Compare two values (metric CMP const)\n    EXISTS          - Check if metric exists\n    AND             - Logical AND of two booleans\n    OR              - Logical OR of two booleans\n    EMIT_WARN       - Emit warning action\n    EMIT_BLOCK      - Emit block action\n    EMIT_REQUIRE_APPROVAL - Emit require approval action\n    END             - End of clause/program\n\nSAFE OPTIMIZATIONS (ALLOWED):\n- Constant folding (evaluate known constants)\n- Dead action elimination (unreachable code)\n- Metric de-duplication (load once, reference many)\n\nFORBIDDEN OPTIMIZATIONS:\n- Short-circuit evaluation\n- Any semantic changes\n- Execution logic\n\nGOVERNANCE:\n- IR is the audit identity of a policy\n- Replay uses IR, not DSL text",
        "functions": [
          {
            "name": "compile_policy",
            "signature": "(ast: PolicyAST, optimize: bool = False) -> PolicyIR",
            "docstring": "Compile PolicyAST to PolicyIR.\n\nArgs:\n    ast: Validated PolicyAST\n    optimize: Enable safe optimizations (default False for max determinism)\n\nReturns:\n    PolicyIR: Compiled intermediate representation\n\nExample:\n    >>> from app.dsl import parse, validate\n    >>> ast = parse('''\n    ... policy CostGuard\n    ... version 1\n    ... scope PROJECT\n    ... mode MONITOR\n    ...\n    ... when cost > 100\n    ... then WARN \"High cost\"\n    ... ''')\n    >>> result = validate(ast)\n    >>> assert result.is_valid\n    >>> ir = compile_policy(ast)\n    >>> ir.compute_hash()\n    'a1b2c3...'",
            "is_async": false,
            "line": 418
          },
          {
            "name": "ir_hash",
            "signature": "(ast: PolicyAST) -> str",
            "docstring": "Convenience function to get IR hash from AST.\n\nThis is the audit identity of the policy.",
            "is_async": false,
            "line": 453
          }
        ],
        "classes": [
          {
            "name": "OpCode",
            "docstring": "Closed instruction set for Policy IR.\n\nGUARANTEE: This enum will never grow beyond these 10 opcodes.\nAny new functionality requires a new IR version.",
            "methods": [],
            "line": 89
          },
          {
            "name": "Instruction",
            "docstring": "A single IR instruction.\n\nImmutable to ensure IR integrity after compilation.",
            "methods": [
              "to_dict"
            ],
            "line": 115
          },
          {
            "name": "CompiledClause",
            "docstring": "Compiled form of a single when-then clause.\n\nContains:\n- condition_ir: Instructions to evaluate the condition\n- action_ir: Instructions to emit actions (if condition true)",
            "methods": [
              "to_dict"
            ],
            "line": 134
          },
          {
            "name": "PolicyIR",
            "docstring": "Complete IR for a policy.\n\nGUARANTEE: Same AST \u2192 Same IR \u2192 Same hash",
            "methods": [
              "to_dict",
              "to_json",
              "compute_hash",
              "instruction_count"
            ],
            "line": 155
          },
          {
            "name": "IRCompiler",
            "docstring": "Compiles PolicyAST to PolicyIR.\n\nThe compiler is stateless - each compile() call is independent.",
            "methods": [
              "__init__",
              "compile",
              "_compile_clause",
              "_compile_condition",
              "_emit_condition",
              "_emit_predicate",
              "_emit_exists",
              "_emit_logical",
              "_compile_actions"
            ],
            "line": 209
          },
          {
            "name": "OptimizingIRCompiler",
            "docstring": "IR Compiler with safe optimizations.\n\nSAFE OPTIMIZATIONS:\n- Metric de-duplication: Track loaded metrics, reuse references\n- Constant folding: Pre-compute known constant operations\n\nFORBIDDEN:\n- Short-circuit evaluation\n- Dead code elimination that changes observable behavior\n- Any semantic modifications",
            "methods": [
              "__init__",
              "compile"
            ],
            "line": 388
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.dsl.ast",
            "names": [
              "Action",
              "Clause",
              "Condition",
              "ExistsPredicate",
              "LogicalCondition",
              "LogicalOperator",
              "PolicyAST",
              "Predicate",
              "is_block_action",
              "is_exists_predicate",
              "is_logical_condition",
              "is_predicate",
              "is_require_approval_action",
              "is_warn_action"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "ir_nodes.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/ir_nodes.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 404,
        "module_docstring": "IR nodes for PLang v2.0 compilation.\n\nIR design principles:\n- Category-aware: Every node carries governance metadata\n- SSA-like: Single assignment for optimization\n- Intent-oriented: Designed for M18 intent emission\n- Deterministic: Reproducible execution paths",
        "functions": [],
        "classes": [
          {
            "name": "IRType",
            "docstring": "IR value types.",
            "methods": [],
            "line": 40
          },
          {
            "name": "IRGovernance",
            "docstring": "Governance metadata for IR nodes.\n\nPropagated from AST through compilation to runtime.\nUsed by M19 policy engine for validation.",
            "methods": [
              "from_ast",
              "to_dict"
            ],
            "line": 55
          },
          {
            "name": "IRNode",
            "docstring": "Base class for all IR nodes.",
            "methods": [
              "__str__"
            ],
            "line": 95
          },
          {
            "name": "IRInstruction",
            "docstring": "Base class for IR instructions.",
            "methods": [],
            "line": 112
          },
          {
            "name": "IRLoadConst",
            "docstring": "Load constant value.",
            "methods": [
              "__str__"
            ],
            "line": 119
          },
          {
            "name": "IRLoadVar",
            "docstring": "Load variable value.",
            "methods": [
              "__str__"
            ],
            "line": 129
          },
          {
            "name": "IRStoreVar",
            "docstring": "Store value to variable.",
            "methods": [
              "__str__"
            ],
            "line": 139
          },
          {
            "name": "IRBinaryOp",
            "docstring": "Binary operation.",
            "methods": [
              "__str__"
            ],
            "line": 150
          },
          {
            "name": "IRUnaryOp",
            "docstring": "Unary operation.",
            "methods": [
              "__str__"
            ],
            "line": 162
          },
          {
            "name": "IRCompare",
            "docstring": "Comparison operation.",
            "methods": [
              "__str__"
            ],
            "line": 173
          },
          {
            "name": "IRJump",
            "docstring": "Unconditional jump.",
            "methods": [
              "__str__"
            ],
            "line": 186
          },
          {
            "name": "IRJumpIf",
            "docstring": "Conditional jump.",
            "methods": [
              "__str__"
            ],
            "line": 196
          },
          {
            "name": "IRCall",
            "docstring": "Function call.",
            "methods": [
              "__str__"
            ],
            "line": 208
          },
          {
            "name": "IRReturn",
            "docstring": "Return from function.",
            "methods": [
              "__str__"
            ],
            "line": 220
          },
          {
            "name": "IRAction",
            "docstring": "Policy action instruction.\n\nActions: deny, allow, escalate, route",
            "methods": [
              "__str__"
            ],
            "line": 232
          },
          {
            "name": "IRCheckPolicy",
            "docstring": "Check against M19 policy engine.\n\nEmits validation request to policy engine before action.",
            "methods": [
              "__str__"
            ],
            "line": 253
          },
          {
            "name": "IREmitIntent",
            "docstring": "Emit intent to M18 execution layer.\n\nIntents are executed by M18 with governance constraints.",
            "methods": [
              "__str__"
            ],
            "line": 270
          },
          {
            "name": "IRBlock",
            "docstring": "Basic block in IR.\n\nContains a sequence of instructions with single entry/exit.",
            "methods": [
              "add_instruction",
              "is_terminated",
              "__str__"
            ],
            "line": 298
          },
          {
            "name": "IRFunction",
            "docstring": "Function in IR.\n\nRepresents a policy or rule as a callable unit.",
            "methods": [
              "add_block",
              "get_block",
              "__str__"
            ],
            "line": 330
          },
          {
            "name": "IRModule",
            "docstring": "Module in IR.\n\nRepresents a complete compiled PLang program.",
            "methods": [
              "add_function",
              "get_function",
              "get_functions_by_category",
              "__str__"
            ],
            "line": 362
          }
        ],
        "imports": [
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "kernel.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/kernel.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 623,
        "module_docstring": "ExecutionKernel - PIN-337 Governance Enforcement Infrastructure\n\nThis is the MANDATORY choke point for all EXECUTE-power paths.\nAll execution must flow through this kernel.\n\nINVARIANTS:\n- Every EXECUTE path MUST call ExecutionKernel.invoke()\n- Kernel MUST NOT block execution in v1 (PERMISSIVE mode)\n- Kernel MUST emit ExecutionEnvelope for attribution\n- Kernel MUST record invocation metrics\n- Unknown capability_id = CI FAIL (compile-time), not runtime block\n\nThe kernel is PHYSICS, not POLICY.\nIf code doesn't call the kernel, it doesn't execute.",
        "functions": [
          {
            "name": "get_enforcement_mode",
            "signature": "(capability_id: str) -> EnforcementMode",
            "docstring": "Get enforcement mode for a capability.\n\nArgs:\n    capability_id: The capability ID (e.g., \"CAP-019\")\n\nReturns:\n    EnforcementMode for this capability (default: PERMISSIVE)",
            "is_async": false,
            "line": 75
          },
          {
            "name": "set_enforcement_mode",
            "signature": "(capability_id: str, mode: EnforcementMode) -> None",
            "docstring": "Set enforcement mode for a capability.\n\nThis is CONFIG-DRIVEN, not code-driven.\nUsed for gradual rollout of strictness.\n\nArgs:\n    capability_id: The capability ID\n    mode: The enforcement mode to set",
            "is_async": false,
            "line": 88
          }
        ],
        "classes": [
          {
            "name": "EnforcementMode",
            "docstring": "Enforcement mode for capability execution.\n\nPERMISSIVE: Log and allow (v1 default)\nSTRICT: Enforce authority and policy (v2+, opt-in per capability)",
            "methods": [],
            "line": 55
          },
          {
            "name": "InvocationContext",
            "docstring": "Context for an execution invocation.\n\nCaptures WHO is invoking, WHAT they're invoking, and WHERE from.",
            "methods": [],
            "line": 115
          },
          {
            "name": "ExecutionResult",
            "docstring": "Result of an execution through the kernel.\n\nWraps the actual result with governance metadata.",
            "methods": [],
            "line": 149
          },
          {
            "name": "ExecutionKernel",
            "docstring": "Mandatory execution kernel - single choke point for all EXECUTE power.\n\nAll EXECUTE-power paths MUST route through this kernel:\n- HTTP handlers that mutate state\n- CLI commands that execute logic\n- SDK methods that trigger execution\n- Workers that process jobs\n- AUTO_EXECUTE recovery paths\n\nINVARIANTS:\n- v1: PERMISSIVE (log and allow, never block)\n- Envelope emission is ALWAYS on\n- Invocation recording is ALWAYS on\n- Strictness is capability-scoped, never global\n\nThe kernel is PHYSICS, not POLICY.",
            "methods": [
              "invoke",
              "invoke_async",
              "_emit_envelope",
              "_record_invocation_start",
              "_record_invocation_complete",
              "is_known_capability",
              "get_known_capabilities"
            ],
            "line": 182
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Optional",
              "TypeVar"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [
          {
            "name": "T",
            "line": 47
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "kill_switch.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/kill_switch.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 223,
        "module_docstring": "Kill Switch - Runtime Governance Bypass\n\nProvides emergency governance disable capability without restart.\nWhen active, all governance checks are bypassed (fail-open mode).\n\nUse cases:\n- Emergency maintenance\n- Security incident response\n- Governance system failures\n\nSecurity considerations:\n- Activation requires authenticated operator\n- All activations are logged\n- Automatic timeout for safety",
        "functions": [
          {
            "name": "activate_kill_switch",
            "signature": "(reason: str, activated_by: str, auto_expire_minutes: int = 60) -> KillSwitchActivation",
            "docstring": "Activate the runtime kill switch.\n\nWhen active, governance checks are bypassed (fail-open).\n\nArgs:\n    reason: Why the kill switch is being activated\n    activated_by: Identifier of operator activating\n    auto_expire_minutes: Auto-deactivate after this many minutes\n\nReturns:\n    KillSwitchActivation result",
            "is_async": false,
            "line": 90
          },
          {
            "name": "deactivate_kill_switch",
            "signature": "(deactivated_by: str = 'system') -> KillSwitchDeactivation",
            "docstring": "Deactivate the runtime kill switch.\n\nRestores normal governance enforcement.\n\nArgs:\n    deactivated_by: Identifier of operator deactivating\n\nReturns:\n    KillSwitchDeactivation result",
            "is_async": false,
            "line": 147
          },
          {
            "name": "is_kill_switch_active",
            "signature": "() -> bool",
            "docstring": "Check if kill switch is currently active.\n\nAlso handles auto-expiration.\n\nReturns:\n    True if governance should be bypassed",
            "is_async": false,
            "line": 186
          },
          {
            "name": "should_bypass_governance",
            "signature": "() -> bool",
            "docstring": "Check if governance should be bypassed.\n\nAlias for is_kill_switch_active() for clearer intent.\n\nReturns:\n    True if governance checks should be skipped",
            "is_async": false,
            "line": 214
          }
        ],
        "classes": [
          {
            "name": "KillSwitchStatus",
            "docstring": "Current status of the kill switch.",
            "methods": [
              "get_current"
            ],
            "line": 52
          },
          {
            "name": "KillSwitchActivation",
            "docstring": "Result of kill switch activation.",
            "methods": [],
            "line": 72
          },
          {
            "name": "KillSwitchDeactivation",
            "docstring": "Result of kill switch deactivation.",
            "methods": [],
            "line": 82
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "threading",
            "names": [
              "Lock"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lessons_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/lessons_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 1082,
        "module_docstring": "Lessons Learned Engine (L4 Domain Logic)\n\nThis engine implements the learning-driven governance pattern:\n- Failures (all severities) \u2192 Lesson created\n- Near-threshold events \u2192 Lesson created\n- Critical success events \u2192 Lesson created\n\nLessons are the memory substrate for policy evolution.\nOnly human action (via PolicyProposalEngine) converts lessons to drafts.\n\nReference: PIN-411, POLICIES_DOMAIN_AUDIT.md Section 11",
        "functions": [
          {
            "name": "is_valid_transition",
            "signature": "(from_status: str, to_status: str) -> bool",
            "docstring": "Check if a state transition is valid.",
            "is_async": false,
            "line": 116
          },
          {
            "name": "get_threshold_band",
            "signature": "(utilization: float) -> str",
            "docstring": "Get the threshold band for a utilization percentage.",
            "is_async": false,
            "line": 150
          },
          {
            "name": "get_lessons_learned_engine",
            "signature": "(driver: Any = None) -> LessonsLearnedEngine",
            "docstring": "Get a LessonsLearnedEngine instance.\n\nPIN-508 Phase 2A: When driver (LessonsQueryCapability) is provided,\nreturns a new engine with that capability injected.\nWhen no driver, returns singleton with lazy initialization.",
            "is_async": false,
            "line": 1070
          }
        ],
        "classes": [
          {
            "name": "LessonsLearnedEngine",
            "docstring": "L4 Domain Engine for lesson creation and management.\n\nThis engine implements the learning-driven governance pattern:\n- Detect learning opportunities from system events\n- Create lesson records (memory substrate)\n- Support human-driven conversion to draft proposals\n\nSDSR Contract (PIN-370):\n- This engine is called when events occur\n- It creates lesson records automatically\n- Lessons are NEVER created by scenarios directly\n- If lessons don't appear for events, THIS ENGINE is broken\n\nCallers:\n- IncidentEngine (on failures)\n- Worker runtime (on near-threshold, success)\n- API endpoints (for queries)",
            "methods": [
              "__init__",
              "_get_driver",
              "detect_lesson_from_failure",
              "detect_lesson_from_near_threshold",
              "detect_lesson_from_critical_success",
              "emit_near_threshold",
              "emit_critical_success",
              "list_lessons",
              "get_lesson",
              "convert_lesson_to_draft",
              "defer_lesson",
              "dismiss_lesson",
              "get_lesson_stats",
              "reactivate_deferred_lesson",
              "_is_debounced",
              "_create_lesson",
              "_generate_failure_description",
              "_generate_failure_proposed_action",
              "get_expired_deferred_lessons",
              "reactivate_expired_deferred_lessons"
            ],
            "line": 159
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "uuid",
            "names": [
              "UUID",
              "uuid4"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "prometheus_client",
            "names": [
              "Counter"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [
          {
            "name": "LESSONS_CREATION_FAILED",
            "line": 77
          },
          {
            "name": "LESSON_TYPE_FAILURE",
            "line": 88
          },
          {
            "name": "LESSON_TYPE_NEAR_THRESHOLD",
            "line": 89
          },
          {
            "name": "LESSON_TYPE_CRITICAL_SUCCESS",
            "line": 90
          },
          {
            "name": "LESSON_STATUS_PENDING",
            "line": 92
          },
          {
            "name": "LESSON_STATUS_CONVERTED",
            "line": 93
          },
          {
            "name": "LESSON_STATUS_DEFERRED",
            "line": 94
          },
          {
            "name": "LESSON_STATUS_DISMISSED",
            "line": 95
          },
          {
            "name": "SEVERITY_CRITICAL",
            "line": 124
          },
          {
            "name": "SEVERITY_HIGH",
            "line": 125
          },
          {
            "name": "SEVERITY_MEDIUM",
            "line": 126
          },
          {
            "name": "SEVERITY_LOW",
            "line": 127
          },
          {
            "name": "SEVERITY_NONE",
            "line": 128
          },
          {
            "name": "NEAR_THRESHOLD_PERCENT",
            "line": 138
          },
          {
            "name": "DEBOUNCE_WINDOW_HOURS",
            "line": 139
          },
          {
            "name": "THRESHOLD_BANDS",
            "line": 143
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "limits.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/limits.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 157,
        "module_docstring": "Phase-6 Limits \u2014 Derived from Plan (Not Stored)\n\nPIN-399 Phase-6: Limits are derived from plan at runtime, never hand-edited.\n\nDESIGN INVARIANTS (LOCKED):\n- BILLING-002: Limits are derived, not stored\n\nENFORCEMENT SEMANTICS:\n- Limits are evaluated at runtime\n- Limits are enforced after onboarding COMPLETE\n- Limits may emit warnings before enforcement\n\nWHAT LIMITS CAN DO:\n- Throttle\n- Reject with explicit error\n- Emit usage warnings\n\nWHAT LIMITS MUST NOT DO:\n- Mutate onboarding state\n- Revoke API keys silently\n- Affect auth or roles",
        "functions": [
          {
            "name": "derive_limits",
            "signature": "(limits_profile: str) -> Limits",
            "docstring": "Derive limits from a limits profile key.\n\nINVARIANT: This is the single source of limit derivation.\n\nArgs:\n    limits_profile: Profile key from Plan.limits_profile\n\nReturns:\n    Limits instance (immutable)",
            "is_async": false,
            "line": 137
          }
        ],
        "classes": [
          {
            "name": "Limits",
            "docstring": "Phase-6 Limits Model (Immutable, Derived).\n\nLimits are computed from a plan's limits_profile.\nNEVER stored directly in database.\n\nAttributes:\n    max_requests_per_day: Maximum API requests per day\n    max_active_agents: Maximum concurrent agents\n    max_storage_mb: Maximum storage in megabytes\n    max_monthly_cost_usd: Maximum monthly compute cost (soft limit)\n    max_runs_per_day: Maximum run executions per day\n    max_policies: Maximum policy rules\n\nINVARIANTS:\n- All limits are optional (None = unlimited)\n- Limits are derived from limits_profile at runtime\n- Limits are never directly persisted",
            "methods": [
              "is_unlimited"
            ],
            "line": 49
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_LIMITS",
            "line": 127
          }
        ],
        "all_exports": [
          "Limits",
          "derive_limits",
          "LIMITS_PROFILES",
          "DEFAULT_LIMITS"
        ]
      },
      {
        "file_name": "limits_facade.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/limits_facade.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 459,
        "module_docstring": "Limits Facade (L4 Domain Logic)\n\nThis facade provides the external interface for limit operations.\nAll limit APIs MUST use this facade instead of directly importing\ninternal limit modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes rate limit and quota logic\n- Provides unified access to usage tracking\n- Single point for audit emission\n\nL2 API Routes (GAP-122):\n- GET /api/v1/limits (list limits)\n- GET /api/v1/limits/{id} (get limit)\n- PUT /api/v1/limits/{id} (update limit)\n- GET /api/v1/limits/usage (current usage)\n- POST /api/v1/limits/check (check limit)\n- POST /api/v1/limits/reset (reset usage)\n\nUsage:\n    from app.hoc.cus.policies.L5_engines.limits_facade import get_limits_facade\n\n    facade = get_limits_facade()\n\n    # Check a limit\n    result = await facade.check_limit(\n        tenant_id=\"...\",\n        limit_type=\"api_calls\",\n    )",
        "functions": [
          {
            "name": "get_limits_facade",
            "signature": "() -> LimitsFacade",
            "docstring": "Get the limits facade instance.\n\nThis is the recommended way to access limit operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    LimitsFacade instance",
            "is_async": false,
            "line": 446
          }
        ],
        "classes": [
          {
            "name": "LimitType",
            "docstring": "Types of limits.",
            "methods": [],
            "line": 63
          },
          {
            "name": "LimitPeriod",
            "docstring": "Limit period.",
            "methods": [],
            "line": 73
          },
          {
            "name": "LimitConfig",
            "docstring": "Limit configuration.",
            "methods": [
              "to_dict"
            ],
            "line": 82
          },
          {
            "name": "LimitCheckResult",
            "docstring": "Result of checking a limit.",
            "methods": [
              "to_dict"
            ],
            "line": 118
          },
          {
            "name": "UsageSummary",
            "docstring": "Usage summary across all limits.",
            "methods": [
              "to_dict"
            ],
            "line": 142
          },
          {
            "name": "LimitsFacade",
            "docstring": "Facade for limit operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nlimit services.\n\nLayer: L4 (Domain Logic)\nCallers: limits.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "_get_or_create_limit",
              "list_limits",
              "get_limit",
              "update_limit",
              "check_limit",
              "get_usage",
              "reset_limit"
            ],
            "line": 161
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "nodes.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/nodes.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 379,
        "module_docstring": "AST nodes for PLang v2.0.\n\nEach node includes:\n- Source location (line, column)\n- Governance metadata where applicable\n- Type-safe structure for analysis",
        "functions": [],
        "classes": [
          {
            "name": "GovernanceMetadata",
            "docstring": "M19 Governance metadata attached to AST nodes.\n\nThis metadata is carried through compilation to runtime\nfor governance-aware execution.",
            "methods": [
              "merge_with"
            ],
            "line": 39
          },
          {
            "name": "ASTNode",
            "docstring": "Base class for all AST nodes.",
            "methods": [
              "accept",
              "location"
            ],
            "line": 70
          },
          {
            "name": "ExprNode",
            "docstring": "Base class for expression nodes.",
            "methods": [],
            "line": 89
          },
          {
            "name": "ProgramNode",
            "docstring": "Root node representing a complete PLang program.",
            "methods": [
              "accept"
            ],
            "line": 101
          },
          {
            "name": "PolicyDeclNode",
            "docstring": "Policy declaration node.",
            "methods": [
              "__post_init__",
              "accept"
            ],
            "line": 111
          },
          {
            "name": "RuleDeclNode",
            "docstring": "Rule declaration node.",
            "methods": [
              "__post_init__",
              "accept"
            ],
            "line": 133
          },
          {
            "name": "ImportNode",
            "docstring": "Import statement node.",
            "methods": [
              "accept"
            ],
            "line": 154
          },
          {
            "name": "RuleRefNode",
            "docstring": "Reference to a named rule.",
            "methods": [
              "accept"
            ],
            "line": 164
          },
          {
            "name": "PriorityNode",
            "docstring": "Priority declaration node.",
            "methods": [
              "accept"
            ],
            "line": 174
          },
          {
            "name": "ConditionBlockNode",
            "docstring": "When/then condition block.",
            "methods": [
              "accept"
            ],
            "line": 189
          },
          {
            "name": "ActionBlockNode",
            "docstring": "Action block (deny, allow, escalate, route).",
            "methods": [
              "accept"
            ],
            "line": 200
          },
          {
            "name": "RouteTargetNode",
            "docstring": "Route target specification.",
            "methods": [
              "accept"
            ],
            "line": 211
          },
          {
            "name": "BinaryOpNode",
            "docstring": "Binary operation (and, or, ==, !=, etc.).",
            "methods": [
              "accept"
            ],
            "line": 226
          },
          {
            "name": "UnaryOpNode",
            "docstring": "Unary operation (not).",
            "methods": [
              "accept"
            ],
            "line": 238
          },
          {
            "name": "ValueNode",
            "docstring": "Base class for value nodes.",
            "methods": [],
            "line": 249
          },
          {
            "name": "IdentNode",
            "docstring": "Identifier node.",
            "methods": [
              "accept"
            ],
            "line": 256
          },
          {
            "name": "LiteralNode",
            "docstring": "Literal value node (number, string, boolean).",
            "methods": [
              "accept"
            ],
            "line": 266
          },
          {
            "name": "FuncCallNode",
            "docstring": "Function call node.",
            "methods": [
              "accept"
            ],
            "line": 276
          },
          {
            "name": "AttrAccessNode",
            "docstring": "Attribute access node (obj.attr).",
            "methods": [
              "accept"
            ],
            "line": 287
          },
          {
            "name": "ASTVisitor",
            "docstring": "Abstract base class for AST visitors.\n\nConcrete implementations must define all visit_* methods.\nThis enables the visitor pattern for AST traversal.",
            "methods": [
              "visit_program",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_import",
              "visit_rule_ref",
              "visit_priority",
              "visit_condition_block",
              "visit_action_block",
              "visit_route_target",
              "visit_binary_op",
              "visit_unary_op",
              "visit_ident",
              "visit_literal",
              "visit_func_call",
              "visit_attr_access"
            ],
            "line": 298
          }
        ],
        "imports": [
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "phase_status_invariants.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/phase_status_invariants.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 360,
        "module_docstring": "Module: phase_status_invariants\nPurpose: Enforce phase-status invariants using GovernanceConfig.\n\nThe phase_status_invariant_enforce flag in GovernanceConfig controls\nwhether invalid phase-status combinations are blocked.\n\nPhase-Status Invariants:\n    - CREATED, AUTHORIZED: status must be \"queued\"\n    - EXECUTING, GOVERNANCE_CHECK, FINALIZING: status must be \"running\"\n    - COMPLETED: status must be \"succeeded\"\n    - FAILED: status must be \"failed\", \"failed_policy\", \"cancelled\", or \"retry\"\n\nWhen enforcement is enabled, attempting an invalid combination raises\nPhaseStatusInvariantEnforcementError.\n\nExports:\n    - PhaseStatusInvariantEnforcementError: Raised on violation\n    - PhaseStatusInvariantChecker: Main checker class\n    - check_phase_status_invariant: Quick helper function",
        "functions": [
          {
            "name": "check_phase_status_invariant",
            "signature": "(phase: str, status: str, enforcement_enabled: bool = True) -> InvariantCheckResponse",
            "docstring": "Quick helper to check a phase-status invariant.\n\nArgs:\n    phase: Phase name\n    status: Status value\n    enforcement_enabled: Whether enforcement is enabled\n\nReturns:\n    InvariantCheckResponse with validation result",
            "is_async": false,
            "line": 323
          },
          {
            "name": "ensure_phase_status_invariant",
            "signature": "(phase: str, status: str, enforcement_enabled: bool = True) -> None",
            "docstring": "Quick helper to ensure phase-status invariant or raise error.\n\nArgs:\n    phase: Phase name\n    status: Status value\n    enforcement_enabled: Whether enforcement is enabled\n\nRaises:\n    PhaseStatusInvariantEnforcementError: If invalid and enforcement enabled",
            "is_async": false,
            "line": 343
          }
        ],
        "classes": [
          {
            "name": "InvariantCheckResult",
            "docstring": "Result of an invariant check.",
            "methods": [],
            "line": 46
          },
          {
            "name": "PhaseStatusInvariantEnforcementError",
            "docstring": "Raised when phase-status invariant enforcement fails.\n\nThis error indicates that an invalid phase-status combination\nwas attempted when enforcement is enabled.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 67
          },
          {
            "name": "InvariantCheckResponse",
            "docstring": "Response from an invariant check.",
            "methods": [
              "to_dict"
            ],
            "line": 102
          },
          {
            "name": "PhaseStatusInvariantChecker",
            "docstring": "Checks and enforces phase-status invariants.\n\nGAP-051: Add invariant checks to ROK.\n\nThe checker validates that phase-status combinations are valid\nand can raise errors when enforcement is enabled.\n\nUsage:\n    checker = PhaseStatusInvariantChecker(enforcement_enabled=True)\n\n    # Before a phase transition\n    checker.ensure_valid(\"EXECUTING\", \"running\")\n\n    # Or check without raising\n    response = checker.check(\"EXECUTING\", \"running\")\n    if not response.is_valid and response.enforcement_enabled:\n        handle_invariant_violation()",
            "methods": [
              "__init__",
              "from_governance_config",
              "enforcement_enabled",
              "get_allowed_statuses",
              "is_valid_combination",
              "check",
              "ensure_valid",
              "should_allow_transition"
            ],
            "line": 126
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "FrozenSet",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "plan.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/plan.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 145,
        "module_docstring": "Phase-6 Plan Model \u2014 Named Contracts (Not Pricing Logic)\n\nPIN-399 Phase-6: Plans are named contracts, not pricing logic.\n\nEXPLICIT NON-GOALS:\n- No prices\n- No currency\n- No billing cycle assumptions\n- No gateway IDs\n- No subscriptions\n- No coupons / proration / invoices\n- No taxes\n\nThose come in future phases, if ever.\n\nThis module defines the abstract Plan model used for limit derivation.",
        "functions": [],
        "classes": [
          {
            "name": "PlanTier",
            "docstring": "Plan tier hierarchy.\n\nTiers represent capability levels, not prices.",
            "methods": [
              "from_string"
            ],
            "line": 44
          },
          {
            "name": "Plan",
            "docstring": "Phase-6 Plan Model (Immutable).\n\nPlans define what a tenant is entitled to, not what they pay.\n\nAttributes:\n    id: Unique plan identifier (e.g., \"free-v1\", \"pro-v1\")\n    name: Human-readable name (e.g., \"Free\", \"Pro\")\n    tier: Capability tier (FREE, PRO, ENTERPRISE)\n    limits_profile: Key for deriving limits (e.g., \"free\", \"pro\", \"enterprise\")\n    description: Optional human-readable description\n\nINVARIANTS:\n- Plans are immutable after creation\n- Plans do not contain pricing information\n- Plans do not reference gateway IDs\n- Limits are derived from limits_profile, not stored on the plan",
            "methods": [
              "__post_init__"
            ],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [
          {
            "name": "PLAN_FREE",
            "line": 110
          },
          {
            "name": "PLAN_PRO",
            "line": 118
          },
          {
            "name": "PLAN_ENTERPRISE",
            "line": 126
          },
          {
            "name": "DEFAULT_PLAN",
            "line": 135
          }
        ],
        "all_exports": [
          "PlanTier",
          "Plan",
          "PLAN_FREE",
          "PLAN_PRO",
          "PLAN_ENTERPRISE",
          "DEFAULT_PLAN"
        ]
      },
      {
        "file_name": "policies_facade.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policies_facade.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 1193,
        "module_docstring": "PoliciesFacade (L5)\n\nUnified facade for policy management operations.\n\nProvides:\n- Policy Rules: list, get detail (via L6 driver)\n- Limits: list, get detail (via L6 driver)\n- Lessons: list, get detail, stats (delegates to LessonsLearnedEngine)\n- Policy State: synthesized snapshot (mixed: driver + engine delegation)\n- Policy Metrics: enforcement effectiveness (delegates to PolicyEngine)\n- Policy Conflicts: detect contradictions (delegates to PolicyConflictEngine)\n- Policy Dependencies: structural relationships (delegates to PolicyDependencyEngine)\n- Policy Violations: unified violation view (delegates to PolicyEngine)\n- Budget Definitions: enforcement limits (via L6 driver)\n- Policy Requests: pending approvals (via L6 driver)\n\nAll operations are tenant-scoped for isolation.",
        "functions": [
          {
            "name": "get_policies_facade",
            "signature": "(driver: Optional[PoliciesFacadeDriver] = None) -> PoliciesFacade",
            "docstring": "Get the singleton PoliciesFacade instance.",
            "is_async": false,
            "line": 1149
          }
        ],
        "classes": [
          {
            "name": "PolicyRuleSummaryResult",
            "docstring": "Policy rule summary for list view (O2).",
            "methods": [],
            "line": 46
          },
          {
            "name": "PolicyRulesListResult",
            "docstring": "Policy rules list response.",
            "methods": [],
            "line": 64
          },
          {
            "name": "PolicyRuleDetailResult",
            "docstring": "Policy rule detail response (O3).",
            "methods": [],
            "line": 74
          },
          {
            "name": "LimitSummaryResult",
            "docstring": "Limit summary for list view (O2).",
            "methods": [],
            "line": 101
          },
          {
            "name": "LimitsListResult",
            "docstring": "Limits list response.",
            "methods": [],
            "line": 122
          },
          {
            "name": "LimitDetailResult",
            "docstring": "Limit detail response (O3).",
            "methods": [],
            "line": 132
          },
          {
            "name": "PolicyStateResult",
            "docstring": "Policy layer state summary (ACT-O4).",
            "methods": [],
            "line": 162
          },
          {
            "name": "PolicyMetricsResult",
            "docstring": "Policy enforcement metrics (ACT-O5).",
            "methods": [],
            "line": 175
          },
          {
            "name": "PolicyConflictResult",
            "docstring": "Policy conflict summary (DFT-O4).",
            "methods": [],
            "line": 194
          },
          {
            "name": "ConflictsListResult",
            "docstring": "Policy conflicts list response.",
            "methods": [],
            "line": 209
          },
          {
            "name": "PolicyDependencyRelation",
            "docstring": "A dependency relationship.",
            "methods": [],
            "line": 219
          },
          {
            "name": "PolicyNodeResult",
            "docstring": "A node in the dependency graph (DFT-O5).",
            "methods": [],
            "line": 229
          },
          {
            "name": "PolicyDependencyEdge",
            "docstring": "A dependency edge in the graph.",
            "methods": [],
            "line": 243
          },
          {
            "name": "DependencyGraphResult",
            "docstring": "Policy dependency graph response.",
            "methods": [],
            "line": 255
          },
          {
            "name": "PolicyViolationResult",
            "docstring": "Policy violation summary (VIO-O1).",
            "methods": [],
            "line": 271
          },
          {
            "name": "ViolationsListResult",
            "docstring": "Policy violations list response.",
            "methods": [],
            "line": 287
          },
          {
            "name": "BudgetDefinitionResult",
            "docstring": "Budget definition summary (THR-O2).",
            "methods": [],
            "line": 302
          },
          {
            "name": "BudgetsListResult",
            "docstring": "Budget definitions list response.",
            "methods": [],
            "line": 317
          },
          {
            "name": "PolicyRequestResult",
            "docstring": "Pending policy request summary (ACT-O3).",
            "methods": [],
            "line": 331
          },
          {
            "name": "PolicyRequestsListResult",
            "docstring": "Policy requests list response.",
            "methods": [],
            "line": 346
          },
          {
            "name": "LessonSummaryResult",
            "docstring": "Lesson summary for list view (O2).",
            "methods": [],
            "line": 361
          },
          {
            "name": "LessonsListResult",
            "docstring": "Lessons list response.",
            "methods": [],
            "line": 375
          },
          {
            "name": "LessonDetailResult",
            "docstring": "Lesson detail response (O3).",
            "methods": [],
            "line": 385
          },
          {
            "name": "LessonStatsResult",
            "docstring": "Lesson statistics response.",
            "methods": [],
            "line": 406
          },
          {
            "name": "PoliciesFacade",
            "docstring": "Unified facade for policy management.\n\nSQL operations delegate to PoliciesFacadeDriver (L6).\nDomain operations delegate to same-domain L5 engines.",
            "methods": [
              "__init__",
              "list_policy_rules",
              "get_policy_rule_detail",
              "list_limits",
              "get_limit_detail",
              "list_lessons",
              "get_lesson_detail",
              "get_lesson_stats",
              "get_policy_state",
              "get_policy_metrics",
              "list_policy_violations",
              "list_policy_conflicts",
              "get_policy_dependencies",
              "list_policy_requests",
              "list_budgets"
            ],
            "line": 419
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policies_facade_driver",
            "names": [
              "PoliciesFacadeDriver"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": [
          "PoliciesFacade",
          "get_policies_facade",
          "PolicyRuleSummaryResult",
          "PolicyRulesListResult",
          "PolicyRuleDetailResult",
          "LimitSummaryResult",
          "LimitsListResult",
          "LimitDetailResult",
          "PolicyStateResult",
          "PolicyMetricsResult",
          "PolicyConflictResult",
          "ConflictsListResult",
          "PolicyDependencyRelation",
          "PolicyNodeResult",
          "PolicyDependencyEdge",
          "DependencyGraphResult",
          "PolicyViolationResult",
          "ViolationsListResult",
          "BudgetDefinitionResult",
          "BudgetsListResult",
          "PolicyRequestResult",
          "PolicyRequestsListResult",
          "LessonSummaryResult",
          "LessonsListResult",
          "LessonDetailResult",
          "LessonStatsResult"
        ]
      },
      {
        "file_name": "policies_limits_query_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policies_limits_query_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 343,
        "module_docstring": "Limits Query Engine (L5)\n\nRead-only query operations for limits and budget definitions.\nProvides list, get detail, filtering, and budget queries.\n\nInvariant: This engine is READ-ONLY. No writes. No state mutation.",
        "functions": [
          {
            "name": "get_limits_query_engine",
            "signature": "(session: 'AsyncSession' = None) -> LimitsQueryEngine",
            "docstring": "Get a LimitsQueryEngine instance.\n\nPIN-508 Phase 2B: Prefer passing driver (LimitsQueryCapability) from DomainBridge.\nFalls back to lazy cross-domain import if no driver provided (legacy path).",
            "is_async": false,
            "line": 302
          }
        ],
        "classes": [
          {
            "name": "LimitSummaryResult",
            "docstring": "Limit summary for list view (O2).",
            "methods": [],
            "line": 43
          },
          {
            "name": "LimitsListResult",
            "docstring": "Limits list response.",
            "methods": [],
            "line": 64
          },
          {
            "name": "LimitDetailResult",
            "docstring": "Limit detail response (O3).",
            "methods": [],
            "line": 74
          },
          {
            "name": "BudgetDefinitionResult",
            "docstring": "Budget definition summary (THR-O2).",
            "methods": [],
            "line": 99
          },
          {
            "name": "BudgetsListResult",
            "docstring": "Budget definitions list response.",
            "methods": [],
            "line": 114
          },
          {
            "name": "LimitsQueryEngine",
            "docstring": "L5 Query Engine for limits.\n\nProvides read-only operations:\n- List limits with filters\n- Get limit detail\n- List budget definitions\n\nAll data access is delegated to L6 driver.",
            "methods": [
              "__init__",
              "list_limits",
              "get_limit_detail",
              "list_budgets"
            ],
            "line": 127
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": [
          "LimitsQueryEngine",
          "get_limits_query_engine",
          "LimitSummaryResult",
          "LimitsListResult",
          "LimitDetailResult",
          "BudgetDefinitionResult",
          "BudgetsListResult"
        ]
      },
      {
        "file_name": "policies_proposals_query_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policies_proposals_query_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 294,
        "module_docstring": "Proposals Query Engine (L5)\n\nRead-only query operations for policy proposals (list view).\nProvides list, get detail, and draft counts.\n\nNote: This engine is for the \"Proposals\" tab UI.\nFor proposal lifecycle operations (create, approve, reject),\nsee policy_proposal_engine.py.\n\nInvariant: This engine is READ-ONLY. No writes. No state mutation.",
        "functions": [
          {
            "name": "get_proposals_query_engine",
            "signature": "(session: 'AsyncSession') -> ProposalsQueryEngine",
            "docstring": "Get a ProposalsQueryEngine instance.",
            "is_async": false,
            "line": 279
          }
        ],
        "classes": [
          {
            "name": "PolicyRequestResult",
            "docstring": "Pending policy request summary (ACT-O3).",
            "methods": [],
            "line": 49
          },
          {
            "name": "PolicyRequestsListResult",
            "docstring": "Policy requests list response.",
            "methods": [],
            "line": 64
          },
          {
            "name": "PolicyRequestDetailResult",
            "docstring": "Policy request detail response.",
            "methods": [],
            "line": 74
          },
          {
            "name": "ProposalsQueryEngine",
            "docstring": "L5 Query Engine for policy proposals.\n\nProvides read-only operations:\n- List proposals with filters\n- Get proposal detail\n- Count draft proposals\n\nAll data access is delegated to L6 driver.",
            "methods": [
              "__init__",
              "list_policy_requests",
              "get_policy_request_detail",
              "count_drafts",
              "list_proposals_paginated",
              "get_proposal_stats",
              "get_proposal_detail",
              "list_proposal_versions"
            ],
            "line": 98
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.proposals_read_driver",
            "names": [
              "ProposalsReadDriver",
              "get_proposals_read_driver"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": [
          "ProposalsQueryEngine",
          "get_proposals_query_engine",
          "PolicyRequestResult",
          "PolicyRequestsListResult",
          "PolicyRequestDetailResult"
        ]
      },
      {
        "file_name": "policies_rules_query_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policies_rules_query_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 246,
        "module_docstring": "Policy Rules Query Engine (L5)\n\nRead-only query operations for policy rules.\nProvides list, get detail, filtering, and counts.\n\nInvariant: This engine is READ-ONLY. No writes. No state mutation.",
        "functions": [
          {
            "name": "get_policy_rules_query_engine",
            "signature": "(session: 'AsyncSession') -> PolicyRulesQueryEngine",
            "docstring": "Get a PolicyRulesQueryEngine instance.",
            "is_async": false,
            "line": 229
          }
        ],
        "classes": [
          {
            "name": "PolicyRuleSummaryResult",
            "docstring": "Policy rule summary for list view (O2).",
            "methods": [],
            "line": 46
          },
          {
            "name": "PolicyRulesListResult",
            "docstring": "Policy rules list response.",
            "methods": [],
            "line": 64
          },
          {
            "name": "PolicyRuleDetailResult",
            "docstring": "Policy rule detail response (O3).",
            "methods": [],
            "line": 74
          },
          {
            "name": "PolicyRulesQueryEngine",
            "docstring": "L5 Query Engine for policy rules.\n\nProvides read-only operations:\n- List rules with filters\n- Get rule detail\n- Count rules\n\nAll data access is delegated to L6 driver.",
            "methods": [
              "__init__",
              "list_policy_rules",
              "get_policy_rule_detail",
              "count_rules"
            ],
            "line": 100
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_rules_read_driver",
            "names": [
              "PolicyRulesReadDriver",
              "get_policy_rules_read_driver"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyRulesQueryEngine",
          "get_policy_rules_query_engine",
          "PolicyRuleSummaryResult",
          "PolicyRulesListResult",
          "PolicyRuleDetailResult"
        ]
      },
      {
        "file_name": "policy_command.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_command.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 480,
        "module_docstring": "Policy Command (L4)\n\nDomain command for policy evaluation and approval workflow. This L4 command:\n1. Owns all policy decisions (cost feasibility, violations, outcomes)\n2. Delegates to L5 for execution (metrics, simulation, enforcement)\n3. Returns result objects to L3 adapter\n\nThis command may import L5 (workflow.metrics, workflow.cost_sim, workflow.policies)\nbecause L4 \u2192 L5 is allowed per layer rules.\n\nReference: PIN-258 Phase F-3 Policy Cluster",
        "functions": [
          {
            "name": "simulate_cost",
            "signature": "(skill_id: str, tenant_id: str, payload: Dict[str, Any]) -> Optional[int]",
            "docstring": "Simulate cost for a skill execution.\n\nThis L4 command delegates to L5 CostSimulator.\nL4 \u2192 L5 is allowed per layer rules.\n\nArgs:\n    skill_id: Skill to simulate\n    tenant_id: Tenant context\n    payload: Execution payload\n\nReturns:\n    Estimated cost in cents, or fallback estimate\n\nReference: PIN-258 Phase F-3 (F-P-RULE-4: No Dual Ownership)",
            "is_async": true,
            "line": 90
          },
          {
            "name": "check_policy_violations",
            "signature": "(skill_id: str, tenant_id: str, agent_id: Optional[str], payload: Dict[str, Any], simulated_cost: Optional[int]) -> List[PolicyViolation]",
            "docstring": "Check for policy violations.\n\nThis L4 command delegates to L5 PolicyEnforcer.\nL4 \u2192 L5 is allowed per layer rules.\n\nArgs:\n    skill_id: Skill being evaluated\n    tenant_id: Tenant context\n    agent_id: Optional agent context\n    payload: Execution payload\n    simulated_cost: Cost estimate from simulation\n\nReturns:\n    List of policy violations found\n\nReference: PIN-258 Phase F-3 (F-P-RULE-1: Policy Decisions in L4)",
            "is_async": true,
            "line": 131
          },
          {
            "name": "evaluate_policy",
            "signature": "(skill_id: str, tenant_id: str, agent_id: Optional[str], payload: Dict[str, Any], auto_approve_max_cost_cents: int = 0, approval_level: int = 1) -> PolicyEvaluationResult",
            "docstring": "Evaluate policy for a skill execution.\n\nThis L4 command orchestrates:\n1. Cost simulation (via L5)\n2. Policy violation check (via L5)\n3. Decision determination\n4. Metrics emission (via L5)\n\nL4 \u2192 L5 is allowed per layer rules.\n\nArgs:\n    skill_id: Skill to evaluate\n    tenant_id: Tenant context\n    agent_id: Optional agent context\n    payload: Execution payload\n    auto_approve_max_cost_cents: Threshold for auto-approval\n    approval_level: Required approval level\n\nReturns:\n    PolicyEvaluationResult with decision and details\n\nReference: PIN-258 Phase F-3 (F-P-RULE-1: Policy Decisions in L4)",
            "is_async": true,
            "line": 230
          },
          {
            "name": "_record_policy_decision",
            "signature": "(decision: str, policy_type: str) -> None",
            "docstring": "Record policy decision metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 317
          },
          {
            "name": "_record_capability_violation",
            "signature": "(violation_type: str, skill_id: str, tenant_id: Optional[str] = None) -> None",
            "docstring": "Record capability violation metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 331
          },
          {
            "name": "_record_budget_rejection",
            "signature": "(resource_type: str, skill_id: str) -> None",
            "docstring": "Record budget rejection metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 345
          },
          {
            "name": "_record_approval_request_created",
            "signature": "(policy_type: str) -> None",
            "docstring": "Record approval request creation metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 359
          },
          {
            "name": "_record_approval_action",
            "signature": "(result: str) -> None",
            "docstring": "Record approval action metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 373
          },
          {
            "name": "_record_approval_escalation",
            "signature": "() -> None",
            "docstring": "Record approval escalation metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 387
          },
          {
            "name": "_record_webhook_fallback",
            "signature": "() -> None",
            "docstring": "Record webhook fallback metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 401
          },
          {
            "name": "record_approval_created",
            "signature": "(policy_type: str) -> None",
            "docstring": "Record that an approval request was created.\n\nThis is a public L4 command for L3 to call.\nDelegates metric emission to L5.",
            "is_async": false,
            "line": 420
          },
          {
            "name": "record_approval_outcome",
            "signature": "(result: str) -> None",
            "docstring": "Record approval outcome (approved/rejected/expired).\n\nThis is a public L4 command for L3 to call.\nDelegates metric emission to L5.",
            "is_async": false,
            "line": 430
          },
          {
            "name": "record_escalation",
            "signature": "() -> None",
            "docstring": "Record that an escalation occurred.\n\nThis is a public L4 command for L3 to call.\nDelegates metric emission to L5.",
            "is_async": false,
            "line": 440
          },
          {
            "name": "record_webhook_used",
            "signature": "() -> None",
            "docstring": "Record that webhook fallback was used.\n\nThis is a public L4 command for L3 to call.\nDelegates metric emission to L5.",
            "is_async": false,
            "line": 450
          }
        ],
        "classes": [
          {
            "name": "PolicyViolation",
            "docstring": "A policy violation detected during evaluation.",
            "methods": [],
            "line": 52
          },
          {
            "name": "PolicyEvaluationResult",
            "docstring": "Result from policy evaluation command.",
            "methods": [],
            "line": 62
          },
          {
            "name": "ApprovalConfig",
            "docstring": "Approval level configuration.",
            "methods": [],
            "line": 74
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyViolation",
          "PolicyEvaluationResult",
          "ApprovalConfig",
          "simulate_cost",
          "check_policy_violations",
          "evaluate_policy",
          "record_approval_created",
          "record_approval_outcome",
          "record_escalation",
          "record_webhook_used"
        ]
      },
      {
        "file_name": "policy_conflict_resolver.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_conflict_resolver.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 267,
        "module_docstring": "Module: conflict_resolver\nPurpose: Defines explicit rules for resolving policy conflicts.\n\nImplements INV-005: Policy Conflict Determinism (CONFLICT-DET-001)\n> When multiple policies apply to the same action, the most restrictive action wins.\n> If two policies have equal restrictiveness, the policy with the lowest policy_id wins\n> (deterministic tiebreaker).\n\nImports (Dependencies):\n    - None (standalone)\n\nExports (Provides):\n    - resolve_policy_conflict(actions: List[PolicyAction]) -> ResolvedAction\n    - ConflictResolutionStrategy: Enum\n    - PolicyConflictLog: Audit record of conflict resolution\n\nWiring Points:\n    - Called from: prevention_engine.py:evaluate_policies()\n    - Emits: PolicyConflictLog to audit ledger\n\nConflict Resolution Rules (INV-005):\n    1. Higher precedence wins (lower number = higher priority)\n    2. Within same precedence, more restrictive action wins\n    3. Action restrictiveness order: KILL > STOP > PAUSE > WARN > CONTINUE\n    4. If precedence and action are equal, lowest policy_id wins (deterministic tiebreaker)\n\nAcceptance Criteria:\n    - [x] AC-068-01: Single policy returns without conflict\n    - [x] AC-068-02: Multiple policies same action no conflict\n    - [x] AC-068-03: Precedence resolves conflict\n    - [x] AC-068-04: Severity resolves same-precedence\n    - [x] AC-068-05: Conflict logged to audit\n    - [x] AC-068-06: Wired to prevention_engine\n    - [x] AC-068-07: Deterministic tiebreaker (INV-005)",
        "functions": [
          {
            "name": "resolve_policy_conflict",
            "signature": "(actions: List[PolicyAction], strategy: ConflictResolutionStrategy = ConflictResolutionStrategy.PRECEDENCE_FIRST) -> ResolvedAction",
            "docstring": "Resolve conflict when multiple policies trigger.\n\nImplements INV-005: Policy Conflict Determinism\n\nResolution Algorithm:\n1. Sort by precedence (lower number = higher priority)\n2. Within same precedence, sort by action severity (higher = more restrictive)\n3. Within same precedence and severity, sort by policy_id (deterministic tiebreaker)\n4. Return the winning action\n\nArgs:\n    actions: List of triggered policy actions\n    strategy: Resolution strategy to use\n\nReturns:\n    ResolvedAction with winning policy and audit trail",
            "is_async": false,
            "line": 133
          },
          {
            "name": "create_conflict_log",
            "signature": "(run_id: str, resolved: ResolvedAction, strategy: ConflictResolutionStrategy) -> PolicyConflictLog",
            "docstring": "Create audit log entry for conflict resolution.\n\nArgs:\n    run_id: ID of the run being evaluated\n    resolved: Resolution result\n    strategy: Strategy used\n\nReturns:\n    PolicyConflictLog for audit trail",
            "is_async": false,
            "line": 217
          },
          {
            "name": "get_action_severity",
            "signature": "(action: str) -> int",
            "docstring": "Get the severity level for an action.\n\nArgs:\n    action: Action string (CONTINUE, WARN, PAUSE, STOP, KILL)\n\nReturns:\n    Severity level (0-4)",
            "is_async": false,
            "line": 243
          },
          {
            "name": "is_more_restrictive",
            "signature": "(action_a: str, action_b: str) -> bool",
            "docstring": "Check if action_a is more restrictive than action_b.\n\nArgs:\n    action_a: First action\n    action_b: Second action\n\nReturns:\n    True if action_a is more restrictive",
            "is_async": false,
            "line": 256
          }
        ],
        "classes": [
          {
            "name": "ActionSeverity",
            "docstring": "Action severity for conflict resolution. Higher = more restrictive.\n\nINV-005 Restrictiveness Order: KILL > STOP > PAUSE > WARN > CONTINUE",
            "methods": [],
            "line": 66
          },
          {
            "name": "ConflictResolutionStrategy",
            "docstring": "Resolution strategy for policy conflicts.",
            "methods": [],
            "line": 82
          },
          {
            "name": "PolicyAction",
            "docstring": "A triggered policy action.",
            "methods": [],
            "line": 90
          },
          {
            "name": "ResolvedAction",
            "docstring": "Result of conflict resolution.",
            "methods": [],
            "line": 100
          },
          {
            "name": "PolicyConflictLog",
            "docstring": "Audit log entry for conflict resolution.",
            "methods": [],
            "line": 110
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum",
              "IntEnum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [
          {
            "name": "ACTION_SEVERITY",
            "line": 121
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "policy_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_driver.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 424,
        "module_docstring": "Policy Domain Driver (INTERNAL)\n\nThis driver provides the internal interface for policy evaluation operations.\nUsed by policy_layer API, governance services, and worker runtime.\n\nFor CUSTOMER policy CRUD operations, use policies_facade.py instead.\n\nWhy Drivers (not Facades for internal use):\n- Facades are API projection layers (CUSTOMER-facing)\n- Drivers are orchestration layers (INTERNAL)\n- Clear separation prevents confusion\n- Import rules become enforceable\n\nUsage:\n    from app.hoc.cus.policies.L5_engines.policy_driver import get_policy_driver\n\n    driver = get_policy_driver()\n    result = await driver.evaluate(eval_request, db)",
        "functions": [
          {
            "name": "get_policy_driver",
            "signature": "(db_url: Optional[str] = None) -> PolicyDriver",
            "docstring": "Get the PolicyDriver singleton.\n\nThis is the recommended way to access policy evaluation from\ninternal code (policy_layer, governance services).\n\nFor CUSTOMER API CRUD operations, use get_policies_facade() instead.\n\nArgs:\n    db_url: Optional database URL override\n\nReturns:\n    PolicyDriver singleton instance",
            "is_async": false,
            "line": 393
          },
          {
            "name": "reset_policy_driver",
            "signature": "() -> None",
            "docstring": "Reset the driver singleton (for testing).",
            "is_async": false,
            "line": 414
          }
        ],
        "classes": [
          {
            "name": "PolicyDriver",
            "docstring": "Driver for Policy domain operations (INTERNAL).\n\nThis is the entry point for internal code (policy_layer, governance)\nto interact with policy evaluation services.\n\nCUSTOMER-facing CRUD code should use policies_facade.py instead.",
            "methods": [
              "__init__",
              "_engine",
              "policy_engine_driver",
              "evaluate",
              "pre_check",
              "get_state",
              "reload_policies",
              "get_violations",
              "get_violation",
              "acknowledge_violation",
              "get_risk_ceilings",
              "get_risk_ceiling",
              "update_risk_ceiling",
              "reset_risk_ceiling",
              "get_safety_rules",
              "update_safety_rule",
              "get_ethical_constraints",
              "get_active_cooldowns",
              "clear_cooldowns",
              "get_metrics",
              "get_policy_versions",
              "get_current_version",
              "create_policy_version",
              "rollback_to_version",
              "get_version_provenance",
              "activate_policy_version",
              "get_dependency_graph",
              "get_policy_conflicts",
              "resolve_conflict",
              "validate_dependency_dag",
              "add_dependency_with_dag_check",
              "get_topological_evaluation_order",
              "get_temporal_policies",
              "create_temporal_policy",
              "get_temporal_utilization",
              "prune_temporal_metrics",
              "get_temporal_storage_stats",
              "evaluate_with_context"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_limits_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_limits_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 391,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "PolicyLimitsServiceError",
            "docstring": "Base exception for policy limits service.",
            "methods": [],
            "line": 74
          },
          {
            "name": "LimitNotFoundError",
            "docstring": "Raised when limit is not found.",
            "methods": [],
            "line": 79
          },
          {
            "name": "LimitValidationError",
            "docstring": "Raised when limit validation fails.",
            "methods": [],
            "line": 84
          },
          {
            "name": "ImmutableFieldError",
            "docstring": "Raised when attempting to modify immutable fields.",
            "methods": [],
            "line": 89
          },
          {
            "name": "PolicyLimitsService",
            "docstring": "Service for policy limit CRUD operations.\n\nINVARIANTS:\n- Limits are tenant-scoped\n- limit_category and limit_type are immutable after creation\n- Every active limit MUST have an integrity record\n- Deletions are soft (status = DISABLED)",
            "methods": [
              "__init__",
              "create",
              "update",
              "delete",
              "get",
              "_get_limit",
              "_validate_category_fields",
              "_to_response"
            ],
            "line": 94
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.hoc_spine.drivers.cross_domain",
            "names": [
              "generate_uuid"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.domain_enums",
            "names": [
              "ActorType"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.policy_limits",
            "names": [
              "CreatePolicyLimitRequest",
              "UpdatePolicyLimitRequest",
              "PolicyLimitResponse"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_mapper.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_mapper.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 643,
        "module_docstring": "Module: policy_mapper\nPurpose: Map MCP tool invocations to policy gates.\n\nWires:\n    - Source: app/services/mcp/server_registry.py (tools)\n    - Source: app/services/policies/policy_engine.py (policy evaluation)\n    - Target: Tool invocations are gated by policy\n\nThis module:\n    1. Maps MCP tool invocations to policy checks\n    2. Determines required permissions for each tool\n    3. Evaluates policy before allowing invocation\n    4. Provides deny-by-default for unknown tools\n\nAcceptance Criteria:\n    - AC-142-01: Tools are mapped to policies\n    - AC-142-02: Deny-by-default for unmapped tools\n    - AC-142-03: Dangerous tools require explicit allow\n    - AC-142-04: Policy decisions are logged\n    - AC-142-05: Tenant policies are respected",
        "functions": [
          {
            "name": "get_mcp_policy_mapper",
            "signature": "() -> MCPPolicyMapper",
            "docstring": "Get or create the singleton MCPPolicyMapper.\n\nReturns:\n    MCPPolicyMapper instance",
            "is_async": false,
            "line": 600
          },
          {
            "name": "configure_mcp_policy_mapper",
            "signature": "(policy_engine: Optional[Any] = None) -> MCPPolicyMapper",
            "docstring": "Configure the singleton MCPPolicyMapper.\n\nArgs:\n    policy_engine: Policy engine to use\n\nReturns:\n    Configured MCPPolicyMapper",
            "is_async": false,
            "line": 616
          },
          {
            "name": "reset_mcp_policy_mapper",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 640
          }
        ],
        "classes": [
          {
            "name": "MCPPolicyDecisionType",
            "docstring": "Types of policy decisions for MCP tools.",
            "methods": [],
            "line": 54
          },
          {
            "name": "MCPDenyReason",
            "docstring": "Reasons for denying MCP tool invocation.",
            "methods": [],
            "line": 62
          },
          {
            "name": "MCPPolicyDecision",
            "docstring": "Policy decision for MCP tool invocation.\n\nContains the decision and context for audit.",
            "methods": [
              "to_dict",
              "allow",
              "deny"
            ],
            "line": 75
          },
          {
            "name": "MCPToolPolicy",
            "docstring": "Policy configuration for an MCP tool.\n\nDefines what permissions are required to invoke the tool.",
            "methods": [],
            "line": 138
          },
          {
            "name": "MCPPolicyMapper",
            "docstring": "Maps MCP tool invocations to policy gates.\n\nThis service:\n1. Maintains tool\u2192policy mappings\n2. Evaluates policies before tool invocation\n3. Enforces deny-by-default\n4. Handles dangerous tool restrictions",
            "methods": [
              "__init__",
              "check_tool_invocation",
              "register_tool_policy",
              "_evaluate_policy",
              "_check_explicit_allow",
              "_check_rate_limit",
              "_get_policy_engine"
            ],
            "line": 155
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_models.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_models.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 739,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "PolicyCategory",
            "docstring": "Categories of policies in the M19 Policy Layer.",
            "methods": [],
            "line": 37
          },
          {
            "name": "PolicyDecision",
            "docstring": "Possible decisions from policy evaluation.",
            "methods": [],
            "line": 47
          },
          {
            "name": "ActionType",
            "docstring": "Types of actions that require policy evaluation.",
            "methods": [],
            "line": 55
          },
          {
            "name": "ViolationType",
            "docstring": "Types of policy violations.",
            "methods": [],
            "line": 69
          },
          {
            "name": "ViolationSeverity",
            "docstring": "Enhanced violation severity classifications (GAP 5).",
            "methods": [],
            "line": 81
          },
          {
            "name": "RecoverabilityType",
            "docstring": "Whether a violation is recoverable.",
            "methods": [],
            "line": 102
          },
          {
            "name": "SafetyRuleType",
            "docstring": "Types of safety rules.",
            "methods": [],
            "line": 111
          },
          {
            "name": "EthicalConstraintType",
            "docstring": "Types of ethical constraints.",
            "methods": [],
            "line": 121
          },
          {
            "name": "BusinessRuleType",
            "docstring": "Types of business rules.",
            "methods": [],
            "line": 130
          },
          {
            "name": "PolicyEvaluationRequest",
            "docstring": "Request for policy evaluation.",
            "methods": [],
            "line": 145
          },
          {
            "name": "PolicyModification",
            "docstring": "Modification applied to an action by policy engine.",
            "methods": [],
            "line": 171
          },
          {
            "name": "PolicyEvaluationResult",
            "docstring": "Result of policy evaluation.",
            "methods": [],
            "line": 180
          },
          {
            "name": "PolicyViolation",
            "docstring": "A policy violation record.",
            "methods": [],
            "line": 203
          },
          {
            "name": "PolicyRule",
            "docstring": "A single rule within a policy.",
            "methods": [],
            "line": 231
          },
          {
            "name": "Policy",
            "docstring": "A policy definition.",
            "methods": [],
            "line": 241
          },
          {
            "name": "RiskCeiling",
            "docstring": "A risk ceiling definition.",
            "methods": [],
            "line": 268
          },
          {
            "name": "SafetyRule",
            "docstring": "A safety rule definition.",
            "methods": [],
            "line": 293
          },
          {
            "name": "EthicalConstraint",
            "docstring": "An ethical constraint definition.",
            "methods": [],
            "line": 318
          },
          {
            "name": "BusinessRule",
            "docstring": "A business rule definition.",
            "methods": [],
            "line": 340
          },
          {
            "name": "PolicyState",
            "docstring": "Current state of the policy layer.",
            "methods": [],
            "line": 365
          },
          {
            "name": "PolicyLoadResult",
            "docstring": "Result of loading policies from database.",
            "methods": [],
            "line": 388
          },
          {
            "name": "PolicyVersion",
            "docstring": "A versioned snapshot of a policy set (GAP 1).",
            "methods": [],
            "line": 406
          },
          {
            "name": "PolicyProvenance",
            "docstring": "Audit trail for policy changes (GAP 1).",
            "methods": [],
            "line": 434
          },
          {
            "name": "PolicyDependency",
            "docstring": "Dependency relationship between policies (GAP 2).",
            "methods": [],
            "line": 460
          },
          {
            "name": "PolicyConflict",
            "docstring": "A detected conflict between policies (GAP 2).",
            "methods": [],
            "line": 476
          },
          {
            "name": "DependencyGraph",
            "docstring": "The complete policy dependency graph (GAP 2).",
            "methods": [],
            "line": 498
          },
          {
            "name": "TemporalPolicyType",
            "docstring": "Types of temporal policies.",
            "methods": [],
            "line": 512
          },
          {
            "name": "TemporalPolicy",
            "docstring": "A temporal/sliding window policy (GAP 3).",
            "methods": [],
            "line": 522
          },
          {
            "name": "TemporalMetricWindow",
            "docstring": "A sliding window of metric values (GAP 3).",
            "methods": [],
            "line": 551
          },
          {
            "name": "PolicyContext",
            "docstring": "Complete policy context passed through the decision cycle (GAP 4).\n\nThis object provides the full state needed for policy evaluation,\nenabling multi-agent coordination and trajectory-based decisions.",
            "methods": [],
            "line": 574
          },
          {
            "name": "EnhancedPolicyEvaluationRequest",
            "docstring": "Enhanced evaluation request with full context (GAP 4).",
            "methods": [],
            "line": 634
          },
          {
            "name": "EnhancedPolicyViolation",
            "docstring": "Enhanced violation with severity classification (GAP 5).",
            "methods": [],
            "line": 659
          },
          {
            "name": "EnhancedPolicyEvaluationResult",
            "docstring": "Enhanced evaluation result with full context (GAPs 1-5).",
            "methods": [],
            "line": 696
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 30
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_proposal_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_proposal_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 716,
        "module_docstring": "Policy Proposal Engine (L5)\n\nProposes policy changes based on observed feedback WITHOUT auto-enforcement.\n\nPB-S4 Contract:\n- Observe feedback patterns \u2192 propose policy \u2192 wait for human\n- NO auto-enforcement\n- NO execution modification\n- Human approval is MANDATORY\n\nRule: Propose \u2192 Review \u2192 Decide (Human)\n\nState Machine:\n    DRAFT \u2192 PENDING \u2192 APPROVED/REJECTED\n                \u2193\n            ACTIVE (on activation)",
        "functions": [
          {
            "name": "generate_default_rule",
            "signature": "(policy_type: str, feedback_type: str) -> dict",
            "docstring": "Generate a default rule template based on policy type.\n\nPB-S4: These are SUGGESTIONS only. Human must review.",
            "is_async": false,
            "line": 587
          },
          {
            "name": "get_policy_proposal_engine",
            "signature": "(session: 'AsyncSession') -> PolicyProposalEngine",
            "docstring": "Get a PolicyProposalEngine instance with drivers.",
            "is_async": false,
            "line": 622
          },
          {
            "name": "check_proposal_eligibility",
            "signature": "(session: 'AsyncSession', tenant_id: Optional[UUID] = None, feedback_type: Optional[str] = None, threshold: int = FEEDBACK_THRESHOLD_FOR_PROPOSAL) -> list[dict]",
            "docstring": "Backward-compatible wrapper for eligibility checking.",
            "is_async": true,
            "line": 637
          },
          {
            "name": "create_policy_proposal",
            "signature": "(session: 'AsyncSession', proposal: PolicyProposalCreate) -> str",
            "docstring": "Backward-compatible wrapper for proposal creation.",
            "is_async": true,
            "line": 652
          },
          {
            "name": "review_policy_proposal",
            "signature": "(session: 'AsyncSession', proposal_id: UUID, review: PolicyApprovalRequest, audit: Any = None) -> dict",
            "docstring": "Backward-compatible wrapper for proposal review.",
            "is_async": true,
            "line": 661
          },
          {
            "name": "delete_policy_rule",
            "signature": "(session: 'AsyncSession', rule_id: str, tenant_id: str, deleted_by: str) -> bool",
            "docstring": "Backward-compatible wrapper for rule deletion.",
            "is_async": true,
            "line": 672
          },
          {
            "name": "get_proposal_summary",
            "signature": "(session: 'AsyncSession', tenant_id: Optional[UUID] = None, status: Optional[str] = None, limit: int = 50) -> dict",
            "docstring": "Backward-compatible wrapper for proposal summary.",
            "is_async": true,
            "line": 683
          }
        ],
        "classes": [
          {
            "name": "PolicyActivationBlockedError",
            "docstring": "GOV-POL-001: Raised when policy activation is blocked due to BLOCKING conflicts.\n\nThis exception is CONSTITUTIONAL - it cannot be caught and ignored.\nThe caller must surface the conflict to the human reviewer.",
            "methods": [
              "__init__"
            ],
            "line": 71
          },
          {
            "name": "PolicyDeletionBlockedError",
            "docstring": "GOV-POL-002: Raised when policy deletion is blocked due to dependents.\n\nThis exception is CONSTITUTIONAL - it cannot be caught and ignored.\nThe caller must resolve dependencies before deletion.",
            "methods": [
              "__init__"
            ],
            "line": 84
          },
          {
            "name": "PolicyProposalEngine",
            "docstring": "L5 Domain Engine for policy proposal lifecycle management.\n\nResponsibilities:\n- Eligibility checking (business logic)\n- Proposal creation orchestration\n- State machine transitions (DRAFT \u2192 APPROVED/REJECTED)\n- Conflict detection coordination\n- Approval workflow\n\nDoes NOT own:\n- Direct DB queries (delegated to L6 drivers)\n- HTTP concerns (that's L2/L3)",
            "methods": [
              "__init__",
              "check_proposal_eligibility",
              "create_proposal",
              "review_proposal",
              "_create_policy_rule_from_proposal",
              "delete_policy_rule",
              "get_proposal_summary"
            ],
            "line": 110
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_proposal_read_driver",
            "names": [
              "PolicyProposalReadDriver",
              "get_policy_proposal_read_driver"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_proposal_write_driver",
            "names": [
              "PolicyProposalWriteDriver",
              "get_policy_proposal_write_driver"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.domain_enums",
            "names": [
              "ActorType"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.policy_graph",
            "names": [
              "ConflictSeverity",
              "get_conflict_engine",
              "get_dependency_engine"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [
          {
            "name": "FEEDBACK_THRESHOLD_FOR_PROPOSAL",
            "line": 98
          },
          {
            "name": "PROPOSAL_TYPES",
            "line": 99
          }
        ],
        "all_exports": [
          "PolicyProposalEngine",
          "get_policy_proposal_engine",
          "PolicyActivationBlockedError",
          "PolicyDeletionBlockedError",
          "FEEDBACK_THRESHOLD_FOR_PROPOSAL",
          "PROPOSAL_TYPES",
          "generate_default_rule",
          "check_proposal_eligibility",
          "create_policy_proposal",
          "review_policy_proposal",
          "delete_policy_rule",
          "get_proposal_summary"
        ]
      },
      {
        "file_name": "policy_rules_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_rules_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 397,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "PolicyRulesServiceError",
            "docstring": "Base exception for policy rules service.",
            "methods": [],
            "line": 79
          },
          {
            "name": "RuleNotFoundError",
            "docstring": "Raised when rule is not found.",
            "methods": [],
            "line": 84
          },
          {
            "name": "RuleValidationError",
            "docstring": "Raised when rule validation fails.",
            "methods": [],
            "line": 89
          },
          {
            "name": "PolicyRulesService",
            "docstring": "Service for policy rule CRUD operations.\n\nINVARIANTS:\n- Rules are tenant-scoped\n- Rules are never deleted, only retired\n- Every active rule MUST have an integrity record\n- Retirement creates audit trail",
            "methods": [
              "__init__",
              "create",
              "update",
              "get",
              "_get_rule",
              "_validate_conditions",
              "_compute_hash",
              "_to_response"
            ],
            "line": 94
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.hoc_spine.drivers.cross_domain",
            "names": [
              "generate_uuid"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_rules_driver",
            "names": [
              "PolicyRulesDriver",
              "get_policy_rules_driver"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.domain_enums",
            "names": [
              "ActorType"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.hoc.cus.policies.L5_schemas.policy_rules",
            "names": [
              "CreatePolicyRuleRequest",
              "UpdatePolicyRuleRequest",
              "PolicyRuleResponse"
            ],
            "is_relative": false,
            "line": 72
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "prevention_hook.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/prevention_hook.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 302,
        "module_docstring": null,
        "functions": [
          {
            "name": "create_prevention_hook",
            "signature": "(strict_mode: bool = True, block_on_fail: bool = True) -> PreventionHook",
            "docstring": "Factory function to create a prevention hook.",
            "is_async": false,
            "line": 240
          },
          {
            "name": "get_prevention_hook",
            "signature": "() -> PreventionHook",
            "docstring": "Get the global prevention hook instance.",
            "is_async": false,
            "line": 255
          },
          {
            "name": "evaluate_response",
            "signature": "(tenant_id: str, call_id: str, user_query: str, context_data: Dict[str, Any], llm_output: str, model: str = 'unknown', user_id: Optional[str] = None) -> PreventionResult",
            "docstring": "Convenience function to evaluate an LLM response.\n\nUsage:\n    result = evaluate_response(\n        tenant_id=\"tenant_123\",\n        call_id=\"call_abc\",\n        user_query=\"Is my contract auto-renewed?\",\n        context_data={\"auto_renew\": None},\n        llm_output=\"Yes, your contract is set to auto-renew...\",\n    )\n\n    if result.action != PreventionAction.ALLOW:\n        # Handle blocked/modified response\n        pass",
            "is_async": false,
            "line": 263
          }
        ],
        "classes": [
          {
            "name": "PreventionAction",
            "docstring": "Action to take when prevention hook triggers.",
            "methods": [],
            "line": 43
          },
          {
            "name": "PreventionContext",
            "docstring": "Context for prevention hook evaluation.",
            "methods": [
              "__post_init__"
            ],
            "line": 54
          },
          {
            "name": "PreventionResult",
            "docstring": "Result of prevention hook evaluation.",
            "methods": [
              "__post_init__",
              "to_dict"
            ],
            "line": 82
          },
          {
            "name": "PreventionHook",
            "docstring": "Prevention hook for pre-response validation.\n\nUsage:\n    hook = PreventionHook(strict_mode=True)\n\n    # Before sending response to client\n    result = hook.evaluate(PreventionContext(\n        tenant_id=\"tenant_123\",\n        call_id=\"call_abc\",\n        user_id=\"cust_8372\",\n        model=\"gpt-4.1\",\n        user_query=\"Is my contract auto-renewed?\",\n        system_prompt=\"You are a helpful assistant.\",\n        context_data={\"auto_renew\": None, \"contract_status\": \"active\"},\n        llm_output=\"Yes, your contract is set to auto-renew...\",\n        output_tokens=18,\n    ))\n\n    if result.action == PreventionAction.BLOCK:\n        # Don't send response, return error or safe message\n        pass\n    elif result.action == PreventionAction.MODIFY:\n        # Send modified response\n        pass",
            "methods": [
              "__init__",
              "evaluate",
              "get_safe_response"
            ],
            "line": 117
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.content_accuracy",
            "names": [
              "ContentAccuracyValidator",
              "ValidationResult"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "protection_provider.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/protection_provider.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 388,
        "module_docstring": "Phase-7 Abuse Protection Provider \u2014 Interface and Mock Implementation\n\nPIN-399 Phase-7: Mock provider must be behavior-compatible with real provider.\n\nDESIGN INVARIANTS (LOCKED):\n- ABUSE-004: Protection providers are swappable behind a fixed interface\n- ABUSE-005: Mock provider must be behavior-compatible with real provider\n\nIMPLEMENTATION CONSTRAINTS:\n- Deterministic thresholds\n- Static configs\n- No external calls\n- No ML\n\nORDERING RULE (Critical):\n    Checks execute in this order:\n    1. Rate limit\n    2. Burst control\n    3. Cost guard\n    4. Anomaly detection\n\n    First REJECT stops evaluation.\n    This order is LOCKED to preserve predictability.",
        "functions": [
          {
            "name": "get_protection_provider",
            "signature": "() -> AbuseProtectionProvider",
            "docstring": "Get the abuse protection provider instance.\n\nReturns MockAbuseProtectionProvider by default.\nCan be replaced for testing or production.",
            "is_async": false,
            "line": 360
          },
          {
            "name": "set_protection_provider",
            "signature": "(provider: AbuseProtectionProvider) -> None",
            "docstring": "Set the abuse protection provider instance.\n\nUsed for testing or to swap in a real provider.",
            "is_async": false,
            "line": 373
          }
        ],
        "classes": [
          {
            "name": "AbuseProtectionProvider",
            "docstring": "Phase-7 Abuse Protection Provider Protocol.\n\nAll protection providers (mock and real) must implement this interface.\n\nThis protocol is LOCKED per ABUSE-004.",
            "methods": [
              "check_rate_limit",
              "check_burst",
              "check_cost",
              "detect_anomaly",
              "check_all"
            ],
            "line": 63
          },
          {
            "name": "MockAbuseProtectionProvider",
            "docstring": "Phase-7 Mock Abuse Protection Provider.\n\nImplements AbuseProtectionProvider protocol with deterministic behavior.\n\nIMPLEMENTATION CONSTRAINTS:\n- Deterministic thresholds\n- Static configs\n- No external calls\n- No ML\n- No adaptive behavior\n\nPROTECTION DIMENSIONS:\n- Rate limits: 1000 req/min default\n- Burst control: 100 req/sec default\n- Cost guards: Read from billing limits\n- Anomaly detection: 10x jump threshold",
            "methods": [
              "__init__",
              "check_rate_limit",
              "check_burst",
              "check_cost",
              "detect_anomaly",
              "check_all",
              "add_cost",
              "reset",
              "reset_rate_limits"
            ],
            "line": 148
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Protocol",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.protection.decisions",
            "names": [
              "Decision",
              "ProtectionResult",
              "AnomalySignal",
              "allow",
              "reject_rate_limit",
              "reject_cost_limit",
              "throttle"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.billing",
            "names": [
              "get_billing_provider",
              "Limits"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": [
          "AbuseProtectionProvider",
          "MockAbuseProtectionProvider",
          "get_protection_provider",
          "set_protection_provider"
        ]
      },
      {
        "file_name": "recovery_evaluation_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/recovery_evaluation_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 415,
        "module_docstring": "Domain engine for recovery evaluation decisions.\n\nThis L4 engine contains the authoritative decision logic for:\n1. Rule evaluation - evaluate_rules()\n2. Pattern matching - RecoveryMatcher\n3. Confidence combination - combine_confidences()\n4. Action selection threshold - should_select_action()\n5. Auto-execution threshold - should_auto_execute()\n6. Decision record emission - emit_recovery_decision()\n\nL5 workers must call this engine and execute the returned decisions,\nnot implement their own decision logic.\n\nReference: PIN-257 Phase R-1\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md",
        "functions": [
          {
            "name": "evaluate_recovery",
            "signature": "(failure_match_id: str, error_code: str, error_message: str, **kwargs) -> RecoveryDecision",
            "docstring": "Convenience function to evaluate a failure and get a decision.\n\nThis is the L4 entry point for recovery evaluation. It returns\na RecoveryDecision that L5 must execute.\n\nArgs:\n    failure_match_id: ID of the failure match record\n    error_code: Error code\n    error_message: Error message\n    **kwargs: Additional context fields\n\nReturns:\n    RecoveryDecision with all domain decisions\n\nReference: PIN-257 Phase R-1",
            "is_async": false,
            "line": 291
          },
          {
            "name": "evaluate_and_execute",
            "signature": "(failure_match_id: str, error_code: str, error_message: str, **kwargs) -> 'EvaluationOutcome'",
            "docstring": "Full entry point: evaluate failure and execute decision.\n\nThis L4 function:\n1. Creates FailureContext from input\n2. Evaluates using RecoveryEvaluationEngine (L4 domain decisions)\n3. Calls L5 RecoveryExecutor to execute the decision\n4. Emits decision record (L4 responsibility)\n5. Returns EvaluationOutcome\n\nThis replaces the old evaluate_failure() in L5 recovery_evaluator.py.\n\nArgs:\n    failure_match_id: ID of the failure match record\n    error_code: Error code\n    error_message: Error message\n    **kwargs: Additional context fields\n\nReturns:\n    EvaluationOutcome with execution result\n\nReference: PIN-257 Phase R-1 (L5\u2192L4 Violation Fix)",
            "is_async": true,
            "line": 329
          }
        ],
        "classes": [
          {
            "name": "FailureContext",
            "docstring": "Context for recovery evaluation (mirrors L5 FailureEvent for L4 use).",
            "methods": [
              "__post_init__"
            ],
            "line": 73
          },
          {
            "name": "RecoveryDecision",
            "docstring": "Domain decision DTO returned by L4 engine to L5 executor.\n\nThis dataclass contains all decisions made by L4 domain logic.\nL5 must execute based on these decisions without reimplementing logic.\n\nReference: PIN-257 Phase R-1",
            "methods": [
              "to_dict"
            ],
            "line": 94
          },
          {
            "name": "RecoveryEvaluationEngine",
            "docstring": "L4 Domain Engine for recovery evaluation decisions.\n\nThis engine contains ALL domain decision logic that was previously\nscattered in L5 recovery_evaluator.py. It evaluates failure context\nand returns a RecoveryDecision DTO that L5 must execute.\n\nL5 may NOT:\n- Re-implement rule evaluation\n- Re-calculate confidence scores\n- Make action selection decisions\n- Make auto-execution decisions\n- Emit decision records\n\nL5 may ONLY:\n- Execute the decision returned by this engine\n- Perform DB operations (L6)\n- Trigger execution hooks\n\nReference: PIN-257 Phase R-1\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md Section 3.4",
            "methods": [
              "__init__",
              "evaluate",
              "emit_decision_record"
            ],
            "line": 140
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.contracts.decisions",
            "names": [
              "emit_recovery_decision"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.recovery_matcher",
            "names": [
              "RecoveryMatcher"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.hoc_spine.utilities.recovery_decisions",
            "names": [
              "combine_confidences",
              "should_auto_execute",
              "should_select_action"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.cross_domain_gateway",
            "names": [
              "evaluate_rules"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [],
        "all_exports": [
          "FailureContext",
          "RecoveryDecision",
          "RecoveryEvaluationEngine",
          "evaluate_recovery",
          "evaluate_and_execute"
        ]
      },
      {
        "file_name": "runtime_command.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/runtime_command.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 561,
        "module_docstring": "Runtime Domain Commands (L4)\n\nDomain engine for runtime-related decisions. Provides authoritative answers for:\n1. Skill descriptions - what skills exist and their metadata\n2. Runtime queries - budget, history, capability information\n3. Resource contracts - budget, rate limits, constraints\n\nThis is an L4 domain engine. It makes decisions based on domain facts.\nIt does NOT execute skills. Execution is L5's responsibility.\n\nReference: PIN-258 Phase F-3 Runtime Cluster",
        "functions": [
          {
            "name": "get_supported_query_types",
            "signature": "() -> List[str]",
            "docstring": "Get list of supported query types.\n\nThis is an L4 domain decision - defining what queries the system supports.\n\nReturns:\n    List of supported query type strings",
            "is_async": false,
            "line": 230
          },
          {
            "name": "query_remaining_budget",
            "signature": "(spent_cents: int = 0, total_cents: int = DEFAULT_BUDGET_CENTS) -> QueryResult",
            "docstring": "Query remaining budget.\n\nL4 domain decision: How to calculate and present budget information.\n\nArgs:\n    spent_cents: Amount already spent\n    total_cents: Total budget available\n\nReturns:\n    QueryResult with budget information",
            "is_async": false,
            "line": 242
          },
          {
            "name": "query_execution_history",
            "signature": "(history: Optional[List[Dict[str, Any]]] = None) -> QueryResult",
            "docstring": "Query execution history.\n\nL4 domain decision: How to present execution history.\n\nArgs:\n    history: Execution history records\n\nReturns:\n    QueryResult with history",
            "is_async": false,
            "line": 268
          },
          {
            "name": "query_allowed_skills",
            "signature": "() -> QueryResult",
            "docstring": "Query list of allowed skills.\n\nL4 domain decision: What skills are available.\n\nReturns:\n    QueryResult with skill list",
            "is_async": false,
            "line": 286
          },
          {
            "name": "query_last_step_outcome",
            "signature": "(outcome: Optional[Dict[str, Any]] = None) -> QueryResult",
            "docstring": "Query last step outcome.\n\nL4 domain decision: How to present last outcome.\n\nArgs:\n    outcome: Last execution outcome\n\nReturns:\n    QueryResult with outcome",
            "is_async": false,
            "line": 305
          },
          {
            "name": "query_skills_for_goal",
            "signature": "(goal: str) -> QueryResult",
            "docstring": "Query skills available for a goal.\n\nL4 domain decision: Deterministic skill matching based on goal.\n\nArgs:\n    goal: Goal description\n\nReturns:\n    QueryResult with matched skills",
            "is_async": false,
            "line": 323
          },
          {
            "name": "execute_query",
            "signature": "(query_type: str, params: Optional[Dict[str, Any]] = None) -> QueryResult",
            "docstring": "Execute a runtime query.\n\nL4 domain command: Routes query to appropriate handler.\n\nArgs:\n    query_type: Type of query\n    params: Query parameters\n\nReturns:\n    QueryResult with query response",
            "is_async": false,
            "line": 350
          },
          {
            "name": "get_skill_info",
            "signature": "(skill_id: str) -> Optional[SkillInfo]",
            "docstring": "Get domain information about a skill.\n\nL4 domain decision: Skill metadata and capabilities.\n\nArgs:\n    skill_id: Skill identifier\n\nReturns:\n    SkillInfo if skill exists, None otherwise",
            "is_async": false,
            "line": 391
          },
          {
            "name": "list_skills",
            "signature": "() -> List[str]",
            "docstring": "List all available skill IDs.\n\nL4 domain decision: What skills are known to the system.\n\nReturns:\n    List of skill IDs",
            "is_async": false,
            "line": 420
          },
          {
            "name": "get_all_skill_descriptors",
            "signature": "() -> Dict[str, Dict[str, Any]]",
            "docstring": "Get descriptors for all skills.\n\nL4 domain decision: Comprehensive skill information.\n\nReturns:\n    Dict mapping skill_id to descriptor dict",
            "is_async": false,
            "line": 432
          },
          {
            "name": "get_resource_contract",
            "signature": "(resource_id: str) -> ResourceContractInfo",
            "docstring": "Get resource contract information.\n\nL4 domain decision: Default resource constraints.\n\nArgs:\n    resource_id: Resource identifier\n\nReturns:\n    ResourceContractInfo with contract details",
            "is_async": false,
            "line": 460
          },
          {
            "name": "get_capabilities",
            "signature": "(agent_id: Optional[str] = None, tenant_id: Optional[str] = None) -> CapabilitiesInfo",
            "docstring": "Get capabilities for an agent/tenant.\n\nL4 domain decision: What capabilities are available.\n\nArgs:\n    agent_id: Optional agent ID\n    tenant_id: Optional tenant ID\n\nReturns:\n    CapabilitiesInfo with capability details",
            "is_async": false,
            "line": 485
          }
        ],
        "classes": [
          {
            "name": "QueryResult",
            "docstring": "Result from a runtime query command.",
            "methods": [],
            "line": 72
          },
          {
            "name": "SkillInfo",
            "docstring": "Domain information about a skill.",
            "methods": [],
            "line": 81
          },
          {
            "name": "ResourceContractInfo",
            "docstring": "Domain information about a resource contract.",
            "methods": [],
            "line": 98
          },
          {
            "name": "CapabilitiesInfo",
            "docstring": "Domain information about available capabilities.",
            "methods": [],
            "line": 108
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "DEFAULT_BUDGET_CENTS",
          "DEFAULT_RATE_LIMIT_PER_MINUTE",
          "DEFAULT_MAX_CONCURRENT",
          "SUPPORTED_QUERY_TYPES",
          "DEFAULT_SKILL_METADATA",
          "QueryResult",
          "SkillInfo",
          "ResourceContractInfo",
          "CapabilitiesInfo",
          "get_supported_query_types",
          "query_remaining_budget",
          "query_execution_history",
          "query_allowed_skills",
          "query_last_step_outcome",
          "query_skills_for_goal",
          "execute_query",
          "get_skill_info",
          "list_skills",
          "get_all_skill_descriptors",
          "get_resource_contract",
          "get_capabilities"
        ]
      },
      {
        "file_name": "sandbox_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/sandbox_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 562,
        "module_docstring": "Sandbox Service (GAP-174)\n\nHigh-level service for managing sandbox execution:\n- Policy-based isolation level selection\n- Execution quota management\n- Audit logging\n- Result caching",
        "functions": [
          {
            "name": "get_sandbox_service",
            "signature": "() -> 'SandboxService'",
            "docstring": "Return the process-wide SandboxService singleton (GAP-174).",
            "is_async": false,
            "line": 557
          }
        ],
        "classes": [
          {
            "name": "SandboxPolicy",
            "docstring": "Policy for sandbox execution.",
            "methods": [
              "to_resource_limits",
              "to_dict"
            ],
            "line": 51
          },
          {
            "name": "ExecutionRequest",
            "docstring": "Request to execute code in a sandbox.",
            "methods": [],
            "line": 113
          },
          {
            "name": "ExecutionRecord",
            "docstring": "Record of a sandbox execution for audit.",
            "methods": [
              "to_dict"
            ],
            "line": 134
          },
          {
            "name": "SandboxService",
            "docstring": "High-level sandbox service.\n\nFeatures:\n- Policy-based execution management\n- Quota enforcement\n- Audit logging\n- Multiple executor support",
            "methods": [
              "__init__",
              "_setup_default_policies",
              "_get_executor",
              "execute",
              "_get_policy",
              "_check_quota",
              "_track_execution",
              "define_policy",
              "get_policy",
              "list_policies",
              "get_execution_records",
              "get_execution_stats"
            ],
            "line": 180
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "sandbox_executor",
            "names": [
              "ExecutionResult",
              "IsolationLevel",
              "NetworkPolicy",
              "ResourceLimits",
              "SandboxExecutor",
              "SandboxStatus",
              "create_sandbox_executor"
            ],
            "is_relative": true,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "snapshot_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/snapshot_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 594,
        "module_docstring": "Policy Snapshot Immutability Engine (GAP-029).\n\nProvides immutable policy snapshot management with:\n- Immutability enforcement (no modifications after creation)\n- Snapshot versioning and history\n- Integrity verification\n- Tenant isolation",
        "functions": [
          {
            "name": "get_snapshot_registry",
            "signature": "() -> PolicySnapshotRegistry",
            "docstring": "Get the singleton registry instance.",
            "is_async": false,
            "line": 535
          },
          {
            "name": "_reset_snapshot_registry",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 543
          },
          {
            "name": "create_policy_snapshot",
            "signature": "(tenant_id: str, policies: list[dict[str, Any]], thresholds: dict[str, Any], policy_version: Optional[str] = None, description: Optional[str] = None) -> PolicySnapshotData",
            "docstring": "Create a new immutable policy snapshot.",
            "is_async": false,
            "line": 552
          },
          {
            "name": "get_policy_snapshot",
            "signature": "(snapshot_id: str) -> Optional[PolicySnapshotData]",
            "docstring": "Get a policy snapshot by ID.",
            "is_async": false,
            "line": 570
          },
          {
            "name": "get_active_snapshot",
            "signature": "(tenant_id: str) -> Optional[PolicySnapshotData]",
            "docstring": "Get the active policy snapshot for a tenant.",
            "is_async": false,
            "line": 576
          },
          {
            "name": "get_snapshot_history",
            "signature": "(tenant_id: str, limit: int = 100) -> List[PolicySnapshotData]",
            "docstring": "Get snapshot version history for a tenant.",
            "is_async": false,
            "line": 582
          },
          {
            "name": "verify_snapshot",
            "signature": "(snapshot_id: str) -> dict[str, Any]",
            "docstring": "Verify snapshot integrity.",
            "is_async": false,
            "line": 591
          }
        ],
        "classes": [
          {
            "name": "SnapshotStatus",
            "docstring": "Status of a policy snapshot.",
            "methods": [],
            "line": 39
          },
          {
            "name": "ImmutabilityViolation",
            "docstring": "Types of immutability violations.",
            "methods": [],
            "line": 48
          },
          {
            "name": "PolicySnapshotData",
            "docstring": "Immutable policy snapshot data.\n\nOnce created, the content cannot be modified.\nOnly status can transition through allowed paths.",
            "methods": [
              "compute_hash",
              "verify_integrity",
              "verify_threshold_integrity",
              "get_policies",
              "get_thresholds",
              "to_dict"
            ],
            "line": 59
          },
          {
            "name": "PolicySnapshotError",
            "docstring": "Exception for policy snapshot errors.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 139
          },
          {
            "name": "SnapshotRegistryStats",
            "docstring": "Statistics for snapshot registry.",
            "methods": [
              "to_dict"
            ],
            "line": 165
          },
          {
            "name": "PolicySnapshotRegistry",
            "docstring": "Registry for managing immutable policy snapshots.\n\nFeatures:\n- Immutability enforcement (no content modifications)\n- Version tracking per tenant\n- Automatic supersession of old snapshots\n- Integrity verification\n- Tenant isolation",
            "methods": [
              "__init__",
              "create",
              "get",
              "get_active",
              "get_by_version",
              "list",
              "get_history",
              "archive",
              "verify",
              "attempt_modify",
              "delete",
              "get_statistics",
              "clear_tenant",
              "reset",
              "_get_next_version",
              "_supersede_active"
            ],
            "line": 193
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "state.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/state.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 108,
        "module_docstring": "Phase-6 Billing State \u2014 Commercial State Model\n\nPIN-399 Phase-6: Billing never blocks onboarding.\n\nDESIGN INVARIANTS (LOCKED):\n- BILLING-001: Billing never blocks onboarding\n- BILLING-002: Limits are derived, not stored\n- BILLING-003: Billing state does not affect roles\n- BILLING-004: No billing mutation without audit\n- BILLING-005: Mock provider must satisfy same interface as real provider\n\nAPPLICABILITY GATE:\n    Billing logic is evaluated ONLY IF tenant.onboarding_state == COMPLETE.\n    Before COMPLETE:\n    - Billing APIs return neutral placeholders\n    - Limits are not enforced\n    - Usage is tracked but not blocked\n\nThis enum is the single source of truth for billing states.",
        "functions": [],
        "classes": [
          {
            "name": "BillingState",
            "docstring": "Phase-6 Billing States (Tenant-scoped).\n\nStates represent the commercial standing of a tenant.\nNOT tied to any specific payment gateway.\n\nSEMANTICS (LOCKED):\n- TRIAL: Default after onboarding COMPLETE\n- ACTIVE: Valid paid plan\n- PAST_DUE: Payment issue, grace period active\n- SUSPENDED: Usage blocked, data intact\n\nNo other states allowed in v1.",
            "methods": [
              "from_string",
              "default",
              "allows_usage",
              "is_in_good_standing"
            ],
            "line": 45
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "BillingState"
        ]
      },
      {
        "file_name": "tokenizer.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/tokenizer.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 352,
        "module_docstring": "Tokenizer for PLang v2.0 with M19 category support.\n\nToken types include:\n- Keywords: policy, rule, when, then, deny, allow, etc.\n- Categories: SAFETY, PRIVACY, OPERATIONAL, ROUTING, CUSTOM\n- Identifiers: user-defined names\n- Literals: numbers, strings, booleans\n- Operators: ==, !=, <, >, etc.\n- Delimiters: {, }, (, ), :, ,",
        "functions": [],
        "classes": [
          {
            "name": "TokenType",
            "docstring": "Token types for PLang v2.0.",
            "methods": [],
            "line": 39
          },
          {
            "name": "Token",
            "docstring": "A token in PLang source code.",
            "methods": [
              "__repr__",
              "is_category",
              "is_action"
            ],
            "line": 123
          },
          {
            "name": "TokenizerError",
            "docstring": "Error during tokenization.",
            "methods": [
              "__init__"
            ],
            "line": 151
          },
          {
            "name": "Tokenizer",
            "docstring": "Tokenizer for PLang v2.0.\n\nConverts source code into a stream of tokens for parsing.\nSupports M19 governance categories and policy-specific syntax.",
            "methods": [
              "__init__",
              "current_char",
              "peek",
              "advance",
              "skip_whitespace",
              "skip_comment",
              "read_string",
              "read_number",
              "read_identifier",
              "read_operator",
              "tokenize",
              "__iter__"
            ],
            "line": 161
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Iterator",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [
          {
            "name": "KEYWORD_TOKENS",
            "line": 96
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "validator.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/validator.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 386,
        "module_docstring": "Policy DSL Semantic Validator\n\nValidates AST against semantic rules. Does NOT parse.\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- Pure validation logic\n- No side effects\n- No I/O, no DB\n- Must produce validation result (errors/warnings), not exceptions\n\nSEMANTIC RULES:\n1. Mode Enforcement:\n   - MONITOR mode: Only WARN actions allowed\n   - ENFORCE mode: WARN, BLOCK, REQUIRE_APPROVAL allowed\n\n2. Metric Validation (optional):\n   - If metric registry provided, validate metrics exist\n\n3. Version Validation:\n   - Version must be >= 1\n\n4. Structural Validation:\n   - At least one clause\n   - At least one action per clause\n\nGOVERNANCE:\n- Validator is the authority on policy correctness\n- All enforcement decisions derive from validator",
        "functions": [
          {
            "name": "validate",
            "signature": "(policy: PolicyAST, allowed_metrics: set[str] | None = None) -> ValidationResult",
            "docstring": "Validate a policy AST.\n\nArgs:\n    policy: The PolicyAST to validate\n    allowed_metrics: If provided, validate metrics against this set\n\nReturns:\n    ValidationResult with all issues found\n\nExample:\n    >>> from app.dsl import parse\n    >>> ast = parse('''\n    ... policy Test\n    ... version 1\n    ... scope ORG\n    ... mode MONITOR\n    ...\n    ... when x > 0\n    ... then BLOCK\n    ... ''')\n    >>> result = validate(ast)\n    >>> result.is_valid\n    False\n    >>> result.errors[0].code\n    'V001'",
            "is_async": false,
            "line": 336
          },
          {
            "name": "is_valid",
            "signature": "(policy: PolicyAST, allowed_metrics: set[str] | None = None) -> bool",
            "docstring": "Quick check if a policy is valid.\n\nArgs:\n    policy: The PolicyAST to validate\n    allowed_metrics: If provided, validate metrics against this set\n\nReturns:\n    True if valid, False otherwise",
            "is_async": false,
            "line": 371
          }
        ],
        "classes": [
          {
            "name": "Severity",
            "docstring": "Severity level for validation issues.",
            "methods": [],
            "line": 73
          },
          {
            "name": "ValidationIssue",
            "docstring": "A single validation issue found in the policy.",
            "methods": [
              "__str__"
            ],
            "line": 81
          },
          {
            "name": "ValidationResult",
            "docstring": "Result of policy validation.",
            "methods": [
              "__post_init__",
              "errors",
              "warnings",
              "__bool__"
            ],
            "line": 95
          },
          {
            "name": "PolicyValidator",
            "docstring": "Validates PolicyAST against semantic rules.\n\nUsage:\n    validator = PolicyValidator()\n    result = validator.validate(ast)\n    if not result.is_valid:\n        for error in result.errors:\n            print(error)",
            "methods": [
              "__init__",
              "validate",
              "_validate_mode_enforcement",
              "_validate_metrics",
              "_extract_metrics",
              "_validate_structure",
              "_check_warnings"
            ],
            "line": 146
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Callable"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.dsl.ast",
            "names": [
              "Condition",
              "Mode",
              "PolicyAST",
              "is_block_action",
              "is_exists_predicate",
              "is_logical_condition",
              "is_predicate",
              "is_require_approval_action"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [
          {
            "name": "V001",
            "line": 126
          },
          {
            "name": "V002",
            "line": 127
          },
          {
            "name": "V010",
            "line": 130
          },
          {
            "name": "V020",
            "line": 133
          },
          {
            "name": "V021",
            "line": 134
          },
          {
            "name": "W001",
            "line": 137
          },
          {
            "name": "W002",
            "line": 138
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "visitors.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/visitors.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 307,
        "module_docstring": "AST visitors for PLang v2.0.\n\nVisitors for:\n- Pretty printing\n- Category collection\n- Rule extraction\n- Governance analysis",
        "functions": [],
        "classes": [
          {
            "name": "BaseVisitor",
            "docstring": "Base visitor with default implementations.",
            "methods": [
              "visit_program",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_import",
              "visit_rule_ref",
              "visit_priority",
              "visit_condition_block",
              "visit_action_block",
              "visit_route_target",
              "visit_binary_op",
              "visit_unary_op",
              "visit_ident",
              "visit_literal",
              "visit_func_call",
              "visit_attr_access"
            ],
            "line": 54
          },
          {
            "name": "PrintVisitor",
            "docstring": "Visitor that prints AST in readable format.",
            "methods": [
              "__init__",
              "_emit",
              "get_output",
              "visit_program",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_import",
              "visit_rule_ref",
              "visit_priority",
              "visit_condition_block",
              "visit_action_block",
              "visit_route_target",
              "visit_binary_op",
              "visit_unary_op",
              "visit_ident",
              "visit_literal",
              "visit_func_call",
              "visit_attr_access"
            ],
            "line": 118
          },
          {
            "name": "CategoryCollector",
            "docstring": "Visitor that collects all categories used in the AST.\n\nUsed for governance analysis and category-based routing.",
            "methods": [
              "__init__",
              "get_categories",
              "visit_policy_decl",
              "visit_rule_decl"
            ],
            "line": 222
          },
          {
            "name": "RuleExtractor",
            "docstring": "Visitor that extracts all rules with their governance metadata.\n\nUsed for building the symbol table and IR.",
            "methods": [
              "__init__",
              "get_rules",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_condition_block"
            ],
            "line": 250
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.policy.ast.nodes",
            "names": [
              "ActionBlockNode",
              "ASTVisitor",
              "AttrAccessNode",
              "BinaryOpNode",
              "ConditionBlockNode",
              "FuncCallNode",
              "IdentNode",
              "ImportNode",
              "LiteralNode",
              "PolicyDeclNode",
              "PriorityNode",
              "ProgramNode",
              "RouteTargetNode",
              "RuleDeclNode",
              "RuleRefNode",
              "UnaryOpNode"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "worker_execution_command.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/worker_execution_command.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 355,
        "module_docstring": "Worker Execution Command (L4)\n\nDomain command for Business Builder Worker execution. This L4 command:\n1. Takes domain facts (task, brand, budget, etc.)\n2. Provides authorization for execution\n3. Delegates to L5 workers (since L4 \u2192 L5 is allowed)\n4. Returns results\n\nThis is NOT an execution layer. It authorizes and delegates.\nAll execution logic remains in L5 workers.\n\nReference: PIN-258 Phase F-3 Workers Cluster",
        "functions": [
          {
            "name": "calculate_cost_cents",
            "signature": "(model: str, input_tokens: int, output_tokens: int) -> int",
            "docstring": "Calculate LLM cost in cents.\n\nThis L4 command delegates to L5 cost calculation.\nL4 \u2192 L5 is an allowed import per layer rules.\n\nArgs:\n    model: Model name\n    input_tokens: Number of input tokens\n    output_tokens: Number of output tokens\n\nReturns:\n    Cost in cents\n\nReference: PIN-258 Phase F-3 (F-W-RULE-1: No semantic changes)",
            "is_async": false,
            "line": 92
          },
          {
            "name": "get_brand_schema_types",
            "signature": "()",
            "docstring": "Get brand schema types from L5.\n\nL4 \u2192 L5 is an allowed import per layer rules.\nReturns the schema types needed for brand conversion.\n\nReference: PIN-258 Phase F-3 (F-W-RULE-1: No semantic changes)",
            "is_async": false,
            "line": 120
          },
          {
            "name": "convert_brand_request",
            "signature": "(brand_req) -> Any",
            "docstring": "Convert API brand request to BrandSchema.\n\nThis L4 command handles the conversion logic using L5 schemas.\nL4 \u2192 L5 is an allowed import per layer rules.\n\nArgs:\n    brand_req: Brand request from API\n\nReturns:\n    BrandSchema instance\n\nReference: PIN-258 Phase F-3 (F-W-RULE-1: No semantic changes)",
            "is_async": false,
            "line": 148
          },
          {
            "name": "execute_worker",
            "signature": "(task: str, brand: Optional[Any] = None, budget: Optional[int] = None, strict_mode: bool = False, depth: int = 2, run_id: Optional[str] = None, event_bus: Optional[Any] = None) -> WorkerExecutionResult",
            "docstring": "Execute Business Builder Worker.\n\nThis L4 command authorizes and delegates execution to L5.\nL4 \u2192 L5 is an allowed import per layer rules.\n\nF-W-RULE-2: Worker is a blind executor. This command delegates to it.\nF-W-RULE-3: This command authorizes, L5 executes.\n\nArgs:\n    task: Business/product idea\n    brand: Optional brand schema\n    budget: Optional budget\n    strict_mode: Whether to use strict mode\n    depth: Execution depth\n    run_id: Optional run ID\n    event_bus: Optional event bus\n\nReturns:\n    WorkerExecutionResult with execution outcome\n\nReference: PIN-258 Phase F-3 Workers Cluster",
            "is_async": true,
            "line": 231
          },
          {
            "name": "replay_execution",
            "signature": "(replay_token: str, run_id: str) -> ReplayResult",
            "docstring": "Replay a previous execution.\n\nThis L4 command authorizes and delegates replay to L5.\nL4 \u2192 L5 is an allowed import per layer rules.\n\nArgs:\n    replay_token: Token from previous execution\n    run_id: New run ID for this replay\n\nReturns:\n    ReplayResult with replay outcome\n\nReference: PIN-258 Phase F-3 Workers Cluster",
            "is_async": true,
            "line": 300
          }
        ],
        "classes": [
          {
            "name": "WorkerExecutionResult",
            "docstring": "Result from worker execution command.",
            "methods": [],
            "line": 48
          },
          {
            "name": "ReplayResult",
            "docstring": "Result from replay command.",
            "methods": [],
            "line": 68
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": [
          "WorkerExecutionResult",
          "ReplayResult",
          "calculate_cost_cents",
          "get_brand_schema_types",
          "convert_brand_request",
          "execute_worker",
          "replay_execution"
        ]
      }
    ],
    "l5_schemas": [
      {
        "file_name": "policy_rules.py",
        "file_path": "backend/app/hoc/cus/policies/L5_schemas/policy_rules.py",
        "layer": "L5_schemas",
        "domain": "policies",
        "lines": 161,
        "module_docstring": "Policy Rules Schemas (PIN-LIM-02)\n\nRequest and response models for policy rule CRUD operations.\nRules define governance constraints that govern LLM Run behavior.",
        "functions": [],
        "classes": [
          {
            "name": "EnforcementModeEnum",
            "docstring": "Policy rule enforcement modes.",
            "methods": [],
            "line": 26
          },
          {
            "name": "PolicyScopeEnum",
            "docstring": "Policy rule scope levels.",
            "methods": [],
            "line": 34
          },
          {
            "name": "PolicySourceEnum",
            "docstring": "Policy rule creation source.",
            "methods": [],
            "line": 42
          },
          {
            "name": "CreatePolicyRuleRequest",
            "docstring": "Request model for creating a policy rule.",
            "methods": [],
            "line": 49
          },
          {
            "name": "UpdatePolicyRuleRequest",
            "docstring": "Request model for updating a policy rule.",
            "methods": [],
            "line": 98
          },
          {
            "name": "PolicyRuleResponse",
            "docstring": "Response model for policy rule operations.",
            "methods": [],
            "line": 137
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 23
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "arbitrator.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/arbitrator.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 339,
        "module_docstring": "Policy Arbitrator Engine\n\nResolves conflicts when multiple policies apply to the same run:\n1. Sort policies by precedence (lower = higher priority)\n2. Resolve limit conflicts using conflict strategy\n3. Resolve action conflicts (harshest action wins)\n4. Return effective limits and actions\n\nArbitration Rules:\n- MOST_RESTRICTIVE: Smallest limit, harshest action wins\n- EXPLICIT_PRIORITY: Higher precedence (lower number) wins\n- FAIL_CLOSED: If ambiguous, deny/stop",
        "functions": [
          {
            "name": "get_policy_arbitrator",
            "signature": "() -> PolicyArbitrator",
            "docstring": "Get or create PolicyArbitrator singleton.",
            "is_async": false,
            "line": 334
          }
        ],
        "classes": [
          {
            "name": "PolicyLimit",
            "docstring": "Represents a policy limit.",
            "methods": [],
            "line": 56
          },
          {
            "name": "PolicyAction",
            "docstring": "Represents a policy breach action.",
            "methods": [],
            "line": 66
          },
          {
            "name": "ArbitrationInput",
            "docstring": "Input for policy arbitration.",
            "methods": [],
            "line": 83
          },
          {
            "name": "PolicyArbitrator",
            "docstring": "Resolves conflicts between multiple applicable policies.\n\nThe arbitrator determines effective limits and actions when\nmultiple policies apply to the same run.",
            "methods": [
              "__init__",
              "arbitrate",
              "_load_precedence_map",
              "_get_precedence_map",
              "_resolve_limit_conflict",
              "_resolve_action_conflict"
            ],
            "line": 93
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.db",
            "names": [
              "engine"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.policy_precedence",
            "names": [
              "ArbitrationResult",
              "ConflictStrategy",
              "PolicyPrecedence"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [
          {
            "name": "ACTION_SEVERITY",
            "line": 75
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "optimizer_conflict_resolver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/optimizer_conflict_resolver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 390,
        "module_docstring": "Conflict resolution for PLang v2.0.\n\nConflict types:\n- Action conflicts: Different actions for same condition\n- Priority conflicts: Same priority for different policies\n- Category conflicts: Cross-category interactions\n\nResolution strategies:\n- Category precedence: SAFETY > PRIVACY > OPERATIONAL > ROUTING > CUSTOM\n- Priority ordering: Higher priority wins\n- Action precedence: deny > escalate > route > allow",
        "functions": [],
        "classes": [
          {
            "name": "ConflictType",
            "docstring": "Types of policy conflicts.",
            "methods": [],
            "line": 51
          },
          {
            "name": "PolicyConflict",
            "docstring": "A detected conflict between policies.\n\nIncludes conflict type, involved policies, and resolution.",
            "methods": [
              "__str__"
            ],
            "line": 61
          },
          {
            "name": "ConflictResolver",
            "docstring": "Resolves conflicts between policies.\n\nUses M19 governance rules to determine winning policy\nwhen conflicts are detected.",
            "methods": [
              "__init__",
              "resolve",
              "_detect_action_conflicts",
              "_detect_priority_conflicts",
              "_detect_category_conflicts",
              "_detect_circular_dependencies",
              "_get_condition_signature",
              "_might_override",
              "_get_actions",
              "_resolve_conflict",
              "_resolve_action_conflict",
              "_resolve_priority_conflict",
              "_resolve_category_conflict",
              "_resolve_circular_conflict"
            ],
            "line": 81
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "List",
              "Optional",
              "Set",
              "Tuple"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "PLANG_GRAMMAR",
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRAction",
              "IRBlock",
              "IRFunction",
              "IRModule"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_engine_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_engine_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 1911,
        "module_docstring": "Policy Engine Driver (L6)\n\nPure data access for PolicyEngine operations.\nNo business logic - only DB operations.\n\nAuthority: POLICY_ENGINE_PERSISTENCE\nTables:\n  - policy.evaluations (write)\n  - policy.violations (read/write)\n  - policy.ethical_constraints (read)\n  - policy.risk_ceilings (read/write)\n  - policy.safety_rules (read/write)\n  - policy.business_rules (read)\n  - policy.policy_versions (read/write)\n  - policy.policy_provenance (read/write)\n  - policy.policy_dependencies (read/write)\n  - policy.policy_conflicts (read/write)\n  - policy.temporal_policies (read/write)\n  - policy.temporal_metric_events (read/write)\n  - policy.temporal_metric_windows (read/write)",
        "functions": [
          {
            "name": "get_policy_engine_driver",
            "signature": "(db_url: str) -> PolicyEngineDriver",
            "docstring": "Factory function for PolicyEngineDriver.",
            "is_async": false,
            "line": 1903
          }
        ],
        "classes": [
          {
            "name": "PolicyEngineDriver",
            "docstring": "L6 driver for PolicyEngine data access.\n\nINVARIANTS (L6):\n- No business branching\n- No validation\n- No cross-domain calls\n- Pure persistence operations only",
            "methods": [
              "__init__",
              "_get_engine",
              "get_engine",
              "fetch_ethical_constraints",
              "fetch_risk_ceilings",
              "fetch_safety_rules",
              "fetch_business_rules",
              "insert_evaluation",
              "insert_violation",
              "fetch_violations",
              "fetch_violation_by_id",
              "update_violation_acknowledged",
              "update_risk_ceiling",
              "reset_risk_ceiling",
              "update_safety_rule",
              "fetch_policy_versions",
              "fetch_current_active_version",
              "fetch_policy_version_by_id",
              "fetch_policy_version_by_id_or_version",
              "deactivate_all_versions",
              "insert_policy_version",
              "fetch_version_for_rollback",
              "mark_version_rolled_back",
              "activate_version",
              "insert_provenance",
              "fetch_provenance",
              "fetch_dependencies",
              "fetch_dependency_edges",
              "fetch_dependency_edges_with_type",
              "insert_dependency",
              "fetch_conflicts",
              "fetch_unresolved_conflicts",
              "resolve_conflict",
              "fetch_temporal_policies",
              "insert_temporal_policy",
              "fetch_temporal_policy_for_utilization",
              "fetch_temporal_metric_sum",
              "delete_old_temporal_events",
              "compact_temporal_events",
              "cap_temporal_events",
              "fetch_temporal_stats",
              "fetch_temporal_storage_stats",
              "fetch_active_policies_for_integrity",
              "fetch_temporal_policies_for_integrity",
              "fetch_ethical_constraints_for_integrity",
              "managed_connection",
              "_conn",
              "_write_conn",
              "fetch_ethical_constraints_auto",
              "fetch_risk_ceilings_auto",
              "fetch_safety_rules_auto",
              "fetch_business_rules_auto",
              "fetch_violations_auto",
              "fetch_violation_by_id_auto",
              "fetch_policy_versions_auto",
              "fetch_current_active_version_auto",
              "fetch_policy_version_by_id_auto",
              "fetch_policy_version_by_id_or_version_auto",
              "fetch_version_for_rollback_auto",
              "fetch_provenance_auto",
              "fetch_dependencies_auto",
              "fetch_dependency_edges_auto",
              "fetch_dependency_edges_with_type_auto",
              "fetch_conflicts_auto",
              "fetch_unresolved_conflicts_auto",
              "fetch_temporal_policies_auto",
              "fetch_temporal_policy_for_utilization_auto",
              "fetch_temporal_metric_sum_auto",
              "fetch_temporal_stats_auto",
              "fetch_temporal_storage_stats_auto",
              "fetch_active_policies_for_integrity_auto",
              "fetch_temporal_policies_for_integrity_auto",
              "fetch_ethical_constraints_for_integrity_auto",
              "insert_evaluation_committed",
              "insert_violation_committed",
              "update_violation_acknowledged_committed",
              "update_risk_ceiling_committed",
              "reset_risk_ceiling_committed",
              "update_safety_rule_committed",
              "deactivate_all_versions_committed",
              "insert_policy_version_committed",
              "mark_version_rolled_back_committed",
              "activate_version_committed",
              "insert_provenance_committed",
              "insert_dependency_committed",
              "resolve_conflict_committed",
              "insert_temporal_policy_committed",
              "delete_old_temporal_events_committed",
              "compact_temporal_events_committed",
              "cap_temporal_events_committed",
              "fetch_snapshot_by_id",
              "fetch_snapshot_by_id_auto",
              "insert_snapshot",
              "insert_snapshot_committed"
            ],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "contextlib",
            "names": [
              "contextmanager"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "sqlalchemy",
            "names": [
              "create_engine",
              "text"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "sqlalchemy.engine",
            "names": [
              "Connection",
              "Engine"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyEngineDriver",
          "get_policy_engine_driver"
        ]
      },
      {
        "file_name": "policy_graph_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_graph_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 226,
        "module_docstring": "Policy Graph Driver (L6 Data Access)\n\nHandles database operations for policy graph computation:\n- Fetching policies for conflict detection\n- Fetching limits for threshold analysis\n- Fetching resolved conflict pairs\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_policy_graph_driver",
            "signature": "(session: AsyncSession) -> PolicyGraphDriver",
            "docstring": "Get a PolicyGraphDriver instance.",
            "is_async": false,
            "line": 224
          }
        ],
        "classes": [
          {
            "name": "PolicyGraphDriver",
            "docstring": "L6 Driver for policy graph data operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (conflict detection, graph computation) stay in L5.",
            "methods": [
              "__init__",
              "fetch_active_policies",
              "fetch_all_policies",
              "fetch_active_limits",
              "fetch_all_limits",
              "fetch_resolved_conflicts"
            ],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_proposal_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_proposal_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 201,
        "module_docstring": "Policy Proposal Read Driver (L6)\n\nPure data access layer for policy proposal read operations.\nNo business logic - only query execution and data retrieval.",
        "functions": [
          {
            "name": "get_policy_proposal_read_driver",
            "signature": "(session: AsyncSession) -> PolicyProposalReadDriver",
            "docstring": "Factory function for PolicyProposalReadDriver.",
            "is_async": false,
            "line": 193
          }
        ],
        "classes": [
          {
            "name": "PolicyProposalReadDriver",
            "docstring": "Read operations for policy proposals.",
            "methods": [
              "__init__",
              "fetch_unacknowledged_feedback",
              "fetch_proposal_by_id",
              "fetch_proposal_status",
              "count_versions_for_proposal",
              "fetch_proposals",
              "check_rule_exists",
              "fetch_rule_by_id"
            ],
            "line": 34
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select",
              "text"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.models.feedback",
            "names": [
              "PatternFeedback"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyProposal",
              "PolicyVersion"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyProposalReadDriver",
          "get_policy_proposal_read_driver"
        ]
      },
      {
        "file_name": "policy_proposal_write_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_proposal_write_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 228,
        "module_docstring": "Policy Proposal Write Driver (L6)\n\nPure data access layer for policy proposal write operations.\nNo business logic - only persistence and mutations.",
        "functions": [
          {
            "name": "get_policy_proposal_write_driver",
            "signature": "(session: AsyncSession) -> PolicyProposalWriteDriver",
            "docstring": "Factory function for PolicyProposalWriteDriver.",
            "is_async": false,
            "line": 218
          }
        ],
        "classes": [
          {
            "name": "PolicyProposalWriteDriver",
            "docstring": "Write operations for policy proposals.",
            "methods": [
              "__init__",
              "create_proposal",
              "update_proposal_status",
              "create_version",
              "create_policy_rule",
              "delete_policy_rule"
            ],
            "line": 35
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyProposal",
              "PolicyVersion"
            ],
            "is_relative": false,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyProposalWriteDriver",
          "get_policy_proposal_write_driver"
        ]
      },
      {
        "file_name": "policy_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 243,
        "module_docstring": "Policy Read Driver (L6)\n\nPure data access layer for customer policy read operations.\nNo business logic - only query construction and data retrieval.\n\nArchitecture:\n    L3 (Adapter) \u2192 L4 (Engine) \u2192 L6 (this driver) \u2192 Database\n\nOperations:\n- Query tenant settings\n- Query usage totals (ProxyCall sum)\n- Query guardrails\n- No mutations (read-only)\n\nReference: PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_policy_read_driver",
            "signature": "(session: Session) -> PolicyReadDriver",
            "docstring": "Get PolicyReadDriver instance.\n\nArgs:\n    session: SQLModel session\n\nReturns:\n    PolicyReadDriver instance",
            "is_async": false,
            "line": 219
          }
        ],
        "classes": [
          {
            "name": "TenantBudgetDataDTO",
            "docstring": "Raw tenant budget settings from database.",
            "methods": [],
            "line": 68
          },
          {
            "name": "UsageSumDTO",
            "docstring": "Raw usage sum from database.",
            "methods": [],
            "line": 76
          },
          {
            "name": "GuardrailDTO",
            "docstring": "Raw guardrail data from database.",
            "methods": [],
            "line": 82
          },
          {
            "name": "PolicyReadDriver",
            "docstring": "L6 driver for customer policy read operations.\n\nPure data access - no business logic.\nAll methods provide raw database data for L4 engine to process.",
            "methods": [
              "__init__",
              "get_tenant_budget_settings",
              "get_usage_sum_since",
              "get_guardrail_by_id",
              "list_all_guardrails",
              "_to_guardrail_dto"
            ],
            "line": 99
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "DefaultGuardrail",
              "ProxyCall"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.models.tenant",
            "names": [
              "Tenant"
            ],
            "is_relative": false,
            "line": 60
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyReadDriver",
          "get_policy_read_driver",
          "TenantBudgetDataDTO",
          "UsageSumDTO",
          "GuardrailDTO"
        ]
      },
      {
        "file_name": "policy_rules_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_rules_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 149,
        "module_docstring": "Policy Rules Driver\n\nPure data access for policy rules table.\nNo business logic - only DB operations.\n\nAuthority: RULE_PERSISTENCE\nTables: policy_rules, policy_rule_integrity",
        "functions": [
          {
            "name": "get_policy_rules_driver",
            "signature": "(session: AsyncSession) -> PolicyRulesDriver",
            "docstring": "Factory function for PolicyRulesDriver.",
            "is_async": false,
            "line": 147
          }
        ],
        "classes": [
          {
            "name": "PolicyRulesDriver",
            "docstring": "Data access driver for policy rules.\n\nINVARIANTS (L6):\n- No business branching\n- No validation\n- No cross-domain calls\n- Pure persistence operations only",
            "methods": [
              "__init__",
              "fetch_rule_by_id",
              "add_rule",
              "add_integrity",
              "create_rule",
              "create_integrity",
              "flush"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_rules_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_rules_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 255,
        "module_docstring": "Policy Rules Read Driver (L6)\n\nPure data access layer for policy rules read operations.\nAll SQLAlchemy queries live here. No business logic.",
        "functions": [
          {
            "name": "get_policy_rules_read_driver",
            "signature": "(session: AsyncSession) -> PolicyRulesReadDriver",
            "docstring": "Factory function for PolicyRulesReadDriver.",
            "is_async": false,
            "line": 247
          }
        ],
        "classes": [
          {
            "name": "PolicyRulesReadDriver",
            "docstring": "Read operations for policy rules.",
            "methods": [
              "__init__",
              "fetch_policy_rules",
              "fetch_policy_rule_by_id",
              "count_policy_rules"
            ],
            "line": 38
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "PolicyEnforcement",
              "PolicyRule",
              "PolicyRuleIntegrity"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyRulesReadDriver",
          "get_policy_rules_read_driver"
        ]
      },
      {
        "file_name": "proposals_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/proposals_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 413,
        "module_docstring": "Proposals Read Driver (L6)\n\nPure data access layer for policy proposals read operations (list view).\nThis driver is for the \"Proposals\" tab in the policies domain.\n\nNote: This is separate from policy_proposal_read_driver.py which handles\nthe proposal lifecycle engine operations.\n\nAll SQLAlchemy queries live here. No business logic.",
        "functions": [
          {
            "name": "get_proposals_read_driver",
            "signature": "(session: AsyncSession) -> ProposalsReadDriver",
            "docstring": "Factory function for ProposalsReadDriver.",
            "is_async": false,
            "line": 405
          }
        ],
        "classes": [
          {
            "name": "ProposalsReadDriver",
            "docstring": "Read operations for policy proposals (list view).",
            "methods": [
              "__init__",
              "fetch_proposals",
              "fetch_proposal_by_id",
              "count_draft_proposals",
              "list_proposals_paginated",
              "get_proposal_stats",
              "get_proposal_detail",
              "list_proposal_versions"
            ],
            "line": 38
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyProposal"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": [
          "ProposalsReadDriver",
          "get_proposals_read_driver"
        ]
      },
      {
        "file_name": "recovery_matcher.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/recovery_matcher.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 1011,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "MatchResult",
            "docstring": "Result from matching a failure to a recovery suggestion.",
            "methods": [],
            "line": 80
          },
          {
            "name": "RecoveryMatcher",
            "docstring": "Matches failures to recovery suggestions using pattern matching\nand confidence scoring.\n\nTransaction Boundary: L6 drivers DO NOT commit.\nThe caller (L5 engine or L4 coordinator) owns the transaction.\nThis driver only calls session.add()/session.execute() \u2014 never session.commit().",
            "methods": [
              "__init__",
              "_normalize_error",
              "_calculate_time_weight",
              "_compute_confidence",
              "_generate_suggestion",
              "_find_similar_failures",
              "_count_occurrences",
              "_get_cached_recovery",
              "_set_cached_recovery",
              "_find_similar_by_embedding",
              "_escalate_to_llm",
              "suggest_hybrid",
              "_upsert_candidate",
              "suggest",
              "get_candidates",
              "count_candidates",
              "count_by_status",
              "approve_candidate"
            ],
            "line": 93
          }
        ],
        "imports": [
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "math",
            "names": [
              "math"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.security.sanitize",
            "names": [
              "sanitize_error_message"
            ],
            "is_relative": false,
            "line": 60
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 32
          },
          {
            "name": "RETRY_POLICY",
            "line": 33
          },
          {
            "name": "HALF_LIFE_DAYS",
            "line": 68
          },
          {
            "name": "EMBEDDING_SIMILARITY_THRESHOLD",
            "line": 69
          },
          {
            "name": "LLM_ESCALATION_THRESHOLD",
            "line": 70
          },
          {
            "name": "CACHE_TTL_SECONDS",
            "line": 71
          },
          {
            "name": "LAMBDA",
            "line": 72
          },
          {
            "name": "ALPHA",
            "line": 73
          },
          {
            "name": "MIN_CONFIDENCE_THRESHOLD",
            "line": 74
          },
          {
            "name": "NO_HISTORY_CONFIDENCE",
            "line": 75
          },
          {
            "name": "EXACT_MATCH_CONFIDENCE",
            "line": 76
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "recovery_write_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/recovery_write_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 265,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "RecoveryWriteService",
            "docstring": "Sync DB write operations for Recovery APIs.\n\nWrite-only facade. No policy logic, no branching beyond DB operations.\nRaw SQL preserved exactly as extracted from API files.",
            "methods": [
              "__init__",
              "upsert_recovery_candidate",
              "get_candidate_by_idempotency_key",
              "enqueue_evaluation_db_fallback",
              "update_recovery_candidate",
              "insert_suggestion_provenance"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 30
          },
          {
            "name": "RETRY_POLICY",
            "line": 31
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "scope_resolver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/scope_resolver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 259,
        "module_docstring": "Scope Resolver Engine\n\nResolves which policies apply to a run based on:\n- Tenant ID (always required)\n- Agent ID (for AGENT scope)\n- API Key ID (for API_KEY scope)\n- Human Actor ID (for HUMAN_ACTOR scope)\n\nResolution happens BEFORE run starts and the result is frozen\ninto the policy snapshot for audit purposes.",
        "functions": [
          {
            "name": "get_scope_resolver",
            "signature": "() -> ScopeResolver",
            "docstring": "Get or create ScopeResolver singleton.",
            "is_async": false,
            "line": 254
          }
        ],
        "classes": [
          {
            "name": "RunContext",
            "docstring": "Context for scope resolution.",
            "methods": [],
            "line": 48
          },
          {
            "name": "ScopeResolutionResult",
            "docstring": "Result of scope resolution.",
            "methods": [
              "to_snapshot"
            ],
            "line": 59
          },
          {
            "name": "ScopeResolver",
            "docstring": "Resolves which policies apply to a given run context.\n\nThe resolver evaluates all active policy scopes for a tenant\nand returns the list of policies that match the run context.",
            "methods": [
              "__init__",
              "resolve_applicable_policies",
              "_load_scopes",
              "matches_scope",
              "get_scope_for_policy",
              "_get_scope"
            ],
            "line": 97
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.db",
            "names": [
              "engine"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.models.policy_scope",
            "names": [
              "PolicyScope",
              "ScopeType"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "symbol_table.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/symbol_table.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 309,
        "module_docstring": "Symbol table for PLang v2.0 compilation.\n\nFeatures:\n- Hierarchical scoping (global, policy, rule, block)\n- Category-aware symbol lookup\n- Governance metadata tracking\n- M19 policy reference resolution",
        "functions": [],
        "classes": [
          {
            "name": "SymbolType",
            "docstring": "Types of symbols in PLang.",
            "methods": [],
            "line": 41
          },
          {
            "name": "Symbol",
            "docstring": "A symbol in the symbol table.\n\nRepresents named entities in PLang: policies, rules, variables, etc.",
            "methods": [
              "__repr__"
            ],
            "line": 54
          },
          {
            "name": "Scope",
            "docstring": "A scope in the symbol table.\n\nScopes form a hierarchy: global -> policy -> rule -> block",
            "methods": [
              "define",
              "lookup",
              "lookup_by_category",
              "get_all_symbols"
            ],
            "line": 79
          },
          {
            "name": "SymbolTable",
            "docstring": "Symbol table for PLang compilation.\n\nManages scopes and symbol resolution with M19 category awareness.",
            "methods": [
              "__init__",
              "_define_builtins",
              "enter_scope",
              "exit_scope",
              "define",
              "lookup",
              "lookup_policy",
              "lookup_rule",
              "get_symbols_by_category",
              "get_policies",
              "get_rules",
              "add_reference",
              "get_unreferenced_symbols",
              "__str__"
            ],
            "line": 131
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 103,
    "violation_count": 0,
    "gap_count": 2
  },
  "controls": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/controls.py",
    "l2_apis": [],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "controls_facade.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/controls_facade.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 438,
        "module_docstring": "Controls Facade (L4 Domain Logic)\n\nThis facade provides the external interface for control operations.\nAll control APIs MUST use this facade instead of directly importing\ninternal control modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes killswitch and control logic\n- Provides unified access to system controls\n- Single point for audit emission\n\nL2 API Routes (GAP-123):\n- GET /api/v1/controls (list controls)\n- GET /api/v1/controls/{id} (get control)\n- PUT /api/v1/controls/{id} (update control)\n- POST /api/v1/controls/{id}/enable (enable control)\n- POST /api/v1/controls/{id}/disable (disable control)\n- GET /api/v1/controls/status (overall status)\n\nUsage:\n    from app.hoc.cus.controls.L5_engines.controls_facade import get_controls_facade\n\n    facade = get_controls_facade()\n\n    # Get control status\n    status = await facade.get_status(tenant_id=\"...\")",
        "functions": [
          {
            "name": "get_controls_facade",
            "signature": "() -> ControlsFacade",
            "docstring": "Get the controls facade instance.\n\nThis is the recommended way to access control operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    ControlsFacade instance",
            "is_async": false,
            "line": 425
          }
        ],
        "classes": [
          {
            "name": "ControlType",
            "docstring": "Types of controls.",
            "methods": [],
            "line": 60
          },
          {
            "name": "ControlState",
            "docstring": "Control state.",
            "methods": [],
            "line": 69
          },
          {
            "name": "ControlConfig",
            "docstring": "Control configuration.",
            "methods": [
              "to_dict"
            ],
            "line": 77
          },
          {
            "name": "ControlStatusSummary",
            "docstring": "Overall control status summary.",
            "methods": [
              "to_dict"
            ],
            "line": 115
          },
          {
            "name": "ControlsFacade",
            "docstring": "Facade for control operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ncontrol services.\n\nLayer: L4 (Domain Logic)\nCallers: controls.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "_ensure_default_controls",
              "list_controls",
              "get_control",
              "update_control",
              "enable_control",
              "disable_control",
              "get_status"
            ],
            "line": 140
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 55
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "threshold_engine.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/threshold_engine.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 694,
        "module_docstring": "Threshold Decision Engine (L5)\n\nProvides:\n- ThresholdParams: Validated threshold configuration (decision contract)\n- LLMRunThresholdResolver: Resolves effective params using precedence rules\n- LLMRunEvaluator: Evaluates runs against thresholds, determines signals\n- Signal helpers: Create and collect threshold signal records\n\nThis engine owns the DECISION logic:\n- Precedence rules (AGENT > PROJECT > TENANT > GLOBAL)\n- Threshold evaluation (compare metrics to limits)\n- Signal determination (which signals to emit)\n\nThe engine does NOT own:\n- Database queries (delegated to ThresholdDriver in L6)\n- Signal persistence (delegated to L6)\n\nReference: ACTIVITY_PHASE2.5_IMPLEMENTATION_PLAN.md",
        "functions": [
          {
            "name": "create_threshold_signal_record",
            "signature": "(tenant_id: str, run_id: str, state: str, signal: ThresholdSignal, params_used: dict) -> ThresholdSignalRecord",
            "docstring": "Create a threshold signal record for activity domain.\n\nThis creates a record that surfaces in:\n- Activity \u2192 LLM Runs \u2192 Live \u2192 Signals\n- Activity \u2192 LLM Runs \u2192 Completed \u2192 Signals\n\nArgs:\n    tenant_id: Tenant identifier\n    run_id: Run identifier\n    state: Run state (live or completed)\n    signal: The threshold signal triggered\n    params_used: The params that were evaluated against\n\nReturns:\n    ThresholdSignalRecord for persistence/emission",
            "is_async": false,
            "line": 624
          },
          {
            "name": "collect_signals_from_evaluation",
            "signature": "(evaluation: ThresholdEvaluationResult, tenant_id: str, state: str) -> list[ThresholdSignalRecord]",
            "docstring": "Collect all signals from an evaluation result into records.\n\nArgs:\n    evaluation: The evaluation result\n    tenant_id: Tenant identifier\n    state: Run state (live or completed)\n\nReturns:\n    List of ThresholdSignalRecord for persistence",
            "is_async": false,
            "line": 667
          }
        ],
        "classes": [
          {
            "name": "ThresholdParams",
            "docstring": "Validated threshold parameters for LLM run governance.\n\nValidation Rules (Hard Stop):\n- max_execution_time_ms: 1000-300000 (1s to 5min)\n- max_tokens: 256-200000\n- max_cost_usd: 0.01-100.00\n- failure_signal: boolean\n\nNo partial garbage. No unknown keys. No absurd values.",
            "methods": [
              "coerce_decimal_to_float"
            ],
            "line": 84
          },
          {
            "name": "ThresholdParamsUpdate",
            "docstring": "Partial update for threshold params.\nAll fields optional - only provided fields are updated.",
            "methods": [],
            "line": 131
          },
          {
            "name": "ThresholdDriverProtocol",
            "docstring": "Protocol defining the interface for threshold drivers.",
            "methods": [
              "get_active_threshold_limits"
            ],
            "line": 166
          },
          {
            "name": "ThresholdDriverSyncProtocol",
            "docstring": "Protocol defining the interface for sync threshold drivers.",
            "methods": [
              "get_active_threshold_limits"
            ],
            "line": 176
          },
          {
            "name": "LLMRunThresholdResolver",
            "docstring": "Resolves effective threshold params for an LLM run\nusing Policy \u2192 Limit \u2192 Threshold precedence.\n\nResolution order (highest to lowest precedence):\n1. Agent-scoped threshold (scope=AGENT, scope_id=agent_id)\n2. Project-scoped threshold (scope=PROJECT, scope_id=project_id)\n3. Tenant-scoped threshold (scope=TENANT)\n4. Global defaults (DEFAULT_LLM_RUN_PARAMS)\n\nProperties:\n- Deterministic\n- Merge-based (higher precedence overrides)\n- Safe if nothing exists\n\nL4 CONTRACT: This class contains ONLY precedence logic.\nDB queries are delegated to the ThresholdDriver (L6).",
            "methods": [
              "__init__",
              "resolve"
            ],
            "line": 191
          },
          {
            "name": "LLMRunEvaluator",
            "docstring": "Evaluates LLM runs against threshold params.\n\nSupports:\n- Live run evaluation (execution time, tokens)\n- Completed run evaluation (all metrics + failure)\n\nSignals are determined but evaluation is non-blocking.\n\nL4 CONTRACT: Pure evaluation logic, no DB operations.",
            "methods": [
              "__init__",
              "evaluate_live_run",
              "evaluate_completed_run"
            ],
            "line": 291
          },
          {
            "name": "LLMRunThresholdResolverSync",
            "docstring": "Sync version of LLMRunThresholdResolver for worker context.\n\nUses ThresholdDriverSync for DB access since the worker runs\nin a ThreadPoolExecutor which doesn't support async.\n\nL4 CONTRACT: Same precedence logic as async version.",
            "methods": [
              "__init__",
              "resolve"
            ],
            "line": 451
          },
          {
            "name": "LLMRunEvaluatorSync",
            "docstring": "Sync version of LLMRunEvaluator for worker context.\n\nUses LLMRunThresholdResolverSync instead of the async resolver.\n\nL4 CONTRACT: Pure evaluation logic, no DB operations.",
            "methods": [
              "__init__",
              "evaluate_completed_run"
            ],
            "line": 527
          },
          {
            "name": "ThresholdSignalRecord",
            "docstring": "Record of a threshold signal for activity domain.\n\nThis structure is used for:\n- Activity \u2192 LLM Runs \u2192 Live \u2192 Signals\n- Activity \u2192 LLM Runs \u2192 Completed \u2192 Signals",
            "methods": [],
            "line": 607
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional",
              "Protocol"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.threshold_signals",
            "names": [
              "ThresholdEvaluationResult",
              "ThresholdSignal"
            ],
            "is_relative": false,
            "line": 155
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_LLM_RUN_PARAMS",
            "line": 71
          }
        ],
        "all_exports": null
      }
    ],
    "l5_schemas": [
      {
        "file_name": "overrides.py",
        "file_path": "backend/app/hoc/cus/controls/L5_schemas/overrides.py",
        "layer": "L5_schemas",
        "domain": "controls",
        "lines": 188,
        "module_docstring": "Limit Override Schemas (PIN-LIM-05)\n\nRequest and response models for temporary limit increases.\nOverrides allow customers to request and apply temporary limit increases\nwith proper audit trail.",
        "functions": [],
        "classes": [
          {
            "name": "OverrideStatus",
            "docstring": "Override lifecycle status.",
            "methods": [],
            "line": 29
          },
          {
            "name": "LimitOverrideRequest",
            "docstring": "Request model for requesting a temporary limit override.",
            "methods": [
              "validate_override_value"
            ],
            "line": 39
          },
          {
            "name": "LimitOverrideResponse",
            "docstring": "Response model for limit override operations.",
            "methods": [],
            "line": 81
          },
          {
            "name": "OverrideApprovalRequest",
            "docstring": "Request model for approving/rejecting an override.",
            "methods": [
              "validate_rejection_reason"
            ],
            "line": 146
          },
          {
            "name": "OverrideListResponse",
            "docstring": "Response model for listing overrides.",
            "methods": [],
            "line": 176
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_limits.py",
        "file_path": "backend/app/hoc/cus/controls/L5_schemas/policy_limits.py",
        "layer": "L5_schemas",
        "domain": "controls",
        "lines": 190,
        "module_docstring": "Policy Limits Schemas (PIN-LIM-01)\n\nRequest and response models for policy limit CRUD operations.\nEnforces schema contract between API and service layer.",
        "functions": [],
        "classes": [
          {
            "name": "LimitCategoryEnum",
            "docstring": "Limit categories.",
            "methods": [],
            "line": 28
          },
          {
            "name": "LimitScopeEnum",
            "docstring": "Limit scope levels.",
            "methods": [],
            "line": 35
          },
          {
            "name": "LimitEnforcementEnum",
            "docstring": "Limit enforcement behaviors.",
            "methods": [],
            "line": 44
          },
          {
            "name": "ResetPeriodEnum",
            "docstring": "Budget limit reset periods.",
            "methods": [],
            "line": 54
          },
          {
            "name": "CreatePolicyLimitRequest",
            "docstring": "Request model for creating a policy limit.",
            "methods": [
              "validate_reset_period",
              "validate_window_seconds"
            ],
            "line": 62
          },
          {
            "name": "UpdatePolicyLimitRequest",
            "docstring": "Request model for updating a policy limit.",
            "methods": [],
            "line": 131
          },
          {
            "name": "PolicyLimitResponse",
            "docstring": "Response model for policy limit operations.",
            "methods": [],
            "line": 170
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 25
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "simulation.py",
        "file_path": "backend/app/hoc/cus/controls/L5_schemas/simulation.py",
        "layer": "L5_schemas",
        "domain": "controls",
        "lines": 217,
        "module_docstring": "Limit Simulation Schemas (PIN-LIM-04)\n\nRequest and response models for pre-execution limit checks.\nThe simulation endpoint allows dry-run verification against all limits\nbefore actually executing a run.",
        "functions": [],
        "classes": [
          {
            "name": "SimulationDecision",
            "docstring": "Simulation outcome decision.",
            "methods": [],
            "line": 28
          },
          {
            "name": "MessageCode",
            "docstring": "Standardized message codes (no free-text messages).",
            "methods": [],
            "line": 35
          },
          {
            "name": "LimitSimulationRequest",
            "docstring": "Request model for limit simulation (pre-execution check).",
            "methods": [],
            "line": 60
          },
          {
            "name": "LimitCheckResult",
            "docstring": "Result of a single limit check.",
            "methods": [],
            "line": 108
          },
          {
            "name": "HeadroomInfo",
            "docstring": "Remaining headroom before hitting limits.",
            "methods": [],
            "line": 141
          },
          {
            "name": "LimitWarning",
            "docstring": "Warning for soft limit approaching.",
            "methods": [],
            "line": 158
          },
          {
            "name": "LimitSimulationResponse",
            "docstring": "Response model for limit simulation.",
            "methods": [],
            "line": 176
          }
        ],
        "imports": [
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 25
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "budget_enforcement_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/budget_enforcement_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 124,
        "module_docstring": "Budget Enforcement Driver (L6 Data Access)\n\nHandles database operations for budget enforcement:\n- Fetching halted runs that lack decision records\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_budget_enforcement_driver",
            "signature": "(db_url: Optional[str] = None) -> BudgetEnforcementDriver",
            "docstring": "Get a BudgetEnforcementDriver instance.",
            "is_async": false,
            "line": 122
          }
        ],
        "classes": [
          {
            "name": "BudgetEnforcementDriver",
            "docstring": "L6 Driver for budget enforcement data operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (parsing, emit logic) stay in L4.",
            "methods": [
              "__init__",
              "_get_engine",
              "fetch_pending_budget_halts",
              "dispose"
            ],
            "line": 45
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlalchemy",
            "names": [
              "create_engine",
              "text"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "limits_read_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/limits_read_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 322,
        "module_docstring": "Limits Read Driver (L6)\n\nPure data access layer for limits read operations.\nAll SQLAlchemy queries live here. No business logic.",
        "functions": [
          {
            "name": "get_limits_read_driver",
            "signature": "(session: AsyncSession) -> LimitsReadDriver",
            "docstring": "Factory function for LimitsReadDriver.",
            "is_async": false,
            "line": 314
          }
        ],
        "classes": [
          {
            "name": "LimitsReadDriver",
            "docstring": "Read operations for limits.",
            "methods": [
              "__init__",
              "fetch_limits",
              "fetch_limit_by_id",
              "fetch_budget_limits",
              "fetch_limit_breaches_for_run"
            ],
            "line": 33
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitBreach",
              "LimitIntegrity"
            ],
            "is_relative": false,
            "line": 30
          }
        ],
        "constants": [],
        "all_exports": [
          "LimitsReadDriver",
          "get_limits_read_driver"
        ]
      },
      {
        "file_name": "override_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/override_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 295,
        "module_docstring": "Limit Override Driver (PIN-LIM-05)\n\nL6 driver for limit_overrides table. All persistence logic\nfor temporary limit overrides lives here.\n\nL6 contract:\n- Receives AsyncSession from caller (L5 or L4 coordinator)\n- NEVER commits \u2014 caller owns transaction\n- Returns domain objects (LimitOverrideResponse) or raises typed errors",
        "functions": [],
        "classes": [
          {
            "name": "LimitOverrideService",
            "docstring": "Driver for limit override lifecycle.\n\nINVARIANTS:\n- One override per limit (no stacking)\n- Override cannot exceed plan quota cap\n- Max 5 active overrides per tenant\n- All overrides require justification\n\nTransaction contract:\n- All methods receive an AsyncSession\n- No method calls session.commit()\n- Caller (L4 coordinator) owns commit authority",
            "methods": [
              "__init__",
              "request_override",
              "get_override",
              "list_overrides",
              "cancel_override",
              "_get_limit",
              "_to_response"
            ],
            "line": 59
          }
        ],
        "imports": [
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitOverride"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.overrides",
            "names": [
              "LimitOverrideRequest",
              "LimitOverrideResponse",
              "OverrideStatus"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.override_types",
            "names": [
              "LimitOverrideServiceError",
              "LimitNotFoundError",
              "OverrideNotFoundError",
              "OverrideValidationError",
              "StackingAbuseError"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_limits_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/policy_limits_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 131,
        "module_docstring": "Policy Limits Driver\n\nPure data access for policy limits table.\nNo business logic - only DB operations.\n\nAuthority: LIMIT_PERSISTENCE\nTables: limits, limit_integrity",
        "functions": [
          {
            "name": "get_policy_limits_driver",
            "signature": "(session: AsyncSession) -> PolicyLimitsDriver",
            "docstring": "Factory function for PolicyLimitsDriver.",
            "is_async": false,
            "line": 129
          }
        ],
        "classes": [
          {
            "name": "PolicyLimitsDriver",
            "docstring": "Data access driver for policy limits.\n\nINVARIANTS (L6):\n- No business branching\n- No validation\n- No cross-domain calls\n- Pure persistence operations only",
            "methods": [
              "__init__",
              "fetch_limit_by_id",
              "add_limit",
              "add_integrity",
              "create_limit",
              "create_integrity",
              "flush"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "threshold_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/threshold_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 332,
        "module_docstring": "Threshold Driver (L6)\n\nProvides:\n- LimitSnapshot: Immutable snapshot returned to engines\n- ThresholdDriver: Async DB operations for threshold limits\n- ThresholdDriverSync: Sync DB operations for worker context\n- Signal emission functions for dual console output\n\nThis driver owns the DATA ACCESS logic:\n- Query active threshold limits from database\n- Emit signals to ops_events table\n- Update run risk levels\n\nThe driver does NOT own:\n- Precedence resolution (delegated to L4 engine)\n- Threshold evaluation (delegated to L4 engine)\n- Signal determination (delegated to L4 engine)\n\nReference: ACTIVITY_PHASE2.5_IMPLEMENTATION_PLAN.md",
        "functions": [
          {
            "name": "emit_threshold_signal_sync",
            "signature": "(session: Any, tenant_id: str, run_id: str, state: str, signal: Any, params_used: dict) -> None",
            "docstring": "Emit a threshold signal to ops_events table (sync).\n\nFor use in sync contexts (e.g., worker callbacks).\n\nL6 CONTRACT: Pure DB write, no business logic.\n\nArgs:\n    session: Sync SQLAlchemy Session\n    tenant_id: Tenant identifier\n    run_id: Run identifier\n    state: Run state (live or completed)\n    signal: ThresholdSignal enum value\n    params_used: The params that were evaluated against",
            "is_async": false,
            "line": 259
          }
        ],
        "classes": [
          {
            "name": "LimitSnapshot",
            "docstring": "Immutable snapshot of a Limit record returned to engines.\n\nThis is the boundary contract between L6 (driver) and L5 (engine).\nEngines receive snapshots, not ORM models.\n\nNOTE: This DTO intentionally lives here to avoid L6 importing hoc_spine\n(T0 law tests: no cross-domain imports from L6).",
            "methods": [],
            "line": 69
          },
          {
            "name": "ThresholdDriver",
            "docstring": "Async database driver for threshold limit operations.\n\nL6 CONTRACT:\n- Pure data access, no business logic\n- Returns LimitSnapshot objects, not ORM models\n- No precedence resolution (that's L4)",
            "methods": [
              "__init__",
              "get_active_threshold_limits",
              "get_threshold_limit_by_scope"
            ],
            "line": 94
          },
          {
            "name": "ThresholdDriverSync",
            "docstring": "Sync database driver for threshold limit operations.\n\nUsed in worker context (ThreadPoolExecutor) which doesn't support async.\n\nL6 CONTRACT:\n- Pure data access, no business logic\n- Returns LimitSnapshot objects\n- Uses raw SQL for sync compatibility",
            "methods": [
              "__init__",
              "get_active_threshold_limits"
            ],
            "line": 194
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "uuid",
            "names": [
              "uuid_module"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "sqlmodel",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitCategory",
              "LimitStatus"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 10,
    "violation_count": 0,
    "gap_count": 3
  },
  "logs": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/logs.py",
    "l2_apis": [
      {
        "file_name": "cost_intelligence.py",
        "file_path": "backend/app/hoc/api/cus/logs/cost_intelligence.py",
        "layer": "L2_api",
        "domain": "logs",
        "lines": 903,
        "module_docstring": "M26 Cost Intelligence API\n\nCore Objective:\nEvery token spent is attributable to tenant -> user -> feature -> request.\nEvery anomaly must trigger an action, not a chart.\n\nThis is not reporting. This is CONTROL.\n\nL2 PURITY:\n- No session.execute() calls in this file\n- All DB operations routed through L4 bridge -> L5 engine -> L6 driver\n- L2 is thin: validation, response mapping, and routing only",
        "functions": [
          {
            "name": "_get_cost_write_service",
            "signature": "(session)",
            "docstring": "Get cost write service via L4 analytics bridge (PIN-520 compliance).",
            "is_async": false,
            "line": 51
          },
          {
            "name": "_get_cost_intelligence_engine",
            "signature": "(session)",
            "docstring": "Get cost intelligence engine via L4 logs bridge (L2 purity migration).",
            "is_async": false,
            "line": 57
          },
          {
            "name": "get_tenant_id",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID')) -> str",
            "docstring": "Extract tenant_id from query parameter.",
            "is_async": false,
            "line": 63
          },
          {
            "name": "create_feature_tag",
            "signature": "(data: FeatureTagCreate, tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> FeatureTagResponse",
            "docstring": "Register a new feature tag.\n\nFeature tags are MANDATORY for cost attribution.\nNo tag -> request defaulted to 'unclassified' (and flagged).",
            "is_async": true,
            "line": 306
          },
          {
            "name": "list_feature_tags",
            "signature": "(include_inactive: bool = False, tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> List[FeatureTagResponse]",
            "docstring": "List all feature tags for the tenant.",
            "is_async": true,
            "line": 355
          },
          {
            "name": "update_feature_tag",
            "signature": "(tag: str, data: FeatureTagUpdate, tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> FeatureTagResponse",
            "docstring": "Update a feature tag.",
            "is_async": true,
            "line": 381
          },
          {
            "name": "record_cost",
            "signature": "(data: CostRecordCreate, tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> dict",
            "docstring": "Record a cost entry.\n\nThis is called internally after each LLM invocation.\nFeature tag validation: if tag doesn't exist, default to 'unclassified'.",
            "is_async": true,
            "line": 424
          },
          {
            "name": "get_cost_dashboard",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostDashboard",
            "docstring": "Get complete cost dashboard.\n\nIf a CTO can't answer \"what burned money yesterday?\" in 10 seconds, this failed.",
            "is_async": true,
            "line": 469
          },
          {
            "name": "get_cost_summary",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostSummary",
            "docstring": "Get cost summary for the period.",
            "is_async": true,
            "line": 540
          },
          {
            "name": "get_costs_by_feature",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostByFeatureEnvelope",
            "docstring": "Get cost breakdown by feature tag.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 576
          },
          {
            "name": "get_costs_by_user",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostByUserEnvelope",
            "docstring": "Get cost breakdown by user with anomaly detection.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 611
          },
          {
            "name": "get_costs_by_model",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostByModelEnvelope",
            "docstring": "Get cost breakdown by model.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 646
          },
          {
            "name": "get_anomalies",
            "signature": "(days: int = Query(7, ge=1, le=90), include_resolved: bool = False, tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostAnomaliesEnvelope",
            "docstring": "Get detected cost anomalies.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 680
          },
          {
            "name": "get_projection",
            "signature": "(lookback_days: int = Query(7, ge=1, le=30), forecast_days: int = Query(7, ge=1, le=30), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> CostProjection",
            "docstring": "Get cost projection based on historical data.",
            "is_async": true,
            "line": 709
          },
          {
            "name": "create_or_update_budget",
            "signature": "(data: BudgetCreate, tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> BudgetResponse",
            "docstring": "Create or update a budget.",
            "is_async": true,
            "line": 727
          },
          {
            "name": "list_budgets",
            "signature": "(tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> List[BudgetResponse]",
            "docstring": "List all budgets for the tenant.",
            "is_async": true,
            "line": 784
          },
          {
            "name": "trigger_anomaly_detection",
            "signature": "(request: AnomalyDetectionRequest = AnomalyDetectionRequest(), tenant_id: str = Depends(get_tenant_id), session = Depends(get_sync_session_dep)) -> AnomalyDetectionResponse",
            "docstring": "Trigger anomaly detection for this tenant.\n\nThis endpoint:\n1. Scans for USER_SPIKE, FEATURE_SPIKE, BUDGET_WARNING, BUDGET_EXCEEDED\n2. Persists detected anomalies to database\n3. Optionally escalates HIGH/CRITICAL anomalies to M25 incident loop\n\nM25 Integration:\nWhen escalate_to_m25=True (default), HIGH and CRITICAL anomalies are:\n- Converted to M25 incidents\n- Processed through the M25 loop (Pattern -> Recovery -> Policy -> Routing)\n- Resulting in automated policies to prevent future cost anomalies",
            "is_async": true,
            "line": 835
          }
        ],
        "classes": [
          {
            "name": "FeatureTagCreate",
            "docstring": "Create a new feature tag.",
            "methods": [],
            "line": 78
          },
          {
            "name": "FeatureTagResponse",
            "docstring": "Feature tag response.",
            "methods": [],
            "line": 87
          },
          {
            "name": "FeatureTagUpdate",
            "docstring": "Update a feature tag.",
            "methods": [],
            "line": 101
          },
          {
            "name": "CostRecordCreate",
            "docstring": "Record a cost entry.",
            "methods": [],
            "line": 110
          },
          {
            "name": "CostProvenance",
            "docstring": "Provenance metadata for cost interpretation panels.",
            "methods": [],
            "line": 124
          },
          {
            "name": "CostSummary",
            "docstring": "Cost summary for a period.",
            "methods": [],
            "line": 133
          },
          {
            "name": "CostByFeature",
            "docstring": "Cost breakdown by feature.",
            "methods": [],
            "line": 149
          },
          {
            "name": "CostByUser",
            "docstring": "Cost breakdown by user.",
            "methods": [],
            "line": 161
          },
          {
            "name": "CostByModel",
            "docstring": "Cost breakdown by model.",
            "methods": [],
            "line": 172
          },
          {
            "name": "CostProjection",
            "docstring": "Cost projection for upcoming period.",
            "methods": [],
            "line": 183
          },
          {
            "name": "CostAnomalyResponse",
            "docstring": "Cost anomaly response.",
            "methods": [],
            "line": 197
          },
          {
            "name": "AnalyticsProvenance",
            "docstring": "Provenance envelope for analytics interpretation panels.\n\nSDSR requires provenance metadata on all interpretation panels to ensure\nthe UI can correctly display how data was derived.",
            "methods": [],
            "line": 221
          },
          {
            "name": "CostByUserEnvelope",
            "docstring": "Envelope response for cost by user with provenance.",
            "methods": [],
            "line": 234
          },
          {
            "name": "CostByModelEnvelope",
            "docstring": "Envelope response for cost by model with provenance.",
            "methods": [],
            "line": 241
          },
          {
            "name": "CostByFeatureEnvelope",
            "docstring": "Envelope response for cost by feature with provenance.",
            "methods": [],
            "line": 248
          },
          {
            "name": "CostAnomaliesEnvelope",
            "docstring": "Envelope response for cost anomalies with provenance.",
            "methods": [],
            "line": 255
          },
          {
            "name": "CostDashboard",
            "docstring": "Complete cost dashboard data.",
            "methods": [],
            "line": 262
          },
          {
            "name": "BudgetCreate",
            "docstring": "Create or update a budget.",
            "methods": [],
            "line": 273
          },
          {
            "name": "BudgetResponse",
            "docstring": "Budget response.",
            "methods": [],
            "line": 284
          },
          {
            "name": "AnomalyDetectionRequest",
            "docstring": "Request to trigger anomaly detection.",
            "methods": [],
            "line": 819
          },
          {
            "name": "AnomalyDetectionResponse",
            "docstring": "Response from anomaly detection.",
            "methods": [],
            "line": 825
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_sync_session_dep"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges.analytics_bridge",
            "names": [
              "get_analytics_bridge"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges.logs_bridge",
            "names": [
              "get_logs_bridge"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard_logs.py",
        "file_path": "backend/app/hoc/api/cus/logs/guard_logs.py",
        "layer": "L2_api",
        "domain": "logs",
        "lines": 215,
        "module_docstring": "Guard Logs API - Customer Console Logs Endpoint\n\nThis router provides endpoints for the Customer Console (guard.agenticverz.com).\nFocused on LOG VISIBILITY - customers can see their execution audit trail.\n\nEndpoints:\n- GET  /guard/logs          - List customer logs (execution audit trail)\n- GET  /guard/logs/export   - Export logs (JSON or CSV)\n- GET  /guard/logs/{id}     - Log detail with steps\n\nPIN-281 Promotion:\n- L4\u2192L3: customer_logs_adapter.py (boundary adapter)\n- L3\u2192L2: This file (API route)\n\nRule: One adapter per route. No business logic here.",
        "functions": [
          {
            "name": "list_logs",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID (required)'), agent_id: Optional[str] = Query(None, description='Filter by agent ID'), status: Optional[str] = Query(None, description='Filter by status (running, completed, failed)'), from_date: Optional[str] = Query(None, description='Filter from date (ISO format)'), to_date: Optional[str] = Query(None, description='Filter to date (ISO format)'), limit: int = Query(50, le=100, description='Page size (max 100)'), offset: int = Query(0, ge=0, description='Pagination offset'))",
            "docstring": "List execution logs for customer.\n\nReturns paginated list of customer logs (execution audit trail).\nCustomer can only see their own tenant's logs (enforced by adapter).\n\nThis endpoint:\n- Shows what ran / is running\n- Provides step counts and status\n- Enables filtering by agent, status, date range\n- Supports pagination\n\nNo internal fields exposed (cost_cents, hashes, replay data).\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 67
          },
          {
            "name": "export_logs",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID (required)'), format: str = Query('json', description='Export format (json, csv)'), from_date: Optional[str] = Query(None, description='Filter from date (ISO format)'), to_date: Optional[str] = Query(None, description='Filter to date (ISO format)'), limit: int = Query(1000, le=10000, description='Max records (max 10000)'))",
            "docstring": "Export logs for customer.\n\nReturns logs in requested format (JSON or CSV).\nCustomer can only export their own tenant's logs (enforced by adapter).\n\nSupports:\n- JSON format (default)\n- CSV format for spreadsheet import\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 116
          },
          {
            "name": "get_log",
            "signature": "(log_id: str, tenant_id: str = Query(..., description='Tenant ID (required)'))",
            "docstring": "Get log detail with execution steps.\n\nReturns detailed view of a single log including all steps.\nCustomer can only see their own tenant's logs (enforced by adapter).\n\nThis endpoint:\n- Shows step-by-step execution trace\n- Shows outcome categories and codes\n- Shows duration per step\n- No cost or internal hash data\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 178
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi.responses",
            "names": [
              "StreamingResponse"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.adapters.customer_logs_adapter",
            "names": [
              "CustomerLogDetail",
              "CustomerLogListResponse",
              "get_customer_logs_adapter"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "verify_console_token"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "tenants.py",
        "file_path": "backend/app/hoc/api/cus/logs/tenants.py",
        "layer": "L2_api",
        "domain": "logs",
        "lines": 677,
        "module_docstring": "Tenant & API Key Management API (M21)\n\nProvides:\n- Tenant management endpoints\n- API key CRUD operations\n- Usage and quota queries\n- Worker registry endpoints",
        "functions": [
          {
            "name": "get_services",
            "signature": "(session = Depends(get_sync_session_dep))",
            "docstring": "Get worker registry and session for route handlers.",
            "is_async": false,
            "line": 52
          },
          {
            "name": "_tenant_op",
            "signature": "(session, tenant_id: str, method: str, **kwargs)",
            "docstring": "Execute a tenant operation via L4 registry (account.tenant).",
            "is_async": true,
            "line": 68
          },
          {
            "name": "_api_keys_op",
            "signature": "(session, tenant_id: str, method: str, **kwargs)",
            "docstring": "Execute an API keys operation via L4 registry (api_keys.write).",
            "is_async": true,
            "line": 81
          },
          {
            "name": "_maybe_advance_to_api_key_created",
            "signature": "(tenant_id: str) -> None",
            "docstring": "PIN-399: Trigger onboarding state transition on first API key creation.\n\nCalled after successful API key creation to potentially advance\na tenant from IDENTITY_VERIFIED to API_KEY_CREATED.\n\nTRIGGER: First successful API key creation.\n\nThis is idempotent - if tenant is already at or past API_KEY_CREATED,\nthis is a no-op.",
            "is_async": true,
            "line": 97
          },
          {
            "name": "get_current_tenant",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Get information about the current tenant (from API key).",
            "is_async": true,
            "line": 286
          },
          {
            "name": "get_tenant_usage",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Get usage summary for the current tenant.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 317
          },
          {
            "name": "check_run_quota",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Check if the tenant can create a new run.",
            "is_async": true,
            "line": 348
          },
          {
            "name": "check_token_quota",
            "signature": "(tokens_needed: int = Query(default=10000, ge=1), ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Check if the tenant has token budget for an operation.",
            "is_async": true,
            "line": 372
          },
          {
            "name": "list_api_keys",
            "signature": "(include_revoked: bool = False, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "List all API keys for the current tenant.\n\nRequires admin permission.",
            "is_async": true,
            "line": 400
          },
          {
            "name": "create_api_key",
            "signature": "(request: APIKeyCreateRequest, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Create a new API key for the current tenant.\n\n**Important:** The full API key is only shown once in this response.\nStore it securely!\n\nRequires admin permission.",
            "is_async": true,
            "line": 439
          },
          {
            "name": "revoke_api_key",
            "signature": "(key_id: str, reason: str = Query(default='Manual revocation'), ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Revoke an API key.\n\nThe key cannot be un-revoked. Create a new key instead.\n\nRequires admin permission.",
            "is_async": true,
            "line": 491
          },
          {
            "name": "list_workers",
            "signature": "(status: Optional[str] = None, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "List all available workers.",
            "is_async": true,
            "line": 522
          },
          {
            "name": "list_available_workers_for_tenant",
            "signature": "(include_disabled: bool = False, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "List workers available to the current tenant with their configurations.",
            "is_async": true,
            "line": 535
          },
          {
            "name": "get_worker_details",
            "signature": "(worker_id: str, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Get detailed information about a specific worker.",
            "is_async": true,
            "line": 551
          },
          {
            "name": "get_worker_config",
            "signature": "(worker_id: str, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Get the effective configuration for a worker (tenant overrides merged with defaults).",
            "is_async": true,
            "line": 567
          },
          {
            "name": "set_worker_config",
            "signature": "(worker_id: str, request: WorkerConfigRequest, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Set tenant-specific configuration for a worker.\n\nRequires admin permission.",
            "is_async": true,
            "line": 583
          },
          {
            "name": "list_runs",
            "signature": "(limit: int = Query(default=20, ge=1, le=100), offset: int = Query(default=0, ge=0), status: Optional[str] = None, worker_id: Optional[str] = None, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "List runs for the current tenant.",
            "is_async": true,
            "line": 623
          },
          {
            "name": "tenant_health",
            "signature": "()",
            "docstring": "Health check for tenant system.",
            "is_async": true,
            "line": 663
          }
        ],
        "classes": [
          {
            "name": "TenantResponse",
            "docstring": "Tenant information response.",
            "methods": [],
            "line": 140
          },
          {
            "name": "APIKeyCreateRequest",
            "docstring": "Request to create an API key.",
            "methods": [],
            "line": 159
          },
          {
            "name": "APIKeyResponse",
            "docstring": "API key information (without the actual key).",
            "methods": [],
            "line": 170
          },
          {
            "name": "APIKeyCreatedResponse",
            "docstring": "Response when creating an API key (includes the key once).",
            "methods": [],
            "line": 183
          },
          {
            "name": "AnalyticsProvenance",
            "docstring": "Provenance envelope for analytics interpretation panels.\n\nSDSR requires provenance metadata on all interpretation panels to ensure\nthe UI can correctly display how data was derived.",
            "methods": [],
            "line": 189
          },
          {
            "name": "UsageSummaryResponse",
            "docstring": "Usage summary for a tenant with provenance for SDSR ANALYTICS domain.",
            "methods": [],
            "line": 202
          },
          {
            "name": "WorkerSummaryResponse",
            "docstring": "Worker summary information.",
            "methods": [],
            "line": 212
          },
          {
            "name": "WorkerDetailResponse",
            "docstring": "Detailed worker information.",
            "methods": [],
            "line": 225
          },
          {
            "name": "WorkerConfigRequest",
            "docstring": "Request to configure a worker for a tenant.",
            "methods": [],
            "line": 236
          },
          {
            "name": "WorkerConfigResponse",
            "docstring": "Worker configuration response.",
            "methods": [],
            "line": 246
          },
          {
            "name": "RunHistoryItem",
            "docstring": "Run history item.",
            "methods": [],
            "line": 257
          },
          {
            "name": "QuotaCheckResponse",
            "docstring": "Quota check response.",
            "methods": [],
            "line": 272
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "status"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_sync_session_dep"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.coordinators.bridges",
            "names": [
              "get_integrations_driver_bridge"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict",
              "wrap_list"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "traces.py",
        "file_path": "backend/app/hoc/api/cus/logs/traces.py",
        "layer": "L2_api",
        "domain": "logs",
        "lines": 910,
        "module_docstring": "Trace Query API\nM8 Deliverable: Trace storage, indexing, and query endpoints\n\nProvides REST API for:\n- Listing and searching traces\n- Getting trace details\n- Finding traces by root_hash (for replay verification)\n- Comparing traces for determinism validation\n- RBAC-protected access via JWT/OIDC\n- PII redaction on storage",
        "functions": [
          {
            "name": "get_current_user",
            "signature": "(request: Request, token: TokenPayload = Depends(_jwt_auth)) -> User",
            "docstring": "Get current authenticated user from JWT token.\n\nSupports:\n- Bearer JWT tokens (OIDC/Keycloak)\n- X-API-Key header (legacy/backwards compatible)\n- Development tokens (dev:xxx prefix)",
            "is_async": true,
            "line": 115
          },
          {
            "name": "require_role",
            "signature": "(user: User, role: str) -> bool",
            "docstring": "Check if user has required role.",
            "is_async": false,
            "line": 127
          },
          {
            "name": "get_trace_store",
            "signature": "() -> TraceStoreType",
            "docstring": "Get the trace store instance.",
            "is_async": false,
            "line": 139
          },
          {
            "name": "list_traces",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant ID'), agent_id: Optional[str] = Query(None, description='Filter by agent ID'), status: Optional[str] = Query(None, description='Filter by status'), root_hash: Optional[str] = Query(None, description='Filter by root hash'), plan_hash: Optional[str] = Query(None, description='Filter by plan hash'), seed: Optional[int] = Query(None, description='Filter by random seed'), from_date: Optional[str] = Query(None, description='Filter from date (ISO8601)'), to_date: Optional[str] = Query(None, description='Filter to date (ISO8601)'), limit: int = Query(100, ge=1, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "List and search traces with optional filters.\n\nRBAC: Users can only see traces from their tenant unless admin.",
            "is_async": true,
            "line": 249
          },
          {
            "name": "store_trace",
            "signature": "(request: StoreTraceRequest, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Store a client-provided trace.\n\nApplies PII redaction before storage.",
            "is_async": true,
            "line": 316
          },
          {
            "name": "list_all_mismatches",
            "signature": "(window: Optional[str] = Query(None, description='Time window (e.g., 24h, 7d)'), status: Optional[str] = Query(None, regex='^(open|resolved)$', description='Filter by status'), limit: int = Query(100, le=500, description='Max results'))",
            "docstring": "List all trace mismatches across the system.\n\nREAD-ONLY endpoint for observability. No side effects.\nReturns mismatches with summary counts.\n\nAuth: OBSERVER-safe (SDSR compatible)",
            "is_async": true,
            "line": 368
          },
          {
            "name": "get_trace",
            "signature": "(run_id: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Get a complete trace by run ID.\n\nRBAC: Users can only access their tenant's traces.",
            "is_async": true,
            "line": 407
          },
          {
            "name": "get_trace_by_hash",
            "signature": "(root_hash: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Get a trace by its deterministic root hash.\n\nUseful for replay verification.",
            "is_async": true,
            "line": 465
          },
          {
            "name": "compare_traces",
            "signature": "(run_id1: str, run_id2: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Compare two traces for deterministic equality.\n\nCompares root_hash and step hashes to verify replay parity.",
            "is_async": true,
            "line": 521
          },
          {
            "name": "delete_trace",
            "signature": "(run_id: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Delete a trace by run ID.\n\nRBAC: Requires admin or operator role.",
            "is_async": true,
            "line": 626
          },
          {
            "name": "cleanup_old_traces",
            "signature": "(days: int = Query(30, ge=1, le=365, description='Delete traces older than N days'), store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Delete traces older than specified number of days.\n\nRBAC: Requires admin role.",
            "is_async": true,
            "line": 651
          },
          {
            "name": "check_idempotency",
            "signature": "(idempotency_key: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Check if an idempotency key has been executed.\n\nReturns execution status and output if found.",
            "is_async": true,
            "line": 677
          },
          {
            "name": "bulk_report_mismatches",
            "signature": "(mismatch_ids: List[str] = Query(..., description='List of mismatch IDs to link'), github_issue: bool = Query(True, description='Create a GitHub issue for all'), user: User = Depends(get_current_user))",
            "docstring": "Create a single GitHub issue for multiple mismatches.\n\nUseful when a replay causes multiple step mismatches that should be tracked together.\n\nRBAC: Requires admin or operator role.",
            "is_async": true,
            "line": 733
          },
          {
            "name": "report_mismatch",
            "signature": "(trace_id: str, payload: MismatchReport, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Report a replay mismatch for operator review.\n\nThis endpoint:\n1. Records the mismatch in the database\n2. Optionally creates a GitHub issue or sends a Slack notification\n3. Returns the mismatch ID for tracking\n\nRBAC: Requires authenticated user. Only allows reporting mismatches for user's tenant.",
            "is_async": true,
            "line": 777
          },
          {
            "name": "list_trace_mismatches",
            "signature": "(trace_id: str, user: User = Depends(get_current_user))",
            "docstring": "List all mismatches reported for a trace.",
            "is_async": true,
            "line": 835
          },
          {
            "name": "resolve_mismatch",
            "signature": "(trace_id: str, mismatch_id: str, resolution_note: Optional[str] = Query(None, description='Optional note about the resolution'), user: User = Depends(get_current_user))",
            "docstring": "Mark a mismatch as resolved.\n\nRBAC: Requires admin or operator role.",
            "is_async": true,
            "line": 871
          }
        ],
        "classes": [
          {
            "name": "User",
            "docstring": "User model for RBAC - wraps JWT TokenPayload for backwards compatibility.",
            "methods": [
              "__init__",
              "has_role",
              "from_token"
            ],
            "line": 83
          },
          {
            "name": "TraceSummaryResponse",
            "docstring": "Trace summary for list views.",
            "methods": [],
            "line": 155
          },
          {
            "name": "TraceStepResponse",
            "docstring": "Individual trace step.",
            "methods": [],
            "line": 175
          },
          {
            "name": "TraceDetailResponse",
            "docstring": "Full trace with all steps.",
            "methods": [],
            "line": 196
          },
          {
            "name": "TraceListResponse",
            "docstring": "Paginated trace list.",
            "methods": [],
            "line": 217
          },
          {
            "name": "TraceCompareResponse",
            "docstring": "Result of comparing two traces.",
            "methods": [],
            "line": 226
          },
          {
            "name": "StoreTraceRequest",
            "docstring": "Request to store a client-provided trace.",
            "methods": [],
            "line": 236
          },
          {
            "name": "MismatchReport",
            "docstring": "Report a replay mismatch for operator review.",
            "methods": [],
            "line": 711
          },
          {
            "name": "MismatchResponse",
            "docstring": "Response after reporting a mismatch.",
            "methods": [],
            "line": 721
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request",
              "Response",
              "status"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.jwt_auth",
            "names": [
              "JWTAuthDependency",
              "JWTConfig",
              "TokenPayload"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_async_session_context",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.traces.redact",
            "names": [
              "redact_trace_data"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.handlers.traces_handler",
            "names": [
              "register_traces_handlers"
            ],
            "is_relative": false,
            "line": 66
          }
        ],
        "constants": [
          {
            "name": "USE_POSTGRES",
            "line": 43
          }
        ],
        "all_exports": null
      }
    ],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "audit_evidence.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/audit_evidence.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 671,
        "module_docstring": "Module: audit_evidence\nPurpose: Emit compliance-grade audit for MCP tool calls.\n\nWires:\n    - Source: app/services/mcp/policy_mapper.py (policy decisions)\n    - Source: app/services/mcp/server_registry.py (server/tool info)\n    - Target: app/events (event bus) / audit storage\n\nThis module:\n    1. Emits audit events for all MCP tool invocations\n    2. Records policy decisions for compliance\n    3. Captures input/output for forensic analysis\n    4. Provides tamper-evident audit trail\n\nAcceptance Criteria:\n    - AC-143-01: All tool invocations are audited\n    - AC-143-02: Policy decisions are recorded\n    - AC-143-03: Audit events are tamper-evident\n    - AC-143-04: Sensitive data is redacted\n    - AC-143-05: Events include full context",
        "functions": [
          {
            "name": "_hash_value",
            "signature": "(value: Any) -> str",
            "docstring": "Hash a value for audit purposes.",
            "is_async": false,
            "line": 170
          },
          {
            "name": "_contains_sensitive",
            "signature": "(key: str) -> bool",
            "docstring": "Check if key name suggests sensitive data.",
            "is_async": false,
            "line": 178
          },
          {
            "name": "_redact_sensitive",
            "signature": "(data: Dict[str, Any]) -> Dict[str, Any]",
            "docstring": "Redact sensitive fields from data for logging.",
            "is_async": false,
            "line": 184
          },
          {
            "name": "get_mcp_audit_emitter",
            "signature": "() -> MCPAuditEmitter",
            "docstring": "Get or create the singleton MCPAuditEmitter.\n\nReturns:\n    MCPAuditEmitter instance",
            "is_async": false,
            "line": 628
          },
          {
            "name": "configure_mcp_audit_emitter",
            "signature": "(publisher: Optional[Any] = None) -> MCPAuditEmitter",
            "docstring": "Configure the singleton MCPAuditEmitter.\n\nArgs:\n    publisher: Event publisher to use\n\nReturns:\n    Configured MCPAuditEmitter",
            "is_async": false,
            "line": 644
          },
          {
            "name": "reset_mcp_audit_emitter",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 668
          }
        ],
        "classes": [
          {
            "name": "MCPAuditEventType",
            "docstring": "Types of MCP audit events.",
            "methods": [],
            "line": 56
          },
          {
            "name": "MCPAuditEvent",
            "docstring": "Compliance-grade audit event for MCP operations.\n\nContains full context for forensic analysis and compliance reporting.\nIncludes integrity hash for tamper detection.",
            "methods": [
              "__post_init__",
              "_compute_integrity_hash",
              "to_dict",
              "verify_integrity"
            ],
            "line": 72
          },
          {
            "name": "MCPAuditEmitter",
            "docstring": "Emitter for compliance-grade MCP audit events.\n\nThis service:\n1. Emits audit events to event bus\n2. Maintains chain of audit events (previous hash)\n3. Redacts sensitive data\n4. Provides forensic context\n\nINVARIANT: All tool invocations must be audited.",
            "methods": [
              "__init__",
              "_generate_event_id",
              "emit_tool_requested",
              "emit_tool_allowed",
              "emit_tool_denied",
              "emit_tool_started",
              "emit_tool_completed",
              "emit_tool_failed",
              "emit_server_registered",
              "emit_server_unregistered",
              "_emit",
              "_get_publisher"
            ],
            "line": 205
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [
          {
            "name": "SENSITIVE_PATTERNS",
            "line": 153
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "audit_reconciler.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/audit_reconciler.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 322,
        "module_docstring": "Audit Reconciler\n\nPerforms four-way validation of expectations vs acknowledgments:\n\n1. expected \u2212 acked \u2192 missing (audit alert)\n2. acked \u2212 expected \u2192 drift (unexpected action)\n3. missing finalization \u2192 stale run (liveness violation)\n4. expectations without deadline \u2192 invalid contract\n\nThis is the core of the Runtime Audit Contract (RAC).\n\nUsage:\n    reconciler = get_audit_reconciler()\n    result = reconciler.reconcile(run_id)\n\n    if not result.is_clean:\n        # Handle issues\n        if result.has_missing:\n            alert_missing_actions(result.missing_actions)\n        if result.stale_run:\n            alert_stale_run(run_id)",
        "functions": [
          {
            "name": "get_audit_reconciler",
            "signature": "(store: Optional[AuditStore] = None) -> AuditReconciler",
            "docstring": "Get the audit reconciler singleton.\n\nArgs:\n    store: Optional audit store (only used on first call)\n\nReturns:\n    AuditReconciler instance",
            "is_async": false,
            "line": 309
          }
        ],
        "classes": [
          {
            "name": "AuditReconciler",
            "docstring": "Reconciles expectations with acknowledgments.\n\nThis is the heart of the RAC system. It performs set operations\nto identify:\n- Missing actions (expected but not acked)\n- Drift actions (acked but not expected)\n- Stale runs (finalize_run never acked)\n\nLayer: L4 (Domain Logic)\nCallers: ROK (L5), Scheduler (L5)",
            "methods": [
              "__init__",
              "reconcile",
              "check_deadline_violations",
              "get_run_audit_summary",
              "_record_metrics"
            ],
            "line": 96
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Set",
              "Tuple"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "prometheus_client",
            "names": [
              "Counter",
              "Histogram"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.hoc_spine.schemas.rac_models",
            "names": [
              "AuditAction",
              "AuditDomain",
              "AuditExpectation",
              "AuditStatus",
              "DomainAck",
              "ReconciliationResult"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.audit_store",
            "names": [
              "AuditStore",
              "get_audit_store"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [
          {
            "name": "RECONCILIATION_TOTAL",
            "line": 66
          },
          {
            "name": "MISSING_ACTIONS_TOTAL",
            "line": 72
          },
          {
            "name": "DRIFT_ACTIONS_TOTAL",
            "line": 78
          },
          {
            "name": "STALE_RUNS_TOTAL",
            "line": 84
          },
          {
            "name": "RECONCILIATION_DURATION",
            "line": 89
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "certificate.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/certificate.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 386,
        "module_docstring": "M23 Certificate Service - Cryptographic Evidence of Deterministic Replay\n\nUses M4 HMAC infrastructure to create signed certificates that prove:\n1. Policy decisions were evaluated at a specific time\n2. Replay validation passed at a specific determinism level\n3. No tampering occurred between original call and validation\n\nCertificate Structure:\n- Certificate ID (UUID)\n- Original call metadata\n- Replay validation result\n- HMAC signature (using M4 infrastructure)\n- Timestamp and expiry\n\nUsage:\n    from app.hoc.cus.logs.L5_engines.certificate import CertificateService, CertificateRequest\n\n    service = CertificateService()\n    cert = service.create_certificate(\n        call_id=\"abc123\",\n        validation_result=replay_result,\n        level=DeterminismLevel.LOGICAL,\n    )\n\n    # Verify later\n    is_valid = service.verify_certificate(cert)",
        "functions": [],
        "classes": [
          {
            "name": "CertificateType",
            "docstring": "Types of certificates that can be issued.",
            "methods": [],
            "line": 62
          },
          {
            "name": "CertificatePayload",
            "docstring": "The signed payload of a certificate.",
            "methods": [
              "to_dict",
              "canonical_json"
            ],
            "line": 71
          },
          {
            "name": "Certificate",
            "docstring": "A signed certificate proving deterministic replay or policy evaluation.",
            "methods": [
              "to_dict",
              "to_json",
              "from_dict"
            ],
            "line": 131
          },
          {
            "name": "CertificateService",
            "docstring": "Service for creating and verifying cryptographic certificates.\n\nUses M4 HMAC infrastructure (same secret as golden file signing).",
            "methods": [
              "__init__",
              "_sign",
              "_verify_signature",
              "create_replay_certificate",
              "create_policy_audit_certificate",
              "verify_certificate",
              "export_certificate"
            ],
            "line": 180
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.hoc.cus.logs.L5_engines.replay_determinism",
            "names": [
              "DeterminismLevel",
              "ReplayResult"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [],
        "all_exports": [
          "CertificateService",
          "Certificate",
          "CertificatePayload",
          "CertificateType"
        ]
      },
      {
        "file_name": "completeness_checker.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/completeness_checker.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 518,
        "module_docstring": "Module: completeness_checker\nPurpose: Validate evidence bundle completeness before PDF generation.\n\nEvidence PDF exports require specific fields for SOC2 compliance.\nThis module validates that all required fields are present and\nnon-empty before allowing PDF generation.\n\nRequired Fields (Standard):\n    - incident_id, tenant_id, run_id, trace_id\n    - policy_snapshot_id, termination_reason\n    - total_steps, total_tokens, total_cost_cents\n\nSOC2 Required Fields (Enhanced):\n    - control_mappings, attestation_statement\n    - compliance_period_start, compliance_period_end\n\nExports:\n    - EvidenceCompletenessError: Raised when evidence is incomplete\n    - EvidenceCompletenessChecker: Main checker class\n    - check_evidence_completeness: Quick helper function\n    - ensure_evidence_completeness: Helper that raises on incomplete",
        "functions": [
          {
            "name": "check_evidence_completeness",
            "signature": "(bundle: Any, export_type: str = 'evidence', validation_enabled: bool = True, strict_mode: bool = False) -> CompletenessCheckResponse",
            "docstring": "Quick helper to check evidence completeness.\n\nArgs:\n    bundle: Evidence bundle to check\n    export_type: Type of export\n    validation_enabled: Whether validation is enforced\n    strict_mode: Whether recommended fields are required\n\nReturns:\n    CompletenessCheckResponse with validation result",
            "is_async": false,
            "line": 471
          },
          {
            "name": "ensure_evidence_completeness",
            "signature": "(bundle: Any, export_type: str = 'evidence', validation_enabled: bool = True, strict_mode: bool = False) -> None",
            "docstring": "Quick helper to ensure evidence completeness or raise error.\n\nArgs:\n    bundle: Evidence bundle to validate\n    export_type: Type of export\n    validation_enabled: Whether validation is enforced\n    strict_mode: Whether recommended fields are required\n\nRaises:\n    EvidenceCompletenessError: If incomplete and validation enabled",
            "is_async": false,
            "line": 496
          }
        ],
        "classes": [
          {
            "name": "CompletenessCheckResult",
            "docstring": "Result of a completeness check.",
            "methods": [],
            "line": 47
          },
          {
            "name": "EvidenceCompletenessError",
            "docstring": "Raised when evidence bundle is incomplete for PDF generation.\n\nThis error indicates that required fields are missing\nand the PDF cannot be generated without them.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 89
          },
          {
            "name": "CompletenessCheckResponse",
            "docstring": "Response from a completeness check.",
            "methods": [
              "to_dict"
            ],
            "line": 121
          },
          {
            "name": "EvidenceCompletenessChecker",
            "docstring": "Checks evidence bundle completeness before PDF generation.\n\nGAP-027: Ensure evidence PDFs contain all required fields for SOC2.\n\nThe checker validates that all required fields are present\nand non-empty before allowing PDF generation.\n\nUsage:\n    checker = EvidenceCompletenessChecker(validation_enabled=True)\n\n    # Before generating PDF\n    checker.ensure_complete(bundle, \"evidence\")\n\n    # Or check without raising\n    response = checker.check(bundle, \"evidence\")\n    if not response.is_complete and response.validation_enabled:\n        handle_incomplete_evidence()",
            "methods": [
              "__init__",
              "from_governance_config",
              "validation_enabled",
              "strict_mode",
              "get_required_fields",
              "get_field_value",
              "is_field_present",
              "check",
              "ensure_complete",
              "should_allow_export",
              "get_completeness_summary"
            ],
            "line": 147
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "FrozenSet",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "evidence_facade.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/evidence_facade.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 570,
        "module_docstring": "Evidence Facade (L5 Domain Engine)\n\nThis facade provides the external interface for evidence chain and export operations.\nAll evidence APIs MUST use this facade instead of directly importing\ninternal evidence modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes evidence chain management\n- Provides unified access to evidence export\n- Single point for audit emission\n\nL2 API Routes (GAP-104, GAP-105):\n- GET /api/v1/evidence/chains (list evidence chains)\n- GET /api/v1/evidence/chains/{id} (get evidence chain)\n- POST /api/v1/evidence/chains (create evidence chain)\n- GET /api/v1/evidence/chains/{id}/verify (verify chain integrity)\n- POST /api/v1/evidence/export (export evidence)\n- GET /api/v1/evidence/exports/{id} (get export status)\n\nUsage:\n    from app.hoc.cus.logs.L5_engines.evidence_facade import get_evidence_facade\n\n    facade = get_evidence_facade()\n\n    # List evidence chains\n    chains = await facade.list_chains(tenant_id=\"...\")\n\n    # Export evidence\n    export = await facade.create_export(tenant_id=\"...\", chain_id=\"...\")",
        "functions": [
          {
            "name": "get_evidence_facade",
            "signature": "() -> EvidenceFacade",
            "docstring": "Get the evidence facade instance.\n\nThis is the recommended way to access evidence operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    EvidenceFacade instance",
            "is_async": false,
            "line": 557
          }
        ],
        "classes": [
          {
            "name": "EvidenceType",
            "docstring": "Evidence types.",
            "methods": [],
            "line": 66
          },
          {
            "name": "ExportFormat",
            "docstring": "Export formats.",
            "methods": [],
            "line": 75
          },
          {
            "name": "ExportStatus",
            "docstring": "Export status.",
            "methods": [],
            "line": 82
          },
          {
            "name": "EvidenceLink",
            "docstring": "A link in an evidence chain.",
            "methods": [
              "to_dict"
            ],
            "line": 91
          },
          {
            "name": "EvidenceChain",
            "docstring": "An evidence chain.",
            "methods": [
              "to_dict"
            ],
            "line": 113
          },
          {
            "name": "VerificationResult",
            "docstring": "Result of chain verification.",
            "methods": [
              "to_dict"
            ],
            "line": 139
          },
          {
            "name": "EvidenceExport",
            "docstring": "Evidence export request.",
            "methods": [
              "to_dict"
            ],
            "line": 157
          },
          {
            "name": "EvidenceFacade",
            "docstring": "Facade for evidence chain and export operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nevidence services.\n\nLayer: L4 (Domain Logic)\nCallers: evidence.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "list_chains",
              "get_chain",
              "create_chain",
              "add_evidence",
              "verify_chain",
              "_create_link",
              "_hash_data",
              "create_export",
              "get_export",
              "list_exports"
            ],
            "line": 184
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "evidence_report.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/evidence_report.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 1164,
        "module_docstring": "Evidence Report Generator - Legal-Grade PDF Export\n\nGenerates deterministic, verifiable PDF evidence reports for AI incidents.\nThis document must survive legal review, audit, and hostile questioning.\n\nFeatures:\n- Cover page with metadata\n- Executive summary for legal/leadership\n- Factual reconstruction (pure evidence)\n- Policy evaluation record\n- Decision timeline (deterministic trace)\n- Replay verification with hash matching\n- Counterfactual prevention proof\n- Remediation & controls\n- Legal attestation with verification signature",
        "functions": [
          {
            "name": "generate_evidence_report",
            "signature": "(incident_id: str, tenant_id: str, tenant_name: str, user_id: str, product_name: str, model_id: str, timestamp: str, user_input: str, context_data: Dict[str, Any], ai_output: str, policy_results: List[Dict[str, Any]], timeline_events: List[Dict[str, Any]], replay_result: Optional[Dict[str, Any]] = None, prevention_result: Optional[Dict[str, Any]] = None, root_cause: str = 'Policy enforcement gap: system asserted fact when required data was NULL.', impact_assessment: Optional[List[str]] = None, certificate: Optional[Dict[str, Any]] = None, severity: str = 'HIGH', status: str = 'RESOLVED', is_demo: bool = True) -> bytes",
            "docstring": "Convenience function to generate an evidence report.\n\nReturns:\n    PDF file as bytes",
            "is_async": false,
            "line": 1089
          }
        ],
        "classes": [
          {
            "name": "CertificateEvidence",
            "docstring": "M23: Certificate data for cryptographic proof.",
            "methods": [],
            "line": 60
          },
          {
            "name": "IncidentEvidence",
            "docstring": "Evidence data for an incident.",
            "methods": [],
            "line": 77
          },
          {
            "name": "EvidenceReportGenerator",
            "docstring": "Generates legal-grade PDF evidence reports.\n\nThe report is structured for:\n- Legal review\n- Audit compliance\n- Executive briefing\n- Technical verification",
            "methods": [
              "__init__",
              "_setup_custom_styles",
              "generate",
              "_add_footer",
              "_build_incident_snapshot",
              "_build_cover_page",
              "_build_executive_summary",
              "_build_factual_reconstruction",
              "_build_policy_evaluation",
              "_build_decision_timeline",
              "_build_replay_verification",
              "_build_certificate_section",
              "_build_prevention_proof",
              "_build_remediation",
              "_build_legal_attestation",
              "_compute_hash",
              "_compute_report_hash"
            ],
            "line": 101
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "io",
            "names": [
              "io"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "reportlab.lib",
            "names": [
              "colors"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "reportlab.lib.enums",
            "names": [
              "TA_CENTER"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "reportlab.lib.pagesizes",
            "names": [
              "letter"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "reportlab.lib.styles",
            "names": [
              "ParagraphStyle",
              "getSampleStyleSheet"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "reportlab.lib.units",
            "names": [
              "inch"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "reportlab.platypus",
            "names": [
              "HRFlowable",
              "PageBreak",
              "Paragraph",
              "SimpleDocTemplate",
              "Spacer",
              "Table",
              "TableStyle"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "logs_facade.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/logs_facade.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 1407,
        "module_docstring": "Logs Domain Facade (L5)\n\nUnified facade for all logs domain operations:\n- LLM_RUNS: envelope, trace, governance, replay, export\n- SYSTEM_LOGS: snapshot, telemetry, events, replay, audit\n- AUDIT: identity, authorization, access, integrity, exports\n\nAll responses include EvidenceMetadata per INV-LOG-META-001.\n\nL5 CONTRACT:\n- NO sqlalchemy imports\n- NO direct database queries\n- Delegates all data access to L6 LogsDomainStore",
        "functions": [
          {
            "name": "get_logs_facade",
            "signature": "() -> LogsFacade",
            "docstring": "Get the singleton LogsFacade instance.",
            "is_async": false,
            "line": 1356
          }
        ],
        "classes": [
          {
            "name": "SourceDomain",
            "docstring": "Source domain for evidence metadata.",
            "methods": [],
            "line": 64
          },
          {
            "name": "Origin",
            "docstring": "Origin of the record.",
            "methods": [],
            "line": 74
          },
          {
            "name": "EvidenceMetadataResult",
            "docstring": "Global metadata contract for all Logs responses.",
            "methods": [],
            "line": 90
          },
          {
            "name": "LLMRunRecordResult",
            "docstring": "Single LLM run record.",
            "methods": [],
            "line": 130
          },
          {
            "name": "LLMRunRecordsResult",
            "docstring": "Response envelope for LLM run records.",
            "methods": [],
            "line": 150
          },
          {
            "name": "TraceStepResult",
            "docstring": "Individual trace step.",
            "methods": [],
            "line": 160
          },
          {
            "name": "LLMRunEnvelopeResult",
            "docstring": "O1: Canonical immutable run record.",
            "methods": [],
            "line": 173
          },
          {
            "name": "LLMRunTraceResult",
            "docstring": "O2: Step-by-step trace.",
            "methods": [],
            "line": 194
          },
          {
            "name": "GovernanceEventResult",
            "docstring": "Policy interaction event.",
            "methods": [],
            "line": 205
          },
          {
            "name": "LLMRunGovernanceResult",
            "docstring": "O3: Policy interaction trace.",
            "methods": [],
            "line": 218
          },
          {
            "name": "ReplayEventResult",
            "docstring": "Replay window event.",
            "methods": [],
            "line": 228
          },
          {
            "name": "LLMRunReplayResult",
            "docstring": "O4: 60-second replay window.",
            "methods": [],
            "line": 239
          },
          {
            "name": "LLMRunExportResult",
            "docstring": "O5: Export metadata.",
            "methods": [],
            "line": 251
          },
          {
            "name": "SystemRecordResult",
            "docstring": "Single system record entry.",
            "methods": [],
            "line": 262
          },
          {
            "name": "SystemRecordsResult",
            "docstring": "Response envelope for system records.",
            "methods": [],
            "line": 277
          },
          {
            "name": "SystemSnapshotResult",
            "docstring": "O1: Environment snapshot.",
            "methods": [],
            "line": 287
          },
          {
            "name": "TelemetryStubResult",
            "docstring": "O2: Telemetry stub response.",
            "methods": [],
            "line": 301
          },
          {
            "name": "SystemEventResult",
            "docstring": "System event record.",
            "methods": [],
            "line": 314
          },
          {
            "name": "SystemEventsResult",
            "docstring": "O3: Infra events affecting run.",
            "methods": [],
            "line": 328
          },
          {
            "name": "SystemReplayResult",
            "docstring": "O4: Infra replay window.",
            "methods": [],
            "line": 338
          },
          {
            "name": "SystemAuditResult",
            "docstring": "O5: Infra attribution record.",
            "methods": [],
            "line": 349
          },
          {
            "name": "AuditLedgerItemResult",
            "docstring": "Single audit ledger entry.",
            "methods": [],
            "line": 358
          },
          {
            "name": "AuditLedgerDetailResult",
            "docstring": "Audit ledger entry with state snapshots.",
            "methods": [],
            "line": 372
          },
          {
            "name": "AuditLedgerListResult",
            "docstring": "Response envelope for audit ledger.",
            "methods": [],
            "line": 389
          },
          {
            "name": "IdentityEventResult",
            "docstring": "Identity lifecycle event.",
            "methods": [],
            "line": 399
          },
          {
            "name": "AuditIdentityResult",
            "docstring": "O1: Identity lifecycle.",
            "methods": [],
            "line": 410
          },
          {
            "name": "AuthorizationDecisionResult",
            "docstring": "Authorization decision record.",
            "methods": [],
            "line": 419
          },
          {
            "name": "AuditAuthorizationResult",
            "docstring": "O2: Access decisions.",
            "methods": [],
            "line": 432
          },
          {
            "name": "AccessEventResult",
            "docstring": "Log access event.",
            "methods": [],
            "line": 441
          },
          {
            "name": "AuditAccessResult",
            "docstring": "O3: Log access audit.",
            "methods": [],
            "line": 454
          },
          {
            "name": "IntegrityCheckResult",
            "docstring": "Integrity verification record.",
            "methods": [],
            "line": 463
          },
          {
            "name": "AuditIntegrityResult",
            "docstring": "O4: Tamper detection.",
            "methods": [],
            "line": 473
          },
          {
            "name": "ExportRecordResult",
            "docstring": "Export record.",
            "methods": [],
            "line": 481
          },
          {
            "name": "AuditExportsResult",
            "docstring": "O5: Compliance exports.",
            "methods": [],
            "line": 495
          },
          {
            "name": "LogsFacade",
            "docstring": "Unified facade for all Logs domain operations.\n\nL4 CONTRACT:\n- Composition only - delegates to L6 driver\n- NO sqlalchemy imports\n- NO direct DB queries",
            "methods": [
              "__init__",
              "list_llm_run_records",
              "get_llm_run_envelope",
              "get_llm_run_trace",
              "get_llm_run_governance",
              "get_llm_run_replay",
              "get_llm_run_export",
              "list_system_records",
              "get_system_snapshot",
              "get_system_telemetry",
              "get_system_events",
              "get_system_replay",
              "get_system_audit",
              "list_audit_entries",
              "get_audit_entry",
              "get_audit_identity",
              "get_audit_authorization",
              "get_audit_access",
              "get_audit_integrity",
              "get_audit_exports",
              "_snapshot_to_record_result"
            ],
            "line": 508
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.logs.L6_drivers.logs_domain_store",
            "names": [
              "AuditLedgerSnapshot",
              "LLMRunSnapshot",
              "LogsDomainStore",
              "LogExportSnapshot",
              "QueryResult",
              "SystemRecordSnapshot",
              "TraceStepSnapshot",
              "get_logs_domain_store"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": [
          "LogsFacade",
          "get_logs_facade",
          "SourceDomain",
          "Origin",
          "EvidenceMetadataResult",
          "LLMRunRecordResult",
          "LLMRunRecordsResult",
          "TraceStepResult",
          "LLMRunEnvelopeResult",
          "LLMRunTraceResult",
          "GovernanceEventResult",
          "LLMRunGovernanceResult",
          "ReplayEventResult",
          "LLMRunReplayResult",
          "LLMRunExportResult",
          "SystemRecordResult",
          "SystemRecordsResult",
          "SystemSnapshotResult",
          "TelemetryStubResult",
          "SystemEventResult",
          "SystemEventsResult",
          "SystemReplayResult",
          "SystemAuditResult",
          "AuditLedgerItemResult",
          "AuditLedgerDetailResult",
          "AuditLedgerListResult",
          "IdentityEventResult",
          "AuditIdentityResult",
          "AuthorizationDecisionResult",
          "AuditAuthorizationResult",
          "AccessEventResult",
          "AuditAccessResult",
          "IntegrityCheckResult",
          "AuditIntegrityResult",
          "ExportRecordResult",
          "AuditExportsResult"
        ]
      },
      {
        "file_name": "logs_read_engine.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/logs_read_engine.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 215,
        "module_docstring": "Logs Read Engine (L5)\n\nThis service provides all READ operations for the Logs/Traces domain.\nIt sits between L3 (CustomerLogsAdapter) and L6 (PostgresTraceStore).\n\nL3 (Adapter) \u2192 L4 (this service) \u2192 L6 (PostgresTraceStore)\n\nResponsibilities:\n- Query traces with tenant isolation\n- Get trace details\n- Get trace counts\n- Search traces with filters\n- No write operations (writes go through runtime)\n\nReference: PIN-281 (L3 Adapter Closure - PHASE 1)",
        "functions": [
          {
            "name": "get_logs_read_service",
            "signature": "() -> LogsReadService",
            "docstring": "Factory function to get LogsReadService instance.\n\nThis is the ONLY way L3 should obtain a logs read service.",
            "is_async": false,
            "line": 200
          }
        ],
        "classes": [
          {
            "name": "LogsReadService",
            "docstring": "L4 service for logs/trace read operations.\n\nProvides tenant-scoped, bounded reads for the Logs domain.\nAll L3 adapters must use this service for log reads.",
            "methods": [
              "__init__",
              "_get_store",
              "search_traces",
              "get_trace",
              "get_trace_count",
              "get_trace_by_root_hash",
              "list_traces"
            ],
            "line": 51
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.logs.L5_engines.traces_models",
            "names": [
              "TraceRecord",
              "TraceSummary"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.logs.L6_drivers.pg_store",
            "names": [
              "PostgresTraceStore",
              "get_postgres_trace_store"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": [
          "LogsReadService",
          "get_logs_read_service"
        ]
      },
      {
        "file_name": "mapper.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/mapper.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 273,
        "module_docstring": "Module: mapper\nPurpose: Map incidents and evidence to SOC2 controls.\n\nProvides intelligent mapping of incident categories and evidence\nto the appropriate SOC2 Trust Service Criteria controls.\n\nExports:\n    - SOC2ControlMapper: Maps incidents to controls\n    - get_control_mappings_for_incident: Main entry point",
        "functions": [
          {
            "name": "get_control_mappings_for_incident",
            "signature": "(incident_category: str, incident_data: dict[str, Any]) -> list[dict[str, Any]]",
            "docstring": "Get SOC2 control mappings for an incident (GAP-025 main entry point).\n\nThis is the primary function for obtaining SOC2 control mappings\nfor incident exports and compliance reporting.\n\nArgs:\n    incident_category: Category of the incident\n    incident_data: Incident data dict\n\nReturns:\n    List of control mapping dicts suitable for API responses",
            "is_async": false,
            "line": 254
          }
        ],
        "classes": [
          {
            "name": "SOC2ControlMapper",
            "docstring": "Maps incidents to relevant SOC2 controls.\n\nProvides intelligent mapping based on incident category,\nseverity, and available evidence.\n\nGAP-025: Complete SOC2 control objective mapping.",
            "methods": [
              "__init__",
              "map_incident_to_controls",
              "_create_mapping",
              "_determine_compliance_status",
              "get_all_applicable_controls"
            ],
            "line": 87
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.control_registry",
            "names": [
              "SOC2ComplianceStatus",
              "SOC2Control",
              "SOC2ControlMapping",
              "SOC2ControlRegistry",
              "get_control_registry"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "pdf_renderer.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/pdf_renderer.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 683,
        "module_docstring": "PDF Renderer Engine\n\nRenders export bundles to PDF format for compliance exports,\nexecutive debriefs, and evidence documentation.\n\nKey Responsibilities:\n1. Render EvidenceBundle to detailed PDF\n2. Render SOC2Bundle with control attestations\n3. Render ExecutiveDebriefBundle for leadership\n\nUses reportlab for PDF generation (same library as evidence_report.py).",
        "functions": [
          {
            "name": "get_pdf_renderer",
            "signature": "() -> PDFRenderer",
            "docstring": "Get or create PDFRenderer singleton.",
            "is_async": false,
            "line": 678
          }
        ],
        "classes": [
          {
            "name": "PDFRenderer",
            "docstring": "Render export bundles to PDF format.",
            "methods": [
              "__init__",
              "_setup_styles",
              "render_evidence_pdf",
              "render_soc2_pdf",
              "render_executive_debrief_pdf",
              "_build_evidence_cover",
              "_build_evidence_summary",
              "_build_trace_timeline",
              "_build_policy_section",
              "_build_integrity_section",
              "_build_soc2_cover",
              "_build_control_mappings",
              "_build_attestation",
              "_build_exec_cover",
              "_build_exec_summary",
              "_build_recommendations",
              "_build_exec_metrics"
            ],
            "line": 59
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "io",
            "names": [
              "io"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "reportlab.lib",
            "names": [
              "colors"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "reportlab.lib.enums",
            "names": [
              "TA_CENTER",
              "TA_LEFT"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "reportlab.lib.pagesizes",
            "names": [
              "letter"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "reportlab.lib.styles",
            "names": [
              "ParagraphStyle",
              "getSampleStyleSheet"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "reportlab.lib.units",
            "names": [
              "inch"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "reportlab.platypus",
            "names": [
              "HRFlowable",
              "PageBreak",
              "Paragraph",
              "SimpleDocTemplate",
              "Spacer",
              "Table",
              "TableStyle"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "redact.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/redact.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 267,
        "module_docstring": "PII Redaction Utility for Trace Storage\nM8 Deliverable: Secure trace storage with PII masking\n\nRedacts sensitive data from traces before storage:\n- Passwords, API keys, tokens\n- Credit card numbers\n- Email addresses\n- Custom patterns via configuration",
        "functions": [
          {
            "name": "redact_json_string",
            "signature": "(json_str: str) -> str",
            "docstring": "Apply PII redaction patterns to a JSON string.\n\nArgs:\n    json_str: JSON string to redact\n\nReturns:\n    Redacted JSON string",
            "is_async": false,
            "line": 108
          },
          {
            "name": "redact_dict",
            "signature": "(data: dict[str, Any], depth: int = 0, max_depth: int = 20) -> dict[str, Any]",
            "docstring": "Recursively redact sensitive fields in a dictionary.\n\nArgs:\n    data: Dictionary to redact\n    depth: Current recursion depth\n    max_depth: Maximum recursion depth\n\nReturns:\n    Redacted dictionary (new copy)",
            "is_async": false,
            "line": 124
          },
          {
            "name": "redact_list",
            "signature": "(data: list[Any], depth: int = 0, max_depth: int = 20) -> list[Any]",
            "docstring": "Recursively redact sensitive fields in a list.",
            "is_async": false,
            "line": 157
          },
          {
            "name": "redact_string_value",
            "signature": "(value: str) -> str",
            "docstring": "Redact sensitive patterns in a string value.",
            "is_async": false,
            "line": 176
          },
          {
            "name": "redact_trace_data",
            "signature": "(trace: dict[str, Any]) -> dict[str, Any]",
            "docstring": "Redact PII from a complete trace object.\n\nThis is the main entry point for trace redaction.\nCreates a deep copy to avoid modifying the original.\n\nArgs:\n    trace: Trace object to redact\n\nReturns:\n    Redacted trace (new copy)",
            "is_async": false,
            "line": 200
          },
          {
            "name": "is_sensitive_field",
            "signature": "(field_name: str) -> bool",
            "docstring": "Check if a field name indicates sensitive data.",
            "is_async": false,
            "line": 255
          },
          {
            "name": "add_sensitive_field",
            "signature": "(field_name: str) -> None",
            "docstring": "Add a custom field name to the sensitive fields set.",
            "is_async": false,
            "line": 260
          },
          {
            "name": "add_redaction_pattern",
            "signature": "(pattern: str, replacement: str) -> None",
            "docstring": "Add a custom redaction pattern.",
            "is_async": false,
            "line": 265
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "copy",
            "names": [
              "copy"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [
          {
            "name": "PII_PATTERNS",
            "line": 44
          },
          {
            "name": "SENSITIVE_FIELD_NAMES",
            "line": 79
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "replay_determinism.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/replay_determinism.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 498,
        "module_docstring": "Replay Determinism Service - Defines and Enforces Determinism Semantics\n\nWatchpoint #2: Replay Determinism Across Model Versions\n\nThis service addresses the fundamental tension between:\n- \"Logical Determinism\": Same policy decision given same context\n- \"Byte-for-byte Determinism\": Exact same output bytes\n\nKey Insight: As upstream LLM models drift (model updates, temperature changes),\nwe cannot guarantee byte-for-byte determinism. However, we CAN guarantee:\n\n1. Policy decisions are deterministic (same rules -> same enforcement)\n2. Replay validates logical equivalence, not exact match\n3. Version tracking allows audit trail of what ran when\n\nDeterminism Levels:\n- STRICT: Byte-for-byte match required (only for local/cached responses)\n- LOGICAL: Policy decision match required (default for LLM calls)\n- SEMANTIC: Meaning-equivalent match (for content validation)\n\nUsage:\n    from app.hoc.cus.logs.L5_engines.replay_determinism import (\n        ReplayValidator,\n        DeterminismLevel,\n        ReplayResult\n    )\n\n    validator = ReplayValidator()\n    result = validator.validate_replay(\n        original_call=original,\n        replayed_call=replayed,\n        level=DeterminismLevel.LOGICAL\n    )",
        "functions": [],
        "classes": [
          {
            "name": "ModelVersion",
            "docstring": "Track the model version used for a call.",
            "methods": [
              "to_dict",
              "from_dict"
            ],
            "line": 75
          },
          {
            "name": "PolicyDecision",
            "docstring": "Record of a policy enforcement decision.",
            "methods": [
              "to_dict"
            ],
            "line": 108
          },
          {
            "name": "ReplayMatch",
            "docstring": "Result of replay comparison.",
            "methods": [],
            "line": 132
          },
          {
            "name": "ReplayResult",
            "docstring": "Result of replay validation.",
            "methods": [
              "to_dict"
            ],
            "line": 142
          },
          {
            "name": "CallRecord",
            "docstring": "Record of a call for replay validation.",
            "methods": [
              "to_dict"
            ],
            "line": 183
          },
          {
            "name": "ReplayValidator",
            "docstring": "Validates replay determinism at configurable levels.\n\nThe key insight is that LLM outputs will drift over time as models\nare updated. We don't try to fight this - instead we:\n\n1. Track model versions explicitly\n2. Define determinism in terms of POLICY DECISIONS, not raw output\n3. Provide clear audit trails when drift is detected\n4. Allow operators to choose their determinism level",
            "methods": [
              "__init__",
              "validate_replay",
              "_detect_model_drift",
              "_compare_policies",
              "_semantic_equivalent",
              "_level_meets_requirement",
              "hash_content"
            ],
            "line": 221
          },
          {
            "name": "ReplayContextBuilder",
            "docstring": "Builds replay context from API calls.\n\nUsed to capture all information needed for replay validation:\n- Request details\n- Response details\n- Model version\n- Policy decisions",
            "methods": [
              "__init__",
              "build_call_record"
            ],
            "line": 413
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.hoc.cus.logs.L5_schemas.determinism_types",
            "names": [
              "DeterminismLevel"
            ],
            "is_relative": false,
            "line": 68
          }
        ],
        "constants": [],
        "all_exports": [
          "DeterminismLevel",
          "ModelVersion",
          "PolicyDecision",
          "ReplayMatch",
          "ReplayResult",
          "CallRecord",
          "ReplayValidator",
          "ReplayContextBuilder"
        ]
      },
      {
        "file_name": "traces_models.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/traces_models.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 51,
        "module_docstring": "Trace Models for AOS - BACKWARD COMPATIBILITY RE-EXPORTS\n\nPIN-521 Migration:\n- Canonical home is now L5_schemas/traces_models.py\n- This file re-exports for backward compatibility\n- L6 drivers MUST import from L5_schemas (not here)\n- New code SHOULD import from L5_schemas\n\nTo migrate existing imports:\n    OLD: from app.hoc.cus.logs.L5_engines.traces_models import TraceRecord\n    NEW: from app.hoc.cus.logs.L5_schemas.traces_models import TraceRecord",
        "functions": [],
        "classes": [],
        "imports": [
          {
            "module": "app.hoc.cus.logs.L5_schemas.traces_models",
            "names": [
              "ParityResult",
              "TraceRecord",
              "TraceStatus",
              "TraceStep",
              "TraceSummary",
              "_normalize_for_determinism",
              "compare_traces"
            ],
            "is_relative": false,
            "line": 33
          }
        ],
        "constants": [],
        "all_exports": [
          "TraceStatus",
          "TraceStep",
          "TraceSummary",
          "TraceRecord",
          "ParityResult",
          "compare_traces",
          "_normalize_for_determinism"
        ]
      }
    ],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "bridges_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/bridges_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 123,
        "module_docstring": "M25 Bridges Driver\n\nDatabase operations for integration bridge audit trails.\n\nL6 Contract:\n    - Session REQUIRED (passed from L4 handler)\n    - L6 does NOT commit (L4 owns transaction boundary)\n\nUNFROZEN: 2026-02-06 (PIN-520 L6 purity compliance)",
        "functions": [
          {
            "name": "record_policy_activation",
            "signature": "(session: AsyncSession, policy_id: str, source_pattern_id: str, source_recovery_id: str, confidence: float, approval_path: str, loop_trace_id: str, tenant_id: str) -> PolicyActivationAudit",
            "docstring": "Record policy activation for audit trail.\n\nEvery ACTIVE policy must have an audit record.\n\nArgs:\n    session: AsyncSession from L4 handler (required)\n    policy_id: Policy being activated\n    source_pattern_id: Source pattern ID\n    source_recovery_id: Source recovery ID\n    confidence: Confidence score at activation\n    approval_path: Approval workflow path\n    loop_trace_id: Loop trace correlation ID\n    tenant_id: Tenant scope\n\nReturns:\n    PolicyActivationAudit record\n\nNote:\n    L6 does NOT commit \u2014 L4 handler owns transaction boundary.",
            "is_async": true,
            "line": 48
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "schemas.audit_schemas",
            "names": [
              "PolicyActivationAudit"
            ],
            "is_relative": true,
            "line": 42
          },
          {
            "module": "schemas.loop_events",
            "names": [
              "ConfidenceCalculator"
            ],
            "is_relative": true,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "export_bundle_store.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/export_bundle_store.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 245,
        "module_docstring": "Export Bundle Store (L6)\n\nDatabase driver for export bundle data access:\n- Incidents\n- Runs\n- Trace summaries and steps\n\nAll methods return immutable snapshots, never ORM models.",
        "functions": [
          {
            "name": "get_export_bundle_store",
            "signature": "() -> ExportBundleStore",
            "docstring": "Get the singleton ExportBundleStore instance.",
            "is_async": false,
            "line": 230
          }
        ],
        "classes": [
          {
            "name": "IncidentSnapshot",
            "docstring": "Immutable snapshot of incident.",
            "methods": [],
            "line": 56
          },
          {
            "name": "RunSnapshot",
            "docstring": "Immutable snapshot of run.",
            "methods": [],
            "line": 70
          },
          {
            "name": "TraceSummarySnapshot",
            "docstring": "Immutable snapshot of trace summary.",
            "methods": [],
            "line": 85
          },
          {
            "name": "TraceStepSnapshot",
            "docstring": "Immutable snapshot of trace step.",
            "methods": [],
            "line": 96
          },
          {
            "name": "ExportBundleStore",
            "docstring": "L6 Database Driver for export bundle data.\n\nAll methods:\n- Use sync Session (for sqlmodel compatibility)\n- Return immutable snapshots\n- Contain NO business logic",
            "methods": [
              "__init__",
              "trace_store",
              "get_incident",
              "get_run_by_run_id",
              "get_trace_summary",
              "get_trace_steps"
            ],
            "line": 114
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.db",
            "names": [
              "Run",
              "engine"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.traces.store",
            "names": [
              "TraceStore"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": [
          "ExportBundleStore",
          "get_export_bundle_store",
          "IncidentSnapshot",
          "RunSnapshot",
          "TraceSummarySnapshot",
          "TraceStepSnapshot"
        ]
      },
      {
        "file_name": "logs_domain_store.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/logs_domain_store.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 673,
        "module_docstring": "Logs Domain Store (L6)\n\nDatabase driver for all Logs domain data access:\n- LLM Run Records\n- System Records\n- Audit Ledger\n- Log Exports\n\nAll methods return immutable snapshots, never ORM models.",
        "functions": [
          {
            "name": "get_logs_domain_store",
            "signature": "() -> LogsDomainStore",
            "docstring": "Get the singleton LogsDomainStore instance.",
            "is_async": false,
            "line": 655
          }
        ],
        "classes": [
          {
            "name": "LLMRunSnapshot",
            "docstring": "Immutable snapshot of LLM run record.",
            "methods": [],
            "line": 56
          },
          {
            "name": "SystemRecordSnapshot",
            "docstring": "Immutable snapshot of system record.",
            "methods": [],
            "line": 77
          },
          {
            "name": "AuditLedgerSnapshot",
            "docstring": "Immutable snapshot of audit ledger entry.",
            "methods": [],
            "line": 93
          },
          {
            "name": "LogExportSnapshot",
            "docstring": "Immutable snapshot of log export record.",
            "methods": [],
            "line": 111
          },
          {
            "name": "TraceStepSnapshot",
            "docstring": "Immutable snapshot of trace step.",
            "methods": [],
            "line": 126
          },
          {
            "name": "QueryResult",
            "docstring": "Generic query result with pagination info.",
            "methods": [],
            "line": 139
          },
          {
            "name": "LogsDomainStore",
            "docstring": "L6 Database Driver for Logs domain.\n\nAll methods:\n- Accept AsyncSession as parameter\n- Return immutable snapshots\n- Contain NO business logic",
            "methods": [
              "list_llm_runs",
              "get_llm_run",
              "_to_llm_run_snapshot",
              "get_trace_id_for_run",
              "get_trace_steps",
              "get_replay_window_events",
              "list_system_records",
              "get_system_record_by_correlation",
              "get_system_records_in_window",
              "_to_system_record_snapshot",
              "list_audit_entries",
              "get_audit_entry",
              "get_governance_events",
              "_to_audit_snapshot",
              "list_log_exports",
              "_to_export_snapshot"
            ],
            "line": 152
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select",
              "text"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "AuditLedger"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.log_exports",
            "names": [
              "LogExport"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.models.logs_records",
            "names": [
              "LLMRunRecord",
              "SystemRecord"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": [
          "LogsDomainStore",
          "get_logs_domain_store",
          "LLMRunSnapshot",
          "SystemRecordSnapshot",
          "AuditLedgerSnapshot",
          "LogExportSnapshot",
          "TraceStepSnapshot",
          "QueryResult"
        ]
      },
      {
        "file_name": "pg_store.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/pg_store.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 769,
        "module_docstring": "PostgreSQL Trace Store for AOS\nM8 Deliverable: Production-grade trace storage with PostgreSQL\n\nProvides:\n- Async PostgreSQL storage with connection pooling\n- RBAC-aware trace access\n- PII redaction before storage\n- Efficient indexing for query API\n\nFROZEN SEMANTICS (PIN-198, S6 Trace Integrity Truth):\n- All trace INSERTs use ON CONFLICT DO NOTHING (Invariant #15: First Truth Wins)\n- No UPDATE on aos_trace_steps (Invariant #13: Trace Ledger Semantics)\n- Only status/completed_at UPDATE allowed on aos_traces\n- DELETE requires archive-first (Invariant #13)\nSee LESSONS_ENFORCED.md Invariants #13, #15",
        "functions": [
          {
            "name": "_status_to_level",
            "signature": "(status: str) -> str",
            "docstring": "Derive log level from step status.\n\nMapping per PIN-378 (Canonical Logs System):\n- success \u2192 INFO\n- skipped \u2192 INFO\n- retry \u2192 WARN\n- failure \u2192 ERROR",
            "is_async": false,
            "line": 55
          },
          {
            "name": "get_postgres_trace_store",
            "signature": "() -> PostgresTraceStore",
            "docstring": "Get singleton PostgreSQL trace store.",
            "is_async": false,
            "line": 764
          }
        ],
        "classes": [
          {
            "name": "PostgresTraceStore",
            "docstring": "PostgreSQL-based trace storage for production.\n\nUses asyncpg for async database operations.\nSupports multi-tenant isolation and RBAC.",
            "methods": [
              "__init__",
              "_get_pool",
              "close",
              "start_trace",
              "record_step",
              "complete_trace",
              "mark_trace_aborted",
              "store_trace",
              "get_trace",
              "get_trace_by_root_hash",
              "search_traces",
              "list_traces",
              "delete_trace",
              "get_trace_count",
              "cleanup_old_traces",
              "check_idempotency_key"
            ],
            "line": 74
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "models",
            "names": [
              "TraceRecord",
              "TraceStatus",
              "TraceStep",
              "TraceSummary"
            ],
            "is_relative": true,
            "line": 51
          },
          {
            "module": "redact",
            "names": [
              "redact_trace_data"
            ],
            "is_relative": true,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 21,
    "violation_count": 0,
    "gap_count": 2
  },
  "analytics": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/analytics.py",
    "l2_apis": [
      {
        "file_name": "costsim.py",
        "file_path": "backend/app/hoc/api/cus/analytics/costsim.py",
        "layer": "L2_api",
        "domain": "analytics",
        "lines": 1010,
        "module_docstring": "API endpoints for CostSim V2 sandbox.\n\nEndpoints:\n- POST /costsim/v2/simulate - Run V2 simulation (sandbox mode)\n- GET /costsim/v2/status - Get V2 sandbox status\n- POST /costsim/v2/reset - Reset circuit breaker\n- GET /costsim/divergence - Get divergence report\n- POST /costsim/canary/run - Trigger canary run\n- GET /costsim/canary/reports - Get canary reports\n\nM7 Enhancements:\n- Memory context injection for simulations\n- Post-execution memory updates via rules engine\n- Drift detection between baseline and memory-enabled runs",
        "functions": [
          {
            "name": "get_memory_context",
            "signature": "(tenant_id: str, workflow_id: Optional[str] = None, agent_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Retrieve memory context for simulation.\n\nFetches relevant memory pins for the tenant, workflow, and agent.\nReturns empty dict if memory service unavailable (fail-open).",
            "is_async": true,
            "line": 258
          },
          {
            "name": "apply_post_execution_updates",
            "signature": "(tenant_id: str, workflow_id: Optional[str], agent_id: Optional[str], simulation_result: Dict[str, Any]) -> int",
            "docstring": "Apply deterministic post-execution memory updates.\n\nUses the update rules engine to apply memory updates based on\nsimulation results. Returns count of updates applied.",
            "is_async": true,
            "line": 314
          },
          {
            "name": "detect_simulation_drift",
            "signature": "(baseline_result: Dict[str, Any], memory_result: Dict[str, Any], workflow_id: Optional[str]) -> tuple[bool, float]",
            "docstring": "Detect drift between baseline and memory-enabled simulation.\n\nCompares results to identify if memory context significantly\nchanged the simulation outcome.",
            "is_async": true,
            "line": 385
          },
          {
            "name": "get_sandbox_status",
            "signature": "(session = Depends(get_session_dep))",
            "docstring": "Get current V2 sandbox status.\n\nReturns information about:\n- Whether sandbox is enabled (feature flag)\n- Whether circuit breaker is open (auto-disabled due to drift)\n- Current model version\n- Drift thresholds\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 443
          },
          {
            "name": "simulate_v2",
            "signature": "(request: SimulateRequest, session = Depends(get_session_dep))",
            "docstring": "Run simulation through V2 sandbox.\n\nThis endpoint always runs V1 for production results.\nIf sandbox is enabled, also runs V2 in shadow mode\nand returns comparison metrics.\n\nThe V1 result is always the authoritative result.\nV2 is for validation only.\n\nM7 Enhancements:\n- Memory context injection for simulations\n- Post-execution memory updates via rules engine\n- Drift detection between baseline and memory-enabled runs\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 477
          },
          {
            "name": "reset_circuit_breaker",
            "signature": "(reason: Optional[str] = Query(None, description='Reason for reset'), session = Depends(get_session_dep))",
            "docstring": "Reset the V2 circuit breaker.\n\nThis re-enables V2 sandbox after it was auto-disabled due to drift.\nShould only be called after investigating and fixing the drift cause.\n\nReturns success status and updated circuit breaker state.\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 658
          },
          {
            "name": "get_incidents",
            "signature": "(include_resolved: bool = Query(False, description='Include resolved incidents'), limit: int = Query(10, ge=1, le=100, description='Max incidents to return'), session = Depends(get_session_dep))",
            "docstring": "Get circuit breaker incidents.\n\nReturns recent incidents that caused circuit breaker trips.\nUseful for investigating drift causes.\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 689
          },
          {
            "name": "get_divergence_report",
            "signature": "(start_date: Optional[datetime] = Query(None, description='Start of analysis period'), end_date: Optional[datetime] = Query(None, description='End of analysis period'), tenant_id: Optional[str] = Query(None, description='Filter by tenant'), days: int = Query(7, ge=1, le=90, description='Days to analyze (if start_date not provided)'), session = Depends(get_session_dep))",
            "docstring": "Get cost divergence report between V1 and V2.\n\nReturns metrics:\n- delta_p50: Median cost delta\n- delta_p90: 90th percentile cost delta\n- kl_divergence: KL divergence between distributions\n- outlier_count: Number of outlier samples\n- fail_ratio: Ratio of major drift samples\n- matching_rate: Ratio of matching samples\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 720
          },
          {
            "name": "trigger_canary_run",
            "signature": "(sample_count: int = Query(100, ge=10, le=1000, description='Number of samples'), drift_threshold: float = Query(0.2, ge=0.0, le=1.0, description='Drift threshold'), session = Depends(get_session_dep))",
            "docstring": "Trigger a canary run on-demand.\n\nThe canary run:\n1. Loads samples from recent provenance logs\n2. Runs both V1 and V2 on each sample\n3. Computes drift metrics\n4. Returns pass/fail verdict\n\nNote: Daily canary runs are automatic via systemd timer.\nThis endpoint is for manual testing.\n\nPIN-520 Phase 3: Routes through L4 registry (analytics.canary).",
            "is_async": true,
            "line": 771
          },
          {
            "name": "get_canary_reports",
            "signature": "(limit: int = Query(10, ge=1, le=100, description='Max reports to return'), status: Optional[str] = Query(None, description='Filter by status (pass, fail, error, skipped)'), passed: Optional[bool] = Query(None, description='Filter by passed status'), session = Depends(get_session_dep))",
            "docstring": "Get recent canary run reports.\n\nReturns summaries of recent canary runs.\nFull artifacts are available at the artifact_paths.\n\nRoutes through L4 handler for policy/audit compliance.",
            "is_async": true,
            "line": 818
          },
          {
            "name": "list_datasets",
            "signature": "(session = Depends(get_session_dep))",
            "docstring": "List all available reference datasets.\n\nReference datasets are used to validate V2 accuracy:\n- low_variance: Simple, predictable plans\n- high_variance: Complex, variable plans\n- mixed_city: Real-world mixed workloads\n- noise_injected: Edge cases and invalid inputs\n- historical: Real production patterns\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 887
          },
          {
            "name": "get_dataset_info",
            "signature": "(dataset_id: str, session = Depends(get_session_dep))",
            "docstring": "Get information about a specific dataset.\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 924
          },
          {
            "name": "validate_against_dataset",
            "signature": "(dataset_id: str, session = Depends(get_session_dep))",
            "docstring": "Validate V2 against a specific reference dataset.\n\nRuns V2 on all samples in the dataset and compares\nagainst expected values. Returns metrics and verdict.\n\nVerdict is \"acceptable\" if all metrics are within thresholds.\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 946
          },
          {
            "name": "validate_all",
            "signature": "(session = Depends(get_session_dep))",
            "docstring": "Validate V2 against ALL reference datasets.\n\nThis is a comprehensive validation that runs all 5 datasets.\nUse for pre-release validation or debugging.\n\nPIN-520 Phase 3: Routes through L4 registry.",
            "is_async": true,
            "line": 986
          }
        ],
        "classes": [
          {
            "name": "SimulationStep",
            "docstring": "A single step in a simulation plan.",
            "methods": [],
            "line": 112
          },
          {
            "name": "SimulateRequest",
            "docstring": "Request for V2 simulation.",
            "methods": [],
            "line": 120
          },
          {
            "name": "SimulationStepResult",
            "docstring": "Result for a single step.",
            "methods": [],
            "line": 133
          },
          {
            "name": "V2SimulationResponse",
            "docstring": "Response from V2 simulation.",
            "methods": [],
            "line": 143
          },
          {
            "name": "ComparisonResponse",
            "docstring": "Comparison between V1 and V2.",
            "methods": [],
            "line": 159
          },
          {
            "name": "SideEffectDisclosure",
            "docstring": "PIN-254 Phase C Fix (C5 Implicit Side-Effect): Explicit disclosure of side effects.\n\nThe /simulate endpoint can trigger memory writes when MEMORY_POST_UPDATE=true.\nThis violates the implicit contract that \"simulation\" is side-effect-free.\n\nThis disclosure makes the side-effect conditions explicit in the response.",
            "methods": [],
            "line": 171
          },
          {
            "name": "SandboxSimulateResponse",
            "docstring": "Response from sandbox simulation.",
            "methods": [],
            "line": 187
          },
          {
            "name": "SandboxStatusResponse",
            "docstring": "Status of V2 sandbox.",
            "methods": [],
            "line": 213
          },
          {
            "name": "DivergenceReportResponse",
            "docstring": "Divergence report response.",
            "methods": [],
            "line": 224
          },
          {
            "name": "CanaryRunResponse",
            "docstring": "Canary run response.",
            "methods": [],
            "line": 240
          },
          {
            "name": "DatasetInfo",
            "docstring": "Dataset information.",
            "methods": [],
            "line": 860
          },
          {
            "name": "ValidationResultResponse",
            "docstring": "Validation result response.",
            "methods": [],
            "line": 870
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [
          {
            "name": "MEMORY_CONTEXT_INJECTION",
            "line": 49
          },
          {
            "name": "MEMORY_POST_UPDATE",
            "line": 50
          },
          {
            "name": "DRIFT_DETECTION_ENABLED",
            "line": 51
          },
          {
            "name": "MEMORY_FAIL_OPEN_OVERRIDE",
            "line": 53
          },
          {
            "name": "MEMORY_POST_UPDATE_SYNC",
            "line": 55
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "feedback.py",
        "file_path": "backend/app/hoc/api/cus/analytics/feedback.py",
        "layer": "L2_api",
        "domain": "analytics",
        "lines": 221,
        "module_docstring": "PB-S3 Pattern Feedback API (READ-ONLY)\n\nExposes pattern_feedback data for observability without modification.\n\nPB-S3 Contract:\n- Feedback observes but never mutates\n- Provenance references runs (read-only)\n- No execution data modification allowed\n\nREAD_ONLY = True\n\nO1: API endpoint exists \u2713\nO2: List visible with pagination \u2713\nO3: Detail accessible \u2713\nO4: Execution unchanged \u2713 (no POST/PUT/DELETE)",
        "functions": [
          {
            "name": "list_feedback",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), pattern_type: Optional[str] = Query(None, description='Filter by pattern type'), severity: Optional[str] = Query(None, description='Filter by severity'), acknowledged: Optional[bool] = Query(None, description='Filter by acknowledgement status'), limit: int = Query(50, ge=1, le=200, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), _: str = Depends(verify_api_key))",
            "docstring": "List pattern feedback records (PB-S3).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 107
          },
          {
            "name": "get_feedback",
            "signature": "(feedback_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Get detailed feedback record by ID (PB-S3).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 160
          },
          {
            "name": "get_feedback_stats",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), _: str = Depends(verify_api_key))",
            "docstring": "Get feedback statistics summary (PB-S3).\n\nREAD-ONLY: This endpoint only reads aggregated data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 195
          }
        ],
        "classes": [
          {
            "name": "FeedbackSummaryResponse",
            "docstring": "Summary of a feedback record.",
            "methods": [],
            "line": 54
          },
          {
            "name": "FeedbackListResponse",
            "docstring": "Paginated list of feedback records.",
            "methods": [],
            "line": 69
          },
          {
            "name": "FeedbackDetailResponse",
            "docstring": "Detailed feedback record.",
            "methods": [],
            "line": 80
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth",
            "names": [
              "verify_api_key"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_async_session_context",
              "get_operation_registry",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "predictions.py",
        "file_path": "backend/app/hoc/api/cus/analytics/predictions.py",
        "layer": "L2_api",
        "domain": "analytics",
        "lines": 300,
        "module_docstring": "PB-S5 Predictions API (READ-ONLY)\n\nExposes prediction_events data for observability without modification.\n\nPB-S5 Contract:\n- Predictions are advisory only\n- Predictions have zero side-effects\n- Predictions never modify execution, scheduling, or history\n- Rule: Advise, don't influence\n\nREAD_ONLY = True\n\nO1: API endpoint exists \u2713\nO2: List visible with pagination \u2713\nO3: Detail accessible \u2713\nO4: Execution unchanged \u2713 (no POST/PUT/DELETE)",
        "functions": [
          {
            "name": "list_predictions",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), prediction_type: Optional[str] = Query(None, description='Filter by type (failure_likelihood/cost_overrun)'), subject_type: Optional[str] = Query(None, description='Filter by subject type (worker/run/tenant)'), subject_id: Optional[str] = Query(None, description='Filter by subject ID'), include_expired: bool = Query(False, description='Include expired predictions'), limit: int = Query(50, ge=1, le=200, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), session = Depends(get_session_dep), auth: AuthorityResult = Depends(require_predictions_read))",
            "docstring": "List prediction events (PB-S5).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.\nAll predictions are ADVISORY only.",
            "is_async": true,
            "line": 105
          },
          {
            "name": "get_prediction",
            "signature": "(prediction_id: str, session = Depends(get_session_dep), auth: AuthorityResult = Depends(require_predictions_read))",
            "docstring": "Get detailed prediction by ID (PB-S5).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.\nThis prediction is ADVISORY only.",
            "is_async": true,
            "line": 175
          },
          {
            "name": "get_predictions_for_subject",
            "signature": "(subject_type: str, subject_id: str, include_expired: bool = Query(False, description='Include expired predictions'), limit: int = Query(20, ge=1, le=100, description='Maximum results'), session = Depends(get_session_dep), auth: AuthorityResult = Depends(require_predictions_read))",
            "docstring": "Get all predictions for a specific subject (PB-S5).\n\nREAD-ONLY: This endpoint only reads data.\nReturns all advisory predictions for a worker/run/tenant.",
            "is_async": true,
            "line": 229
          },
          {
            "name": "get_prediction_stats",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), include_expired: bool = Query(False, description='Include expired predictions'), session = Depends(get_session_dep), auth: AuthorityResult = Depends(require_predictions_read))",
            "docstring": "Get prediction statistics (PB-S5).\n\nREAD-ONLY: This endpoint only reads aggregated data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 269
          }
        ],
        "classes": [
          {
            "name": "PredictionSummaryResponse",
            "docstring": "Summary of a prediction event.",
            "methods": [],
            "line": 55
          },
          {
            "name": "PredictionListResponse",
            "docstring": "Paginated list of predictions.",
            "methods": [],
            "line": 70
          },
          {
            "name": "PredictionDetailResponse",
            "docstring": "Detailed prediction event record.",
            "methods": [],
            "line": 81
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "emit_authority_audit",
              "require_predictions_read"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_operation_registry",
              "get_session_dep",
              "OperationContext"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "scenarios.py",
        "file_path": "backend/app/hoc/api/cus/analytics/scenarios.py",
        "layer": "L2_api",
        "domain": "analytics",
        "lines": 525,
        "module_docstring": "Scenario-based Cost Simulation API (H2)\n\nREAD-ONLY simulation endpoints for scenario planning.\n\nINVARIANTS:\n- Pure computation ONLY - no real budget changes\n- No side effects - no database writes for simulation results\n- Advisory only - results are informational, not actionable\n- Scenarios can be stored for re-use (stored in-memory for v1)\n\nEndpoints:\n- GET /scenarios - List available scenarios\n- POST /scenarios - Create new scenario\n- GET /scenarios/{id} - Get scenario details\n- DELETE /scenarios/{id} - Delete scenario\n- POST /scenarios/{id}/simulate - Run simulation (pure computation)\n- POST /scenarios/simulate-adhoc - Run one-off simulation without saving\n\nReference: Phase H2 - Cost Simulation v1",
        "functions": [
          {
            "name": "_init_default_scenarios",
            "signature": "()",
            "docstring": "Initialize default template scenarios for quick access.",
            "is_async": false,
            "line": 168
          },
          {
            "name": "_simulate_plan",
            "signature": "(plan: List[SimulationStepInput], budget_cents: int) -> SimulationResult",
            "docstring": "Run pure simulation on a plan.\n\nINVARIANT: This function has NO side effects.\n- No database writes\n- No external API calls\n- No budget mutations\n- Pure computation only",
            "is_async": false,
            "line": 220
          },
          {
            "name": "list_scenarios",
            "signature": "(include_templates: bool = Query(True, description='Include template scenarios'))",
            "docstring": "List all available scenarios.\n\nReturns both user-created scenarios and template scenarios.\nTemplates are pre-defined common scenarios for quick testing.",
            "is_async": true,
            "line": 338
          },
          {
            "name": "create_scenario",
            "signature": "(request: ScenarioCreate)",
            "docstring": "Create a new scenario.\n\nScenarios are stored in-memory for v1 (session-ephemeral).\nThis ensures no persistent side-effects from scenario creation.",
            "is_async": true,
            "line": 368
          },
          {
            "name": "get_scenario",
            "signature": "(scenario_id: str)",
            "docstring": "Get a specific scenario by ID.",
            "is_async": true,
            "line": 407
          },
          {
            "name": "delete_scenario",
            "signature": "(scenario_id: str)",
            "docstring": "Delete a scenario.\n\nTemplate scenarios cannot be deleted.",
            "is_async": true,
            "line": 428
          },
          {
            "name": "simulate_scenario",
            "signature": "(scenario_id: str, budget_override: Optional[int] = Query(None, ge=0, le=1000000, description='Override budget'))",
            "docstring": "Run simulation for a saved scenario.\n\nINVARIANT: Pure computation only.\n- No database writes\n- No budget mutations\n- No external side-effects\n- Results are advisory only",
            "is_async": true,
            "line": 451
          },
          {
            "name": "simulate_adhoc",
            "signature": "(request: AdhocSimulationRequest)",
            "docstring": "Run ad-hoc simulation without saving scenario.\n\nUse this for quick one-off simulations.\n\nINVARIANT: Pure computation only.\n- No database writes\n- No budget mutations\n- No external side-effects\n- Results are advisory only",
            "is_async": true,
            "line": 480
          },
          {
            "name": "get_immutability_info",
            "signature": "()",
            "docstring": "Get information about the immutability guarantees.\n\nThis endpoint documents the READ-ONLY nature of scenario simulations.",
            "is_async": true,
            "line": 507
          }
        ],
        "classes": [
          {
            "name": "SimulationStepInput",
            "docstring": "A single step in a simulation plan.",
            "methods": [],
            "line": 62
          },
          {
            "name": "ScenarioCreate",
            "docstring": "Request to create a new scenario.",
            "methods": [],
            "line": 70
          },
          {
            "name": "ScenarioModel",
            "docstring": "Stored scenario model.",
            "methods": [],
            "line": 79
          },
          {
            "name": "ScenarioResponse",
            "docstring": "Response for scenario operations.",
            "methods": [],
            "line": 92
          },
          {
            "name": "StepEstimate",
            "docstring": "Cost estimate for a single step.",
            "methods": [],
            "line": 105
          },
          {
            "name": "SimulationResult",
            "docstring": "Result of a scenario simulation (advisory only).",
            "methods": [],
            "line": 116
          },
          {
            "name": "AdhocSimulationRequest",
            "docstring": "Request for ad-hoc simulation without saving scenario.",
            "methods": [],
            "line": 156
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "verify_fops_token"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "analytics_facade.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/analytics_facade.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 628,
        "module_docstring": "Analytics Facade (L5)\n\nProvides unified access to analytics domain operations.\nThis is the single entry point for all analytics business logic.\n\nOperations:\n- get_usage_statistics: Get usage statistics for a time window\n- get_cost_statistics: Get cost statistics for a time window\n- get_status: Get analytics domain capability status\n\nSignal Sources:\n- cost_records (cost attribution)\n- llm.usage (LLM runs)\n- worker.execution (trace execution)\n- gateway.metrics (API gateway)\n\nReference: Analytics Domain Declaration v1",
        "functions": [
          {
            "name": "get_analytics_facade",
            "signature": "() -> AnalyticsFacade",
            "docstring": "Get the singleton AnalyticsFacade instance.",
            "is_async": false,
            "line": 623
          }
        ],
        "classes": [
          {
            "name": "TimeWindowResult",
            "docstring": "Time window specification.",
            "methods": [],
            "line": 73
          },
          {
            "name": "UsageTotalsResult",
            "docstring": "Aggregate usage totals.",
            "methods": [],
            "line": 82
          },
          {
            "name": "UsageDataPointResult",
            "docstring": "Single data point in usage time series.",
            "methods": [],
            "line": 91
          },
          {
            "name": "SignalSourceResult",
            "docstring": "Signal source metadata.",
            "methods": [],
            "line": 101
          },
          {
            "name": "UsageStatisticsResult",
            "docstring": "Usage statistics result.",
            "methods": [],
            "line": 109
          },
          {
            "name": "CostTotalsResult",
            "docstring": "Aggregate cost totals.",
            "methods": [],
            "line": 119
          },
          {
            "name": "CostDataPointResult",
            "docstring": "Single data point in cost time series.",
            "methods": [],
            "line": 130
          },
          {
            "name": "CostByModelResult",
            "docstring": "Cost breakdown by model.",
            "methods": [],
            "line": 141
          },
          {
            "name": "CostByFeatureResult",
            "docstring": "Cost breakdown by feature tag.",
            "methods": [],
            "line": 153
          },
          {
            "name": "CostStatisticsResult",
            "docstring": "Cost statistics result.",
            "methods": [],
            "line": 163
          },
          {
            "name": "TopicStatusResult",
            "docstring": "Status of a topic within a subdomain.",
            "methods": [],
            "line": 175
          },
          {
            "name": "AnalyticsStatusResult",
            "docstring": "Analytics domain status.",
            "methods": [],
            "line": 184
          },
          {
            "name": "SignalAdapter",
            "docstring": "Signal adapters for fetching data from various sources.\n\nFacade owns:\n- Time alignment\n- Cardinality control\n- Cross-signal reconciliation\n- Forward compatibility",
            "methods": [
              "fetch_cost_metrics",
              "fetch_llm_usage",
              "fetch_worker_execution",
              "fetch_cost_spend",
              "fetch_cost_by_model",
              "fetch_cost_by_feature"
            ],
            "line": 197
          },
          {
            "name": "AnalyticsFacade",
            "docstring": "Unified facade for Analytics domain operations.\n\nThis class provides a single entry point for all analytics business logic.",
            "methods": [
              "__init__",
              "get_usage_statistics",
              "get_cost_statistics",
              "get_status",
              "_calculate_freshness",
              "_calculate_freshness_from_cost"
            ],
            "line": 318
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.hoc.cus.analytics.L6_drivers.analytics_read_driver",
            "names": [
              "get_analytics_read_driver"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.analytics.L5_schemas.query_types",
            "names": [
              "ResolutionType",
              "ScopeType"
            ],
            "is_relative": false,
            "line": 64
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "costsim_models.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/costsim_models.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 306,
        "module_docstring": "Data models for CostSim V2 sandbox evaluation.",
        "functions": [],
        "classes": [
          {
            "name": "V2SimulationStatus",
            "docstring": "V2 simulation result status.",
            "methods": [],
            "line": 34
          },
          {
            "name": "ComparisonVerdict",
            "docstring": "Verdict from V1 vs V2 comparison.",
            "methods": [],
            "line": 43
          },
          {
            "name": "V2SimulationResult",
            "docstring": "Result from CostSim V2 simulation.",
            "methods": [
              "to_dict",
              "compute_output_hash"
            ],
            "line": 53
          },
          {
            "name": "ComparisonResult",
            "docstring": "Result of comparing V2 vs V1 simulation.",
            "methods": [
              "to_dict"
            ],
            "line": 110
          },
          {
            "name": "DiffResult",
            "docstring": "Detailed diff between two simulation results.",
            "methods": [
              "to_dict"
            ],
            "line": 151
          },
          {
            "name": "CanaryReport",
            "docstring": "Report from daily canary run.",
            "methods": [
              "to_dict"
            ],
            "line": 183
          },
          {
            "name": "DivergenceReport",
            "docstring": "Cost divergence report between V1 and V2.",
            "methods": [
              "to_dict"
            ],
            "line": 234
          },
          {
            "name": "ValidationResult",
            "docstring": "Result of validating V2 against a reference dataset.",
            "methods": [
              "to_dict"
            ],
            "line": 271
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "detection_facade.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/detection_facade.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 615,
        "module_docstring": "Detection Facade (L5 Domain Engine)\n\nThis facade provides the external interface for anomaly detection operations.\nAll detection APIs MUST use this facade instead of directly importing\ninternal detection modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes anomaly detection logic\n- Provides unified access to cost, behavioral, and policy anomalies\n- Single point for audit emission\n\nWrapped Services:\n- CostAnomalyDetector: Cost anomaly detection (GAP-066)\n- (Future) BehavioralDetector: Behavioral anomaly detection\n- (Future) DriftDetector: Model drift detection\n\nL2 API Routes (GAP-102):\n- POST /api/v1/detection/run (run detection on demand)\n- GET /api/v1/detection/anomalies (list anomalies)\n- GET /api/v1/detection/anomalies/{id} (get anomaly)\n- POST /api/v1/detection/anomalies/{id}/resolve (resolve anomaly)\n- GET /api/v1/detection/status (detection engine status)\n\nUsage:\n    from app.hoc.cus.analytics.L5_engines.detection_facade import get_detection_facade\n\n    facade = get_detection_facade()\n\n    # Run detection\n    result = await facade.run_detection(tenant_id=\"...\", detection_type=\"cost\")\n\n    # List anomalies\n    anomalies = await facade.list_anomalies(tenant_id=\"...\")",
        "functions": [
          {
            "name": "get_detection_facade",
            "signature": "(anomaly_coordinator: Optional[AnomalyCoordinatorPort] = None) -> DetectionFacade",
            "docstring": "Get the detection facade instance.\n\nThis is the recommended way to access detection operations\nfrom L2 APIs and the SDK.\n\nPIN-520: L4 callers must inject anomaly_coordinator.\nL5 must not import from hoc_spine.\n\nArgs:\n    anomaly_coordinator: Optional coordinator for cost anomaly detection.\n                         Required for cost detection to work (injected by L4 caller).\n\nReturns:\n    DetectionFacade instance",
            "is_async": false,
            "line": 590
          }
        ],
        "classes": [
          {
            "name": "AnomalyCoordinatorPort",
            "docstring": "Protocol for anomaly detection + incident ingestion (PIN-520 L5 purity).\n\nL5 declares what it needs; L4 provides the implementation via bridge.\nThis removes the L5 \u2192 L4 orchestrator import violation.",
            "methods": [
              "detect_and_ingest"
            ],
            "line": 72
          },
          {
            "name": "DetectionType",
            "docstring": "Types of anomaly detection.",
            "methods": [],
            "line": 87
          },
          {
            "name": "AnomalyStatus",
            "docstring": "Anomaly resolution status.",
            "methods": [],
            "line": 102
          },
          {
            "name": "DetectionResult",
            "docstring": "Result of a detection run.",
            "methods": [
              "to_dict"
            ],
            "line": 111
          },
          {
            "name": "AnomalyInfo",
            "docstring": "Anomaly information.",
            "methods": [
              "to_dict"
            ],
            "line": 137
          },
          {
            "name": "DetectionStatusInfo",
            "docstring": "Detection engine status.",
            "methods": [
              "to_dict"
            ],
            "line": 181
          },
          {
            "name": "DetectionFacade",
            "docstring": "Facade for anomaly detection operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ndetection services.\n\nLayer: L5 (Domain Engine)\nCallers: detection.py (L2), aos_sdk, Worker\n\nPIN-520: anomaly_coordinator is now injected via L4 bridge instead of\nbeing imported directly from L4 orchestrator.",
            "methods": [
              "__init__",
              "cost_detector",
              "run_detection",
              "_run_cost_detection",
              "list_anomalies",
              "get_anomaly",
              "resolve_anomaly",
              "acknowledge_anomaly",
              "get_detection_status"
            ],
            "line": 198
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Protocol"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.cost_anomaly_detector_engine",
            "names": [
              "AnomalySeverity"
            ],
            "is_relative": false,
            "line": 97
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "provenance.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/provenance.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 413,
        "module_docstring": "Full provenance logging for CostSim V2 sandbox.\n\nLogs:\n- input_hash: SHA256 of input\n- output_hash: SHA256 of output\n- input_json: Full input (optionally compressed)\n- output_json: Full output (optionally compressed)\n- model_version: V2 model version\n- adapter_version: Adapter version\n- commit_sha: Git commit\n- runtime_ms: Execution time\n- status: success/error/schema_error\n- tenant_id: Tenant if present",
        "functions": [
          {
            "name": "compute_hash",
            "signature": "(data: Any) -> str",
            "docstring": "Compute SHA256 hash of data.",
            "is_async": false,
            "line": 143
          },
          {
            "name": "compress_json",
            "signature": "(data: Any) -> str",
            "docstring": "Compress JSON data to base64-encoded gzip.",
            "is_async": false,
            "line": 152
          },
          {
            "name": "get_provenance_logger",
            "signature": "() -> ProvenanceLogger",
            "docstring": "Get the global provenance logger.",
            "is_async": false,
            "line": 408
          }
        ],
        "classes": [
          {
            "name": "ProvenanceLog",
            "docstring": "Single provenance log entry.",
            "methods": [
              "to_dict",
              "from_dict",
              "get_decompressed_input",
              "get_decompressed_output"
            ],
            "line": 56
          },
          {
            "name": "ProvenanceLogger",
            "docstring": "Logger for CostSim V2 provenance.\n\nStores provenance logs for every V2 simulation for:\n- Audit trail\n- Debugging\n- Drift analysis\n- Replay capability",
            "methods": [
              "__init__",
              "log",
              "_store",
              "_flush",
              "_write_to_file",
              "_write_to_db",
              "close",
              "query"
            ],
            "line": 159
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "base64",
            "names": [
              "base64"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "gzip",
            "names": [
              "gzip"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.config_engine",
            "names": [
              "get_commit_sha",
              "get_config"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [
      {
        "file_name": "cost_snapshot_schemas.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_schemas/cost_snapshot_schemas.py",
        "layer": "L5_schemas",
        "domain": "analytics",
        "lines": 302,
        "module_docstring": "M27 Cost Snapshot Schemas\n\nDataclasses and enums for the cost snapshot system.",
        "functions": [],
        "classes": [
          {
            "name": "SnapshotType",
            "docstring": null,
            "methods": [],
            "line": 32
          },
          {
            "name": "SnapshotStatus",
            "docstring": null,
            "methods": [],
            "line": 37
          },
          {
            "name": "EntityType",
            "docstring": null,
            "methods": [],
            "line": 44
          },
          {
            "name": "CostSnapshot",
            "docstring": "Point-in-time cost snapshot definition.",
            "methods": [
              "create",
              "to_dict"
            ],
            "line": 66
          },
          {
            "name": "SnapshotAggregate",
            "docstring": "Aggregated cost data for an entity within a snapshot.",
            "methods": [
              "create"
            ],
            "line": 119
          },
          {
            "name": "SnapshotBaseline",
            "docstring": "Rolling baseline for an entity (used for anomaly threshold).",
            "methods": [
              "create"
            ],
            "line": 170
          },
          {
            "name": "AnomalyEvaluation",
            "docstring": "Audit record for an anomaly evaluation.",
            "methods": [],
            "line": 227
          },
          {
            "name": "CostSnapshotsDriverProtocol",
            "docstring": "Typed boundary contract for cost snapshot database operations.\n\nPIN-508 Gap 1: L5\u2194L6 boundary enforced by Protocol, not convention.\nL5 engines accept this Protocol \u2014 they never see a session.",
            "methods": [
              "insert_snapshot",
              "update_snapshot",
              "insert_aggregate",
              "get_current_baseline",
              "aggregate_cost_records",
              "insert_baseline",
              "get_snapshot",
              "get_aggregates_with_baseline",
              "insert_evaluation",
              "insert_anomaly",
              "compute_baselines"
            ],
            "line": 252
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [
          {
            "name": "SEVERITY_THRESHOLDS",
            "line": 52
          }
        ],
        "all_exports": null
      }
    ],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "analytics_read_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/analytics_read_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 376,
        "module_docstring": "Analytics Read Driver (L6 Data Access)\n\nHandles database operations for analytics queries:\n- Fetching cost metrics from cost_records\n- Fetching LLM usage from runs\n- Fetching worker execution from aos_traces\n- Fetching cost breakdowns by model and feature\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_analytics_read_driver",
            "signature": "(session: AsyncSession) -> AnalyticsReadDriver",
            "docstring": "Get an AnalyticsReadDriver instance.",
            "is_async": false,
            "line": 374
          }
        ],
        "classes": [
          {
            "name": "AnalyticsReadDriver",
            "docstring": "L6 Driver for analytics read operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (time alignment, reconciliation) stay in L5.",
            "methods": [
              "__init__",
              "fetch_cost_metrics",
              "fetch_llm_usage",
              "fetch_worker_execution",
              "fetch_cost_spend",
              "fetch_cost_by_model",
              "fetch_cost_by_feature"
            ],
            "line": 49
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cost_anomaly_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/cost_anomaly_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 992,
        "module_docstring": "Cost Anomaly Driver (L6)\n\nPure database operations for cost anomaly detection.\nAll business logic stays in L4 engine.\n\nOperations:\n- Read baseline/today aggregations for spike detection\n- Read rolling/baseline averages for drift detection\n- Read/write breach history for consecutive tracking\n- Read/write drift tracking state\n- Read cost metrics for cause derivation\n- Persist CostAnomaly records\n\nNO business logic:\n- NO threshold comparisons (L4)\n- NO severity classification (L4)\n- NO anomaly type decisions (L4)\n\nReference: Phase-2.5A Analytics Extraction",
        "functions": [
          {
            "name": "get_cost_anomaly_driver",
            "signature": "(session: Session) -> CostAnomalyDriver",
            "docstring": "Factory function to get CostAnomalyDriver instance.",
            "is_async": false,
            "line": 984
          }
        ],
        "classes": [
          {
            "name": "CostAnomalyDriver",
            "docstring": "L6 driver for cost anomaly detection data access.\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "fetch_entity_baseline",
              "fetch_entity_today_spend",
              "fetch_tenant_baseline",
              "fetch_tenant_today_spend",
              "fetch_rolling_avg",
              "fetch_baseline_avg",
              "fetch_daily_spend",
              "fetch_monthly_spend",
              "fetch_breach_exists_today",
              "insert_breach_history",
              "fetch_consecutive_breaches",
              "fetch_drift_tracking",
              "update_drift_tracking",
              "insert_drift_tracking",
              "reset_drift_tracking",
              "fetch_retry_comparison",
              "fetch_prompt_comparison",
              "fetch_feature_concentration",
              "fetch_request_comparison"
            ],
            "line": 95
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime"
            ],
            "is_relative": false,
            "line": 88
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 89
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 91
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 92
          }
        ],
        "constants": [],
        "all_exports": [
          "CostAnomalyDriver",
          "get_cost_anomaly_driver"
        ]
      },
      {
        "file_name": "cost_write_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/cost_write_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 250,
        "module_docstring": "Cost Write Driver (L6)\n\nPure database write operations for Cost Intelligence.\n\nL4 (CostWriteService) \u2192 L6 (this driver)\n\nResponsibilities:\n- Persist FeatureTag records\n- Persist CostRecord records\n- Persist CostBudget records\n- NO business logic (L4 responsibility)\n\nReference: PIN-250, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_cost_write_driver",
            "signature": "(session: Session) -> CostWriteDriver",
            "docstring": "Factory function to get CostWriteDriver instance.",
            "is_async": false,
            "line": 242
          }
        ],
        "classes": [
          {
            "name": "CostWriteDriver",
            "docstring": "L6 driver for cost write operations.\n\nPure database access - no business logic.",
            "methods": [
              "__init__",
              "create_feature_tag",
              "update_feature_tag",
              "create_cost_record",
              "create_or_update_budget"
            ],
            "line": 52
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.db",
            "names": [
              "CostBudget",
              "CostRecord",
              "FeatureTag"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": [
          "CostWriteDriver",
          "get_cost_write_driver"
        ]
      },
      {
        "file_name": "pattern_detection_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/pattern_detection_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 209,
        "module_docstring": "Pattern Detection Driver (L6 Data Access)\n\nHandles all database operations for pattern detection:\n- Fetching failed runs for pattern analysis\n- Fetching completed runs for cost spike detection\n- Inserting pattern feedback records\n- Querying feedback summaries\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_pattern_detection_driver",
            "signature": "(session: AsyncSession) -> PatternDetectionDriver",
            "docstring": "Get a PatternDetectionDriver instance.",
            "is_async": false,
            "line": 207
          }
        ],
        "classes": [
          {
            "name": "PatternDetectionDriver",
            "docstring": "L6 Driver for pattern detection data operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (threshold checks, pattern grouping) stay in L5.",
            "methods": [
              "__init__",
              "fetch_failed_runs",
              "fetch_completed_runs_with_costs",
              "insert_feedback",
              "fetch_feedback_records"
            ],
            "line": 53
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.models.feedback",
            "names": [
              "PatternFeedback"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "prediction_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/prediction_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 319,
        "module_docstring": "Prediction Driver (L6)\n\nPure database operations for prediction management.\nAll business logic stays in L4 engine.\n\nOperations:\n- Read failure patterns from feedback\n- Read failed runs and totals\n- Read cost data for projections\n- Read prediction events\n- Insert new prediction events\n\nNO business logic:\n- NO prediction math (L4)\n- NO confidence calculations (L4)\n- NO threshold comparisons (L4)\n\nReference: Phase-2.5A Analytics Extraction",
        "functions": [
          {
            "name": "get_prediction_driver",
            "signature": "(session: AsyncSession) -> PredictionDriver",
            "docstring": "Factory function to get PredictionDriver instance.",
            "is_async": false,
            "line": 311
          }
        ],
        "classes": [
          {
            "name": "PredictionDriver",
            "docstring": "L6 driver for prediction data access.\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "fetch_failure_patterns",
              "fetch_failed_runs",
              "fetch_run_totals",
              "fetch_cost_runs",
              "fetch_predictions",
              "insert_prediction"
            ],
            "line": 75
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.models.feedback",
            "names": [
              "PatternFeedback"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "app.models.prediction",
            "names": [
              "PredictionEvent"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 72
          }
        ],
        "constants": [],
        "all_exports": [
          "PredictionDriver",
          "get_prediction_driver"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 14,
    "violation_count": 0,
    "gap_count": 2
  },
  "integrations": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/integrations.py",
    "l2_apis": [
      {
        "file_name": "cus_telemetry.py",
        "file_path": "backend/app/hoc/api/cus/integrations/cus_telemetry.py",
        "layer": "L2_api",
        "domain": "integrations",
        "lines": 391,
        "module_docstring": "Customer LLM Telemetry Ingestion API\n\nPURPOSE:\n    Receives telemetry data from customer SDKs reporting LLM usage.\n    This is the DATA PLANE ingestion surface - it records facts about\n    what happened during LLM calls.\n\nENDPOINTS:\n    POST /telemetry/llm-usage     - Single call telemetry\n    POST /telemetry/llm-usage/batch - Batch telemetry (up to 100 records)\n    GET  /telemetry/usage-summary  - Usage summary for dashboard\n\nSEMANTIC:\n    - Append-only: Telemetry records are never updated or deleted\n    - Idempotent: call_id prevents duplicate ingestion\n    - Tenant-isolated: All data scoped to authenticated tenant\n\nAUTHENTICATION:\n    Uses integration API key (X-CUS-Integration-Key header) to identify\n    both the tenant and the specific integration being reported.",
        "functions": [
          {
            "name": "get_integration_context",
            "signature": "(request: Request, x_cus_integration_key: Optional[str] = Header(None, alias='X-CUS-Integration-Key')) -> dict",
            "docstring": "Extract and validate integration context from request.\n\nThe integration key encodes both tenant_id and integration_id,\nallowing SDK to authenticate and route telemetry.\n\nReturns:\n    dict with tenant_id and integration_id",
            "is_async": true,
            "line": 63
          },
          {
            "name": "ingest_llm_usage",
            "signature": "(payload: CusLLMUsageIngest, ctx: dict = Depends(get_integration_context))",
            "docstring": "Ingest a single LLM usage telemetry record.\n\nPURPOSE:\n    SDK calls this endpoint after each LLM call to report:\n    - Token counts (input/output)\n    - Cost calculation\n    - Latency measurement\n    - Policy enforcement result\n\nIDEMPOTENCY:\n    The call_id field serves as an idempotency key. If a record\n    with the same call_id already exists, this is a no-op.\n\nArgs:\n    payload: Telemetry data from SDK\n\nReturns:\n    Envelope with ingestion result",
            "is_async": true,
            "line": 110
          },
          {
            "name": "ingest_llm_usage_batch",
            "signature": "(payload: CusLLMUsageBatchIngest, ctx: dict = Depends(get_integration_context))",
            "docstring": "Ingest a batch of LLM usage telemetry records.\n\nPURPOSE:\n    SDK may buffer telemetry and send in batches for efficiency.\n    Maximum 100 records per batch.\n\nIDEMPOTENCY:\n    Each record's call_id is checked. Duplicates are silently ignored.\n\nArgs:\n    payload: Batch of telemetry records\n\nReturns:\n    Envelope with batch ingestion result (accepted/duplicates counts)",
            "is_async": true,
            "line": 172
          },
          {
            "name": "get_usage_summary",
            "signature": "(request: Request, integration_id: Optional[str] = Query(None, description='Filter by integration'), start_date: Optional[date] = Query(None, description='Period start (default: 30 days ago)'), end_date: Optional[date] = Query(None, description='Period end (default: today)'), ctx: dict = Depends(get_integration_context))",
            "docstring": "Get aggregated usage summary for dashboard.\n\nPURPOSE:\n    Provides rolled-up usage statistics for a tenant's integrations.\n    Used by dashboard to show cost, token, and call totals.\n\nArgs:\n    integration_id: Optional filter for specific integration\n    start_date: Period start (default: 30 days ago)\n    end_date: Period end (default: today)\n\nReturns:\n    CusUsageSummary with aggregated metrics",
            "is_async": true,
            "line": 225
          },
          {
            "name": "get_usage_history",
            "signature": "(request: Request, integration_id: Optional[str] = Query(None, description='Filter by integration'), limit: int = Query(50, ge=1, le=1000, description='Max records to return'), offset: int = Query(0, ge=0, description='Offset for pagination'), ctx: dict = Depends(get_integration_context))",
            "docstring": "Get detailed usage history records.\n\nPURPOSE:\n    Detailed view of individual LLM calls for audit and debugging.\n    Paginated for large datasets.\n\nArgs:\n    integration_id: Optional filter for specific integration\n    limit: Max records per page (default 50, max 1000)\n    offset: Pagination offset\n\nReturns:\n    List of CusLLMUsageResponse records",
            "is_async": true,
            "line": 282
          },
          {
            "name": "get_daily_aggregates",
            "signature": "(request: Request, integration_id: Optional[str] = Query(None, description='Filter by integration'), start_date: Optional[date] = Query(None, description='Period start'), end_date: Optional[date] = Query(None, description='Period end'), ctx: dict = Depends(get_integration_context))",
            "docstring": "Get daily aggregated usage for charts.\n\nPURPOSE:\n    Pre-computed daily aggregates for time-series visualization.\n    More efficient than computing from raw usage records.\n\nArgs:\n    integration_id: Optional filter for specific integration\n    start_date: Period start (default: 30 days ago)\n    end_date: Period end (default: today)\n\nReturns:\n    List of daily aggregate records",
            "is_async": true,
            "line": 338
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "date",
              "timedelta"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "Header",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.cus_schemas",
            "names": [
              "CusLLMUsageBatchIngest",
              "CusLLMUsageIngest",
              "CusLLMUsageResponse",
              "CusUsageSummary"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict",
              "wrap_error",
              "wrap_list"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "protection_dependencies.py",
        "file_path": "backend/app/hoc/api/cus/integrations/protection_dependencies.py",
        "layer": "L2_api",
        "domain": "integrations",
        "lines": 243,
        "module_docstring": "Phase-7 Protection Dependencies \u2014 FastAPI Integration\n\nProvides dependencies for protection checks in API endpoints.\n\nENFORCEMENT SURFACE:\n    Protection applies to:\n    - SDK endpoints\n    - Runtime execution paths\n    - Background workers\n\n    Protection does NOT apply to:\n    - Onboarding endpoints\n    - Auth endpoints\n    - Founder endpoints\n    - Internal ops endpoints\n\nDESIGN INVARIANTS:\n- ABUSE-001: Protection does not affect onboarding, roles, or billing state\n- ABUSE-002: All enforcement outcomes are explicit (no silent failure)\n- ABUSE-003: Anomaly detection never blocks user traffic",
        "functions": [
          {
            "name": "is_exempt_endpoint",
            "signature": "(path: str) -> bool",
            "docstring": "Check if an endpoint is exempt from protection.",
            "is_async": false,
            "line": 89
          },
          {
            "name": "check_protection",
            "signature": "(request: Request) -> ProtectionContext",
            "docstring": "FastAPI dependency: Run protection checks for current request.\n\nReturns ProtectionContext with decision and any anomaly signals.\nDoes NOT raise exceptions - caller decides how to handle.\n\nUsage:\n    @router.post(\"/runs\")\n    async def create_run(\n        protection: ProtectionContext = Depends(check_protection),\n    ):\n        if protection.result.decision == Decision.REJECT:\n            raise HTTPException(status_code=429, detail=protection.result.to_error_response())\n        ...",
            "is_async": false,
            "line": 94
          },
          {
            "name": "require_protection_allow",
            "signature": "(request: Request) -> ProtectionContext",
            "docstring": "FastAPI dependency: Require protection checks to pass.\n\nRaises HTTP 429 if protection rejects the request.\nRaises HTTP 503 if protection throttles (with Retry-After header).\n\nUsage:\n    @router.post(\"/runs\")\n    async def create_run(\n        protection: ProtectionContext = Depends(require_protection_allow),\n    ):\n        # Protection checks passed\n        ...",
            "is_async": false,
            "line": 176
          },
          {
            "name": "emit_protection_event",
            "signature": "(context: ProtectionContext) -> dict",
            "docstring": "Emit a structured protection event for observability.\n\nPer Phase-7 design Section 7.9, all rejections emit structured events.\n\nReturns:\n    Event dict suitable for logging/dashboards",
            "is_async": false,
            "line": 212
          }
        ],
        "classes": [
          {
            "name": "ProtectionContext",
            "docstring": "Protection context for a request.\n\nAttributes:\n    tenant_id: The tenant identifier\n    endpoint: The endpoint being accessed\n    operation: The operation being performed\n    result: Result of protection checks\n    anomaly: Anomaly signal if detected (non-blocking)\n    is_exempt: True if endpoint is exempt from protection",
            "methods": [],
            "line": 68
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "fastapi",
            "names": [
              "Request",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.protection.decisions",
            "names": [
              "Decision",
              "ProtectionResult",
              "AnomalySignal",
              "allow"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.protection.provider",
            "names": [
              "get_protection_provider"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.onboarding_state",
            "names": [
              "OnboardingState"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [
          {
            "name": "EXEMPT_PREFIXES",
            "line": 55
          }
        ],
        "all_exports": [
          "ProtectionContext",
          "check_protection",
          "require_protection_allow",
          "emit_protection_event",
          "is_exempt_endpoint",
          "EXEMPT_PREFIXES"
        ]
      },
      {
        "file_name": "session_context.py",
        "file_path": "backend/app/hoc/api/cus/integrations/session_context.py",
        "layer": "L2_api",
        "domain": "integrations",
        "lines": 155,
        "module_docstring": "Session Context API\n\nPIN-409: Provides verified session context to frontend.\n\nThis endpoint replaces frontend-derived authorization facts (isFounder, audience)\nwith backend-verified context. The frontend reads, never infers.\n\nEndpoint:\n    GET /session/context - Get current session context\n\nResponse:\n    {\n        \"actor_type\": \"customer\" | \"founder\" | \"machine\",\n        \"tenant_id\": \"...\",\n        \"capabilities\": [...],  // for machine clients only\n        \"lifecycle_state\": \"ACTIVE\" | \"SUSPENDED\" | \"TERMINATED\" | \"ARCHIVED\",\n        \"onboarding_state\": \"CREATED\" | \"IDENTITY_VERIFIED\" | ... | \"COMPLETE\"\n    }\n\nRULE-AUTH-UI-001: Frontend never decides 'who I am' beyond signed-in vs not.\nThis endpoint is the single source of truth for authorization facts.",
        "functions": [
          {
            "name": "get_session_context",
            "signature": "(request: Request) -> Dict[str, Any]",
            "docstring": "Get verified session context for the current authenticated user.\n\nThis endpoint returns authorization facts derived from the verified\nbackend context. The frontend should use these values instead of\nderiving them locally.\n\nReturns:\n    actor_type: \"customer\" | \"founder\" | \"machine\"\n    tenant_id: Tenant ID if applicable (null for founders)\n    capabilities: List of scopes for machine clients (empty for humans)\n    lifecycle_state: Current tenant lifecycle state (for tenant-scoped actors)\n    onboarding_state: Current onboarding state (for tenant-scoped actors)\n\nRaises:\n    401: Not authenticated",
            "is_async": true,
            "line": 57
          },
          {
            "name": "_fetch_lifecycle_state_name",
            "signature": "(tenant_id: str) -> str",
            "docstring": "Fetch lifecycle state name from DB (Tenant.status).",
            "is_async": true,
            "line": 132
          },
          {
            "name": "_get_onboarding_state",
            "signature": "(tenant_id: str) -> str",
            "docstring": "Fetch onboarding state name from DB (Tenant.onboarding_state).",
            "is_async": true,
            "line": 145
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Request",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.contexts",
            "names": [
              "FounderAuthContext",
              "HumanAuthContext",
              "MachineCapabilityContext"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "get_async_session_context",
              "sql_text"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.tenant_lifecycle_enums",
            "names": [
              "normalize_status"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "connectors_facade.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/connectors_facade.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 439,
        "module_docstring": "Connectors Facade (L4 Domain Logic)\n\nThis facade provides the external interface for connector operations.\nAll connector APIs MUST use this facade instead of directly importing\ninternal connector modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes connector management logic\n- Provides unified access to HTTP, SQL, MCP connectors\n- Single point for audit emission\n\nWrapped Services:\n- ConnectorRegistry: Connector registration and management\n- HTTPConnector: HTTP/REST connector (GAP-059)\n- SQLConnector: SQL database connector (GAP-060)\n- MCPConnector: MCP protocol connector (GAP-063)\n\nL2 API Routes (GAP-093):\n- GET /api/v1/connectors (list connectors)\n- POST /api/v1/connectors (register connector)\n- GET /api/v1/connectors/{id} (get connector)\n- PUT /api/v1/connectors/{id} (update connector)\n- DELETE /api/v1/connectors/{id} (delete connector)\n- POST /api/v1/connectors/{id}/test (test connector)\n\nUsage:\n    # L5 engine import (migrated to HOC per SWEEP-13)\n    from app.hoc.cus.integrations.L5_engines.connectors_facade import get_connectors_facade\n\n    facade = get_connectors_facade()\n\n    # List connectors\n    connectors = await facade.list_connectors(tenant_id=\"...\")\n\n    # Register a new connector\n    connector = await facade.register_connector(...)\n\n    # Test connection\n    result = await facade.test_connector(connector_id=\"...\")",
        "functions": [
          {
            "name": "get_connectors_facade",
            "signature": "() -> ConnectorsFacade",
            "docstring": "Get the connectors facade instance.\n\nThis is the recommended way to access connector operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    ConnectorsFacade instance",
            "is_async": false,
            "line": 426
          }
        ],
        "classes": [
          {
            "name": "ConnectorInfo",
            "docstring": "Connector information.",
            "methods": [
              "to_dict"
            ],
            "line": 73
          },
          {
            "name": "TestResult",
            "docstring": "Result of connector test.",
            "methods": [
              "to_dict"
            ],
            "line": 107
          },
          {
            "name": "ConnectorsFacade",
            "docstring": "Facade for connector operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nconnector services.\n\nLayer: L4 (Domain Logic)\nCallers: connectors.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "registry",
              "list_connectors",
              "get_connector",
              "register_connector",
              "update_connector",
              "delete_connector",
              "test_connector",
              "_get_capabilities_for_type"
            ],
            "line": 126
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "protocol.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/credentials/protocol.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 63,
        "module_docstring": "CredentialService Protocol \u2014 Canonical Definition\n\nThis is the CANONICAL and ONLY authoritative definition of the\nCredentialService protocol used by connector services.\n\nHistory:\n    Previously duplicated in:\n    - http_connector.py (lines 106-112)\n    - mcp_connector.py (lines 97-103)\n    - sql_gateway.py (lines 121-127)\n\n    Consolidated here per INT-DUP-002 quarantine resolution.",
        "functions": [],
        "classes": [
          {
            "name": "CredentialService",
            "docstring": "Protocol for credential service.\n\nDefines the contract for services that retrieve credentials\nfrom a vault or other secure storage. Connector services\ndepend on this protocol for authentication.\n\nImplementations:\n    - CusCredentialService (vault/engines/cus_credential_service.py)\n    - Any vault adapter that provides credential retrieval",
            "methods": [
              "get"
            ],
            "line": 40
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.types",
            "names": [
              "Credential"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_health_engine.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/cus_health_engine.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 542,
        "module_docstring": "Customer Health Engine\n\nPURPOSE:\n    Provider reachability and credential validation for customer LLM integrations.\n    Performs lightweight health checks without consuming significant quota.\n\nRESPONSIBILITIES:\n    - Test provider connectivity\n    - Validate credentials are still valid\n    - Measure response latency\n    - Update health state in integrations\n\nHEALTH STATES:\n    - UNKNOWN: Never checked or no recent data\n    - HEALTHY: Last check successful\n    - DEGRADED: Slow or partial responses\n    - UNHEALTHY: Check failed\n\nCHECK STRATEGY:\n    - OpenAI: GET /models endpoint (lightweight, no tokens)\n    - Anthropic: POST /messages with max_tokens=1 (minimal cost)\n    - Google: GET /models endpoint\n    - Others: Provider-specific lightweight calls\n\nRATE LIMITING:\n    - Maximum one check per integration per minute\n    - Batch checks spread over time\n    - Failed integrations checked less frequently",
        "functions": [],
        "classes": [
          {
            "name": "CusHealthService",
            "docstring": "Service for health checking customer LLM integrations.\n\nPhase 4: Provider reachability and credential validation.",
            "methods": [
              "__init__",
              "_get_driver",
              "check_health",
              "_perform_health_check",
              "check_all_integrations",
              "get_health_summary",
              "_calculate_overall_health"
            ],
            "line": 72
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "contextlib",
            "names": [
              "contextmanager"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.integrations.L5_schemas.cus_enums",
            "names": [
              "CusHealthState"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.cus_credential_engine",
            "names": [
              "CusCredentialService"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.hoc.cus.integrations.L6_drivers.cus_health_driver",
            "names": [
              "CusHealthDriver",
              "HealthIntegrationRow",
              "cus_health_driver_session"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "datasources_facade.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/datasources_facade.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 451,
        "module_docstring": "DataSources Facade (L4 Domain Logic)\n\nThis facade provides the external interface for data source operations.\nAll data source APIs MUST use this facade instead of directly importing\ninternal datasource modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes data source management\n- Provides unified access to source configuration\n- Single point for audit emission\n\nL2 API Routes (GAP-113):\n- POST /api/v1/datasources (create source)\n- GET /api/v1/datasources (list sources)\n- GET /api/v1/datasources/{id} (get source)\n- PUT /api/v1/datasources/{id} (update source)\n- DELETE /api/v1/datasources/{id} (delete source)\n- POST /api/v1/datasources/{id}/test (test connection)\n- POST /api/v1/datasources/{id}/activate (activate source)\n- POST /api/v1/datasources/{id}/deactivate (deactivate source)\n- GET /api/v1/datasources/stats (statistics)\n\nUsage:\n    from app.hoc.cus.integrations.L5_engines.datasources_facade import get_datasources_facade\n\n    facade = get_datasources_facade()\n\n    # Register data source\n    source = await facade.register_source(\n        tenant_id=\"...\",\n        name=\"Production DB\",\n        source_type=\"database\",\n        config={...},\n    )",
        "functions": [
          {
            "name": "get_datasources_facade",
            "signature": "() -> DataSourcesFacade",
            "docstring": "Get the data sources facade instance.\n\nThis is the recommended way to access data source operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    DataSourcesFacade instance",
            "is_async": false,
            "line": 438
          }
        ],
        "classes": [
          {
            "name": "TestConnectionResult",
            "docstring": "Result of testing a data source connection.",
            "methods": [
              "to_dict"
            ],
            "line": 75
          },
          {
            "name": "DataSourcesFacade",
            "docstring": "Facade for data source operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ndata source services.\n\nLayer: L4 (Domain Logic)\nCallers: datasources.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "registry",
              "register_source",
              "list_sources",
              "get_source",
              "update_source",
              "delete_source",
              "test_connection",
              "activate_source",
              "deactivate_source",
              "get_statistics"
            ],
            "line": 92
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.integrations.L5_schemas.datasource_model",
            "names": [
              "CustomerDataSource",
              "DataSourceConfig",
              "DataSourceRegistry",
              "DataSourceStats",
              "DataSourceStatus",
              "DataSourceType",
              "get_datasource_registry"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "integrations_facade.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/integrations_facade.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 506,
        "module_docstring": "Integrations Domain Facade (L4)\n\nUnified facade for LLM integration management (BYOK - Bring Your Own Key).\n\nProvides:\n- CRUD: list, get, create, update, delete integrations\n- Lifecycle: enable, disable\n- Health: get health status, test credentials\n- Limits: get usage vs limits\n\nThis facade wraps the CusIntegrationEngine and provides dataclass result types\nfor consistency with other domain facades.",
        "functions": [
          {
            "name": "get_integrations_facade",
            "signature": "(session) -> IntegrationsFacade",
            "docstring": "Get an IntegrationsFacade instance.\n\nArgs:\n    session: Database session from L4 handler (required)\n\nReturns:\n    IntegrationsFacade instance\n\nNote:\n    Session is REQUIRED. L4 handler owns transaction boundary.\n    Not a singleton \u2014 each request creates a new facade with its session.",
            "is_async": false,
            "line": 477
          }
        ],
        "classes": [
          {
            "name": "IntegrationSummaryResult",
            "docstring": "Integration summary for list view.",
            "methods": [],
            "line": 53
          },
          {
            "name": "IntegrationListResult",
            "docstring": "Integration list response.",
            "methods": [],
            "line": 66
          },
          {
            "name": "IntegrationDetailResult",
            "docstring": "Integration detail response.",
            "methods": [],
            "line": 74
          },
          {
            "name": "IntegrationLifecycleResult",
            "docstring": "Result of enable/disable operation.",
            "methods": [],
            "line": 95
          },
          {
            "name": "IntegrationDeleteResult",
            "docstring": "Result of delete operation.",
            "methods": [],
            "line": 104
          },
          {
            "name": "HealthCheckResult",
            "docstring": "Health check result.",
            "methods": [],
            "line": 112
          },
          {
            "name": "HealthStatusResult",
            "docstring": "Cached health status.",
            "methods": [],
            "line": 123
          },
          {
            "name": "LimitsStatusResult",
            "docstring": "Usage vs limits status.",
            "methods": [],
            "line": 133
          },
          {
            "name": "IntegrationsFacade",
            "docstring": "Unified facade for LLM integration management.\n\nProvides:\n- CRUD: list, get, create, update, delete integrations\n- Lifecycle: enable, disable\n- Health: get health status, test credentials\n- Limits: get usage vs limits\n\nAll operations are tenant-scoped for isolation.",
            "methods": [
              "__init__",
              "list_integrations",
              "get_integration",
              "create_integration",
              "update_integration",
              "delete_integration",
              "enable_integration",
              "disable_integration",
              "get_health_status",
              "test_credentials",
              "get_limits_status"
            ],
            "line": 155
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.cus_integration_engine",
            "names": [
              "CusIntegrationEngine",
              "get_cus_integration_engine"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "IntegrationsFacade",
          "get_integrations_facade",
          "IntegrationSummaryResult",
          "IntegrationListResult",
          "IntegrationDetailResult",
          "IntegrationLifecycleResult",
          "IntegrationDeleteResult",
          "HealthCheckResult",
          "HealthStatusResult",
          "LimitsStatusResult"
        ]
      },
      {
        "file_name": "prevention_contract.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/prevention_contract.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 206,
        "module_docstring": "M25 Prevention Contract Enforcement\n\n# =============================================================================\n# M25_FROZEN - DO NOT MODIFY\n# =============================================================================\n# Any changes here require explicit M25 reopen approval.\n# Changes invalidate all prior graduation evidence.\n# See PIN-140 for freeze rationale.\n# PREVENTION_CONTRACT_VERSION = \"1.0.0\"\n# =============================================================================\n\nFrom PIN-136, prevention records can ONLY be written when:\n1. Same pattern signature matches\n2. Same tenant\n3. Same feature path\n4. Policy is ACTIVE (not SHADOW, not PENDING)\n5. No incident is created (blocked before INSERT)\n6. Prevention record is written (append-only, immutable)\n\nThis module enforces these rules programmatically.",
        "functions": [
          {
            "name": "validate_prevention_candidate",
            "signature": "(candidate: PreventionCandidate) -> None",
            "docstring": "Validate that a prevention candidate satisfies the contract.\n\nRaises PreventionContractViolation if any rule is violated.\n\nRules (from PIN-136):\n1. Policy must be ACTIVE\n2. No incident created\n3. Pattern signature matches\n4. Same tenant\n5. Prevention records are append-only (handled at DB level)",
            "is_async": false,
            "line": 85
          },
          {
            "name": "assert_prevention_immutable",
            "signature": "(record_id: str, existing_record: dict[str, Any]) -> None",
            "docstring": "Assert that a prevention record has not been modified.\n\nPrevention records are append-only and immutable.\nThis should be called before any UPDATE attempt.",
            "is_async": false,
            "line": 142
          },
          {
            "name": "assert_no_deletion",
            "signature": "(record_id: str) -> None",
            "docstring": "Assert that a prevention record cannot be deleted.\n\nPrevention records are append-only and immutable.",
            "is_async": false,
            "line": 159
          },
          {
            "name": "validate_prevention_for_graduation",
            "signature": "(prevention_record: dict[str, Any], policy_activated_at: datetime) -> bool",
            "docstring": "Validate that a prevention record counts toward graduation.\n\nFor Gate 1 (Prevention) to pass:\n- Prevention must be real (is_simulated = False)\n- Prevention must be after policy activation\n- Policy must have been active at time of prevention",
            "is_async": false,
            "line": 175
          }
        ],
        "classes": [
          {
            "name": "PreventionContractViolation",
            "docstring": "Raised when a prevention record would violate the contract.",
            "methods": [
              "__init__"
            ],
            "line": 55
          },
          {
            "name": "PreventionCandidate",
            "docstring": "Candidate for prevention record creation.\n\nMust pass all contract checks before writing to prevention_records.",
            "methods": [],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [
          {
            "name": "PREVENTION_CONTRACT_VERSION",
            "line": 51
          },
          {
            "name": "PREVENTION_CONTRACT_FROZEN_AT",
            "line": 52
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "sql_gateway.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/sql_gateway.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 429,
        "module_docstring": "Module: sql_gateway\nPurpose: Template-based SQL queries (NO raw SQL from LLM).\n\nKey Difference from PostgresQuerySkill:\n    - PostgresQuerySkill: LLM provides SQL string (DANGEROUS)\n    - SqlGatewayService: LLM selects template ID, machine fills parameters\n\nSecurity Invariant: LLM NEVER sees or constructs SQL.\nThe SQL comes from pre-registered, audited templates.\n\nImports (Dependencies):\n    - None (credential service passed via constructor)\n\nExports (Provides):\n    - SqlGatewayService: Governed SQL access\n    - SqlGatewayConfig: Configuration dataclass\n    - QueryTemplate: SQL template definition\n\nWiring Points:\n    - Called from: RetrievalMediator\n    - Registered in: ConnectorRegistry\n\nAcceptance Criteria:\n    - [x] AC-060-01: No raw SQL from LLM\n    - [x] AC-060-02: Template ID required\n    - [x] AC-060-03: Parameters validated\n    - [x] AC-060-04: Read-only enforced\n    - [x] AC-060-05: SQL injection prevented\n    - [x] AC-060-06: Max rows enforced\n    - [x] AC-060-07: Tenant isolation (INV-003)\n    - [x] AC-060-08: Max result bytes enforced\n    - [x] AC-060-09: Query timeout enforced",
        "functions": [],
        "classes": [
          {
            "name": "ParameterType",
            "docstring": "Supported parameter types for validation.",
            "methods": [],
            "line": 83
          },
          {
            "name": "ParameterSpec",
            "docstring": "Specification for a query parameter.",
            "methods": [],
            "line": 97
          },
          {
            "name": "QueryTemplate",
            "docstring": "Definition of a SQL query template.",
            "methods": [],
            "line": 110
          },
          {
            "name": "SqlGatewayConfig",
            "docstring": "Configuration for SQL gateway.",
            "methods": [],
            "line": 123
          },
          {
            "name": "SqlGatewayError",
            "docstring": "Error from SQL gateway.",
            "methods": [],
            "line": 143
          },
          {
            "name": "SqlInjectionAttemptError",
            "docstring": "Potential SQL injection detected.",
            "methods": [],
            "line": 148
          },
          {
            "name": "SqlGatewayService",
            "docstring": "Governed SQL gateway.\n\nMachine controls:\n- SQL query templates (pre-registered)\n- Parameter validation\n- Connection credentials\n- Read-only enforcement\n- Row limits\n\nLLM controls:\n- Template selection (by ID from allowlist)\n- Parameter values (validated against spec)\n\nImplements Connector protocol for use with RetrievalMediator.",
            "methods": [
              "__init__",
              "id",
              "execute",
              "_resolve_template",
              "_validate_parameters",
              "_coerce_parameter",
              "_check_sql_injection",
              "_get_connection_string"
            ],
            "line": 153
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "TYPE_CHECKING"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.credentials",
            "names": [
              "Credential",
              "CredentialService"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.hoc.cus.integrations.L5_schemas.sql_gateway_protocol",
            "names": [
              "SqlQueryRequest",
              "SqlQueryResult"
            ],
            "is_relative": false,
            "line": 65
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_MAX_ROWS",
            "line": 78
          },
          {
            "name": "DEFAULT_MAX_RESULT_BYTES",
            "line": 79
          },
          {
            "name": "DEFAULT_TIMEOUT_SECONDS",
            "line": 80
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "types.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/types.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 56,
        "module_docstring": "Credential Type \u2014 Canonical Definition\n\nThis is the CANONICAL and ONLY authoritative definition of the\nCredential dataclass used by connector services.\n\nHistory:\n    Previously duplicated in:\n    - http_connector.py (lines 99-103)\n    - mcp_connector.py (lines 90-94)\n    - sql_gateway.py (lines 114-118)\n\n    Consolidated here per INT-DUP-001 quarantine resolution.",
        "functions": [],
        "classes": [
          {
            "name": "Credential",
            "docstring": "Credential from vault.\n\nA simple container for credential values retrieved from\nthe credential service. Used by connector services to\nauthenticate with external systems.\n\nAttributes:\n    value: The credential value (e.g., API key, token)\n    expires_at: Optional expiration timestamp",
            "methods": [],
            "line": 42
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [
      {
        "file_name": "audit_schemas.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/audit_schemas.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 59,
        "module_docstring": "M25 Audit Schemas\n\nDataclasses for audit records in the integration bridges.\n\nFROZEN: 2025-12-23\nDo NOT modify without explicit approval.",
        "functions": [],
        "classes": [
          {
            "name": "PolicyActivationAudit",
            "docstring": "Audit record for policy activation.\n\nRequired for:\n- Rollback\n- Blame tracking\n- Trust verification",
            "methods": [
              "to_dict"
            ],
            "line": 28
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_schemas.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/cus_schemas.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 498,
        "module_docstring": "Customer Integrations API Schemas\n\nPURPOSE:\n    Pydantic request/response models for the Customer Integrations API surface.\n    These schemas define the contract between SDK/clients and the backend.\n\nSCHEMAS:\n    Request Schemas:\n    - CusIntegrationCreate: Create a new integration\n    - CusIntegrationUpdate: Update integration settings\n    - CusLLMUsageIngest: Telemetry ingestion from SDK\n\n    Response Schemas:\n    - CusIntegrationResponse: Full integration details\n    - CusIntegrationSummary: List view integration\n    - CusUsageSummary: Aggregated usage statistics\n    - CusLimitsStatus: Current usage vs limits\n\nVALIDATION:\n    - All credential_ref values are validated as non-raw (no bare API keys)\n    - Provider types are constrained to supported enum values\n    - Token/cost values must be non-negative",
        "functions": [],
        "classes": [
          {
            "name": "CusIntegrationCreate",
            "docstring": "Request schema for creating a new integration.\n\nPURPOSE:\n    Captures all required information to create a customer LLM integration.\n    Credential handling is secure - we never accept raw API keys directly.\n\nVALIDATION:\n    - name is required, 1-255 chars\n    - provider_type must be a supported provider\n    - credential_ref must not look like a raw API key",
            "methods": [
              "validate_not_raw_key"
            ],
            "line": 55
          },
          {
            "name": "CusIntegrationUpdate",
            "docstring": "Request schema for updating an integration.\n\nPURPOSE:\n    Partial update - only provided fields are changed.\n    Status changes should use dedicated enable/disable endpoints.",
            "methods": [
              "validate_not_raw_key"
            ],
            "line": 133
          },
          {
            "name": "CusLLMUsageIngest",
            "docstring": "Request schema for SDK telemetry ingestion.\n\nPURPOSE:\n    SDK sends telemetry for each LLM call. This schema validates\n    the payload before persisting to cus_llm_usage.\n\nSEMANTIC:\n    This is DATA PLANE ingestion - append-only facts about what happened.\n    call_id provides idempotency for at-least-once delivery.",
            "methods": [],
            "line": 192
          },
          {
            "name": "CusLLMUsageBatchIngest",
            "docstring": "Request schema for batch telemetry ingestion.\n\nPURPOSE:\n    SDK may buffer and send multiple telemetry records at once\n    for efficiency. Max batch size is 100.",
            "methods": [],
            "line": 273
          },
          {
            "name": "CusIntegrationResponse",
            "docstring": "Full integration details response.\n\nPURPOSE:\n    Complete integration information including health state\n    and current limits. Used for detail view.",
            "methods": [],
            "line": 294
          },
          {
            "name": "CusIntegrationSummary",
            "docstring": "Integration summary for list views.\n\nPURPOSE:\n    Lightweight representation for list endpoints.\n    Excludes detailed config and health messages.",
            "methods": [],
            "line": 330
          },
          {
            "name": "CusLimitsStatus",
            "docstring": "Current usage vs configured limits.\n\nPURPOSE:\n    Dashboard view showing how much of each limit has been used.\n    Enables proactive budget and capacity management.",
            "methods": [],
            "line": 350
          },
          {
            "name": "CusUsageSummary",
            "docstring": "Aggregated usage statistics.\n\nPURPOSE:\n    Summary view of usage across integrations.\n    Used for dashboard totals and reports.",
            "methods": [],
            "line": 396
          },
          {
            "name": "CusIntegrationUsage",
            "docstring": "Usage for a single integration within a period.\n\nPURPOSE:\n    Per-integration breakdown within CusUsageSummary.",
            "methods": [],
            "line": 428
          },
          {
            "name": "CusLLMUsageResponse",
            "docstring": "Individual usage record response.\n\nPURPOSE:\n    Detailed view of a single LLM call for audit/debugging.",
            "methods": [],
            "line": 445
          },
          {
            "name": "CusHealthCheckResponse",
            "docstring": "Response from integration health check.\n\nPURPOSE:\n    Result of testing integration connectivity and credentials.",
            "methods": [],
            "line": 480
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.integrations.L5_schemas.cus_enums",
            "names": [
              "CusHealthState",
              "CusIntegrationStatus",
              "CusPolicyResult",
              "CusProviderType"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "datasource_model.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/datasource_model.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 584,
        "module_docstring": "CustomerDataSource - Customer data source models and registry.\n\nProvides data source abstraction for:\n- Database connections\n- File storage\n- API endpoints\n- Vector stores\n- Custom connectors",
        "functions": [
          {
            "name": "get_datasource_registry",
            "signature": "() -> DataSourceRegistry",
            "docstring": "Get the singleton registry instance.",
            "is_async": false,
            "line": 539
          },
          {
            "name": "_reset_registry",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 547
          },
          {
            "name": "create_datasource",
            "signature": "(tenant_id: str, name: str, source_type: DataSourceType, config: Optional[DataSourceConfig] = None) -> CustomerDataSource",
            "docstring": "Create a new data source using the singleton registry.",
            "is_async": false,
            "line": 556
          },
          {
            "name": "get_datasource",
            "signature": "(source_id: str) -> Optional[CustomerDataSource]",
            "docstring": "Get a data source by ID using the singleton registry.",
            "is_async": false,
            "line": 572
          },
          {
            "name": "list_datasources",
            "signature": "(tenant_id: Optional[str] = None, source_type: Optional[DataSourceType] = None) -> list[CustomerDataSource]",
            "docstring": "List data sources using the singleton registry.",
            "is_async": false,
            "line": 578
          }
        ],
        "classes": [
          {
            "name": "DataSourceType",
            "docstring": "Types of data sources.",
            "methods": [],
            "line": 24
          },
          {
            "name": "DataSourceStatus",
            "docstring": "Status of a data source.",
            "methods": [],
            "line": 36
          },
          {
            "name": "DataSourceConfig",
            "docstring": "Configuration for a data source.",
            "methods": [
              "to_dict",
              "get_connection_url"
            ],
            "line": 48
          },
          {
            "name": "CustomerDataSource",
            "docstring": "Representation of a customer data source.",
            "methods": [
              "record_connection",
              "record_error",
              "activate",
              "deactivate",
              "deprecate",
              "update_config",
              "add_tag",
              "remove_tag",
              "grant_access",
              "revoke_access",
              "has_access",
              "to_dict"
            ],
            "line": 128
          },
          {
            "name": "DataSourceError",
            "docstring": "Exception for data source errors.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 259
          },
          {
            "name": "DataSourceStats",
            "docstring": "Statistics for data sources.",
            "methods": [
              "to_dict"
            ],
            "line": 283
          },
          {
            "name": "DataSourceRegistry",
            "docstring": "Registry for managing customer data sources.\n\nFeatures:\n- CRUD operations for data sources\n- Status management\n- Tenant isolation\n- Access control",
            "methods": [
              "__init__",
              "register",
              "get",
              "get_by_name",
              "list",
              "update",
              "activate",
              "deactivate",
              "delete",
              "get_statistics",
              "clear_tenant",
              "reset"
            ],
            "line": 313
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 17
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 21
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "loop_events.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/loop_events.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 968,
        "module_docstring": "M25 Integration Loop Events\n\n# =============================================================================\n# M25_FROZEN - DO NOT MODIFY\n# =============================================================================\n# Any changes here require explicit M25 reopen approval.\n# Changes invalidate all prior graduation evidence.\n# See PIN-140 for freeze rationale.\n# =============================================================================\n\nEnhanced with:\n- Confidence bands (strong/weak/novel) instead of binary matching\n- Loop failure states for unhappy paths\n- Policy shadow mode support\n- Human checkpoint controls\n- Routing guardrails\n\nFROZEN: 2025-12-23\nGRADUATION_RULES_VERSION = \"1.0.0\"",
        "functions": [
          {
            "name": "ensure_json_serializable",
            "signature": "(obj: Any, path: str = 'root') -> Any",
            "docstring": "Guard function to ensure all objects stored in details are JSON-serializable.\n\nRaises TypeError with clear path if non-serializable object found.",
            "is_async": false,
            "line": 133
          }
        ],
        "classes": [
          {
            "name": "ConfidenceCalculator",
            "docstring": "Centralized confidence calculation.\n\nFROZEN: All confidence logic must go through this class.\nVersion is logged with every confidence value for audit.",
            "methods": [
              "calculate_recovery_confidence",
              "should_auto_apply",
              "get_confirmation_level"
            ],
            "line": 55
          },
          {
            "name": "ConfidenceBand",
            "docstring": "Confidence classification for pattern matching.\n\n- STRONG_MATCH: High confidence (>0.85) - Safe for auto-apply\n- WEAK_MATCH: Medium confidence (0.6-0.85) - Requires review\n- NOVEL: Low confidence (<0.6) - New pattern, needs investigation",
            "methods": [
              "from_confidence",
              "allows_auto_apply",
              "requires_human_review"
            ],
            "line": 166
          },
          {
            "name": "LoopStage",
            "docstring": "Stages in the integration feedback loop.",
            "methods": [],
            "line": 205
          },
          {
            "name": "LoopFailureState",
            "docstring": "Explicit failure states for when the loop doesn't complete.\n\nCritical for debugging and trust - the unhappy path matters more\nthan the happy path.",
            "methods": [],
            "line": 216
          },
          {
            "name": "PolicyMode",
            "docstring": "Policy activation modes for safety.\n\nShadow mode allows observation without enforcement.",
            "methods": [],
            "line": 238
          },
          {
            "name": "HumanCheckpointType",
            "docstring": "Types of human intervention points.",
            "methods": [],
            "line": 251
          },
          {
            "name": "LoopEvent",
            "docstring": "Base event for integration loop.\n\nAll events flow through the dispatcher and are persisted for durability.",
            "methods": [
              "create",
              "is_success",
              "is_blocked",
              "to_dict"
            ],
            "line": 267
          },
          {
            "name": "PatternMatchResult",
            "docstring": "Result of Bridge 1: Incident \u2192 Failure Catalog.\n\nEnhanced with confidence bands instead of binary matching.",
            "methods": [
              "from_match",
              "no_match",
              "should_auto_proceed",
              "to_dict"
            ],
            "line": 342
          },
          {
            "name": "RecoverySuggestion",
            "docstring": "Result of Bridge 2: Pattern \u2192 Recovery.\n\nEnhanced with template vs generated distinction and confidence scoring.",
            "methods": [
              "create",
              "none_available",
              "add_confirmation",
              "to_dict"
            ],
            "line": 415
          },
          {
            "name": "PolicyRule",
            "docstring": "Result of Bridge 3: Recovery \u2192 Policy.\n\nEnhanced with:\n- Shadow mode for safe observation\n- Confirmation requirements\n- Policy regret tracking",
            "methods": [
              "create",
              "record_shadow_evaluation",
              "add_confirmation",
              "record_regret",
              "shadow_block_rate",
              "to_dict"
            ],
            "line": 509
          },
          {
            "name": "RoutingAdjustment",
            "docstring": "Result of Bridge 4: Policy \u2192 CARE Routing.\n\nEnhanced with guardrails:\n- Max delta per adjustment\n- Decay window\n- Rollback on KPI regression",
            "methods": [
              "create",
              "check_kpi_regression",
              "rollback",
              "effective_magnitude",
              "to_dict"
            ],
            "line": 636
          },
          {
            "name": "HumanCheckpoint",
            "docstring": "Human intervention point in the loop.\n\nSupports: approve, simulate, revert actions.",
            "methods": [
              "create",
              "resolve",
              "is_pending"
            ],
            "line": 771
          },
          {
            "name": "LoopStatus",
            "docstring": "Complete status of an integration loop instance.\n\nUsed for console display and debugging.",
            "methods": [
              "completion_pct",
              "to_console_display",
              "_generate_narrative",
              "to_dict"
            ],
            "line": 835
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Literal",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [
          {
            "name": "LOOP_MECHANICS_VERSION",
            "line": 46
          },
          {
            "name": "LOOP_MECHANICS_FROZEN_AT",
            "line": 47
          }
        ],
        "all_exports": null
      }
    ],
    "l5_other": [
      {
        "file_name": "channel_engine.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_notifications/engines/channel_engine.py",
        "layer": "L5_other",
        "domain": "integrations",
        "lines": 1102,
        "module_docstring": "Module: channel_engine\nPurpose: Configurable notification channels for alerts and events.\n\nGAP-017: Notify channels must be configurable per tenant/policy.\nThis service provides:\n    - Channel configuration (enable/disable per channel type)\n    - Channel validation (test connectivity)\n    - Delivery tracking (success/failure metrics)\n    - Retry logic for failed deliveries\n\nExports:\n    - NotifyChannel: Enum of available channels\n    - NotifyEventType: Enum of event types\n    - NotifyChannelConfig: Channel configuration\n    - NotifyChannelService: Main service class\n    - NotifyDeliveryResult: Delivery result tracking\n    - NotifyChannelError: Error for channel failures\n    - Helper functions for quick access",
        "functions": [
          {
            "name": "get_notify_service",
            "signature": "() -> NotifyChannelService",
            "docstring": "Get or create the notification service singleton.",
            "is_async": false,
            "line": 1032
          },
          {
            "name": "_reset_notify_service",
            "signature": "() -> None",
            "docstring": "Reset the notification service (for testing).",
            "is_async": false,
            "line": 1040
          },
          {
            "name": "get_channel_config",
            "signature": "(tenant_id: str, channel: NotifyChannel) -> Optional[NotifyChannelConfig]",
            "docstring": "Quick helper to get channel configuration.\n\nArgs:\n    tenant_id: Tenant identifier\n    channel: Channel type\n\nReturns:\n    NotifyChannelConfig or None",
            "is_async": false,
            "line": 1049
          },
          {
            "name": "send_notification",
            "signature": "(tenant_id: str, event_type: NotifyEventType, payload: Dict[str, Any], channels: Optional[List[NotifyChannel]] = None) -> List[NotifyDeliveryResult]",
            "docstring": "Quick helper to send notification.\n\nArgs:\n    tenant_id: Tenant identifier\n    event_type: Type of event\n    payload: Notification payload\n    channels: Optional specific channels\n\nReturns:\n    List of delivery results",
            "is_async": true,
            "line": 1067
          },
          {
            "name": "check_channel_health",
            "signature": "(tenant_id: str) -> Dict[NotifyChannel, Dict[str, Any]]",
            "docstring": "Quick helper to check channel health.\n\nArgs:\n    tenant_id: Tenant identifier\n\nReturns:\n    Dictionary of channel health status",
            "is_async": true,
            "line": 1089
          }
        ],
        "classes": [
          {
            "name": "NotifyChannel",
            "docstring": "Available notification channels.",
            "methods": [],
            "line": 49
          },
          {
            "name": "NotifyEventType",
            "docstring": "Types of events that can trigger notifications.",
            "methods": [],
            "line": 60
          },
          {
            "name": "NotifyChannelStatus",
            "docstring": "Status of a notification channel.",
            "methods": [],
            "line": 75
          },
          {
            "name": "NotifyChannelError",
            "docstring": "Raised when notification channel operation fails.\n\nThis error indicates that a notification could not be sent\nthrough the configured channel.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 84
          },
          {
            "name": "NotifyDeliveryResult",
            "docstring": "Result of a notification delivery attempt.",
            "methods": [
              "to_dict"
            ],
            "line": 116
          },
          {
            "name": "NotifyChannelConfig",
            "docstring": "Configuration for a notification channel.",
            "methods": [
              "is_event_enabled",
              "is_configured",
              "record_success",
              "record_failure",
              "to_dict"
            ],
            "line": 145
          },
          {
            "name": "NotifyChannelConfigResponse",
            "docstring": "Response from channel configuration operations.",
            "methods": [
              "to_dict"
            ],
            "line": 232
          },
          {
            "name": "NotificationSender",
            "docstring": "Protocol for notification sender implementations.",
            "methods": [
              "send"
            ],
            "line": 252
          },
          {
            "name": "NotifyChannelService",
            "docstring": "Service for managing notification channels.\n\nGAP-017: Provides configurable notification channels for\nalerts, incidents, and policy events.\n\nUsage:\n    service = NotifyChannelService()\n\n    # Configure a channel\n    config = service.configure_channel(\n        tenant_id=\"tenant-1\",\n        channel=NotifyChannel.WEBHOOK,\n        webhook_url=\"https://example.com/webhook\"\n    )\n\n    # Send notification\n    result = await service.send(\n        tenant_id=\"tenant-1\",\n        event_type=NotifyEventType.INCIDENT_CREATED,\n        payload={\"incident_id\": \"inc-123\", ...}\n    )\n\n    # Check channel health\n    health = await service.check_health(tenant_id=\"tenant-1\")",
            "methods": [
              "__init__",
              "configure_channel",
              "get_channel_config",
              "get_all_configs",
              "get_enabled_channels",
              "enable_channel",
              "disable_channel",
              "set_event_filter",
              "send",
              "_send_via_channel",
              "_send_ui_notification",
              "_send_webhook_notification",
              "_send_email_notification",
              "_send_slack_notification",
              "_send_pagerduty_notification",
              "_send_teams_notification",
              "check_health",
              "get_delivery_history"
            ],
            "line": 265
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Protocol",
              "Set"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "vault.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_vault/drivers/vault.py",
        "layer": "L5_other",
        "domain": "integrations",
        "lines": 1050,
        "module_docstring": "Credential Vault Abstraction (GAP-171)\n\nSupports multiple vault providers:\n- HashiCorp Vault (production)\n- AWS Secrets Manager (production)\n- Environment variables (development only)",
        "functions": [
          {
            "name": "create_credential_vault",
            "signature": "() -> CredentialVault",
            "docstring": "Factory function to create appropriate vault based on scope and configuration.\n\nPIN-517: Authority split between system and customer scopes.\n\nArgs:\n    scope: Trust zone - \"system\" (dev/infra) or \"customer\" (SDK-visible)\n\nReturns:\n    CredentialVault instance\n\nRaises:\n    ValueError: If customer scope with env provider (forbidden)\n    ValueError: If required credentials missing for production vault",
            "is_async": false,
            "line": 991
          }
        ],
        "classes": [
          {
            "name": "VaultProvider",
            "docstring": "Supported vault providers.",
            "methods": [],
            "line": 49
          },
          {
            "name": "CredentialType",
            "docstring": "Types of credentials.",
            "methods": [],
            "line": 57
          },
          {
            "name": "CredentialMetadata",
            "docstring": "Metadata about a stored credential (without secret values).",
            "methods": [],
            "line": 71
          },
          {
            "name": "CredentialData",
            "docstring": "Full credential including secret values.",
            "methods": [
              "credential_id",
              "tenant_id"
            ],
            "line": 91
          },
          {
            "name": "CredentialVault",
            "docstring": "Abstract credential vault interface.",
            "methods": [
              "store_credential",
              "get_credential",
              "get_metadata",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential"
            ],
            "line": 106
          },
          {
            "name": "HashiCorpVault",
            "docstring": "HashiCorp Vault implementation.",
            "methods": [
              "__init__",
              "store_credential",
              "get_credential",
              "get_metadata",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential"
            ],
            "line": 266
          },
          {
            "name": "EnvCredentialVault",
            "docstring": "Environment variable credential vault (development only).\n\nCredentials are stored in memory with secrets read from environment.",
            "methods": [
              "__init__",
              "store_credential",
              "get_credential",
              "get_metadata",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential"
            ],
            "line": 562
          },
          {
            "name": "AwsSecretsManagerVault",
            "docstring": "AWS Secrets Manager implementation (PIN-517 FIX 3).\n\nUses boto3 for AWS Secrets Manager operations.",
            "methods": [
              "__init__",
              "_get_client",
              "_secret_id",
              "store_credential",
              "get_credential",
              "get_metadata",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential"
            ],
            "line": 729
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Literal"
            ],
            "is_relative": false,
            "line": 988
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "service.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_vault/engines/service.py",
        "layer": "L5_other",
        "domain": "integrations",
        "lines": 551,
        "module_docstring": "Credential Service (GAP-171)\n\nHigh-level service for credential management with:\n- Input validation\n- Audit logging\n- Expiration checking\n- Rotation scheduling",
        "functions": [],
        "classes": [
          {
            "name": "CredentialAccessRecord",
            "docstring": "Record of credential access for auditing.",
            "methods": [],
            "line": 45
          },
          {
            "name": "CredentialService",
            "docstring": "High-level credential service.\n\nFeatures:\n- Credential CRUD with validation\n- Expiration checking\n- Access auditing\n- Rotation support",
            "methods": [
              "__init__",
              "store_credential",
              "get_credential",
              "get_secret_value",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential",
              "get_expiring_credentials",
              "get_rotatable_credentials",
              "get_access_log",
              "_audit",
              "_validate_tenant_id",
              "_validate_name",
              "_validate_secret_data"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "drivers.vault",
            "names": [
              "CredentialData",
              "CredentialMetadata",
              "CredentialType",
              "CredentialVault"
            ],
            "is_relative": true,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l6_drivers": [
      {
        "file_name": "worker_registry_driver.py",
        "file_path": "backend/app/hoc/cus/integrations/L6_drivers/worker_registry_driver.py",
        "layer": "L6_drivers",
        "domain": "integrations",
        "lines": 424,
        "module_docstring": "Worker Registry Driver (L6)\n\nProvides:\n- Dynamic worker discovery from database\n- Worker status and capability queries\n- Per-tenant worker configuration\n- Worker availability checks",
        "functions": [
          {
            "name": "get_worker_registry_service",
            "signature": "(session: Session) -> WorkerRegistryService",
            "docstring": "Get a WorkerRegistryService instance.",
            "is_async": false,
            "line": 413
          }
        ],
        "classes": [
          {
            "name": "WorkerRegistryError",
            "docstring": "Base exception for worker registry errors.",
            "methods": [],
            "line": 47
          },
          {
            "name": "WorkerNotFoundError",
            "docstring": "Raised when a worker is not found.",
            "methods": [],
            "line": 53
          },
          {
            "name": "WorkerUnavailableError",
            "docstring": "Raised when a worker is not available.",
            "methods": [],
            "line": 59
          },
          {
            "name": "WorkerRegistryService",
            "docstring": "Service for worker registry operations.",
            "methods": [
              "__init__",
              "get_worker",
              "get_worker_or_raise",
              "list_workers",
              "list_available_workers",
              "is_worker_available",
              "get_worker_details",
              "get_worker_summary",
              "list_worker_summaries",
              "register_worker",
              "update_worker_status",
              "deprecate_worker",
              "get_tenant_worker_config",
              "set_tenant_worker_config",
              "list_tenant_worker_configs",
              "get_effective_worker_config",
              "is_worker_enabled_for_tenant",
              "get_workers_for_tenant"
            ],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerConfig",
              "WorkerRegistry"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "WorkerRegistryService",
          "WorkerRegistryError",
          "WorkerNotFoundError",
          "WorkerUnavailableError",
          "get_worker_registry_service"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 19,
    "violation_count": 0,
    "gap_count": 2
  },
  "apis": {
    "l2_1_facade": null,
    "l2_apis": [],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "keys_driver.py",
        "file_path": "backend/app/hoc/cus/apis/L6_drivers/keys_driver.py",
        "layer": "L6_drivers",
        "domain": "apis",
        "lines": 196,
        "module_docstring": "Keys Driver (L6)\n\nPure data access for API keys.\nNo business logic - only DB operations.\n\nAuthority: KEY_PERSISTENCE\nTables: api_keys, proxy_calls (read-only for usage)",
        "functions": [
          {
            "name": "get_keys_driver",
            "signature": "(session: Session) -> KeysDriver",
            "docstring": "Factory function for KeysDriver.",
            "is_async": false,
            "line": 188
          }
        ],
        "classes": [
          {
            "name": "KeysDriver",
            "docstring": "L6 driver for API key data access.\n\nINVARIANTS (L6):\n- No business branching\n- No validation\n- No cross-domain calls\n- Pure persistence operations only",
            "methods": [
              "__init__",
              "fetch_keys_paginated",
              "fetch_key_by_id",
              "fetch_key_usage_today",
              "update_key_frozen"
            ],
            "line": 55
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "ProxyCall"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.models.tenant",
            "names": [
              "APIKey"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": [
          "KeysDriver",
          "get_keys_driver"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 1,
    "violation_count": 0,
    "gap_count": 2
  },
  "account": {
    "l2_1_facade": "/root/agenticverz2.0/backend/app/hoc/api/facades/cus/account.py",
    "l2_apis": [
      {
        "file_name": "memory_pins.py",
        "file_path": "backend/app/hoc/api/cus/account/memory_pins.py",
        "layer": "L2_api",
        "domain": "account",
        "lines": 363,
        "module_docstring": "Memory Pins API - M7 Implementation\n\nProvides REST API for managing memory pins (structured key-value storage).\n\nFeatures:\n- Tenant-isolated storage\n- JSONB values for flexible schema\n- Optional TTL for expiring entries\n- RBAC enforcement (when enabled)\n- Prometheus metrics (via L5 engine)\n\nEndpoints:\n- POST /memory/pins - Create or upsert a pin\n- GET /memory/pins/{key} - Get a pin by key\n- GET /memory/pins - List pins for tenant\n- DELETE /memory/pins/{key} - Delete a pin\n- POST /memory/pins/cleanup - Clean up expired pins\n\nAll DB access routed through L4 operation registry \u2192 L5 engine \u2192 L6 driver.",
        "functions": [
          {
            "name": "extract_tenant_from_request",
            "signature": "(request: Request, tenant_id: Optional[str] = None) -> str",
            "docstring": "Extract tenant ID from request or parameter.",
            "is_async": false,
            "line": 116
          },
          {
            "name": "_pin_row_to_response",
            "signature": "(pin: Any) -> MemoryPinResponse",
            "docstring": "Convert a MemoryPinRow dataclass to response model.",
            "is_async": false,
            "line": 126
          },
          {
            "name": "create_or_upsert_pin",
            "signature": "(pin: MemoryPinCreate, request: Request, session = Depends(get_session_dep))",
            "docstring": "Create or upsert a memory pin.\n\nIf a pin with the same (tenant_id, key) exists, it will be updated.\nOtherwise, a new pin is created.\n\nRequires RBAC permission: memory_pin:write",
            "is_async": true,
            "line": 147
          },
          {
            "name": "get_pin",
            "signature": "(key: str, request: Request, tenant_id: str = Query(default='global', description='Tenant ID'), session = Depends(get_session_dep))",
            "docstring": "Get a memory pin by key.\n\nReturns 404 if not found or expired.\n\nRequires RBAC permission: memory_pin:read",
            "is_async": true,
            "line": 192
          },
          {
            "name": "list_pins",
            "signature": "(request: Request, tenant_id: str = Query(default='global', description='Tenant ID'), prefix: Optional[str] = Query(default=None, description='Key prefix filter'), limit: int = Query(default=100, ge=1, le=1000, description='Max results'), offset: int = Query(default=0, ge=0, description='Offset for pagination'), include_expired: bool = Query(default=False, description='Include expired pins'), session = Depends(get_session_dep))",
            "docstring": "List memory pins for a tenant.\n\nSupports filtering by key prefix and pagination.\n\nRequires RBAC permission: memory_pin:read",
            "is_async": true,
            "line": 234
          },
          {
            "name": "delete_pin",
            "signature": "(key: str, request: Request, tenant_id: str = Query(default='global', description='Tenant ID'), session = Depends(get_session_dep))",
            "docstring": "Delete a memory pin by key.\n\nReturns 404 if not found.\n\nRequires RBAC permission: memory_pin:delete",
            "is_async": true,
            "line": 283
          },
          {
            "name": "cleanup_expired_pins",
            "signature": "(request: Request, tenant_id: Optional[str] = Query(default=None, description='Limit to specific tenant'), session = Depends(get_session_dep))",
            "docstring": "Clean up expired memory pins.\n\nTypically called by a cron job. Deletes all pins where expires_at < now().\n\nRequires RBAC permission: memory_pin:admin",
            "is_async": true,
            "line": 325
          }
        ],
        "classes": [
          {
            "name": "MemoryPinCreate",
            "docstring": "Schema for creating/upserting a memory pin.",
            "methods": [
              "validate_key"
            ],
            "line": 58
          },
          {
            "name": "MemoryPinResponse",
            "docstring": "Schema for memory pin response.",
            "methods": [],
            "line": 77
          },
          {
            "name": "MemoryPinListResponse",
            "docstring": "Schema for listing memory pins.",
            "methods": [],
            "line": 94
          },
          {
            "name": "MemoryPinDeleteResponse",
            "docstring": "Schema for delete response.",
            "methods": [],
            "line": 103
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.hoc_spine.orchestrator.operation_registry",
            "names": [
              "OperationContext",
              "get_operation_registry",
              "get_session_dep"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "accounts_facade.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/accounts_facade.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 1135,
        "module_docstring": "Accounts Domain Facade (L5)\n\nUnified facade for all accounts domain operations:\n- Projects: list, detail\n- Users: list, detail, invite, remove, update role\n- Profile: get, update\n- Billing: summary, invoices\n- Support: contact, tickets\n\nGOVERNANCE NOTE:\nAccount is NOT a domain - it manages who, what, and billing (not what happened).\nAccount pages MUST NOT display executions, incidents, policies, or logs.",
        "functions": [
          {
            "name": "get_accounts_facade",
            "signature": "() -> AccountsFacade",
            "docstring": "Get the singleton AccountsFacade instance.",
            "is_async": false,
            "line": 1096
          }
        ],
        "classes": [
          {
            "name": "ProjectSummaryResult",
            "docstring": "Project summary for list view.",
            "methods": [],
            "line": 66
          },
          {
            "name": "ProjectsListResult",
            "docstring": "Projects list response.",
            "methods": [],
            "line": 79
          },
          {
            "name": "ProjectDetailResult",
            "docstring": "Project detail response.",
            "methods": [],
            "line": 89
          },
          {
            "name": "UserSummaryResult",
            "docstring": "User summary for list view.",
            "methods": [],
            "line": 122
          },
          {
            "name": "UsersListResult",
            "docstring": "Users list response.",
            "methods": [],
            "line": 135
          },
          {
            "name": "UserDetailResult",
            "docstring": "User detail response.",
            "methods": [],
            "line": 145
          },
          {
            "name": "TenantUserResult",
            "docstring": "User in tenant.",
            "methods": [],
            "line": 170
          },
          {
            "name": "TenantUsersListResult",
            "docstring": "List of tenant users.",
            "methods": [],
            "line": 181
          },
          {
            "name": "ProfileResult",
            "docstring": "User profile response.",
            "methods": [],
            "line": 194
          },
          {
            "name": "ProfileUpdateResult",
            "docstring": "Profile update response.",
            "methods": [],
            "line": 209
          },
          {
            "name": "BillingSummaryResult",
            "docstring": "Billing summary response.",
            "methods": [],
            "line": 226
          },
          {
            "name": "InvoiceSummaryResult",
            "docstring": "Invoice summary.",
            "methods": [],
            "line": 244
          },
          {
            "name": "InvoiceListResult",
            "docstring": "Invoice list response.",
            "methods": [],
            "line": 256
          },
          {
            "name": "SupportContactResult",
            "docstring": "Support contact info.",
            "methods": [],
            "line": 270
          },
          {
            "name": "SupportTicketResult",
            "docstring": "Support ticket response.",
            "methods": [],
            "line": 279
          },
          {
            "name": "SupportTicketListResult",
            "docstring": "Support ticket list response.",
            "methods": [],
            "line": 295
          },
          {
            "name": "InvitationResult",
            "docstring": "Invitation response.",
            "methods": [],
            "line": 308
          },
          {
            "name": "InvitationListResult",
            "docstring": "Invitation list response.",
            "methods": [],
            "line": 321
          },
          {
            "name": "AcceptInvitationResult",
            "docstring": "Invitation acceptance result.",
            "methods": [],
            "line": 329
          },
          {
            "name": "AccountsFacade",
            "docstring": "Unified facade for all Accounts domain operations.\n\nProvides:\n- Projects: list, detail\n- Users: list, detail, invite, remove, update role\n- Profile: get, update\n- Billing: summary, invoices\n- Support: contact, tickets\n\nGOVERNANCE NOTE:\nAccount is NOT a domain - it manages who, what, and billing (not what happened).\n\nLAYER COMPLIANCE (Phase 2.5B):\nThis L4 facade delegates all DB operations to AccountsFacadeDriver (L6).\nBusiness logic (validation, permissions) remains here.",
            "methods": [
              "__init__",
              "list_projects",
              "get_project_detail",
              "list_users",
              "get_user_detail",
              "list_tenant_users",
              "update_user_role",
              "remove_user",
              "get_profile",
              "update_profile",
              "get_billing_summary",
              "get_billing_invoices",
              "get_support_contact",
              "create_support_ticket",
              "list_support_tickets",
              "invite_user",
              "list_invitations",
              "accept_invitation"
            ],
            "line": 352
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "secrets",
            "names": [
              "secrets"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.account.L6_drivers.accounts_facade_driver",
            "names": [
              "AccountsFacadeDriver",
              "get_accounts_facade_driver"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.result_types",
            "names": [
              "AccountsErrorResult"
            ],
            "is_relative": false,
            "line": 344
          }
        ],
        "constants": [],
        "all_exports": [
          "AccountsFacade",
          "get_accounts_facade",
          "ProjectSummaryResult",
          "ProjectsListResult",
          "ProjectDetailResult",
          "UserSummaryResult",
          "UsersListResult",
          "UserDetailResult",
          "TenantUserResult",
          "TenantUsersListResult",
          "ProfileResult",
          "ProfileUpdateResult",
          "BillingSummaryResult",
          "InvoiceSummaryResult",
          "InvoiceListResult",
          "SupportContactResult",
          "SupportTicketResult",
          "SupportTicketListResult",
          "InvitationResult",
          "InvitationListResult",
          "AcceptInvitationResult",
          "AccountsErrorResult"
        ]
      },
      {
        "file_name": "notifications_facade.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/notifications_facade.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 480,
        "module_docstring": "Notifications Facade (L5 Domain Engine)\n\nThis facade provides the external interface for notification operations.\nAll notification APIs MUST use this facade instead of directly importing\ninternal notification modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes notification delivery logic\n- Provides unified access to multiple notification channels\n- Single point for audit emission\n\nL2 API Routes (GAP-109):\n- POST /api/v1/notifications (send notification)\n- GET /api/v1/notifications (list notifications)\n- GET /api/v1/notifications/{id} (get notification)\n- POST /api/v1/notifications/{id}/read (mark as read)\n- GET /api/v1/notifications/channels (list channels)\n- PUT /api/v1/notifications/preferences (update preferences)\n\nUsage:\n    from app.hoc.cus.account.L5_engines import get_notifications_facade\n\n    facade = get_notifications_facade()\n\n    # Send notification\n    result = await facade.send_notification(\n        tenant_id=\"...\",\n        channel=\"email\",\n        recipient=\"...\",\n        message=\"...\",\n    )",
        "functions": [
          {
            "name": "get_notifications_facade",
            "signature": "() -> NotificationsFacade",
            "docstring": "Get the notifications facade instance.\n\nThis is the recommended way to access notification operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    NotificationsFacade instance",
            "is_async": false,
            "line": 467
          }
        ],
        "classes": [
          {
            "name": "NotificationChannel",
            "docstring": "Notification channels.",
            "methods": [],
            "line": 67
          },
          {
            "name": "NotificationPriority",
            "docstring": "Notification priorities.",
            "methods": [],
            "line": 76
          },
          {
            "name": "NotificationStatus",
            "docstring": "Notification delivery status.",
            "methods": [],
            "line": 84
          },
          {
            "name": "NotificationInfo",
            "docstring": "Notification information.",
            "methods": [
              "to_dict"
            ],
            "line": 94
          },
          {
            "name": "ChannelInfo",
            "docstring": "Notification channel information.",
            "methods": [
              "to_dict"
            ],
            "line": 128
          },
          {
            "name": "NotificationPreferences",
            "docstring": "User notification preferences.",
            "methods": [
              "to_dict"
            ],
            "line": 148
          },
          {
            "name": "NotificationsFacade",
            "docstring": "Facade for notification operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nnotification services.\n\nLayer: L4 (Domain Logic)\nCallers: notifications.py (L2), aos_sdk, Worker",
            "methods": [
              "__init__",
              "send_notification",
              "list_notifications",
              "get_notification",
              "mark_as_read",
              "list_channels",
              "get_channel",
              "get_preferences",
              "update_preferences"
            ],
            "line": 165
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 62
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "tenant_engine.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/tenant_engine.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 583,
        "module_docstring": "Tenant Engine (L5)\n\nBusiness logic for tenant operations.\n\nProvides:\n- Tenant creation with plan quotas\n- Plan upgrades/downgrades\n- Quota enforcement (runs per day, tokens per month, concurrent runs)\n- API key management with limits\n- Run lifecycle with quota checks\n- Usage tracking\n\nAll DB operations are delegated to TenantDriver (L6).",
        "functions": [
          {
            "name": "get_tenant_engine",
            "signature": "(session: Session) -> TenantEngine",
            "docstring": "Get a TenantEngine instance.",
            "is_async": false,
            "line": 573
          }
        ],
        "classes": [
          {
            "name": "TenantEngineError",
            "docstring": "Base exception for tenant engine errors.",
            "methods": [],
            "line": 66
          },
          {
            "name": "QuotaExceededError",
            "docstring": "Raised when a quota limit is exceeded.",
            "methods": [
              "__init__"
            ],
            "line": 71
          },
          {
            "name": "TenantEngine",
            "docstring": "L4 Engine for tenant business logic.\n\nHandles:\n- Quota decisions\n- Plan logic\n- Status validation\n- Temporal logic (daily counter reset)\n\nDelegates all DB operations to TenantDriver (L6).",
            "methods": [
              "__init__",
              "create_tenant",
              "get_tenant",
              "get_tenant_by_slug",
              "update_plan",
              "suspend",
              "create_membership_with_default",
              "create_api_key",
              "list_api_keys",
              "revoke_api_key",
              "check_run_quota",
              "check_token_quota",
              "increment_usage",
              "_maybe_reset_daily_counter",
              "record_usage",
              "get_usage_summary",
              "create_run",
              "complete_run",
              "list_runs"
            ],
            "line": 86
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "timedelta"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.hoc_spine.services.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.account.L6_drivers.tenant_driver",
            "names": [
              "TenantDriver",
              "get_tenant_driver"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.account.L5_schemas.plan_quotas",
            "names": [
              "PLAN_QUOTAS"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": [
          "TenantEngine",
          "TenantEngineError",
          "QuotaExceededError",
          "get_tenant_engine"
        ]
      }
    ],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "accounts_facade_driver.py",
        "file_path": "backend/app/hoc/cus/account/L6_drivers/accounts_facade_driver.py",
        "layer": "L6_drivers",
        "domain": "account",
        "lines": 954,
        "module_docstring": "Accounts Facade Driver (L6)\n\nPure data access layer for accounts domain operations.\n\nProvides:\n- Tenant/Project queries\n- User queries\n- Membership queries\n- Profile queries\n- Billing queries\n- Support ticket queries\n- Invitation queries\n\nAll methods return snapshot dataclasses, not ORM models.\nBusiness logic belongs in the facade (L4), not here.",
        "functions": [
          {
            "name": "get_accounts_facade_driver",
            "signature": "() -> AccountsFacadeDriver",
            "docstring": "Get the singleton AccountsFacadeDriver instance.",
            "is_async": false,
            "line": 932
          }
        ],
        "classes": [
          {
            "name": "TenantSnapshot",
            "docstring": "Tenant data from DB for list view.",
            "methods": [],
            "line": 72
          },
          {
            "name": "TenantDetailSnapshot",
            "docstring": "Detailed tenant data from DB.",
            "methods": [],
            "line": 84
          },
          {
            "name": "UserSnapshot",
            "docstring": "User data from DB for list view.",
            "methods": [],
            "line": 106
          },
          {
            "name": "UserDetailSnapshot",
            "docstring": "Detailed user data from DB.",
            "methods": [],
            "line": 118
          },
          {
            "name": "MembershipSnapshot",
            "docstring": "Tenant membership data from DB.",
            "methods": [],
            "line": 139
          },
          {
            "name": "ProfileSnapshot",
            "docstring": "User profile data from DB.",
            "methods": [],
            "line": 149
          },
          {
            "name": "SubscriptionSnapshot",
            "docstring": "Subscription data from DB.",
            "methods": [],
            "line": 163
          },
          {
            "name": "InvitationSnapshot",
            "docstring": "Invitation data from DB.",
            "methods": [],
            "line": 173
          },
          {
            "name": "TicketSnapshot",
            "docstring": "Support ticket data from DB.",
            "methods": [],
            "line": 187
          },
          {
            "name": "AccountsFacadeDriver",
            "docstring": "L6 Driver for accounts domain data access.\n\nAll methods are pure data access - no business logic.\nReturns snapshot dataclasses, not ORM models.",
            "methods": [
              "fetch_tenant",
              "fetch_tenants",
              "count_tenants",
              "fetch_tenant_detail",
              "fetch_users",
              "count_users",
              "fetch_user_detail",
              "fetch_tenant_memberships",
              "fetch_membership",
              "fetch_membership_with_user",
              "update_membership_role",
              "delete_membership",
              "fetch_profile",
              "fetch_user_by_id",
              "update_user_profile",
              "fetch_subscription",
              "insert_support_ticket",
              "fetch_support_tickets",
              "fetch_invitation_by_email",
              "insert_invitation",
              "fetch_invitations",
              "fetch_invitation_by_id_and_token",
              "fetch_user_by_email",
              "insert_user",
              "insert_membership",
              "update_invitation_accepted",
              "update_invitation_expired"
            ],
            "line": 206
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.models.tenant",
            "names": [
              "Invitation",
              "Subscription",
              "SupportTicket",
              "Tenant",
              "TenantMembership",
              "User",
              "generate_uuid",
              "utc_now"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": [
          "AccountsFacadeDriver",
          "get_accounts_facade_driver",
          "TenantSnapshot",
          "TenantDetailSnapshot",
          "UserSnapshot",
          "UserDetailSnapshot",
          "MembershipSnapshot",
          "ProfileSnapshot",
          "SubscriptionSnapshot",
          "InvitationSnapshot",
          "TicketSnapshot"
        ]
      },
      {
        "file_name": "tenant_driver.py",
        "file_path": "backend/app/hoc/cus/account/L6_drivers/tenant_driver.py",
        "layer": "L6_drivers",
        "domain": "account",
        "lines": 573,
        "module_docstring": "Tenant Driver (L6)\n\nPure data access layer for tenant operations.\n\nProvides:\n- Tenant CRUD\n- Membership CRUD\n- API key CRUD\n- Usage record CRUD\n- Run CRUD\n- Audit logging\n\nAll methods are pure data access - no business logic.\nReturns snapshot dataclasses or ORM models for mutations.\nBusiness logic belongs in the engine (L4).",
        "functions": [
          {
            "name": "get_tenant_driver",
            "signature": "(session: Session) -> TenantDriver",
            "docstring": "Get a TenantDriver instance.",
            "is_async": false,
            "line": 559
          }
        ],
        "classes": [
          {
            "name": "TenantCoreSnapshot",
            "docstring": "Core tenant data for engine operations.",
            "methods": [],
            "line": 71
          },
          {
            "name": "RunCountSnapshot",
            "docstring": "Running count for quota checks.",
            "methods": [],
            "line": 92
          },
          {
            "name": "APIKeySnapshot",
            "docstring": "API key data snapshot.",
            "methods": [],
            "line": 98
          },
          {
            "name": "UsageRecordSnapshot",
            "docstring": "Usage record data.",
            "methods": [],
            "line": 115
          },
          {
            "name": "RunSnapshot",
            "docstring": "Worker run snapshot.",
            "methods": [],
            "line": 127
          },
          {
            "name": "TenantDriver",
            "docstring": "L6 Driver for tenant data access.\n\nAll methods are pure data access - no business logic.\nReturns snapshots or ORM models for mutations.",
            "methods": [
              "__init__",
              "fetch_tenant_by_id",
              "fetch_tenant_by_slug",
              "fetch_tenant_snapshot",
              "insert_tenant",
              "update_tenant_plan",
              "update_tenant_status",
              "update_tenant_usage",
              "increment_tenant_usage",
              "insert_membership",
              "count_active_api_keys",
              "insert_api_key",
              "fetch_api_keys",
              "fetch_api_key_by_id",
              "update_api_key_revoked",
              "count_running_runs",
              "insert_run",
              "fetch_run_by_id",
              "update_run_completed",
              "fetch_runs",
              "insert_usage_record",
              "fetch_usage_records",
              "insert_audit_log"
            ],
            "line": 147
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional",
              "cast"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.models.tenant",
            "names": [
              "APIKey",
              "AuditLog",
              "Tenant",
              "TenantMembership",
              "UsageRecord",
              "User",
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": [
          "TenantDriver",
          "get_tenant_driver",
          "TenantCoreSnapshot",
          "RunCountSnapshot",
          "APIKeySnapshot",
          "UsageRecordSnapshot",
          "RunSnapshot"
        ]
      },
      {
        "file_name": "user_write_driver.py",
        "file_path": "backend/app/hoc/cus/account/L6_drivers/user_write_driver.py",
        "layer": "L6_drivers",
        "domain": "account",
        "lines": 137,
        "module_docstring": "User Write Driver (L6)\n\nPure database write operations for User management.\n\nL4 (UserWriteService) \u2192 L6 (this driver)\n\nResponsibilities:\n- Create user records\n- Update user login timestamps\n- Convert user to dict (DTO transformation)\n- NO business logic (L4 responsibility)\n\nReference: PIN-250, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_user_write_driver",
            "signature": "(session: Session) -> UserWriteDriver",
            "docstring": "Factory function to get UserWriteDriver instance.",
            "is_async": false,
            "line": 129
          }
        ],
        "classes": [
          {
            "name": "UserWriteDriver",
            "docstring": "L6 driver for user write operations.\n\nPure database access - no business logic.",
            "methods": [
              "__init__",
              "create_user",
              "update_user_login",
              "user_to_dict"
            ],
            "line": 51
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.models.tenant",
            "names": [
              "User"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": [
          "UserWriteDriver",
          "get_user_write_driver"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 7,
    "violation_count": 0,
    "gap_count": 2
  }
}