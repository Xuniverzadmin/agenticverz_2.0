{
  "general": {
    "l2_1_facade": null,
    "l2_apis": [
      {
        "file_name": "agents.py",
        "file_path": "backend/app/hoc/api/cus/general/agents.py",
        "layer": "L2_api",
        "domain": "general",
        "lines": 2762,
        "module_docstring": null,
        "functions": [
          {
            "name": "simulate_job",
            "signature": "(request: SimulateJobRequest, x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "Simulate job execution before committing resources.\n\nMachine-native pre-execution simulation (PIN-005):\n- Estimates total credits required\n- Checks budget availability\n- Estimates execution duration\n- Identifies risks and warnings\n- Returns feasibility assessment\n\nDoes NOT create the job or reserve credits.",
            "is_async": true,
            "line": 196
          },
          {
            "name": "create_job",
            "signature": "(request: CreateJobRequest, x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "Create a new parallel job.",
            "is_async": true,
            "line": 281
          },
          {
            "name": "get_job",
            "signature": "(job_id: str)",
            "docstring": "Get job status by ID.",
            "is_async": true,
            "line": 342
          },
          {
            "name": "cancel_job",
            "signature": "(job_id: str)",
            "docstring": "Cancel a running job.",
            "is_async": true,
            "line": 381
          },
          {
            "name": "claim_item",
            "signature": "(job_id: str, worker_instance_id: str = Query(..., description='Worker instance ID'))",
            "docstring": "Worker claims next available item.",
            "is_async": true,
            "line": 393
          },
          {
            "name": "complete_item",
            "signature": "(job_id: str, item_id: str, request: CompleteItemRequest)",
            "docstring": "Mark item as completed with output.",
            "is_async": true,
            "line": 415
          },
          {
            "name": "fail_item",
            "signature": "(job_id: str, item_id: str, request: FailItemRequest)",
            "docstring": "Mark item as failed.",
            "is_async": true,
            "line": 436
          },
          {
            "name": "get_blackboard",
            "signature": "(key: str)",
            "docstring": "Read value from blackboard.",
            "is_async": true,
            "line": 464
          },
          {
            "name": "put_blackboard",
            "signature": "(key: str, request: BlackboardWriteRequest)",
            "docstring": "Write value to blackboard.",
            "is_async": true,
            "line": 477
          },
          {
            "name": "increment_blackboard",
            "signature": "(key: str, request: BlackboardIncrementRequest)",
            "docstring": "Atomically increment a counter.",
            "is_async": true,
            "line": 489
          },
          {
            "name": "lock_blackboard",
            "signature": "(key: str, request: LockRequest)",
            "docstring": "Lock operation on blackboard.",
            "is_async": true,
            "line": 501
          },
          {
            "name": "register_agent",
            "signature": "(request: RegisterAgentRequest)",
            "docstring": "Register an agent instance.",
            "is_async": true,
            "line": 529
          },
          {
            "name": "agent_heartbeat",
            "signature": "(instance_id: str)",
            "docstring": "Update agent heartbeat.",
            "is_async": true,
            "line": 553
          },
          {
            "name": "deregister_agent",
            "signature": "(instance_id: str)",
            "docstring": "Deregister an agent instance.",
            "is_async": true,
            "line": 565
          },
          {
            "name": "get_agent",
            "signature": "(instance_id: str)",
            "docstring": "Get agent instance details.",
            "is_async": true,
            "line": 577
          },
          {
            "name": "list_agents",
            "signature": "(agent_id: Optional[str] = Query(default=None), job_id: Optional[str] = Query(default=None), status: Optional[str] = Query(default=None))",
            "docstring": "List agent instances.",
            "is_async": true,
            "line": 599
          },
          {
            "name": "send_message",
            "signature": "(instance_id: str, request: SendMessageRequest)",
            "docstring": "Send a message to an agent.",
            "is_async": true,
            "line": 633
          },
          {
            "name": "get_messages",
            "signature": "(instance_id: str, status: Optional[str] = Query(default=None), message_type: Optional[str] = Query(default=None), job_id: Optional[str] = Query(default=None), limit: int = Query(default=100, le=500))",
            "docstring": "Get messages for an agent.",
            "is_async": true,
            "line": 659
          },
          {
            "name": "mark_message_read",
            "signature": "(instance_id: str, message_id: str)",
            "docstring": "Mark message as read.",
            "is_async": true,
            "line": 694
          },
          {
            "name": "respond_to_invocation",
            "signature": "(request: InvokeResponseRequest)",
            "docstring": "Respond to an agent invocation.",
            "is_async": true,
            "line": 709
          },
          {
            "name": "validate_sba_endpoint",
            "signature": "(request: SBAValidateRequest)",
            "docstring": "Validate an SBA schema.\n\nM15.1 Strategy-Bound Agent validation endpoint.\nReturns validation result with any errors or warnings.",
            "is_async": true,
            "line": 754
          },
          {
            "name": "register_agent_with_sba",
            "signature": "(request: SBARegisterRequest, x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "Register an agent with its SBA schema.\n\nM15.1 Strategy-Bound Agent registration.\nValidates SBA and stores agent definition in registry.",
            "is_async": true,
            "line": 781
          },
          {
            "name": "generate_sba_for_agent",
            "signature": "(request: SBAGenerateRequest)",
            "docstring": "Auto-generate SBA for an agent.\n\nM15.1 SBA generation for retrofitting existing agents.",
            "is_async": true,
            "line": 828
          },
          {
            "name": "get_sba_version_info",
            "signature": "()",
            "docstring": "M15.1.1: Get SBA version negotiation info.\n\nReturns information about supported SBA versions for client negotiation.",
            "is_async": true,
            "line": 858
          },
          {
            "name": "negotiate_sba_version",
            "signature": "(requested_version: str = Query(..., description='Requested SBA version'))",
            "docstring": "M15.1.1: Negotiate SBA version.\n\nClient submits requested version, server responds with best compatible version.",
            "is_async": true,
            "line": 871
          },
          {
            "name": "get_sba_health",
            "signature": "(x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "M16: Get aggregated strategy health for Guard Console.\n\nReturns simple signal-level health status for all agents.\nUsed by StrategyHealthWidget in Guard Console.",
            "is_async": true,
            "line": 905
          },
          {
            "name": "get_agent_sba",
            "signature": "(agent_id: str)",
            "docstring": "Get SBA schema for an agent.\n\nM15.1 SBA retrieval endpoint.",
            "is_async": true,
            "line": 986
          },
          {
            "name": "list_agents_sba",
            "signature": "(agent_type: Optional[str] = Query(default=None), sba_validated: Optional[bool] = Query(default=None), x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "List agents with their SBA status.\n\nM15.1 SBA registry listing.",
            "is_async": true,
            "line": 1021
          },
          {
            "name": "check_spawn_allowed",
            "signature": "(agent_id: str = Query(..., description='Agent ID to check'), orchestrator: Optional[str] = Query(default=None), auto_generate: bool = Query(default=True))",
            "docstring": "Check if agent is allowed to spawn.\n\nM15.1 spawn-time enforcement check.\nReturns whether the agent has a valid SBA and can be spawned.",
            "is_async": true,
            "line": 1065
          },
          {
            "name": "get_fulfillment_aggregated",
            "signature": "(group_by: str = Query(default='domain', description='Group by: domain, agent_type, orchestrator'), threshold: Optional[float] = Query(default=None, description='Filter by minimum fulfillment'), x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "M15.1.1: Get aggregated fulfillment metrics for heatmap visualization.\n\nReturns fulfillment data for all agents with grouping and marketplace readiness.\nUsed by the SBA Inspector UI for the fulfillment heatmap feature.",
            "is_async": true,
            "line": 1100
          },
          {
            "name": "get_agent_activity_costs",
            "signature": "(agent_id: str, x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "M16: Get worker cost and risk metrics for an agent.\n\nReturns per-worker cost levels, risk scores, and budget usage.",
            "is_async": true,
            "line": 1309
          },
          {
            "name": "get_agent_activity_spending",
            "signature": "(agent_id: str, period: str = Query(default='24h', description='Time period: 1h, 6h, 24h, 7d'), x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "M16: Get spending data for budget burn chart.\n\nReturns actual vs projected spending over time with anomaly detection.",
            "is_async": true,
            "line": 1391
          },
          {
            "name": "get_agent_activity_retries",
            "signature": "(agent_id: str, limit: int = Query(default=50, le=200), x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "M16: Get retry log for an agent.\n\nReturns recent retry attempts with outcomes and risk impact.",
            "is_async": true,
            "line": 1476
          },
          {
            "name": "get_agent_activity_blockers",
            "signature": "(agent_id: str, x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "M16: Get current blockers for an agent.\n\nReturns issues preventing agent execution with suggested actions.",
            "is_async": true,
            "line": 1550
          },
          {
            "name": "check_agent_health",
            "signature": "(agent_id: str, x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "M16: Run comprehensive health check for an agent.\n\nValidates SBA configuration, checks for missing tools, unregistered\nconnections, workflow issues, and purpose conflicts.",
            "is_async": true,
            "line": 1663
          },
          {
            "name": "cascade_evaluate",
            "signature": "(request: CascadeEvaluateRequest, x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "M17: Evaluate agents through CARE pipeline without routing.\n\nReturns ranked list of agents with evaluation details for each stage.\nUse this to understand why agents are eligible or rejected.",
            "is_async": true,
            "line": 1938
          },
          {
            "name": "routing_dispatch",
            "signature": "(request: RoutingDispatchRequest, x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "M17: Execute full CARE routing pipeline and select best agent.\n\nThis is the main entry point for strategic routing.\nReturns the selected agent and routing decision details.",
            "is_async": true,
            "line": 2005
          },
          {
            "name": "get_agent_strategy",
            "signature": "(agent_id: str)",
            "docstring": "M17: Get agent's Strategy Cascade.\n\nReturns the full SBA with routing configuration.",
            "is_async": true,
            "line": 2061
          },
          {
            "name": "update_agent_strategy",
            "signature": "(agent_id: str, update: RoutingConfigUpdate)",
            "docstring": "M17: Hot-swap agent's routing configuration.\n\nUpdates routing-specific settings without changing the full SBA.",
            "is_async": true,
            "line": 2106
          },
          {
            "name": "get_routing_stats",
            "signature": "(x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "M17: Get routing statistics.\n\nReturns aggregate stats on routing decisions.",
            "is_async": true,
            "line": 2183
          },
          {
            "name": "explain_routing_decision",
            "signature": "(request_id: str, x_tenant_id: str = Header(default='default', alias='X-Tenant-ID'))",
            "docstring": "M18: Explain why a routing decision was made.\n\nReturns detailed explanation of all factors that influenced the decision,\nincluding reputation scores, SLA adjustments, hysteresis effects, and\ncapability matching.",
            "is_async": true,
            "line": 2322
          },
          {
            "name": "get_agent_evolution",
            "signature": "(agent_id: str, include_acknowledged: bool = Query(default=False, description='Include acknowledged drift signals'), limit: int = Query(default=20, le=100, description='Max items per category'))",
            "docstring": "M18: Get agent evolution history and current state.\n\nReturns drift signals, boundary violations, strategy adjustments,\nand recommendations for the agent.",
            "is_async": true,
            "line": 2462
          },
          {
            "name": "get_system_stability",
            "signature": "()",
            "docstring": "M18: Get system-wide stability metrics.\n\nReturns governor state, freeze status, adjustment counts,\nand oscillation detection results.",
            "is_async": true,
            "line": 2564
          },
          {
            "name": "freeze_system",
            "signature": "(duration_seconds: int = Query(default=900, ge=60, le=3600, description='Freeze duration'), reason: str = Query(default='Manual freeze', description='Reason for freeze'))",
            "docstring": "M18: Manually freeze the learning system.\n\nUse this to prevent any parameter adjustments during investigation\nor maintenance.",
            "is_async": true,
            "line": 2595
          },
          {
            "name": "unfreeze_system",
            "signature": "()",
            "docstring": "M18: Manually unfreeze the learning system.\n\nResumes normal operation after a manual freeze.",
            "is_async": true,
            "line": 2624
          },
          {
            "name": "trigger_batch_learning",
            "signature": "(window_hours: int = Query(default=1, ge=1, le=24, description='Hours of data to process'))",
            "docstring": "M18: Trigger batch learning process.\n\nRuns offline learning over the specified window and returns\nparameter adjustment recommendations.",
            "is_async": true,
            "line": 2645
          },
          {
            "name": "get_agent_reputation",
            "signature": "(agent_id: str)",
            "docstring": "M18: Get agent reputation details.\n\nReturns full reputation breakdown including quarantine state.",
            "is_async": true,
            "line": 2682
          },
          {
            "name": "get_agent_sla",
            "signature": "(agent_id: str)",
            "docstring": "M18: Get agent SLA score details.\n\nReturns SLA compliance metrics and targets.",
            "is_async": true,
            "line": 2703
          },
          {
            "name": "get_agent_successors",
            "signature": "(agent_id: str)",
            "docstring": "M18: Get successor mapping for agent failover.\n\nReturns mapping of capabilities to recommended successor agents.",
            "is_async": true,
            "line": 2741
          }
        ],
        "classes": [
          {
            "name": "CreateJobRequest",
            "docstring": "Request to create a parallel job.",
            "methods": [],
            "line": 71
          },
          {
            "name": "JobResponse",
            "docstring": "Job status response.",
            "methods": [],
            "line": 83
          },
          {
            "name": "ClaimItemResponse",
            "docstring": "Response when claiming an item.",
            "methods": [],
            "line": 96
          },
          {
            "name": "CompleteItemRequest",
            "docstring": "Request to complete an item.",
            "methods": [],
            "line": 106
          },
          {
            "name": "FailItemRequest",
            "docstring": "Request to fail an item.",
            "methods": [],
            "line": 112
          },
          {
            "name": "BlackboardWriteRequest",
            "docstring": "Request to write to blackboard.",
            "methods": [],
            "line": 119
          },
          {
            "name": "BlackboardIncrementRequest",
            "docstring": "Request to increment counter.",
            "methods": [],
            "line": 126
          },
          {
            "name": "LockRequest",
            "docstring": "Request for lock operation.",
            "methods": [],
            "line": 132
          },
          {
            "name": "RegisterAgentRequest",
            "docstring": "Request to register an agent.",
            "methods": [],
            "line": 140
          },
          {
            "name": "SendMessageRequest",
            "docstring": "Request to send a message.",
            "methods": [],
            "line": 149
          },
          {
            "name": "InvokeResponseRequest",
            "docstring": "Request to respond to an invocation.",
            "methods": [],
            "line": 159
          },
          {
            "name": "SimulateJobRequest",
            "docstring": "Request to simulate job execution before committing.",
            "methods": [],
            "line": 166
          },
          {
            "name": "SimulateJobResponse",
            "docstring": "Response from job simulation.",
            "methods": [],
            "line": 178
          },
          {
            "name": "SBAValidateRequest",
            "docstring": "Request to validate SBA schema.",
            "methods": [],
            "line": 725
          },
          {
            "name": "SBARegisterRequest",
            "docstring": "Request to register agent with SBA.",
            "methods": [],
            "line": 732
          },
          {
            "name": "SBAGenerateRequest",
            "docstring": "Request to auto-generate SBA for an agent.",
            "methods": [],
            "line": 744
          },
          {
            "name": "WorkerCostMetrics",
            "docstring": "Worker cost and risk metrics.",
            "methods": [],
            "line": 1216
          },
          {
            "name": "ActivityCostsResponse",
            "docstring": "Response for activity costs endpoint.",
            "methods": [],
            "line": 1226
          },
          {
            "name": "SpendingDataResponse",
            "docstring": "Response for spending tracker endpoint.",
            "methods": [],
            "line": 1236
          },
          {
            "name": "RetryEntryResponse",
            "docstring": "Single retry entry.",
            "methods": [],
            "line": 1248
          },
          {
            "name": "ActivityRetriesResponse",
            "docstring": "Response for retries endpoint.",
            "methods": [],
            "line": 1258
          },
          {
            "name": "BlockerEntry",
            "docstring": "Single blocker entry.",
            "methods": [],
            "line": 1268
          },
          {
            "name": "ActivityBlockersResponse",
            "docstring": "Response for blockers endpoint.",
            "methods": [],
            "line": 1278
          },
          {
            "name": "HealthCheckItem",
            "docstring": "Single health check result.",
            "methods": [],
            "line": 1287
          },
          {
            "name": "HealthCheckResponse",
            "docstring": "Response for health check endpoint.",
            "methods": [],
            "line": 1297
          },
          {
            "name": "CascadeEvaluateRequest",
            "docstring": "Request for cascade evaluation.",
            "methods": [],
            "line": 1897
          },
          {
            "name": "RoutingDispatchRequest",
            "docstring": "Request for routing dispatch.",
            "methods": [],
            "line": 1909
          },
          {
            "name": "RoutingConfigUpdate",
            "docstring": "Request to update agent routing config.",
            "methods": [],
            "line": 1922
          },
          {
            "name": "ExplainRoutingResponse",
            "docstring": "Response explaining a routing decision.",
            "methods": [],
            "line": 2287
          },
          {
            "name": "EvolutionReportResponse",
            "docstring": "Response with agent evolution history.",
            "methods": [],
            "line": 2297
          },
          {
            "name": "SystemStabilityResponse",
            "docstring": "Response with system-wide stability metrics.",
            "methods": [],
            "line": 2308
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Header",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "agents.services.blackboard_service",
            "names": [
              "get_blackboard_service"
            ],
            "is_relative": true,
            "line": 33
          },
          {
            "module": "schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": true,
            "line": 34
          },
          {
            "module": "agents.services.credit_service",
            "names": [
              "CREDIT_COSTS",
              "get_credit_service"
            ],
            "is_relative": true,
            "line": 35
          },
          {
            "module": "agents.services.job_service",
            "names": [
              "JobConfig",
              "get_job_service"
            ],
            "is_relative": true,
            "line": 36
          },
          {
            "module": "agents.services.message_service",
            "names": [
              "get_message_service"
            ],
            "is_relative": true,
            "line": 37
          },
          {
            "module": "agents.services.registry_service",
            "names": [
              "get_registry_service"
            ],
            "is_relative": true,
            "line": 38
          },
          {
            "module": "agents.services.worker_service",
            "names": [
              "get_worker_service"
            ],
            "is_relative": true,
            "line": 39
          },
          {
            "module": "agents.skills.agent_invoke",
            "names": [
              "AgentInvokeSkill"
            ],
            "is_relative": true,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "debug_auth.py",
        "file_path": "backend/app/hoc/api/cus/general/debug_auth.py",
        "layer": "L2_api",
        "domain": "general",
        "lines": 278,
        "module_docstring": "Debug Auth Context Endpoint\n\nProvides visibility into the current authentication state.\nThis endpoint is for DEBUGGING only \u2014 never expose in production without auth.\n\nAuthority Contract (AUTH_AUTHORITY.md):\n- This endpoint reveals the interpreted auth context\n- Shows which auth plane was selected (HUMAN vs MACHINE)\n- Shows tenant state as derived (not cached)\n- Helps diagnose auth failures without guessing\n\nSECURITY NOTE:\n- This endpoint should be protected behind auth\n- Do not return sensitive tokens or secrets\n- Return only interpreted state, not raw inputs",
        "functions": [
          {
            "name": "_mask_value",
            "signature": "(value: str, visible_chars: int = 8) -> str",
            "docstring": "Mask a sensitive value, showing only first N chars.",
            "is_async": false,
            "line": 85
          },
          {
            "name": "_get_tenant_state",
            "signature": "(tenant_id: Optional[str]) -> tuple[Optional[str], Optional[int]]",
            "docstring": "Get the DERIVED tenant state (not cached).\n\nUses TenantStateResolver to compute state from:\naccount \u2192 users \u2192 bindings \u2192 billing\n\nReturns:\n    Tuple of (state_name, state_value) or (None, None) if no tenant",
            "is_async": true,
            "line": 94
          },
          {
            "name": "get_auth_context",
            "signature": "(request: Request)",
            "docstring": "Debug endpoint: Show current auth context.\n\nReturns the interpreted authentication context for the current request.\nThis reveals:\n- Which auth plane was selected (HUMAN vs MACHINE)\n- The resolved identity\n- The derived tenant state (computed, not cached)\n- What the gateway understood from the headers\n\nUse this to debug auth failures and understand system state.",
            "is_async": true,
            "line": 121
          },
          {
            "name": "get_auth_planes",
            "signature": "()",
            "docstring": "Debug endpoint: Show available auth planes and their characteristics.\n\nThis is a reference endpoint - no auth context required.",
            "is_async": true,
            "line": 219
          },
          {
            "name": "get_tenant_states",
            "signature": "()",
            "docstring": "Debug endpoint: Show tenant state definitions.\n\nThis is a reference endpoint - no auth context required.",
            "is_async": true,
            "line": 248
          }
        ],
        "classes": [
          {
            "name": "AuthContextDebugResponse",
            "docstring": "Debug response showing current auth context state.",
            "methods": [],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Request"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.contexts",
            "names": [
              "AuthPlane",
              "FounderAuthContext",
              "HumanAuthContext",
              "MachineCapabilityContext"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "health.py",
        "file_path": "backend/app/hoc/api/cus/general/health.py",
        "layer": "L2_api",
        "domain": "general",
        "lines": 171,
        "module_docstring": "Health and Determinism Status Endpoints\n\nProvides operational visibility into:\n- Service health\n- Determinism status (last replay hash)\n- Adapter availability\n- Registry state",
        "functions": [
          {
            "name": "update_replay_hash",
            "signature": "(workflow_name: str, output_hash: str)",
            "docstring": "Update the determinism state after a replay test.",
            "is_async": false,
            "line": 30
          },
          {
            "name": "report_drift",
            "signature": "(workflow_name: str, expected: str, actual: str)",
            "docstring": "Report a determinism drift.",
            "is_async": false,
            "line": 38
          },
          {
            "name": "health_check",
            "signature": "() -> Dict[str, Any]",
            "docstring": "Basic health check endpoint.\n\nReturns:\n    200: Service is healthy\n    503: Service is degraded",
            "is_async": true,
            "line": 51
          },
          {
            "name": "readiness_check",
            "signature": "() -> Dict[str, Any]",
            "docstring": "Kubernetes readiness probe.\n\nChecks:\n- Database connectivity\n- Redis connectivity\n- Essential services",
            "is_async": true,
            "line": 68
          },
          {
            "name": "determinism_status",
            "signature": "() -> Dict[str, Any]",
            "docstring": "Determinism status endpoint.\n\nShows:\n- Last replay hash\n- Replay count\n- Drift detection status\n\nUsed for operational monitoring and debugging.",
            "is_async": true,
            "line": 95
          },
          {
            "name": "adapter_status",
            "signature": "() -> Dict[str, Any]",
            "docstring": "LLM adapter availability status.\n\nShows registered adapters and their health.",
            "is_async": true,
            "line": 119
          },
          {
            "name": "skills_status",
            "signature": "() -> Dict[str, Any]",
            "docstring": "Skill registry status.\n\nShows registered skills and their versions.",
            "is_async": true,
            "line": 148
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 14
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict"
            ],
            "is_relative": false,
            "line": 15
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter"
            ],
            "is_relative": false,
            "line": 17
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "sdk.py",
        "file_path": "backend/app/hoc/api/cus/general/sdk.py",
        "layer": "L2_api",
        "domain": "general",
        "lines": 226,
        "module_docstring": "SDK Endpoints\n\nPIN-399: Provides SDK handshake and registration endpoints for onboarding.\n\nThese endpoints are called by SDK clients during initial setup:\n1. /sdk/handshake - Validate SDK connection and advance onboarding\n2. /sdk/register - Register SDK instance (future use)\n3. /sdk/instructions - Get SDK setup instructions (future use)\n\nONBOARDING TRANSITIONS:\n- /sdk/handshake triggers: API_KEY_CREATED \u2192 SDK_CONNECTED",
        "functions": [
          {
            "name": "_maybe_advance_to_sdk_connected",
            "signature": "(tenant_id: str) -> Optional[str]",
            "docstring": "PIN-399: Trigger onboarding state transition on first SDK handshake.\n\nReturns the new state name if transition occurred, None otherwise.",
            "is_async": true,
            "line": 75
          },
          {
            "name": "sdk_handshake",
            "signature": "(request: Request, body: HandshakeRequest)",
            "docstring": "SDK handshake endpoint.\n\nCalled by SDK clients on first connection to validate setup\nand trigger onboarding state transition.\n\nPIN-399: This endpoint triggers API_KEY_CREATED \u2192 SDK_CONNECTED transition.\n\nRequires: Valid API key authentication (X-AOS-Key header)",
            "is_async": true,
            "line": 115
          },
          {
            "name": "get_sdk_instructions",
            "signature": "(request: Request)",
            "docstring": "Get SDK setup instructions.\n\nReturns configuration and example code for SDK setup.\n\nRequires: Valid authentication (JWT or API key)",
            "is_async": true,
            "line": 177
          }
        ],
        "classes": [
          {
            "name": "HandshakeRequest",
            "docstring": "SDK handshake request.",
            "methods": [],
            "line": 43
          },
          {
            "name": "HandshakeResponse",
            "docstring": "SDK handshake response.",
            "methods": [],
            "line": 51
          },
          {
            "name": "InstructionsResponse",
            "docstring": "SDK setup instructions response.",
            "methods": [],
            "line": 62
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request",
              "status"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": true,
            "line": 33
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l3_adapters": [],
    "l4_runtime": [
      {
        "file_name": "transaction_coordinator.py",
        "file_path": "backend/app/hoc/cus/general/L4_runtime/drivers/transaction_coordinator.py",
        "layer": "L4_runtime",
        "domain": "general",
        "lines": 841,
        "module_docstring": "Transaction Coordinator for Cross-Domain Writes\n\nThis module provides atomic transaction coordination for run completion,\nensuring that ALL domain updates succeed or NONE persist.\n\nProblem Addressed (FIX-001):\n- Incident/policy/trace writes are independent\n- Partial failure causes inconsistent state\n- Events published before all operations complete\n\nSolution:\n- Wrap all domain operations in single transaction boundary\n- Track which operations succeeded for rollback\n- Publish events ONLY after successful commit\n\nArchitecture:\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502              Transaction Coordinator (L4)                        \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502  TRANSACTION FLOW:                                               \u2502\n    \u2502  1. Begin transaction                                            \u2502\n    \u2502  2. Create incident (via IncidentFacade)                         \u2502\n    \u2502  3. Create policy evaluation (via GovernanceFacade)              \u2502\n    \u2502  4. Complete trace (via TraceFacade)                             \u2502\n    \u2502  5. Commit transaction                                           \u2502\n    \u2502  6. Publish events (post-commit only)                            \u2502\n    \u2502                                                                  \u2502\n    \u2502  ON FAILURE:                                                     \u2502\n    \u2502  \u2022 Rollback transaction                                          \u2502\n    \u2502  \u2022 No events published                                           \u2502\n    \u2502  \u2022 Raise TransactionFailed with context                          \u2502\n    \u2502                                                                  \u2502\n    \u2502  INVARIANTS:                                                     \u2502\n    \u2502  \u2022 Events ONLY after successful commit                           \u2502\n    \u2502  \u2022 Partial state is never visible                                \u2502\n    \u2502  \u2022 All domain operations use facades (layer compliance)          \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nUsage:\n\n    from app.hoc.cus.general.L4_runtime.drivers.transaction_coordinator import (\n        RunCompletionTransaction,\n        get_transaction_coordinator,\n    )\n\n    coordinator = get_transaction_coordinator()\n    result = coordinator.execute(\n        run_id=run_id,\n        tenant_id=tenant_id,\n        run_status=\"succeeded\",\n        agent_id=agent_id,\n    )",
        "functions": [
          {
            "name": "get_transaction_coordinator",
            "signature": "() -> RunCompletionTransaction",
            "docstring": "Get the singleton transaction coordinator instance.\n\nReturns:\n    RunCompletionTransaction instance",
            "is_async": false,
            "line": 816
          },
          {
            "name": "create_transaction_coordinator",
            "signature": "(publisher = None) -> RunCompletionTransaction",
            "docstring": "Create a new transaction coordinator instance.\n\nUse this for testing or when you need a fresh instance.\n\nArgs:\n    publisher: Optional event publisher\n\nReturns:\n    RunCompletionTransaction instance",
            "is_async": false,
            "line": 829
          }
        ],
        "classes": [
          {
            "name": "TransactionPhase",
            "docstring": "Phases of transaction execution.",
            "methods": [],
            "line": 111
          },
          {
            "name": "TransactionFailed",
            "docstring": "Raised when cross-domain transaction fails.",
            "methods": [
              "__init__"
            ],
            "line": 124
          },
          {
            "name": "DomainResult",
            "docstring": "Result from a single domain operation.",
            "methods": [
              "to_dict"
            ],
            "line": 141
          },
          {
            "name": "TransactionResult",
            "docstring": "Result of a successful cross-domain transaction.",
            "methods": [
              "is_complete",
              "all_domains_succeeded",
              "to_dict"
            ],
            "line": 164
          },
          {
            "name": "RollbackAction",
            "docstring": "Describes a rollback action for a domain operation.",
            "methods": [],
            "line": 202
          },
          {
            "name": "RunCompletionTransaction",
            "docstring": "Atomic cross-domain transaction for run completion.\n\nEnsures either ALL domain updates succeed or NONE persist.\nEvents published ONLY after commit succeeds.\n\nLayer: L4 (Domain Logic)\nCallers: ROK (L5), RunRunner (L5)",
            "methods": [
              "__init__",
              "execute",
              "_create_incident",
              "_create_policy_evaluation",
              "_complete_trace",
              "_publish_events",
              "_execute_rollback",
              "_emit_rollback_ack",
              "_rollback_incident",
              "_rollback_policy"
            ],
            "line": 212
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 79
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 80
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 81
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 82
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 83
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 84
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 85
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 87
          },
          {
            "module": "app.db",
            "names": [
              "engine"
            ],
            "is_relative": false,
            "line": 89
          },
          {
            "module": "app.events",
            "names": [
              "get_publisher"
            ],
            "is_relative": false,
            "line": 90
          },
          {
            "module": "app.hoc.cus.general.L5_schemas.rac_models",
            "names": [
              "AckStatus",
              "AuditAction",
              "AuditDomain",
              "DomainAck"
            ],
            "is_relative": false,
            "line": 93
          },
          {
            "module": "app.hoc.cus.general.L5_engines.audit_store",
            "names": [
              "get_audit_store"
            ],
            "is_relative": false,
            "line": 100
          }
        ],
        "constants": [
          {
            "name": "RAC_ROLLBACK_AUDIT_ENABLED",
            "line": 103
          },
          {
            "name": "TRANSACTION_COORDINATOR_ENABLED",
            "line": 108
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "constraint_checker.py",
        "file_path": "backend/app/hoc/cus/general/L4_runtime/engines/constraint_checker.py",
        "layer": "L4_runtime",
        "domain": "general",
        "lines": 310,
        "module_docstring": "Module: constraint_checker\nPurpose: Enforce inspection constraints from MonitorConfig.\n\nInspection constraints are \"negative capabilities\" - they define what\na policy is NOT allowed to inspect or capture. Before any logging\noperation, the runner/worker must check these constraints.\n\nConstraint Fields (from MonitorConfig):\n    - allow_prompt_logging: Can prompts be logged?\n    - allow_response_logging: Can responses be logged?\n    - allow_pii_capture: Can PII be captured?\n    - allow_secret_access: Can secrets be accessed?\n\nExports:\n    - InspectionOperation: Enum of operations requiring checks\n    - InspectionConstraintViolation: Violation record\n    - InspectionConstraintChecker: Main enforcement class\n    - check_inspection_allowed: Quick helper function\n    - get_constraint_violations: Get all violations",
        "functions": [
          {
            "name": "check_inspection_allowed",
            "signature": "(operation: InspectionOperation, allow_prompt_logging: bool = False, allow_response_logging: bool = False, allow_pii_capture: bool = False, allow_secret_access: bool = False) -> bool",
            "docstring": "Quick helper to check if an operation is allowed.\n\nArgs:\n    operation: The operation to check\n    allow_prompt_logging: Whether prompts can be logged\n    allow_response_logging: Whether responses can be logged\n    allow_pii_capture: Whether PII can be captured\n    allow_secret_access: Whether secrets can be accessed\n\nReturns:\n    True if operation is allowed, False otherwise",
            "is_async": false,
            "line": 254
          },
          {
            "name": "get_constraint_violations",
            "signature": "(operations: list[InspectionOperation], allow_prompt_logging: bool = False, allow_response_logging: bool = False, allow_pii_capture: bool = False, allow_secret_access: bool = False) -> list[dict[str, Any]]",
            "docstring": "Get all constraint violations for a set of operations.\n\nArgs:\n    operations: List of operations to check\n    allow_prompt_logging: Whether prompts can be logged\n    allow_response_logging: Whether responses can be logged\n    allow_pii_capture: Whether PII can be captured\n    allow_secret_access: Whether secrets can be accessed\n\nReturns:\n    List of violation dicts (empty if all allowed)",
            "is_async": false,
            "line": 283
          }
        ],
        "classes": [
          {
            "name": "InspectionOperation",
            "docstring": "Operations that require inspection constraint checks.",
            "methods": [],
            "line": 47
          },
          {
            "name": "InspectionConstraintViolation",
            "docstring": "Record of an inspection constraint violation.\n\nCreated when an operation is attempted that violates\nthe MonitorConfig inspection constraints.",
            "methods": [
              "to_dict"
            ],
            "line": 66
          },
          {
            "name": "InspectionConstraintChecker",
            "docstring": "Enforces inspection constraints from MonitorConfig.\n\nThis class checks whether logging and data capture operations\nare allowed based on the MonitorConfig's inspection constraint\nsettings (negative capabilities).\n\nGAP-033: Wire MonitorConfig flags to runner.\n\nUsage:\n    checker = InspectionConstraintChecker(monitor_config)\n    if checker.is_allowed(InspectionOperation.LOG_PROMPT):\n        # Log the prompt\n    else:\n        # Skip logging, constraint forbids it",
            "methods": [
              "__init__",
              "from_monitor_config",
              "from_snapshot",
              "is_allowed",
              "check",
              "check_all",
              "get_allowed_operations",
              "get_denied_operations",
              "to_dict"
            ],
            "line": 89
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "governance_orchestrator.py",
        "file_path": "backend/app/hoc/cus/general/L4_runtime/engines/governance_orchestrator.py",
        "layer": "L4_runtime",
        "domain": "general",
        "lines": 807,
        "module_docstring": "Part-2 Governance Orchestrator (L4)\n\nOrchestrates the governance workflow from contract activation through\naudit triggering. This is the \"traffic controller\" - it directs flow\nbut does not execute.\n\nComponents:\n1. Contract Activation Service - APPROVED \u2192 ACTIVE\n2. Execution Orchestrator - contract \u2192 job plan\n3. Job State Tracker - observes job states\n4. Audit Trigger - hands evidence to audit layer\n\nKey Constraints (PIN-292):\n- Orchestrates only; does not execute jobs\n- No health or audit authority\n- Contract is the sole source of execution intent\n- MAY_NOT remains mechanically un-overridable\n\nReference: PART2_CRM_WORKFLOW_CHARTER.md, PIN-292, part2-design-v1",
        "functions": [],
        "classes": [
          {
            "name": "HealthLookup",
            "docstring": "Protocol for capturing health state (read-only).",
            "methods": [
              "capture_health_snapshot"
            ],
            "line": 93
          },
          {
            "name": "JobState",
            "docstring": "In-memory representation of job state.\n\nUsed for state tracking before persistence.",
            "methods": [],
            "line": 107
          },
          {
            "name": "JobStateMachine",
            "docstring": "State machine for Governance Job lifecycle.\n\nEnforces:\n- JOB-002: Job steps execute in order\n- JOB-003: Terminal states are immutable",
            "methods": [
              "can_transition",
              "validate_transition",
              "transition"
            ],
            "line": 138
          },
          {
            "name": "ExecutionOrchestrator",
            "docstring": "Translates contract \u2192 job plan.\n\nThis is purely a planning service. It does NOT execute.\n\nResponsibilities:\n1. Parse contract proposed_changes into JobSteps\n2. Validate step ordering\n3. Calculate timeouts\n\nReference: PART2_CRM_WORKFLOW_CHARTER.md Step 7",
            "methods": [
              "create_job_plan",
              "_parse_change_to_step"
            ],
            "line": 258
          },
          {
            "name": "JobStateTracker",
            "docstring": "Observes job state - does NOT control execution.\n\nThis is purely an observation service.\n\nResponsibilities:\n1. Track job state transitions\n2. Record step results\n3. Capture evidence for audit\n\nKey constraint: This service READS state, it doesn't DRIVE execution.\nThe actual execution is done by L5 Job Executor.",
            "methods": [
              "record_step_result",
              "calculate_completion_status"
            ],
            "line": 340
          },
          {
            "name": "AuditEvidence",
            "docstring": "Evidence package for audit layer.\n\nThis is what we hand to the auditor (L8).",
            "methods": [],
            "line": 429
          },
          {
            "name": "AuditTrigger",
            "docstring": "Prepares and hands evidence to audit layer.\n\nThis service does NOT make audit decisions.\nIt packages evidence and signals that audit should occur.\n\nThe actual audit logic is in the Audit Service (L8).",
            "methods": [
              "prepare_evidence",
              "should_trigger_audit"
            ],
            "line": 447
          },
          {
            "name": "ContractActivationError",
            "docstring": "Raised when contract activation fails.",
            "methods": [
              "__init__"
            ],
            "line": 501
          },
          {
            "name": "ContractActivationService",
            "docstring": "Activates approved contracts (APPROVED \u2192 ACTIVE).\n\nThis is the bridge between the contract state machine and job creation.\n\nResponsibilities:\n1. Verify contract is APPROVED\n2. Create job plan from contract\n3. Create job record\n4. Transition contract to ACTIVE\n\nKey constraint: Activation creates a job but does NOT execute it.",
            "methods": [
              "__init__",
              "activate_contract"
            ],
            "line": 510
          },
          {
            "name": "GovernanceOrchestrator",
            "docstring": "Facade for all governance orchestration services.\n\nThis is the main entry point for governance workflow orchestration.\nIt combines:\n- Contract Activation Service\n- Execution Orchestrator\n- Job State Tracker\n- Audit Trigger\n\nKey Properties (PIN-292):\n- Orchestrates only; does not execute jobs\n- No health or audit authority\n- Contract is the sole source of execution intent\n\nReference: PART2_CRM_WORKFLOW_CHARTER.md, PIN-292",
            "methods": [
              "__init__",
              "version",
              "activate_contract",
              "start_job",
              "record_step_result",
              "complete_job",
              "cancel_job",
              "should_trigger_audit",
              "prepare_audit_evidence",
              "is_job_terminal",
              "can_start_job",
              "get_job_progress"
            ],
            "line": 629
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional",
              "Protocol"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "uuid",
            "names": [
              "UUID",
              "uuid4"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "app.models.contract",
            "names": [
              "ContractStatus"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.models.governance_job",
            "names": [
              "JOB_TERMINAL_STATES",
              "JOB_VALID_TRANSITIONS",
              "HealthSnapshot",
              "InvalidJobTransitionError",
              "JobImmutableError",
              "JobStatus",
              "JobStep",
              "JobTransitionRecord",
              "StepResult",
              "StepStatus"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "app.hoc.cus.general.L5_workflow.contracts.engines.contract_engine",
            "names": [
              "ContractService",
              "ContractState"
            ],
            "is_relative": false,
            "line": 82
          }
        ],
        "constants": [
          {
            "name": "ORCHESTRATOR_VERSION",
            "line": 85
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "phase_status_invariants.py",
        "file_path": "backend/app/hoc/cus/general/L4_runtime/engines/phase_status_invariants.py",
        "layer": "L4_runtime",
        "domain": "general",
        "lines": 361,
        "module_docstring": "Module: phase_status_invariants\nPurpose: Enforce phase-status invariants using GovernanceConfig.\n\nThe phase_status_invariant_enforce flag in GovernanceConfig controls\nwhether invalid phase-status combinations are blocked.\n\nPhase-Status Invariants:\n    - CREATED, AUTHORIZED: status must be \"queued\"\n    - EXECUTING, GOVERNANCE_CHECK, FINALIZING: status must be \"running\"\n    - COMPLETED: status must be \"succeeded\"\n    - FAILED: status must be \"failed\", \"failed_policy\", \"cancelled\", or \"retry\"\n\nWhen enforcement is enabled, attempting an invalid combination raises\nPhaseStatusInvariantEnforcementError.\n\nExports:\n    - PhaseStatusInvariantEnforcementError: Raised on violation\n    - PhaseStatusInvariantChecker: Main checker class\n    - check_phase_status_invariant: Quick helper function",
        "functions": [
          {
            "name": "check_phase_status_invariant",
            "signature": "(phase: str, status: str, enforcement_enabled: bool = True) -> InvariantCheckResponse",
            "docstring": "Quick helper to check a phase-status invariant.\n\nArgs:\n    phase: Phase name\n    status: Status value\n    enforcement_enabled: Whether enforcement is enabled\n\nReturns:\n    InvariantCheckResponse with validation result",
            "is_async": false,
            "line": 324
          },
          {
            "name": "ensure_phase_status_invariant",
            "signature": "(phase: str, status: str, enforcement_enabled: bool = True) -> None",
            "docstring": "Quick helper to ensure phase-status invariant or raise error.\n\nArgs:\n    phase: Phase name\n    status: Status value\n    enforcement_enabled: Whether enforcement is enabled\n\nRaises:\n    PhaseStatusInvariantEnforcementError: If invalid and enforcement enabled",
            "is_async": false,
            "line": 344
          }
        ],
        "classes": [
          {
            "name": "InvariantCheckResult",
            "docstring": "Result of an invariant check.",
            "methods": [],
            "line": 47
          },
          {
            "name": "PhaseStatusInvariantEnforcementError",
            "docstring": "Raised when phase-status invariant enforcement fails.\n\nThis error indicates that an invalid phase-status combination\nwas attempted when enforcement is enabled.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 68
          },
          {
            "name": "InvariantCheckResponse",
            "docstring": "Response from an invariant check.",
            "methods": [
              "to_dict"
            ],
            "line": 103
          },
          {
            "name": "PhaseStatusInvariantChecker",
            "docstring": "Checks and enforces phase-status invariants.\n\nGAP-051: Add invariant checks to ROK.\n\nThe checker validates that phase-status combinations are valid\nand can raise errors when enforcement is enabled.\n\nUsage:\n    checker = PhaseStatusInvariantChecker(enforcement_enabled=True)\n\n    # Before a phase transition\n    checker.ensure_valid(\"EXECUTING\", \"running\")\n\n    # Or check without raising\n    response = checker.check(\"EXECUTING\", \"running\")\n    if not response.is_valid and response.enforcement_enabled:\n        handle_invariant_violation()",
            "methods": [
              "__init__",
              "from_governance_config",
              "enforcement_enabled",
              "get_allowed_statuses",
              "is_valid_combination",
              "check",
              "ensure_valid",
              "should_allow_transition"
            ],
            "line": 127
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "FrozenSet",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "plan_generation_engine.py",
        "file_path": "backend/app/hoc/cus/general/L4_runtime/engines/plan_generation_engine.py",
        "layer": "L4_runtime",
        "domain": "general",
        "lines": 264,
        "module_docstring": "Domain engine for plan generation.\n\nThis L4 engine contains the authoritative logic for:\n1. Memory context retrieval\n2. Plan generation via planner\n3. Plan validation\n\nL5 workers must receive plans from this engine (via run.plan_json),\nnot generate their own plans.\n\nReference: PIN-257 Phase R-2\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md",
        "functions": [
          {
            "name": "generate_plan_for_run",
            "signature": "(agent_id: str, goal: str, run_id: str) -> PlanGenerationResult",
            "docstring": "Convenience function to generate a plan for a run.\n\nThis is the L4 entry point for plan generation. It should be called\nby the run creation flow (in L2 API) to generate plans before\nthe run is queued for execution.\n\nArgs:\n    agent_id: Agent ID\n    goal: Run goal\n    run_id: Run ID\n\nReturns:\n    PlanGenerationResult with the generated plan\n\nReference: PIN-257 Phase R-2",
            "is_async": false,
            "line": 218
          }
        ],
        "classes": [
          {
            "name": "PlanGenerationContext",
            "docstring": "Context for plan generation.",
            "methods": [],
            "line": 62
          },
          {
            "name": "PlanGenerationResult",
            "docstring": "Result of plan generation.",
            "methods": [],
            "line": 72
          },
          {
            "name": "PlanGenerationEngine",
            "docstring": "L4 Domain Engine for plan generation.\n\nThis engine contains ALL plan generation logic that was previously\nscattered in L5 runner.py. It generates plans from goals using\nmemory context and the configured planner.\n\nL5 workers must NOT:\n- Import memory.get_retriever()\n- Import planners.get_planner()\n- Generate plans inline\n\nL5 workers must ONLY:\n- Execute plans provided via run.plan_json\n- Fail if no plan is provided\n\nReference: PIN-257 Phase R-2\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md Section 3.2",
            "methods": [
              "__init__",
              "generate"
            ],
            "line": 89
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.memory",
            "names": [
              "get_retriever"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.planners",
            "names": [
              "get_planner"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.skills",
            "names": [
              "get_skill_manifest"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.utils.budget_tracker",
            "names": [
              "get_budget_tracker"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.utils.plan_inspector",
            "names": [
              "validate_plan"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": [
          "PlanGenerationContext",
          "PlanGenerationResult",
          "PlanGenerationEngine",
          "generate_plan_for_run"
        ]
      },
      {
        "file_name": "run_governance_facade.py",
        "file_path": "backend/app/hoc/cus/general/L4_runtime/facades/run_governance_facade.py",
        "layer": "L4_runtime",
        "domain": "general",
        "lines": 335,
        "module_docstring": "Run Governance Facade (L4 Domain Logic)\n\nThis facade provides the external interface for governance operations\nduring run execution. The L5 runner MUST use this facade instead of\ndirectly importing L4 engines.\n\nWhy This Facade Exists (PIN-454):\n- Prevents L5\u2192L4 layer violations (runner importing engines directly)\n- Centralizes governance logic for run lifecycle\n- Provides RAC (Runtime Audit Contract) acknowledgment emission\n- Single point for audit expectation/acknowledgment emission\n\nWrapped Services:\n- LessonsLearnedEngine: Learning from run outcomes\n- PolicyViolationService: Policy evaluation for runs\n\nRAC Integration (PIN-454):\n- Emits acknowledgments after policy evaluation\n- Domain: POLICIES\n- Action: EVALUATE_POLICY\n\nUsage:\n    from app.hoc.cus.general.L4_runtime.facades.run_governance_facade import get_run_governance_facade\n\n    facade = get_run_governance_facade()\n\n    # Policy evaluation (emits RAC ack automatically)\n    policy_id = facade.create_policy_evaluation(\n        run_id=run_id,\n        tenant_id=tenant_id,\n        run_status=\"succeeded\",\n    )\n\n    # Lesson emission\n    lesson_id = facade.emit_near_threshold_lesson(\n        tenant_id=tenant_id,\n        metric=\"budget\",\n        utilization=87.5,\n        ...\n    )",
        "functions": [
          {
            "name": "get_run_governance_facade",
            "signature": "() -> RunGovernanceFacade",
            "docstring": "Get the run governance facade instance.\n\nThis is the recommended way to access governance operations from\nthe L5 worker runtime.\n\nReturns:\n    RunGovernanceFacade instance",
            "is_async": false,
            "line": 322
          }
        ],
        "classes": [
          {
            "name": "RunGovernanceFacade",
            "docstring": "Facade for run governance operations.\n\nThis is the ONLY entry point for L5 worker code to interact with\nlessons learned and policy evaluation services.\n\nLayer: L4 (Domain Logic)\nCallers: RunRunner (L5)",
            "methods": [
              "__init__",
              "_lessons",
              "create_policy_evaluation",
              "_emit_ack",
              "emit_near_threshold_lesson",
              "emit_critical_success_lesson"
            ],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 65
          }
        ],
        "constants": [
          {
            "name": "RAC_ENABLED",
            "line": 70
          }
        ],
        "all_exports": null
      }
    ],
    "l5_engines": [
      {
        "file_name": "alert_log_linker.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/alert_log_linker.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 759,
        "module_docstring": "Module: alert_log_linker\nPurpose: Explicit linking between alerts and log records.\n\nGAP-019: Alert \u2192 Log linking must be explicit, not implicit.\nThis service provides:\n    - Create links between alerts and log entries\n    - Query logs by alert or alerts by run\n    - Track link creation and access patterns\n    - Support for different link types (threshold, breach, incident)\n\nExports:\n    - AlertLogLinkType: Type of link (threshold, breach, incident)\n    - AlertLogLinkStatus: Status of link (active, expired, archived)\n    - AlertLogLink: Model for alert-log relationships\n    - AlertLogLinker: Main service class\n    - AlertLogLinkResponse: Response model\n    - AlertLogLinkError: Error for link operations\n    - Helper functions for quick access",
        "functions": [
          {
            "name": "get_alert_log_linker",
            "signature": "() -> AlertLogLinker",
            "docstring": "Get or create the alert log linker singleton.",
            "is_async": false,
            "line": 680
          },
          {
            "name": "_reset_alert_log_linker",
            "signature": "() -> None",
            "docstring": "Reset the alert log linker (for testing).",
            "is_async": false,
            "line": 688
          },
          {
            "name": "create_alert_log_link",
            "signature": "(alert_id: str, run_id: str, tenant_id: str, link_type: AlertLogLinkType, step_indices: Optional[List[int]] = None, **kwargs) -> AlertLogLink",
            "docstring": "Quick helper to create an alert-log link.\n\nArgs:\n    alert_id: Alert identifier\n    run_id: Run identifier\n    tenant_id: Tenant identifier\n    link_type: Type of link\n    step_indices: Steps to link\n    **kwargs: Additional link parameters\n\nReturns:\n    Created AlertLogLink",
            "is_async": false,
            "line": 697
          },
          {
            "name": "get_alerts_for_run",
            "signature": "(run_id: str, link_type: Optional[AlertLogLinkType] = None) -> List[AlertLogLink]",
            "docstring": "Quick helper to get alerts for a run.\n\nArgs:\n    run_id: Run identifier\n    link_type: Optional filter by type\n\nReturns:\n    List of alert-log links for the run",
            "is_async": false,
            "line": 730
          },
          {
            "name": "get_logs_for_alert",
            "signature": "(alert_id: str) -> List[AlertLogLink]",
            "docstring": "Quick helper to get log links for an alert.\n\nArgs:\n    alert_id: Alert identifier\n\nReturns:\n    List of alert-log links for the alert",
            "is_async": false,
            "line": 748
          }
        ],
        "classes": [
          {
            "name": "AlertLogLinkType",
            "docstring": "Type of alert-to-log link.",
            "methods": [],
            "line": 51
          },
          {
            "name": "AlertLogLinkStatus",
            "docstring": "Status of an alert-log link.",
            "methods": [],
            "line": 63
          },
          {
            "name": "AlertLogLinkError",
            "docstring": "Raised when alert-log linking operation fails.\n\nThis error indicates that a link could not be created\nor queried due to validation or consistency issues.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 72
          },
          {
            "name": "AlertLogLink",
            "docstring": "Represents a link between an alert and log records.\n\nThis is the core model for GAP-019 alert-log linking.\nEach link connects one alert to one or more log entries\n(trace steps, execution logs, etc.).",
            "methods": [
              "is_valid",
              "record_access",
              "expire",
              "archive",
              "to_dict"
            ],
            "line": 107
          },
          {
            "name": "AlertLogLinkResponse",
            "docstring": "Response from link operations.",
            "methods": [
              "to_dict"
            ],
            "line": 200
          },
          {
            "name": "AlertLogLinker",
            "docstring": "Service for managing alert-to-log links.\n\nGAP-019: Provides explicit linking between alerts and log records\nfor the LLM Runs domain.\n\nUsage:\n    linker = AlertLogLinker()\n\n    # Create a link when alert is generated\n    link = linker.create_link(\n        alert_id=\"alert-123\",\n        run_id=\"run-456\",\n        tenant_id=\"tenant-1\",\n        link_type=AlertLogLinkType.THRESHOLD_BREACH,\n        step_indices=[10, 11, 12],\n    )\n\n    # Query logs for an alert\n    links = linker.get_links_for_alert(\"alert-123\")\n\n    # Query alerts for a run\n    links = linker.get_links_for_run(\"run-456\")",
            "methods": [
              "__init__",
              "_generate_link_id",
              "create_link",
              "get_link",
              "get_links_for_alert",
              "get_links_for_run",
              "get_links_for_tenant",
              "get_links_by_step",
              "update_link",
              "expire_link",
              "archive_link",
              "delete_link",
              "cleanup_expired",
              "get_statistics"
            ],
            "line": 218
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "alert_worker.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/alert_worker.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 430,
        "module_docstring": "CostSim Alert Worker - Reliable Alert Delivery (L4 Engine)\n\nBackground worker for reliable alert delivery.\n\nPhase-2.5A Extraction:\n- PERSISTENCE: Delegated to AlertDriver (L6)\n- DELIVERY: Delegated to AlertDeliveryAdapter (L3)\n- DECISIONS: Retained in this engine (L4)\n\nThis worker processes the alert queue, sending alerts to Alertmanager\nwith exponential backoff retry logic. It ensures alerts are delivered\neven if Alertmanager is temporarily unavailable.\n\nFeatures:\n- Exponential backoff (1s, 2s, 4s, 8s, ... up to max_backoff)\n- Maximum retry attempts (configurable, default 10)\n- Dead letter handling (marks alerts as failed after max attempts)\n- Leader election (only one worker processes at a time)\n- Batch processing for efficiency\n\nUsage:\n    from app.costsim.alert_worker import AlertWorker, run_alert_worker\n\n    # Run continuously\n    await run_alert_worker()\n\n    # Or run once (e.g., from cron)\n    worker = AlertWorker()\n    processed = await worker.process_batch(batch_size=10)",
        "functions": [
          {
            "name": "enqueue_alert",
            "signature": "(payload: List[Dict[str, Any]], alert_type: str, circuit_breaker_name: Optional[str] = None, incident_id: Optional[str] = None, session: Optional[AsyncSession] = None) -> int",
            "docstring": "Enqueue an alert for delivery.\n\nPhase-2.5A: Delegated to driver (L6).\n\nArgs:\n    payload: Alertmanager payload\n    alert_type: Type of alert (disable, enable, canary_fail)\n    circuit_breaker_name: Associated circuit breaker\n    incident_id: Associated incident\n    session: Optional async session\n\nReturns:\n    ID of created queue entry",
            "is_async": true,
            "line": 294
          },
          {
            "name": "retry_failed_alerts",
            "signature": "(max_retries: int = 3) -> int",
            "docstring": "Retry failed alerts (reset to pending).\n\nPhase-2.5A: Delegated to driver (L6).\n\nArgs:\n    max_retries: Maximum additional retries to allow\n\nReturns:\n    Number of alerts reset",
            "is_async": true,
            "line": 350
          },
          {
            "name": "purge_old_alerts",
            "signature": "(days: int = 30, statuses: Optional[List[str]] = None) -> int",
            "docstring": "Purge old alerts from queue.\n\nPhase-2.5A: Delegated to driver (L6).\n\nArgs:\n    days: Delete alerts older than this many days\n    statuses: Only delete these statuses (default: sent, failed)\n\nReturns:\n    Number of alerts deleted",
            "is_async": true,
            "line": 381
          },
          {
            "name": "run_alert_worker",
            "signature": "(use_leader_election: bool = True, process_interval: float = 5.0) -> None",
            "docstring": "Run alert worker continuously.\n\nConvenience function for running the worker as a background task.\n\nArgs:\n    use_leader_election: Only process if we hold the leader lock\n    process_interval: Seconds between processing batches",
            "is_async": true,
            "line": 416
          }
        ],
        "classes": [
          {
            "name": "AlertWorker",
            "docstring": "Background worker for processing alert queue.\n\nPhase-2.5A Extraction:\n- PERSISTENCE: Delegated to AlertDriver (L6)\n- DELIVERY: Delegated to AlertDeliveryAdapter (L3)\n- DECISIONS: Retained here (L4) - retry eligibility, backoff, status transitions",
            "methods": [
              "__init__",
              "close",
              "process_batch",
              "run_continuous",
              "get_queue_stats"
            ],
            "line": 104
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 85
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 86
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 87
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 88
          },
          {
            "module": "app.costsim.config",
            "names": [
              "get_config"
            ],
            "is_relative": false,
            "line": 93
          },
          {
            "module": "app.costsim.leader",
            "names": [
              "LOCK_ALERT_WORKER",
              "leader_election"
            ],
            "is_relative": false,
            "line": 94
          },
          {
            "module": "app.costsim.metrics",
            "names": [
              "get_metrics"
            ],
            "is_relative": false,
            "line": 98
          },
          {
            "module": "app.db_async",
            "names": [
              "AsyncSessionLocal",
              "async_session_context"
            ],
            "is_relative": false,
            "line": 99
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 82
          },
          {
            "name": "RETRY_POLICY",
            "line": 83
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "alerts_facade.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/alerts_facade.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 679,
        "module_docstring": "Alerts Facade (L4 Domain Logic)\n\nThis facade provides the external interface for alert operations.\nAll alert APIs MUST use this facade instead of directly importing\ninternal alert modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes alert configuration and routing\n- Provides unified access to alert history\n- Single point for audit emission\n\nL2 API Routes (GAP-110, GAP-111, GAP-124):\n- POST /api/v1/alerts/rules (create alert rule)\n- GET /api/v1/alerts/rules (list alert rules)\n- GET /api/v1/alerts/rules/{id} (get alert rule)\n- PUT /api/v1/alerts/rules/{id} (update alert rule)\n- DELETE /api/v1/alerts/rules/{id} (delete alert rule)\n- GET /api/v1/alerts/history (alert history)\n- GET /api/v1/alerts/routes (alert routes)\n- POST /api/v1/alerts/routes (create route)\n\nUsage:\n    from app.services.alerts.facade import get_alerts_facade\n\n    facade = get_alerts_facade()\n\n    # Create alert rule\n    rule = await facade.create_rule(\n        tenant_id=\"...\",\n        name=\"High Cost Alert\",\n        condition={\"metric\": \"cost\", \"threshold\": 1000},\n    )",
        "functions": [
          {
            "name": "get_alerts_facade",
            "signature": "() -> AlertsFacade",
            "docstring": "Get the alerts facade instance.\n\nThis is the recommended way to access alert operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    AlertsFacade instance",
            "is_async": false,
            "line": 666
          }
        ],
        "classes": [
          {
            "name": "AlertSeverity",
            "docstring": "Alert severity levels.",
            "methods": [],
            "line": 67
          },
          {
            "name": "AlertStatus",
            "docstring": "Alert status.",
            "methods": [],
            "line": 75
          },
          {
            "name": "AlertRule",
            "docstring": "Alert rule definition.",
            "methods": [
              "to_dict"
            ],
            "line": 83
          },
          {
            "name": "AlertEvent",
            "docstring": "Alert event (history entry).",
            "methods": [
              "to_dict"
            ],
            "line": 115
          },
          {
            "name": "AlertRoute",
            "docstring": "Alert routing rule.",
            "methods": [
              "to_dict"
            ],
            "line": 151
          },
          {
            "name": "AlertsFacade",
            "docstring": "Facade for alert operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nalert services.\n\nLayer: L4 (Domain Logic)\nCallers: alerts.py (L2), aos_sdk, Worker",
            "methods": [
              "__init__",
              "create_rule",
              "list_rules",
              "get_rule",
              "update_rule",
              "delete_rule",
              "list_history",
              "get_event",
              "acknowledge_event",
              "resolve_event",
              "trigger_alert",
              "create_route",
              "list_routes",
              "get_route",
              "delete_route"
            ],
            "line": 176
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 62
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "audit_durability.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/audit_durability.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 325,
        "module_docstring": "Module: durability\nPurpose: Enforce RAC durability before acknowledgment.\n\nThe rac_durability_enforce flag in GovernanceConfig controls whether\ndurability is strictly enforced before acknowledging audit operations.\n\nWhen enabled:\n    - Acks must be persisted to durable storage before being accepted\n    - Expectations must be durably stored before run starts\n    - In-memory-only mode raises RACDurabilityEnforcementError\n\nThis ensures audit contracts survive crashes and can be reconciled\neven if workers fail.\n\nExports:\n    - RACDurabilityEnforcementError: Raised when durability not satisfied\n    - RACDurabilityChecker: Checks durability constraints\n    - check_rac_durability: Quick helper function",
        "functions": [
          {
            "name": "check_rac_durability",
            "signature": "(enforcement_enabled: bool = True, durability_mode: str = 'MEMORY') -> DurabilityCheckResponse",
            "docstring": "Quick helper to check RAC durability.\n\nArgs:\n    enforcement_enabled: Whether rac_durability_enforce is True\n    durability_mode: Current durability mode\n\nReturns:\n    DurabilityCheckResponse with status and metadata",
            "is_async": false,
            "line": 284
          },
          {
            "name": "ensure_rac_durability",
            "signature": "(operation: str, enforcement_enabled: bool = True, durability_mode: str = 'MEMORY') -> None",
            "docstring": "Quick helper to ensure RAC durability or raise error.\n\nArgs:\n    operation: Name of the operation being performed\n    enforcement_enabled: Whether rac_durability_enforce is True\n    durability_mode: Current durability mode\n\nRaises:\n    RACDurabilityEnforcementError: If enforcement enabled and not durable",
            "is_async": false,
            "line": 305
          }
        ],
        "classes": [
          {
            "name": "DurabilityCheckResult",
            "docstring": "Result of a durability check.",
            "methods": [],
            "line": 44
          },
          {
            "name": "RACDurabilityEnforcementError",
            "docstring": "Raised when RAC durability enforcement fails.\n\nThis error indicates that an operation requiring durable storage\nwas attempted without durable backing store available.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 53
          },
          {
            "name": "DurabilityCheckResponse",
            "docstring": "Response from a durability check.",
            "methods": [
              "to_dict"
            ],
            "line": 85
          },
          {
            "name": "RACDurabilityChecker",
            "docstring": "Checks and enforces RAC durability constraints.\n\nGAP-050: Add durability checks to RAC.\n\nThe checker verifies that audit data is durably stored before\nallowing acknowledgment operations when enforcement is enabled.\n\nUsage:\n    checker = RACDurabilityChecker(\n        enforcement_enabled=True,\n        durability_mode=\"REDIS\",\n    )\n\n    # Before adding an ack\n    checker.ensure_durable(\"add_ack\")\n\n    # Or check without raising\n    response = checker.check()\n    if not response.is_durable and response.enforcement_enabled:\n        handle_durability_issue()",
            "methods": [
              "__init__",
              "from_governance_config",
              "from_audit_store",
              "is_durable",
              "enforcement_enabled",
              "check",
              "ensure_durable",
              "should_allow_operation"
            ],
            "line": 105
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "audit_store.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/audit_store.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 448,
        "module_docstring": "Audit Store\n\nProvides storage for audit expectations and acknowledgments.\n\nStorage Strategy:\n- MEMORY: In-memory dictionary (dev/test only - NOT crash-safe)\n- REDIS: Redis-backed store (staging/prod - crash-safe, cross-process)\n\nDurability Modes:\n- AOS_MODE=local \u2192 MEMORY allowed\n- AOS_MODE=test/prod \u2192 REDIS required (startup fails without it)\n\nThe store is designed to be:\n1. Fast for writes (acks happen in hot path)\n2. Durable in production (Redis backing mandatory)\n3. TTL-managed (old data expires automatically)\n\nRedis keys:\n- rac:expectations:{run_id} -> JSON list of expectations\n- rac:acks:{run_id} -> JSON list of acks\n- TTL: 1 hour (runs should complete within this time)",
        "functions": [
          {
            "name": "_determine_durability_mode",
            "signature": "(redis_client) -> StoreDurabilityMode",
            "docstring": "Determine the durability mode based on environment and Redis availability.\n\nRules:\n- AOS_MODE=local \u2192 MEMORY allowed (dev)\n- AOS_MODE=test/prod + RAC_ENABLED + no Redis \u2192 ERROR\n- AOS_MODE=test/prod + RAC_ENABLED + Redis \u2192 REDIS",
            "is_async": false,
            "line": 77
          },
          {
            "name": "get_audit_store",
            "signature": "(redis_client = None) -> AuditStore",
            "docstring": "Get the audit store singleton.\n\nArgs:\n    redis_client: Optional Redis client (only used on first call)\n\nReturns:\n    AuditStore instance",
            "is_async": false,
            "line": 435
          }
        ],
        "classes": [
          {
            "name": "StoreDurabilityMode",
            "docstring": "Durability mode for the audit store.",
            "methods": [],
            "line": 64
          },
          {
            "name": "RACDurabilityError",
            "docstring": "Raised when RAC requires durable storage but none is available.",
            "methods": [],
            "line": 71
          },
          {
            "name": "AuditStore",
            "docstring": "Storage for audit expectations and acknowledgments.\n\nThread-safe store with configurable durability:\n- MEMORY mode: In-memory only (dev/test, NOT crash-safe)\n- REDIS mode: Redis-backed (staging/prod, crash-safe)\n\nUsage:\n    store = get_audit_store()\n\n    # Add expectations at run start\n    store.add_expectations(run_id, expectations)\n\n    # Add acks as domains complete\n    store.add_ack(run_id, ack)\n\n    # Get for reconciliation\n    expectations = store.get_expectations(run_id)\n    acks = store.get_acks(run_id)\n\nDurability:\n    In production (AOS_MODE=test/prod), Redis is REQUIRED when RAC_ENABLED=true.\n    This ensures expectations/acks survive worker crashes.",
            "methods": [
              "__init__",
              "durability_mode",
              "is_durable",
              "add_expectations",
              "get_expectations",
              "update_expectation_status",
              "add_ack",
              "get_acks",
              "clear_run",
              "get_pending_run_ids",
              "_sync_expectations_to_redis",
              "_sync_acks_to_redis",
              "load_from_redis"
            ],
            "line": 103
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "threading",
            "names": [
              "Lock"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.general.L5_schemas.rac_models",
            "names": [
              "AuditExpectation",
              "AuditStatus",
              "DomainAck"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [
          {
            "name": "REDIS_TTL_SECONDS",
            "line": 56
          },
          {
            "name": "AUDIT_REDIS_ENABLED",
            "line": 59
          },
          {
            "name": "RAC_ENABLED",
            "line": 60
          },
          {
            "name": "AOS_MODE",
            "line": 61
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "canonical_json.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/canonical_json.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 294,
        "module_docstring": "Canonical JSON serialization for AOS.\n\nEnsures deterministic JSON output for:\n- Replay testing\n- Content hashing\n- Golden file comparison\n\nSee: app/specs/canonical_json.md for full specification.",
        "functions": [
          {
            "name": "canonical_json",
            "signature": "(obj: Any, exclude_fields: Optional[Set[str]] = None) -> str",
            "docstring": "Serialize object to canonical JSON format.\n\nRules:\n- Keys sorted alphabetically\n- No whitespace\n- UTF-8 encoding\n- Minimal escaping\n\nArgs:\n    obj: Object to serialize\n    exclude_fields: Optional set of field names to exclude (for variance fields)\n\nReturns:\n    Canonical JSON string",
            "is_async": false,
            "line": 42
          },
          {
            "name": "canonical_json_bytes",
            "signature": "(obj: Any, exclude_fields: Optional[Set[str]] = None) -> bytes",
            "docstring": "Serialize object to canonical JSON bytes (UTF-8).\n\nArgs:\n    obj: Object to serialize\n    exclude_fields: Optional set of field names to exclude\n\nReturns:\n    UTF-8 encoded canonical JSON bytes",
            "is_async": false,
            "line": 65
          },
          {
            "name": "content_hash",
            "signature": "(obj: Any, exclude_fields: Optional[Set[str]] = None, length: int = 16) -> str",
            "docstring": "Compute deterministic content hash.\n\nArgs:\n    obj: Object to hash\n    exclude_fields: Fields to exclude from hash (e.g., timestamps)\n    length: Length of hash to return (default 16 hex chars)\n\nReturns:\n    Hex string of SHA-256 hash (truncated to length)",
            "is_async": false,
            "line": 79
          },
          {
            "name": "content_hash_full",
            "signature": "(obj: Any, exclude_fields: Optional[Set[str]] = None) -> str",
            "docstring": "Compute full SHA-256 content hash.\n\nArgs:\n    obj: Object to hash\n    exclude_fields: Fields to exclude from hash\n\nReturns:\n    Full 64-character hex hash",
            "is_async": false,
            "line": 96
          },
          {
            "name": "deterministic_hash",
            "signature": "(obj: Any, length: int = 16) -> str",
            "docstring": "Compute hash excluding allowed variance fields.\n\nThis is the standard hashing function for replay comparisons.\n\nArgs:\n    obj: Object to hash\n    length: Length of hash to return\n\nReturns:\n    Hex hash string",
            "is_async": false,
            "line": 130
          },
          {
            "name": "_json_serializer",
            "signature": "(obj: Any) -> Any",
            "docstring": "Custom JSON serializer for non-standard types.\n\nHandles:\n- datetime/date \u2192 ISO format string\n- UUID \u2192 string\n- Enum \u2192 value\n- bytes \u2192 base64 string (if needed)\n- Objects with to_dict() method\n- Objects with __dict__ attribute",
            "is_async": false,
            "line": 146
          },
          {
            "name": "_filter_fields",
            "signature": "(obj: Any, exclude: Set[str]) -> Any",
            "docstring": "Recursively filter out excluded fields from an object.\n\nArgs:\n    obj: Object to filter\n    exclude: Set of field names to exclude\n\nReturns:\n    Filtered object",
            "is_async": false,
            "line": 178
          },
          {
            "name": "is_canonical",
            "signature": "(json_str: str) -> bool",
            "docstring": "Check if a JSON string is in canonical format.\n\nArgs:\n    json_str: JSON string to check\n\nReturns:\n    True if canonical, False otherwise",
            "is_async": false,
            "line": 196
          },
          {
            "name": "canonicalize_file",
            "signature": "(filepath: str) -> None",
            "docstring": "Rewrite a JSON file in canonical format.\n\nArgs:\n    filepath: Path to JSON file\n\nRaises:\n    ValueError: If file is not valid JSON",
            "is_async": false,
            "line": 214
          },
          {
            "name": "assert_canonical",
            "signature": "(filepath: str) -> None",
            "docstring": "Assert that a JSON file is in canonical format.\n\nArgs:\n    filepath: Path to JSON file\n\nRaises:\n    AssertionError: If file is not canonical",
            "is_async": false,
            "line": 233
          },
          {
            "name": "compare_deterministic",
            "signature": "(actual: Dict[str, Any], expected: Dict[str, Any], deterministic_fields: Optional[List[str]] = None) -> Dict[str, Any]",
            "docstring": "Compare two outputs, checking only deterministic fields.\n\nArgs:\n    actual: Actual output\n    expected: Expected output\n    deterministic_fields: List of fields that must match exactly\n\nReturns:\n    Dict with 'match' (bool) and 'differences' (list)",
            "is_async": false,
            "line": 253
          },
          {
            "name": "_get_nested",
            "signature": "(obj: Dict[str, Any], path: str) -> Any",
            "docstring": "Get nested value using dot notation.",
            "is_async": false,
            "line": 285
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [
          {
            "name": "ALLOWED_VARIANCE_FIELDS",
            "line": 112
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "compliance_facade.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/compliance_facade.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 518,
        "module_docstring": "Compliance Facade (L4 Domain Logic)\n\nThis facade provides the external interface for compliance verification operations.\nAll compliance APIs MUST use this facade instead of directly importing\ninternal compliance modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes compliance verification logic\n- Provides unified access to compliance checks and reports\n- Single point for audit emission\n\nL2 API Routes (GAP-103):\n- POST /api/v1/compliance/verify (run compliance verification)\n- GET /api/v1/compliance/reports (list compliance reports)\n- GET /api/v1/compliance/reports/{id} (get compliance report)\n- GET /api/v1/compliance/rules (list compliance rules)\n- GET /api/v1/compliance/status (compliance status)\n\nUsage:\n    from app.services.compliance.facade import get_compliance_facade\n\n    facade = get_compliance_facade()\n\n    # Run compliance verification\n    result = await facade.verify_compliance(tenant_id=\"...\", scope=\"all\")\n\n    # List compliance reports\n    reports = await facade.list_reports(tenant_id=\"...\")",
        "functions": [
          {
            "name": "get_compliance_facade",
            "signature": "() -> ComplianceFacade",
            "docstring": "Get the compliance facade instance.\n\nThis is the recommended way to access compliance operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    ComplianceFacade instance",
            "is_async": false,
            "line": 505
          }
        ],
        "classes": [
          {
            "name": "ComplianceScope",
            "docstring": "Compliance verification scope.",
            "methods": [],
            "line": 63
          },
          {
            "name": "ComplianceStatus",
            "docstring": "Compliance status.",
            "methods": [],
            "line": 72
          },
          {
            "name": "ComplianceRule",
            "docstring": "Compliance rule definition.",
            "methods": [
              "to_dict"
            ],
            "line": 81
          },
          {
            "name": "ComplianceViolation",
            "docstring": "A compliance violation.",
            "methods": [
              "to_dict"
            ],
            "line": 103
          },
          {
            "name": "ComplianceReport",
            "docstring": "Compliance verification report.",
            "methods": [
              "to_dict"
            ],
            "line": 123
          },
          {
            "name": "ComplianceStatusInfo",
            "docstring": "Overall compliance status.",
            "methods": [
              "to_dict"
            ],
            "line": 155
          },
          {
            "name": "ComplianceFacade",
            "docstring": "Facade for compliance verification operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ncompliance services.\n\nLayer: L4 (Domain Logic)\nCallers: compliance.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "_init_default_rules",
              "verify_compliance",
              "_check_rule_compliance",
              "list_reports",
              "get_report",
              "list_rules",
              "get_rule",
              "get_compliance_status"
            ],
            "line": 174
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "concurrent_runs.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/concurrent_runs.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 247,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_concurrent_limiter",
            "signature": "() -> ConcurrentRunsLimiter",
            "docstring": "Get the singleton concurrent runs limiter.",
            "is_async": false,
            "line": 224
          },
          {
            "name": "acquire_slot",
            "signature": "(key: str, max_slots: int)",
            "docstring": "Convenience context manager for acquiring a slot.\n\nArgs:\n    key: Unique key (e.g., \"agent:{agent_id}\")\n    max_slots: Maximum concurrent runs\n\nYields:\n    Token string\n\nRaises:\n    RuntimeError: If limit reached",
            "is_async": false,
            "line": 233
          }
        ],
        "classes": [
          {
            "name": "ConcurrentRunsLimiter",
            "docstring": "Limits concurrent runs using Redis-based semaphore.\n\nUses Redis sets to track active runs per key.\nAutomatically expires slots after timeout.",
            "methods": [
              "__init__",
              "_get_client",
              "acquire",
              "release",
              "get_count",
              "slot"
            ],
            "line": 36
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "contextlib",
            "names": [
              "contextmanager"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 28
          }
        ],
        "constants": [
          {
            "name": "REDIS_URL",
            "line": 32
          },
          {
            "name": "DEFAULT_SLOT_TIMEOUT",
            "line": 33
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "constraint_checker.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/constraint_checker.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 309,
        "module_docstring": "Module: constraint_checker\nPurpose: Enforce inspection constraints from MonitorConfig.\n\nInspection constraints are \"negative capabilities\" - they define what\na policy is NOT allowed to inspect or capture. Before any logging\noperation, the runner/worker must check these constraints.\n\nConstraint Fields (from MonitorConfig):\n    - allow_prompt_logging: Can prompts be logged?\n    - allow_response_logging: Can responses be logged?\n    - allow_pii_capture: Can PII be captured?\n    - allow_secret_access: Can secrets be accessed?\n\nExports:\n    - InspectionOperation: Enum of operations requiring checks\n    - InspectionConstraintViolation: Violation record\n    - InspectionConstraintChecker: Main enforcement class\n    - check_inspection_allowed: Quick helper function\n    - get_constraint_violations: Get all violations",
        "functions": [
          {
            "name": "check_inspection_allowed",
            "signature": "(operation: InspectionOperation, allow_prompt_logging: bool = False, allow_response_logging: bool = False, allow_pii_capture: bool = False, allow_secret_access: bool = False) -> bool",
            "docstring": "Quick helper to check if an operation is allowed.\n\nArgs:\n    operation: The operation to check\n    allow_prompt_logging: Whether prompts can be logged\n    allow_response_logging: Whether responses can be logged\n    allow_pii_capture: Whether PII can be captured\n    allow_secret_access: Whether secrets can be accessed\n\nReturns:\n    True if operation is allowed, False otherwise",
            "is_async": false,
            "line": 253
          },
          {
            "name": "get_constraint_violations",
            "signature": "(operations: list[InspectionOperation], allow_prompt_logging: bool = False, allow_response_logging: bool = False, allow_pii_capture: bool = False, allow_secret_access: bool = False) -> list[dict[str, Any]]",
            "docstring": "Get all constraint violations for a set of operations.\n\nArgs:\n    operations: List of operations to check\n    allow_prompt_logging: Whether prompts can be logged\n    allow_response_logging: Whether responses can be logged\n    allow_pii_capture: Whether PII can be captured\n    allow_secret_access: Whether secrets can be accessed\n\nReturns:\n    List of violation dicts (empty if all allowed)",
            "is_async": false,
            "line": 282
          }
        ],
        "classes": [
          {
            "name": "InspectionOperation",
            "docstring": "Operations that require inspection constraint checks.",
            "methods": [],
            "line": 46
          },
          {
            "name": "InspectionConstraintViolation",
            "docstring": "Record of an inspection constraint violation.\n\nCreated when an operation is attempted that violates\nthe MonitorConfig inspection constraints.",
            "methods": [
              "to_dict"
            ],
            "line": 65
          },
          {
            "name": "InspectionConstraintChecker",
            "docstring": "Enforces inspection constraints from MonitorConfig.\n\nThis class checks whether logging and data capture operations\nare allowed based on the MonitorConfig's inspection constraint\nsettings (negative capabilities).\n\nGAP-033: Wire MonitorConfig flags to runner.\n\nUsage:\n    checker = InspectionConstraintChecker(monitor_config)\n    if checker.is_allowed(InspectionOperation.LOG_PROMPT):\n        # Log the prompt\n    else:\n        # Skip logging, constraint forbids it",
            "methods": [
              "__init__",
              "from_monitor_config",
              "from_snapshot",
              "is_allowed",
              "check",
              "check_all",
              "get_allowed_operations",
              "get_denied_operations",
              "to_dict"
            ],
            "line": 88
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "control_registry.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/control_registry.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 455,
        "module_docstring": "Module: control_registry\nPurpose: Registry of SOC2 Trust Service Criteria controls.\n\nSOC2 Trust Service Categories:\n    - CC (Common Criteria): Security-related controls\n    - A (Availability): System availability controls\n    - PI (Processing Integrity): Processing accuracy controls\n    - C (Confidentiality): Data confidentiality controls\n    - P (Privacy): Privacy-related controls\n\nKey Controls for AI Agent Governance:\n    - CC7.x: System Operations (Incident Response)\n    - CC6.x: Logical and Physical Access Controls\n    - CC8.x: Change Management\n    - PI1.x: Processing Integrity\n    - A1.x: Availability\n\nExports:\n    - SOC2Category: Enum of trust service categories\n    - SOC2ComplianceStatus: Enum of compliance states\n    - SOC2Control: Control definition\n    - SOC2ControlMapping: Mapping with evidence\n    - SOC2ControlRegistry: Registry singleton",
        "functions": [
          {
            "name": "get_control_registry",
            "signature": "() -> SOC2ControlRegistry",
            "docstring": "Get or create the singleton control registry.",
            "is_async": false,
            "line": 450
          }
        ],
        "classes": [
          {
            "name": "SOC2Category",
            "docstring": "SOC2 Trust Service Categories.",
            "methods": [],
            "line": 52
          },
          {
            "name": "SOC2ComplianceStatus",
            "docstring": "Compliance status for a control mapping.",
            "methods": [],
            "line": 62
          },
          {
            "name": "SOC2Control",
            "docstring": "SOC2 Trust Service Criteria control definition.\n\nRepresents a single SOC2 control with its ID, name, description,\nand the category it belongs to.",
            "methods": [
              "__post_init__"
            ],
            "line": 73
          },
          {
            "name": "SOC2ControlMapping",
            "docstring": "Mapping of incident/evidence to a SOC2 control.\n\nContains the control, the evidence provided, and compliance status.",
            "methods": [
              "to_dict"
            ],
            "line": 103
          },
          {
            "name": "SOC2ControlRegistry",
            "docstring": "Registry of SOC2 Trust Service Criteria controls.\n\nProvides lookup and management of SOC2 controls relevant to\nAI agent governance and incident response.\n\nGAP-025: Complete SOC2 control objective mapping.",
            "methods": [
              "__init__",
              "_register_all_controls",
              "_register_incident_response_controls",
              "_register_access_controls",
              "_register_change_management_controls",
              "_register_processing_integrity_controls",
              "_register_availability_controls",
              "_register_communication_controls",
              "_register_risk_controls",
              "get_control",
              "get_controls_by_category",
              "get_controls_by_prefix",
              "get_all_controls",
              "get_incident_response_controls"
            ],
            "line": 136
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_credential_service.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/cus_credential_service.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 477,
        "module_docstring": "Customer Credential Service\n\nPURPOSE:\n    Secure handling of customer LLM API credentials.\n    Encrypts credentials at rest, provides vault-ready integration.\n\nSECURITY PRINCIPLES:\n    1. NO PLAINTEXT PERSISTENCE: All stored credentials are encrypted\n    2. ROTATION-READY: Credentials can be rotated without downtime\n    3. AUDIT TRAIL: All credential access is logged\n    4. MINIMAL EXPOSURE: Decryption only at point of use\n\nCREDENTIAL REFERENCE FORMAT:\n    - vault://<path>         - HashiCorp Vault reference\n    - encrypted://<id>       - Locally encrypted (AES-256-GCM)\n    - env://<var_name>       - Environment variable (dev only)\n\nENCRYPTION:\n    - Algorithm: AES-256-GCM\n    - Key derivation: PBKDF2 with per-tenant salt\n    - In production: KEK from external key management service",
        "functions": [],
        "classes": [
          {
            "name": "CusCredentialService",
            "docstring": "Service for managing customer LLM credentials.\n\nPhase 4: Secure credential storage and retrieval.\nProduction deployments should use external vault integration.",
            "methods": [
              "__init__",
              "_derive_dev_key",
              "_derive_tenant_key",
              "encrypt_credential",
              "decrypt_credential",
              "resolve_credential",
              "_resolve_vault_credential",
              "_resolve_env_credential",
              "rotate_credential",
              "validate_credential_format",
              "generate_master_key",
              "mask_credential"
            ],
            "line": 55
          }
        ],
        "imports": [
          {
            "module": "base64",
            "names": [
              "base64"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "secrets",
            "names": [
              "secrets"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "cryptography.hazmat.primitives.ciphers.aead",
            "names": [
              "AESGCM"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_health_shim.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/cus_health_shim.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 66,
        "module_docstring": "DEPRECATED: Customer Health Service\n\nThis module has been moved to drivers/cus_health_driver.py.\n\nThe service was reclassified from L4 Engine to L6 Driver because it contains\ndirect database operations (sqlmodel Session imports).\n\nFor backward compatibility, this module re-exports the class from its new location.\nPlease update your imports to use the new location directly.",
        "functions": [],
        "classes": [],
        "imports": [
          {
            "module": "warnings",
            "names": [
              "warnings"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.hoc.cus.general.L6_drivers.cus_health_driver",
            "names": [
              "CusHealthDriver",
              "CusHealthService"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": [
          "CusHealthService",
          "CusHealthDriver"
        ]
      },
      {
        "file_name": "dag_sorter.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/dag_sorter.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 318,
        "module_docstring": "DAG-based execution ordering for PLang v2.0.\n\nFeatures:\n- Topological sort for dependency-respecting execution\n- Category-aware ordering (SAFETY first)\n- Priority-based tie breaking\n- Deterministic execution plan generation",
        "functions": [],
        "classes": [
          {
            "name": "ExecutionPhase",
            "docstring": "Execution phases in deterministic order.",
            "methods": [],
            "line": 40
          },
          {
            "name": "ExecutionNode",
            "docstring": "A node in the execution DAG.\n\nRepresents a policy/rule to execute with its dependencies\nand governance metadata.",
            "methods": [
              "__hash__",
              "__eq__"
            ],
            "line": 51
          },
          {
            "name": "ExecutionDAG",
            "docstring": "Directed Acyclic Graph of policy execution.\n\nProvides deterministic ordering for policy evaluation.",
            "methods": [
              "add_node",
              "add_edge",
              "get_roots",
              "get_leaves"
            ],
            "line": 76
          },
          {
            "name": "ExecutionPlan",
            "docstring": "A deterministic execution plan.\n\nContains ordered list of policies to execute with\nparallel execution opportunities.",
            "methods": [
              "to_dict"
            ],
            "line": 108
          },
          {
            "name": "DAGSorter",
            "docstring": "Sorts policies into deterministic execution order.\n\nUses topological sort with governance-aware ordering:\n1. SAFETY policies always execute first\n2. Higher priority policies execute before lower\n3. Dependencies are respected\n4. Parallelizable policies grouped into stages",
            "methods": [
              "__init__",
              "build_dag",
              "_get_phase",
              "_add_category_dependencies",
              "_add_routing_dependencies",
              "sort",
              "get_execution_order",
              "visualize"
            ],
            "line": 129
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set",
              "Tuple"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRFunction",
              "IRGovernance",
              "IRModule"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "db_helpers.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/db_helpers.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 437,
        "module_docstring": "Database helper functions for SQLModel row extraction.\n\nPIN-099: SQLModel Row Extraction Patterns\n\nThis module provides helper functions to safely extract values from\nSQLModel/SQLAlchemy query results, avoiding common anti-patterns that\ncause runtime errors.\n\nCommon Issues Prevented:\n1. Row objects are truthy even when containing 0/None\n2. Row objects don't support direct comparison operators\n3. Row objects from .all() are not Python tuples\n\nUsage:\n    from app.utils.db_helpers import scalar_or_default, extract_model\n\n    # For scalar queries (COUNT, SUM, AVG, etc.)\n    row = session.exec(select(func.count(Model.id))).first()\n    count = scalar_or_default(row, default=0)\n\n    # For model queries with potential Row wrapping\n    results = session.exec(stmt).all()\n    for row in results:\n        model = extract_model(row, 'id')",
        "functions": [
          {
            "name": "scalar_or_default",
            "signature": "(row: Optional[Any], default: Any = 0) -> Any",
            "docstring": "Extract scalar value from Row or return default.\n\nSQLModel's session.exec(stmt).first() returns a Row object for scalar\nqueries (like func.count, func.sum). This function safely extracts\nthe scalar value.\n\nArgs:\n    row: The Row object from .first(), or None if no results\n    default: Value to return if row is None or contains None\n\nReturns:\n    The scalar value from row[0], or default if unavailable\n\nExample:\n    stmt = select(func.count(Incident.id)).where(...)\n    row = session.exec(stmt).first()\n    count = scalar_or_default(row, 0)  # Returns int, not Row",
            "is_async": false,
            "line": 53
          },
          {
            "name": "scalar_or_none",
            "signature": "(row: Optional[Any]) -> Optional[Any]",
            "docstring": "Extract scalar value from Row, returning None if unavailable.\n\nSimilar to scalar_or_default but returns None instead of a default.\n\nArgs:\n    row: The Row object from .first(), or None\n\nReturns:\n    The scalar value from row[0], or None\n\nExample:\n    stmt = select(func.max(Run.ended_at)).where(...)\n    row = session.exec(stmt).first()\n    last_time = scalar_or_none(row)  # Returns datetime or None",
            "is_async": false,
            "line": 82
          },
          {
            "name": "extract_model",
            "signature": "(row: Any, model_attr: str = 'id') -> Any",
            "docstring": "Extract model instance from Row or return as-is.\n\nWhen using session.exec(stmt).all(), results may be:\n1. Model instances directly (single model select)\n2. Row objects (joins, expressions, order_by with expressions)\n\nThis function detects which case and extracts appropriately.\n\nArgs:\n    row: A result from .all() iteration\n    model_attr: An attribute that exists on the model (for detection)\n\nReturns:\n    The model instance, extracted from Row if necessary\n\nExample:\n    for row in session.exec(select(Incident).order_by(...)).all():\n        incident = extract_model(row, 'tenant_id')\n        print(incident.title)",
            "is_async": false,
            "line": 106
          },
          {
            "name": "extract_models",
            "signature": "(results: List[Any], model_attr: str = 'id') -> List[Any]",
            "docstring": "Extract model instances from a list of results.\n\nConvenience wrapper around extract_model for processing .all() results.\n\nArgs:\n    results: List from session.exec(stmt).all()\n    model_attr: An attribute that exists on the model\n\nReturns:\n    List of extracted model instances\n\nExample:\n    results = session.exec(select(Tenant).order_by(...)).all()\n    tenants = extract_models(results, 'tenant_id')",
            "is_async": false,
            "line": 142
          },
          {
            "name": "count_or_zero",
            "signature": "(row: Optional[Any]) -> int",
            "docstring": "Extract count value, guaranteed to return int.",
            "is_async": false,
            "line": 162
          },
          {
            "name": "sum_or_zero",
            "signature": "(row: Optional[Any]) -> float",
            "docstring": "Extract sum value, guaranteed to return numeric.",
            "is_async": false,
            "line": 168
          },
          {
            "name": "query_one",
            "signature": "(session: Any, statement: Any, model_class: Optional[type] = None) -> Optional[Any]",
            "docstring": "Safe single-row query with automatic Row/Model detection.\n\nHandles SQLModel version differences where .first() may return:\n- Row tuple (needs [0] extraction)\n- Model directly (no extraction needed)\n\nArgs:\n    session: SQLModel Session\n    statement: Select statement\n    model_class: Optional model class for isinstance check\n\nReturns:\n    Model instance or None\n\nExample:\n    user = query_one(session, select(User).where(User.email == email), User)",
            "is_async": false,
            "line": 179
          },
          {
            "name": "query_all",
            "signature": "(session: Any, statement: Any, model_class: Optional[type] = None) -> list",
            "docstring": "Safe multi-row query with automatic Row/Model detection.\n\nHandles SQLModel version differences where .all() may return:\n- List of Row tuples (needs [0] extraction)\n- List of Models directly (no extraction needed)\n\nArgs:\n    session: SQLModel Session\n    statement: Select statement\n    model_class: Optional model class for isinstance check\n\nReturns:\n    List of model instances\n\nExample:\n    users = query_all(session, select(User).where(User.status == 'active'), User)",
            "is_async": false,
            "line": 224
          },
          {
            "name": "model_to_dict",
            "signature": "(model: Any, include: Optional[list] = None, exclude: Optional[list] = None) -> dict",
            "docstring": "Convert ORM model to dict to prevent DetachedInstanceError.\n\nCall this BEFORE the session closes to extract values safely.\n\nArgs:\n    model: ORM model instance\n    include: List of attributes to include (None = all)\n    exclude: List of attributes to exclude\n\nReturns:\n    Dictionary with model values\n\nExample:\n    with Session(engine) as session:\n        user = session.get(User, user_id)\n        user_data = model_to_dict(user, exclude=['password_hash'])\n    # user_data is safe to use after session closes\n    return user_data",
            "is_async": false,
            "line": 268
          },
          {
            "name": "models_to_dicts",
            "signature": "(models: list, include: Optional[list] = None, exclude: Optional[list] = None) -> list",
            "docstring": "Convert list of ORM models to list of dicts.\n\nArgs:\n    models: List of ORM model instances\n    include: List of attributes to include\n    exclude: List of attributes to exclude\n\nReturns:\n    List of dictionaries",
            "is_async": false,
            "line": 331
          },
          {
            "name": "safe_get",
            "signature": "(session: Any, model_class: type, id: Any, to_dict: bool = False, include: Optional[list] = None, exclude: Optional[list] = None) -> Any",
            "docstring": "Safe session.get() wrapper with optional dict conversion.\n\nUse session.get() for direct ID lookups - it's simpler and always\nreturns the model directly (not a Row tuple).\n\nArgs:\n    session: SQLModel Session\n    model_class: Model class to query\n    id: Primary key value\n    to_dict: If True, convert to dict before returning\n    include: Attributes to include in dict\n    exclude: Attributes to exclude from dict\n\nReturns:\n    Model instance, dict, or None\n\nExample:\n    # Simple get\n    user = safe_get(session, User, user_id)\n\n    # Get as dict (safe after session closes)\n    user_data = safe_get(session, User, user_id, to_dict=True)",
            "is_async": false,
            "line": 346
          },
          {
            "name": "get_or_create",
            "signature": "(session: Any, model_class: type, defaults: Optional[dict] = None, **kwargs) -> tuple",
            "docstring": "Get existing model or create new one.\n\nSimilar to Django's get_or_create, but with proper SQLModel handling.\n\nArgs:\n    session: SQLModel Session\n    model_class: Model class\n    defaults: Dict of fields to set on creation only\n    **kwargs: Fields to filter by\n\nReturns:\n    Tuple of (instance, created: bool)\n\nExample:\n    user, created = get_or_create(\n        session, User,\n        defaults={'status': 'active'},\n        email='test@example.com'\n    )",
            "is_async": false,
            "line": 388
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional",
              "TypeVar"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [
          {
            "name": "T",
            "line": 50
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "deterministic.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/deterministic.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 143,
        "module_docstring": null,
        "functions": [
          {
            "name": "seeded_jitter",
            "signature": "(workflow_run_id: str, attempt: int) -> float",
            "docstring": "Generate deterministic jitter value from workflow ID and attempt number.\n\nUses HMAC-SHA256 to produce a consistent float between 0 and 1\nthat is reproducible given the same inputs.\n\nArgs:\n    workflow_run_id: Unique workflow run identifier\n    attempt: Current attempt number (1-based)\n\nReturns:\n    Float between 0.0 and 1.0",
            "is_async": false,
            "line": 30
          },
          {
            "name": "deterministic_backoff_ms",
            "signature": "(workflow_run_id: str, attempt: int, initial_ms: int = 200, multiplier: float = 2.0, jitter_pct: float = 0.1, max_ms: int = 10000) -> int",
            "docstring": "Calculate exponential backoff with deterministic jitter.\n\nThe jitter is derived from the workflow_run_id and attempt number,\nmaking the backoff sequence reproducible for replay verification.\n\nArgs:\n    workflow_run_id: Unique workflow run identifier\n    attempt: Current attempt number (1-based)\n    initial_ms: Initial backoff in milliseconds\n    multiplier: Exponential multiplier per attempt\n    jitter_pct: Jitter percentage (0.1 = +/- 10%)\n    max_ms: Maximum backoff in milliseconds\n\nReturns:\n    Backoff duration in milliseconds",
            "is_async": false,
            "line": 51
          },
          {
            "name": "deterministic_timestamp",
            "signature": "(workflow_run_id: str, step_index: int, base_time: Optional[float] = None) -> int",
            "docstring": "Generate a deterministic timestamp for replay scenarios.\n\nIn production, returns current time. In replay mode with base_time,\nreturns a reproducible offset from base_time.\n\nArgs:\n    workflow_run_id: Unique workflow run identifier\n    step_index: Step index within workflow\n    base_time: Base timestamp for replay (None = use current time)\n\nReturns:\n    Unix timestamp in seconds",
            "is_async": false,
            "line": 89
          },
          {
            "name": "generate_idempotency_key",
            "signature": "(workflow_run_id: str, skill_name: str, step_index: int) -> str",
            "docstring": "Generate a deterministic idempotency key for a skill execution.\n\nArgs:\n    workflow_run_id: Unique workflow run identifier\n    skill_name: Name of the skill being executed\n    step_index: Step index within workflow\n\nReturns:\n    Idempotency key string",
            "is_async": false,
            "line": 113
          },
          {
            "name": "hash_params",
            "signature": "(params: dict) -> str",
            "docstring": "Generate a hash of skill parameters for idempotency comparison.\n\nArgs:\n    params: Skill input parameters\n\nReturns:\n    SHA256 hash prefix (16 chars)",
            "is_async": false,
            "line": 130
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "struct",
            "names": [
              "struct"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "fatigue_controller.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/fatigue_controller.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 749,
        "module_docstring": "AlertFatigueController - Alert fatigue management service.\n\nManages alert fatigue through:\n- Rate limiting: Limit alerts per source per time window\n- Suppression: Temporarily suppress repetitive alerts\n- Aggregation: Group similar alerts together\n- Cool-down periods: Auto-suppress after threshold breaches",
        "functions": [
          {
            "name": "get_alert_fatigue_controller",
            "signature": "() -> AlertFatigueController",
            "docstring": "Get the singleton controller instance.",
            "is_async": false,
            "line": 695
          },
          {
            "name": "_reset_controller",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 703
          },
          {
            "name": "check_alert_fatigue",
            "signature": "(tenant_id: str, alert_type: str, source_id: Optional[str] = None, source_data: Optional[dict[str, Any]] = None, alert_data: Optional[dict[str, Any]] = None) -> FatigueCheckResult",
            "docstring": "Check if an alert should be allowed or suppressed.",
            "is_async": false,
            "line": 712
          },
          {
            "name": "suppress_alert",
            "signature": "(tenant_id: str, source_id: str, alert_type: str, duration_seconds: Optional[int] = None) -> AlertFatigueState",
            "docstring": "Manually suppress an alert source.",
            "is_async": false,
            "line": 730
          },
          {
            "name": "get_fatigue_stats",
            "signature": "(tenant_id: Optional[str] = None) -> AlertFatigueStats",
            "docstring": "Get fatigue statistics.",
            "is_async": false,
            "line": 746
          }
        ],
        "classes": [
          {
            "name": "AlertFatigueMode",
            "docstring": "Operating modes for fatigue control.",
            "methods": [],
            "line": 37
          },
          {
            "name": "AlertFatigueAction",
            "docstring": "Actions taken by the fatigue controller.",
            "methods": [],
            "line": 46
          },
          {
            "name": "AlertFatigueConfig",
            "docstring": "Configuration for alert fatigue thresholds.",
            "methods": [
              "to_dict"
            ],
            "line": 58
          },
          {
            "name": "AlertFatigueState",
            "docstring": "State tracking for an alert source.",
            "methods": [
              "record_alert",
              "reset_window",
              "start_suppression",
              "end_suppression",
              "start_cooldown",
              "end_cooldown",
              "add_to_aggregation",
              "flush_aggregation",
              "is_window_expired",
              "is_suppression_expired",
              "is_cooldown_expired",
              "to_dict"
            ],
            "line": 96
          },
          {
            "name": "AlertFatigueStats",
            "docstring": "Statistics from fatigue controller.",
            "methods": [
              "update_rates",
              "to_dict"
            ],
            "line": 257
          },
          {
            "name": "AlertFatigueError",
            "docstring": "Exception for fatigue controller errors.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 304
          },
          {
            "name": "FatigueCheckResult",
            "docstring": "Result of a fatigue check.",
            "methods": [
              "to_dict"
            ],
            "line": 328
          },
          {
            "name": "AlertFatigueController",
            "docstring": "Controller for managing alert fatigue.\n\nFeatures:\n- Rate limiting per source\n- Automatic suppression after thresholds\n- Alert aggregation\n- Cool-down periods\n- Per-tenant configuration",
            "methods": [
              "__init__",
              "_get_state_key",
              "_generate_source_id",
              "configure_tenant",
              "get_config",
              "get_or_create_state",
              "get_state",
              "check_alert",
              "suppress_source",
              "unsuppress_source",
              "get_statistics",
              "get_active_sources",
              "clear_tenant",
              "reset"
            ],
            "line": 351
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/guard.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 622,
        "module_docstring": "Guard Console Data Contracts - Customer-Facing API\n\nDOMAIN: Customer Console (/guard/*)\nAUDIENCE: Customers (tenant-scoped access)\nAUTH: aud=\"console\", requires org_id\n\nThese contracts are FROZEN as of M29. Changes require:\n1. Deprecation annotation\n2. 2-version grace period\n3. PIN documentation\n\nINVARIANTS:\n- All responses are tenant-scoped (no cross-tenant data)\n- No founder-only fields (those belong in ops.py)\n- Times are ISO8601 strings\n- IDs are prefixed strings (inc_, key_, etc.)",
        "functions": [],
        "classes": [
          {
            "name": "GuardStatusDTO",
            "docstring": "GET /guard/status response.\n\nTells customer if their traffic is protected.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 48
          },
          {
            "name": "TodaySnapshotDTO",
            "docstring": "GET /guard/snapshot/today response.\n\nToday's metrics at a glance.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 83
          },
          {
            "name": "IncidentSummaryDTO",
            "docstring": "Incident list item.\n\nUsed in GET /guard/incidents (list) and detail views.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 114
          },
          {
            "name": "IncidentEventDTO",
            "docstring": "Timeline event within an incident.",
            "methods": [],
            "line": 137
          },
          {
            "name": "IncidentDetailDTO",
            "docstring": "GET /guard/incidents/{id} response.\n\nFull incident with timeline.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 147
          },
          {
            "name": "IncidentListDTO",
            "docstring": "GET /guard/incidents response (paginated).\n\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 159
          },
          {
            "name": "CustomerIncidentImpactDTO",
            "docstring": "Impact assessment for customers - calm, explicit.\n\nFrozen: 2025-12-24 (M29 Category 5)",
            "methods": [],
            "line": 183
          },
          {
            "name": "CustomerIncidentResolutionDTO",
            "docstring": "Resolution status for customers - reassuring.\n\nFrozen: 2025-12-24 (M29 Category 5)",
            "methods": [],
            "line": 197
          },
          {
            "name": "CustomerIncidentActionDTO",
            "docstring": "Customer action item - only if necessary.\n\nFrozen: 2025-12-24 (M29 Category 5)",
            "methods": [],
            "line": 210
          },
          {
            "name": "CustomerIncidentNarrativeDTO",
            "docstring": "GET /guard/incidents/{id} enhanced response.\n\nCustomer-friendly incident detail with calm narrative.\nAnswers: What happened? Did it affect me? Is it fixed? Do I need to act?\n\nFrozen: 2025-12-24 (M29 Category 5)\n\nIMPORTANT: This is CUSTOMER-ONLY data.\n- Uses calm vocabulary (normal, rising, protected, resolved)\n- No internal terminology (no policy names, no thresholds)\n- No cross-tenant data (no affected_tenants, no percentiles)",
            "methods": [],
            "line": 223
          },
          {
            "name": "ApiKeyDTO",
            "docstring": "API key response (masked).\n\nGET /guard/keys response item.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 302
          },
          {
            "name": "ApiKeyListDTO",
            "docstring": "GET /guard/keys response.",
            "methods": [],
            "line": 321
          },
          {
            "name": "GuardrailConfigDTO",
            "docstring": "Individual guardrail configuration.",
            "methods": [],
            "line": 333
          },
          {
            "name": "TenantSettingsDTO",
            "docstring": "GET /guard/settings response.\n\nRead-only tenant configuration view.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 342
          },
          {
            "name": "ReplayCallSnapshotDTO",
            "docstring": "Original call context for replay.",
            "methods": [],
            "line": 364
          },
          {
            "name": "ReplayCertificateDTO",
            "docstring": "Cryptographic proof of replay (M23).",
            "methods": [],
            "line": 374
          },
          {
            "name": "ReplayResultDTO",
            "docstring": "POST /guard/replay/{call_id} response.\n\nResult of replaying a call with determinism validation.\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 386
          },
          {
            "name": "KillSwitchActionDTO",
            "docstring": "POST /guard/killswitch/activate and /deactivate response.\n\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 407
          },
          {
            "name": "OnboardingVerifyResponseDTO",
            "docstring": "POST /guard/onboarding/verify response.\n\nFrozen: 2025-12-23 (M29)",
            "methods": [],
            "line": 425
          },
          {
            "name": "CustomerCostSummaryDTO",
            "docstring": "GET /guard/costs/summary response.\n\nCustomer cost summary with trend and projection.\nFrozen: 2025-12-23 (M29 Category 4)\n\nTHE INVARIANT: All values derive from complete snapshots, never live data.\nCustomer sees their own tenant data only - no cross-tenant leakage.",
            "methods": [],
            "line": 443
          },
          {
            "name": "CostBreakdownItemDTO",
            "docstring": "Individual cost breakdown item.",
            "methods": [],
            "line": 497
          },
          {
            "name": "CustomerCostExplainedDTO",
            "docstring": "GET /guard/costs/explained response.\n\nExplains WHY costs are what they are.\nFrozen: 2025-12-23 (M29 Category 4)\n\nIMPORTANT: Does not expose founder-only fields like churn_risk or affected_tenants.",
            "methods": [],
            "line": 508
          },
          {
            "name": "CustomerCostIncidentDTO",
            "docstring": "Cost-related incident visible to customer.\n\nUsed in GET /guard/costs/incidents response.\nFrozen: 2025-12-23 (M29 Category 4)\n\nIMPORTANT: Uses calm vocabulary (protected, attention_needed).\nDoes not expose severity levels - maps internally.",
            "methods": [],
            "line": 582
          },
          {
            "name": "CustomerCostIncidentListDTO",
            "docstring": "GET /guard/costs/incidents response.",
            "methods": [],
            "line": 617
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Literal",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "input_sanitizer.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/input_sanitizer.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 260,
        "module_docstring": null,
        "functions": [
          {
            "name": "detect_injection_patterns",
            "signature": "(text: str) -> List[tuple]",
            "docstring": "Detect prompt injection patterns in text.\n\nReturns:\n    List of (pattern_name, matched_text) tuples",
            "is_async": false,
            "line": 110
          },
          {
            "name": "extract_urls",
            "signature": "(text: str) -> List[str]",
            "docstring": "Extract all URLs from text.",
            "is_async": false,
            "line": 124
          },
          {
            "name": "is_url_safe",
            "signature": "(url: str) -> tuple[bool, Optional[str]]",
            "docstring": "Check if a URL is safe (not targeting internal resources).\n\nReturns:\n    Tuple of (is_safe, reason_if_unsafe)",
            "is_async": false,
            "line": 130
          },
          {
            "name": "sanitize_goal",
            "signature": "(goal: str) -> SanitizationResult",
            "docstring": "Sanitize a goal string before processing.\n\nThis is the main entry point for the input sanitizer.\n\nArgs:\n    goal: The user-provided goal text\n\nReturns:\n    SanitizationResult with sanitized text and safety info",
            "is_async": false,
            "line": 168
          },
          {
            "name": "validate_goal",
            "signature": "(goal: str) -> tuple[bool, Optional[str], List[str]]",
            "docstring": "Convenience function to validate a goal.\n\nReturns:\n    Tuple of (is_valid, error_message, warnings)",
            "is_async": false,
            "line": 253
          }
        ],
        "classes": [
          {
            "name": "SanitizationResult",
            "docstring": "Result of input sanitization.",
            "methods": [
              "__post_init__"
            ],
            "line": 96
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "urllib.parse",
            "names": [
              "urlparse"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [
          {
            "name": "MAX_GOAL_LENGTH",
            "line": 35
          },
          {
            "name": "ENABLE_INJECTION_DETECTION",
            "line": 38
          },
          {
            "name": "ENABLE_URL_SANITIZATION",
            "line": 39
          },
          {
            "name": "INJECTION_PATTERNS",
            "line": 55
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "knowledge_lifecycle_manager.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/knowledge_lifecycle_manager.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 921,
        "module_docstring": "GAP-086: Knowledge Lifecycle Manager\n\nTHE ORCHESTRATOR \u2014 Single service owning entire knowledge plane lifecycle.\n\nARCHITECTURAL PRINCIPLE:\n    Lifecycle operations are governance-controlled, not user-controlled.\n    SDK calls REQUEST transitions. This manager DECIDES.\n    Policy + state machine ARBITRATE.\n    Users never force transitions directly.\n\nRESPONSIBILITIES:\n1. Enforce state machine transitions (GAP-089)\n2. Coordinate with policy gates (GAP-087)\n3. Emit audit events for all transitions (GAP-088)\n4. Coordinate async background jobs\n5. Block illegal transitions with clear reasons\n\nDESIGN INVARIANTS:\n- MANAGER-001: All transitions go through this manager\n- MANAGER-002: No transition without audit event\n- MANAGER-003: Policy gates are mandatory for protected transitions\n- MANAGER-004: Failed transitions leave state unchanged\n- MANAGER-005: Async jobs report completion back to manager",
        "functions": [
          {
            "name": "generate_id",
            "signature": "(prefix: str = 'kp') -> str",
            "docstring": "Generate a unique ID with prefix.",
            "is_async": false,
            "line": 74
          },
          {
            "name": "get_knowledge_lifecycle_manager",
            "signature": "() -> KnowledgeLifecycleManager",
            "docstring": "Get the singleton KnowledgeLifecycleManager instance.",
            "is_async": false,
            "line": 896
          },
          {
            "name": "reset_manager",
            "signature": "() -> None",
            "docstring": "Reset the singleton instance (for testing).",
            "is_async": false,
            "line": 904
          }
        ],
        "classes": [
          {
            "name": "GateDecision",
            "docstring": "Policy gate decision.",
            "methods": [],
            "line": 84
          },
          {
            "name": "GateResult",
            "docstring": "Result of a policy gate check.",
            "methods": [
              "__bool__",
              "allowed",
              "blocked",
              "pending"
            ],
            "line": 92
          },
          {
            "name": "LifecycleAuditEventType",
            "docstring": "Types of lifecycle audit events.",
            "methods": [],
            "line": 128
          },
          {
            "name": "LifecycleAuditEvent",
            "docstring": "Audit event for lifecycle transitions (GAP-088).",
            "methods": [
              "to_dict"
            ],
            "line": 140
          },
          {
            "name": "KnowledgePlaneLifecycle",
            "docstring": "In-memory representation of a knowledge plane lifecycle.\n\nRenamed from KnowledgePlane to KnowledgePlaneLifecycle (2026-01-23)\nto avoid name collision with lifecycle/engines/knowledge_plane.py::KnowledgePlane\nwhich represents the knowledge graph abstraction.\n\nThis class represents the LIFECYCLE state machine for knowledge planes.\nReference: GEN-DUP-002, HOC_general_deep_audit_report.md",
            "methods": [
              "record_state_change"
            ],
            "line": 182
          },
          {
            "name": "TransitionRequest",
            "docstring": "Request to transition a knowledge plane to a new state.",
            "methods": [],
            "line": 234
          },
          {
            "name": "TransitionResponse",
            "docstring": "Response from a transition attempt.",
            "methods": [
              "to_dict"
            ],
            "line": 248
          },
          {
            "name": "KnowledgeLifecycleManager",
            "docstring": "GAP-086: Knowledge Lifecycle Manager \u2014 THE ORCHESTRATOR.\n\nSingle service owning entire knowledge plane lifecycle.\n\nUsage:\n    manager = KnowledgeLifecycleManager()\n\n    # Register a new plane\n    response = manager.handle_transition(TransitionRequest(\n        plane_id=\"new\",\n        tenant_id=\"tenant-123\",\n        action=LifecycleAction.REGISTER,\n        actor_id=\"user-456\",\n    ))\n\n    # Check current state\n    state = manager.get_state(\"plane-id\")\n\n    # Wait for state\n    reached = manager.wait_until(\"plane-id\", KnowledgePlaneLifecycleState.ACTIVE)",
            "methods": [
              "__init__",
              "handle_transition",
              "_handle_register",
              "get_state",
              "get_plane",
              "get_history",
              "get_audit_log",
              "get_next_action",
              "can_transition_to",
              "_default_policy_gate",
              "set_policy_gate",
              "_emit_transition_event",
              "_emit_blocked_event",
              "_default_audit_sink",
              "set_audit_sink",
              "_start_async_job",
              "_get_job_type_for_state",
              "_default_job_scheduler",
              "complete_job",
              "bind_policy",
              "unbind_policy",
              "approve_purge"
            ],
            "line": 282
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.models.knowledge_lifecycle",
            "names": [
              "KnowledgePlaneLifecycleState",
              "LifecycleAction",
              "TransitionResult",
              "is_valid_transition",
              "validate_transition",
              "get_action_for_transition",
              "get_transition_for_action",
              "get_next_onboarding_state",
              "get_next_offboarding_state"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": [
          "KnowledgeLifecycleManager",
          "KnowledgePlaneLifecycle",
          "TransitionRequest",
          "TransitionResponse",
          "GateDecision",
          "GateResult",
          "LifecycleAuditEventType",
          "LifecycleAuditEvent",
          "get_knowledge_lifecycle_manager",
          "reset_manager"
        ]
      },
      {
        "file_name": "knowledge_sdk.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/knowledge_sdk.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 983,
        "module_docstring": "GAP-083-085: Knowledge SDK Fa\u00e7ade\n\nA thin, state-driven, async-aware SDK interface over KnowledgeLifecycleManager.\n\nARCHITECTURAL PRINCIPLE:\n    SDK calls REQUEST transitions.\n    LifecycleManager DECIDES.\n    Policy + state machine ARBITRATE.\n\nDESIGN INVARIANTS:\n- SDK-001: SDK does NOT force transitions \u2014 it requests them\n- SDK-002: SDK does NOT manage state \u2014 orchestrator does\n- SDK-003: SDK does NOT bypass policy gates \u2014 gates are mandatory\n- SDK-004: SDK provides async-aware wait semantics\n- SDK-005: SDK returns rich results, not exceptions\n\nWHY THIN:\n- If SDK owns state logic, you get split-brain with orchestrator\n- If SDK bypasses gates, you lose governance\n- If SDK throws exceptions, you lose structured outcomes\n\nCOVERAGE:\n- GAP-083: Onboarding SDK methods (register, verify, ingest, index, classify, activate)\n- GAP-084: Offboarding SDK methods (deregister, deactivate, archive, purge)\n- GAP-085: Wait semantics and state queries",
        "functions": [
          {
            "name": "create_knowledge_sdk",
            "signature": "(tenant_id: str, actor_id: Optional[str] = None) -> KnowledgeSDK",
            "docstring": "Create a KnowledgeSDK instance for a tenant.\n\nArgs:\n    tenant_id: Tenant ID (required)\n    actor_id: Optional actor ID for audit trails\n\nReturns:\n    KnowledgeSDK instance bound to the tenant",
            "is_async": false,
            "line": 959
          }
        ],
        "classes": [
          {
            "name": "KnowledgePlaneConfig",
            "docstring": "Configuration for creating a knowledge plane.",
            "methods": [],
            "line": 78
          },
          {
            "name": "WaitOptions",
            "docstring": "Options for wait operations.",
            "methods": [],
            "line": 88
          },
          {
            "name": "SDKResult",
            "docstring": "Structured result from SDK operations.\n\nSDK-005: SDK returns rich results, not exceptions.\nEvery SDK method returns this type with success/failure and context.",
            "methods": [
              "from_transition_response",
              "error",
              "to_dict"
            ],
            "line": 101
          },
          {
            "name": "PlaneInfo",
            "docstring": "Information about a knowledge plane for SDK consumers.",
            "methods": [
              "from_plane",
              "to_dict"
            ],
            "line": 170
          },
          {
            "name": "KnowledgeSDK",
            "docstring": "GAP-083-085: Knowledge SDK Fa\u00e7ade.\n\nA thin, state-driven, async-aware SDK interface.\n\nUsage:\n    sdk = KnowledgeSDK(tenant_id=\"tenant-123\")\n\n    # Register a new knowledge plane\n    result = sdk.register(KnowledgePlaneConfig(\n        name=\"My Knowledge Base\",\n        connection_string=\"postgresql://...\",\n    ))\n\n    if result.success:\n        plane_id = result.plane_id\n\n        # Progress through lifecycle\n        await sdk.verify(plane_id)\n        await sdk.wait_until(plane_id, KnowledgePlaneLifecycleState.VERIFIED)\n\n        await sdk.ingest(plane_id)\n        await sdk.wait_until(plane_id, KnowledgePlaneLifecycleState.INDEXED)\n\n        # ... continue through activation\n\nIMPORTANT:\n    SDK calls REQUEST transitions. This SDK does NOT guarantee success.\n    The KnowledgeLifecycleManager decides whether transitions are allowed\n    based on state machine rules and policy gates.",
            "methods": [
              "__init__",
              "register",
              "verify",
              "ingest",
              "index",
              "classify",
              "request_activation",
              "activate",
              "deregister",
              "cancel_deregister",
              "deactivate",
              "archive",
              "purge",
              "get_state",
              "get_plane",
              "get_history",
              "get_audit_log",
              "get_next_action",
              "can_transition_to",
              "wait_until",
              "wait_until_sync",
              "bind_policy",
              "unbind_policy",
              "approve_purge"
            ],
            "line": 250
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.models.knowledge_lifecycle",
            "names": [
              "KnowledgePlaneLifecycleState",
              "LifecycleAction"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.general.L5_engines.knowledge_lifecycle_manager",
            "names": [
              "KnowledgeLifecycleManager",
              "KnowledgePlaneLifecycle",
              "TransitionRequest",
              "TransitionResponse",
              "GateDecision",
              "get_knowledge_lifecycle_manager"
            ],
            "is_relative": false,
            "line": 62
          }
        ],
        "constants": [],
        "all_exports": [
          "KnowledgeSDK",
          "KnowledgePlaneConfig",
          "WaitOptions",
          "SDKResult",
          "PlaneInfo",
          "create_knowledge_sdk"
        ]
      },
      {
        "file_name": "lifecycle_facade.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/lifecycle_facade.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 709,
        "module_docstring": "Lifecycle Facade (L4 Domain Logic)\n\nThis facade provides the external interface for lifecycle operations.\nAll lifecycle APIs MUST use this facade instead of directly importing\ninternal lifecycle modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes agent and run lifecycle logic\n- Provides unified access to state transitions\n- Single point for audit emission\n\nL2 API Routes (GAP-131 to GAP-136):\n- POST /api/v1/lifecycle/agents (create agent)\n- GET /api/v1/lifecycle/agents (list agents)\n- GET /api/v1/lifecycle/agents/{id} (get agent)\n- POST /api/v1/lifecycle/agents/{id}/start (start agent)\n- POST /api/v1/lifecycle/agents/{id}/stop (stop agent)\n- POST /api/v1/lifecycle/agents/{id}/terminate (terminate agent)\n- POST /api/v1/lifecycle/runs (create run)\n- GET /api/v1/lifecycle/runs (list runs)\n- GET /api/v1/lifecycle/runs/{id} (get run)\n- POST /api/v1/lifecycle/runs/{id}/pause (pause run)\n- POST /api/v1/lifecycle/runs/{id}/resume (resume run)\n- POST /api/v1/lifecycle/runs/{id}/cancel (cancel run)\n\nUsage:\n    # L5 engine import (migrated to HOC per SWEEP-11)\n    from app.hoc.cus.general.L5_engines.lifecycle_facade import get_lifecycle_facade\n\n    facade = get_lifecycle_facade()\n\n    # Start an agent\n    agent = await facade.start_agent(agent_id=\"...\", tenant_id=\"...\")",
        "functions": [
          {
            "name": "get_lifecycle_facade",
            "signature": "() -> LifecycleFacade",
            "docstring": "Get the lifecycle facade instance.\n\nThis is the recommended way to access lifecycle operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    LifecycleFacade instance",
            "is_async": false,
            "line": 696
          }
        ],
        "classes": [
          {
            "name": "AgentState",
            "docstring": "Agent lifecycle states.",
            "methods": [],
            "line": 69
          },
          {
            "name": "RunState",
            "docstring": "Run lifecycle states.",
            "methods": [],
            "line": 80
          },
          {
            "name": "AgentLifecycle",
            "docstring": "Agent lifecycle information.",
            "methods": [
              "to_dict"
            ],
            "line": 91
          },
          {
            "name": "RunLifecycle",
            "docstring": "Run lifecycle information.",
            "methods": [
              "to_dict"
            ],
            "line": 123
          },
          {
            "name": "LifecycleSummary",
            "docstring": "Summary of lifecycle entities.",
            "methods": [
              "to_dict"
            ],
            "line": 161
          },
          {
            "name": "LifecycleFacade",
            "docstring": "Facade for lifecycle operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nlifecycle services.\n\nLayer: L4 (Domain Logic)\nCallers: lifecycle.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "create_agent",
              "list_agents",
              "get_agent",
              "start_agent",
              "stop_agent",
              "terminate_agent",
              "create_run",
              "list_runs",
              "get_run",
              "pause_run",
              "resume_run",
              "cancel_run",
              "get_summary"
            ],
            "line": 190
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 64
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lifecycle_stages_base.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/lifecycle_stages_base.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 317,
        "module_docstring": "Stage Handler Protocol and Base Types\n\nThis module defines the contract for lifecycle stage handlers.\n\nCRITICAL DESIGN INVARIANT:\n    Stage handlers are DUMB PLUGINS.\n    They do NOT manage state.\n    They do NOT emit events.\n    They do NOT check policies.\n    The orchestrator does ALL of that.\n\nWhy Dumb:\n- If stages manage state, you get split-brain\n- If stages emit events, you get duplicate audit\n- If stages check policy, you get enforcement fragmentation",
        "functions": [],
        "classes": [
          {
            "name": "StageStatus",
            "docstring": "Result status from stage execution.",
            "methods": [],
            "line": 47
          },
          {
            "name": "StageContext",
            "docstring": "Context passed to stage handlers.\n\nContains all information a stage needs to execute,\nwithout giving it direct access to state management.",
            "methods": [],
            "line": 56
          },
          {
            "name": "StageResult",
            "docstring": "Result returned by stage handlers.\n\nStage handlers return this to indicate success/failure.\nThe orchestrator uses this to decide what to do next.",
            "methods": [
              "success",
              "is_async",
              "ok",
              "fail",
              "pending",
              "skipped"
            ],
            "line": 83
          },
          {
            "name": "StageHandler",
            "docstring": "Protocol for stage handlers.\n\nStage handlers are dumb. The orchestrator is smart.\n\nImplementation Requirements:\n- Must be stateless (no instance state that affects execution)\n- Must not call KnowledgeLifecycleManager methods\n- Must not emit audit events\n- Must not check policies\n- Must only perform their specific operation",
            "methods": [
              "stage_name",
              "handles_states",
              "execute",
              "validate"
            ],
            "line": 159
          },
          {
            "name": "BaseStageHandler",
            "docstring": "Base class for stage handlers.\n\nProvides common implementation while enforcing the \"dumb plugin\" contract.",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute"
            ],
            "line": 214
          },
          {
            "name": "StageRegistry",
            "docstring": "Registry of stage handlers.\n\nMaps states to their handlers for the orchestrator to use.",
            "methods": [
              "__init__",
              "register",
              "get_handler",
              "has_handler",
              "create_default"
            ],
            "line": 253
          }
        ],
        "imports": [
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional",
              "Protocol",
              "Type",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.models.knowledge_lifecycle",
            "names": [
              "KnowledgePlaneLifecycleState"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "manager.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/manager.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 394,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_envelope_manager",
            "signature": "() -> EnvelopeManager",
            "docstring": "Get the global envelope manager instance.",
            "is_async": false,
            "line": 381
          },
          {
            "name": "reset_manager_for_testing",
            "signature": "() -> None",
            "docstring": "Reset envelope manager. FOR TESTING ONLY.",
            "is_async": false,
            "line": 390
          }
        ],
        "classes": [
          {
            "name": "EnvelopeApplication",
            "docstring": "Record of an active envelope application.",
            "methods": [],
            "line": 52
          },
          {
            "name": "EnvelopeManager",
            "docstring": "Manages the lifecycle of optimization envelopes.\n\nResponsibilities:\n- Validate envelopes before application\n- Track active envelopes\n- Handle kill-switch triggered rollback\n- Emit audit records\n- Ensure deterministic rollback\n\nThread-safe implementation.",
            "methods": [
              "__init__",
              "active_envelope_count",
              "can_apply",
              "apply",
              "revert",
              "revert_all",
              "_on_killswitch_activated",
              "get_active_envelopes",
              "get_audit_records",
              "is_envelope_active"
            ],
            "line": 63
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "threading",
            "names": [
              "threading"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.optimization.envelope",
            "names": [
              "Envelope",
              "EnvelopeAuditRecord",
              "EnvelopeLifecycle",
              "EnvelopeValidationError",
              "RevertReason",
              "calculate_bounded_value",
              "create_audit_record",
              "validate_envelope"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.optimization.killswitch",
            "names": [
              "KillSwitch",
              "KillSwitchEvent",
              "RollbackStatus",
              "get_killswitch"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "metrics_helpers.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/metrics_helpers.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 210,
        "module_docstring": "Prometheus Metrics Helpers - Idempotent Registration\n\nThis module provides helper functions for creating Prometheus metrics\nthat are safe to use in modules that may be reimported during testing.\n\nUsage:\n    from app.utils.metrics_helpers import get_or_create_counter, get_or_create_gauge\n\n    MY_COUNTER = get_or_create_counter(\n        \"mymodule_operations_total\",\n        \"Total operations\",\n        [\"status\", \"type\"]\n    )\n\nPrevention: PIN-120 / PREV-1 - Prevents duplicate timeseries errors in tests.",
        "functions": [
          {
            "name": "_find_existing_metric",
            "signature": "(name: str)",
            "docstring": "Find an existing metric in the registry by name.\n\nPrometheus registers metrics under multiple keys (base name, _total, _created).\nThe collector's _name attribute contains the base name.\n\nArgs:\n    name: The base metric name (without _total suffix for counters)\n\nReturns:\n    The existing metric collector if found, None otherwise",
            "is_async": false,
            "line": 44
          },
          {
            "name": "get_or_create_counter",
            "signature": "(name: str, documentation: str, labelnames: Optional[List[str]] = None) -> Counter",
            "docstring": "Get existing counter or create new one - idempotent.\n\nArgs:\n    name: Metric name (should follow naming convention: {module}_{metric}_total)\n    documentation: Help text for the metric\n    labelnames: List of label names\n\nReturns:\n    Counter metric (existing or new)\n\nExample:\n    MY_COUNTER = get_or_create_counter(\n        \"drift_detector_comparisons_total\",\n        \"Total drift comparisons performed\",\n        [\"status\"]\n    )",
            "is_async": false,
            "line": 69
          },
          {
            "name": "get_or_create_gauge",
            "signature": "(name: str, documentation: str, labelnames: Optional[List[str]] = None) -> Gauge",
            "docstring": "Get existing gauge or create new one - idempotent.\n\nArgs:\n    name: Metric name (should follow naming convention: {module}_{metric})\n    documentation: Help text for the metric\n    labelnames: List of label names\n\nReturns:\n    Gauge metric (existing or new)\n\nExample:\n    MY_GAUGE = get_or_create_gauge(\n        \"policy_cache_size\",\n        \"Current policy cache size\",\n        [\"tenant_id\"]\n    )",
            "is_async": false,
            "line": 94
          },
          {
            "name": "get_or_create_histogram",
            "signature": "(name: str, documentation: str, labelnames: Optional[List[str]] = None, buckets: Optional[List[float]] = None) -> Histogram",
            "docstring": "Get existing histogram or create new one - idempotent.\n\nArgs:\n    name: Metric name (should follow naming convention: {module}_{metric}_seconds)\n    documentation: Help text for the metric\n    labelnames: List of label names\n    buckets: Histogram bucket boundaries\n\nReturns:\n    Histogram metric (existing or new)\n\nExample:\n    MY_HISTOGRAM = get_or_create_histogram(\n        \"outbox_processing_seconds\",\n        \"Time to process outbox events\",\n        buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 5.0]\n    )",
            "is_async": false,
            "line": 119
          },
          {
            "name": "validate_metric_name",
            "signature": "(name: str) -> bool",
            "docstring": "Validate metric name follows conventions.\n\nConvention (PIN-120 / PREV-2):\n- Counter: {module}_{metric}_total\n- Histogram: {module}_{metric}_seconds\n- Gauge: {module}_{metric} (no required suffix)\n- Info: {module}_{metric}_info\n\nArgs:\n    name: Metric name to validate\n\nReturns:\n    True if valid, False otherwise",
            "is_async": false,
            "line": 159
          },
          {
            "name": "reset_metrics_registry",
            "signature": "()",
            "docstring": "Reset the Prometheus registry for test isolation.\n\nWARNING: Only use in test fixtures, never in production code.",
            "is_async": false,
            "line": 192
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "prometheus_client",
            "names": [
              "REGISTRY",
              "Counter",
              "Gauge",
              "Histogram"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [
          {
            "name": "VALID_SUFFIXES",
            "line": 156
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "monitors_facade.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/monitors_facade.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 541,
        "module_docstring": "Monitors Facade (L4 Domain Logic)\n\nThis facade provides the external interface for monitoring operations.\nAll monitor APIs MUST use this facade instead of directly importing\ninternal monitor modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes health monitoring logic\n- Provides unified access to monitor configuration\n- Single point for audit emission\n\nL2 API Routes (GAP-120, GAP-121):\n- POST /api/v1/monitors (create monitor)\n- GET /api/v1/monitors (list monitors)\n- GET /api/v1/monitors/{id} (get monitor)\n- PUT /api/v1/monitors/{id} (update monitor)\n- DELETE /api/v1/monitors/{id} (delete monitor)\n- POST /api/v1/monitors/{id}/check (run health check)\n- GET /api/v1/monitors/{id}/history (check history)\n- GET /api/v1/monitors/status (overall status)\n\nUsage:\n    from app.services.monitors.facade import get_monitors_facade\n\n    facade = get_monitors_facade()\n\n    # Create monitor\n    monitor = await facade.create_monitor(\n        tenant_id=\"...\",\n        name=\"API Health\",\n        target={\"url\": \"https://api.example.com/health\"},\n    )",
        "functions": [
          {
            "name": "get_monitors_facade",
            "signature": "() -> MonitorsFacade",
            "docstring": "Get the monitors facade instance.\n\nThis is the recommended way to access monitor operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    MonitorsFacade instance",
            "is_async": false,
            "line": 528
          }
        ],
        "classes": [
          {
            "name": "MonitorType",
            "docstring": "Types of monitors.",
            "methods": [],
            "line": 67
          },
          {
            "name": "MonitorStatus",
            "docstring": "Monitor status.",
            "methods": [],
            "line": 76
          },
          {
            "name": "CheckStatus",
            "docstring": "Health check result status.",
            "methods": [],
            "line": 84
          },
          {
            "name": "MonitorConfig",
            "docstring": "Monitor configuration.",
            "methods": [
              "to_dict"
            ],
            "line": 93
          },
          {
            "name": "HealthCheckResult",
            "docstring": "Health check result.",
            "methods": [
              "to_dict"
            ],
            "line": 133
          },
          {
            "name": "MonitorStatusSummary",
            "docstring": "Overall monitoring status summary.",
            "methods": [
              "to_dict"
            ],
            "line": 159
          },
          {
            "name": "MonitorsFacade",
            "docstring": "Facade for monitor operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nmonitoring services.\n\nLayer: L4 (Domain Logic)\nCallers: monitors.py (L2), aos_sdk, Scheduler",
            "methods": [
              "__init__",
              "create_monitor",
              "list_monitors",
              "get_monitor",
              "update_monitor",
              "delete_monitor",
              "run_check",
              "get_check_history",
              "get_status_summary"
            ],
            "line": 180
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 62
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "panel_invariant_monitor.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/panel_invariant_monitor.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 456,
        "module_docstring": "Panel Invariant Monitor\n\nThis module prevents silent governance failures by monitoring panel-backing queries.\n\nA panel returning zero rows may mean:\n- Correct state (no violations) - acceptable\n- Broken ingestion - FAILURE\n- Filter regression - FAILURE\n- Upstream failure - FAILURE\n\nThe UI cannot distinguish these. This monitor provides out-of-band alerting.\n\nKey Principle: Zero results NEVER block UI rendering.\n               Zero results only trigger out-of-band alerting.\n\nAlert Types:\n- EMPTY_PANEL: Panel returning zero unexpectedly\n- STALE_PANEL: Data older than freshness SLA\n- FILTER_BREAK: Query returns error / no match\n\nReference: PIN-411 Gap Closure Spec (Part B)",
        "functions": [
          {
            "name": "get_panel_monitor",
            "signature": "() -> PanelInvariantMonitor",
            "docstring": "Get the singleton panel invariant monitor.",
            "is_async": false,
            "line": 445
          },
          {
            "name": "reset_panel_monitor",
            "signature": "() -> None",
            "docstring": "Reset the monitor (for testing).",
            "is_async": false,
            "line": 453
          }
        ],
        "classes": [
          {
            "name": "AlertType",
            "docstring": "Panel invariant alert types.",
            "methods": [],
            "line": 63
          },
          {
            "name": "AlertSeverity",
            "docstring": "Alert severity levels.",
            "methods": [],
            "line": 71
          },
          {
            "name": "PanelInvariant",
            "docstring": "A panel's invariant definition.",
            "methods": [],
            "line": 85
          },
          {
            "name": "PanelStatus",
            "docstring": "Current status of a panel.",
            "methods": [],
            "line": 101
          },
          {
            "name": "PanelAlert",
            "docstring": "An alert for a panel invariant violation.",
            "methods": [
              "to_dict"
            ],
            "line": 114
          },
          {
            "name": "PanelInvariantRegistry",
            "docstring": "Registry of panel invariants.\n\nLoads invariant definitions from YAML and provides lookup.",
            "methods": [
              "__init__",
              "_default_registry_path",
              "_load_registry",
              "get_invariant",
              "get_all_invariants",
              "get_alertable_invariants"
            ],
            "line": 140
          },
          {
            "name": "PanelInvariantMonitor",
            "docstring": "Monitors panel invariants and detects silent governance failures.\n\nRuns periodically (e.g., every 5 minutes) to check panel health.\n\nEvaluation Logic:\n- If now > warmup_grace\n- AND result_count < min_rows\n- FOR > alert_after_minutes\n- THEN raise alert",
            "methods": [
              "__init__",
              "check_panel",
              "report_filter_break",
              "_create_empty_panel_alert",
              "get_panel_status",
              "get_all_statuses",
              "get_unhealthy_panels",
              "get_recent_alerts",
              "get_metrics"
            ],
            "line": 203
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "yaml",
            "names": [
              "yaml"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "panel_slot_evaluator.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/panel_slot_evaluator.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 248,
        "module_docstring": "Panel Slot Evaluator \u2014 Execute slot evaluation logic\n\nEvaluates a slot given collected signals and verification results.\nComputes derived output signals.",
        "functions": [],
        "classes": [
          {
            "name": "PanelSlotEvaluator",
            "docstring": "Evaluates individual panel slots.\n\nUsage:\n    evaluator = PanelSlotEvaluator(adapter_version)\n    result = evaluator.evaluate(slot_spec, signals, verification)",
            "methods": [
              "__init__",
              "evaluate",
              "evaluate_missing",
              "_compute_outputs",
              "_map_signal",
              "_get_nested",
              "_compute_system_state",
              "_compute_attention_required",
              "_compute_highest_severity",
              "_determine_aggregation"
            ],
            "line": 44
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "panel_types",
            "names": [
              "Authority",
              "NegativeAuthorityValue",
              "PanelSlotResult",
              "SlotProvenance",
              "SlotSpec",
              "SlotState",
              "TimeSemantics",
              "TruthMetadata",
              "VerificationSignals"
            ],
            "is_relative": true,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "panel_verification_engine.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/panel_verification_engine.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 220,
        "module_docstring": "Panel Verification Engine \u2014 Determinism enforcement\n\nVerifies inputs and enforces determinism rules.\nHard failures on violations. No best-effort.",
        "functions": [],
        "classes": [
          {
            "name": "PanelVerificationEngine",
            "docstring": "Verifies inputs and enforces determinism rules.\n\nUsage:\n    engine = PanelVerificationEngine()\n    verification = engine.verify_inputs(required, signals)\n    engine.enforce_determinism(expected, actual)",
            "methods": [
              "verify_inputs",
              "check_contradictions",
              "determine_state",
              "determine_authority",
              "_check_negative_authority",
              "enforce_determinism",
              "check_determinism_rule"
            ],
            "line": 41
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "panel_types",
            "names": [
              "Authority",
              "DeterminismRule",
              "NegativeAuthorityValue",
              "SlotState",
              "VerificationSignals"
            ],
            "is_relative": true,
            "line": 30
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "plan_inspector.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/plan_inspector.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 312,
        "module_docstring": null,
        "functions": [
          {
            "name": "extract_urls_from_params",
            "signature": "(params: Dict[str, Any]) -> List[str]",
            "docstring": "Extract all URLs from skill parameters.",
            "is_async": false,
            "line": 88
          },
          {
            "name": "is_domain_forbidden",
            "signature": "(url: str) -> tuple[bool, str]",
            "docstring": "Check if a URL targets a forbidden domain.\n\nReturns:\n    Tuple of (is_forbidden: bool, domain: str)",
            "is_async": false,
            "line": 109
          },
          {
            "name": "validate_step",
            "signature": "(step: Dict[str, Any], result: PlanValidationResult)",
            "docstring": "Validate a single plan step.",
            "is_async": false,
            "line": 148
          },
          {
            "name": "validate_plan",
            "signature": "(plan: Dict[str, Any], agent_budget_cents: int = 0) -> PlanValidationResult",
            "docstring": "Validate a complete plan before execution.\n\nArgs:\n    plan: The plan dictionary from the planner\n    agent_budget_cents: The agent's remaining budget (0 = unlimited)\n\nReturns:\n    PlanValidationResult with errors and warnings",
            "is_async": false,
            "line": 186
          },
          {
            "name": "inspect_plan",
            "signature": "(plan: Dict[str, Any], agent_budget_cents: int = 0) -> Dict[str, Any]",
            "docstring": "Inspect a plan and return validation results.\n\nArgs:\n    plan: The plan dictionary\n    agent_budget_cents: Agent's remaining budget\n\nReturns:\n    Dict with 'valid', 'errors', and 'warnings' keys\n\nRaises:\n    Exception if plan has critical errors and should be rejected",
            "is_async": false,
            "line": 275
          }
        ],
        "classes": [
          {
            "name": "PlanValidationError",
            "docstring": "A single validation error.",
            "methods": [],
            "line": 63
          },
          {
            "name": "PlanValidationResult",
            "docstring": "Result of plan validation.",
            "methods": [
              "add_error",
              "add_warning"
            ],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "urllib.parse",
            "names": [
              "urlparse"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [
          {
            "name": "MAX_PLAN_STEPS",
            "line": 32
          },
          {
            "name": "MAX_LOOP_ITERATIONS",
            "line": 33
          },
          {
            "name": "MAX_ESTIMATED_COST_CENTS",
            "line": 34
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "profile_policy_mode.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/profile_policy_mode.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 459,
        "module_docstring": "Governance Profile Configuration\n\nReduces cognitive load and configuration drift by providing three\nwell-defined governance profiles:\n\n- STRICT: Full enforcement, all features enabled, production-ready\n- STANDARD: Core features enabled, some optional features disabled\n- OBSERVE_ONLY: Audit and observe without enforcement (safe rollout)\n\nUsage:\n    from app.hoc.cus.general.L5_engines.profile_policy_mode import (\n        get_governance_profile,\n        validate_governance_config,\n        GovernanceProfile,\n    )\n\n    # At startup\n    profile = get_governance_profile()\n    validate_governance_config()  # Raises if invalid combination\n\n    # Check profile\n    if profile == GovernanceProfile.STRICT:\n        # Full enforcement mode\n        ...\n\nEnvironment Variables:\n    GOVERNANCE_PROFILE: STRICT | STANDARD | OBSERVE_ONLY (default: STANDARD)\n\n    Individual flags (override profile defaults):\n    - ROK_ENABLED\n    - RAC_ENABLED\n    - TRANSACTION_COORDINATOR_ENABLED\n    - EVENT_REACTOR_ENABLED\n    - MID_EXECUTION_POLICY_CHECK_ENABLED\n    - RAC_DURABILITY_ENFORCE (STRICT only)\n    - PHASE_STATUS_INVARIANT_ENFORCE (STRICT only)",
        "functions": [
          {
            "name": "_get_bool_env",
            "signature": "(name: str, default: bool) -> bool",
            "docstring": "Get boolean from environment variable.",
            "is_async": false,
            "line": 246
          },
          {
            "name": "get_governance_profile",
            "signature": "() -> GovernanceProfile",
            "docstring": "Get the current governance profile from environment.\n\nReturns:\n    GovernanceProfile enum value",
            "is_async": false,
            "line": 254
          },
          {
            "name": "load_governance_config",
            "signature": "() -> GovernanceConfig",
            "docstring": "Load complete governance configuration.\n\nLoads profile defaults, then applies any environment variable overrides.\n\nReturns:\n    GovernanceConfig with all settings",
            "is_async": false,
            "line": 276
          },
          {
            "name": "validate_governance_config",
            "signature": "(config: Optional[GovernanceConfig] = None) -> List[str]",
            "docstring": "Validate governance configuration for invalid combinations.\n\nArgs:\n    config: Configuration to validate (loads from env if not provided)\n\nReturns:\n    List of warning messages (empty if valid)\n\nRaises:\n    GovernanceConfigError: If configuration has blocking violations",
            "is_async": false,
            "line": 326
          },
          {
            "name": "get_governance_config",
            "signature": "() -> GovernanceConfig",
            "docstring": "Get the validated governance configuration singleton.\n\nLoads and validates on first call, caches thereafter.\n\nReturns:\n    Validated GovernanceConfig",
            "is_async": false,
            "line": 411
          },
          {
            "name": "reset_governance_config",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 427
          },
          {
            "name": "validate_governance_at_startup",
            "signature": "() -> None",
            "docstring": "Validate governance configuration at application startup.\n\nCall this from main.py during FastAPI lifespan startup.\n\nRaises:\n    GovernanceConfigError: If configuration is invalid",
            "is_async": false,
            "line": 438
          }
        ],
        "classes": [
          {
            "name": "GovernanceProfile",
            "docstring": "Pre-defined governance profiles.\n\nEach profile represents a coherent set of feature flag settings\ndesigned for specific deployment scenarios.",
            "methods": [],
            "line": 68
          },
          {
            "name": "GovernanceConfig",
            "docstring": "Complete governance configuration derived from profile + overrides.",
            "methods": [
              "to_dict"
            ],
            "line": 110
          },
          {
            "name": "GovernanceConfigError",
            "docstring": "Raised when governance configuration is invalid.",
            "methods": [
              "__init__"
            ],
            "line": 233
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "FrozenSet",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "rate_limiter.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/rate_limiter.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 184,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_rate_limiter",
            "signature": "() -> RateLimiter",
            "docstring": "Get the singleton rate limiter instance.",
            "is_async": false,
            "line": 166
          },
          {
            "name": "allow_request",
            "signature": "(key: str, rate_per_min: int) -> bool",
            "docstring": "Convenience function to check rate limit.\n\nArgs:\n    key: Rate limit key\n    rate_per_min: Max requests per minute\n\nReturns:\n    True if allowed",
            "is_async": false,
            "line": 174
          }
        ],
        "classes": [
          {
            "name": "RateLimiter",
            "docstring": "Token bucket rate limiter using Redis.\n\nProvides per-key rate limiting with configurable RPM.\nFalls back to allowing requests if Redis is unavailable.",
            "methods": [
              "__init__",
              "_get_client",
              "allow",
              "get_remaining"
            ],
            "line": 60
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [
          {
            "name": "REDIS_URL",
            "line": 31
          },
          {
            "name": "TOKEN_BUCKET_LUA",
            "line": 34
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "retrieval_facade.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/retrieval_facade.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 518,
        "module_docstring": "Retrieval Facade (L4 Domain Logic)\n\nThis facade provides the external interface for mediated data retrieval operations.\nAll retrieval APIs MUST use this facade instead of directly importing\nthe RetrievalMediator.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes retrieval mediation logic\n- Provides unified access to data retrieval with policy enforcement\n- Single point for audit emission\n\nWrapped Services:\n- RetrievalMediator: Central choke point for data access (GAP-065)\n\nL2 API Routes (GAP-094):\n- POST /api/v1/retrieval/access (mediated data access)\n- GET /api/v1/retrieval/planes (list available planes)\n- GET /api/v1/retrieval/evidence (retrieve evidence records)\n\nUsage:\n    from app.services.retrieval.facade import get_retrieval_facade\n\n    facade = get_retrieval_facade()\n\n    # Mediated data access\n    result = await facade.access_data(\n        tenant_id=\"...\",\n        run_id=\"...\",\n        plane_id=\"documents\",\n        action=\"query\",\n        payload={\"query\": \"...\"},\n    )\n\n    # List available planes\n    planes = await facade.list_planes(tenant_id=\"...\")",
        "functions": [
          {
            "name": "get_retrieval_facade",
            "signature": "() -> RetrievalFacade",
            "docstring": "Get the retrieval facade instance.\n\nThis is the recommended way to access retrieval operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    RetrievalFacade instance",
            "is_async": false,
            "line": 505
          }
        ],
        "classes": [
          {
            "name": "AccessResult",
            "docstring": "Result of a mediated data access.",
            "methods": [
              "to_dict"
            ],
            "line": 67
          },
          {
            "name": "PlaneInfo",
            "docstring": "Information about a knowledge plane.",
            "methods": [
              "to_dict"
            ],
            "line": 97
          },
          {
            "name": "EvidenceInfo",
            "docstring": "Evidence record information.",
            "methods": [
              "to_dict"
            ],
            "line": 119
          },
          {
            "name": "RetrievalFacade",
            "docstring": "Facade for mediated data retrieval operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nthe retrieval mediator.\n\nLayer: L4 (Domain Logic)\nCallers: retrieval.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "mediator",
              "access_data",
              "list_planes",
              "register_plane",
              "get_plane",
              "list_evidence",
              "get_evidence",
              "record_evidence"
            ],
            "line": 148
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "retrieval_mediator.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/retrieval_mediator.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 471,
        "module_docstring": "Module: retrieval_mediator\nPurpose: All external data access must route through this layer.\n\nThis is the CENTRAL CHOKE POINT for data retrieval.\nAny data access from LLM-controlled code MUST go through here.\n\nImports (Dependencies):\n    - None (interfaces defined here, implementations injected)\n\nExports (Provides):\n    - RetrievalMediator: Main mediation class\n    - MediatedResult: Result of a mediated access\n    - MediationDeniedError: Raised when access denied\n    - get_retrieval_mediator(): Factory to get singleton\n\nWiring Points:\n    - Called from: L2 API route /api/v1/mediation/access\n    - Calls: PolicyEngine (injected), ConnectorRegistry (injected)\n\nInvariant: Deny-by-default. All access blocked unless explicitly allowed.\n\nAcceptance Criteria:\n    - [x] AC-065-01: All data access routes through mediator\n    - [x] AC-065-02: Deny-by-default enforced\n    - [x] AC-065-03: Evidence emitted for every access\n    - [x] AC-065-04: Policy check before connector\n    - [x] AC-065-05: Tenant isolation enforced",
        "functions": [
          {
            "name": "get_retrieval_mediator",
            "signature": "() -> RetrievalMediator",
            "docstring": "Get or create the singleton RetrievalMediator.\n\nIn production, this should be configured with real implementations\nof PolicyChecker, ConnectorRegistry, and EvidenceService.",
            "is_async": false,
            "line": 431
          },
          {
            "name": "configure_retrieval_mediator",
            "signature": "(policy_checker: Optional[PolicyChecker] = None, connector_registry: Optional[ConnectorRegistry] = None, evidence_service: Optional[EvidenceService] = None) -> RetrievalMediator",
            "docstring": "Configure the singleton RetrievalMediator with dependencies.\n\nCall this at startup to inject real implementations.",
            "is_async": false,
            "line": 447
          }
        ],
        "classes": [
          {
            "name": "MediationAction",
            "docstring": "Allowed mediation actions.",
            "methods": [],
            "line": 59
          },
          {
            "name": "MediatedResult",
            "docstring": "Result of a mediated data access.",
            "methods": [],
            "line": 68
          },
          {
            "name": "PolicyCheckResult",
            "docstring": "Result of policy check.",
            "methods": [],
            "line": 82
          },
          {
            "name": "EvidenceRecord",
            "docstring": "Evidence record for a mediated access.",
            "methods": [],
            "line": 91
          },
          {
            "name": "MediationDeniedError",
            "docstring": "Raised when mediation denies access.",
            "methods": [
              "__init__"
            ],
            "line": 105
          },
          {
            "name": "Connector",
            "docstring": "Protocol for connectors.",
            "methods": [
              "execute"
            ],
            "line": 123
          },
          {
            "name": "ConnectorRegistry",
            "docstring": "Protocol for connector registry.",
            "methods": [
              "resolve"
            ],
            "line": 133
          },
          {
            "name": "PolicyChecker",
            "docstring": "Protocol for policy checking.",
            "methods": [
              "check_access"
            ],
            "line": 146
          },
          {
            "name": "EvidenceService",
            "docstring": "Protocol for evidence recording.",
            "methods": [
              "record"
            ],
            "line": 161
          },
          {
            "name": "RetrievalMediator",
            "docstring": "Unified mediation layer for all external data access.\n\nFlow:\n1. Receive access request (plane_id, action, payload)\n2. Tenant isolation check\n3. Policy check (deny-by-default)\n4. Connector resolution (plane -> data source)\n5. Execute access through connector\n6. Emit retrieval evidence\n7. Return result\n\nAll data access from LLM-controlled code MUST go through this layer.",
            "methods": [
              "__init__",
              "access",
              "_check_policy",
              "_resolve_connector",
              "_record_evidence",
              "_hash_payload"
            ],
            "line": 180
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "runtime.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/runtime.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 68,
        "module_docstring": "Runtime Utilities - Centralized Shared Helpers\n\nCANONICAL LOCATION: All code needing generate_uuid() or utc_now() must import from here.\nDO NOT define these functions elsewhere.\nDO NOT import them transitively through other modules.\n\nThis prevents import hygiene violations where services fail at runtime\nbecause they relied on transitive imports that aren't guaranteed.\n\nSee LESSONS_ENFORCED.md Invariant #5: Import Locality",
        "functions": [
          {
            "name": "generate_uuid",
            "signature": "() -> str",
            "docstring": "Generate a UUID string.\n\nCANONICAL LOCATION: Import from app.utils.runtime, not from other modules.",
            "is_async": false,
            "line": 37
          },
          {
            "name": "utc_now",
            "signature": "() -> datetime",
            "docstring": "Return timezone-aware UTC datetime.\n\nCANONICAL LOCATION: Import from app.utils.runtime, not from other modules.\n\nFor asyncpg compatibility in raw SQL, use utc_now_naive() instead.",
            "is_async": false,
            "line": 46
          },
          {
            "name": "utc_now_naive",
            "signature": "() -> datetime",
            "docstring": "Return timezone-naive UTC datetime (for asyncpg raw SQL compatibility).\n\nUse this ONLY when:\n- Writing raw SQL with asyncpg\n- You explicitly need a naive datetime\n\nFor all other cases, prefer utc_now().",
            "is_async": false,
            "line": 57
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "scheduler_facade.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/scheduler_facade.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 552,
        "module_docstring": "Scheduler Facade (L4 Domain Logic)\n\nThis facade provides the external interface for scheduled job operations.\nAll scheduler APIs MUST use this facade instead of directly importing\ninternal scheduler modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes job scheduling logic\n- Provides unified access to job management\n- Single point for audit emission\n\nL2 API Routes (GAP-112):\n- POST /api/v1/scheduler/jobs (create job)\n- GET /api/v1/scheduler/jobs (list jobs)\n- GET /api/v1/scheduler/jobs/{id} (get job)\n- PUT /api/v1/scheduler/jobs/{id} (update job)\n- DELETE /api/v1/scheduler/jobs/{id} (delete job)\n- POST /api/v1/scheduler/jobs/{id}/trigger (trigger job)\n- POST /api/v1/scheduler/jobs/{id}/pause (pause job)\n- POST /api/v1/scheduler/jobs/{id}/resume (resume job)\n- GET /api/v1/scheduler/jobs/{id}/runs (job run history)\n\nUsage:\n    # L5 engine import (migrated to HOC per SWEEP-10)\n    from app.hoc.cus.general.L5_engines.scheduler_facade import get_scheduler_facade\n\n    facade = get_scheduler_facade()\n\n    # Create scheduled job\n    job = await facade.create_job(\n        tenant_id=\"...\",\n        name=\"Daily Report\",\n        schedule=\"0 9 * * *\",\n        action={\"type\": \"run_agent\", \"agent_id\": \"...\"},\n    )",
        "functions": [
          {
            "name": "get_scheduler_facade",
            "signature": "() -> SchedulerFacade",
            "docstring": "Get the scheduler facade instance.\n\nThis is the recommended way to access scheduler operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    SchedulerFacade instance",
            "is_async": false,
            "line": 539
          }
        ],
        "classes": [
          {
            "name": "JobStatus",
            "docstring": "Job status.",
            "methods": [],
            "line": 69
          },
          {
            "name": "JobRunStatus",
            "docstring": "Job run status.",
            "methods": [],
            "line": 76
          },
          {
            "name": "ScheduledJob",
            "docstring": "Scheduled job definition.",
            "methods": [
              "to_dict"
            ],
            "line": 86
          },
          {
            "name": "JobRun",
            "docstring": "Job run history entry.",
            "methods": [
              "to_dict"
            ],
            "line": 124
          },
          {
            "name": "SchedulerFacade",
            "docstring": "Facade for scheduled job operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nscheduler services.\n\nLayer: L4 (Domain Logic)\nCallers: scheduler.py (L2), aos_sdk, Worker",
            "methods": [
              "__init__",
              "create_job",
              "list_jobs",
              "get_job",
              "update_job",
              "delete_job",
              "trigger_job",
              "pause_job",
              "resume_job",
              "list_runs",
              "get_run",
              "_calculate_next_run"
            ],
            "line": 151
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 64
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "webhook_verify.py",
        "file_path": "backend/app/hoc/cus/general/L5_engines/webhook_verify.py",
        "layer": "L5_engines",
        "domain": "general",
        "lines": 294,
        "module_docstring": "Webhook Signature Verification Utility\n\nProvides HMAC-SHA256 signature verification for webhook receivers with\nsupport for key versioning and grace periods during rotation.\n\nUsage (FastAPI example):\n    from app.utils.webhook_verify import WebhookVerifier\n\n    verifier = WebhookVerifier(keys={\n        \"v1\": \"old_key_hex...\",\n        \"v2\": \"new_key_hex...\",\n    }, current_version=\"v2\", grace_versions=[\"v1\"])\n\n    @app.post(\"/webhook\")\n    async def receive_webhook(request: Request):\n        body = await request.body()\n        signature = request.headers.get(\"X-Webhook-Signature\")\n        key_version = request.headers.get(\"X-Webhook-Key-Version\")\n\n        if not verifier.verify(body, signature, key_version):\n            raise HTTPException(status_code=401, detail=\"Invalid signature\")\n        # Process webhook...",
        "functions": [
          {
            "name": "create_file_key_loader",
            "signature": "(keys_path: str) -> Callable[[str], Optional[str]]",
            "docstring": "Create a key loader that reads from files.\n\nArgs:\n    keys_path: Directory containing key files (e.g., /var/lib/aos/webhook-keys)\n\nReturns:\n    Function that loads key hex string for a version",
            "is_async": false,
            "line": 213
          },
          {
            "name": "create_vault_key_loader",
            "signature": "(mount_path: str = 'secret', secret_path: str = 'webhook/keys') -> Callable[[str], Optional[str]]",
            "docstring": "Create a key loader that reads from Vault.\n\nRequires hvac library: pip install hvac\n\nArgs:\n    mount_path: Vault KV v2 mount path\n    secret_path: Path to secret within mount\n\nReturns:\n    Function that loads key hex string for a version",
            "is_async": false,
            "line": 233
          },
          {
            "name": "verify_webhook",
            "signature": "(body: bytes, signature: str, key_version: Optional[str], keys: Dict[str, str], grace_versions: Optional[List[str]] = None) -> bool",
            "docstring": "Quick verification without creating a WebhookVerifier instance.\n\nArgs:\n    body: Raw request body\n    signature: X-Webhook-Signature header\n    key_version: X-Webhook-Key-Version header\n    keys: Dict of version -> hex key\n    grace_versions: List of grace period versions\n\nReturns:\n    True if valid",
            "is_async": false,
            "line": 270
          }
        ],
        "classes": [
          {
            "name": "WebhookVerifier",
            "docstring": "Webhook signature verifier with key version support.\n\nSupports zero-downtime key rotation by accepting:\n1. The specified key version from X-Webhook-Key-Version header\n2. Grace period versions during rotation\n3. Current version as fallback if no header provided",
            "methods": [
              "__init__",
              "_parse_grace_env",
              "_get_key",
              "_compute_signature",
              "verify",
              "sign"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Callable",
              "Dict",
              "List",
              "Optional",
              "Union"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [
      {
        "file_name": "agent.py",
        "file_path": "backend/app/hoc/cus/general/L5_schemas/agent.py",
        "layer": "L5_schemas",
        "domain": "general",
        "lines": 229,
        "module_docstring": null,
        "functions": [
          {
            "name": "_utc_now",
            "signature": "() -> datetime",
            "docstring": "Return timezone-aware UTC datetime.",
            "is_async": false,
            "line": 30
          }
        ],
        "classes": [
          {
            "name": "AgentStatus",
            "docstring": "Agent operational status.",
            "methods": [],
            "line": 38
          },
          {
            "name": "PlannerType",
            "docstring": "Supported planner backends.",
            "methods": [],
            "line": 47
          },
          {
            "name": "PlannerConfig",
            "docstring": "Configuration for the agent's planner.\n\nControls how goals are translated into execution plans.",
            "methods": [],
            "line": 57
          },
          {
            "name": "RateLimitConfig",
            "docstring": "Rate limiting configuration for an agent.",
            "methods": [],
            "line": 84
          },
          {
            "name": "BudgetConfig",
            "docstring": "Budget tracking configuration for an agent.",
            "methods": [
              "remaining_cents",
              "usage_percent"
            ],
            "line": 94
          },
          {
            "name": "AgentCapabilities",
            "docstring": "Defines what an agent can and cannot do.\n\nControls access to skills, external resources,\nand establishes security boundaries.",
            "methods": [
              "can_use_skill",
              "can_access_domain"
            ],
            "line": 119
          },
          {
            "name": "AgentConfig",
            "docstring": "Complete configuration for an agent.\n\nCombines capabilities, planner settings, rate limits,\nand budget tracking.",
            "methods": [],
            "line": 188
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "ConfigDict",
              "Field"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "retry",
            "names": [
              "RetryPolicy"
            ],
            "is_relative": true,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "artifact.py",
        "file_path": "backend/app/hoc/cus/general/L5_schemas/artifact.py",
        "layer": "L5_schemas",
        "domain": "general",
        "lines": 156,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "ArtifactType",
            "docstring": "Type of artifact produced by a run.",
            "methods": [],
            "line": 32
          },
          {
            "name": "StorageBackend",
            "docstring": "Where the artifact is stored.",
            "methods": [],
            "line": 47
          },
          {
            "name": "Artifact",
            "docstring": "An artifact produced by a run or step.\n\nArtifacts capture outputs, files, and data produced\nduring execution for later retrieval and analysis.",
            "methods": [
              "is_inline",
              "has_content",
              "get_inline_content"
            ],
            "line": 56
          },
          {
            "name": "ArtifactReference",
            "docstring": "Lightweight reference to an artifact.\n\nUsed when you need to reference an artifact without\nloading its full content.",
            "methods": [
              "from_artifact"
            ],
            "line": 132
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "ConfigDict",
              "Field"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "common.py",
        "file_path": "backend/app/hoc/cus/general/L5_schemas/common.py",
        "layer": "L5_schemas",
        "domain": "general",
        "lines": 155,
        "module_docstring": "Common Data Contracts - Shared Infrastructure Types\n\nThese are NON-DOMAIN contracts used by both consoles:\n- Health checks\n- Error responses\n- Pagination\n\nThese are the ONLY contracts allowed to be shared between domains.\nDomain-specific data MUST NOT be in this module.\n\nFrozen: 2025-12-23 (M29)",
        "functions": [],
        "classes": [
          {
            "name": "HealthDTO",
            "docstring": "GET /health response.\n\nNon-authenticated health check.",
            "methods": [],
            "line": 44
          },
          {
            "name": "HealthDetailDTO",
            "docstring": "GET /health/detail response (if authenticated).\n\nDetailed health with component status.",
            "methods": [],
            "line": 56
          },
          {
            "name": "ErrorDTO",
            "docstring": "Standard error response.\n\nAll 4xx/5xx responses use this format.",
            "methods": [],
            "line": 75
          },
          {
            "name": "ValidationErrorDTO",
            "docstring": "422 Validation error response.\n\nPydantic validation errors.",
            "methods": [],
            "line": 88
          },
          {
            "name": "PaginationMetaDTO",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 105
          },
          {
            "name": "CursorPaginationMetaDTO",
            "docstring": "Cursor-based pagination metadata.",
            "methods": [],
            "line": 116
          },
          {
            "name": "ActionResultDTO",
            "docstring": "Generic action result (activate, deactivate, etc.).",
            "methods": [],
            "line": 130
          },
          {
            "name": "ContractVersionDTO",
            "docstring": "GET /api/v1/contracts/version response.\n\nContract version for client compatibility checks.",
            "methods": [],
            "line": 145
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "plan.py",
        "file_path": "backend/app/hoc/cus/general/L5_schemas/plan.py",
        "layer": "L5_schemas",
        "domain": "general",
        "lines": 257,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "OnErrorPolicy",
            "docstring": "What to do when a step fails.",
            "methods": [],
            "line": 35
          },
          {
            "name": "StepStatus",
            "docstring": "Execution status of a plan step.",
            "methods": [],
            "line": 44
          },
          {
            "name": "ConditionOperator",
            "docstring": "Operators for step conditions.",
            "methods": [],
            "line": 55
          },
          {
            "name": "StepCondition",
            "docstring": "Condition for conditional step execution.\n\nAllows steps to be skipped based on previous step outputs.",
            "methods": [],
            "line": 68
          },
          {
            "name": "PlanStep",
            "docstring": "A single step in an execution plan.\n\nDefines what skill to run, with what parameters,\ndependencies, conditions, and error handling.",
            "methods": [
              "validate_fallback"
            ],
            "line": 80
          },
          {
            "name": "PlanMetadata",
            "docstring": "Metadata about the plan and how it was created.",
            "methods": [],
            "line": 149
          },
          {
            "name": "Plan",
            "docstring": "Complete execution plan for achieving a goal.\n\nThe plan is the contract between planner and executor.\nIt defines what steps to run and in what order.",
            "methods": [
              "validate_step_ids_unique",
              "validate_dependencies",
              "get_step",
              "get_ready_steps"
            ],
            "line": 163
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "ConfigDict",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "retry",
            "names": [
              "RetryPolicy"
            ],
            "is_relative": true,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "rac_models.py",
        "file_path": "backend/app/hoc/cus/general/L5_schemas/rac_models.py",
        "layer": "L5_schemas",
        "domain": "general",
        "lines": 408,
        "module_docstring": "Runtime Audit Contract (RAC) Models\n\nThese models define the data structures for the audit system:\n\n- AuditExpectation: Declares what action MUST happen for a run\n- DomainAck: Reports that an action has completed\n- ReconciliationResult: Result of comparing expectations vs acks\n\nDesign Principles:\n1. Immutable after creation (expectations are contracts)\n2. UUID-based for correlation across domains\n3. Serializable for Redis storage\n4. Type-safe with enums for domains and actions",
        "functions": [
          {
            "name": "create_run_expectations",
            "signature": "(run_id: UUID, run_timeout_ms: int = 30000, grace_period_ms: int = 5000) -> List[AuditExpectation]",
            "docstring": "Create the standard set of expectations for a run.\n\nThis is called by ROK at T0 (run creation) to declare\nwhat MUST happen during run execution.\n\nArgs:\n    run_id: The run ID\n    run_timeout_ms: Expected run duration\n    grace_period_ms: Grace period after run timeout\n\nReturns:\n    List of AuditExpectation objects",
            "is_async": false,
            "line": 304
          },
          {
            "name": "create_domain_ack",
            "signature": "(run_id: UUID, domain: AuditDomain, action: AuditAction, result_id: Optional[str] = None, error: Optional[str] = None, **metadata: Any) -> DomainAck",
            "docstring": "Create a domain acknowledgment.\n\nThis is called by facades after completing domain operations.\n\nArgs:\n    run_id: The run ID\n    domain: Which domain performed the action\n    action: What action was performed\n    result_id: ID of created entity (e.g., incident_id)\n    error: Error message if action failed\n    **metadata: Additional context\n\nReturns:\n    DomainAck object",
            "is_async": false,
            "line": 357
          }
        ],
        "classes": [
          {
            "name": "AuditStatus",
            "docstring": "Status of an audit expectation.",
            "methods": [],
            "line": 43
          },
          {
            "name": "AuditDomain",
            "docstring": "Domains that participate in the audit contract.",
            "methods": [],
            "line": 52
          },
          {
            "name": "AuditAction",
            "docstring": "Actions that can be expected/acked.",
            "methods": [],
            "line": 61
          },
          {
            "name": "AuditExpectation",
            "docstring": "An expectation that an action MUST happen for a run.\n\nCreated at run start (T0) by ROK, one per expected domain action.\nThe finalize_run expectation is the liveness guarantee.\n\nAttributes:\n    id: Unique expectation ID\n    run_id: The run this expectation belongs to\n    domain: Which domain should perform the action\n    action: What action is expected\n    status: Current status (PENDING -> ACKED | MISSING | FAILED)\n    deadline_ms: Time allowed for ack (from creation)\n    created_at: When this expectation was created\n    acked_at: When the ack was received (if any)\n    metadata: Additional context (e.g., expected result type)",
            "methods": [
              "to_dict",
              "from_dict",
              "key"
            ],
            "line": 79
          },
          {
            "name": "AckStatus",
            "docstring": "Status of a domain acknowledgment.",
            "methods": [],
            "line": 142
          },
          {
            "name": "DomainAck",
            "docstring": "Acknowledgment that a domain action has completed.\n\nEmitted by facades after successful domain operations.\nMatched against expectations during reconciliation.\n\nAttributes:\n    id: Unique ack ID\n    run_id: The run this ack belongs to\n    domain: Which domain performed the action\n    action: What action was performed\n    status: Status of the ack (SUCCESS, FAILED, ROLLED_BACK)\n    result_id: ID of the created entity (e.g., incident_id)\n    error: Error message if action failed\n    rolled_back: True if this action was rolled back (audit trail)\n    rollback_reason: Why the action was rolled back\n    created_at: When this ack was created\n    metadata: Additional context (e.g., execution time)",
            "methods": [
              "is_success",
              "is_rolled_back",
              "to_dict",
              "from_dict",
              "key"
            ],
            "line": 151
          },
          {
            "name": "ReconciliationResult",
            "docstring": "Result of reconciling expectations against acknowledgments.\n\nProduced by AuditReconciler after comparing what was expected\nvs what actually happened.\n\nAttributes:\n    run_id: The run that was reconciled\n    status: Overall status (COMPLETE, INCOMPLETE, STALE)\n    missing_actions: Actions expected but not acked\n    drift_actions: Actions acked but not expected\n    failed_actions: Actions acked with errors\n    stale_run: True if finalize_run was never acked\n    reconciled_at: When reconciliation was performed\n    expectations_count: Total expectations\n    acks_count: Total acks received",
            "methods": [
              "is_clean",
              "has_missing",
              "has_drift",
              "to_dict"
            ],
            "line": 233
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "uuid",
            "names": [
              "UUID",
              "uuid4"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": [
          "AckStatus",
          "AuditAction",
          "AuditDomain",
          "AuditStatus",
          "AuditExpectation",
          "DomainAck",
          "ReconciliationResult",
          "create_domain_ack",
          "create_run_expectations"
        ]
      },
      {
        "file_name": "response.py",
        "file_path": "backend/app/hoc/cus/general/L5_schemas/response.py",
        "layer": "L5_schemas",
        "domain": "general",
        "lines": 340,
        "module_docstring": "Standard API Response Envelope\n\nThis module provides the standard response format for all API endpoints.\nConsistent response structures enable:\n- Predictable error handling in clients\n- Request tracing via metadata\n- Pagination support\n- SDK code generation\n\nStandard format:\n    {\n        \"success\": true,\n        \"data\": { ... },\n        \"meta\": {\n            \"timestamp\": \"2024-01-15T10:30:00Z\",\n            \"request_id\": \"req-abc123\"\n        }\n    }\n\nUsage:\n    from app.schemas.response import ResponseEnvelope, ok, error, paginated\n\n    # Simple success response\n    @router.get(\"/items/{id}\")\n    async def get_item(id: str) -> ResponseEnvelope:\n        item = await fetch_item(id)\n        return ok(item)\n\n    # Error response\n    @router.get(\"/items/{id}\")\n    async def get_item(id: str) -> ResponseEnvelope:\n        item = await fetch_item(id)\n        if not item:\n            return error(\"Item not found\", code=\"NOT_FOUND\")\n        return ok(item)\n\n    # Paginated response\n    @router.get(\"/items\")\n    async def list_items(page: int = 1) -> ResponseEnvelope:\n        items, total = await fetch_items_paginated(page)\n        return paginated(items, total=total, page=page, page_size=20)",
        "functions": [
          {
            "name": "ok",
            "signature": "(data: Any, request_id: Optional[str] = None) -> ResponseEnvelope",
            "docstring": "Create a successful response envelope.\n\nArgs:\n    data: The response payload\n    request_id: Optional request ID (auto-generated if not provided)\n\nReturns:\n    ResponseEnvelope with success=True",
            "is_async": false,
            "line": 122
          },
          {
            "name": "error",
            "signature": "(message: str, code: Optional[str] = None, details: Optional[Dict[str, Any]] = None, request_id: Optional[str] = None) -> ResponseEnvelope",
            "docstring": "Create an error response envelope.\n\nArgs:\n    message: Human-readable error message\n    code: Machine-readable error code\n    details: Additional error context\n    request_id: Optional request ID (auto-generated if not provided)\n\nReturns:\n    ResponseEnvelope with success=False",
            "is_async": false,
            "line": 144
          },
          {
            "name": "paginated",
            "signature": "(items: List[Any], total: int, page: int = 1, page_size: int = 20, request_id: Optional[str] = None) -> ResponseEnvelope",
            "docstring": "Create a paginated response envelope.\n\nArgs:\n    items: List of items for current page\n    total: Total count of all items\n    page: Current page number (1-indexed)\n    page_size: Number of items per page\n    request_id: Optional request ID (auto-generated if not provided)\n\nReturns:\n    ResponseEnvelope with pagination metadata",
            "is_async": false,
            "line": 180
          },
          {
            "name": "wrap_dict",
            "signature": "(data: Dict[str, Any], request_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Wrap a dictionary in the standard envelope format.\n\nUse this when you need a dict instead of Pydantic model (e.g., for legacy endpoints).\n\nArgs:\n    data: Dictionary to wrap (MUST be finalized output, see warnings below)\n    request_id: Optional request ID\n\nReturns:\n    Dictionary with envelope structure\n\nWARNING - API-002-CR-001 (Counter-rule):\n    `data` must ONLY be:\n    1. model_dump() output from Pydantic models\n    2. Fully constructed response dictionaries\n\n    NEVER pass:\n    - Raw ORM/SQLModel entities\n    - Internal domain objects\n    - Partial computation results\n\n    Example:\n        # \u2705 CORRECT\n        return wrap_dict(result.model_dump())\n        return wrap_dict({\"key\": \"value\"})\n\n        # \u274c VIOLATION\n        return wrap_dict(orm_entity)\n        return wrap_dict(partial_result)\n\nWARNING - API-002-CR-002 (Counter-rule for lists):\n    When using {\"items\": [...], \"total\": len(results)}:\n    - Valid ONLY for non-paginated endpoints\n    - For paginated endpoints, total MUST come from COUNT(*) query\n\nReference: docs/architecture/GOVERNANCE_GUARDRAILS.md (API-002)",
            "is_async": false,
            "line": 216
          },
          {
            "name": "wrap_list",
            "signature": "(items: List[Any], total: Optional[int] = None, page: Optional[int] = None, page_size: Optional[int] = None, request_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Wrap a list in the standard envelope format.\n\nUse this when you need a dict instead of Pydantic model.\n\nArgs:\n    items: List to wrap\n    total: Optional total count for pagination\n    page: Optional current page\n    page_size: Optional page size\n    request_id: Optional request ID\n\nReturns:\n    Dictionary with envelope structure",
            "is_async": false,
            "line": 265
          },
          {
            "name": "wrap_error",
            "signature": "(message: str, code: Optional[str] = None, details: Optional[Dict[str, Any]] = None, request_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Create an error response as a dictionary.\n\nArgs:\n    message: Error message\n    code: Error code\n    details: Additional context\n    request_id: Optional request ID\n\nReturns:\n    Dictionary with error envelope structure",
            "is_async": false,
            "line": 308
          }
        ],
        "classes": [
          {
            "name": "ResponseMeta",
            "docstring": "Metadata included with every response.",
            "methods": [],
            "line": 73
          },
          {
            "name": "ResponseEnvelope",
            "docstring": "Standard API response envelope.\n\nAll API endpoints should return this structure for consistency.",
            "methods": [],
            "line": 91
          },
          {
            "name": "ErrorDetail",
            "docstring": "Structured error information.",
            "methods": [],
            "line": 108
          }
        ],
        "imports": [
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Generic",
              "List",
              "Optional",
              "TypeVar"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 68
          }
        ],
        "constants": [
          {
            "name": "T",
            "line": 70
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "retry.py",
        "file_path": "backend/app/hoc/cus/general/L5_schemas/retry.py",
        "layer": "L5_schemas",
        "domain": "general",
        "lines": 88,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "BackoffStrategy",
            "docstring": "Backoff strategy for retries.",
            "methods": [],
            "line": 21
          },
          {
            "name": "RetryPolicy",
            "docstring": "Retry policy configuration for skills and steps.\n\nDefines how failures should be retried, including\nmax attempts, delays, and backoff strategies.",
            "methods": [
              "get_delay",
              "_fibonacci"
            ],
            "line": 30
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 15
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 16
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "ConfigDict",
              "Field"
            ],
            "is_relative": false,
            "line": 18
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "skill.py",
        "file_path": "backend/app/hoc/cus/general/L5_schemas/skill.py",
        "layer": "L5_schemas",
        "domain": "general",
        "lines": 457,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "SkillStatus",
            "docstring": "Skill execution status.",
            "methods": [],
            "line": 30
          },
          {
            "name": "SkillInputBase",
            "docstring": "Base class for all skill inputs.\n\nAll skill-specific inputs should inherit from this.\nProvides common validation and serialization.",
            "methods": [],
            "line": 40
          },
          {
            "name": "SkillOutputBase",
            "docstring": "Base class for all skill outputs.\n\nProvides consistent structure for all skill results.",
            "methods": [],
            "line": 50
          },
          {
            "name": "HttpMethod",
            "docstring": "Supported HTTP methods.",
            "methods": [],
            "line": 72
          },
          {
            "name": "HttpCallInput",
            "docstring": "Input schema for http_call skill.",
            "methods": [
              "validate_url"
            ],
            "line": 84
          },
          {
            "name": "HttpCallOutput",
            "docstring": "Output schema for http_call skill.",
            "methods": [],
            "line": 103
          },
          {
            "name": "LLMProvider",
            "docstring": "Supported LLM providers.",
            "methods": [],
            "line": 119
          },
          {
            "name": "LLMMessage",
            "docstring": "A single message in the LLM conversation.",
            "methods": [],
            "line": 127
          },
          {
            "name": "LLMInvokeInput",
            "docstring": "Input schema for llm_invoke skill.",
            "methods": [],
            "line": 134
          },
          {
            "name": "LLMInvokeOutput",
            "docstring": "Output schema for llm_invoke skill.",
            "methods": [],
            "line": 147
          },
          {
            "name": "FileReadInput",
            "docstring": "Input schema for file_read skill.",
            "methods": [],
            "line": 165
          },
          {
            "name": "FileReadOutput",
            "docstring": "Output schema for file_read skill.",
            "methods": [],
            "line": 173
          },
          {
            "name": "FileWriteInput",
            "docstring": "Input schema for file_write skill.",
            "methods": [],
            "line": 187
          },
          {
            "name": "FileWriteOutput",
            "docstring": "Output schema for file_write skill.",
            "methods": [],
            "line": 197
          },
          {
            "name": "PostgresQueryInput",
            "docstring": "Input schema for postgres_query skill.",
            "methods": [],
            "line": 209
          },
          {
            "name": "PostgresQueryOutput",
            "docstring": "Output schema for postgres_query skill.",
            "methods": [],
            "line": 219
          },
          {
            "name": "JsonTransformInput",
            "docstring": "Input schema for json_transform skill.",
            "methods": [],
            "line": 233
          },
          {
            "name": "JsonTransformOutput",
            "docstring": "Output schema for json_transform skill.",
            "methods": [],
            "line": 242
          },
          {
            "name": "EmailSendInput",
            "docstring": "Input schema for email_send skill.",
            "methods": [
              "normalize_recipients"
            ],
            "line": 255
          },
          {
            "name": "EmailSendOutput",
            "docstring": "Output schema for email_send skill.",
            "methods": [],
            "line": 283
          },
          {
            "name": "KVOperation",
            "docstring": "KV store operations.",
            "methods": [],
            "line": 297
          },
          {
            "name": "KVStoreInput",
            "docstring": "Input schema for kv_store skill.",
            "methods": [],
            "line": 310
          },
          {
            "name": "KVStoreOutput",
            "docstring": "Output schema for kv_store skill.",
            "methods": [],
            "line": 326
          },
          {
            "name": "SlackSendInput",
            "docstring": "Input schema for slack_send skill.",
            "methods": [],
            "line": 342
          },
          {
            "name": "SlackSendOutput",
            "docstring": "Output schema for slack_send skill.",
            "methods": [],
            "line": 357
          },
          {
            "name": "WebhookSendInput",
            "docstring": "Input schema for webhook_send skill.",
            "methods": [
              "validate_webhook_url"
            ],
            "line": 370
          },
          {
            "name": "WebhookSendOutput",
            "docstring": "Output schema for webhook_send skill.",
            "methods": [],
            "line": 391
          },
          {
            "name": "VoyageModel",
            "docstring": "Voyage AI embedding models.",
            "methods": [],
            "line": 406
          },
          {
            "name": "VoyageInputType",
            "docstring": "Input type for Voyage embeddings.",
            "methods": [],
            "line": 415
          },
          {
            "name": "VoyageEmbedInput",
            "docstring": "Input schema for voyage_embed skill.",
            "methods": [],
            "line": 422
          },
          {
            "name": "VoyageEmbedOutput",
            "docstring": "Output schema for voyage_embed skill.",
            "methods": [],
            "line": 433
          },
          {
            "name": "SkillMetadata",
            "docstring": "Metadata about a registered skill.",
            "methods": [],
            "line": 447
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Union"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "ConfigDict",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_other": [
      {
        "file_name": "guard_write_driver.py",
        "file_path": "backend/app/hoc/cus/general/L5_controls/drivers/guard_write_driver.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 267,
        "module_docstring": "Guard Write Driver (L6)\n\nPure database write operations for Guard Console (KillSwitch, Incidents).\n\nL4 (GuardWriteService) \u2192 L6 (this driver)\n\nResponsibilities:\n- Get/create KillSwitchState records\n- Freeze/unfreeze killswitch\n- Acknowledge/resolve incidents\n- Create demo incidents with events\n- NO business logic (L4 responsibility)\n\nReference: PIN-250, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_guard_write_driver",
            "signature": "(session: Session) -> GuardWriteDriver",
            "docstring": "Factory function to get GuardWriteDriver instance.",
            "is_async": false,
            "line": 259
          }
        ],
        "classes": [
          {
            "name": "GuardWriteDriver",
            "docstring": "L6 driver for guard write operations.\n\nPure database access - no business logic.",
            "methods": [
              "__init__",
              "get_or_create_killswitch_state",
              "freeze_killswitch",
              "unfreeze_killswitch",
              "acknowledge_incident",
              "resolve_incident",
              "create_demo_incident"
            ],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "select"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentEvent",
              "IncidentSeverity",
              "IncidentStatus",
              "KillSwitchState",
              "TriggerType"
            ],
            "is_relative": false,
            "line": 55
          }
        ],
        "constants": [],
        "all_exports": [
          "GuardWriteDriver",
          "get_guard_write_driver"
        ]
      },
      {
        "file_name": "runtime_switch.py",
        "file_path": "backend/app/hoc/cus/general/L5_controls/drivers/runtime_switch.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 279,
        "module_docstring": "Module: runtime_switch\nPurpose: Provides runtime toggle for governance. Emergency kill switch.\n\nImports (Dependencies):\n    - logging\n    - datetime\n    - threading (for atomic operations)\n\nExports (Provides):\n    - is_governance_active() -> bool\n    - disable_governance_runtime(reason, actor) -> None\n    - enable_governance_runtime(actor) -> None\n    - get_governance_state() -> GovernanceState\n    - is_degraded_mode() -> bool (GAP-070)\n    - enter_degraded_mode(reason, actor) -> None (GAP-070)\n    - exit_degraded_mode(actor) -> None (GAP-070)\n\nWiring Points:\n    - Called from: prevention_engine.py (check before enforcement)\n    - Called from: runner.py (check before accepting new runs)\n    - Called from: ops_api.py (manual toggle endpoint)\n    - Emits: governance_state_changed event\n\nAcceptance Criteria:\n    - [x] AC-069-01: Governance active by default\n    - [x] AC-069-02: Kill switch disables enforcement\n    - [x] AC-069-03: Kill switch logs critical audit\n    - [x] AC-069-04: Re-enable restores enforcement\n    - [x] AC-069-05: OPS endpoint exists\n    - [x] AC-069-06: Requires OPS permission\n    - [x] AC-069-07: State visible in health\n    - [x] AC-069-08: Thread-safe operations",
        "functions": [
          {
            "name": "is_governance_active",
            "signature": "() -> bool",
            "docstring": "Check if governance is currently active.\n\nReturns:\n    True if governance enforcement is active",
            "is_async": false,
            "line": 82
          },
          {
            "name": "is_degraded_mode",
            "signature": "() -> bool",
            "docstring": "Check if system is in degraded mode (GAP-070).\n\nDegraded mode:\n- Governance is active\n- New runs are blocked\n- Existing runs complete with WARN\n\nReturns:\n    True if in degraded mode",
            "is_async": false,
            "line": 93
          },
          {
            "name": "disable_governance_runtime",
            "signature": "(reason: str, actor: str) -> None",
            "docstring": "Emergency kill switch. Disables governance enforcement.\n\nWARNING: This allows runs to bypass policy enforcement.\nUse only for emergency incident response.\n\nArgs:\n    reason: Why governance is being disabled\n    actor: Who/what triggered the disable (user_id or \"system\")",
            "is_async": false,
            "line": 109
          },
          {
            "name": "enable_governance_runtime",
            "signature": "(actor: str) -> None",
            "docstring": "Re-enable governance after emergency.\n\nArgs:\n    actor: Who/what triggered the re-enable",
            "is_async": false,
            "line": 141
          },
          {
            "name": "enter_degraded_mode",
            "signature": "(reason: str, actor: str) -> None",
            "docstring": "GAP-070: Enter degraded mode.\n\nDegraded mode:\n- Blocks new runs\n- Existing runs complete with WARN\n- Full audit emitted\n\nArgs:\n    reason: Why entering degraded mode\n    actor: Who/what triggered degraded mode",
            "is_async": false,
            "line": 167
          },
          {
            "name": "exit_degraded_mode",
            "signature": "(actor: str) -> None",
            "docstring": "Exit degraded mode, return to normal operation.\n\nArgs:\n    actor: Who/what triggered exit from degraded mode",
            "is_async": false,
            "line": 200
          },
          {
            "name": "get_governance_state",
            "signature": "() -> dict",
            "docstring": "Get current governance state for health checks.\n\nReturns:\n    Dict with governance state details",
            "is_async": false,
            "line": 226
          },
          {
            "name": "reset_governance_state",
            "signature": "() -> None",
            "docstring": "Reset governance state to defaults (for testing).",
            "is_async": false,
            "line": 243
          },
          {
            "name": "_emit_governance_event",
            "signature": "(event_type: str, reason: str, actor: str) -> None",
            "docstring": "Emit governance state change event.\n\nArgs:\n    event_type: Type of event (governance_disabled, governance_enabled, etc.)\n    reason: Reason for the change\n    actor: Who triggered the change",
            "is_async": false,
            "line": 257
          }
        ],
        "classes": [
          {
            "name": "GovernanceState",
            "docstring": "Current governance state.",
            "methods": [],
            "line": 62
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "threading",
            "names": [
              "threading"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "degraded_mode_checker.py",
        "file_path": "backend/app/hoc/cus/general/L5_controls/engines/degraded_mode_checker.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 675,
        "module_docstring": "Module: degraded_mode_checker\nPurpose: Check and manage governance degraded mode with incident integration.\n\nWhen governance systems are unavailable or degraded, this module:\n    - Tracks the degraded state with proper metadata\n    - Creates incidents for degraded mode transitions\n    - Enforces degraded mode rules (block new runs, warn existing)\n    - Integrates with incident response for visibility\n\nDegraded Mode States:\n    - NORMAL: Governance is fully operational\n    - DEGRADED: Governance is partially unavailable\n    - CRITICAL: Governance is fully unavailable (block all)\n\nExports:\n    - GovernanceDegradedModeError: Raised when degraded mode blocks operation\n    - GovernanceDegradedModeChecker: Main checker class\n    - DegradedModeIncidentCreator: Creates incidents for degraded mode\n    - check_degraded_mode: Quick helper function\n    - enter_degraded_with_incident: Enter degraded mode with incident",
        "functions": [
          {
            "name": "check_degraded_mode",
            "signature": "(check_enabled: bool = True) -> DegradedModeCheckResponse",
            "docstring": "Quick helper to check degraded mode.\n\nArgs:\n    check_enabled: Whether checking is enabled\n\nReturns:\n    DegradedModeCheckResponse with current state",
            "is_async": false,
            "line": 605
          },
          {
            "name": "ensure_not_degraded",
            "signature": "(operation: str, check_enabled: bool = True) -> None",
            "docstring": "Quick helper to ensure not in degraded mode or raise error.\n\nArgs:\n    operation: Name of the operation being attempted\n    check_enabled: Whether checking is enabled\n\nRaises:\n    GovernanceDegradedModeError: If governance is degraded and blocking",
            "is_async": false,
            "line": 621
          },
          {
            "name": "enter_degraded_with_incident",
            "signature": "(state: DegradedModeState, reason: str, entered_by: str, new_runs_action: str = 'BLOCK', existing_runs_action: str = 'WARN') -> DegradedModeStatus",
            "docstring": "Quick helper to enter degraded mode with incident.\n\nArgs:\n    state: Degraded mode state to enter\n    reason: Reason for entering degraded mode\n    entered_by: Who/what triggered the transition\n    new_runs_action: Action for new runs\n    existing_runs_action: Action for existing runs\n\nReturns:\n    DegradedModeStatus after transition",
            "is_async": false,
            "line": 639
          },
          {
            "name": "_reset_degraded_mode_state",
            "signature": "() -> None",
            "docstring": "Reset global state (for testing only).",
            "is_async": false,
            "line": 671
          }
        ],
        "classes": [
          {
            "name": "DegradedModeCheckResult",
            "docstring": "Result of a degraded mode check.",
            "methods": [],
            "line": 45
          },
          {
            "name": "DegradedModeState",
            "docstring": "Possible degraded mode states.",
            "methods": [],
            "line": 54
          },
          {
            "name": "GovernanceDegradedModeError",
            "docstring": "Raised when governance degraded mode blocks an operation.\n\nThis error indicates that governance is in a degraded state\nand the requested operation cannot be performed.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 70
          },
          {
            "name": "DegradedModeStatus",
            "docstring": "Current degraded mode status.",
            "methods": [
              "to_dict"
            ],
            "line": 105
          },
          {
            "name": "DegradedModeCheckResponse",
            "docstring": "Response from a degraded mode check.",
            "methods": [
              "to_dict"
            ],
            "line": 130
          },
          {
            "name": "DegradedModeIncident",
            "docstring": "Incident data for degraded mode transition.",
            "methods": [],
            "line": 161
          },
          {
            "name": "DegradedModeIncidentCreator",
            "docstring": "Creates incidents for degraded mode transitions.\n\nWhen governance enters or exits degraded mode, an incident\nis created to provide visibility and audit trail.",
            "methods": [
              "__init__",
              "create_degraded_incident",
              "create_recovery_incident"
            ],
            "line": 174
          },
          {
            "name": "GovernanceDegradedModeChecker",
            "docstring": "Checks and manages governance degraded mode.\n\nGAP-070: Add DEGRADED state for incident response.\n\nThe checker validates governance availability and can enter/exit\ndegraded mode, creating incidents for visibility.\n\nUsage:\n    checker = GovernanceDegradedModeChecker(check_enabled=True)\n\n    # Check before starting a new run\n    response = checker.check()\n    if response.is_degraded:\n        handle_degraded_mode(response)\n\n    # Or ensure not degraded (raises on degraded)\n    checker.ensure_not_degraded(\"start_new_run\")\n\n    # Enter degraded mode with incident\n    checker.enter_degraded(\n        state=DegradedModeState.DEGRADED,\n        reason=\"Database connection pool exhausted\",\n        entered_by=\"health_monitor\",\n    )",
            "methods": [
              "__init__",
              "from_governance_config",
              "check_enabled",
              "get_current_status",
              "check",
              "ensure_not_degraded",
              "enter_degraded",
              "exit_degraded",
              "should_allow_new_run",
              "get_existing_run_action"
            ],
            "line": 309
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "threading",
            "names": [
              "Lock"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "FrozenSet",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard_write_engine.py",
        "file_path": "backend/app/hoc/cus/general/L5_controls/engines/guard_write_engine.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 154,
        "module_docstring": "Guard Write Engine (L5)\n\nDB write operations for Guard API.\nDelegates to GuardWriteDriver (L6) for all database access.\n\nL2 (API) \u2192 L4 (this service) \u2192 L6 (GuardWriteDriver)\n\nResponsibilities:\n- Delegate to L6 driver for data access\n- Maintain backward compatibility for callers\n\nReference: PIN-250, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [],
        "classes": [
          {
            "name": "GuardWriteService",
            "docstring": "DB write operations for Guard Console.\n\nDelegates all operations to GuardWriteDriver (L6).\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "get_or_create_killswitch_state",
              "freeze_killswitch",
              "unfreeze_killswitch",
              "acknowledge_incident",
              "resolve_incident",
              "create_demo_incident"
            ],
            "line": 62
          }
        ],
        "imports": [
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.general.L5_controls.drivers.guard_write_driver",
            "names": [
              "GuardWriteDriver",
              "get_guard_write_driver"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "execution.py",
        "file_path": "backend/app/hoc/cus/general/L5_lifecycle/drivers/execution.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 1322,
        "module_docstring": "Module: execution\nPurpose: Real execution implementations for knowledge plane lifecycle stages.\n\nWires:\n    - Source: ConnectorRegistry for data source access\n    - Target: Internal storage for processed data\n\nContains:\n    - DataIngestionExecutor (GAP-159): Real data ingestion from connectors\n    - IndexingExecutor (GAP-160): Real embedding generation and indexing\n    - ClassificationExecutor (GAP-161): Real PII detection and classification\n\nAcceptance Criteria:\n    - AC-159-01: Data read via ConnectorRegistry\n    - AC-159-02: Supports HTTP, SQL, File connector types\n    - AC-159-03: Progress reported via JobProgressTracker\n    - AC-159-04: Failures captured with retry support\n    - AC-160-01: Embeddings generated for text content\n    - AC-160-02: Vectors stored in VectorConnector\n    - AC-160-03: Metadata indexed for search\n    - AC-161-01: PII patterns detected\n    - AC-161-02: Sensitivity levels assigned\n    - AC-161-03: Classification evidence emitted",
        "functions": [
          {
            "name": "get_ingestion_executor",
            "signature": "() -> DataIngestionExecutor",
            "docstring": "Get or create the singleton DataIngestionExecutor.",
            "is_async": false,
            "line": 1287
          },
          {
            "name": "get_indexing_executor",
            "signature": "() -> IndexingExecutor",
            "docstring": "Get or create the singleton IndexingExecutor.",
            "is_async": false,
            "line": 1297
          },
          {
            "name": "get_classification_executor",
            "signature": "() -> ClassificationExecutor",
            "docstring": "Get or create the singleton ClassificationExecutor.",
            "is_async": false,
            "line": 1307
          },
          {
            "name": "reset_executors",
            "signature": "() -> None",
            "docstring": "Reset all singletons (for testing).",
            "is_async": false,
            "line": 1317
          }
        ],
        "classes": [
          {
            "name": "IngestionSourceType",
            "docstring": "Types of data sources for ingestion.",
            "methods": [],
            "line": 65
          },
          {
            "name": "IngestionBatch",
            "docstring": "A batch of ingested records.",
            "methods": [
              "__post_init__"
            ],
            "line": 75
          },
          {
            "name": "IngestionResult",
            "docstring": "Result of data ingestion operation.",
            "methods": [
              "to_dict"
            ],
            "line": 96
          },
          {
            "name": "DataIngestionExecutor",
            "docstring": "Real data ingestion executor (GAP-159).\n\nReads data from configured connectors and prepares it for indexing.\n\nSupported source types:\n- HTTP: REST API endpoints via HttpConnectorService\n- SQL: Database queries via SqlGatewayService\n- FILE: File storage via FileConnector\n- VECTOR: Existing vector stores via VectorConnector",
            "methods": [
              "__init__",
              "execute",
              "_get_connector",
              "_ingest_from_http",
              "_ingest_from_sql",
              "_ingest_from_file",
              "_ingest_from_vector",
              "_simulate_ingestion"
            ],
            "line": 121
          },
          {
            "name": "IndexingResult",
            "docstring": "Result of indexing operation.",
            "methods": [
              "to_dict"
            ],
            "line": 626
          },
          {
            "name": "IndexingExecutor",
            "docstring": "Real indexing executor (GAP-160).\n\nGenerates embeddings and stores vectors for search.\n\nFeatures:\n- Text chunking for long documents\n- Embedding generation (via configured provider)\n- Vector upsert to VectorConnector\n- Metadata indexing for filtering",
            "methods": [
              "__init__",
              "execute",
              "_get_vector_connector",
              "_extract_documents",
              "_chunk_documents",
              "_generate_embeddings",
              "_simulate_embedding",
              "_call_embedding_api"
            ],
            "line": 649
          },
          {
            "name": "SensitivityLevel",
            "docstring": "Data sensitivity levels.",
            "methods": [],
            "line": 943
          },
          {
            "name": "PIIType",
            "docstring": "Types of PII detected.",
            "methods": [],
            "line": 951
          },
          {
            "name": "PIIDetection",
            "docstring": "A detected PII instance.",
            "methods": [],
            "line": 966
          },
          {
            "name": "ClassificationResult",
            "docstring": "Result of classification operation.",
            "methods": [
              "to_dict"
            ],
            "line": 975
          },
          {
            "name": "ClassificationExecutor",
            "docstring": "Real classification executor (GAP-161).\n\nAnalyzes data for:\n- PII detection (emails, phones, SSNs, etc.)\n- Sensitivity classification\n- Content categorization\n\nFeatures:\n- Regex-based PII detection\n- Configurable sensitivity thresholds\n- Category inference from content",
            "methods": [
              "__init__",
              "execute",
              "_sample_records",
              "_detect_pii",
              "_redact",
              "_detect_categories",
              "_determine_sensitivity"
            ],
            "line": 1002
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Iterator",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "knowledge_plane.py",
        "file_path": "backend/app/hoc/cus/general/L5_lifecycle/drivers/knowledge_plane.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 482,
        "module_docstring": "KnowledgePlane - Knowledge plane models and registry.\n\nProvides knowledge graph abstraction for:\n- Knowledge organization\n- Semantic relationships\n- Multi-source integration",
        "functions": [
          {
            "name": "get_knowledge_plane_registry",
            "signature": "() -> KnowledgePlaneRegistry",
            "docstring": "Get the singleton registry instance.",
            "is_async": false,
            "line": 440
          },
          {
            "name": "_reset_registry",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 448
          },
          {
            "name": "create_knowledge_plane",
            "signature": "(tenant_id: str, name: str, description: Optional[str] = None) -> KnowledgePlane",
            "docstring": "Create a new knowledge plane using the singleton registry.",
            "is_async": false,
            "line": 457
          },
          {
            "name": "get_knowledge_plane",
            "signature": "(plane_id: str) -> Optional[KnowledgePlane]",
            "docstring": "Get a knowledge plane by ID using the singleton registry.",
            "is_async": false,
            "line": 471
          },
          {
            "name": "list_knowledge_planes",
            "signature": "(tenant_id: Optional[str] = None) -> list[KnowledgePlane]",
            "docstring": "List knowledge planes using the singleton registry.",
            "is_async": false,
            "line": 477
          }
        ],
        "classes": [
          {
            "name": "KnowledgePlaneStatus",
            "docstring": "Status of a knowledge plane.",
            "methods": [],
            "line": 35
          },
          {
            "name": "KnowledgeNodeType",
            "docstring": "Types of knowledge nodes.",
            "methods": [],
            "line": 47
          },
          {
            "name": "KnowledgeNode",
            "docstring": "A node in the knowledge graph.",
            "methods": [
              "add_child",
              "add_related",
              "to_dict"
            ],
            "line": 60
          },
          {
            "name": "KnowledgePlane",
            "docstring": "Representation of a knowledge plane.\n\nA knowledge plane is a tenant-specific knowledge graph\nthat organizes and indexes content from multiple sources.",
            "methods": [
              "add_node",
              "get_node",
              "remove_node",
              "add_source",
              "remove_source",
              "activate",
              "deactivate",
              "start_indexing",
              "finish_indexing",
              "archive",
              "record_error",
              "to_dict"
            ],
            "line": 115
          },
          {
            "name": "KnowledgePlaneError",
            "docstring": "Exception for knowledge plane errors.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 259
          },
          {
            "name": "KnowledgePlaneStats",
            "docstring": "Statistics for knowledge planes.",
            "methods": [
              "to_dict"
            ],
            "line": 280
          },
          {
            "name": "KnowledgePlaneRegistry",
            "docstring": "Registry for managing knowledge planes.\n\nFeatures:\n- Plane registration and lookup\n- Node management\n- Status tracking\n- Tenant isolation",
            "methods": [
              "__init__",
              "register",
              "get",
              "get_by_name",
              "list",
              "delete",
              "get_statistics",
              "clear_tenant",
              "reset"
            ],
            "line": 304
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "offboarding.py",
        "file_path": "backend/app/hoc/cus/general/L5_lifecycle/engines/offboarding.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 532,
        "module_docstring": "Offboarding Stage Handlers\n\nThese handlers implement the \"dumb plugin\" contract for knowledge plane offboarding.\n\nOffboarding Path:\n    ACTIVE \u2192 PENDING_DEACTIVATE \u2192 DEACTIVATED \u2192 ARCHIVED \u2192 PURGED\n\nEach handler:\n- Performs ONLY its specific operation\n- Returns success/failure\n- Does NOT manage state\n- Does NOT emit events\n- Does NOT check policies\n\nThe KnowledgeLifecycleManager orchestrates everything else.\n\nCRITICAL: Offboarding is governance-controlled for GDPR/CCPA compliance.\n- PENDING_DEACTIVATE has a grace period (cancel window)\n- DEACTIVATED preserves data (soft delete)\n- ARCHIVED exports to cold storage\n- PURGED deletes data but preserves audit trail",
        "functions": [],
        "classes": [
          {
            "name": "DeregisterHandler",
            "docstring": "GAP-078: Start offboarding process.\n\nInitiates deregistration by moving to PENDING_DEACTIVATE state.\nThis starts a grace period where the offboarding can be cancelled.\n\nResponsibilities:\n- Validate no active runs are using this plane\n- Check for dependent resources\n- Calculate grace period end time\n\nDoes NOT:\n- Actually deactivate the plane\n- Delete any data\n- Change state (orchestrator does that)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_check_active_references",
              "_check_dependents"
            ],
            "line": 57
          },
          {
            "name": "VerifyDeactivateHandler",
            "docstring": "GAP-079: Verify deactivation is safe.\n\nVerifies that the knowledge plane can be safely deactivated:\n- No active runs\n- No pending queries\n- Grace period has passed (or forced)\n\nResponsibilities:\n- Verify grace period status\n- Check for any remaining active usage\n- Validate deactivation is safe\n\nDoes NOT:\n- Actually deactivate\n- Make policy decisions (orchestrator's policy gate does that)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_check_active_usage"
            ],
            "line": 157
          },
          {
            "name": "DeactivateHandler",
            "docstring": "GAP-080: Deactivate knowledge plane (soft delete).\n\nPerforms soft deletion - the plane is no longer queryable but data is preserved.\n\nResponsibilities:\n- Disable query endpoint\n- Revoke active access tokens\n- Mark as deactivated\n\nDoes NOT:\n- Delete any data (preserved for archival)\n- Remove from storage\n- Delete audit trail",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_perform_deactivation"
            ],
            "line": 253
          },
          {
            "name": "ArchiveHandler",
            "docstring": "GAP-081: Archive knowledge plane to cold storage.\n\nExports data to cold storage for long-term retention.\n\nResponsibilities:\n- Export data to archive storage\n- Generate archive manifest\n- Verify archive integrity\n- Remove from hot storage (after verification)\n\nDoes NOT:\n- Delete audit trail\n- Remove from system entirely\n- Make purge decision (requires separate approval)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_perform_archive"
            ],
            "line": 332
          },
          {
            "name": "PurgeHandler",
            "docstring": "GAP-082: Purge knowledge plane (permanent deletion).\n\nPermanently deletes all data except the audit trail.\n\nResponsibilities:\n- Delete data from archive storage\n- Delete indexes and embeddings\n- Delete metadata\n- Preserve audit trail (REQUIRED for compliance)\n\nDoes NOT:\n- Delete audit trail (audit is immutable)\n- Make this reversible (PURGED is terminal)\n\nCRITICAL: This operation requires approval via GAP-087 policy gate.\nThe orchestrator calls the policy gate BEFORE this handler.",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_perform_purge"
            ],
            "line": 429
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.models.knowledge_lifecycle",
            "names": [
              "KnowledgePlaneLifecycleState"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "base",
            "names": [
              "BaseStageHandler",
              "StageContext",
              "StageResult"
            ],
            "is_relative": true,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "onboarding.py",
        "file_path": "backend/app/hoc/cus/general/L5_lifecycle/engines/onboarding.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 703,
        "module_docstring": "Onboarding Stage Handlers\n\nThese handlers implement the \"dumb plugin\" contract for knowledge plane onboarding.\n\nOnboarding Path:\n    DRAFT \u2192 PENDING_VERIFY \u2192 VERIFIED \u2192 INGESTING \u2192 INDEXED \u2192\n    CLASSIFIED \u2192 PENDING_ACTIVATE \u2192 ACTIVE\n\nEach handler:\n- Performs ONLY its specific operation\n- Returns success/failure\n- Does NOT manage state\n- Does NOT emit events\n- Does NOT check policies\n\nThe KnowledgeLifecycleManager orchestrates everything else.",
        "functions": [],
        "classes": [
          {
            "name": "RegisterHandler",
            "docstring": "GAP-071: Register knowledge plane.\n\nCreates the initial knowledge plane record in DRAFT state.\nThis is a special handler - it doesn't transition FROM a state,\nit creates a new entity.\n\nResponsibilities:\n- Validate registration request\n- Create plane configuration\n- Initialize metadata\n\nDoes NOT:\n- Create database records (orchestrator does that)\n- Set state (orchestrator does that)\n- Emit events (orchestrator does that)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute"
            ],
            "line": 52
          },
          {
            "name": "VerifyHandler",
            "docstring": "GAP-072: Verify knowledge plane connectivity.\n\nVerifies that the knowledge source is accessible and credentials are valid.\n\nResponsibilities:\n- Test connection to source\n- Validate credentials\n- Check source schema/structure\n\nDoes NOT:\n- Store credentials (already done at registration)\n- Update state (orchestrator does that)\n- Retry on failure (orchestrator handles retry logic)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_simulate_verification"
            ],
            "line": 134
          },
          {
            "name": "IngestHandler",
            "docstring": "GAP-073: Ingest data from knowledge source.\nGAP-159: Real execution via DataIngestionExecutor.\n\nReads data from the source and stores it for processing.\n\nResponsibilities:\n- Read data from source via ConnectorRegistry\n- Transform to internal format\n- Store raw data for indexing\n\nDoes NOT:\n- Create indexes (IndexHandler does that)\n- Classify data (ClassifyHandler does that)\n- Track progress in state (orchestrator does that)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute"
            ],
            "line": 243
          },
          {
            "name": "IndexHandler",
            "docstring": "GAP-074: Create indexes and embeddings.\nGAP-160: Real execution via IndexingExecutor.\n\nCreates vector embeddings and search indexes for the ingested data.\n\nResponsibilities:\n- Generate embeddings via configured provider\n- Create vector indexes in VectorConnector\n- Build search structures\n\nDoes NOT:\n- Classify data (ClassifyHandler does that)\n- Manage index lifecycle (orchestrator does that)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute"
            ],
            "line": 337
          },
          {
            "name": "ClassifyHandler",
            "docstring": "GAP-075: Classify data sensitivity and schema.\nGAP-161: Real execution via ClassificationExecutor.\n\nAnalyzes the data to determine:\n- Sensitivity level (public, internal, confidential, restricted)\n- Data schema/structure\n- Content categories\n- PII presence\n\nResponsibilities:\n- Detect PII via pattern matching\n- Classify sensitivity based on content\n- Categorize content\n\nDoes NOT:\n- Enforce policies (policy gate does that)\n- Block activation (orchestrator does that)",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute"
            ],
            "line": 447
          },
          {
            "name": "ActivateHandler",
            "docstring": "GAP-076: Activate knowledge plane.\n\nFinal activation steps before the plane becomes operational.\n\nResponsibilities:\n- Validate policies are bound\n- Initialize runtime state\n- Set up access controls\n\nDoes NOT:\n- Check policy gate (orchestrator does that via GAP-087)\n- Emit activation event (orchestrator does that)\n\nNote: This handler runs AFTER the policy gate check.\nThe orchestrator calls GAP-087 policy gate first, then this handler.",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute",
              "_simulate_activation"
            ],
            "line": 560
          },
          {
            "name": "GovernHandler",
            "docstring": "GAP-077: Runtime governance hooks.\n\nCalled on every access to the knowledge plane to emit governance evidence.\n\nResponsibilities:\n- Emit access evidence\n- Track usage metrics\n- Validate access context\n\nDoes NOT:\n- Enforce policies (runtime enforcer does that)\n- Block access (returns evidence, enforcer decides)\n\nNote: This is not a state transition handler.\nIt's called at runtime when the plane is ACTIVE.",
            "methods": [
              "stage_name",
              "handles_states",
              "validate",
              "execute"
            ],
            "line": 639
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.models.knowledge_lifecycle",
            "names": [
              "KnowledgePlaneLifecycleState"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "base",
            "names": [
              "BaseStageHandler",
              "StageContext",
              "StageResult",
              "StageStatus"
            ],
            "is_relative": true,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "pool_manager.py",
        "file_path": "backend/app/hoc/cus/general/L5_lifecycle/engines/pool_manager.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 606,
        "module_docstring": "Connection Pool Manager (GAP-172)\n\nManages connection pools for various services with:\n- Health checking\n- Per-tenant limits\n- Metrics\n- Graceful shutdown",
        "functions": [],
        "classes": [
          {
            "name": "PoolType",
            "docstring": "Types of connection pools.",
            "methods": [],
            "line": 41
          },
          {
            "name": "PoolStatus",
            "docstring": "Pool health status.",
            "methods": [],
            "line": 50
          },
          {
            "name": "PoolConfig",
            "docstring": "Configuration for a connection pool.",
            "methods": [],
            "line": 60
          },
          {
            "name": "PoolStats",
            "docstring": "Statistics for a connection pool.",
            "methods": [
              "to_dict"
            ],
            "line": 86
          },
          {
            "name": "PoolHandle",
            "docstring": "Handle to a managed connection pool.",
            "methods": [],
            "line": 131
          },
          {
            "name": "ConnectionPoolManager",
            "docstring": "Unified connection pool manager.\n\nFeatures:\n- Manages multiple pool types (database, redis, http)\n- Health checking with automatic status updates\n- Per-tenant connection limits\n- Graceful shutdown\n- Metrics collection",
            "methods": [
              "__init__",
              "start",
              "stop",
              "create_database_pool",
              "create_redis_pool",
              "create_http_pool",
              "get_pool",
              "acquire_connection",
              "release_connection",
              "close_pool",
              "get_stats",
              "health_check",
              "_health_check_loop",
              "list_pools"
            ],
            "line": 143
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "job_executor.py",
        "file_path": "backend/app/hoc/cus/general/L5_support/CRM/engines/job_executor.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 520,
        "module_docstring": "Part-2 Job Executor (L5)\n\nExecutes governance job steps in order and emits evidence.\n\nThis is a MACHINE that performs declared steps. It does not:\n- Decide what to execute (that's Contract + Orchestrator)\n- Retry failures (failed = done)\n- Interpret results (that's Audit)\n- Modify health (that's PlatformHealthService)\n\nThe Executor is \"just physics\" - it runs the plan and records what happened.\n\nInvariants:\n- EXEC-001: Execute steps in declared order\n- EXEC-002: Emit evidence per step\n- EXEC-003: Stop on first failure\n- EXEC-004: Health is observed, never modified\n- EXEC-005: No eligibility or contract mutation\n- EXEC-006: No retry logic\n\nReference: PIN-294, PIN-292, PART2_CRM_WORKFLOW_CHARTER.md, part2-design-v1",
        "functions": [
          {
            "name": "create_default_executor",
            "signature": "() -> JobExecutor",
            "docstring": "Create a JobExecutor with default handlers.\n\nDefault handlers are no-ops for testing.\nProduction handlers should be registered separately.",
            "is_async": false,
            "line": 458
          },
          {
            "name": "execution_result_to_evidence",
            "signature": "(result: ExecutionResult) -> dict[str, Any]",
            "docstring": "Convert ExecutionResult to audit evidence format.\n\nThis is what gets passed to the Audit Trigger.",
            "is_async": false,
            "line": 484
          }
        ],
        "classes": [
          {
            "name": "HealthObserver",
            "docstring": "Protocol for observing health state (read-only).\n\nJOB EXECUTOR RULE: Health is OBSERVED, not MODIFIED.",
            "methods": [
              "observe_health"
            ],
            "line": 79
          },
          {
            "name": "StepHandler",
            "docstring": "Protocol for step type handlers.\n\nEach step type (capability_enable, capability_disable, etc.)\nhas a handler that performs the actual operation.",
            "methods": [
              "execute"
            ],
            "line": 99
          },
          {
            "name": "StepOutput",
            "docstring": "Output from executing a single step.\n\nThis is the raw output from the step handler,\nbefore it becomes a StepResult.",
            "methods": [],
            "line": 131
          },
          {
            "name": "ExecutionContext",
            "docstring": "Context passed to step handlers during execution.\n\nContains information the handler needs without\ngiving it authority to change governance state.",
            "methods": [],
            "line": 145
          },
          {
            "name": "ExecutionResult",
            "docstring": "Result of executing a job.\n\nContains the final status and all step results.",
            "methods": [],
            "line": 163
          },
          {
            "name": "JobExecutor",
            "docstring": "Part-2 Job Executor (L5)\n\nExecutes governance job steps in order and emits evidence.\n\nKey Properties (PIN-294):\n- Consumes job plans only\n- No eligibility, no approval, no contract mutation\n- Emits evidence per step\n- Stops on failure\n- Health is observed, never modified\n\nUsage:\n    executor = JobExecutor()\n    result = executor.execute_job(job_state, health_observer)",
            "methods": [
              "__init__",
              "version",
              "register_handler",
              "execute_job",
              "_execute_step"
            ],
            "line": 188
          },
          {
            "name": "NoOpHandler",
            "docstring": "No-op handler for testing.\n\nAlways succeeds without doing anything.",
            "methods": [
              "execute"
            ],
            "line": 414
          },
          {
            "name": "FailingHandler",
            "docstring": "Failing handler for testing.\n\nAlways fails with a configurable error.",
            "methods": [
              "__init__",
              "execute"
            ],
            "line": 434
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional",
              "Protocol"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.models.governance_job",
            "names": [
              "JobStatus",
              "JobStep",
              "StepResult",
              "StepStatus"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [
          {
            "name": "EXECUTOR_VERSION",
            "line": 71
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "rollout_projection.py",
        "file_path": "backend/app/hoc/cus/general/L5_ui/engines/rollout_projection.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 724,
        "module_docstring": "Part-2 Rollout Projection Service (L4 - Projection)\n\nRead-only projection layer that derives rollout state from audited truth.\n\nThis is the FINAL layer of Part-2 governance workflow.\n\nKey Properties:\n- Read-only and derived\n- No execution authority\n- No approval authority\n- No mutation authority\n- A lens, not a lever\n\nComponents:\n- FounderRolloutView: Full lineage projection for founders\n- GovernanceCompletionReport: Machine-generated completion artifact\n- RolloutStage: State machine for exposure\n- BlastRadius: Projection attribute for impact scope\n- StabilizationWindow: Gate for stage advancement\n\nInvariants:\n- ROLLOUT-001: Projection is read-only\n- ROLLOUT-002: Stage advancement requires audit PASS\n- ROLLOUT-003: Stage advancement requires stabilization\n- ROLLOUT-004: No health degradation during rollout\n- ROLLOUT-005: Stages are monotonic (no regression without new contract)\n- ROLLOUT-006: Customer sees only current stage facts\n\nReference: PIN-296, part2-design-v1",
        "functions": [
          {
            "name": "founder_view_to_dict",
            "signature": "(view: FounderRolloutView) -> dict[str, Any]",
            "docstring": "Convert FounderRolloutView to dictionary for API response.",
            "is_async": false,
            "line": 657
          },
          {
            "name": "completion_report_to_dict",
            "signature": "(report: GovernanceCompletionReport) -> dict[str, Any]",
            "docstring": "Convert GovernanceCompletionReport to dictionary for storage.",
            "is_async": false,
            "line": 713
          }
        ],
        "classes": [
          {
            "name": "RolloutStage",
            "docstring": "Rollout stages for controlled exposure.\n\nIMPORTANT: Stages are monotonic. Regression requires new contract.",
            "methods": [],
            "line": 89
          },
          {
            "name": "BlastRadius",
            "docstring": "Blast radius projection attribute.\n\nThis describes impact scope, not system behavior.\nRollout Projection DECLARES blast radius.\nExecution does NOT change blast radius.",
            "methods": [],
            "line": 119
          },
          {
            "name": "StabilizationWindow",
            "docstring": "Stabilization window for stage advancement.\n\nStage advancement requires stabilization window elapsed.",
            "methods": [],
            "line": 135
          },
          {
            "name": "ContractSummary",
            "docstring": "Summary of contract for rollout view.",
            "methods": [],
            "line": 150
          },
          {
            "name": "ExecutionSummary",
            "docstring": "Summary of execution for rollout view.",
            "methods": [],
            "line": 163
          },
          {
            "name": "AuditSummary",
            "docstring": "Summary of audit for rollout view.",
            "methods": [],
            "line": 175
          },
          {
            "name": "RolloutPlan",
            "docstring": "Rollout plan showing progression.",
            "methods": [],
            "line": 186
          },
          {
            "name": "FounderRolloutView",
            "docstring": "Complete rollout projection for founders.\n\nThis is DERIVED, not stored. It shows the full lineage:\nIssue -> Contract -> Approval -> Execution -> Audit -> Rollout\n\nFounders see everything. Customers see only current stage facts.",
            "methods": [],
            "line": 196
          },
          {
            "name": "GovernanceCompletionReport",
            "docstring": "Machine-generated governance completion artifact.\n\nGenerated ONLY if audit.verdict == PASS.\n\nThis is immutable, append-only, and not human-editable.\nIt is the document that says:\n\"The system asserts this task completed truthfully.\"",
            "methods": [],
            "line": 216
          },
          {
            "name": "CustomerRolloutView",
            "docstring": "Customer-facing rollout view.\n\nCustomers see FACTS ONLY, never intent.\n- Only features at current rollout stage\n- No audit details\n- No job visibility\n- No \"coming soon\" claims",
            "methods": [],
            "line": 238
          },
          {
            "name": "RolloutProjectionService",
            "docstring": "Part-2 Rollout Projection Service (Read-Only)\n\nProjects rollout state from audited truth.\n\nKey Properties:\n- Read-only: Never modifies anything\n- Derived: All data computed from existing sources\n- No execution: Cannot trigger execution\n- No approval: Cannot approve anything\n\nInvariants:\n- ROLLOUT-001: Projection is read-only\n- ROLLOUT-002: Stage advancement requires audit PASS\n- ROLLOUT-003: Stage advancement requires stabilization\n- ROLLOUT-004: No health degradation during rollout\n- ROLLOUT-005: Stages are monotonic\n- ROLLOUT-006: Customer sees only current stage facts\n\nUsage:\n    service = RolloutProjectionService()\n    view = service.project_founder_view(contract, execution, audit)",
            "methods": [
              "__init__",
              "version",
              "project_founder_view",
              "_check_lineage_gaps",
              "_derive_stage",
              "_get_planned_stages",
              "_default_blast_radius",
              "_calculate_stabilization",
              "generate_completion_report",
              "_calculate_health_delta",
              "project_customer_view",
              "can_advance_stage"
            ],
            "line": 260
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 78
          }
        ],
        "constants": [
          {
            "name": "PROJECTION_VERSION",
            "line": 81
          },
          {
            "name": "STAGE_ORDER",
            "line": 104
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "time.py",
        "file_path": "backend/app/hoc/cus/general/L5_utils/time.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 25,
        "module_docstring": null,
        "functions": [
          {
            "name": "utc_now",
            "signature": "() -> datetime",
            "docstring": "Get current UTC time.",
            "is_async": false,
            "line": 23
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 20
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "contract_engine.py",
        "file_path": "backend/app/hoc/cus/general/L5_workflow/contracts/engines/contract_engine.py",
        "layer": "L5_other",
        "domain": "general",
        "lines": 718,
        "module_docstring": "Part-2 Contract Service (L4)\n\nManages the System Contract state machine - the first stateful component\nin the Part-2 governance workflow.\n\nResponsibilities:\n1. Create contracts from validated + eligible proposals\n2. Enforce state machine transitions\n3. Record transition history for audit\n4. Enforce terminal state immutability\n\nInvariants (from SYSTEM_CONTRACT_OBJECT.md):\n- CONTRACT-001: Status transitions must follow state machine\n- CONTRACT-002: APPROVED requires approved_by\n- CONTRACT-003: ACTIVE requires job exists\n- CONTRACT-004: COMPLETED requires audit_verdict = PASS\n- CONTRACT-005: Terminal states are immutable\n- CONTRACT-006: proposed_changes must validate schema\n- CONTRACT-007: confidence_score range [0,1]\n\nMAY_NOT ENFORCEMENT (PIN-291):\n- MAY_NOT verdicts are mechanically un-overridable\n- No constructor, method, or bypass can create contracts from MAY_NOT\n- This is not a business rule; it is a system invariant\n\nReference: PIN-291, SYSTEM_CONTRACT_OBJECT.md, part2-design-v1",
        "functions": [],
        "classes": [
          {
            "name": "ContractState",
            "docstring": "In-memory representation of contract state.\n\nUsed for state machine operations before persistence.",
            "methods": [],
            "line": 114
          },
          {
            "name": "ContractStateMachine",
            "docstring": "State machine for System Contract lifecycle.\n\nEnforces:\n- CONTRACT-001: Valid transitions only\n- CONTRACT-002: APPROVED requires approved_by\n- CONTRACT-003: ACTIVE requires job_id\n- CONTRACT-004: COMPLETED requires audit_verdict = PASS\n- CONTRACT-005: Terminal states are immutable",
            "methods": [
              "can_transition",
              "validate_transition",
              "transition"
            ],
            "line": 151
          },
          {
            "name": "ContractService",
            "docstring": "Part-2 Contract Service (L4)\n\nManages System Contract lifecycle - the first stateful component\nof the Part-2 governance workflow.\n\nKey Properties:\n- Consumes validator + eligibility outputs\n- Enforces MAY_NOT mechanically (un-overridable)\n- Implements state machine with invariants\n- No execution logic (that's for Job Executor)\n\nReference: SYSTEM_CONTRACT_OBJECT.md, PIN-291",
            "methods": [
              "__init__",
              "version",
              "create_contract",
              "approve",
              "reject",
              "activate",
              "complete",
              "fail",
              "expire",
              "is_terminal",
              "is_approved",
              "can_approve",
              "get_valid_transitions"
            ],
            "line": 312
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 78
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 79
          },
          {
            "module": "uuid",
            "names": [
              "UUID",
              "uuid4"
            ],
            "is_relative": false,
            "line": 80
          },
          {
            "module": "app.models.contract",
            "names": [
              "TERMINAL_STATES",
              "VALID_TRANSITIONS",
              "AuditVerdict",
              "ContractApproval",
              "ContractImmutableError",
              "ContractSource",
              "ContractStatus",
              "EligibilityVerdictData",
              "InvalidTransitionError",
              "MayNotVerdictError",
              "RiskLevel",
              "TransitionRecord",
              "ValidatorVerdictData"
            ],
            "is_relative": false,
            "line": 82
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.eligibility_engine",
            "names": [
              "EligibilityDecision",
              "EligibilityVerdict"
            ],
            "is_relative": false,
            "line": 98
          },
          {
            "module": "app.hoc.cus.account.L5_support.CRM.engines.crm_validator_engine",
            "names": [
              "ValidatorVerdict"
            ],
            "is_relative": false,
            "line": 102
          }
        ],
        "constants": [
          {
            "name": "CONTRACT_SERVICE_VERSION",
            "line": 105
          }
        ],
        "all_exports": null
      }
    ],
    "l6_drivers": [
      {
        "file_name": "alert_driver.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/alert_driver.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 342,
        "module_docstring": "Alert Driver (L6)\n\nPure database operations for alert queue management.\nAll business logic stays in L4 engine.\nAll HTTP delivery stays in adapter.\n\nOperations:\n- Read pending alerts from queue\n- Update alert status (sent, retry, failed)\n- Update incident alert_sent flag\n- Queue statistics\n- Enqueue new alerts\n- Retry/purge operations\n\nNO business logic:\n- NO retry decision logic (L4)\n- NO backoff calculation (L4)\n- NO HTTP operations (adapter)\n\nReference: Phase-2.5A Analytics Extraction",
        "functions": [
          {
            "name": "get_alert_driver",
            "signature": "(session: AsyncSession) -> AlertDriver",
            "docstring": "Factory function to get AlertDriver instance.",
            "is_async": false,
            "line": 334
          }
        ],
        "classes": [
          {
            "name": "AlertDriver",
            "docstring": "L6 driver for alert queue data access.\n\nPure database access - no business logic, no HTTP.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "fetch_pending_alerts",
              "fetch_queue_stats",
              "update_alert_sent",
              "update_alert_retry",
              "update_alert_failed",
              "mark_incident_alert_sent",
              "insert_alert",
              "retry_failed_alerts",
              "purge_old_alerts"
            ],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "delete",
              "func",
              "select",
              "update"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "app.models.costsim_cb",
            "names": [
              "CostSimAlertQueueModel",
              "CostSimCBIncidentModel"
            ],
            "is_relative": false,
            "line": 73
          }
        ],
        "constants": [],
        "all_exports": [
          "AlertDriver",
          "get_alert_driver"
        ]
      },
      {
        "file_name": "alert_emitter.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/alert_emitter.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 422,
        "module_docstring": "Alert Emitter Service\n\nEmits alerts for threshold events via configured channels:\n- UI notifications\n- Webhooks\n- Email (future)\n- Slack (future)\n\nAlert flow:\n1. ThresholdSignal created\n2. AlertEmitter checks AlertConfig\n3. If enabled and not throttled, send via configured channels\n4. Record alert sent status",
        "functions": [
          {
            "name": "get_alert_emitter",
            "signature": "() -> AlertEmitter",
            "docstring": "Get or create AlertEmitter singleton.",
            "is_async": false,
            "line": 417
          }
        ],
        "classes": [
          {
            "name": "AlertEmitter",
            "docstring": "Emits alerts for threshold events.\n\nHandles alert throttling, channel routing, and delivery tracking.",
            "methods": [
              "__init__",
              "emit_near_threshold",
              "emit_breach",
              "_send_via_channel",
              "_send_ui_notification",
              "_send_webhook",
              "_send_slack",
              "_send_email",
              "_persist_signal",
              "_persist_config"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.db",
            "names": [
              "engine"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.models.alert_config",
            "names": [
              "AlertChannel",
              "AlertConfig"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.models.threshold_signal",
            "names": [
              "SignalType",
              "ThresholdSignal"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "budget_tracker.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/budget_tracker.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 531,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_budget_tracker",
            "signature": "() -> BudgetTracker",
            "docstring": "Get the singleton budget tracker.",
            "is_async": false,
            "line": 486
          },
          {
            "name": "check_budget",
            "signature": "(agent_id: str, estimated_cost_cents: int) -> tuple[bool, Optional[str]]",
            "docstring": "Convenience function to check budget.",
            "is_async": false,
            "line": 494
          },
          {
            "name": "deduct_budget",
            "signature": "(agent_id: str, cost_cents: int, tenant_id: Optional[str] = None) -> bool",
            "docstring": "Convenience function to deduct budget.",
            "is_async": false,
            "line": 499
          },
          {
            "name": "record_cost",
            "signature": "(run_id: str, agent_id: str, provider: str, model: str, input_tokens: int, output_tokens: int, cost_cents: int)",
            "docstring": "Convenience function to record cost.",
            "is_async": false,
            "line": 504
          },
          {
            "name": "enforce_budget",
            "signature": "(agent_id: str, estimated_cost_cents: int, model: Optional[str] = None, run_id: Optional[str] = None, request_id: Optional[str] = None) -> BudgetCheckResult",
            "docstring": "Full budget enforcement with all protection layers.\n\nThis is the main entry point for Phase 5 budget protection.\nChecks: per-run, per-model, per-day, and total budget limits.\n\nPhase 4B Extension: request_id for causal binding of pre-run decisions.",
            "is_async": false,
            "line": 517
          }
        ],
        "classes": [
          {
            "name": "BudgetStatus",
            "docstring": "Current budget status for an agent.",
            "methods": [],
            "line": 65
          },
          {
            "name": "BudgetCheckResult",
            "docstring": "Result of a budget enforcement check.",
            "methods": [],
            "line": 79
          },
          {
            "name": "BudgetTracker",
            "docstring": "Tracks and enforces LLM cost budgets.\n\nProvides atomic budget deduction and cost recording.\nSupports alert thresholds for proactive notification.",
            "methods": [
              "__init__",
              "get_status",
              "_get_today_spent",
              "check_budget",
              "enforce_budget",
              "_pause_agent",
              "deduct",
              "record_cost"
            ],
            "line": 89
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "text"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "db",
            "names": [
              "Agent",
              "engine"
            ],
            "is_relative": true,
            "line": 36
          },
          {
            "module": "app.contracts.decisions",
            "names": [
              "emit_budget_decision"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [
          {
            "name": "BUDGET_ALERT_THRESHOLD",
            "line": 44
          },
          {
            "name": "PER_RUN_MAX_CENTS",
            "line": 48
          },
          {
            "name": "PER_DAY_MAX_CENTS",
            "line": 51
          },
          {
            "name": "AUTO_PAUSE_ON_BREACH",
            "line": 61
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "cross_domain.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/cross_domain.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 506,
        "module_docstring": "Cross-Domain Governance Functions (Mandatory)\n\nPIN: design/CROSS_DOMAIN_GOVERNANCE.md\n\nThese functions implement mandatory governance for customer-facing paths.\nThey MUST succeed or raise GovernanceError. Silent failures are forbidden.\n\nDOCTRINE:\n- Rule 1: Governance must throw\n- Rule 2: No optional dependencies\n- Rule 3: Learning is downstream only\n\nDOMAINS:\n- Analytics \u2192 Incidents: Cost anomalies MUST create incidents\n- Policies \u2194 Analytics: Limit breaches MUST be recorded\n\nCOROLLARY: GovernanceError must surface - never catch and ignore.",
        "functions": [
          {
            "name": "utc_now",
            "signature": "() -> datetime",
            "docstring": "Return timezone-aware UTC datetime.",
            "is_async": false,
            "line": 62
          },
          {
            "name": "generate_uuid",
            "signature": "() -> str",
            "docstring": "Generate a UUID string.",
            "is_async": false,
            "line": 67
          },
          {
            "name": "create_incident_from_cost_anomaly",
            "signature": "(session: AsyncSession, tenant_id: str, anomaly_id: str, anomaly_type: str, severity: str, current_value_cents: int, expected_value_cents: int, entity_type: Optional[str] = None, entity_id: Optional[str] = None, description: Optional[str] = None) -> str",
            "docstring": "Create an incident from a cost anomaly. MANDATORY.\n\nThis function MUST succeed or raise GovernanceError.\nIt cannot be skipped based on optional configuration.\n\nArgs:\n    session: Database session\n    tenant_id: Tenant scope\n    anomaly_id: ID of the cost anomaly\n    anomaly_type: Type of anomaly (BUDGET_EXCEEDED, USER_SPIKE, etc.)\n    severity: Anomaly severity (CRITICAL, HIGH, MEDIUM, LOW)\n    current_value_cents: Actual cost in cents\n    expected_value_cents: Expected cost in cents\n    entity_type: Optional entity type (user, tenant, etc.)\n    entity_id: Optional entity ID\n    description: Optional description\n\nReturns:\n    incident_id\n\nRaises:\n    GovernanceError: If incident cannot be created\n\nExample:\n    incident_id = await create_incident_from_cost_anomaly(\n        session=session,\n        tenant_id=\"tenant-123\",\n        anomaly_id=\"anomaly-456\",\n        anomaly_type=\"BUDGET_EXCEEDED\",\n        severity=\"HIGH\",\n        current_value_cents=15000,\n        expected_value_cents=10000,\n    )",
            "is_async": true,
            "line": 97
          },
          {
            "name": "record_limit_breach",
            "signature": "(session: AsyncSession, tenant_id: str, limit_id: str, breach_type: str, value_at_breach: Decimal, limit_value: Decimal, run_id: Optional[str] = None, incident_id: Optional[str] = None, details: Optional[dict] = None) -> str",
            "docstring": "Record a limit breach. MANDATORY.\n\nThis function MUST succeed or raise GovernanceError.\nEvery budget/rate/threshold breach MUST be recorded.\n\nArgs:\n    session: Database session\n    tenant_id: Tenant scope\n    limit_id: ID of the limit that was breached\n    breach_type: Type of breach (BREACHED, EXHAUSTED, THROTTLED, VIOLATED)\n    value_at_breach: The value that caused the breach\n    limit_value: The limit value that was exceeded\n    run_id: Optional ID of the run that caused the breach\n    incident_id: Optional ID of resulting incident\n    details: Optional additional context\n\nReturns:\n    breach_id\n\nRaises:\n    GovernanceError: If breach cannot be recorded\n\nExample:\n    breach_id = await record_limit_breach(\n        session=session,\n        tenant_id=\"tenant-123\",\n        limit_id=\"limit-456\",\n        breach_type=\"BREACHED\",\n        value_at_breach=Decimal(\"150.00\"),\n        limit_value=Decimal(\"100.00\"),\n        run_id=\"run-789\",\n    )",
            "is_async": true,
            "line": 222
          },
          {
            "name": "table_exists",
            "signature": "(session: AsyncSession, table_name: str) -> bool",
            "docstring": "Check if a table exists in the database.\n\nUsed by Overview for defensive queries that should degrade gracefully.\n\nArgs:\n    session: Database session\n    table_name: Name of the table to check\n\nReturns:\n    True if table exists, False otherwise",
            "is_async": true,
            "line": 313
          },
          {
            "name": "create_incident_from_cost_anomaly_sync",
            "signature": "(session: Session, tenant_id: str, anomaly_id: str, anomaly_type: str, severity: str, current_value_cents: int, expected_value_cents: int, entity_type: Optional[str] = None, entity_id: Optional[str] = None, description: Optional[str] = None) -> str",
            "docstring": "Create an incident from a cost anomaly (SYNC version). MANDATORY.\n\nSame as create_incident_from_cost_anomaly but for sync sessions.\nSee async version for full documentation.\n\nRaises:\n    GovernanceError: If incident cannot be created",
            "is_async": false,
            "line": 354
          },
          {
            "name": "record_limit_breach_sync",
            "signature": "(session: Session, tenant_id: str, limit_id: str, breach_type: str, value_at_breach: Decimal, limit_value: Decimal, run_id: Optional[str] = None, incident_id: Optional[str] = None, details: Optional[dict] = None) -> str",
            "docstring": "Record a limit breach (SYNC version). MANDATORY.\n\nSame as record_limit_breach but for sync sessions.\nSee async version for full documentation.\n\nRaises:\n    GovernanceError: If breach cannot be recorded",
            "is_async": false,
            "line": 448
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "Optional",
              "Union"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.errors.governance",
            "names": [
              "GovernanceError"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.metrics",
            "names": [
              "governance_incidents_created_total",
              "governance_limit_breaches_recorded_total"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "LimitBreach"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [
          {
            "name": "ANOMALY_SEVERITY_MAP",
            "line": 76
          },
          {
            "name": "ANOMALY_TRIGGER_TYPE_MAP",
            "line": 83
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "cus_health_driver.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/cus_health_driver.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 542,
        "module_docstring": "Customer Health Driver\n\nPURPOSE:\n    Provider reachability and credential validation for customer LLM integrations.\n    Performs lightweight health checks without consuming significant quota.\n\nRESPONSIBILITIES:\n    - Test provider connectivity\n    - Validate credentials are still valid\n    - Measure response latency\n    - Update health state in integrations\n\nHEALTH STATES:\n    - UNKNOWN: Never checked or no recent data\n    - HEALTHY: Last check successful\n    - DEGRADED: Slow or partial responses\n    - UNHEALTHY: Check failed\n\nCHECK STRATEGY:\n    - OpenAI: GET /models endpoint (lightweight, no tokens)\n    - Anthropic: POST /messages with max_tokens=1 (minimal cost)\n    - Google: GET /models endpoint\n    - Others: Provider-specific lightweight calls\n\nRATE LIMITING:\n    - Maximum one check per integration per minute\n    - Batch checks spread over time\n    - Failed integrations checked less frequently",
        "functions": [],
        "classes": [
          {
            "name": "CusHealthDriver",
            "docstring": "Driver for health checking customer LLM integrations.\n\nPhase 4: Provider reachability and credential validation.\n\nNOTE: Renamed from CusHealthService to CusHealthDriver to reflect L6 Driver role.",
            "methods": [
              "__init__",
              "check_health",
              "_perform_health_check",
              "check_all_integrations",
              "get_health_summary",
              "_calculate_overall_health"
            ],
            "line": 71
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.db",
            "names": [
              "get_engine"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "app.models.cus_models",
            "names": [
              "CusHealthState",
              "CusIntegration"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.hoc.cus.general.L5_engines.cus_credential_service",
            "names": [
              "CusCredentialService"
            ],
            "is_relative": false,
            "line": 66
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "dag_executor.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/dag_executor.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 325,
        "module_docstring": "DAG-based executor for PLang v2.0.\n\nExecutes policies in topologically sorted order:\n- Parallel execution within stages\n- Sequential execution across stages\n- Governance-aware ordering\n- Full execution trace",
        "functions": [],
        "classes": [
          {
            "name": "StageResult",
            "docstring": "Result of executing a single stage.",
            "methods": [
              "success",
              "was_blocked"
            ],
            "line": 50
          },
          {
            "name": "ExecutionTrace",
            "docstring": "Full execution trace across all stages.",
            "methods": [
              "to_dict"
            ],
            "line": 72
          },
          {
            "name": "DAGExecutor",
            "docstring": "Executes policies in DAG order.\n\nFeatures:\n- Parallel execution within stages\n- Early termination on DENY\n- Governance-aware execution order\n- Full audit trail",
            "methods": [
              "__init__",
              "execute",
              "_execute_stage",
              "_execute_policy",
              "_is_more_restrictive",
              "get_execution_plan",
              "visualize_plan"
            ],
            "line": 112
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRModule"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.policy.optimizer.dag_sorter",
            "names": [
              "DAGSorter",
              "ExecutionPlan"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.policy.runtime.deterministic_engine",
            "names": [
              "DeterministicEngine",
              "ExecutionContext",
              "ExecutionResult"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.policy.runtime.intent",
            "names": [
              "Intent"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "decisions.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/decisions.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 1361,
        "module_docstring": "Phase 4B: Decision Record Models and Service\n\nImplements DECISION_RECORD_CONTRACT v0.2.\n\nContract-mandated fields:\n- decision_source: human | system | hybrid\n- decision_trigger: explicit | autonomous | reactive\n\nRule: Emit records where decisions already happen. No logic changes.",
        "functions": [
          {
            "name": "get_decision_service",
            "signature": "() -> DecisionRecordService",
            "docstring": "Get singleton decision record service.",
            "is_async": false,
            "line": 407
          },
          {
            "name": "emit_routing_decision",
            "signature": "(run_id: Optional[str], routed: bool, selected_agent: Optional[str], eligible_agents: list, rejection_reason: Optional[str] = None, tenant_id: str = 'default', details: Optional[Dict[str, Any]] = None, request_id: Optional[str] = None, causal_role: CausalRole = CausalRole.PRE_RUN) -> DecisionRecord",
            "docstring": "Emit a routing decision record.\n\nCalled from CARE engine after every route() call.\nNote: Routing typically happens BEFORE run exists, so causal_role=PRE_RUN.",
            "is_async": false,
            "line": 420
          },
          {
            "name": "emit_recovery_decision",
            "signature": "(run_id: Optional[str], evaluated: bool, triggered: bool, action: Optional[str] = None, candidates_count: int = 0, reason: Optional[str] = None, tenant_id: str = 'default', request_id: Optional[str] = None, causal_role: CausalRole = CausalRole.IN_RUN) -> DecisionRecord",
            "docstring": "Emit a recovery decision record.\n\nCalled from recovery engine after every evaluation.\nNote: Recovery happens DURING run execution, so causal_role=IN_RUN.",
            "is_async": false,
            "line": 464
          },
          {
            "name": "emit_memory_decision",
            "signature": "(run_id: Optional[str], queried: bool, matched: bool, injected: bool, sources: Optional[list] = None, reason: Optional[str] = None, tenant_id: str = 'default', request_id: Optional[str] = None, causal_role: CausalRole = CausalRole.IN_RUN) -> DecisionRecord",
            "docstring": "Emit a memory injection decision record.\n\nCalled after every memory query attempt.\nNote: Memory injection can happen pre-run or in-run. Default is IN_RUN.",
            "is_async": false,
            "line": 512
          },
          {
            "name": "emit_policy_decision",
            "signature": "(run_id: Optional[str], policy_id: str, evaluated: bool, violated: bool, severity: str = 'warning', reason: Optional[str] = None, tenant_id: str = 'default', request_id: Optional[str] = None, causal_role: CausalRole = CausalRole.IN_RUN) -> DecisionRecord",
            "docstring": "Emit a policy enforcement decision record.\n\nCalled after every policy check.\nNote: Policy checks can happen pre-run or in-run. Default is IN_RUN.",
            "is_async": false,
            "line": 564
          },
          {
            "name": "emit_budget_decision",
            "signature": "(run_id: Optional[str], budget_requested: int, budget_available: int, enforcement: str = 'soft', simulation_feasible: Optional[bool] = None, proceeded: bool = True, reason: Optional[str] = None, tenant_id: str = 'default', request_id: Optional[str] = None, causal_role: CausalRole = CausalRole.PRE_RUN) -> DecisionRecord",
            "docstring": "Emit a budget handling decision record.\n\nCalled after every budget check.\nNote: Budget checks typically happen pre-run to verify resource availability.",
            "is_async": false,
            "line": 611
          },
          {
            "name": "_check_budget_enforcement_exists",
            "signature": "(run_id: str) -> bool",
            "docstring": "Check if a budget_enforcement decision already exists for this run.\n\nIdempotency guard: prevents double emission on retry/restart.",
            "is_async": false,
            "line": 670
          },
          {
            "name": "emit_budget_enforcement_decision",
            "signature": "(run_id: str, budget_limit_cents: int, budget_consumed_cents: int, step_cost_cents: int, completed_steps: int, total_steps: int, tenant_id: str = 'default') -> Optional[DecisionRecord]",
            "docstring": "Emit a budget enforcement decision record when hard limit halts execution.\n\nPhase 5A: This is the ONLY decision type for hard budget halts.\nCalled immediately when execution is halted due to hard budget limit.\n\nIDEMPOTENT: If already emitted for this run_id, returns None.\n\nContract alignment:\n- decision_type: budget_enforcement\n- decision_source: system\n- decision_trigger: reactive\n- decision_outcome: execution_halted",
            "is_async": false,
            "line": 705
          },
          {
            "name": "_check_policy_precheck_exists",
            "signature": "(request_id: str, outcome: str) -> bool",
            "docstring": "Check if a policy_pre_check decision already exists for this request+outcome.\n\nIdempotency guard: prevents double emission on retry/restart.",
            "is_async": false,
            "line": 768
          },
          {
            "name": "emit_policy_precheck_decision",
            "signature": "(request_id: str, posture: str, passed: bool, service_available: bool, violations: Optional[list] = None, tenant_id: str = 'default') -> Optional[DecisionRecord]",
            "docstring": "Emit a policy pre-check decision record.\n\nPhase 5B: Pre-execution policy check.\n\nEMISSION RULE (FROZEN):\n  - EMIT IFF (posture == strict AND (failed OR unavailable))\n  - DO NOT EMIT if passed or posture == advisory\n\nContract alignment:\n- decision_type: policy_pre_check\n- decision_source: system\n- decision_trigger: explicit (pre-check is proactive)\n- causal_role: pre_run (always - run doesn't exist yet)\n- run_id: None (run not created on block)\n\nIDEMPOTENT: If already emitted for this request_id+outcome, returns None.",
            "is_async": false,
            "line": 805
          },
          {
            "name": "_check_recovery_evaluation_exists",
            "signature": "(run_id: str, failure_type: str) -> bool",
            "docstring": "Check if a recovery_evaluation decision already exists for this run+failure.\n\nIdempotency guard: prevents double emission on retry/restart.",
            "is_async": false,
            "line": 906
          },
          {
            "name": "emit_recovery_evaluation_decision",
            "signature": "(run_id: str, request_id: str, recovery_class: str, recovery_action: Optional[str], failure_type: str, failure_context: Optional[Dict[str, Any]] = None, tenant_id: str = 'default') -> Optional[DecisionRecord]",
            "docstring": "Emit a recovery evaluation decision record.\n\nPhase 5C: Post-failure recovery evaluation.\n\nEMISSION RULE (FROZEN per PIN-174):\n  - ALWAYS emit exactly one RECOVERY_EVALUATION decision after any:\n    - execution_halted\n    - execution_failed\n\n  Outcome mapping:\n    - R1 and applied \u2192 recovery_applied\n    - R2 and suggested \u2192 recovery_suggested\n    - R3 or no applicable recovery \u2192 recovery_skipped\n\nContract alignment:\n- decision_type: recovery_evaluation\n- decision_source: system\n- decision_trigger: reactive (recovery is always reactive to failure)\n- causal_role: post_run (always - recovery evaluates after failure)\n\nIDEMPOTENT: If already emitted for this run_id+failure_type, returns None.",
            "is_async": false,
            "line": 943
          },
          {
            "name": "backfill_run_id_for_request",
            "signature": "(request_id: str, run_id: str) -> int",
            "docstring": "Backfill run_id for all decisions with matching request_id.\n\nCalled from run creation to bind pre-run decisions (routing, policy, budget)\nto the newly created run. This is context enrichment, not mutation.\n\nReturns the number of records updated.",
            "is_async": false,
            "line": 1036
          },
          {
            "name": "check_signal_access",
            "signature": "(signal_name: str) -> bool",
            "docstring": "Check if a signal is allowed for CARE optimization.\n\nPhase 5D: Hard guard on signal access.\n\nRaises:\n    CARESignalAccessError: If signal is forbidden\n\nReturns:\n    True if signal is allowed",
            "is_async": false,
            "line": 1135
          },
          {
            "name": "activate_care_kill_switch",
            "signature": "() -> bool",
            "docstring": "Activate the CARE optimization kill-switch.\n\nWhen activated:\n- Forces baseline selection\n- Prevents decision emission\n- Takes effect within 1 request cycle\n\nReturns:\n    True on successful activation",
            "is_async": false,
            "line": 1156
          },
          {
            "name": "deactivate_care_kill_switch",
            "signature": "() -> bool",
            "docstring": "Deactivate the CARE optimization kill-switch.\n\nReturns:\n    True on successful deactivation",
            "is_async": false,
            "line": 1174
          },
          {
            "name": "is_care_kill_switch_active",
            "signature": "() -> bool",
            "docstring": "Check if CARE kill-switch is currently active.",
            "is_async": false,
            "line": 1187
          },
          {
            "name": "_check_care_optimization_exists",
            "signature": "(request_id: str) -> bool",
            "docstring": "Check if a care_routing_optimized decision already exists for this request.\n\nIdempotency guard: prevents double emission.",
            "is_async": false,
            "line": 1192
          },
          {
            "name": "emit_care_optimization_decision",
            "signature": "(request_id: str, baseline_agent: str, optimized_agent: str, confidence_score: float, signals_used: list, optimization_enabled: bool = True, shadow_mode: bool = False, tenant_id: str = 'default') -> Optional[DecisionRecord]",
            "docstring": "Emit a CARE routing optimization decision record.\n\nPhase 5D: Optimization-driven routing decision.\n\nEMISSION RULE (FROZEN per PIN-176):\n  - EMIT CARE_ROUTING_OPTIMIZED decision IF AND ONLY IF:\n    - optimization_enabled = true\n    - AND NOT shadow_mode\n    - AND optimized_agent != baseline_agent\n\n  - DO NOT EMIT if:\n    - optimization_disabled\n    - shadow_mode (log only, no decision record)\n    - baseline == optimized (silence allowed)\n    - kill_switch active\n\nContract alignment:\n- decision_type: care_routing_optimized\n- decision_source: system\n- decision_trigger: autonomous (learning-driven)\n- causal_role: pre_run (always - before run exists)\n\nIDEMPOTENT: If already emitted for this request_id, returns None.",
            "is_async": false,
            "line": 1227
          }
        ],
        "classes": [
          {
            "name": "DecisionType",
            "docstring": "Types of decisions that must be recorded.",
            "methods": [],
            "line": 53
          },
          {
            "name": "DecisionSource",
            "docstring": "Who originated the decision authority.",
            "methods": [],
            "line": 67
          },
          {
            "name": "DecisionTrigger",
            "docstring": "Why the decision occurred.",
            "methods": [],
            "line": 75
          },
          {
            "name": "DecisionOutcome",
            "docstring": "Result of the decision.",
            "methods": [],
            "line": 83
          },
          {
            "name": "CausalRole",
            "docstring": "When in the lifecycle this decision occurred.",
            "methods": [],
            "line": 104
          },
          {
            "name": "DecisionRecord",
            "docstring": "Contract-aligned decision record.\n\nEvery decision (routing, recovery, memory, policy, budget) emits one of these.\nAppend-only. No business logic.",
            "methods": [
              "to_dict"
            ],
            "line": 117
          },
          {
            "name": "DecisionRecordService",
            "docstring": "Append-only sink for decision records.\n\nEmits to contracts.decision_records table.\nNon-blocking - failures are logged but don't affect callers.\n\nEvidence Architecture v1.0: Also bridges to governance.policy_decisions for taxonomy evidence.",
            "methods": [
              "__init__",
              "_bridge_to_taxonomy",
              "emit",
              "emit_sync",
              "_emit_sync_impl"
            ],
            "line": 180
          },
          {
            "name": "CARESignalAccessError",
            "docstring": "Raised when attempting to access a forbidden CARE signal.",
            "methods": [],
            "line": 1129
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy",
            "names": [
              "create_engine",
              "text"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy.exc",
            "names": [
              "SQLAlchemyError"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [
          {
            "name": "CARE_ALLOWED_SIGNALS",
            "line": 1096
          },
          {
            "name": "CARE_FORBIDDEN_SIGNALS",
            "line": 1109
          },
          {
            "name": "CARE_CONFIDENCE_THRESHOLD",
            "line": 1126
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "governance_signal_driver.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/governance_signal_driver.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 293,
        "module_docstring": "Governance Signal Service (Phase E FIX-03)\n\nL6 service for persisting and querying governance signals.\n\nWrite Path (L7 \u2192 L6):\n- BLCA, CI, OPS write signals via record_signal()\n- Signals are persisted to governance_signals table\n- Previous signals for same scope/type are superseded\n\nRead Path (L4/L5 \u2190 L6):\n- Domain orchestrators check governance before decisions\n- Workers check governance before execution\n- Returns blocking/warning signals for scope\n\nContract:\n- All governance influence becomes visible data\n- No implicit pressure - only explicit signals\n- L4/L5 can query WHY they're blocked",
        "functions": [
          {
            "name": "check_governance_status",
            "signature": "(session: Session, scope: str, signal_type: Optional[str] = None) -> GovernanceCheckResult",
            "docstring": "Check governance status for a scope.",
            "is_async": false,
            "line": 255
          },
          {
            "name": "is_governance_blocked",
            "signature": "(session: Session, scope: str, signal_type: Optional[str] = None) -> bool",
            "docstring": "Quick check if scope is blocked.",
            "is_async": false,
            "line": 265
          },
          {
            "name": "record_governance_signal",
            "signature": "(session: Session, signal_type: str, scope: str, decision: str, recorded_by: str, reason: Optional[str] = None, constraints: Optional[dict] = None) -> GovernanceSignal",
            "docstring": "Record a governance signal.",
            "is_async": false,
            "line": 275
          }
        ],
        "classes": [
          {
            "name": "GovernanceSignalService",
            "docstring": "Service for governance signal operations.\n\nPhase E: Makes L7 \u2192 L4/L5 influence explicit and queryable.",
            "methods": [
              "__init__",
              "record_signal",
              "_supersede_existing_signals",
              "check_governance",
              "is_blocked",
              "get_active_signals",
              "clear_signal"
            ],
            "line": 55
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "or_",
              "select",
              "update"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy.orm",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.models.governance",
            "names": [
              "GovernanceCheckResult",
              "GovernanceSignal",
              "GovernanceSignalResponse"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard_cache.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/guard_cache.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 252,
        "module_docstring": "Redis-based cache for Guard Console endpoints.\n\nReduces database query latency by caching frequently-accessed data.\nCritical for cross-region deployments (EU server, Singapore DB).\n\nCache Keys:\n- guard:status:{tenant_id} - 5s TTL (real-time status)\n- guard:snapshot:{tenant_id} - 10s TTL (today's metrics)\n- guard:incidents:{tenant_id}:{limit}:{offset} - 5s TTL\n\nPerformance Target:\n- Reduce /guard/status from 4-7s to <100ms (cache hit)\n- Reduce /guard/snapshot/today from 2-6s to <100ms (cache hit)",
        "functions": [
          {
            "name": "get_guard_cache",
            "signature": "() -> GuardCache",
            "docstring": "Get guard cache singleton.",
            "is_async": false,
            "line": 247
          }
        ],
        "classes": [
          {
            "name": "GuardCache",
            "docstring": "Redis-based cache for Guard Console API.\n\nUsage:\n    cache = GuardCache()\n\n    # Check cache first\n    data = await cache.get_status(tenant_id)\n    if data is None:\n        data = fetch_from_db(...)\n        await cache.set_status(tenant_id, data)",
            "methods": [
              "__init__",
              "get_instance",
              "_get_redis",
              "_make_key",
              "get",
              "set",
              "invalidate",
              "get_status",
              "set_status",
              "get_snapshot",
              "set_snapshot",
              "get_incidents",
              "set_incidents",
              "invalidate_tenant"
            ],
            "line": 75
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "metrics_helpers",
            "names": [
              "get_or_create_counter",
              "get_or_create_histogram"
            ],
            "is_relative": true,
            "line": 44
          }
        ],
        "constants": [
          {
            "name": "GUARD_CACHE_ENABLED",
            "line": 49
          },
          {
            "name": "GUARD_STATUS_TTL",
            "line": 50
          },
          {
            "name": "GUARD_SNAPSHOT_TTL",
            "line": 51
          },
          {
            "name": "GUARD_INCIDENTS_TTL",
            "line": 52
          },
          {
            "name": "GUARD_CACHE_PREFIX",
            "line": 53
          },
          {
            "name": "GUARD_CACHE_HITS",
            "line": 56
          },
          {
            "name": "GUARD_CACHE_MISSES",
            "line": 62
          },
          {
            "name": "GUARD_CACHE_LATENCY",
            "line": 68
          }
        ],
        "all_exports": [
          "GuardCache",
          "get_guard_cache",
          "GUARD_STATUS_TTL",
          "GUARD_SNAPSHOT_TTL",
          "GUARD_INCIDENTS_TTL"
        ]
      },
      {
        "file_name": "idempotency.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/idempotency.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 160,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_existing_run",
            "signature": "(idempotency_key: str, tenant_id: Optional[str] = None, agent_id: Optional[str] = None) -> Optional[Run]",
            "docstring": "Check if a run with this idempotency key already exists.\n\nArgs:\n    idempotency_key: The idempotency key to check\n    tenant_id: Optional tenant filter\n    agent_id: Optional agent filter\n\nReturns:\n    Existing Run if found, None otherwise",
            "is_async": false,
            "line": 51
          },
          {
            "name": "check_idempotency",
            "signature": "(idempotency_key: str, tenant_id: Optional[str] = None, agent_id: Optional[str] = None) -> IdempotencyResult",
            "docstring": "Check idempotency and return result with status.\n\nArgs:\n    idempotency_key: The idempotency key to check\n    tenant_id: Optional tenant filter\n    agent_id: Optional agent filter\n\nReturns:\n    IdempotencyResult indicating if key exists and its status",
            "is_async": false,
            "line": 85
          },
          {
            "name": "should_return_cached",
            "signature": "(result: IdempotencyResult) -> bool",
            "docstring": "Determine if we should return cached result.\n\nReturns True if:\n- Key exists and is not expired\n- Status is succeeded, failed, or in progress (queued/running)\n\nReturns False if:\n- Key doesn't exist\n- Key is expired",
            "is_async": false,
            "line": 145
          }
        ],
        "classes": [
          {
            "name": "IdempotencyResult",
            "docstring": "Result of idempotency check.",
            "methods": [],
            "line": 42
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "db",
            "names": [
              "Run",
              "engine"
            ],
            "is_relative": true,
            "line": 33
          }
        ],
        "constants": [
          {
            "name": "IDEMPOTENCY_TTL_SECONDS",
            "line": 38
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "ledger.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/ledger.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 270,
        "module_docstring": "Discovery Ledger - signal recording helpers.\n\nCore principle: Discovery Ledger records curiosity, not decisions.\n\nThis module provides:\n- emit_signal(): Record a discovery signal (aggregating duplicates)\n- DiscoverySignal: Pydantic model for signal data\n\nSignals are aggregated: same (artifact, field, signal_type) updates seen_count.\nNothing in the system depends on this table - it's pure observation.",
        "functions": [
          {
            "name": "emit_signal",
            "signature": "(artifact: str, signal_type: str, evidence: dict[str, Any], detected_by: str, field: Optional[str] = None, confidence: Optional[float] = None, notes: Optional[str] = None, phase: Optional[str] = None, environment: Optional[str] = None) -> Optional[UUID]",
            "docstring": "Record a discovery signal to the ledger.\n\nSignals are aggregated: same (artifact, field, signal_type) updates seen_count.\nThis is non-blocking and safe to call frequently.\n\nArgs:\n    artifact: Artifact name (e.g. \"prediction_events\")\n    signal_type: Signal type (e.g. \"high_operator_access\")\n    evidence: Evidence data as dict\n    detected_by: Subsystem name that detected the signal\n    field: Optional field name within the artifact\n    confidence: Optional confidence score 0.0-1.0\n    notes: Optional notes\n    phase: Current phase (defaults to env var or \"C\")\n    environment: Environment (defaults to env var or \"local\")\n\nReturns:\n    UUID of the signal record, or None if recording failed\n\nExample:\n    emit_signal(\n        artifact=\"prediction_events\",\n        signal_type=\"high_operator_access\",\n        evidence={\"count_7d\": 21, \"distinct_sessions\": 5},\n        detected_by=\"api_access_monitor\",\n        confidence=0.8\n    )",
            "is_async": false,
            "line": 60
          },
          {
            "name": "get_signals",
            "signature": "(artifact: Optional[str] = None, signal_type: Optional[str] = None, status: Optional[str] = None, limit: int = 100) -> list[dict]",
            "docstring": "Query discovery signals from the ledger.\n\nArgs:\n    artifact: Filter by artifact name\n    signal_type: Filter by signal type\n    status: Filter by status (observed/ignored/promoted)\n    limit: Max records to return\n\nReturns:\n    List of signal records as dicts",
            "is_async": false,
            "line": 190
          }
        ],
        "classes": [
          {
            "name": "DiscoverySignal",
            "docstring": "Discovery signal data model.",
            "methods": [],
            "line": 48
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy.exc",
            "names": [
              "SQLAlchemyError"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "schema_parity.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/schema_parity.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 166,
        "module_docstring": "M26 Prevention Mechanism #2: Startup Schema Parity Guard\n=========================================================\n\nINVARIANT: SQLModel metadata must match live DB schema exactly.\nIf not \u2192 hard crash on boot.\n\nWhy hard-fail?\nBecause cost integrity errors are worse than downtime.",
        "functions": [
          {
            "name": "check_schema_parity",
            "signature": "(engine: Engine, models: Optional[List[type]] = None, hard_fail: bool = True) -> Tuple[bool, List[str]]",
            "docstring": "Check that SQLModel definitions match actual database schema.\n\nArgs:\n    engine: SQLAlchemy engine\n    models: List of SQLModel classes to check (default: all with __tablename__)\n    hard_fail: If True, raise exception on mismatch\n\nReturns:\n    Tuple of (is_valid, list of errors)",
            "is_async": false,
            "line": 49
          },
          {
            "name": "check_m26_cost_tables",
            "signature": "(engine: Engine) -> Tuple[bool, List[str]]",
            "docstring": "Specific check for M26 cost tables - the most critical.\n\nThese tables MUST match exactly:\n- feature_tags\n- cost_records\n- cost_anomalies\n- cost_budgets\n- cost_daily_aggregates",
            "is_async": false,
            "line": 117
          },
          {
            "name": "run_startup_parity_check",
            "signature": "(engine: Engine) -> None",
            "docstring": "Run full schema parity check on startup.\nCall this from main.py before accepting requests.",
            "is_async": false,
            "line": 143
          }
        ],
        "classes": [
          {
            "name": "SchemaParityError",
            "docstring": "Raised when model schema doesn't match database schema.",
            "methods": [],
            "line": 43
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "sqlalchemy",
            "names": [
              "inspect"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "sqlalchemy.engine",
            "names": [
              "Engine"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlmodel",
            "names": [
              "SQLModel"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "worker_write_service_async.py",
        "file_path": "backend/app/hoc/cus/general/L6_drivers/worker_write_service_async.py",
        "layer": "L6_drivers",
        "domain": "general",
        "lines": 222,
        "module_docstring": "Worker Write Service (Async) - DB write operations for Worker API.\n\nPhase 2B Batch 4: Extracted from api/workers.py.\n\nConstraints (enforced by PIN-250):\n- Write-only: No policy logic\n- No cross-service calls\n- No domain refactoring\n- Call-path relocation only\n- Preserve async semantics exactly",
        "functions": [],
        "classes": [
          {
            "name": "WorkerWriteServiceAsync",
            "docstring": "Async DB write operations for Worker API.\n\nWrite-only facade. No policy logic, no branching beyond DB operations.\nAll methods preserve existing async execution model.",
            "methods": [
              "__init__",
              "upsert_worker_run",
              "insert_cost_record",
              "insert_cost_advisory",
              "delete_worker_run",
              "get_worker_run"
            ],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.db",
            "names": [
              "CostAnomaly",
              "CostRecord"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 80,
    "violation_count": 11,
    "gap_count": 4
  },
  "overview": {
    "l2_1_facade": null,
    "l2_apis": [
      {
        "file_name": "overview.py",
        "file_path": "backend/app/hoc/api/cus/overview/overview.py",
        "layer": "L2_api",
        "domain": "overview",
        "lines": 519,
        "module_docstring": "Unified Overview API (L2)\n\nCustomer-facing endpoints for system overview and health.\nAll requests are tenant-scoped via auth_context.\n\nEndpoints:\n- GET /api/v1/overview/highlights      \u2192 O1 system pulse & domain counts (Activity, Incidents, Policies)\n- GET /api/v1/overview/decisions       \u2192 O2 pending decisions queue\n- GET /api/v1/overview/decisions/count \u2192 O2 decisions count summary\n- GET /api/v1/overview/costs           \u2192 O2 cost intelligence summary\n- GET /api/v1/overview/recovery-stats  \u2192 O3 recovery statistics\n\nThis is the ONLY facade for overview operations.\nAll overview APIs flow through this router.",
        "functions": [
          {
            "name": "require_preflight",
            "signature": "() -> None",
            "docstring": "Guard for preflight-only endpoints (O4, O5).",
            "is_async": false,
            "line": 63
          },
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 221
          },
          {
            "name": "get_highlights",
            "signature": "(request: Request, session: AsyncSession = Depends(get_async_session_dep)) -> HighlightsResponse",
            "docstring": "System pulse and domain counts. Tenant-scoped.",
            "is_async": true,
            "line": 259
          },
          {
            "name": "get_decisions",
            "signature": "(request: Request, source_domain: Annotated[str | None, Query(description='Filter by source: INCIDENT, POLICY', pattern='^(INCIDENT|POLICY)$')] = None, priority: Annotated[str | None, Query(description='Filter by priority: CRITICAL, HIGH, MEDIUM, LOW', pattern='^(CRITICAL|HIGH|MEDIUM|LOW)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max items')] = 50, offset: Annotated[int, Query(ge=0, description='Items to skip')] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> DecisionsResponse",
            "docstring": "Pending decisions from incidents and policy proposals. Tenant-scoped.",
            "is_async": true,
            "line": 313
          },
          {
            "name": "get_costs",
            "signature": "(request: Request, period_days: Annotated[int, Query(ge=1, le=365, description='Period in days')] = 30, session: AsyncSession = Depends(get_async_session_dep)) -> CostsResponse",
            "docstring": "Cost intelligence summary. Tenant-scoped.",
            "is_async": true,
            "line": 390
          },
          {
            "name": "get_decisions_count",
            "signature": "(request: Request, session: AsyncSession = Depends(get_async_session_dep)) -> DecisionsCountResponse",
            "docstring": "Decisions count by domain and priority. Tenant-scoped.",
            "is_async": true,
            "line": 450
          },
          {
            "name": "get_recovery_stats",
            "signature": "(request: Request, period_days: Annotated[int, Query(ge=1, le=365, description='Period in days')] = 30, session: AsyncSession = Depends(get_async_session_dep)) -> RecoveryStatsResponse",
            "docstring": "Recovery statistics from incidents. Tenant-scoped.",
            "is_async": true,
            "line": 489
          }
        ],
        "classes": [
          {
            "name": "DomainCount",
            "docstring": "Count for a specific domain.",
            "methods": [],
            "line": 80
          },
          {
            "name": "SystemPulse",
            "docstring": "System health pulse summary.",
            "methods": [],
            "line": 88
          },
          {
            "name": "HighlightsResponse",
            "docstring": "GET /highlights response (O1).",
            "methods": [],
            "line": 98
          },
          {
            "name": "DecisionItem",
            "docstring": "A pending decision requiring human action.",
            "methods": [],
            "line": 110
          },
          {
            "name": "Pagination",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 121
          },
          {
            "name": "DecisionsResponse",
            "docstring": "GET /decisions response (O2).",
            "methods": [],
            "line": 128
          },
          {
            "name": "CostPeriod",
            "docstring": "Time period for cost calculation.",
            "methods": [],
            "line": 142
          },
          {
            "name": "CostActuals",
            "docstring": "Actual costs incurred.",
            "methods": [],
            "line": 148
          },
          {
            "name": "LimitCostItem",
            "docstring": "Single limit with cost status.",
            "methods": [],
            "line": 153
          },
          {
            "name": "CostViolations",
            "docstring": "Cost violation summary.",
            "methods": [],
            "line": 164
          },
          {
            "name": "CostsResponse",
            "docstring": "GET /costs response (O2).",
            "methods": [],
            "line": 170
          },
          {
            "name": "DecisionsCountResponse",
            "docstring": "GET /decisions/count response.",
            "methods": [],
            "line": 184
          },
          {
            "name": "RecoveryStatsResponse",
            "docstring": "GET /recovery-stats response.",
            "methods": [],
            "line": 196
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session_dep"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.overview.L5_engines.overview_facade",
            "names": [
              "get_overview_facade"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [
          {
            "name": "_CURRENT_ENVIRONMENT",
            "line": 60
          }
        ],
        "all_exports": null
      }
    ],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "overview_facade.py",
        "file_path": "backend/app/hoc/cus/overview/L5_engines/overview_facade.py",
        "layer": "L5_engines",
        "domain": "overview",
        "lines": 619,
        "module_docstring": "Overview Engine (L5 Domain Logic)\n\nThis facade provides the external interface for overview operations.\nAll overview APIs MUST use this facade instead of directly importing\nmodels or executing queries in L2.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L6 layer violations (direct model imports)\n- Centralizes overview aggregation logic\n- Single point for tenant-scoped queries\n- Maintains projection-only architecture\n\nARCHITECTURAL RULE:\n- Overview DOES NOT own any tables\n- Overview aggregates/projects from existing domains\n- All operations are READ-ONLY\n- All DB access is delegated to overview_facade_driver.py (L6)\n\nL2 API Routes:\n- GET /api/v1/overview/highlights      \u2192 O1 system pulse & domain counts\n- GET /api/v1/overview/decisions       \u2192 O2 pending decisions queue\n- GET /api/v1/overview/decisions/count \u2192 O2 decisions count summary\n- GET /api/v1/overview/costs           \u2192 O2 cost intelligence summary\n- GET /api/v1/overview/recovery-stats  \u2192 O3 recovery statistics\n\nUsage:\n    from app.hoc.cus.overview.L5_engines.overview_facade import get_overview_facade\n\n    facade = get_overview_facade()\n\n    # Get system highlights\n    highlights = await facade.get_highlights(session, tenant_id)",
        "functions": [
          {
            "name": "get_overview_facade",
            "signature": "() -> OverviewFacade",
            "docstring": "Get the singleton OverviewFacade instance.",
            "is_async": false,
            "line": 596
          }
        ],
        "classes": [
          {
            "name": "SystemPulse",
            "docstring": "System health pulse summary.",
            "methods": [
              "to_dict"
            ],
            "line": 85
          },
          {
            "name": "DomainCount",
            "docstring": "Count for a specific domain.",
            "methods": [
              "to_dict"
            ],
            "line": 107
          },
          {
            "name": "HighlightsResult",
            "docstring": "Result from get_highlights.",
            "methods": [
              "to_dict"
            ],
            "line": 125
          },
          {
            "name": "DecisionItem",
            "docstring": "A pending decision requiring human action.",
            "methods": [
              "to_dict"
            ],
            "line": 141
          },
          {
            "name": "DecisionsResult",
            "docstring": "Result from get_decisions.",
            "methods": [
              "to_dict"
            ],
            "line": 165
          },
          {
            "name": "CostPeriod",
            "docstring": "Time period for cost calculation.",
            "methods": [
              "to_dict"
            ],
            "line": 183
          },
          {
            "name": "LimitCostItem",
            "docstring": "Single limit with cost status.",
            "methods": [
              "to_dict"
            ],
            "line": 197
          },
          {
            "name": "CostsResult",
            "docstring": "Result from get_costs.",
            "methods": [
              "to_dict"
            ],
            "line": 221
          },
          {
            "name": "DecisionsCountResult",
            "docstring": "Result from get_decisions_count.",
            "methods": [
              "to_dict"
            ],
            "line": 245
          },
          {
            "name": "RecoveryStatsResult",
            "docstring": "Result from get_recovery_stats.",
            "methods": [
              "to_dict"
            ],
            "line": 261
          },
          {
            "name": "OverviewFacade",
            "docstring": "Overview Facade - Centralized access to overview domain operations.\n\nThis facade aggregates data from multiple domains:\n- Activity (WorkerRun)\n- Incidents (Incident)\n- Policies (PolicyProposal, Limit, LimitBreach)\n- Logs (AuditLedger)\n\nAll DB access is delegated to OverviewFacadeDriver (L6).\nThis facade only contains business logic composition.",
            "methods": [
              "__init__",
              "get_highlights",
              "get_decisions",
              "get_costs",
              "get_decisions_count",
              "get_recovery_stats"
            ],
            "line": 287
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.hoc.cus.overview.L6_drivers.overview_facade_driver",
            "names": [
              "OverviewFacadeDriver"
            ],
            "is_relative": false,
            "line": 69
          }
        ],
        "constants": [],
        "all_exports": [
          "OverviewFacade",
          "get_overview_facade",
          "SystemPulse",
          "DomainCount",
          "HighlightsResult",
          "DecisionItem",
          "DecisionsResult",
          "CostPeriod",
          "LimitCostItem",
          "CostsResult",
          "DecisionsCountResult",
          "RecoveryStatsResult"
        ]
      }
    ],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "overview_facade_driver.py",
        "file_path": "backend/app/hoc/cus/overview/L6_drivers/overview_facade_driver.py",
        "layer": "L6_drivers",
        "domain": "overview",
        "lines": 519,
        "module_docstring": "Overview Facade Driver (L6 Data Access)\n\nThis driver contains all database queries for the overview domain.\nIt returns snapshot dataclasses to the facade (L4) for business logic composition.\n\nARCHITECTURAL RULE:\n- This driver ONLY performs data access\n- NO business logic (no severity thresholds, no status calculations)\n- Returns raw query results as typed snapshots\n- The facade composes business results from these snapshots",
        "functions": [],
        "classes": [
          {
            "name": "IncidentCountSnapshot",
            "docstring": "Raw incident count data from DB.",
            "methods": [],
            "line": 65
          },
          {
            "name": "ProposalCountSnapshot",
            "docstring": "Raw policy proposal count data from DB.",
            "methods": [],
            "line": 74
          },
          {
            "name": "BreachCountSnapshot",
            "docstring": "Raw limit breach count data from DB.",
            "methods": [],
            "line": 82
          },
          {
            "name": "RunCountSnapshot",
            "docstring": "Raw worker run count data from DB.",
            "methods": [],
            "line": 89
          },
          {
            "name": "AuditCountSnapshot",
            "docstring": "Raw audit count data from DB.",
            "methods": [],
            "line": 98
          },
          {
            "name": "IncidentSnapshot",
            "docstring": "Snapshot of a single incident for decisions projection.",
            "methods": [],
            "line": 105
          },
          {
            "name": "ProposalSnapshot",
            "docstring": "Snapshot of a single policy proposal for decisions projection.",
            "methods": [],
            "line": 116
          },
          {
            "name": "LimitSnapshot",
            "docstring": "Snapshot of a single limit for cost projection.",
            "methods": [],
            "line": 126
          },
          {
            "name": "RunCostSnapshot",
            "docstring": "Snapshot of run cost data from DB.",
            "methods": [],
            "line": 137
          },
          {
            "name": "BreachStatsSnapshot",
            "docstring": "Snapshot of breach statistics from DB.",
            "methods": [],
            "line": 144
          },
          {
            "name": "IncidentDecisionCountSnapshot",
            "docstring": "Snapshot of incident counts by severity for decisions count.",
            "methods": [],
            "line": 152
          },
          {
            "name": "RecoverySnapshot",
            "docstring": "Snapshot of incident recovery data from DB.",
            "methods": [],
            "line": 162
          },
          {
            "name": "OverviewFacadeDriver",
            "docstring": "Overview Facade Driver - Pure data access layer.\n\nAll methods execute DB queries and return snapshot dataclasses.\nNo business logic or status calculations.",
            "methods": [
              "fetch_incident_counts",
              "fetch_proposal_counts",
              "fetch_breach_counts",
              "fetch_run_counts",
              "fetch_last_activity",
              "fetch_pending_incidents",
              "fetch_pending_proposals",
              "fetch_run_cost",
              "fetch_budget_limits",
              "fetch_breach_stats",
              "fetch_incident_decision_counts",
              "fetch_proposal_count",
              "fetch_recovery_stats"
            ],
            "line": 176
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "case",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "AuditLedger"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentLifecycleState"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyProposal"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitBreach",
              "LimitCategory"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": [
          "OverviewFacadeDriver",
          "IncidentCountSnapshot",
          "ProposalCountSnapshot",
          "BreachCountSnapshot",
          "RunCountSnapshot",
          "AuditCountSnapshot",
          "IncidentSnapshot",
          "ProposalSnapshot",
          "LimitSnapshot",
          "RunCostSnapshot",
          "BreachStatsSnapshot",
          "IncidentDecisionCountSnapshot",
          "RecoverySnapshot"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 3,
    "violation_count": 1,
    "gap_count": 3
  },
  "activity": {
    "l2_1_facade": null,
    "l2_apis": [
      {
        "file_name": "activity.py",
        "file_path": "backend/app/hoc/api/cus/activity/activity.py",
        "layer": "L2_api",
        "domain": "activity",
        "lines": 2570,
        "module_docstring": null,
        "functions": [
          {
            "name": "require_preflight",
            "signature": "() -> None",
            "docstring": "Guard for preflight-only endpoints (O4, O5).",
            "is_async": false,
            "line": 87
          },
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 747
          },
          {
            "name": "list_runs",
            "signature": "(request: Request, project_id: Annotated[str | None, Query(description='Project scope')] = None, state: Annotated[RunState | None, Query(description='Run lifecycle state')] = None, status: Annotated[list[str] | None, Query(description='Run status (multiple)')] = None, risk: Annotated[bool, Query(description='If true, returns runs with risk signals')] = False, risk_level: Annotated[list[RiskLevel] | None, Query(description='Filter by risk level')] = None, latency_bucket: Annotated[list[LatencyBucket] | None, Query(description='Filter by latency')] = None, evidence_health: Annotated[list[EvidenceHealth] | None, Query(description='Filter by evidence health')] = None, integrity_status: Annotated[list[IntegrityStatus] | None, Query(description='Filter by integrity')] = None, source: Annotated[list[RunSource] | None, Query(description='Filter by run source')] = None, provider_type: Annotated[list[ProviderType] | None, Query(description='Filter by LLM provider')] = None, is_synthetic: Annotated[bool | None, Query(description='Filter by synthetic data flag')] = None, started_after: Annotated[datetime | None, Query(description='Filter runs started after')] = None, started_before: Annotated[datetime | None, Query(description='Filter runs started before')] = None, completed_after: Annotated[datetime | None, Query(description='Filter runs completed after')] = None, completed_before: Annotated[datetime | None, Query(description='Filter runs completed before')] = None, limit: Annotated[int, Query(ge=1, le=200, description='Max runs to return')] = 50, offset: Annotated[int, Query(ge=0, description='Number of runs to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.STARTED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session: AsyncSession = Depends(get_async_session_dep)) -> RunListResponse",
            "docstring": "List runs with unified query filters. READ-ONLY from v_runs_o2 view.",
            "is_async": true,
            "line": 798
          },
          {
            "name": "get_run_detail",
            "signature": "(request: Request, run_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> RunDetailResponse",
            "docstring": "Get run detail (O3). Tenant isolation enforced.",
            "is_async": true,
            "line": 1028
          },
          {
            "name": "get_run_evidence",
            "signature": "(request: Request, run_id: str) -> dict[str, Any]",
            "docstring": "Get run evidence (O4). Preflight console only.",
            "is_async": true,
            "line": 1084
          },
          {
            "name": "get_run_proof",
            "signature": "(request: Request, run_id: str, include_payloads: bool = False) -> dict[str, Any]",
            "docstring": "Get run proof (O5). Preflight console only.",
            "is_async": true,
            "line": 1111
          },
          {
            "name": "get_summary_by_status",
            "signature": "(request: Request, state: Annotated[RunState | None, Query(description='Filter by run state')] = None, session: AsyncSession = Depends(get_async_session_dep)) -> StatusSummaryResponse",
            "docstring": "Get run summary by status (COMP-O3). READ-ONLY from v_runs_o2.",
            "is_async": true,
            "line": 1148
          },
          {
            "name": "_get_runs_by_dimension_internal",
            "signature": "(session: AsyncSession, tenant_id: str, dim: DimensionValue, state: RunState, limit: int = 20) -> DimensionBreakdownResponse",
            "docstring": "Internal helper for dimension breakdown with HARDCODED state binding.\n\nThis function is called by topic-scoped endpoints only.\nState is injected by the endpoint, never from caller.\n\nPolicy: TOPIC-SCOPED-ENDPOINT-001",
            "is_async": true,
            "line": 1202
          },
          {
            "name": "get_live_runs_by_dimension",
            "signature": "(request: Request, dim: Annotated[DimensionValue, Query(description='Dimension to group by')], limit: Annotated[int, Query(ge=1, le=100, description='Max groups to return')] = 20, session: AsyncSession = Depends(get_async_session_dep)) -> DimensionBreakdownResponse",
            "docstring": "Get LIVE runs grouped by dimension. State=LIVE is hardcoded.",
            "is_async": true,
            "line": 1278
          },
          {
            "name": "get_completed_runs_by_dimension",
            "signature": "(request: Request, dim: Annotated[DimensionValue, Query(description='Dimension to group by')], limit: Annotated[int, Query(ge=1, le=100, description='Max groups to return')] = 20, session: AsyncSession = Depends(get_async_session_dep)) -> DimensionBreakdownResponse",
            "docstring": "Get COMPLETED runs grouped by dimension. State=COMPLETED is hardcoded.",
            "is_async": true,
            "line": 1314
          },
          {
            "name": "get_runs_by_dimension",
            "signature": "(request: Request, dim: Annotated[DimensionValue, Query(description='Dimension to group by')], state: Annotated[RunState | None, Query(description='Filter by run state')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max groups to return')] = 20, session: AsyncSession = Depends(get_async_session_dep)) -> DimensionBreakdownResponse",
            "docstring": "[INTERNAL] Get runs grouped by dimension with optional state. NOT FOR PANELS.",
            "is_async": true,
            "line": 1352
          },
          {
            "name": "get_patterns",
            "signature": "(request: Request, window_hours: Annotated[int, Query(ge=1, le=168, description='Hours to look back')] = 24, limit: Annotated[int, Query(ge=1, le=50, description='Max patterns per type')] = 10, session: AsyncSession = Depends(get_async_session_dep)) -> PatternDetectionResponse",
            "docstring": "Detect instability patterns (SIG-O3). READ-ONLY from aos_traces/aos_trace_steps.",
            "is_async": true,
            "line": 1421
          },
          {
            "name": "get_cost_analysis",
            "signature": "(request: Request, baseline_days: Annotated[int, Query(ge=1, le=30, description='Days for baseline')] = 7, anomaly_threshold: Annotated[float, Query(ge=1.0, le=5.0, description='Threshold percentage')] = 50.0, session: AsyncSession = Depends(get_async_session_dep)) -> CostAnalysisResponse",
            "docstring": "Analyze cost anomalies (SIG-O4). READ-ONLY from runs table.",
            "is_async": true,
            "line": 1482
          },
          {
            "name": "get_attention_queue",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100, description='Max items to return')] = 20, session: AsyncSession = Depends(get_async_session_dep)) -> AttentionQueueResponse",
            "docstring": "Get attention queue (SIG-O5). READ-ONLY from v_runs_o2.",
            "is_async": true,
            "line": 1543
          },
          {
            "name": "get_risk_signals",
            "signature": "(request: Request, session: AsyncSession = Depends(get_async_session_dep)) -> RiskSignalsResponse",
            "docstring": "Returns aggregated risk signal counts.\n\nSupports: activity.risk_signals capability\nConsumers: Overview panels, Activity summary panels\n\nOnly considers:\n- Live runs (state = 'LIVE')\n- Completed runs in the last 24 hours",
            "is_async": true,
            "line": 1615
          },
          {
            "name": "_extract_policy_context",
            "signature": "(row: dict) -> PolicyContext",
            "docstring": "Extract PolicyContext from a v_runs_o2 row (V2 schema).\n\nThe v_runs_o2 view includes policy context fields from migration 107.\nThis helper converts DB row to PolicyContext model.\n\nCross-Domain Navigation (PIN-447):\n- facade_ref: Always populated if policy_id exists\n- threshold_ref: Populated if limit_id exists\n- violation_ref: Populated if violation_id exists",
            "is_async": false,
            "line": 1661
          },
          {
            "name": "_row_to_run_summary_v2",
            "signature": "(row: dict) -> RunSummaryV2",
            "docstring": "Convert a v_runs_o2 row to RunSummaryV2.\n\nIncludes policy_context extraction.",
            "is_async": false,
            "line": 1703
          },
          {
            "name": "list_live_runs",
            "signature": "(request: Request, project_id: Annotated[str | None, Query(description='Project scope')] = None, risk_level: Annotated[list[RiskLevel] | None, Query(description='Filter by risk level')] = None, evidence_health: Annotated[list[EvidenceHealth] | None, Query(description='Filter by evidence health')] = None, source: Annotated[list[RunSource] | None, Query(description='Filter by run source')] = None, provider_type: Annotated[list[ProviderType] | None, Query(description='Filter by LLM provider')] = None, limit: Annotated[int, Query(ge=1, le=200, description='Max runs to return')] = 50, offset: Annotated[int, Query(ge=0, description='Number of runs to skip')] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> LiveRunsResponse",
            "docstring": "List LIVE runs with policy context.\n\nState=LIVE is HARDCODED - cannot be overridden.\nThis is the canonical endpoint for the LIVE topic.",
            "is_async": true,
            "line": 1764
          },
          {
            "name": "list_completed_runs",
            "signature": "(request: Request, project_id: Annotated[str | None, Query(description='Project scope')] = None, status: Annotated[list[str] | None, Query(description='Run status (multiple)')] = None, risk_level: Annotated[list[RiskLevel] | None, Query(description='Filter by risk level')] = None, completed_after: Annotated[datetime | None, Query(description='Filter runs completed after')] = None, completed_before: Annotated[datetime | None, Query(description='Filter runs completed before')] = None, limit: Annotated[int, Query(ge=1, le=200, description='Max runs to return')] = 50, offset: Annotated[int, Query(ge=0, description='Number of runs to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.COMPLETED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session: AsyncSession = Depends(get_async_session_dep)) -> CompletedRunsResponse",
            "docstring": "List COMPLETED runs with policy context.\n\nState=COMPLETED is HARDCODED - cannot be overridden.\nThis is the canonical endpoint for the COMPLETED topic.",
            "is_async": true,
            "line": 1892
          },
          {
            "name": "list_signals",
            "signature": "(request: Request, project_id: Annotated[str | None, Query(description='Project scope')] = None, signal_type: Annotated[str | None, Query(description='Filter by signal type')] = None, severity: Annotated[str | None, Query(description='Filter by severity (HIGH, MEDIUM, LOW)')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max signals to return')] = 20, session: AsyncSession = Depends(get_async_session_dep)) -> SignalsResponse",
            "docstring": "List activity signals (V2 projection).\n\nSynthesizes signals from runs with attention-worthy conditions.\nSIGNALS is NOT a run state - it's a computed projection.",
            "is_async": true,
            "line": 2023
          },
          {
            "name": "get_activity_metrics",
            "signature": "(request: Request, session: AsyncSession = Depends(get_async_session_dep)) -> MetricsResponse",
            "docstring": "Get aggregated activity metrics (V2).\n\nProvides counts for:\n- Risk levels\n- Topic (LIVE vs COMPLETED)\n- Evidence health\n- Risk types",
            "is_async": true,
            "line": 2205
          },
          {
            "name": "get_threshold_signals",
            "signature": "(request: Request, risk_type: Annotated[RiskType | None, Query(description='Filter by risk type')] = None, evaluation_outcome: Annotated[EvaluationOutcome | None, Query(description='Filter by evaluation outcome')] = None, state: Annotated[RunState | None, Query(description='Filter by run state')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max signals to return')] = 20, session: AsyncSession = Depends(get_async_session_dep)) -> ThresholdSignalsResponse",
            "docstring": "Get threshold proximity signals (V2).\n\nReturns runs with threshold evaluation data.\nCan be filtered by risk_type (COST, TIME, TOKENS, RATE).",
            "is_async": true,
            "line": 2294
          },
          {
            "name": "acknowledge_signal",
            "signature": "(request: Request, signal_fingerprint: Annotated[str, Path(description='Canonical signal fingerprint (sig-{hash})')], body: SignalAckRequest, session: AsyncSession = Depends(get_async_session_dep)) -> SignalAckResponse",
            "docstring": "Acknowledge a signal.\n\nRecords acknowledgment in the audit_ledger.\nThe signal remains visible but receives a ranking dampener (0.6x).",
            "is_async": true,
            "line": 2413
          },
          {
            "name": "suppress_signal",
            "signature": "(request: Request, signal_fingerprint: Annotated[str, Path(description='Canonical signal fingerprint (sig-{hash})')], body: SignalSuppressRequest, session: AsyncSession = Depends(get_async_session_dep)) -> SignalSuppressResponse",
            "docstring": "Suppress a signal temporarily.\n\nRecords suppression in the audit_ledger with a suppress_until timestamp.\nThe signal is excluded from the attention queue until expiry.",
            "is_async": true,
            "line": 2487
          },
          {
            "name": "get_actor_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract actor ID from request auth context.\n\nFalls back to 'unknown' if not available (should not happen in production).",
            "is_async": false,
            "line": 2561
          }
        ],
        "classes": [
          {
            "name": "RunState",
            "docstring": "Run lifecycle state.",
            "methods": [],
            "line": 104
          },
          {
            "name": "RunStatus",
            "docstring": "Run execution status.",
            "methods": [],
            "line": 111
          },
          {
            "name": "RiskLevel",
            "docstring": "Risk classification.",
            "methods": [],
            "line": 122
          },
          {
            "name": "LatencyBucket",
            "docstring": "Latency classification.",
            "methods": [],
            "line": 131
          },
          {
            "name": "EvidenceHealth",
            "docstring": "Evidence capture health.",
            "methods": [],
            "line": 139
          },
          {
            "name": "IntegrityStatus",
            "docstring": "Integrity verification status.",
            "methods": [],
            "line": 147
          },
          {
            "name": "RunSource",
            "docstring": "Run initiator type.",
            "methods": [],
            "line": 156
          },
          {
            "name": "ProviderType",
            "docstring": "LLM provider.",
            "methods": [],
            "line": 164
          },
          {
            "name": "SortField",
            "docstring": "Allowed sort fields.",
            "methods": [],
            "line": 172
          },
          {
            "name": "SortOrder",
            "docstring": "Sort direction.",
            "methods": [],
            "line": 181
          },
          {
            "name": "EvaluationOutcome",
            "docstring": "Policy evaluation outcome.",
            "methods": [],
            "line": 188
          },
          {
            "name": "PolicyScope",
            "docstring": "Policy/limit scope.",
            "methods": [],
            "line": 198
          },
          {
            "name": "RiskType",
            "docstring": "Risk type classification for panels.",
            "methods": [],
            "line": 208
          },
          {
            "name": "PolicyContext",
            "docstring": "Policy context for a run (V2).\n\nAdvisory metadata showing why a run is at-risk.\nDerived at query time from limits table via v_runs_o2 view.\n\nCross-Domain Navigation (PIN-447):\n- facade_ref: Links to /policy/active/{policy_id}\n- threshold_ref: Links to /policy/thresholds/{id} (if limit-based)\n- violation_ref: Links to /policy/violations/{id} (if violation exists)\n\nReference: ACTIVITY_DOMAIN_V2_MIGRATION_PLAN.md, CROSS_DOMAIN_POLICY_CONTRACT.md",
            "methods": [],
            "line": 228
          },
          {
            "name": "RunSummaryV2",
            "docstring": "Run summary with policy context (V2).\n\nExtends RunSummary with mandatory policy_context field.\nUsed by topic-scoped endpoints: /live, /completed.\n\nReference: ACTIVITY_DOMAIN_CONTRACT.md (V2 sections)",
            "methods": [],
            "line": 261
          },
          {
            "name": "Pagination",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 310
          },
          {
            "name": "LiveRunsResponse",
            "docstring": "GET /activity/live response (V2).\n\nTopic-scoped endpoint - hardcoded state=LIVE.\nEvery run includes policy_context.\n\nPanels: LIVE-O1, LIVE-O3, LIVE-O5",
            "methods": [],
            "line": 318
          },
          {
            "name": "CompletedRunsResponse",
            "docstring": "GET /activity/completed response (V2).\n\nTopic-scoped endpoint - hardcoded state=COMPLETED.\nEvery run includes policy_context.\n\nPanels: COMP-O2, COMP-O5",
            "methods": [],
            "line": 335
          },
          {
            "name": "SignalFeedbackModel",
            "docstring": "Feedback state for a signal.\n\nINVARIANTS:\n- ATTN-DAMP-001: Acknowledgement dampening is idempotent (apply once, 0.6x)\n- SIGNAL-SUPPRESS-001: Suppression is temporary (15-1440 minutes)\n- SIGNAL-ACK-001: Acknowledgement records responsibility, doesn't hide signals",
            "methods": [],
            "line": 352
          },
          {
            "name": "SignalProjection",
            "docstring": "A signal projection (V2).\n\nSIGNALS is NOT a run state - it's a computed projection over LIVE + COMPLETED.\nEach signal includes policy_context for the underlying run.\n\nReference: ACTIVITY_DOMAIN_V2_MIGRATION_PLAN.md",
            "methods": [],
            "line": 368
          },
          {
            "name": "SignalsResponse",
            "docstring": "GET /activity/signals response (V2).\n\nProjection endpoint - synthesizes signals from LIVE + COMPLETED runs.\nReturns SignalProjection[], NOT runs.\n\nPanels: SIG-O1",
            "methods": [],
            "line": 389
          },
          {
            "name": "MetricsResponse",
            "docstring": "GET /activity/metrics response (V2).\n\nExtends /risk-signals with topic-aware counts.\n\nPanels: LIVE-O1, LIVE-O2, LIVE-O4, COMP-O1, COMP-O3",
            "methods": [],
            "line": 404
          },
          {
            "name": "ThresholdSignal",
            "docstring": "A threshold proximity signal (V2).\n\nUsed for runs approaching or exceeding limits.",
            "methods": [],
            "line": 437
          },
          {
            "name": "ThresholdSignalsResponse",
            "docstring": "GET /activity/threshold-signals response (V2).\n\nReturns runs with typed threshold proximity.\n\nPanels: LIVE-O2, COMP-O4, SIG-O2",
            "methods": [],
            "line": 451
          },
          {
            "name": "SignalAckRequest",
            "docstring": "POST /activity/signals/{signal_fingerprint}/ack request.\n\nINVARIANT (SIGNAL-ID-001): The signal_fingerprint in the path MUST match\nthe server-computed fingerprint. Clients provide identifying info for\nserver-side validation.",
            "methods": [],
            "line": 471
          },
          {
            "name": "SignalAckResponse",
            "docstring": "POST /activity/signals/{signal_fingerprint}/ack response.",
            "methods": [],
            "line": 486
          },
          {
            "name": "SignalSuppressRequest",
            "docstring": "POST /activity/signals/{signal_fingerprint}/suppress request.\n\nINVARIANT (SIGNAL-SUPPRESS-001): duration_minutes must be 15-1440 (max 24 hours).",
            "methods": [],
            "line": 497
          },
          {
            "name": "SignalSuppressResponse",
            "docstring": "POST /activity/signals/{signal_fingerprint}/suppress response.",
            "methods": [],
            "line": 511
          },
          {
            "name": "RunSummary",
            "docstring": "Run summary for list view (O2).",
            "methods": [],
            "line": 520
          },
          {
            "name": "RunListResponse",
            "docstring": "GET /runs response.",
            "methods": [],
            "line": 559
          },
          {
            "name": "RunDetailResponse",
            "docstring": "GET /runs/{run_id} response (O3).",
            "methods": [],
            "line": 569
          },
          {
            "name": "StatusBucket",
            "docstring": "A bucket in status summary.",
            "methods": [],
            "line": 607
          },
          {
            "name": "StatusSummaryResponse",
            "docstring": "GET /summary/by-status response (COMP-O3).",
            "methods": [],
            "line": 615
          },
          {
            "name": "DimensionValue",
            "docstring": "Allowed dimension values for grouping.",
            "methods": [],
            "line": 628
          },
          {
            "name": "DimensionGroup",
            "docstring": "A group in dimension breakdown.",
            "methods": [],
            "line": 638
          },
          {
            "name": "DimensionBreakdownResponse",
            "docstring": "GET /runs/by-dimension response (LIVE-O5).",
            "methods": [],
            "line": 646
          },
          {
            "name": "PatternMatchResponse",
            "docstring": "A detected pattern.",
            "methods": [],
            "line": 661
          },
          {
            "name": "PatternDetectionResponse",
            "docstring": "GET /patterns response (SIG-O3).",
            "methods": [],
            "line": 670
          },
          {
            "name": "AgentCostResponse",
            "docstring": "Cost analysis for a single agent.",
            "methods": [],
            "line": 684
          },
          {
            "name": "CostAnalysisResponse",
            "docstring": "GET /cost-analysis response (SIG-O4).",
            "methods": [],
            "line": 696
          },
          {
            "name": "AttentionItemResponse",
            "docstring": "An item in the attention queue.",
            "methods": [],
            "line": 711
          },
          {
            "name": "AttentionQueueResponse",
            "docstring": "GET /attention-queue response (SIG-O5).",
            "methods": [],
            "line": 722
          },
          {
            "name": "RiskSignalsResponse",
            "docstring": "GET /risk-signals response.",
            "methods": [],
            "line": 1587
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 17
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Path",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session_dep"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.activity_facade",
            "names": [
              "get_activity_facade"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 75
          }
        ],
        "constants": [
          {
            "name": "_CURRENT_ENVIRONMENT",
            "line": 84
          }
        ],
        "all_exports": null
      }
    ],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "activity_enums.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/activity_enums.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 120,
        "module_docstring": "Activity Domain Enums\n\nCanonical enum definitions for the activity domain.\nThese are the single source of truth for categorical fields.\n\nRules (per ACT-DUP-006, ACTIVITY_DTO_RULES.md):\n- No free-text categorical fields in Activity\n- Signals are governance inputs - they must be enumerable\n- Engines own canonical enums, facades import them",
        "functions": [],
        "classes": [
          {
            "name": "SignalType",
            "docstring": "Canonical signal types for activity domain.\n\nSignals are governance inputs and must be enumerable.\nNo free-text signal types allowed.",
            "methods": [],
            "line": 34
          },
          {
            "name": "SeverityLevel",
            "docstring": "Canonical severity levels for display/UI.\n\nRule (per ACT-DUP-005):\n- Engines speak numbers (severity_score: float 0.0-1.0)\n- Facades render labels (severity_level: SeverityLevel)\n\nConversion:\n- HIGH: score >= 0.7\n- MEDIUM: score >= 0.4\n- LOW: score < 0.4",
            "methods": [
              "from_score",
              "from_risk_level"
            ],
            "line": 53
          },
          {
            "name": "RunState",
            "docstring": "Run lifecycle state.",
            "methods": [],
            "line": 90
          },
          {
            "name": "RiskType",
            "docstring": "Types of risk for threshold signals.",
            "methods": [],
            "line": 97
          },
          {
            "name": "EvidenceHealth",
            "docstring": "Evidence health status.",
            "methods": [],
            "line": 106
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "SignalType",
          "SeverityLevel",
          "RunState",
          "RiskType",
          "EvidenceHealth"
        ]
      },
      {
        "file_name": "activity_facade.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/activity_facade.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 1387,
        "module_docstring": "Activity Facade (L5)\n\nProvides unified access to activity domain operations.\nThis is the single entry point for all activity business logic.\n\nOperations:\n- get_runs: List runs with filters\n- get_run_detail: Get run details (O3)\n- get_run_evidence: Get run evidence context (O4)\n- get_run_proof: Get run integrity proof (O5)\n- get_status_summary: Get runs grouped by status\n- get_patterns: Pattern detection (SIG-O3)\n- get_cost_analysis: Cost anomalies (SIG-O4)\n- get_attention_queue: Attention ranking (SIG-O5)\n- get_live_runs: V2 live runs with policy context\n- get_completed_runs: V2 completed runs with policy context\n- get_signals: V2 synthesized signals\n- get_metrics: V2 activity metrics\n- get_threshold_signals: V2 threshold proximity signals\n- get_risk_signals: Risk signal aggregates\n- acknowledge_signal: Acknowledge a signal\n- suppress_signal: Suppress a signal\n\nReference: ACTIVITY_DOMAIN_V2_MIGRATION_PLAN.md",
        "functions": [
          {
            "name": "get_activity_facade",
            "signature": "() -> ActivityFacade",
            "docstring": "Get the singleton ActivityFacade instance.",
            "is_async": false,
            "line": 1382
          }
        ],
        "classes": [
          {
            "name": "PolicyContextResult",
            "docstring": "Policy context for a run.",
            "methods": [],
            "line": 90
          },
          {
            "name": "RunSummaryResult",
            "docstring": "Run summary for list view.",
            "methods": [],
            "line": 110
          },
          {
            "name": "RunSummaryV2Result",
            "docstring": "Run summary with policy context (V2).",
            "methods": [],
            "line": 138
          },
          {
            "name": "RunListResult",
            "docstring": "Result of listing runs.",
            "methods": [],
            "line": 145
          },
          {
            "name": "RunsResult",
            "docstring": "Unified result for getting runs (V2).\n\nConsolidates LiveRunsResult and CompletedRunsResult per ACT-DUP-003.\nThese were 100% structurally identical - only the name differed.\n\nRule: If structures are identical today, they will diverge accidentally tomorrow.",
            "methods": [],
            "line": 155
          },
          {
            "name": "RunDetailResult",
            "docstring": "Run detail (O3) - extends summary with additional fields.\n\nRefactored per ACT-DUP-002: Detail DTOs must extend summary DTOs,\nnever re-declare shared fields. This prevents field drift and\nguarantees backward compatibility.",
            "methods": [],
            "line": 178
          },
          {
            "name": "RunEvidenceResult",
            "docstring": "Run evidence context (O4).",
            "methods": [],
            "line": 192
          },
          {
            "name": "RunProofResult",
            "docstring": "Run integrity proof (O5).",
            "methods": [],
            "line": 203
          },
          {
            "name": "StatusCount",
            "docstring": "Status count item.",
            "methods": [],
            "line": 214
          },
          {
            "name": "StatusSummaryResult",
            "docstring": "Summary by status.",
            "methods": [],
            "line": 222
          },
          {
            "name": "SignalProjectionResult",
            "docstring": "A signal projection.",
            "methods": [],
            "line": 235
          },
          {
            "name": "SignalsResult",
            "docstring": "Result of getting signals (V2).",
            "methods": [],
            "line": 250
          },
          {
            "name": "MetricsResult",
            "docstring": "Activity metrics (V2).",
            "methods": [],
            "line": 259
          },
          {
            "name": "ThresholdSignalResult",
            "docstring": "A threshold proximity signal.",
            "methods": [],
            "line": 279
          },
          {
            "name": "ThresholdSignalsResult",
            "docstring": "Result of getting threshold signals (V2).",
            "methods": [],
            "line": 290
          },
          {
            "name": "RiskSignalsResult",
            "docstring": "Risk signal aggregates.\n\nNOTE (ACT-DUP-004): This is a DERIVED PROJECTION of MetricsResult.\nThe get_risk_signals() method extracts a subset from get_metrics().\nIf you need full metrics, use MetricsResult directly.\n\nRule: Derived views must be explicitly labeled as such.",
            "methods": [],
            "line": 300
          },
          {
            "name": "ActivityFacade",
            "docstring": "Unified facade for Activity domain operations.\n\nThis class provides a single entry point for all activity business logic,\ndelegating to specialized services where appropriate.\n\nNote: Services are instantiated per-request with the session, as they\nrequire the session in their constructors.",
            "methods": [
              "__init__",
              "_get_driver",
              "_get_pattern_service",
              "_get_cost_service",
              "_get_attention_service",
              "_get_feedback_service",
              "get_runs",
              "get_run_detail",
              "get_run_evidence",
              "get_run_proof",
              "get_status_summary",
              "get_live_runs",
              "get_completed_runs",
              "_get_runs_with_policy_context",
              "get_signals",
              "_compute_signal_type",
              "_compute_severity",
              "_compute_signal_summary",
              "get_metrics",
              "get_threshold_signals",
              "get_risk_signals",
              "get_patterns",
              "get_cost_analysis",
              "get_attention_queue",
              "acknowledge_signal",
              "suppress_signal"
            ],
            "line": 338
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.hoc.cus.activity.L6_drivers.activity_read_driver",
            "names": [
              "get_activity_read_driver"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.attention_ranking_engine",
            "names": [
              "AttentionRankingService"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.cost_analysis_engine",
            "names": [
              "CostAnalysisService"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.pattern_detection_engine",
            "names": [
              "PatternDetectionService"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.signal_feedback_engine",
            "names": [
              "SignalFeedbackService",
              "AcknowledgeResult",
              "SuppressResult",
              "SignalFeedbackStatus"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.signal_identity",
            "names": [
              "compute_signal_fingerprint_from_row"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.activity_enums",
            "names": [
              "SignalType",
              "SeverityLevel",
              "RunState"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.pattern_detection_engine",
            "names": [
              "PatternDetectionResult",
              "DetectedPattern"
            ],
            "is_relative": false,
            "line": 319
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.cost_analysis_engine",
            "names": [
              "CostAnalysisResult",
              "CostAnomaly"
            ],
            "is_relative": false,
            "line": 323
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.attention_ranking_engine",
            "names": [
              "AttentionQueueResult",
              "AttentionSignal"
            ],
            "is_relative": false,
            "line": 327
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "attention_ranking_engine.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/attention_ranking_engine.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 99,
        "module_docstring": "Attention ranking engine for prioritizing signals.",
        "functions": [],
        "classes": [
          {
            "name": "AttentionSignal",
            "docstring": "A signal in the attention queue.",
            "methods": [],
            "line": 30
          },
          {
            "name": "AttentionQueueResult",
            "docstring": "Result of attention queue query.",
            "methods": [],
            "line": 48
          },
          {
            "name": "AttentionRankingService",
            "docstring": "Service for ranking and prioritizing activity signals.\n\nComputes attention scores based on:\n- Signal severity\n- Recency\n- Pattern frequency\n- User acknowledgment status",
            "methods": [
              "__init__",
              "get_attention_queue",
              "compute_attention_score"
            ],
            "line": 56
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cost_analysis_engine.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/cost_analysis_engine.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 93,
        "module_docstring": "Cost analysis engine for detecting cost anomalies.",
        "functions": [],
        "classes": [
          {
            "name": "CostAnomaly",
            "docstring": "A detected cost anomaly.",
            "methods": [],
            "line": 30
          },
          {
            "name": "CostAnalysisResult",
            "docstring": "Result of cost analysis.",
            "methods": [],
            "line": 47
          },
          {
            "name": "CostAnalysisService",
            "docstring": "Service for analyzing cost patterns and detecting anomalies.\n\nDetects:\n- Cost spikes (sudden increases)\n- Cost trends (gradual increases)\n- Threshold breaches (exceeding limits)",
            "methods": [
              "__init__",
              "analyze_costs",
              "get_cost_breakdown"
            ],
            "line": 56
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_telemetry_service.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/cus_telemetry_service.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 77,
        "module_docstring": "CusTelemetryService (SWEEP-03 Batch 2)\n\nPURPOSE:\n    Customer telemetry ingestion and usage reporting.\n    Called by cus_telemetry.py API endpoints.\n\nINTERFACE:\n    - CusTelemetryService (alias for CusTelemetryEngine)\n    - IngestResult (dataclass)\n    - BatchIngestResult (dataclass)\n    - get_cus_telemetry_service() -> CusTelemetryService\n\nIMPLEMENTATION NOTES:\n    Re-exports from existing cus_telemetry_engine.py which is already\n    properly structured with L4/L6 separation.\n    Future work may fully migrate the implementation to HOC.",
        "functions": [
          {
            "name": "get_cus_telemetry_service",
            "signature": "() -> CusTelemetryService",
            "docstring": "Get the CusTelemetryService instance.\n\nReturns:\n    CusTelemetryService instance\n\nNote:\n    Delegates to get_cus_telemetry_engine() which creates the engine\n    with proper L6 driver injection.",
            "is_async": false,
            "line": 57
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.services.cus_telemetry_engine",
            "names": [
              "BatchIngestResult",
              "CusTelemetryEngine",
              "IngestResult",
              "get_cus_telemetry_engine"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "CusTelemetryService",
          "CusTelemetryEngine",
          "IngestResult",
          "BatchIngestResult",
          "get_cus_telemetry_service",
          "get_cus_telemetry_engine"
        ]
      },
      {
        "file_name": "pattern_detection_engine.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/pattern_detection_engine.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 92,
        "module_docstring": "Pattern detection engine for identifying recurring patterns.",
        "functions": [],
        "classes": [
          {
            "name": "DetectedPattern",
            "docstring": "A detected activity pattern.",
            "methods": [],
            "line": 30
          },
          {
            "name": "PatternDetectionResult",
            "docstring": "Result of pattern detection.",
            "methods": [],
            "line": 47
          },
          {
            "name": "PatternDetectionService",
            "docstring": "Service for detecting patterns in activity data.\n\nDetects:\n- Failure clusters (similar failures occurring together)\n- Latency spikes (performance degradation patterns)\n- Error recurrence (repeated error types)",
            "methods": [
              "__init__",
              "detect_patterns",
              "get_pattern_detail"
            ],
            "line": 56
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "signal_feedback_engine.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/signal_feedback_engine.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 140,
        "module_docstring": "Signal feedback engine for user interactions with signals.",
        "functions": [],
        "classes": [
          {
            "name": "AcknowledgeResult",
            "docstring": "Result of acknowledging a signal.",
            "methods": [],
            "line": 30
          },
          {
            "name": "SuppressResult",
            "docstring": "Result of suppressing a signal.",
            "methods": [],
            "line": 41
          },
          {
            "name": "SignalFeedbackStatus",
            "docstring": "Current feedback status for a signal.",
            "methods": [],
            "line": 54
          },
          {
            "name": "SignalFeedbackService",
            "docstring": "Service for managing user feedback on signals.\n\nProvides:\n- Acknowledge: Mark signal as seen/reviewed\n- Suppress: Temporarily hide signal from attention queue",
            "methods": [
              "__init__",
              "acknowledge_signal",
              "suppress_signal",
              "get_signal_feedback_status",
              "get_bulk_signal_feedback"
            ],
            "line": 64
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "signal_identity.py",
        "file_path": "backend/app/hoc/cus/activity/L5_engines/signal_identity.py",
        "layer": "L5_engines",
        "domain": "activity",
        "lines": 79,
        "module_docstring": "Signal identity utilities for fingerprinting and deduplication.",
        "functions": [
          {
            "name": "compute_signal_fingerprint_from_row",
            "signature": "(row: dict[str, Any]) -> str",
            "docstring": "Compute a stable fingerprint for a signal row.\n\nUsed for:\n- Signal deduplication\n- Change detection\n- Idempotent signal creation\n\nArgs:\n    row: A dictionary containing signal data\n\nReturns:\n    A hex digest fingerprint string",
            "is_async": false,
            "line": 26
          },
          {
            "name": "compute_signal_fingerprint",
            "signature": "(signal_type: str, dimension: str, source: str, tenant_id: str) -> str",
            "docstring": "Compute a stable fingerprint for signal identity fields.\n\nArgs:\n    signal_type: Type of signal (e.g., \"pattern\", \"anomaly\")\n    dimension: Dimension being measured\n    source: Source of the signal\n    tenant_id: Tenant identifier\n\nReturns:\n    A hex digest fingerprint string",
            "is_async": false,
            "line": 56
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 23
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "activity_read_driver.py",
        "file_path": "backend/app/hoc/cus/activity/L6_drivers/activity_read_driver.py",
        "layer": "L6_drivers",
        "domain": "activity",
        "lines": 344,
        "module_docstring": "Activity Read Driver (L6 Data Access)\n\nHandles database operations for activity queries:\n- Fetching runs with filters\n- Fetching run details\n- Fetching metrics aggregates\n- Fetching threshold signals\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_activity_read_driver",
            "signature": "(session: AsyncSession) -> ActivityReadDriver",
            "docstring": "Get an ActivityReadDriver instance.",
            "is_async": false,
            "line": 342
          }
        ],
        "classes": [
          {
            "name": "ActivityReadDriver",
            "docstring": "L6 Driver for activity read operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (risk computation, signal synthesis) stay in L5.",
            "methods": [
              "__init__",
              "count_runs",
              "fetch_runs",
              "fetch_run_detail",
              "fetch_status_summary",
              "fetch_runs_with_policy_context",
              "fetch_at_risk_runs",
              "fetch_metrics",
              "fetch_threshold_signals"
            ],
            "line": 48
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "orphan_recovery.py",
        "file_path": "backend/app/hoc/cus/activity/L6_drivers/orphan_recovery.py",
        "layer": "L6_drivers",
        "domain": "activity",
        "lines": 259,
        "module_docstring": null,
        "functions": [
          {
            "name": "detect_orphaned_runs",
            "signature": "(session: AsyncSession, threshold_minutes: int = ORPHAN_THRESHOLD_MINUTES) -> list[WorkerRun]",
            "docstring": "Detect runs that appear to be orphaned.\n\nA run is orphaned if:\n- Status is \"running\" and created > threshold_minutes ago\n- Status is \"queued\" and created > threshold_minutes ago\n\nThe threshold prevents marking in-progress runs as orphaned.",
            "is_async": true,
            "line": 66
          },
          {
            "name": "mark_run_as_crashed",
            "signature": "(session: AsyncSession, run: WorkerRun, reason: str = 'System restart - run was in progress when system crashed') -> bool",
            "docstring": "Mark a run as crashed.\n\nThis is a factual status update, not a mutation of historical data.\nThe run WAS running/queued, and it DID crash. We're recording that fact.\n\nReturns True if successfully marked, False otherwise.",
            "is_async": true,
            "line": 91
          },
          {
            "name": "recover_orphaned_runs",
            "signature": "(threshold_minutes: Optional[int] = None) -> dict",
            "docstring": "Main recovery function - called on startup.\n\nDetects and marks all orphaned runs as crashed.\n\nReturns a summary dict with:\n- detected: number of orphaned runs found\n- recovered: number successfully marked as crashed\n- failed: number that failed to mark\n- runs: list of run IDs processed",
            "is_async": true,
            "line": 137
          },
          {
            "name": "get_crash_recovery_summary",
            "signature": "() -> dict",
            "docstring": "Get a summary of crashed runs for operator visibility.\n\nReturns counts and recent crashed runs for /ops dashboard.",
            "is_async": true,
            "line": 225
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select",
              "update"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 27
          },
          {
            "name": "RETRY_POLICY",
            "line": 28
          },
          {
            "name": "ORPHAN_THRESHOLD_MINUTES",
            "line": 62
          },
          {
            "name": "RECOVERY_ENABLED",
            "line": 63
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "run_signal_service.py",
        "file_path": "backend/app/hoc/cus/activity/L6_drivers/run_signal_service.py",
        "layer": "L6_drivers",
        "domain": "activity",
        "lines": 188,
        "module_docstring": "RunSignalService (L6 Driver)\n\nPURPOSE:\n    Updates run risk levels based on threshold signals.\n    Bridges threshold evaluation (L5) to run state (L7).\n\nINTERFACE:\n    - RunSignalService(session): Constructor takes sync session\n    - update_risk_level(run_id, signals): Updates risk level for a run\n\nL6 CONTRACT:\n    - Pure data access, no business logic\n    - Does NOT determine which signals to emit (that's L5)\n    - Only persists signal outcomes to runs table\n\nCALLERS:\n    - threshold_driver.py: emit_and_persist_threshold_signal()\n    - llm_threshold_driver.py: emit_and_persist_threshold_signal()",
        "functions": [],
        "classes": [
          {
            "name": "RunSignalService",
            "docstring": "Service for updating run risk levels based on threshold signals.\n\nL6 Driver Contract:\n- Pure data access, no business logic\n- Takes sync session (for worker/callback context)\n- Updates runs.risk_level column\n\nUsage:\n    service = RunSignalService(session)\n    service.update_risk_level(run_id, signals)",
            "methods": [
              "__init__",
              "update_risk_level",
              "get_risk_level"
            ],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [
          {
            "name": "SIGNAL_TO_RISK_LEVEL",
            "line": 56
          },
          {
            "name": "DEFAULT_RISK_LEVEL",
            "line": 64
          }
        ],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 12,
    "violation_count": 1,
    "gap_count": 3
  },
  "incidents": {
    "l2_1_facade": null,
    "l2_apis": [
      {
        "file_name": "cost_guard.py",
        "file_path": "backend/app/hoc/api/cus/incidents/cost_guard.py",
        "layer": "L2_api",
        "domain": "incidents",
        "lines": 556,
        "module_docstring": "Guard Console Cost Visibility API - Customer Cost Transparency\n\nM29 Category 4: Cost Intelligence Completion\n\nThis router provides /guard/costs/* endpoints for the Customer Console.\nCustomers see their own cost data with calm vocabulary.\n\nTHE INVARIANT: All values derive from complete snapshots, never live data.\nCustomer sees ONLY their own tenant data - no cross-tenant leakage.\n\nEndpoints:\n- GET  /guard/costs/summary    - Cost summary with trend and projection\n- GET  /guard/costs/explained  - Why costs are what they are\n- GET  /guard/costs/incidents  - Cost-related incidents\n\nCRITICAL: Uses FROZEN DTOs from app.contracts.guard.\nNEVER expose founder-only fields (affected_tenants, churn_risk, etc.).",
        "functions": [
          {
            "name": "_map_trend",
            "signature": "(deviation_pct: Optional[float]) -> tuple[Literal['normal', 'rising', 'spike'], str]",
            "docstring": "Map deviation to customer-friendly trend.",
            "is_async": false,
            "line": 66
          },
          {
            "name": "_map_severity_to_status",
            "signature": "(severity: str) -> Literal['protected', 'attention_needed', 'resolved']",
            "docstring": "Map internal severity to calm vocabulary.",
            "is_async": false,
            "line": 81
          },
          {
            "name": "_generate_summary",
            "signature": "(by_feature: List[CostBreakdownItemDTO], by_model: List[CostBreakdownItemDTO], total_spend: int) -> str",
            "docstring": "Generate a one-sentence summary of cost drivers.",
            "is_async": false,
            "line": 91
          },
          {
            "name": "get_cost_summary",
            "signature": "(tenant_id: str = Query(..., description='Your tenant ID'), token: CustomerToken = Depends(verify_console_token), session: Session = Depends(get_session)) -> CustomerCostSummaryDTO",
            "docstring": "GET /guard/costs/summary\n\nCustomer cost summary with trend and projection.\nUses calm vocabulary: normal, rising, spike (not critical/high/medium).\n\nShows:\n- Today spend, MTD spend, 7d spend\n- Budget usage (if configured)\n- Projected month-end\n- Trend with human-readable message",
            "is_async": true,
            "line": 123
          },
          {
            "name": "get_cost_explained",
            "signature": "(tenant_id: str = Query(..., description='Your tenant ID'), period: Literal['today', '7d', '30d'] = Query('7d'), token: CustomerToken = Depends(verify_console_token), session: Session = Depends(get_session)) -> CustomerCostExplainedDTO",
            "docstring": "GET /guard/costs/explained\n\nExplains WHY costs are what they are.\nBreaks down by feature, model, and user.\n\nDoes NOT expose:\n- churn_risk_score (founder only)\n- affected_tenants (founder only)\n- stickiness_delta (founder only)",
            "is_async": true,
            "line": 249
          },
          {
            "name": "get_cost_incidents",
            "signature": "(tenant_id: str = Query(..., description='Your tenant ID'), include_resolved: bool = Query(False), limit: int = Query(20, ge=1, le=100), token: CustomerToken = Depends(verify_console_token), session: Session = Depends(get_session)) -> CustomerCostIncidentListDTO",
            "docstring": "GET /guard/costs/incidents\n\nCost-related incidents visible to customer.\nUses calm vocabulary (protected, attention_needed).\nDoes NOT expose severity levels directly.",
            "is_async": true,
            "line": 449
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Literal",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "CustomerToken",
              "verify_console_token"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.contracts.guard",
            "names": [
              "CostBreakdownItemDTO",
              "CustomerCostExplainedDTO",
              "CustomerCostIncidentDTO",
              "CustomerCostIncidentListDTO",
              "CustomerCostSummaryDTO"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.db",
            "names": [
              "get_session"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incidents.py",
        "file_path": "backend/app/hoc/api/cus/incidents/incidents.py",
        "layer": "L2_api",
        "domain": "incidents",
        "lines": 2023,
        "module_docstring": "Unified Incidents API (L2)\n\nCustomer-facing endpoints for viewing incidents.\nAll requests are tenant-scoped via auth_context.\n\nEndpoints:\n- GET /api/v1/incidents                        \u2192 O2 list with filters\n- GET /api/v1/incidents/{incident_id}          \u2192 O3 detail\n- GET /api/v1/incidents/{incident_id}/evidence \u2192 O4 context (preflight)\n- GET /api/v1/incidents/{incident_id}/proof    \u2192 O5 raw (preflight)\n- GET /api/v1/incidents/{incident_id}/learnings \u2192 O4 post-mortem learnings\n- GET /api/v1/incidents/by-run/{run_id}        \u2192 Incidents linked to run\n- GET /api/v1/incidents/patterns               \u2192 ACT-O5 pattern detection\n- GET /api/v1/incidents/recurring              \u2192 HIST-O3 recurrence analysis\n- GET /api/v1/incidents/cost-impact            \u2192 RES-O3 cost impact analysis\n\nArchitecture:\n- ONE facade for all INCIDENTS needs\n- Tenant isolation via auth_context (not header)\n- SDSR validates this same production API",
        "functions": [
          {
            "name": "require_preflight",
            "signature": "() -> None",
            "docstring": "Guard for preflight-only endpoints (O4, O5).",
            "is_async": false,
            "line": 67
          },
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 452
          },
          {
            "name": "list_incidents",
            "signature": "(request: Request, topic: Annotated[Topic | None, Query(description='UX Topic: ACTIVE or RESOLVED')] = None, lifecycle_state: Annotated[LifecycleState | None, Query(description='Direct lifecycle state filter')] = None, severity: Annotated[Severity | None, Query(description='Filter by severity')] = None, category: Annotated[str | None, Query(description='Filter by category')] = None, cause_type: Annotated[CauseType | None, Query(description='Filter by cause type')] = None, is_synthetic: Annotated[bool | None, Query(description='Filter by synthetic data flag')] = None, created_after: Annotated[datetime | None, Query(description='Filter incidents created after')] = None, created_before: Annotated[datetime | None, Query(description='Filter incidents created before')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max incidents to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of incidents to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.CREATED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session: AsyncSession = Depends(get_async_session_dep)) -> IncidentListResponse",
            "docstring": "List incidents with unified query filters. Tenant-scoped.",
            "is_async": true,
            "line": 511
          },
          {
            "name": "get_incidents_for_run",
            "signature": "(request: Request, run_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> IncidentsByRunResponse",
            "docstring": "Get all incidents linked to a specific run. Tenant-scoped.",
            "is_async": true,
            "line": 682
          },
          {
            "name": "detect_patterns",
            "signature": "(request: Request, window_hours: Annotated[int, Query(ge=1, le=168, description='Hours to look back (max 168 = 7 days)')] = 24, limit: Annotated[int, Query(ge=1, le=50, description='Max patterns per type')] = 10, session: AsyncSession = Depends(get_async_session_dep)) -> PatternDetectionResponse",
            "docstring": "Detect incident patterns. Tenant-scoped.",
            "is_async": true,
            "line": 745
          },
          {
            "name": "analyze_recurrence",
            "signature": "(request: Request, baseline_days: Annotated[int, Query(ge=1, le=90, description='Days to analyze (max 90)')] = 30, recurrence_threshold: Annotated[int, Query(ge=2, le=100, description='Min occurrences to flag as recurring')] = 3, limit: Annotated[int, Query(ge=1, le=50, description='Max groups to return')] = 20, session: AsyncSession = Depends(get_async_session_dep)) -> RecurrenceAnalysisResponse",
            "docstring": "Analyze recurring incident patterns. Tenant-scoped.",
            "is_async": true,
            "line": 797
          },
          {
            "name": "analyze_cost_impact",
            "signature": "(request: Request, baseline_days: Annotated[int, Query(ge=1, le=90, description='Days to analyze (max 90)')] = 30, limit: Annotated[int, Query(ge=1, le=50, description='Max categories to return')] = 20, session: AsyncSession = Depends(get_async_session_dep)) -> CostImpactResponse",
            "docstring": "Analyze cost impact across incidents. Tenant-scoped.",
            "is_async": true,
            "line": 853
          },
          {
            "name": "list_active_incidents",
            "signature": "(request: Request, severity: Annotated[Severity | None, Query(description='Filter by severity')] = None, category: Annotated[str | None, Query(description='Filter by category')] = None, cause_type: Annotated[CauseType | None, Query(description='Filter by cause type')] = None, is_synthetic: Annotated[bool | None, Query(description='Filter by synthetic data flag')] = None, created_after: Annotated[datetime | None, Query(description='Filter incidents created after')] = None, created_before: Annotated[datetime | None, Query(description='Filter incidents created before')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max incidents to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of incidents to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.CREATED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session: AsyncSession = Depends(get_async_session_dep)) -> IncidentListResponse",
            "docstring": "List ACTIVE incidents. Topic enforced at endpoint boundary.",
            "is_async": true,
            "line": 936
          },
          {
            "name": "list_resolved_incidents",
            "signature": "(request: Request, severity: Annotated[Severity | None, Query(description='Filter by severity')] = None, category: Annotated[str | None, Query(description='Filter by category')] = None, cause_type: Annotated[CauseType | None, Query(description='Filter by cause type')] = None, is_synthetic: Annotated[bool | None, Query(description='Filter by synthetic data flag')] = None, resolved_after: Annotated[datetime | None, Query(description='Filter incidents resolved after')] = None, resolved_before: Annotated[datetime | None, Query(description='Filter incidents resolved before')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max incidents to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of incidents to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.RESOLVED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session: AsyncSession = Depends(get_async_session_dep)) -> IncidentListResponse",
            "docstring": "List RESOLVED incidents. Topic enforced at endpoint boundary.",
            "is_async": true,
            "line": 1032
          },
          {
            "name": "list_historical_incidents",
            "signature": "(request: Request, retention_days: Annotated[int, Query(ge=7, le=365, description='Retention window in days')] = 30, severity: Annotated[Severity | None, Query(description='Filter by severity')] = None, category: Annotated[str | None, Query(description='Filter by category')] = None, cause_type: Annotated[CauseType | None, Query(description='Filter by cause type')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max incidents to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of incidents to skip')] = 0, sort_by: Annotated[SortField, Query(description='Field to sort by')] = SortField.RESOLVED_AT, sort_order: Annotated[SortOrder, Query(description='Sort direction')] = SortOrder.DESC, session: AsyncSession = Depends(get_async_session_dep)) -> IncidentListResponse",
            "docstring": "List HISTORICAL incidents (resolved beyond retention). Topic enforced.",
            "is_async": true,
            "line": 1128
          },
          {
            "name": "get_incident_metrics",
            "signature": "(request: Request, window_days: Annotated[int, Query(ge=1, le=90, description='Window in days')] = 30, session: AsyncSession = Depends(get_async_session_dep)) -> IncidentMetricsResponse",
            "docstring": "Get incident metrics. Backend-computed, deterministic.",
            "is_async": true,
            "line": 1220
          },
          {
            "name": "get_historical_trend",
            "signature": "(request: Request, window_days: Annotated[int, Query(ge=7, le=365, description='Window in days')] = 90, granularity: Annotated[str, Query(description='Aggregation granularity')] = 'week', session: AsyncSession = Depends(get_async_session_dep)) -> HistoricalTrendResponse",
            "docstring": "Get historical trend. Backend-computed, deterministic.",
            "is_async": true,
            "line": 1341
          },
          {
            "name": "get_historical_distribution",
            "signature": "(request: Request, window_days: Annotated[int, Query(ge=7, le=365, description='Window in days')] = 90, session: AsyncSession = Depends(get_async_session_dep)) -> HistoricalDistributionResponse",
            "docstring": "Get historical distribution. Backend-computed, deterministic.",
            "is_async": true,
            "line": 1432
          },
          {
            "name": "get_historical_cost_trend",
            "signature": "(request: Request, window_days: Annotated[int, Query(ge=7, le=365, description='Window in days')] = 90, granularity: Annotated[str, Query(description='Aggregation granularity')] = 'week', session: AsyncSession = Depends(get_async_session_dep)) -> CostTrendResponse",
            "docstring": "Get historical cost trend. Backend-computed, deterministic.",
            "is_async": true,
            "line": 1559
          },
          {
            "name": "get_incident_detail",
            "signature": "(request: Request, incident_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> IncidentDetailResponse",
            "docstring": "Get incident detail (O3). Tenant isolation enforced.",
            "is_async": true,
            "line": 1638
          },
          {
            "name": "get_incident_evidence",
            "signature": "(request: Request, incident_id: str) -> dict[str, Any]",
            "docstring": "Get incident evidence (O4). Preflight console only.",
            "is_async": true,
            "line": 1687
          },
          {
            "name": "get_incident_proof",
            "signature": "(request: Request, incident_id: str) -> dict[str, Any]",
            "docstring": "Get incident proof (O5). Preflight console only.",
            "is_async": true,
            "line": 1714
          },
          {
            "name": "get_incident_learnings",
            "signature": "(request: Request, incident_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> LearningsResponse",
            "docstring": "Get post-mortem learnings for an incident. Tenant-scoped.",
            "is_async": true,
            "line": 1749
          },
          {
            "name": "export_evidence",
            "signature": "(request: Request, incident_id: str, export_request: ExportRequest) -> Any",
            "docstring": "Export incident evidence bundle.",
            "is_async": true,
            "line": 1842
          },
          {
            "name": "export_soc2",
            "signature": "(request: Request, incident_id: str, export_request: ExportRequest) -> Any",
            "docstring": "Export SOC2-compliant bundle as PDF.",
            "is_async": true,
            "line": 1908
          },
          {
            "name": "export_executive_debrief",
            "signature": "(request: Request, incident_id: str, export_request: ExportRequest) -> Any",
            "docstring": "Export executive debrief as PDF.",
            "is_async": true,
            "line": 1974
          }
        ],
        "classes": [
          {
            "name": "LifecycleState",
            "docstring": "Incident lifecycle state.",
            "methods": [],
            "line": 84
          },
          {
            "name": "Severity",
            "docstring": "Incident severity.",
            "methods": [],
            "line": 92
          },
          {
            "name": "CauseType",
            "docstring": "Incident cause type.",
            "methods": [],
            "line": 101
          },
          {
            "name": "Topic",
            "docstring": "UX topic for filtering.",
            "methods": [],
            "line": 109
          },
          {
            "name": "SortField",
            "docstring": "Allowed sort fields.",
            "methods": [],
            "line": 116
          },
          {
            "name": "SortOrder",
            "docstring": "Sort direction.",
            "methods": [],
            "line": 124
          },
          {
            "name": "IncidentSummary",
            "docstring": "Incident summary for list view (O2).",
            "methods": [],
            "line": 136
          },
          {
            "name": "Pagination",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 164
          },
          {
            "name": "IncidentListResponse",
            "docstring": "GET /incidents response.",
            "methods": [],
            "line": 172
          },
          {
            "name": "IncidentDetailResponse",
            "docstring": "GET /incidents/{incident_id} response (O3).",
            "methods": [],
            "line": 182
          },
          {
            "name": "IncidentsByRunResponse",
            "docstring": "GET /incidents/by-run/{run_id} response.",
            "methods": [],
            "line": 218
          },
          {
            "name": "PatternMatchResponse",
            "docstring": "A detected incident pattern.",
            "methods": [],
            "line": 231
          },
          {
            "name": "PatternDetectionResponse",
            "docstring": "GET /incidents/patterns response (ACT-O5).",
            "methods": [],
            "line": 241
          },
          {
            "name": "RecurrenceGroupResponse",
            "docstring": "A group of recurring incidents.",
            "methods": [],
            "line": 256
          },
          {
            "name": "RecurrenceAnalysisResponse",
            "docstring": "GET /incidents/recurring response (HIST-O3).",
            "methods": [],
            "line": 269
          },
          {
            "name": "CostImpactSummary",
            "docstring": "Cost impact summary for an incident category.",
            "methods": [],
            "line": 283
          },
          {
            "name": "CostImpactResponse",
            "docstring": "GET /incidents/cost-impact response (RES-O3).",
            "methods": [],
            "line": 293
          },
          {
            "name": "IncidentMetricsResponse",
            "docstring": "GET /incidents/metrics response - Dedicated metrics capability.",
            "methods": [],
            "line": 307
          },
          {
            "name": "HistoricalTrendDataPoint",
            "docstring": "A single data point in a historical trend.",
            "methods": [],
            "line": 340
          },
          {
            "name": "HistoricalTrendResponse",
            "docstring": "GET /incidents/historical/trend response.",
            "methods": [],
            "line": 349
          },
          {
            "name": "HistoricalDistributionEntry",
            "docstring": "A single entry in the distribution.",
            "methods": [],
            "line": 359
          },
          {
            "name": "HistoricalDistributionResponse",
            "docstring": "GET /incidents/historical/distribution response.",
            "methods": [],
            "line": 368
          },
          {
            "name": "CostTrendDataPoint",
            "docstring": "A single data point in the cost trend.",
            "methods": [],
            "line": 379
          },
          {
            "name": "CostTrendResponse",
            "docstring": "GET /incidents/historical/cost-trend response.",
            "methods": [],
            "line": 388
          },
          {
            "name": "LearningInsightResponse",
            "docstring": "A learning insight from incident analysis.",
            "methods": [],
            "line": 404
          },
          {
            "name": "ResolutionSummaryResponse",
            "docstring": "Summary of incident resolution.",
            "methods": [],
            "line": 413
          },
          {
            "name": "LearningsResponse",
            "docstring": "GET /incidents/{id}/learnings response (RES-O4).",
            "methods": [],
            "line": 426
          },
          {
            "name": "ExportFormat",
            "docstring": "Export format options.",
            "methods": [],
            "line": 1814
          },
          {
            "name": "ExportRequest",
            "docstring": "Request for export with optional parameters.",
            "methods": [],
            "line": 1821
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session_dep"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.incidents.L5_engines.incidents_facade",
            "names": [
              "get_incidents_facade"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [
          {
            "name": "_CURRENT_ENVIRONMENT",
            "line": 64
          }
        ],
        "all_exports": null
      }
    ],
    "l3_adapters": [
      {
        "file_name": "anomaly_bridge.py",
        "file_path": "backend/app/hoc/cus/incidents/L3_adapters/anomaly_bridge.py",
        "layer": "L3_adapters",
        "domain": "incidents",
        "lines": 351,
        "module_docstring": "Anomaly-to-Incident Bridge\n\nAccepts pure CostAnomalyFact from analytics and decides if an incident\nshould be created. This is NOT a general service - it applies incident\ncreation rules specific to cost anomalies.\n\nResponsibilities:\n- Accept CostAnomalyFact (pure data, no DB, no imports from analytics)\n- Apply severity/confidence thresholds\n- Apply deduplication window\n- Apply suppression rules\n- Map anomaly data to incident schema\n- Delegate persistence to IncidentWriteDriver\n\nThis bridge ensures analytics never writes to incidents directly.",
        "functions": [
          {
            "name": "get_anomaly_incident_bridge",
            "signature": "(session) -> AnomalyIncidentBridge",
            "docstring": "Factory function to get AnomalyIncidentBridge instance.",
            "is_async": false,
            "line": 341
          }
        ],
        "classes": [
          {
            "name": "CostAnomalyFact",
            "docstring": "Pure fact emitted by analytics when a cost anomaly is detected.\n\nThis dataclass contains NO database references, NO session objects,\nand NO imports from analytics. It is a pure data transfer object.\n\nAnalytics engines emit this; the bridge decides what to do with it.",
            "methods": [],
            "line": 64
          },
          {
            "name": "AnomalyIncidentBridge",
            "docstring": "Bridge that accepts cost anomaly facts and creates incidents.\n\nOWNED BY INCIDENTS DOMAIN, not by analytics.\n\nThis bridge applies incident creation rules:\n- Only HIGH severity anomalies create incidents\n- Deduplication prevents duplicate incidents\n- Suppression rules may block incident creation\n\nUsage:\n    bridge = AnomalyIncidentBridge(session)\n    incident_id = bridge.ingest(fact)  # Returns None if not created",
            "methods": [
              "__init__",
              "ingest",
              "_meets_severity_threshold",
              "_is_suppressed",
              "_check_existing_incident",
              "_create_incident",
              "_build_incident_insert_sql"
            ],
            "line": 120
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.errors.governance",
            "names": [
              "GovernanceError"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_write_driver",
            "names": [
              "IncidentWriteDriver",
              "get_incident_write_driver"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.metrics",
            "names": [
              "governance_incidents_created_total"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [
          {
            "name": "INCIDENT_SEVERITY_THRESHOLD",
            "line": 93
          },
          {
            "name": "ANOMALY_SEVERITY_MAP",
            "line": 96
          },
          {
            "name": "ANOMALY_TRIGGER_TYPE_MAP",
            "line": 104
          }
        ],
        "all_exports": [
          "CostAnomalyFact",
          "AnomalyIncidentBridge",
          "get_anomaly_incident_bridge",
          "INCIDENT_SEVERITY_THRESHOLD"
        ]
      }
    ],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "hallucination_detector.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/hallucination_detector.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 467,
        "module_docstring": "Module: hallucination_detector\nPurpose: Detect potential hallucinations in LLM outputs.\n\nCRITICAL INVARIANT (INV-002 / HALLU-INV-001):\n    Hallucination detection is ALWAYS non-blocking by default.\n    This is because:\n    - Hallucination detection is PROBABILISTIC (60-90% confidence)\n    - Policy violations (cost, rate, PII) are DETERMINISTIC (facts)\n    - False positives on hallucination blocking destroy customer trust\n    - Blocking requires explicit customer opt-in\n\nImports (Dependencies):\n    - dataclasses: Detection result structures\n    - hashlib: Content hashing for evidence\n\nExports (Provides):\n    - HallucinationDetector: Main detection service\n    - HallucinationResult: Detection result dataclass\n    - HallucinationIndicator: Individual indicator dataclass\n    - HallucinationType: Type of hallucination detected\n\nWiring Points:\n    - Called from: worker/runner.py after step completion\n    - Calls: incident_engine.create_incident() with blocking=False",
        "functions": [
          {
            "name": "create_detector_for_tenant",
            "signature": "(tenant_config: Optional[dict[str, Any]] = None) -> HallucinationDetector",
            "docstring": "Create a detector configured for a specific tenant.\n\nArgs:\n    tenant_config: Optional tenant-specific configuration\n\nReturns:\n    Configured HallucinationDetector\n\nCRITICAL (INV-002): blocking_enabled requires explicit tenant opt-in.",
            "is_async": false,
            "line": 445
          }
        ],
        "classes": [
          {
            "name": "HallucinationType",
            "docstring": "Types of hallucination indicators.",
            "methods": [],
            "line": 56
          },
          {
            "name": "HallucinationSeverity",
            "docstring": "Severity levels for hallucination detections.",
            "methods": [],
            "line": 78
          },
          {
            "name": "HallucinationIndicator",
            "docstring": "Individual hallucination indicator.\n\nRepresents a single piece of evidence suggesting hallucination.\nMultiple indicators combine to form overall confidence.",
            "methods": [
              "to_dict"
            ],
            "line": 88
          },
          {
            "name": "HallucinationResult",
            "docstring": "Result of hallucination detection.\n\nContains overall assessment and individual indicators.",
            "methods": [
              "to_incident_data",
              "_derive_severity"
            ],
            "line": 116
          },
          {
            "name": "HallucinationConfig",
            "docstring": "Configuration for hallucination detection.\n\nINV-002 COMPLIANCE:\n    - blocking_enabled defaults to False\n    - blocking_enabled=True requires explicit customer opt-in",
            "methods": [],
            "line": 167
          },
          {
            "name": "HallucinationDetector",
            "docstring": "Hallucination detection service.\n\nCRITICAL INVARIANT (INV-002 / HALLU-INV-001):\n    This service MUST be non-blocking by default.\n    Hallucination detection is PROBABILISTIC, not DETERMINISTIC.\n    False positives on blocking destroy customer trust.\n\nDetection feeds OBSERVABILITY path, not SPINE.\nCustomer must explicitly opt-in for blocking behavior.",
            "methods": [
              "__init__",
              "detect",
              "_detect_suspicious_urls",
              "_detect_suspicious_citations",
              "_detect_contradictions",
              "_detect_temporal_issues",
              "_hash_content"
            ],
            "line": 195
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incident_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_driver.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 279,
        "module_docstring": "Incident Domain Driver (INTERNAL)\n\nThis driver provides the internal interface for incident operations.\nUsed by workers, governance services, and transaction coordinators.\n\nFor CUSTOMER API operations, use incidents_facade.py instead.\n\nWhy Drivers (not Facades for internal use):\n- Facades are API projection layers (CUSTOMER-facing)\n- Drivers are orchestration layers (INTERNAL)\n- Clear separation prevents confusion\n- Import rules become enforceable\n\nUsage:\n    from app.hoc.cus.incidents.L5_engines.incident_driver import get_incident_driver\n\n    driver = get_incident_driver()\n    incident_id = driver.create_incident_for_run(...)",
        "functions": [
          {
            "name": "get_incident_driver",
            "signature": "(db_url: Optional[str] = None) -> IncidentDriver",
            "docstring": "Get the incident driver instance.\n\nThis is the recommended way to access incident operations from\ninternal code (workers, governance services).\n\nFor CUSTOMER API operations, use get_incidents_facade() instead.\n\nArgs:\n    db_url: Optional database URL override\n\nReturns:\n    IncidentDriver instance",
            "is_async": false,
            "line": 255
          }
        ],
        "classes": [
          {
            "name": "IncidentDriver",
            "docstring": "Driver for Incident domain operations (INTERNAL).\n\nThis is the entry point for internal code (workers, governance)\nto interact with incident services.\n\nCUSTOMER-facing code should use incidents_facade.py instead.",
            "methods": [
              "__init__",
              "_engine",
              "check_and_create_incident",
              "create_incident_for_run",
              "_emit_ack",
              "get_incidents_for_run"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [
          {
            "name": "RAC_ENABLED",
            "line": 55
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "incident_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 905,
        "module_docstring": "Incident Engine (L4 Domain Logic)\n\nThis engine implements the SDSR cross-domain propagation contract:\n- Run failure (Activity domain) \u2192 Incident creation (Incidents domain)\n\nPer PIN-370 Rule 6 (Scenarios Inject Causes, Not Consequences):\n- Scenarios inject a failed run\n- This engine AUTOMATICALLY creates incidents\n- If incident doesn't appear, the ENGINE is broken, not the scenario\n\nDECISIONS (L4 - stay here):\n- Severity mapping from error codes\n- Category mapping from error codes\n- Policy suppression decision\n- Title generation\n- Policy proposal creation decision\n\nPERSISTENCE (L6 - delegated to driver):\n- INSERT into incidents\n- INSERT into prevention_records\n- INSERT into policy_proposals\n- UPDATE runs, aos_traces\n\nReference: PIN-370, PIN-468, INCIDENTS-EXEC-FAILURE-001",
        "functions": [
          {
            "name": "_get_lessons_learned_engine",
            "signature": "()",
            "docstring": "Get the LessonsLearnedEngine singleton (lazy import).",
            "is_async": false,
            "line": 88
          },
          {
            "name": "get_incident_engine",
            "signature": "() -> IncidentEngine",
            "docstring": "Get or create singleton incident engine instance.",
            "is_async": false,
            "line": 900
          }
        ],
        "classes": [
          {
            "name": "IncidentEngine",
            "docstring": "L4 Domain Engine for incident creation.\n\nThis engine implements the SDSR cross-domain propagation:\nActivity (cause) \u2192 Incidents (reactive)\n\nSDSR Contract (PIN-370):\n- This engine is called when a run fails\n- It creates an incident record automatically\n- Incidents are NEVER created by scenarios directly\n- If incidents don't appear for failed runs, THIS ENGINE is broken\n\nCallers:\n- Worker runtime (on run failure)\n- inject_synthetic.py expectations validator\n\nPIN-468 Phase-2.5A:\n- All DB operations delegated to IncidentWriteDriver\n- Engine contains ONLY decision logic\n- No sqlalchemy/sqlmodel imports at runtime",
            "methods": [
              "__init__",
              "_get_driver",
              "_check_policy_suppression",
              "_write_prevention_record",
              "create_incident_for_run",
              "create_incident_for_failed_run",
              "_maybe_create_policy_proposal",
              "_generate_title",
              "check_and_create_incident",
              "create_incident_for_all_runs",
              "_extract_error_code",
              "get_incidents_for_run"
            ],
            "line": 163
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_write_driver",
            "names": [
              "IncidentWriteDriver",
              "get_incident_write_driver"
            ],
            "is_relative": false,
            "line": 76
          }
        ],
        "constants": [
          {
            "name": "INCIDENT_OUTCOME_SUCCESS",
            "line": 120
          },
          {
            "name": "INCIDENT_OUTCOME_FAILURE",
            "line": 121
          },
          {
            "name": "INCIDENT_OUTCOME_BLOCKED",
            "line": 122
          },
          {
            "name": "INCIDENT_OUTCOME_ABORTED",
            "line": 123
          },
          {
            "name": "SEVERITY_NONE",
            "line": 126
          },
          {
            "name": "FAILURE_SEVERITY_MAP",
            "line": 129
          },
          {
            "name": "FAILURE_CATEGORY_MAP",
            "line": 148
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "incident_pattern_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_pattern_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 279,
        "module_docstring": "Incident Pattern Engine - L4 Domain Logic\n\nDetects structural patterns across incidents:\n- category_cluster: Multiple incidents in same category\n- severity_spike: Multiple high/critical in short window\n- cascade_failure: Multiple incidents from same source run\n- resolution_pattern: Common resolution methods\n\nArchitecture:\n- All DB operations delegated to IncidentPatternDriver (L6)\n- Engine contains only pattern detection logic\n- Read-only (no writes)\n\nDesign Rules:\n- Rule-based only (v1, no ML)\n- No cross-service calls",
        "functions": [],
        "classes": [
          {
            "name": "PatternMatch",
            "docstring": "A detected incident pattern.",
            "methods": [],
            "line": 72
          },
          {
            "name": "PatternResult",
            "docstring": "Result of pattern detection.",
            "methods": [],
            "line": 82
          },
          {
            "name": "IncidentPatternService",
            "docstring": "Detect structural patterns across incidents.\n\nRESPONSIBILITIES:\n- Detect category clusters\n- Detect severity spikes\n- Detect cascade failures\n- Return pattern type + confidence\n\nFORBIDDEN:\n- Write to any table\n- Call other services\n- Use machine learning\n\nNote: All DB operations are delegated to IncidentPatternDriver (L6).\nThis engine contains only pattern detection logic.",
            "methods": [
              "__init__",
              "detect_patterns",
              "_detect_category_clusters",
              "_detect_severity_spikes",
              "_detect_cascade_failures"
            ],
            "line": 90
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_pattern_driver",
            "names": [
              "IncidentPatternDriver",
              "get_incident_pattern_driver"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 65
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incident_read_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_read_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 153,
        "module_docstring": "Incident Read Service (L4)\n\nThis service provides all READ operations for the Incidents domain.\nIt delegates to IncidentReadDriver (L6) for all database access.\n\nL3 (Adapter) \u2192 L4 (this service) \u2192 L6 (IncidentReadDriver)\n\nResponsibilities:\n- Delegate to L6 driver for data access\n- Apply business rules (if any)\n- Maintain backward compatibility for callers\n\nReference: PIN-281, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_read_service",
            "signature": "(session: 'Session') -> IncidentReadService",
            "docstring": "Factory function to get IncidentReadService instance.",
            "is_async": false,
            "line": 145
          }
        ],
        "classes": [
          {
            "name": "IncidentReadService",
            "docstring": "L4 service for incident read operations.\n\nDelegates all database operations to IncidentReadDriver (L6).\nMaintains backward compatibility for existing callers.\n\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "list_incidents",
              "get_incident",
              "get_incident_events",
              "count_incidents_since",
              "get_last_incident"
            ],
            "line": 59
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_read_driver",
            "names": [
              "IncidentReadDriver",
              "get_incident_read_driver"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentReadService",
          "get_incident_read_service"
        ]
      },
      {
        "file_name": "incident_severity_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_severity_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 218,
        "module_docstring": "Incident Severity Engine (L4)\n\nBusiness logic for incident severity decisions:\n- Initial severity mapping from trigger type\n- Severity calculation from affected calls\n- Escalation decisions\n\nDesign Rules:\n- Pure business logic, no DB access\n- Stateless calculations\n- No I/O operations\n- Returns computed values for drivers to persist\n\nThis engine was extracted from incident_aggregator.py per HOC Layer Topology V1.",
        "functions": [
          {
            "name": "generate_incident_title",
            "signature": "(trigger_type: str, trigger_value: str) -> str",
            "docstring": "Generate human-readable incident title.\n\nThis is presentation logic but lives here because it's domain-specific.\n\nArgs:\n    trigger_type: Type of incident trigger\n    trigger_value: Value/details of the trigger\n\nReturns:\n    Human-readable title string",
            "is_async": false,
            "line": 188
          }
        ],
        "classes": [
          {
            "name": "SeverityConfig",
            "docstring": "Configuration for severity decisions.",
            "methods": [
              "default"
            ],
            "line": 48
          },
          {
            "name": "IncidentSeverityEngine",
            "docstring": "L4 Engine for incident severity decisions.\n\nRESPONSIBILITIES:\n- Calculate initial severity from trigger type\n- Calculate severity from affected calls count\n- Determine if severity should escalate\n\nFORBIDDEN:\n- Database access\n- I/O operations\n- State mutation (stateless calculations only)",
            "methods": [
              "__init__",
              "get_initial_severity",
              "calculate_severity_for_calls",
              "should_escalate"
            ],
            "line": 91
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "Tuple"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "IncidentSeverity"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_SEVERITY",
            "line": 83
          }
        ],
        "all_exports": [
          "IncidentSeverityEngine",
          "SeverityConfig",
          "TRIGGER_SEVERITY_MAP",
          "DEFAULT_SEVERITY",
          "generate_incident_title"
        ]
      },
      {
        "file_name": "incident_write_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incident_write_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 303,
        "module_docstring": "Incident Write Service (L4)\n\nThis service provides all WRITE operations for the Incidents domain.\nIt delegates DB access to IncidentWriteDriver (L6) and applies business logic.\n\nL3 (Adapter) \u2192 L4 (this service) \u2192 L6 (IncidentWriteDriver)\n\nResponsibilities:\n- Acknowledge incidents (audit emit + delegate DB to driver)\n- Resolve incidents (audit emit + delegate DB to driver)\n- Transaction orchestration (begin/commit/rollback)\n- Audit event emission (L4 responsibility)\n- NO direct DB access - driver calls only\n\nReference: PIN-281, PIN-413, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_write_service",
            "signature": "(session: 'Session') -> IncidentWriteService",
            "docstring": "Factory function to get IncidentWriteService instance.",
            "is_async": false,
            "line": 295
          }
        ],
        "classes": [
          {
            "name": "IncidentWriteService",
            "docstring": "L4 service for incident write operations.\n\nDelegates DB operations to IncidentWriteDriver (L6).\nMaintains business logic (audit events, transactions) in L4.\n\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "acknowledge_incident",
              "resolve_incident",
              "manual_close_incident"
            ],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incident_write_driver",
            "names": [
              "IncidentWriteDriver",
              "get_incident_write_driver"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "ActorType"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.hoc.cus.logs.L5_engines.audit_ledger_service",
            "names": [
              "AuditLedgerService"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentWriteService",
          "get_incident_write_service"
        ]
      },
      {
        "file_name": "incidents_facade.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incidents_facade.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 983,
        "module_docstring": "Incidents Domain Facade (L5)\n\nUnified facade for incident management operations.\n\nProvides:\n- List incidents: active, resolved, historical\n- Get incident detail\n- Get incidents by run\n- Pattern detection (ACT-O5)\n- Recurrence analysis (HIST-O3)\n- Cost impact analysis (RES-O3)\n- Metrics\n- Historical trend/distribution/cost-trend\n- Post-mortem learnings (RES-O4)\n\nAll operations are tenant-scoped for isolation.\n\nArchitecture:\n- Facade \u2192 Driver (L6) for DB operations\n- Facade \u2192 Engine (L4) for business logic delegation\n- No direct sqlalchemy imports",
        "functions": [
          {
            "name": "get_incidents_facade",
            "signature": "() -> IncidentsFacade",
            "docstring": "Get the singleton IncidentsFacade instance.",
            "is_async": false,
            "line": 942
          }
        ],
        "classes": [
          {
            "name": "IncidentSummaryResult",
            "docstring": "Incident summary for list view (O2).",
            "methods": [],
            "line": 68
          },
          {
            "name": "PaginationResult",
            "docstring": "Pagination metadata.",
            "methods": [],
            "line": 90
          },
          {
            "name": "IncidentListResult",
            "docstring": "Incidents list response.",
            "methods": [],
            "line": 99
          },
          {
            "name": "IncidentDetailResult",
            "docstring": "Incident detail response (O3).",
            "methods": [],
            "line": 115
          },
          {
            "name": "IncidentsByRunResult",
            "docstring": "Incidents by run response.",
            "methods": [],
            "line": 144
          },
          {
            "name": "PatternMatchResult",
            "docstring": "A detected incident pattern.",
            "methods": [],
            "line": 158
          },
          {
            "name": "PatternDetectionResult",
            "docstring": "Pattern detection response.",
            "methods": [],
            "line": 169
          },
          {
            "name": "RecurrenceGroupResult",
            "docstring": "A group of recurring incidents.",
            "methods": [],
            "line": 185
          },
          {
            "name": "RecurrenceAnalysisResult",
            "docstring": "Recurrence analysis response.",
            "methods": [],
            "line": 199
          },
          {
            "name": "CostImpactSummaryResult",
            "docstring": "Cost impact summary for an incident category.",
            "methods": [],
            "line": 214
          },
          {
            "name": "CostImpactResult",
            "docstring": "Cost impact analysis response.",
            "methods": [],
            "line": 225
          },
          {
            "name": "IncidentMetricsResult",
            "docstring": "Incident metrics response.",
            "methods": [],
            "line": 240
          },
          {
            "name": "HistoricalTrendDataPointResult",
            "docstring": "A single data point in a historical trend.",
            "methods": [],
            "line": 268
          },
          {
            "name": "HistoricalTrendResult",
            "docstring": "Historical trend response.",
            "methods": [],
            "line": 278
          },
          {
            "name": "HistoricalDistributionEntryResult",
            "docstring": "A single entry in the distribution.",
            "methods": [],
            "line": 289
          },
          {
            "name": "HistoricalDistributionResult",
            "docstring": "Historical distribution response.",
            "methods": [],
            "line": 299
          },
          {
            "name": "CostTrendDataPointResult",
            "docstring": "A single data point in the cost trend.",
            "methods": [],
            "line": 311
          },
          {
            "name": "CostTrendResult",
            "docstring": "Cost trend response.",
            "methods": [],
            "line": 321
          },
          {
            "name": "LearningInsightResult",
            "docstring": "A learning insight from incident analysis.",
            "methods": [],
            "line": 338
          },
          {
            "name": "ResolutionSummaryResult",
            "docstring": "Summary of incident resolution.",
            "methods": [],
            "line": 348
          },
          {
            "name": "LearningsResult",
            "docstring": "Incident learnings response.",
            "methods": [],
            "line": 362
          },
          {
            "name": "IncidentsFacade",
            "docstring": "Unified facade for incident management.\n\nProvides:\n- List incidents: active, resolved, historical\n- Get incident detail\n- Get incidents by run\n- Metrics\n- Cost impact analysis\n\nAll operations are tenant-scoped for isolation.\n\nArchitecture:\n- Delegates DB operations to IncidentsFacadeDriver (L6)\n- No direct sqlalchemy access",
            "methods": [
              "list_active_incidents",
              "list_resolved_incidents",
              "list_historical_incidents",
              "get_incident_detail",
              "get_incidents_for_run",
              "get_metrics",
              "analyze_cost_impact",
              "_snapshot_to_summary",
              "detect_patterns",
              "analyze_recurrence",
              "get_incident_learnings"
            ],
            "line": 377
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.incidents_facade_driver",
            "names": [
              "IncidentsFacadeDriver",
              "IncidentSnapshot"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentsFacade",
          "get_incidents_facade",
          "IncidentSummaryResult",
          "PaginationResult",
          "IncidentListResult",
          "IncidentDetailResult",
          "IncidentsByRunResult",
          "PatternMatchResult",
          "PatternDetectionResult",
          "RecurrenceGroupResult",
          "RecurrenceAnalysisResult",
          "CostImpactSummaryResult",
          "CostImpactResult",
          "IncidentMetricsResult",
          "HistoricalTrendDataPointResult",
          "HistoricalTrendResult",
          "HistoricalDistributionEntryResult",
          "HistoricalDistributionResult",
          "CostTrendDataPointResult",
          "CostTrendResult",
          "LearningInsightResult",
          "ResolutionSummaryResult",
          "LearningsResult"
        ]
      },
      {
        "file_name": "incidents_types.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/incidents_types.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 44,
        "module_docstring": "Incidents Domain Shared Types\n\nCanonical type aliases used across multiple engines in the incidents domain.\nThis file consolidates duplicated type definitions (INC-DUP-008).\n\nUsage:\n    from app.hoc.cus.incidents.L5_engines.incidents_types import (\n        UuidFn,\n        ClockFn,\n    )",
        "functions": [],
        "classes": [],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Callable"
            ],
            "is_relative": false,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": [
          "UuidFn",
          "ClockFn"
        ]
      },
      {
        "file_name": "llm_failure_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/llm_failure_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 348,
        "module_docstring": "LLMFailureService - S4 Failure Truth Implementation\n\nImplements PIN-196 requirements:\n- Failure fact persistence (before any other action)\n- Run state transition to FAILED\n- Evidence capture (mandatory)\n- No downstream contamination\n\nARCHITECTURE RULE: Explicit dependency injection, NO lazy service resolution.\nSee LESSONS_ENFORCED.md Invariant #10.\n\nCritical Invariant:\n> A failed run must never appear as \"successful\" or \"completed with results.\"",
        "functions": [],
        "classes": [
          {
            "name": "LLMFailureFact",
            "docstring": "Authoritative LLM failure fact.\n\nMust be persisted BEFORE any other action (PIN-196 Invariant 2).\nEvidence is mandatory (PIN-196 Invariant 4).",
            "methods": [
              "__post_init__"
            ],
            "line": 91
          },
          {
            "name": "LLMFailureResult",
            "docstring": "Result of failure persistence operation.",
            "methods": [],
            "line": 127
          },
          {
            "name": "LLMFailureService",
            "docstring": "Service for handling LLM failures with S4 truth guarantees.\n\nPIN-196 Invariants Enforced:\n- Invariant 2: Failure first, always (persisted before classification)\n- Invariant 3: No silent healing (no retry/fallback/suppression)\n- Invariant 4: Evidence is mandatory (failure without evidence is invalid)\n- Invariant 5: Isolation holds under failure (tenant boundaries enforced)\n\nNote: All DB operations are delegated to LLMFailureDriver (L6).\nThis engine contains only business logic decisions.",
            "methods": [
              "__init__",
              "persist_failure_and_mark_run",
              "_persist_failure",
              "_capture_evidence",
              "_mark_run_failed",
              "_verify_no_contamination",
              "get_failure_by_run_id"
            ],
            "line": 136
          }
        ],
        "imports": [
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Callable",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.llm_failure_driver",
            "names": [
              "LLMFailureDriver",
              "get_llm_failure_driver"
            ],
            "is_relative": false,
            "line": 60
          }
        ],
        "constants": [
          {
            "name": "VERIFICATION_MODE",
            "line": 87
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "policy_violation_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/policy_violation_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 713,
        "module_docstring": "Policy Violation Service - S3 Hardening for Phase A.5 Verification\n\nThis service implements the S3 truth model from PIN-195:\n1. Violation detection\n2. Violation fact persistence\n3. Incident creation (severity-bound)\n4. Evidence linking\n5. API + Console exposure\n\nCritical invariants (VERIFICATION_MODE):\n- No incident may exist without a persisted violation fact\n- Policy must be enabled for tenant\n- Evidence must exist before incident creation\n- One incident per (run_id, policy_id)\n- Cost and policy systems don't interfere\n\nSee PIN-195 for full acceptance criteria.",
        "functions": [
          {
            "name": "create_policy_evaluation_record",
            "signature": "(session: 'AsyncSession', run_id: str, tenant_id: str, outcome: str, policies_checked: int = 0, reason: str = '', draft_candidate: bool = False, is_synthetic: bool = False, synthetic_scenario_id: Optional[str] = None) -> str",
            "docstring": "Create a policy evaluation record for ANY run (PIN-407).\n\nEvery run MUST produce exactly one policy evaluation record.\nThis is NOT limited to violations - successful evaluations also get records.\n\nArgs:\n    session: Database session\n    run_id: Run ID\n    tenant_id: Tenant scope\n    outcome: Policy outcome (NO_VIOLATION, VIOLATION, ADVISORY, NOT_APPLICABLE)\n    policies_checked: Number of policies evaluated\n    reason: Human-readable reason\n    draft_candidate: If True, this run is a candidate for policy learning\n    is_synthetic: True if from SDSR scenario\n    synthetic_scenario_id: Scenario ID for traceability\n\nReturns:\n    policy_evaluation_id\n\nDECISION: Confidence calculation based on outcome (business rule).\nPERSISTENCE: Delegated to driver.",
            "is_async": true,
            "line": 468
          },
          {
            "name": "handle_policy_evaluation_for_run",
            "signature": "(session: 'AsyncSession', run_id: str, tenant_id: str, run_status: str, policies_checked: int = 0, is_synthetic: bool = False, synthetic_scenario_id: Optional[str] = None) -> str",
            "docstring": "Create a policy evaluation record for ANY run (PIN-407).\n\nThis is the NEW primary entry point for run \u2192 policy evaluation propagation.\nEvery run creates exactly one policy evaluation record with explicit outcome.\n\nArgs:\n    session: Database session\n    run_id: Run ID\n    tenant_id: Tenant scope\n    run_status: Run status (succeeded, failed, etc.)\n    policies_checked: Number of policies evaluated\n    is_synthetic: True if from SDSR scenario\n    synthetic_scenario_id: Scenario ID for traceability\n\nReturns:\n    policy_evaluation_id",
            "is_async": true,
            "line": 535
          },
          {
            "name": "handle_policy_violation",
            "signature": "(session: 'AsyncSession', run_id: str, tenant_id: str, policy_type: str, policy_id: str, violated_rule: str, reason: str, severity: str = 'medium', evidence: Optional[Dict[str, Any]] = None) -> Optional[ViolationIncident]",
            "docstring": "Handle a policy violation with S3 truth guarantees.\n\nThis is the main entry point for policy violation handling.\nCall this from workers.py when a policy violation is detected.\n\nReturns ViolationIncident if incident was created, None if skipped.",
            "is_async": true,
            "line": 592
          },
          {
            "name": "create_policy_evaluation_sync",
            "signature": "(run_id: str, tenant_id: str, run_status: str, policies_checked: int = 0, is_synthetic: bool = False, synthetic_scenario_id: Optional[str] = None) -> Optional[str]",
            "docstring": "Create a policy evaluation record for ANY run (PIN-407) - SYNC VERSION.\n\nThis is a synchronous wrapper for use in worker contexts where we don't\nhave an async session. Uses direct psycopg2 connection via driver.\n\nArgs:\n    run_id: Run ID\n    tenant_id: Tenant scope\n    run_status: Run status (succeeded, failed, etc.)\n    policies_checked: Number of policies evaluated\n    is_synthetic: True if from SDSR scenario\n    synthetic_scenario_id: Scenario ID for traceability\n\nReturns:\n    policy_evaluation_id if created, None if failed\n\nDECISION: Map run status to policy outcome (business rule).\nPERSISTENCE: Delegated to driver.",
            "is_async": false,
            "line": 634
          }
        ],
        "classes": [
          {
            "name": "ViolationFact",
            "docstring": "Authoritative violation fact - must be persisted before incident creation.\n\nThis is the \"fact\" that PIN-195 AC-1 requires:\n- Linked to run_id\n- Linked to tenant_id\n- Linked to policy_id\n- Contains violated_rule\n- Contains evaluated_value\n- Contains threshold/condition\n- Contains timestamp",
            "methods": [],
            "line": 85
          },
          {
            "name": "ViolationIncident",
            "docstring": "Result of creating an incident from a violation.",
            "methods": [],
            "line": 115
          },
          {
            "name": "PolicyViolationService",
            "docstring": "Service for handling policy violations with S3 truth guarantees.\n\nUsage:\n    service = PolicyViolationService(session)\n\n    # Create violation fact first\n    violation = ViolationFact(\n        run_id=\"...\",\n        tenant_id=\"...\",\n        policy_id=\"content_accuracy_v1\",\n        violated_rule=\"CA001\",\n        ...\n\nNote: All DB operations are delegated to PolicyViolationDriver (L6).\nThis engine contains only business logic decisions.\n    )\n\n    # Persist and create incident\n    result = await service.persist_violation_and_create_incident(violation)",
            "methods": [
              "__init__",
              "persist_violation_fact",
              "check_violation_persisted",
              "check_policy_enabled",
              "persist_evidence",
              "check_incident_exists",
              "create_incident_from_violation",
              "persist_violation_and_create_incident",
              "verify_violation_truth"
            ],
            "line": 124
          },
          {
            "name": "PolicyEvaluationResult",
            "docstring": "Result of policy evaluation (PIN-407: Success as First-Class Data).\n\nEvery run MUST produce exactly one policy evaluation record.\nThis is NOT limited to violations - successful evaluations also get records.",
            "methods": [],
            "line": 450
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.policy_violation_driver",
            "names": [
              "PolicyViolationDriver",
              "get_policy_violation_driver",
              "insert_policy_evaluation_sync"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.utils.runtime",
            "names": [
              "generate_uuid"
            ],
            "is_relative": false,
            "line": 76
          }
        ],
        "constants": [
          {
            "name": "VERIFICATION_MODE",
            "line": 81
          },
          {
            "name": "POLICY_OUTCOME_NO_VIOLATION",
            "line": 443
          },
          {
            "name": "POLICY_OUTCOME_VIOLATION",
            "line": 444
          },
          {
            "name": "POLICY_OUTCOME_ADVISORY",
            "line": 445
          },
          {
            "name": "POLICY_OUTCOME_NOT_APPLICABLE",
            "line": 446
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "postmortem_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/postmortem_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 444,
        "module_docstring": "Post-Mortem Engine - L4 Domain Logic\n\nExtracts learnings from resolved incidents:\n- Resolution summaries\n- Impact analysis\n- Prevention recommendations\n- Pattern correlations\n\nArchitecture:\n- All DB operations delegated to PostMortemDriver (L6)\n- Engine contains only insight generation logic\n- Read-only (no writes)\n\nDesign Rules:\n- Aggregation and analysis only\n- No cross-service calls",
        "functions": [],
        "classes": [
          {
            "name": "ResolutionSummary",
            "docstring": "Summary of how an incident was resolved.",
            "methods": [],
            "line": 71
          },
          {
            "name": "LearningInsight",
            "docstring": "A learning extracted from incident analysis.",
            "methods": [],
            "line": 84
          },
          {
            "name": "PostMortemResult",
            "docstring": "Result of post-mortem analysis for an incident.",
            "methods": [],
            "line": 93
          },
          {
            "name": "CategoryLearnings",
            "docstring": "Aggregated learnings for a category.",
            "methods": [],
            "line": 103
          },
          {
            "name": "PostMortemService",
            "docstring": "Extract learnings and post-mortem insights from incidents.\n\nRESPONSIBILITIES:\n- Generate resolution summaries\n- Find similar past incidents\n- Extract actionable insights\n- Aggregate category-level learnings\n\nFORBIDDEN:\n- Write to any table\n- Call other services\n- Modify incident data\n\nNote: All DB operations are delegated to PostMortemDriver (L6).\nThis engine contains only insight generation logic.",
            "methods": [
              "__init__",
              "get_incident_learnings",
              "get_category_learnings",
              "_get_resolution_summary",
              "_find_similar_incidents",
              "_extract_insights",
              "_generate_category_insights"
            ],
            "line": 114
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.postmortem_driver",
            "names": [
              "PostMortemDriver",
              "get_postmortem_driver"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "prevention_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/prevention_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 890,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_prevention_engine",
            "signature": "() -> PreventionEngine",
            "docstring": "Get global prevention engine instance.",
            "is_async": false,
            "line": 734
          },
          {
            "name": "evaluate_prevention",
            "signature": "(tenant_id: str, call_id: str, user_query: str, llm_output: str, context_data: Dict[str, Any], model: str = 'unknown', user_id: Optional[str] = None) -> PreventionResult",
            "docstring": "Convenience function to evaluate prevention.\n\nUsage:\n    result = evaluate_prevention(\n        tenant_id=\"tenant_123\",\n        call_id=\"call_abc\",\n        user_query=\"Is my contract auto-renewed?\",\n        llm_output=\"Yes, your contract will auto-renew...\",\n        context_data={\"auto_renew\": None},\n    )\n\n    if result.action != PreventionAction.ALLOW:\n        # Handle blocked/modified response\n        pass",
            "is_async": false,
            "line": 742
          },
          {
            "name": "create_incident_from_violation",
            "signature": "(ctx: PreventionContext, result: PreventionResult, session: Optional[Any] = None) -> Optional[str]",
            "docstring": "Create an incident from prevention violation.\n\nS3 Truth Model (PIN-195):\n1. Persist violation fact\n2. Create incident (only after violation persisted)\n3. Link evidence\n\nReturns incident_id if created, None otherwise.",
            "is_async": true,
            "line": 780
          },
          {
            "name": "_create_incident_with_service",
            "signature": "(session: Any, ctx: PreventionContext, primary: PolicyViolation, evidence: dict) -> Optional[str]",
            "docstring": "Helper to create incident using PolicyViolationService.",
            "is_async": true,
            "line": 841
          }
        ],
        "classes": [
          {
            "name": "PolicyType",
            "docstring": "Types of policies that can be evaluated.",
            "methods": [],
            "line": 40
          },
          {
            "name": "Severity",
            "docstring": "Severity levels for policy violations.",
            "methods": [],
            "line": 52
          },
          {
            "name": "PreventionAction",
            "docstring": "Action to take when prevention triggers.",
            "methods": [],
            "line": 61
          },
          {
            "name": "PolicyViolation",
            "docstring": "A single policy violation detected.",
            "methods": [
              "to_dict"
            ],
            "line": 72
          },
          {
            "name": "PreventionContext",
            "docstring": "Context for prevention evaluation.",
            "methods": [
              "hash_output"
            ],
            "line": 100
          },
          {
            "name": "PreventionResult",
            "docstring": "Result of prevention engine evaluation.",
            "methods": [
              "highest_severity",
              "primary_violation",
              "to_dict"
            ],
            "line": 122
          },
          {
            "name": "BaseValidator",
            "docstring": "Base class for policy validators.",
            "methods": [
              "validate"
            ],
            "line": 166
          },
          {
            "name": "ContentAccuracyValidatorV2",
            "docstring": "Enhanced content accuracy validator.",
            "methods": [
              "__init__",
              "validate",
              "_get_value",
              "_extract_claim"
            ],
            "line": 177
          },
          {
            "name": "PIIValidator",
            "docstring": "Detects PII in LLM output that shouldn't be exposed.",
            "methods": [
              "__init__",
              "validate",
              "_redact"
            ],
            "line": 297
          },
          {
            "name": "SafetyValidator",
            "docstring": "Detects harmful, dangerous, or inappropriate content.",
            "methods": [
              "__init__",
              "validate"
            ],
            "line": 353
          },
          {
            "name": "HallucinationValidator",
            "docstring": "Detects potential hallucinations by checking for unsupported claims.",
            "methods": [
              "__init__",
              "validate",
              "_claim_in_context"
            ],
            "line": 410
          },
          {
            "name": "BudgetValidator",
            "docstring": "Validates that response doesn't exceed budget limits.",
            "methods": [
              "__init__",
              "validate"
            ],
            "line": 466
          },
          {
            "name": "PreventionEngine",
            "docstring": "Multi-policy prevention engine with severity levels and async incident creation.\n\nUsage:\n    engine = PreventionEngine()\n\n    result = engine.evaluate(PreventionContext(\n        tenant_id=\"tenant_123\",\n        call_id=\"call_abc\",\n        user_query=\"Is my contract auto-renewed?\",\n        llm_output=\"Yes, your contract will auto-renew...\",\n        context_data={\"auto_renew\": None},\n    ))\n\n    if result.action == PreventionAction.BLOCK:\n        return error_response(\"Response blocked by policy\")\n    elif result.action == PreventionAction.MODIFY:\n        return result.safe_output",
            "methods": [
              "__init__",
              "evaluate",
              "_generate_safe_response",
              "_emit_metrics"
            ],
            "line": 519
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyType",
          "Severity",
          "PreventionAction",
          "PolicyViolation",
          "PreventionContext",
          "PreventionResult",
          "BaseValidator",
          "ContentAccuracyValidatorV2",
          "PIIValidator",
          "SafetyValidator",
          "HallucinationValidator",
          "BudgetValidator",
          "PreventionEngine",
          "get_prevention_engine",
          "evaluate_prevention",
          "create_incident_from_violation"
        ]
      },
      {
        "file_name": "recovery_rule_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/recovery_rule_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 802,
        "module_docstring": "Rule-based evaluation engine for recovery suggestions.\n\nEvaluates a set of rules against failure context and returns\nscored action recommendations.\n\nRules can be:\n1. Error code matching (exact or prefix)\n2. Historical pattern matching\n3. Skill-specific rules\n4. Tenant-specific overrides\n5. Time-based rules (e.g., different behavior during incidents)\n\nEnvironment Variables:\n- RECOVERY_RULE_DEBUG: Enable debug logging for rule evaluation",
        "functions": [
          {
            "name": "combine_confidences",
            "signature": "(rule_confidence: float, match_confidence: float) -> float",
            "docstring": "Combine rule and matcher confidence scores.\n\nThis is an L4 domain decision. L5 workers must NOT implement their own formulas.\n\nArgs:\n    rule_confidence: Confidence from rule evaluation (0.0 to 1.0)\n    match_confidence: Confidence from pattern matching (0.0 to 1.0)\n\nReturns:\n    Combined confidence score (0.0 to 1.0)\n\nReference: PIN-257 Phase E-4 Extraction #3",
            "is_async": false,
            "line": 613
          },
          {
            "name": "should_select_action",
            "signature": "(combined_confidence: float) -> bool",
            "docstring": "Determine if an action should be selected based on combined confidence.\n\nThis is an L4 domain decision. L5 workers must NOT hardcode thresholds.\n\nArgs:\n    combined_confidence: Combined confidence score (0.0 to 1.0)\n\nReturns:\n    True if confidence meets threshold for action selection\n\nReference: PIN-257 Phase E-4 Extraction #3",
            "is_async": false,
            "line": 631
          },
          {
            "name": "should_auto_execute",
            "signature": "(confidence: float) -> bool",
            "docstring": "Determine if a recovery action should be auto-executed based on confidence.\n\nThis is an L4 domain decision. L5 workers must NOT hardcode thresholds.\n\nArgs:\n    confidence: Combined confidence score (0.0 to 1.0)\n\nReturns:\n    True if confidence meets threshold for auto-execution",
            "is_async": false,
            "line": 648
          },
          {
            "name": "classify_error_category",
            "signature": "(error_codes: List[str]) -> str",
            "docstring": "Classify error codes into a category.\n\nThis is an L4 domain decision. L5 workers must NOT implement their own heuristics.\n\nArgs:\n    error_codes: List of error codes to classify\n\nReturns:\n    Category string (TRANSIENT, PERMISSION, RESOURCE, VALIDATION, INFRASTRUCTURE, PLANNER, PERMANENT)",
            "is_async": false,
            "line": 675
          },
          {
            "name": "suggest_recovery_mode",
            "signature": "(error_codes: List[str]) -> str",
            "docstring": "Suggest a recovery mode based on error codes.\n\nThis is an L4 domain decision. L5 workers must NOT implement their own heuristics.\n\nArgs:\n    error_codes: List of error codes to analyze\n\nReturns:\n    Recovery mode string (RETRY_EXPONENTIAL, RETRY_WITH_JITTER, ESCALATE, ABORT)",
            "is_async": false,
            "line": 706
          },
          {
            "name": "evaluate_rules",
            "signature": "(error_code: str, error_message: str, skill_id: Optional[str] = None, tenant_id: Optional[str] = None, occurrence_count: int = 1, historical_matches: Optional[List[Dict[str, Any]]] = None, custom_rules: Optional[List[Rule]] = None) -> EvaluationResult",
            "docstring": "Convenience function to evaluate rules against a failure.\n\nArgs:\n    error_code: The error code (e.g., \"TIMEOUT\", \"HTTP_503\")\n    error_message: The raw error message\n    skill_id: Optional skill ID\n    tenant_id: Optional tenant ID\n    occurrence_count: How many times this failure has occurred\n    historical_matches: Historical similar failures\n    custom_rules: Custom rules to add to evaluation\n\nReturns:\n    EvaluationResult with recommendation",
            "is_async": false,
            "line": 732
          }
        ],
        "classes": [
          {
            "name": "RuleContext",
            "docstring": "Context provided to rules for evaluation.",
            "methods": [
              "to_dict"
            ],
            "line": 56
          },
          {
            "name": "RuleResult",
            "docstring": "Result from evaluating a single rule.",
            "methods": [
              "to_dict"
            ],
            "line": 83
          },
          {
            "name": "EvaluationResult",
            "docstring": "Complete result from rule evaluation.",
            "methods": [
              "to_dict"
            ],
            "line": 109
          },
          {
            "name": "Rule",
            "docstring": "Base class for recovery rules.",
            "methods": [
              "__init__",
              "evaluate",
              "__repr__"
            ],
            "line": 135
          },
          {
            "name": "ErrorCodeRule",
            "docstring": "Match based on error code patterns.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 158
          },
          {
            "name": "HistoricalPatternRule",
            "docstring": "Match based on historical success patterns.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 193
          },
          {
            "name": "SkillSpecificRule",
            "docstring": "Rules specific to certain skills.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 267
          },
          {
            "name": "OccurrenceThresholdRule",
            "docstring": "Escalate based on occurrence count.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 297
          },
          {
            "name": "CompositeRule",
            "docstring": "Combine multiple rules with AND/OR logic.",
            "methods": [
              "__init__",
              "evaluate"
            ],
            "line": 331
          },
          {
            "name": "RecoveryRuleEngine",
            "docstring": "Evaluates rules against failure context to recommend recovery actions.\n\nUsage:\n    engine = RecoveryRuleEngine()\n    result = engine.evaluate(context)\n    print(result.recommended_action)",
            "methods": [
              "__init__",
              "add_rule",
              "remove_rule",
              "evaluate"
            ],
            "line": 473
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [
          {
            "name": "DEBUG_MODE",
            "line": 47
          }
        ],
        "all_exports": [
          "Rule",
          "RuleContext",
          "RuleResult",
          "EvaluationResult",
          "ErrorCodeRule",
          "HistoricalPatternRule",
          "SkillSpecificRule",
          "OccurrenceThresholdRule",
          "CompositeRule",
          "RecoveryRuleEngine",
          "evaluate_rules",
          "DEFAULT_RULES",
          "AUTO_EXECUTE_CONFIDENCE_THRESHOLD",
          "should_auto_execute",
          "ERROR_CATEGORY_RULES",
          "classify_error_category",
          "RECOVERY_MODE_RULES",
          "suggest_recovery_mode",
          "ACTION_SELECTION_THRESHOLD",
          "combine_confidences",
          "should_select_action"
        ]
      },
      {
        "file_name": "recurrence_analysis_engine.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/recurrence_analysis_engine.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 189,
        "module_docstring": "Recurrence Analysis Service (L4 Engine)\n\nAnswers \"how often does this type repeat?\":\n- Group by (category, resolution_method)\n- Count occurrences over time window\n- Calculate recurrence rate\n\nDesign Rules:\n- Statistical analysis only\n- Read-only (no writes)\n- No cross-service calls\n- Delegates to L6 driver for DB access",
        "functions": [],
        "classes": [
          {
            "name": "RecurrenceGroup",
            "docstring": "A group of recurring incidents.",
            "methods": [],
            "line": 56
          },
          {
            "name": "RecurrenceResult",
            "docstring": "Result of recurrence analysis.",
            "methods": [],
            "line": 69
          },
          {
            "name": "RecurrenceAnalysisService",
            "docstring": "Analyze recurring incident patterns.\n\nRESPONSIBILITIES (L4):\n- Validate input parameters (threshold, baseline days)\n- Delegate to L6 driver for data access\n- Compose RecurrenceResult from driver snapshots\n- Calculate aggregates (total_recurring)\n\nFORBIDDEN:\n- Write to any table\n- Call other services\n- Import sqlalchemy at runtime",
            "methods": [
              "__init__",
              "analyze_recurrence",
              "get_recurrence_for_category",
              "_snapshot_to_group"
            ],
            "line": 77
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.recurrence_analysis_driver",
            "names": [
              "RecurrenceAnalysisDriver",
              "RecurrenceGroupSnapshot"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "semantic_failures.py",
        "file_path": "backend/app/hoc/cus/incidents/L5_engines/semantic_failures.py",
        "layer": "L5_engines",
        "domain": "incidents",
        "lines": 298,
        "module_docstring": "Semantic Failures \u2014 Canonical failure taxonomy for two-phase validation.\n\nTwo Phases:\n- Phase A: Intent Guardrails (INT-*) \u2014 design-time, human-facing\n- Phase B: Semantic Reality (SEM-*) \u2014 proof-time, system-facing\n\nEach failure code has:\n- Name: Human-readable name\n- Class: INTENT_VIOLATION or SEMANTIC_VIOLATION\n- Severity: BLOCKING or WARNING\n- Fix Owner: Who is responsible for fixing\n- Fix Action: What action to take\n\nThis taxonomy ensures violations are actionable, not just noise.",
        "functions": [
          {
            "name": "get_failure_info",
            "signature": "(code: FailureCode) -> Dict[str, Any]",
            "docstring": "Get failure taxonomy info for a code (INT-* or SEM-*).",
            "is_async": false,
            "line": 267
          },
          {
            "name": "get_fix_owner",
            "signature": "(code: FailureCode) -> str",
            "docstring": "Get the fix owner for a failure code.",
            "is_async": false,
            "line": 280
          },
          {
            "name": "get_fix_action",
            "signature": "(code: FailureCode) -> str",
            "docstring": "Get the fix action for a failure code.",
            "is_async": false,
            "line": 285
          },
          {
            "name": "get_violation_class",
            "signature": "(code: FailureCode) -> ViolationClass",
            "docstring": "Get the violation class for a failure code.",
            "is_async": false,
            "line": 290
          },
          {
            "name": "format_violation_message",
            "signature": "(code: FailureCode, context_msg: str) -> str",
            "docstring": "Format a violation message with context.",
            "is_async": false,
            "line": 295
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Union"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "semantic_types",
            "names": [
              "FailureCode",
              "IntentFailureCode",
              "SemanticFailureCode",
              "SemanticSeverity",
              "ViolationClass"
            ],
            "is_relative": true,
            "line": 43
          }
        ],
        "constants": [
          {
            "name": "SEMANTIC_FAILURE_TAXONOMY",
            "line": 257
          },
          {
            "name": "INTENT_FAILURE_TAXONOMY",
            "line": 262
          }
        ],
        "all_exports": null
      }
    ],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "export_bundle_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/export_bundle_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 421,
        "module_docstring": "Export Bundle Service\n\nGenerates structured export bundles from incidents, runs, and traces\nfor evidence export, SOC2 compliance, and executive debriefs.\n\nKey Responsibilities:\n1. Load incident, run, and trace data\n2. Assemble EvidenceBundle with all cross-domain links\n3. Enhance for SOC2 compliance (control mappings)\n4. Generate executive summary (non-technical)",
        "functions": [
          {
            "name": "get_export_bundle_service",
            "signature": "() -> ExportBundleService",
            "docstring": "Get or create ExportBundleService singleton.",
            "is_async": false,
            "line": 416
          }
        ],
        "classes": [
          {
            "name": "ExportBundleService",
            "docstring": "Generate structured export bundles from incidents/traces.",
            "methods": [
              "__init__",
              "trace_store",
              "create_evidence_bundle",
              "create_soc2_bundle",
              "create_executive_debrief",
              "_compute_bundle_hash",
              "_generate_attestation",
              "_assess_risk_level",
              "_generate_incident_summary",
              "_assess_business_impact",
              "_generate_recommendations"
            ],
            "line": 59
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.db",
            "names": [
              "Incident",
              "Run",
              "engine"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.export_bundles",
            "names": [
              "DEFAULT_SOC2_CONTROLS",
              "EvidenceBundle",
              "ExecutiveDebriefBundle",
              "PolicyContext",
              "SOC2Bundle",
              "TraceStepEvidence"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.traces.store",
            "names": [
              "TraceStore"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incident_aggregator.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_aggregator.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 613,
        "module_docstring": "Incident Aggregation Driver - Prevents Incident Explosion Under Load\n\nThis service implements intelligent incident grouping to prevent thousands of\nmicro-incidents during large outages. It uses a sliding window approach with\nconfigurable thresholds.\n\nKey Features:\n1. Time-window aggregation (default 5 minutes)\n2. Tenant + trigger_type grouping key\n3. Rate limiting (max 1 incident per key per window)\n4. Auto-escalation for high-volume windows\n5. Incident merging for related failures\n\nWatchpoint #1: Incident Explosion Under Load\n- During a 1000-request outage, we create 1 incident, not 1000\n- Related calls are added to the incident's related_call_ids\n- Severity auto-escalates based on affected call count\n\nARCHITECTURE RULE (LESSONS_ENFORCED.md Invariant #10):\n- This service MUST be constructed with explicit dependency injection\n- NO lazy service resolution (get_incident_aggregator is BANNED)\n- All collaborators (clock, uuid_fn) MUST be passed via constructor\n- Verification scripts and production MUST use the same constructor pattern",
        "functions": [
          {
            "name": "create_incident_aggregator",
            "signature": "(config: Optional[IncidentAggregatorConfig] = None) -> IncidentAggregator",
            "docstring": "Create an IncidentAggregator with canonical dependencies.\n\nThis is the ONLY sanctioned way to create an aggregator.\nUses generate_uuid and utc_now from app.utils.runtime.\n\nUsage:\n    aggregator = create_incident_aggregator()\n    # or with custom config:\n    aggregator = create_incident_aggregator(config=IncidentAggregatorConfig(...))",
            "is_async": false,
            "line": 595
          }
        ],
        "classes": [
          {
            "name": "IncidentAggregatorConfig",
            "docstring": "Configuration for incident aggregation behavior (L6 persistence config only).",
            "methods": [],
            "line": 79
          },
          {
            "name": "IncidentKey",
            "docstring": "Grouping key for incident aggregation.\n\nIncidents are grouped by:\n- tenant_id: Isolation between tenants\n- trigger_type: Type of failure (failure_spike, budget_breach, rate_limit)\n- window_start: 5-minute bucketed window",
            "methods": [
              "__hash__",
              "__eq__",
              "from_event"
            ],
            "line": 104
          },
          {
            "name": "IncidentAggregator",
            "docstring": "L6 Driver for intelligent incident aggregation.\n\nPrevents incident explosion by:\n1. Grouping related failures into single incidents\n2. Rate limiting incident creation per tenant\n3. Auto-escalating severity based on impact (delegated to L4 engine)\n4. Merging calls into existing open incidents\n\nINVARIANT #10: Explicit Dependency Injection Required\n- clock: Function that returns current UTC datetime\n- uuid_fn: Function that generates UUID strings\n- severity_engine: L4 engine for severity decisions (optional, defaults to standard)\n- These MUST be passed explicitly, not resolved lazily\n\nEXTRACTION NOTE (2026-01-24):\nSeverity logic extracted to incident_severity_engine.py (L4).\nThis driver delegates severity decisions to the engine.",
            "methods": [
              "__init__",
              "get_or_create_incident",
              "_find_open_incident",
              "_can_create_incident",
              "_get_rate_limit_incident",
              "_create_incident",
              "_add_call_to_incident",
              "_add_incident_event",
              "resolve_stale_incidents",
              "get_incident_stats"
            ],
            "line": 146
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "Optional",
              "Tuple",
              "cast"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "and_",
              "select"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.incidents.L5_engines.incident_severity_engine",
            "names": [
              "IncidentSeverityEngine",
              "SeverityConfig",
              "generate_incident_title"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentEvent",
              "IncidentSeverity",
              "IncidentStatus"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.utils.runtime",
            "names": [
              "generate_uuid",
              "utc_now"
            ],
            "is_relative": false,
            "line": 66
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "incident_pattern_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_pattern_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 255,
        "module_docstring": "Incident Pattern Driver (L6)\n\nPure database operations for incident pattern detection.\nAll business logic stays in L4 engine.\n\nOperations:\n- Incident count queries\n- Category cluster aggregation\n- Severity spike detection\n- Cascade failure grouping\n\nNO business logic:\n- NO confidence calculation (L4)\n- NO threshold decisions (L4)\n- NO pattern type determination (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_pattern_driver",
            "signature": "(session: AsyncSession) -> IncidentPatternDriver",
            "docstring": "Factory function to get IncidentPatternDriver instance.",
            "is_async": false,
            "line": 247
          }
        ],
        "classes": [
          {
            "name": "IncidentPatternDriver",
            "docstring": "L6 driver for incident pattern detection operations (async).\n\nPure database access - no business logic.\nAll operations are READ-ONLY.",
            "methods": [
              "__init__",
              "fetch_incidents_count",
              "fetch_category_clusters",
              "fetch_severity_spikes",
              "fetch_cascade_failures"
            ],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 68
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentPatternDriver",
          "get_incident_pattern_driver"
        ]
      },
      {
        "file_name": "incident_read_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_read_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 209,
        "module_docstring": "Incident Read Driver (L6)\n\nPure data access layer for incident read operations.\nNo business logic - only query construction and data retrieval.\n\nArchitecture:\n    L3 (Adapter) \u2192 L4 (Engine) \u2192 L6 (this driver) \u2192 Database\n\nOperations:\n- Query incidents with tenant isolation\n- Query incident events\n- Count queries\n- No mutations (read-only)\n\nReference: PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_read_driver",
            "signature": "(session: Session) -> IncidentReadDriver",
            "docstring": "Factory function to get IncidentReadDriver instance.",
            "is_async": false,
            "line": 201
          }
        ],
        "classes": [
          {
            "name": "IncidentReadDriver",
            "docstring": "L6 driver for incident read operations.\n\nPure data access - no business logic.\nAll methods require tenant_id for isolation.",
            "methods": [
              "__init__",
              "list_incidents",
              "get_incident",
              "get_incident_events",
              "count_incidents_since",
              "get_last_incident"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentEvent"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentReadDriver",
          "get_incident_read_driver"
        ]
      },
      {
        "file_name": "incident_write_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incident_write_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 540,
        "module_docstring": "Incident Write Driver (L6)\n\nPure database write operations for incidents.\nAll business logic stays in L4 engine.\n\nOperations:\n- Create incidents from run failures/successes\n- Create prevention records (policy suppression)\n- Create policy proposals\n- Update incident state (acknowledge, resolve)\n- Update related tables (runs.incident_count, aos_traces.incident_id)\n- Create incident events (timeline)\n\nNO business logic:\n- NO severity/category mapping (L4)\n- NO policy suppression decisions (L4)\n- NO proposal creation decisions (L4)\n\nReference: PIN-281, PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_incident_write_driver",
            "signature": "(session: Session) -> IncidentWriteDriver",
            "docstring": "Factory function to get IncidentWriteDriver instance.",
            "is_async": false,
            "line": 532
          }
        ],
        "classes": [
          {
            "name": "IncidentWriteDriver",
            "docstring": "L6 driver for incident write operations.\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "update_incident_acknowledged",
              "update_incident_resolved",
              "create_incident_event",
              "refresh_incident",
              "insert_incident",
              "update_run_incident_count",
              "update_trace_incident_id",
              "insert_prevention_record",
              "insert_policy_proposal",
              "fetch_suppressing_policy",
              "fetch_incidents_by_run_id"
            ],
            "line": 86
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 79
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 80
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident",
              "IncidentEvent",
              "IncidentStatus"
            ],
            "is_relative": false,
            "line": 83
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentWriteDriver",
          "get_incident_write_driver"
        ]
      },
      {
        "file_name": "incidents_facade_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/incidents_facade_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 531,
        "module_docstring": "Incidents Facade Driver (L6)\n\nPure database access layer for the incidents facade.\nReturns snapshots (dicts/dataclasses), not ORM models.\n\nResponsibilities:\n- Execute queries against incidents table\n- Return data snapshots\n- NO business logic\n- NO result type composition (that's L4's job)\n\nThis driver was extracted from incidents_facade.py per HOC Layer Topology V1.",
        "functions": [],
        "classes": [
          {
            "name": "IncidentSnapshot",
            "docstring": "Raw incident data snapshot from database.",
            "methods": [],
            "line": 53
          },
          {
            "name": "IncidentListSnapshot",
            "docstring": "Paginated list of incident snapshots.",
            "methods": [],
            "line": 77
          },
          {
            "name": "MetricsSnapshot",
            "docstring": "Raw metrics aggregates from database.",
            "methods": [],
            "line": 85
          },
          {
            "name": "CostImpactRowSnapshot",
            "docstring": "Single row from cost impact query.",
            "methods": [],
            "line": 105
          },
          {
            "name": "IncidentsFacadeDriver",
            "docstring": "L6 Database driver for incidents facade.\n\nPure data access - no business logic.\nReturns snapshots, not ORM models.",
            "methods": [
              "__init__",
              "fetch_active_incidents",
              "fetch_resolved_incidents",
              "fetch_historical_incidents",
              "fetch_incident_by_id",
              "fetch_incidents_by_run",
              "fetch_metrics_aggregates",
              "fetch_cost_impact_data",
              "_to_snapshot"
            ],
            "line": 120
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select",
              "text"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "Incident"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": [
          "IncidentsFacadeDriver",
          "IncidentSnapshot",
          "IncidentListSnapshot",
          "MetricsSnapshot",
          "CostImpactRowSnapshot"
        ]
      },
      {
        "file_name": "lessons_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/lessons_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 649,
        "module_docstring": "Lessons Driver (L6)\n\nPure database operations for lessons_learned table.\nAll business logic stays in L4 engine.\n\nOperations:\n- Create lessons from various triggers\n- Query lessons with filters\n- Update lesson state (defer, dismiss, convert, reactivate)\n- Debounce checks\n- Scheduler support (expired deferred)\n\nNO business logic:\n- NO state machine validation (L4)\n- NO debounce decisions (L4)\n- NO severity mapping (L4)\n- NO description generation (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_lessons_driver",
            "signature": "(session: Session) -> LessonsDriver",
            "docstring": "Factory function to get LessonsDriver instance.",
            "is_async": false,
            "line": 641
          }
        ],
        "classes": [
          {
            "name": "LessonsDriver",
            "docstring": "L6 driver for lessons_learned operations.\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "insert_lesson",
              "fetch_lesson_by_id",
              "fetch_lessons_list",
              "fetch_lesson_stats",
              "update_lesson_deferred",
              "update_lesson_dismissed",
              "update_lesson_converted",
              "update_lesson_reactivated",
              "fetch_debounce_count",
              "fetch_expired_deferred",
              "insert_policy_proposal_from_lesson"
            ],
            "line": 83
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 79
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 80
          }
        ],
        "constants": [],
        "all_exports": [
          "LessonsDriver",
          "get_lessons_driver"
        ]
      },
      {
        "file_name": "llm_failure_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/llm_failure_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 331,
        "module_docstring": "LLM Failure Driver (L6)\n\nPure database operations for LLM failure handling.\nAll business logic stays in L4 engine.\n\nOperations:\n- Create failure facts\n- Create evidence records\n- Mark runs as failed\n- Contamination verification (read-only)\n\nNO business logic:\n- NO invariant checking (L4)\n- NO verification mode decisions (L4)\n- NO failure type validation (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_llm_failure_driver",
            "signature": "(session: AsyncSession) -> LLMFailureDriver",
            "docstring": "Factory function to get LLMFailureDriver instance.",
            "is_async": false,
            "line": 323
          }
        ],
        "classes": [
          {
            "name": "LLMFailureDriver",
            "docstring": "L6 driver for LLM failure operations (async).\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "insert_failure",
              "insert_evidence",
              "update_run_failed",
              "fetch_failure_by_run_id",
              "fetch_contamination_check"
            ],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 71
          }
        ],
        "constants": [],
        "all_exports": [
          "LLMFailureDriver",
          "get_llm_failure_driver"
        ]
      },
      {
        "file_name": "policy_violation_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/policy_violation_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 490,
        "module_docstring": "Policy Violation Driver (L6)\n\nPure database operations for policy violation handling.\nAll business logic stays in L4 engine.\n\nOperations:\n- Create violation facts\n- Check violation/policy existence\n- Create evidence events\n- Policy evaluation records (both async and sync patterns)\n\nNO business logic:\n- NO outcome mapping (L4)\n- NO verification mode decisions (L4)\n- NO validation decisions (L4)\n- NO severity mapping (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "insert_policy_evaluation_sync",
            "signature": "(database_url: str, evaluation_id: str, run_id: str, tenant_id: str, outcome: str, policies_checked: int, confidence: float, created_at: datetime, is_synthetic: bool, synthetic_scenario_id: Optional[str]) -> Optional[str]",
            "docstring": "Insert policy evaluation record using sync psycopg2 connection.\n\nThis is used in worker contexts where async is not available.\n\nArgs:\n    database_url: Database connection URL\n    evaluation_id: Generated evaluation ID\n    run_id: Run being evaluated\n    tenant_id: Tenant scope\n    outcome: Policy outcome\n    policies_checked: Number of policies checked\n    confidence: Match confidence\n    created_at: Timestamp\n    is_synthetic: SDSR flag\n    synthetic_scenario_id: Scenario ID for SDSR\n\nReturns:\n    evaluation_id if inserted, None if failed",
            "is_async": false,
            "line": 408
          },
          {
            "name": "get_policy_violation_driver",
            "signature": "(session: AsyncSession) -> PolicyViolationDriver",
            "docstring": "Factory function to get PolicyViolationDriver instance.",
            "is_async": false,
            "line": 481
          }
        ],
        "classes": [
          {
            "name": "PolicyViolationDriver",
            "docstring": "L6 driver for policy violation operations (async).\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "insert_violation_record",
              "fetch_violation_exists",
              "fetch_policy_enabled",
              "insert_evidence_event",
              "fetch_incident_by_violation",
              "fetch_violation_truth_check",
              "insert_policy_evaluation"
            ],
            "line": 82
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 73
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 77
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyViolationDriver",
          "get_policy_violation_driver",
          "insert_policy_evaluation_sync"
        ]
      },
      {
        "file_name": "postmortem_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/postmortem_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 316,
        "module_docstring": "Post-Mortem Driver (L6)\n\nPure database operations for post-mortem analytics.\nAll business logic stays in L4 engine.\n\nOperations:\n- Category statistics queries\n- Resolution method aggregation\n- Recurrence rate calculation\n- Similar incident lookup\n\nNO business logic:\n- NO insight generation (L4)\n- NO confidence calculation (L4)\n- NO pattern analysis (L4)\n\nReference: PIN-468, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_postmortem_driver",
            "signature": "(session: AsyncSession) -> PostMortemDriver",
            "docstring": "Factory function to get PostMortemDriver instance.",
            "is_async": false,
            "line": 308
          }
        ],
        "classes": [
          {
            "name": "PostMortemDriver",
            "docstring": "L6 driver for post-mortem analytics operations (async).\n\nPure database access - no business logic.\nAll operations are READ-ONLY.",
            "methods": [
              "__init__",
              "fetch_category_stats",
              "fetch_resolution_methods",
              "fetch_recurrence_data",
              "fetch_resolution_summary",
              "fetch_similar_incidents"
            ],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 68
          }
        ],
        "constants": [],
        "all_exports": [
          "PostMortemDriver",
          "get_postmortem_driver"
        ]
      },
      {
        "file_name": "recurrence_analysis_driver.py",
        "file_path": "backend/app/hoc/cus/incidents/L6_drivers/recurrence_analysis_driver.py",
        "layer": "L6_drivers",
        "domain": "incidents",
        "lines": 213,
        "module_docstring": "Recurrence Analysis Driver (L6)\n\nPure database access layer for recurrence analysis.\nReturns snapshots (dicts/dataclasses), not ORM models.\n\nResponsibilities:\n- Execute queries against incidents table for recurrence patterns\n- Return data snapshots\n- NO business logic\n- NO threshold decisions (that's L4's job)\n\nThis driver was extracted from recurrence_analysis_service.py per HOC Layer Topology V1.",
        "functions": [],
        "classes": [
          {
            "name": "RecurrenceGroupSnapshot",
            "docstring": "Raw recurrence group data from database.",
            "methods": [],
            "line": 51
          },
          {
            "name": "RecurrenceAnalysisDriver",
            "docstring": "L6 Database driver for recurrence analysis.\n\nPure data access - no business logic.\nReturns snapshots, not computed analysis.",
            "methods": [
              "__init__",
              "fetch_recurrence_groups",
              "fetch_recurrence_for_category"
            ],
            "line": 69
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "RecurrenceAnalysisDriver",
          "RecurrenceGroupSnapshot"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 30,
    "violation_count": 4,
    "gap_count": 2
  },
  "policies": {
    "l2_1_facade": null,
    "l2_apis": [
      {
        "file_name": "M25_integrations.py",
        "file_path": "backend/app/hoc/api/cus/policies/M25_integrations.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1586,
        "module_docstring": "M25 Integration API\n\nEndpoints for:\n- Loop status monitoring\n- Human checkpoint resolution\n- Integration statistics\n- Retry/revert operations\n- Graduation status (M25 learning proof)\n- Prevention timeline (Gate 3)",
        "functions": [
          {
            "name": "get_tenant_id_from_token",
            "signature": "(token: FounderToken = Depends(verify_fops_token)) -> str",
            "docstring": "Get tenant ID from founder token - PIN-318 secure implementation.",
            "is_async": false,
            "line": 48
          },
          {
            "name": "get_current_user_from_token",
            "signature": "(token: FounderToken = Depends(verify_fops_token)) -> dict",
            "docstring": "Get current user from founder token - PIN-318 secure implementation.",
            "is_async": false,
            "line": 54
          },
          {
            "name": "get_tenant_id",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID')) -> str",
            "docstring": "DEPRECATED: Get tenant ID from query parameter. Use get_tenant_id_from_token instead.",
            "is_async": false,
            "line": 60
          },
          {
            "name": "get_current_user",
            "signature": "(user_id: Optional[str] = Query(None, description='User ID')) -> Optional[dict]",
            "docstring": "DEPRECATED: Get current user from query parameter. Use get_current_user_from_token instead.",
            "is_async": false,
            "line": 65
          },
          {
            "name": "get_loop_status",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id)) -> LoopStatusResponse",
            "docstring": "Get current loop status for an incident.\n\nReturns the full loop state including:\n- Completed and failed stages\n- Pending human checkpoints\n- Narrative artifacts for storytelling",
            "is_async": true,
            "line": 181
          },
          {
            "name": "get_loop_stages",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id)) -> list[StageDetail]",
            "docstring": "Get detailed stage information for a loop.",
            "is_async": true,
            "line": 225
          },
          {
            "name": "stream_loop_status",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id))",
            "docstring": "SSE endpoint for live loop status updates.\n\nConnect to receive real-time updates as the loop progresses.",
            "is_async": true,
            "line": 265
          },
          {
            "name": "retry_loop_stage",
            "signature": "(incident_id: str, request: RetryStageRequest, tenant_id: str = Depends(get_tenant_id)) -> LoopStatusResponse",
            "docstring": "Retry a failed loop stage.",
            "is_async": true,
            "line": 312
          },
          {
            "name": "revert_loop",
            "signature": "(incident_id: str, request: RevertLoopRequest, tenant_id: str = Depends(get_tenant_id), user: dict = Depends(get_current_user)) -> dict",
            "docstring": "Revert all changes made by a loop.\n\nThis is the ultimate human override - use with caution.",
            "is_async": true,
            "line": 347
          },
          {
            "name": "list_pending_checkpoints",
            "signature": "(tenant_id: str = Depends(get_tenant_id)) -> list[CheckpointResponse]",
            "docstring": "List all pending human checkpoints for the tenant.",
            "is_async": true,
            "line": 382
          },
          {
            "name": "get_checkpoint",
            "signature": "(checkpoint_id: str, tenant_id: str = Depends(get_tenant_id)) -> CheckpointResponse",
            "docstring": "Get details of a specific checkpoint.",
            "is_async": true,
            "line": 412
          },
          {
            "name": "resolve_checkpoint",
            "signature": "(checkpoint_id: str, request: ResolveCheckpointRequest, tenant_id: str = Depends(get_tenant_id), user: dict = Depends(get_current_user)) -> dict",
            "docstring": "Resolve a pending checkpoint.\n\nAvailable resolutions depend on checkpoint type:\n- approve_policy: approve, reject, modify\n- approve_recovery: apply, reject, defer\n- simulate_routing: apply, cancel\n- revert_loop: confirm_revert, cancel",
            "is_async": true,
            "line": 457
          },
          {
            "name": "get_integration_stats",
            "signature": "(tenant_id: str = Depends(get_tenant_id), hours: int = Query(24, ge=1, le=720, description='Period in hours')) -> IntegrationStatsResponse",
            "docstring": "Get integration loop statistics for the specified period.",
            "is_async": true,
            "line": 498
          },
          {
            "name": "get_loop_narrative",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Get narrative artifacts for an incident loop.\n\nReturns storytelling elements:\n- before_after: Before vs After this incident\n- policy_origin: Policy born from this failure\n- agent_improvement: How agent behavior improved",
            "is_async": true,
            "line": 648
          },
          {
            "name": "get_graduation_status",
            "signature": "(tenant_id: str = Depends(get_tenant_id)) -> HardenedGraduationResponse",
            "docstring": "Get M25 graduation status (HARDENED).\n\nCRITICAL: This status is DERIVED from evidence, not manually set.\n\nReturns:\n- Derived graduation level (alpha/beta/candidate/complete/degraded)\n- Gate status with evidence\n- Capability gates (what's unlocked/blocked)\n- Simulation state (separate from real graduation)\n- Degradation info if status has regressed\n\nGraduation is computed from real evidence only:\n- Simulated records are excluded\n- Status is re-evaluated on each call\n- Degradation occurs when evidence regresses",
            "is_async": true,
            "line": 757
          },
          {
            "name": "simulate_prevention",
            "signature": "(request: SimulatePreventionRequest, tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Simulate a prevention event for demo/testing purposes.\n\nIMPORTANT: Simulated records are marked with is_simulated=true\nand DO NOT count toward real graduation.\n\nThis endpoint creates demo data for UI testing only.\nReal graduation requires real prevention evidence.",
            "is_async": true,
            "line": 935
          },
          {
            "name": "simulate_regret",
            "signature": "(request: SimulateRegretRequest, tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Simulate a regret event for demo/testing purposes.\n\nIMPORTANT: Simulated records are marked with is_simulated=true\nand DO NOT count toward real graduation.\n\nThis endpoint creates demo data for UI testing only.\nReal graduation requires real regret/demotion evidence.",
            "is_async": true,
            "line": 1013
          },
          {
            "name": "simulate_timeline_view",
            "signature": "(incident_id: str = Query(..., description='Incident ID to mark as viewed in timeline'), tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Simulate viewing a prevention timeline for Gate 3.\n\nIMPORTANT: Simulated views are marked with is_simulated=true\nand DO NOT count toward real graduation.\n\nThis endpoint creates demo data for UI testing only.\nReal graduation requires real timeline views.",
            "is_async": true,
            "line": 1105
          },
          {
            "name": "record_timeline_view",
            "signature": "(incident_id: str = Query(..., description='Incident ID viewed in timeline'), has_prevention: bool = Query(False, description='Timeline shows prevention event'), has_rollback: bool = Query(False, description='Timeline shows rollback event'), tenant_id: str = Depends(get_tenant_id), user: dict = Depends(get_current_user)) -> dict",
            "docstring": "Record a REAL timeline view for Gate 3 graduation.\n\nThis endpoint is called by the console when a user ACTUALLY views\nan incident's prevention timeline. This counts toward real graduation.\n\nCall this when:\n- User opens the prevention timeline UI\n- Timeline shows learning proof (prevention or rollback)",
            "is_async": true,
            "line": 1167
          },
          {
            "name": "trigger_graduation_re_evaluation",
            "signature": "(tenant_id: str = Depends(get_tenant_id)) -> dict",
            "docstring": "Trigger a re-evaluation of graduation status.\n\nThis recalculates graduation level from current evidence.\nUseful after:\n- New prevention/regret events\n- Timeline views recorded\n- Manual verification\n\nNote: Graduation is automatically re-evaluated on GET /graduation,\nbut this endpoint forces a fresh computation and stores history.",
            "is_async": true,
            "line": 1233
          },
          {
            "name": "get_prevention_timeline",
            "signature": "(incident_id: str, tenant_id: str = Depends(get_tenant_id)) -> PreventionTimelineResponse",
            "docstring": "Get the prevention timeline for an incident.\n\nThis is the Gate 3 UI - shows the learning loop in action:\n1. Original incident detected\n2. Pattern identified\n3. Policy born from failure\n4. (later) Similar incident detected\n5. Policy PREVENTED recurrence\n\nViewing this timeline with a prevention event proves Gate 3.",
            "is_async": true,
            "line": 1379
          }
        ],
        "classes": [
          {
            "name": "LoopStatusResponse",
            "docstring": "Response for loop status endpoint.",
            "methods": [],
            "line": 87
          },
          {
            "name": "StageDetail",
            "docstring": "Detail for a single stage.",
            "methods": [],
            "line": 105
          },
          {
            "name": "CheckpointResponse",
            "docstring": "Response for human checkpoint.",
            "methods": [],
            "line": 116
          },
          {
            "name": "ResolveCheckpointRequest",
            "docstring": "Request to resolve a checkpoint.",
            "methods": [],
            "line": 133
          },
          {
            "name": "IntegrationStatsResponse",
            "docstring": "Statistics for integration loop.",
            "methods": [],
            "line": 139
          },
          {
            "name": "RetryStageRequest",
            "docstring": "Request to retry a failed stage.",
            "methods": [],
            "line": 163
          },
          {
            "name": "RevertLoopRequest",
            "docstring": "Request to revert a loop.",
            "methods": [],
            "line": 169
          },
          {
            "name": "GateEvidenceResponse",
            "docstring": "Evidence for a graduation gate.",
            "methods": [],
            "line": 693
          },
          {
            "name": "CapabilityStatus",
            "docstring": "Status of a capability gate.",
            "methods": [],
            "line": 704
          },
          {
            "name": "SimulationStatus",
            "docstring": "Simulation mode status - separate from real graduation.",
            "methods": [],
            "line": 711
          },
          {
            "name": "HardenedGraduationResponse",
            "docstring": "Hardened graduation status response.\n\nKey differences from v1:\n- Status is DERIVED from evidence, not manually set\n- Includes capability gates (what's unlocked/blocked)\n- Includes simulation status (separate from real)\n- Includes degradation info",
            "methods": [],
            "line": 719
          },
          {
            "name": "SimulatePreventionRequest",
            "docstring": "Request to simulate a prevention event for demo/testing.",
            "methods": [],
            "line": 925
          },
          {
            "name": "SimulateRegretRequest",
            "docstring": "Request to simulate a regret event for demo/testing.",
            "methods": [],
            "line": 1003
          },
          {
            "name": "TimelineEventResponse",
            "docstring": "A single event in the prevention timeline.",
            "methods": [],
            "line": 1356
          },
          {
            "name": "PreventionTimelineResponse",
            "docstring": "Response for prevention timeline endpoint.",
            "methods": [],
            "line": 1368
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "fastapi.responses",
            "names": [
              "StreamingResponse"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "auth.console_auth",
            "names": [
              "FounderToken",
              "verify_fops_token"
            ],
            "is_relative": true,
            "line": 44
          },
          {
            "module": "schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": true,
            "line": 45
          },
          {
            "module": "app.integrations.events",
            "names": [
              "LoopStage"
            ],
            "is_relative": false,
            "line": 72
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "alerts.py",
        "file_path": "backend/app/hoc/api/cus/policies/alerts.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 446,
        "module_docstring": "Alerts API (L2)\n\nProvides alert operations:\n- POST /api/v1/alerts/rules (create rule)\n- GET /api/v1/alerts/rules (list rules)\n- GET /api/v1/alerts/rules/{id} (get rule)\n- PUT /api/v1/alerts/rules/{id} (update rule)\n- DELETE /api/v1/alerts/rules/{id} (delete rule)\n- GET /api/v1/alerts/history (alert history)\n- GET /api/v1/alerts/history/{id} (get event)\n- POST /api/v1/alerts/history/{id}/acknowledge (acknowledge)\n- POST /api/v1/alerts/history/{id}/resolve (resolve)\n- POST /api/v1/alerts/routes (create route)\n- GET /api/v1/alerts/routes (list routes)\n- DELETE /api/v1/alerts/routes/{id} (delete route)\n\nThis is the ONLY facade for alert operations.\nAll alert APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> AlertsFacade",
            "docstring": "Get the alerts facade.",
            "is_async": false,
            "line": 98
          },
          {
            "name": "create_rule",
            "signature": "(request: CreateRuleRequest, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.write')))",
            "docstring": "Create an alert rule (GAP-110).\n\n**Tier: REACT ($9)** - Alert configuration.\n\nCondition example:\n```json\n{\n    \"metric\": \"cost_daily\",\n    \"operator\": \"gt\",\n    \"threshold\": 1000\n}\n```",
            "is_async": true,
            "line": 109
          },
          {
            "name": "list_rules",
            "signature": "(severity: Optional[str] = Query(None, description='Filter by severity'), enabled_only: bool = Query(False, description='Only enabled rules'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "List alert rules.",
            "is_async": true,
            "line": 144
          },
          {
            "name": "get_rule",
            "signature": "(rule_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "Get a specific alert rule.",
            "is_async": true,
            "line": 173
          },
          {
            "name": "update_rule",
            "signature": "(rule_id: str, request: UpdateRuleRequest, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.write')))",
            "docstring": "Update an alert rule.",
            "is_async": true,
            "line": 194
          },
          {
            "name": "delete_rule",
            "signature": "(rule_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.write')))",
            "docstring": "Delete an alert rule.",
            "is_async": true,
            "line": 222
          },
          {
            "name": "list_history",
            "signature": "(rule_id: Optional[str] = Query(None, description='Filter by rule'), severity: Optional[str] = Query(None, description='Filter by severity'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "List alert history (GAP-111).\n\nReturns triggered alert events with status.",
            "is_async": true,
            "line": 248
          },
          {
            "name": "get_event",
            "signature": "(event_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "Get a specific alert event.",
            "is_async": true,
            "line": 281
          },
          {
            "name": "acknowledge_event",
            "signature": "(event_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.acknowledge')))",
            "docstring": "Acknowledge an alert event.",
            "is_async": true,
            "line": 302
          },
          {
            "name": "resolve_event",
            "signature": "(event_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.resolve')))",
            "docstring": "Resolve an alert event.",
            "is_async": true,
            "line": 326
          },
          {
            "name": "create_route",
            "signature": "(request: CreateRouteRequest, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.routes')))",
            "docstring": "Create an alert route (GAP-124).\n\n**Tier: PREVENT ($199)** - Alert routing configuration.\n\nRoutes determine where alerts are sent based on labels.",
            "is_async": true,
            "line": 355
          },
          {
            "name": "list_routes",
            "signature": "(enabled_only: bool = Query(False, description='Only enabled routes'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "List alert routes.",
            "is_async": true,
            "line": 381
          },
          {
            "name": "get_route",
            "signature": "(route_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.read')))",
            "docstring": "Get a specific alert route.",
            "is_async": true,
            "line": 408
          },
          {
            "name": "delete_route",
            "signature": "(route_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: AlertsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('alerts.routes')))",
            "docstring": "Delete an alert route.",
            "is_async": true,
            "line": 429
          }
        ],
        "classes": [
          {
            "name": "CreateRuleRequest",
            "docstring": "Request to create alert rule.",
            "methods": [],
            "line": 63
          },
          {
            "name": "UpdateRuleRequest",
            "docstring": "Request to update alert rule.",
            "methods": [],
            "line": 74
          },
          {
            "name": "CreateRouteRequest",
            "docstring": "Request to create alert route.",
            "methods": [],
            "line": 84
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.general.L5_engines.alerts_facade",
            "names": [
              "AlertsFacade",
              "get_alerts_facade"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "analytics.py",
        "file_path": "backend/app/hoc/api/cus/policies/analytics.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1067,
        "module_docstring": "Unified Analytics API (L2)\n\nCustomer-facing endpoints for viewing usage statistics.\nAll requests are tenant-scoped via auth_context.\n\nDomain: Analytics\nSubdomain: Statistics\nTopic v1: Usage\n\nEndpoints:\n- GET /api/v1/analytics/statistics/usage             \u2192 Usage statistics\n- GET /api/v1/analytics/statistics/usage/export.csv  \u2192 CSV export\n- GET /api/v1/analytics/statistics/usage/export.json \u2192 JSON export\n- GET /api/v1/analytics/_status                      \u2192 Capability probe\n\nArchitecture:\n- ONE facade for all ANALYTICS needs\n- Facade normalizes, aggregates, enforces contracts\n- Does NOT compute - delegates to signal adapters\n- Tenant isolation via auth_context (not header)\n- Export endpoints use SAME aggregator (bit-equivalent)",
        "functions": [
          {
            "name": "get_usage_statistics",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session: AsyncSession = Depends(get_async_session_dep)) -> UsageStatisticsResponse",
            "docstring": "Get usage statistics for the specified time window.\n\nThis is the primary read endpoint for the Usage topic.\nREAD-ONLY customer facade - delegates to L4 AnalyticsFacade.",
            "is_async": true,
            "line": 239
          },
          {
            "name": "get_analytics_status",
            "signature": "() -> AnalyticsStatusResponse",
            "docstring": "Analytics capability probe.\n\nUsed by console/clients to discover available capabilities\nbefore attempting to render panels.\nREAD-ONLY customer facade - delegates to L4 AnalyticsFacade.",
            "is_async": true,
            "line": 359
          },
          {
            "name": "get_cost_statistics",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session: AsyncSession = Depends(get_async_session_dep)) -> CostStatisticsResponse",
            "docstring": "Get cost statistics for the specified time window.\n\nPrimary endpoint for the Cost topic.\nREAD-ONLY customer facade - delegates to L4 AnalyticsFacade.",
            "is_async": true,
            "line": 413
          },
          {
            "name": "analytics_health",
            "signature": "()",
            "docstring": "Internal health check for analytics facade.",
            "is_async": true,
            "line": 555
          },
          {
            "name": "_get_usage_data",
            "signature": "(request: Request, from_ts: datetime, to_ts: datetime, resolution: ResolutionType, scope: ScopeType, session: AsyncSession) -> UsageStatisticsResponse",
            "docstring": "Internal helper to get usage data (shared by read and export endpoints).\n\nEnsures export is bit-equivalent to read API - no alternate code paths.\nDelegates to L4 AnalyticsFacade.",
            "is_async": true,
            "line": 565
          },
          {
            "name": "export_usage_csv",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session: AsyncSession = Depends(get_async_session_dep)) -> Response",
            "docstring": "Export usage statistics as CSV.\n\nUses the same aggregation logic as the read API.\nDeterministic ordering. UTC only.",
            "is_async": true,
            "line": 673
          },
          {
            "name": "export_usage_json",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session: AsyncSession = Depends(get_async_session_dep)) -> UsageStatisticsResponse",
            "docstring": "Export usage statistics as JSON.\n\nStructure matches the standard usage response.\nBit-equivalent to read API.",
            "is_async": true,
            "line": 759
          },
          {
            "name": "_get_cost_data",
            "signature": "(request: Request, from_ts: datetime, to_ts: datetime, resolution: ResolutionType, scope: ScopeType, session: AsyncSession) -> CostStatisticsResponse",
            "docstring": "Internal helper to get cost data (shared by read and export endpoints).\n\nEnsures export is bit-equivalent to read API - no alternate code paths.\nDelegates to L4 AnalyticsFacade.",
            "is_async": true,
            "line": 806
          },
          {
            "name": "export_cost_csv",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session: AsyncSession = Depends(get_async_session_dep)) -> Response",
            "docstring": "Export cost statistics as CSV.\n\nUses the same aggregation logic as the read API.\nDeterministic ordering. UTC only.",
            "is_async": true,
            "line": 941
          },
          {
            "name": "export_cost_json",
            "signature": "(request: Request, from_ts: Annotated[datetime, Query(alias='from', description='Start of time window (ISO-8601)')], to_ts: Annotated[datetime, Query(alias='to', description='End of time window (ISO-8601)')], resolution: Annotated[ResolutionType, Query(description='Time resolution: hour or day')] = ResolutionType.DAY, scope: Annotated[ScopeType, Query(description='Aggregation scope: org, project, or env')] = ScopeType.ORG, session: AsyncSession = Depends(get_async_session_dep)) -> CostStatisticsResponse",
            "docstring": "Export cost statistics as JSON.\n\nStructure matches the standard cost response.\nBit-equivalent to read API.",
            "is_async": true,
            "line": 1028
          }
        ],
        "classes": [
          {
            "name": "ResolutionType",
            "docstring": "Time resolution for usage data.",
            "methods": [],
            "line": 73
          },
          {
            "name": "ScopeType",
            "docstring": "Scope of usage aggregation.",
            "methods": [],
            "line": 79
          },
          {
            "name": "TimeWindow",
            "docstring": "Generic time window specification (shared across topics).",
            "methods": [],
            "line": 91
          },
          {
            "name": "UsageWindow",
            "docstring": "Time window specification.",
            "methods": [],
            "line": 106
          },
          {
            "name": "UsageTotals",
            "docstring": "Aggregate usage totals.",
            "methods": [],
            "line": 116
          },
          {
            "name": "UsageDataPoint",
            "docstring": "Single data point in usage time series.",
            "methods": [],
            "line": 123
          },
          {
            "name": "UsageSignals",
            "docstring": "Signal source metadata for provenance.",
            "methods": [],
            "line": 131
          },
          {
            "name": "UsageStatisticsResponse",
            "docstring": "GET /api/v1/analytics/statistics/usage response (contracted).",
            "methods": [],
            "line": 137
          },
          {
            "name": "CostTotals",
            "docstring": "Aggregate cost totals.",
            "methods": [],
            "line": 150
          },
          {
            "name": "CostDataPoint",
            "docstring": "Single data point in cost time series.",
            "methods": [],
            "line": 159
          },
          {
            "name": "CostByModel",
            "docstring": "Cost breakdown by model.",
            "methods": [],
            "line": 168
          },
          {
            "name": "CostByFeature",
            "docstring": "Cost breakdown by feature tag.",
            "methods": [],
            "line": 178
          },
          {
            "name": "CostSignals",
            "docstring": "Signal source metadata for cost provenance.",
            "methods": [],
            "line": 186
          },
          {
            "name": "CostStatisticsResponse",
            "docstring": "GET /api/v1/analytics/statistics/cost response (contracted).",
            "methods": [],
            "line": 192
          },
          {
            "name": "TopicStatus",
            "docstring": "Status of a topic within a subdomain.",
            "methods": [],
            "line": 202
          },
          {
            "name": "AnalyticsStatusResponse",
            "docstring": "GET /api/v1/analytics/_status response.",
            "methods": [],
            "line": 209
          }
        ],
        "imports": [
          {
            "module": "csv",
            "names": [
              "csv"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "io",
            "names": [
              "io"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Dict",
              "List"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "fastapi.responses",
            "names": [
              "Response"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session_dep"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.analytics_facade",
            "names": [
              "get_analytics_facade"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "aos_accounts.py",
        "file_path": "backend/app/hoc/api/cus/policies/aos_accounts.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1277,
        "module_docstring": "Unified Accounts API (L2)\n\nCustomer-facing endpoints for account management: projects, users, profile, billing.\nAll requests are tenant-scoped via auth_context.\n\nIMPORTANT: Account is NOT a domain. It manages:\n- WHO (users, profile)\n- WHAT (projects)\n- BILLING (subscription, invoices)\n\nIt does NOT manage or display:\n- Executions\n- Incidents\n- Policies\n- Logs\n\nEndpoints:\n- GET /api/v1/accounts/projects            \u2192 O2 list projects\n- GET /api/v1/accounts/projects/{id}       \u2192 O3 project detail\n- GET /api/v1/accounts/users               \u2192 O2 list users\n- GET /api/v1/accounts/users/{id}          \u2192 O3 user detail\n- GET /api/v1/accounts/profile             \u2192 Current user profile\n- PUT /api/v1/accounts/profile             \u2192 Update profile\n- GET /api/v1/accounts/billing             \u2192 Billing summary\n- GET /api/v1/accounts/billing/invoices    \u2192 Invoice history\n\nArchitecture:\n- ONE facade for all ACCOUNTS needs\n- Tenant isolation via auth_context (not header)\n- SDSR validates this same production API",
        "functions": [
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 93
          },
          {
            "name": "get_user_id_from_auth",
            "signature": "(request: Request) -> str | None",
            "docstring": "Extract user_id from auth_context. Returns None if not available.",
            "is_async": false,
            "line": 117
          },
          {
            "name": "list_projects",
            "signature": "(request: Request, status: Annotated[Optional[str], Query(description='Filter by status: active, suspended', pattern='^(active|suspended)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max items to return')] = 50, offset: Annotated[int, Query(ge=0, description='Rows to skip')] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> ProjectsListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 287
          },
          {
            "name": "get_project_detail",
            "signature": "(request: Request, project_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> ProjectDetailResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 355
          },
          {
            "name": "list_users",
            "signature": "(request: Request, role: Annotated[Optional[str], Query(description='Filter by role: owner, admin, member, viewer', pattern='^(owner|admin|member|viewer)$')] = None, status: Annotated[Optional[str], Query(description='Filter by status: active, suspended', pattern='^(active|suspended)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max items to return')] = 50, offset: Annotated[int, Query(ge=0, description='Rows to skip')] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> UsersListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 418
          },
          {
            "name": "get_user_detail",
            "signature": "(request: Request, user_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> UserDetailResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 494
          },
          {
            "name": "get_profile",
            "signature": "(request: Request, session: AsyncSession = Depends(get_async_session_dep)) -> ProfileResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 552
          },
          {
            "name": "get_billing_summary",
            "signature": "(request: Request, session: AsyncSession = Depends(get_async_session_dep)) -> BillingSummaryResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 598
          },
          {
            "name": "update_profile",
            "signature": "(request: Request, update: ProfileUpdateRequest, session: AsyncSession = Depends(get_async_session_dep)) -> ProfileUpdateResponse",
            "docstring": "WRITE customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 666
          },
          {
            "name": "get_billing_invoices",
            "signature": "(request: Request, session: AsyncSession = Depends(get_async_session_dep)) -> InvoiceListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 734
          },
          {
            "name": "get_support_contact",
            "signature": "() -> SupportContactResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 828
          },
          {
            "name": "create_support_ticket",
            "signature": "(request: Request, ticket: SupportTicketCreate, session: AsyncSession = Depends(get_async_session_dep)) -> SupportTicketResponse",
            "docstring": "WRITE customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 841
          },
          {
            "name": "list_support_tickets",
            "signature": "(request: Request, status: Optional[str] = Query(None, description='Filter by status'), session: AsyncSession = Depends(get_async_session_dep)) -> SupportTicketListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 884
          },
          {
            "name": "invite_user",
            "signature": "(request: Request, invite: InviteUserRequest, session: AsyncSession = Depends(get_async_session_dep)) -> InvitationResponse",
            "docstring": "WRITE customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 992
          },
          {
            "name": "list_invitations",
            "signature": "(request: Request, status: Optional[str] = Query(None, description='Filter by status'), session: AsyncSession = Depends(get_async_session_dep)) -> InvitationListResponse",
            "docstring": "READ-ONLY customer facade - delegates to L4 AccountsFacade.",
            "is_async": true,
            "line": 1036
          },
          {
            "name": "accept_invitation",
            "signature": "(invitation_id: str, accept: AcceptInvitationRequest, session: AsyncSession = Depends(get_async_session_dep)) -> dict",
            "docstring": "Accept an invitation to join a tenant.\n\nThis is a public endpoint (no auth required) as the user\nmay not have an account yet.\n\nLayer: L2 (Product APIs) \u2014 delegates to L4 AccountsFacade",
            "is_async": true,
            "line": 1088
          },
          {
            "name": "list_tenant_users",
            "signature": "(request: Request, session: AsyncSession = Depends(get_async_session_dep)) -> TenantUserListResponse",
            "docstring": "List users in the current tenant.\n\nLayer: L2 (Product APIs) \u2014 delegates to L4 AccountsFacade",
            "is_async": true,
            "line": 1139
          },
          {
            "name": "update_user_role",
            "signature": "(request: Request, user_id: str, update: UpdateUserRoleRequest, session: AsyncSession = Depends(get_async_session_dep)) -> TenantUserResponse",
            "docstring": "Update a user's role in the tenant.\n\nRequires: owner role.\n\nLayer: L2 (Product APIs) \u2014 delegates to L4 AccountsFacade",
            "is_async": true,
            "line": 1182
          },
          {
            "name": "remove_user",
            "signature": "(request: Request, user_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> dict",
            "docstring": "Remove a user from the tenant.\n\nRequires: owner or admin role.\n\nLayer: L2 (Product APIs) \u2014 delegates to L4 AccountsFacade",
            "is_async": true,
            "line": 1236
          }
        ],
        "classes": [
          {
            "name": "ProjectSummary",
            "docstring": "O2 Result Shape for projects.",
            "methods": [],
            "line": 132
          },
          {
            "name": "ProjectsListResponse",
            "docstring": "GET /projects response (O2).",
            "methods": [],
            "line": 144
          },
          {
            "name": "ProjectDetailResponse",
            "docstring": "GET /projects/{id} response (O3).",
            "methods": [],
            "line": 153
          },
          {
            "name": "UserSummary",
            "docstring": "O2 Result Shape for users.",
            "methods": [],
            "line": 185
          },
          {
            "name": "UsersListResponse",
            "docstring": "GET /users response (O2).",
            "methods": [],
            "line": 197
          },
          {
            "name": "UserDetailResponse",
            "docstring": "GET /users/{id} response (O3).",
            "methods": [],
            "line": 206
          },
          {
            "name": "ProfileResponse",
            "docstring": "GET /profile response.",
            "methods": [],
            "line": 235
          },
          {
            "name": "BillingSummaryResponse",
            "docstring": "GET /billing response.",
            "methods": [],
            "line": 254
          },
          {
            "name": "ProfileUpdateRequest",
            "docstring": "Request to update user profile preferences.",
            "methods": [],
            "line": 646
          },
          {
            "name": "ProfileUpdateResponse",
            "docstring": "Profile update response.",
            "methods": [],
            "line": 654
          },
          {
            "name": "InvoiceSummary",
            "docstring": "Invoice summary for billing history.",
            "methods": [],
            "line": 714
          },
          {
            "name": "InvoiceListResponse",
            "docstring": "List of invoices response.",
            "methods": [],
            "line": 725
          },
          {
            "name": "SupportTicketCreate",
            "docstring": "Create a support ticket.",
            "methods": [],
            "line": 788
          },
          {
            "name": "SupportTicketResponse",
            "docstring": "Support ticket response.",
            "methods": [],
            "line": 797
          },
          {
            "name": "SupportTicketListResponse",
            "docstring": "List of support tickets.",
            "methods": [],
            "line": 812
          },
          {
            "name": "SupportContactResponse",
            "docstring": "Support contact information.",
            "methods": [],
            "line": 819
          },
          {
            "name": "InviteUserRequest",
            "docstring": "Request to invite a user to the tenant.",
            "methods": [],
            "line": 936
          },
          {
            "name": "InvitationResponse",
            "docstring": "Invitation response.",
            "methods": [],
            "line": 943
          },
          {
            "name": "InvitationListResponse",
            "docstring": "List of invitations.",
            "methods": [],
            "line": 955
          },
          {
            "name": "AcceptInvitationRequest",
            "docstring": "Request to accept an invitation.",
            "methods": [],
            "line": 962
          },
          {
            "name": "UpdateUserRoleRequest",
            "docstring": "Request to update a user's role.",
            "methods": [],
            "line": 968
          },
          {
            "name": "TenantUserResponse",
            "docstring": "User in tenant response.",
            "methods": [],
            "line": 974
          },
          {
            "name": "TenantUserListResponse",
            "docstring": "List of users in tenant.",
            "methods": [],
            "line": 984
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session_dep"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.hoc.cus.account.L5_engines.accounts_facade",
            "names": [
              "get_accounts_facade"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.models.tenant",
            "names": [
              "Invitation",
              "Subscription",
              "SupportTicket",
              "Tenant",
              "TenantMembership",
              "User",
              "generate_uuid",
              "utc_now"
            ],
            "is_relative": false,
            "line": 66
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "aos_api_key.py",
        "file_path": "backend/app/hoc/api/cus/policies/aos_api_key.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 272,
        "module_docstring": "API Keys API (L2) - Connectivity Domain\n\nCustomer-facing endpoints for managing API keys.\nAll requests are tenant-scoped via auth_context.\n\nEndpoints:\n- GET /api/v1/api-keys           \u2192 O2 list API keys\n- GET /api/v1/api-keys/{id}      \u2192 O3 API key detail\n\nArchitecture:\n- ONE facade for API KEYS in Connectivity domain\n- Queries APIKey table\n- Tenant isolation via auth_context (not header)\n- SDSR validates this same production API",
        "functions": [
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 67
          },
          {
            "name": "list_api_keys",
            "signature": "(request: Request, status: Annotated[Optional[str], Query(description='Filter by status: active, revoked, expired', pattern='^(active|revoked|expired)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max items to return')] = 50, offset: Annotated[int, Query(ge=0, description='Rows to skip')] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> APIKeysListResponse",
            "docstring": "List API keys. READ-ONLY. Delegates to L4 APIKeysFacade.",
            "is_async": true,
            "line": 158
          },
          {
            "name": "get_api_key_detail",
            "signature": "(request: Request, key_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> APIKeyDetailResponse",
            "docstring": "Get API key detail (O3). Delegates to L4 APIKeysFacade.",
            "is_async": true,
            "line": 228
          }
        ],
        "classes": [
          {
            "name": "APIKeySummary",
            "docstring": "O2 Result Shape for API keys.",
            "methods": [],
            "line": 96
          },
          {
            "name": "APIKeysListResponse",
            "docstring": "GET /api-keys response (O2).",
            "methods": [],
            "line": 109
          },
          {
            "name": "APIKeyDetailResponse",
            "docstring": "GET /api-keys/{id} response (O3).",
            "methods": [],
            "line": 118
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session_dep"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.api_keys.L5_engines.api_keys_facade",
            "names": [
              "get_api_keys_facade"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "aos_cus_integrations.py",
        "file_path": "backend/app/hoc/api/cus/policies/aos_cus_integrations.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 570,
        "module_docstring": "Customer LLM Integration Management API\n\nPURPOSE:\n    CONTROL PLANE for customer LLM integrations. This API manages the lifecycle\n    of integrations - create, update, enable, disable, delete, health checks.\n\nENDPOINTS:\n    CRUD:\n        GET    /integrations           - List integrations (paginated)\n        GET    /integrations/{id}      - Get integration details\n        POST   /integrations           - Create new integration\n        PUT    /integrations/{id}      - Update integration\n        DELETE /integrations/{id}      - Delete integration (soft)\n\n    Lifecycle:\n        POST   /integrations/{id}/enable   - Enable integration\n        POST   /integrations/{id}/disable  - Disable integration\n\n    Health:\n        GET    /integrations/{id}/health   - Get health status\n        POST   /integrations/{id}/test     - Test credentials\n\n    Limits:\n        GET    /integrations/{id}/limits   - Get current usage vs limits\n\nSEMANTIC:\n    - Tenant-isolated: All operations scoped to authenticated tenant\n    - Status lifecycle: created -> enabled -> disabled\n    - Health checks are non-blocking\n    - Soft delete preserves telemetry references\n\nAUTHENTICATION:\n    Uses standard tenant authentication via gateway middleware.",
        "functions": [
          {
            "name": "get_user_id",
            "signature": "(request: Request) -> Optional[str]",
            "docstring": "Extract user_id from authenticated request.",
            "is_async": false,
            "line": 85
          },
          {
            "name": "list_integrations",
            "signature": "(request: Request, offset: int = Query(default=0, ge=0, description='Pagination offset'), limit: int = Query(default=20, ge=1, le=100, description='Page size'), status: Optional[str] = Query(default=None, description='Filter by status'), provider_type: Optional[str] = Query(default=None, description='Filter by provider'))",
            "docstring": "List all integrations for the tenant.\n\nReturns paginated list of integration summaries.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 99
          },
          {
            "name": "get_integration",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Get full details for a specific integration.\n\nIncludes health state, limits configuration, and timestamps.\nDoes NOT include credential_ref or sensitive config.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 147
          },
          {
            "name": "create_integration",
            "signature": "(payload: CusIntegrationCreate, request: Request)",
            "docstring": "Create a new LLM integration.\n\nThe integration starts in 'created' status. Use /enable to activate it.\nDelegates to L4 IntegrationsFacade.\n\nSECURITY:\n    - credential_ref must be a vault reference or encrypted value\n    - Raw API keys are rejected by schema validation",
            "is_async": true,
            "line": 202
          },
          {
            "name": "update_integration",
            "signature": "(integration_id: UUID, payload: CusIntegrationUpdate, request: Request)",
            "docstring": "Update an existing integration.\n\nPartial update - only provided fields are changed.\nStatus changes should use dedicated enable/disable endpoints.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 261
          },
          {
            "name": "delete_integration",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Delete an integration (soft delete).\n\nThe integration is marked as deleted but retained for telemetry references.\nTelemetry data is NOT deleted.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 321
          },
          {
            "name": "enable_integration",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Enable an integration.\n\nTransitions status from 'created' or 'disabled' to 'enabled'.\nSDK can only use enabled integrations.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 358
          },
          {
            "name": "disable_integration",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Disable an integration.\n\nTransitions status to 'disabled'. SDK calls will fail for disabled integrations.\nTelemetry continues to be accepted for in-flight calls.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 396
          },
          {
            "name": "get_integration_health",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Get current health status without running a new check.\n\nReturns cached health state from last check.\nUse POST /test to trigger a fresh health check.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 439
          },
          {
            "name": "test_integration_credentials",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Test integration credentials and update health status.\n\nPerforms a lightweight API call to the provider to verify:\n- Credentials are valid\n- Provider is reachable\n- Rate limits allow access\n\nThis is NON-BLOCKING but may take a few seconds.\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 480
          },
          {
            "name": "get_integration_limits",
            "signature": "(integration_id: UUID, request: Request)",
            "docstring": "Get current usage against configured limits.\n\nReturns budget, token, and rate limit status with percentages.\nUsed by SDK to check limits before making calls (Phase 5).\nDelegates to L4 IntegrationsFacade.",
            "is_async": true,
            "line": 529
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.auth.tenant_resolver",
            "names": [
              "resolve_tenant_id"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.schemas.cus_schemas",
            "names": [
              "CusHealthCheckResponse",
              "CusIntegrationCreate",
              "CusIntegrationResponse",
              "CusIntegrationSummary",
              "CusIntegrationUpdate"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict",
              "wrap_list"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.integrations_facade",
            "names": [
              "get_integrations_facade"
            ],
            "is_relative": false,
            "line": 69
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "billing_dependencies.py",
        "file_path": "backend/app/hoc/api/cus/policies/billing_dependencies.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 192,
        "module_docstring": "Phase-6 Billing Dependencies \u2014 FastAPI Integration\n\nProvides dependencies for accessing billing context in API endpoints.\n\nAPPLICABILITY GATE:\n    Billing is evaluated ONLY when tenant.onboarding_state == COMPLETE.\n    Before COMPLETE, these dependencies return neutral placeholders.\n\nDESIGN INVARIANTS:\n- BILLING-001: Billing never blocks onboarding\n- BILLING-003: Billing state does not affect roles",
        "functions": [
          {
            "name": "get_billing_context",
            "signature": "(request: Request) -> BillingContext",
            "docstring": "FastAPI dependency: Get billing context for current request.\n\nAPPLICABILITY:\n- Returns neutral context if onboarding is not COMPLETE\n- Returns full billing context if onboarding is COMPLETE\n\nUsage:\n    @router.get(\"/billing/status\")\n    async def get_status(billing: BillingContext = Depends(get_billing_context)):\n        return {\"state\": billing.billing_state.value}",
            "is_async": false,
            "line": 69
          },
          {
            "name": "require_billing_active",
            "signature": "(request: Request) -> BillingContext",
            "docstring": "FastAPI dependency: Require billing state allows usage.\n\nRaises HTTP 402 if billing state is SUSPENDED.\n\nUsage:\n    @router.post(\"/runs\")\n    async def create_run(billing: BillingContext = Depends(require_billing_active)):\n        # Billing state is verified to allow usage\n        ...",
            "is_async": false,
            "line": 121
          },
          {
            "name": "check_limit",
            "signature": "(context: BillingContext, limit_name: str, current_value: float) -> Optional[dict]",
            "docstring": "Check if a specific limit is exceeded.\n\nReturns error dict if exceeded, None otherwise.\n\nArgs:\n    context: Billing context\n    limit_name: Name of limit attribute (e.g., \"max_requests_per_day\")\n    current_value: Current usage value\n\nReturns:\n    Error dict if limit exceeded, None otherwise",
            "is_async": false,
            "line": 148
          }
        ],
        "classes": [
          {
            "name": "BillingContext",
            "docstring": "Billing context for a request.\n\nProvides billing state, plan, and limits for the current tenant.\nReturns neutral values if onboarding is not complete.\n\nAttributes:\n    tenant_id: The tenant identifier\n    billing_state: Current billing state (TRIAL if not complete)\n    plan: Current plan (FREE if not complete)\n    limits: Derived limits\n    is_applicable: True if billing logic applies (onboarding complete)",
            "methods": [
              "allows_usage"
            ],
            "line": 41
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "fastapi",
            "names": [
              "Request",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.billing.state",
            "names": [
              "BillingState"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.billing.plan",
            "names": [
              "Plan",
              "DEFAULT_PLAN"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.billing.limits",
            "names": [
              "Limits",
              "DEFAULT_LIMITS"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.billing.provider",
            "names": [
              "get_billing_provider"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.auth.onboarding_state",
            "names": [
              "OnboardingState"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": [
          "BillingContext",
          "get_billing_context",
          "require_billing_active",
          "check_limit"
        ]
      },
      {
        "file_name": "compliance.py",
        "file_path": "backend/app/hoc/api/cus/policies/compliance.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 220,
        "module_docstring": "Compliance API (L2)\n\nProvides compliance verification operations:\n- POST /api/v1/compliance/verify (run verification)\n- GET /api/v1/compliance/reports (list reports)\n- GET /api/v1/compliance/reports/{id} (get report)\n- GET /api/v1/compliance/rules (list rules)\n- GET /api/v1/compliance/rules/{id} (get rule)\n- GET /api/v1/compliance/status (overall status)\n\nThis is the ONLY facade for compliance verification.\nAll compliance APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> ComplianceFacade",
            "docstring": "Get the compliance facade.",
            "is_async": false,
            "line": 70
          },
          {
            "name": "verify_compliance",
            "signature": "(request: VerifyComplianceRequest, ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.verify')))",
            "docstring": "Run compliance verification (GAP-103).\n\n**Tier: PREVENT ($199)** - Compliance verification.\n\nScopes:\n- all: Run all compliance checks\n- data: Data handling compliance\n- policy: Policy enforcement compliance\n- cost: Cost governance compliance\n- security: Security compliance",
            "is_async": true,
            "line": 81
          },
          {
            "name": "list_reports",
            "signature": "(scope: Optional[str] = Query(None, description='Filter by scope'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "List compliance reports.\n\nReturns compliance verification reports for the tenant.",
            "is_async": true,
            "line": 111
          },
          {
            "name": "get_report",
            "signature": "(report_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "Get a specific compliance report.",
            "is_async": true,
            "line": 142
          },
          {
            "name": "list_rules",
            "signature": "(scope: Optional[str] = Query(None, description='Filter by scope'), enabled_only: bool = Query(True, description='Only enabled rules'), ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "List compliance rules.\n\nReturns all compliance rules that are checked during verification.",
            "is_async": true,
            "line": 163
          },
          {
            "name": "get_rule",
            "signature": "(rule_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "Get a specific compliance rule.",
            "is_async": true,
            "line": 187
          },
          {
            "name": "get_compliance_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: ComplianceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('compliance.read')))",
            "docstring": "Get overall compliance status.\n\nReturns the current compliance status including:\n- Overall status (compliant, non_compliant, partially_compliant)\n- Last verification timestamp\n- Rule counts\n- Pending violations",
            "is_async": true,
            "line": 205
          }
        ],
        "classes": [
          {
            "name": "VerifyComplianceRequest",
            "docstring": "Request to run compliance verification.",
            "methods": [],
            "line": 57
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.general.L5_engines.compliance_facade",
            "names": [
              "ComplianceFacade",
              "get_compliance_facade"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "connectors.py",
        "file_path": "backend/app/hoc/api/cus/policies/connectors.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 235,
        "module_docstring": "Connectors API (L2)\n\nProvides connector management operations:\n- GET /api/v1/connectors (list connectors)\n- POST /api/v1/connectors (register connector)\n- GET /api/v1/connectors/{id} (get connector)\n- PUT /api/v1/connectors/{id} (update connector)\n- DELETE /api/v1/connectors/{id} (delete connector)\n- POST /api/v1/connectors/{id}/test (test connector)\n\nThis is the ONLY facade for connector operations.\nAll connector APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> ConnectorsFacade",
            "docstring": "Get the connectors facade.",
            "is_async": false,
            "line": 79
          },
          {
            "name": "list_connectors",
            "signature": "(connector_type: Optional[str] = Query(None, description='Filter by type'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: ConnectorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('connectors.read')))",
            "docstring": "List connectors for the tenant.\n\nReturns all registered connectors with optional filtering.",
            "is_async": true,
            "line": 90
          },
          {
            "name": "register_connector",
            "signature": "(request: RegisterConnectorRequest, ctx: TenantContext = Depends(get_tenant_context), facade: ConnectorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('connectors.write')))",
            "docstring": "Register a new connector.\n\nSupported types:\n- http: REST/HTTP APIs\n- sql: SQL databases\n- mcp: Model Context Protocol servers\n- vector: Vector databases\n- file: File storage\n- serverless: Serverless functions",
            "is_async": true,
            "line": 121
          },
          {
            "name": "get_connector",
            "signature": "(connector_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: ConnectorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('connectors.read')))",
            "docstring": "Get a specific connector by ID.",
            "is_async": true,
            "line": 151
          },
          {
            "name": "update_connector",
            "signature": "(connector_id: str, request: UpdateConnectorRequest, ctx: TenantContext = Depends(get_tenant_context), facade: ConnectorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('connectors.write')))",
            "docstring": "Update a connector.",
            "is_async": true,
            "line": 172
          },
          {
            "name": "delete_connector",
            "signature": "(connector_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: ConnectorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('connectors.write')))",
            "docstring": "Delete a connector.",
            "is_async": true,
            "line": 198
          },
          {
            "name": "test_connector",
            "signature": "(connector_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: ConnectorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('connectors.test')))",
            "docstring": "Test a connector connection.\n\nAttempts to establish a connection and returns the result.",
            "is_async": true,
            "line": 219
          }
        ],
        "classes": [
          {
            "name": "RegisterConnectorRequest",
            "docstring": "Request to register a new connector.",
            "methods": [],
            "line": 57
          },
          {
            "name": "UpdateConnectorRequest",
            "docstring": "Request to update a connector.",
            "methods": [],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.connectors_facade",
            "names": [
              "ConnectorsFacade",
              "get_connectors_facade"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "controls.py",
        "file_path": "backend/app/hoc/api/cus/policies/controls.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 219,
        "module_docstring": "Controls API (L2)\n\nProvides control operations:\n- GET /api/v1/controls (list controls)\n- GET /api/v1/controls/status (overall status)\n- GET /api/v1/controls/{id} (get control)\n- PUT /api/v1/controls/{id} (update control)\n- POST /api/v1/controls/{id}/enable (enable control)\n- POST /api/v1/controls/{id}/disable (disable control)\n\nThis is the ONLY facade for control operations.\nAll controls APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> ControlsFacade",
            "docstring": "Get the controls facade.",
            "is_async": false,
            "line": 70
          },
          {
            "name": "list_controls",
            "signature": "(control_type: Optional[str] = Query(None, description='Filter by type'), state: Optional[str] = Query(None, description='Filter by state'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: ControlsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('controls.read')))",
            "docstring": "List controls (GAP-123).\n\nReturns all controls for the tenant.",
            "is_async": true,
            "line": 81
          },
          {
            "name": "get_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: ControlsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('controls.read')))",
            "docstring": "Get overall control status.\n\nReturns summary including killswitch and maintenance mode state.",
            "is_async": true,
            "line": 112
          },
          {
            "name": "get_control",
            "signature": "(control_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: ControlsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('controls.read')))",
            "docstring": "Get a specific control.",
            "is_async": true,
            "line": 128
          },
          {
            "name": "update_control",
            "signature": "(control_id: str, request: UpdateControlRequest, ctx: TenantContext = Depends(get_tenant_context), facade: ControlsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('controls.write')))",
            "docstring": "Update a control.",
            "is_async": true,
            "line": 149
          },
          {
            "name": "enable_control",
            "signature": "(control_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: ControlsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('controls.admin')))",
            "docstring": "Enable a control.\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 173
          },
          {
            "name": "disable_control",
            "signature": "(control_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: ControlsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('controls.admin')))",
            "docstring": "Disable a control.\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 198
          }
        ],
        "classes": [
          {
            "name": "UpdateControlRequest",
            "docstring": "Request to update a control.",
            "methods": [],
            "line": 59
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.controls.L5_engines.controls_facade",
            "names": [
              "ControlsFacade",
              "get_controls_facade"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_enforcement.py",
        "file_path": "backend/app/hoc/api/cus/policies/cus_enforcement.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 222,
        "module_docstring": "Customer LLM Enforcement API\n\nPURPOSE:\n    API endpoints for enforcement policy evaluation.\n    SDK calls these endpoints before making LLM calls.\n\nENDPOINTS:\n    POST   /enforcement/check    - Pre-flight enforcement check\n    GET    /enforcement/status   - Get current limits and usage\n    POST   /enforcement/batch    - Batch pre-flight checks\n\nSEMANTIC:\n    - Tenant-isolated: All operations scoped to authenticated tenant\n    - Read-only: These endpoints evaluate policies, they don't change them\n    - Idempotent: Same request always produces same decision (given same state)\n\nAUTHENTICATION:\n    Uses standard tenant authentication via gateway middleware.\n    SDK uses X-AOS-Key header.",
        "functions": [
          {
            "name": "get_enforcement_service",
            "signature": "() -> CusEnforcementService",
            "docstring": "Dependency to get enforcement service instance.",
            "is_async": false,
            "line": 78
          },
          {
            "name": "get_tenant_id",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from authenticated request.",
            "is_async": false,
            "line": 83
          },
          {
            "name": "check_enforcement",
            "signature": "(payload: EnforcementCheckRequest, request: Request, service: CusEnforcementService = Depends(get_enforcement_service))",
            "docstring": "Check enforcement policy before making an LLM call.\n\nThis is the primary endpoint for SDK pre-flight checks. Returns a decision\nthat tells the SDK whether to proceed, warn, throttle, or block.\n\nThe decision includes:\n- result: allowed, warned, throttled, blocked, hard_blocked\n- reasons: Explainability data for why the decision was made\n- degraded: True if decision made with incomplete telemetry\n\nIMPORTANT: This endpoint is read-only and idempotent. Calling it multiple\ntimes with the same state will produce the same result.",
            "is_async": true,
            "line": 105
          },
          {
            "name": "get_enforcement_status",
            "signature": "(request: Request, integration_id: str = Query(..., description='Integration ID'), service: CusEnforcementService = Depends(get_enforcement_service))",
            "docstring": "Get current enforcement status for an integration.\n\nReturns current limits, usage, and remaining allowances. Useful for\ndisplaying in dashboards or for SDK to show users their current state.\n\nDoes NOT make an enforcement decision - use /check for that.",
            "is_async": true,
            "line": 155
          },
          {
            "name": "batch_enforcement_check",
            "signature": "(payload: EnforcementBatchRequest, request: Request, service: CusEnforcementService = Depends(get_enforcement_service))",
            "docstring": "Check enforcement for multiple requests at once.\n\nUseful for batch operations or when making multiple calls in sequence.\nReturns decisions in the same order as the requests.",
            "is_async": true,
            "line": 188
          }
        ],
        "classes": [
          {
            "name": "EnforcementCheckRequest",
            "docstring": "Request for enforcement check.",
            "methods": [],
            "line": 53
          },
          {
            "name": "EnforcementBatchRequest",
            "docstring": "Request for batch enforcement check.",
            "methods": [],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "List"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict",
              "wrap_list"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.cus_enforcement_service",
            "names": [
              "CusEnforcementService"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "customer_visibility.py",
        "file_path": "backend/app/hoc/api/cus/policies/customer_visibility.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 707,
        "module_docstring": "Phase 4C-2: Customer Visibility Endpoints\n\nCustomer-facing endpoints for predictability and accountability.\n\nRules:\n- Show effects, not mechanics\n- No decision records exposed\n- No governance internals\n- Predictability before execution\n- Accountability after execution",
        "functions": [
          {
            "name": "get_db_url",
            "signature": "() -> Optional[str]",
            "docstring": "Get database URL from environment.",
            "is_async": false,
            "line": 195
          },
          {
            "name": "get_budget_mode",
            "signature": "() -> BudgetDeclaration",
            "docstring": "Determine budget enforcement mode from configuration.",
            "is_async": false,
            "line": 200
          },
          {
            "name": "get_policy_posture",
            "signature": "(strict_mode: bool = False) -> PolicyDeclaration",
            "docstring": "Determine policy posture from configuration.",
            "is_async": false,
            "line": 221
          },
          {
            "name": "get_memory_mode",
            "signature": "() -> MemoryDeclaration",
            "docstring": "Determine memory mode from configuration.",
            "is_async": false,
            "line": 237
          },
          {
            "name": "estimate_stages",
            "signature": "(agent_id: str, goal: str) -> List[StageDeclaration]",
            "docstring": "Estimate execution stages based on agent capabilities.\n\nThis is a simplified version - in production, this would\ncall the planner to generate a real plan.",
            "is_async": false,
            "line": 253
          },
          {
            "name": "estimate_cost",
            "signature": "(agent_id: str, goal: str, stages: List[StageDeclaration]) -> CostDeclaration",
            "docstring": "Estimate cost based on stages and historical data.",
            "is_async": false,
            "line": 273
          },
          {
            "name": "fetch_run_outcome",
            "signature": "(run_id: str, tenant_id: str) -> Optional[Dict[str, Any]]",
            "docstring": "Fetch run data for outcome reconciliation.\n\nArgs:\n    run_id: Run ID to fetch\n    tenant_id: Tenant ID for access control (PIN-052 audit fix)\n\nReturns:\n    Run data dict or None if not found/unauthorized",
            "is_async": false,
            "line": 297
          },
          {
            "name": "fetch_decision_summary",
            "signature": "(run_id: str, tenant_id: str) -> Dict[str, Any]",
            "docstring": "Fetch decision summary for outcome reconciliation.\n\nReturns EFFECTS only, not decision details.\n\nArgs:\n    run_id: Run ID to fetch decisions for\n    tenant_id: Tenant ID for access control (PIN-052 audit fix)",
            "is_async": false,
            "line": 350
          },
          {
            "name": "get_pre_run_declaration",
            "signature": "(agent_id: str, goal: str, strict_mode: bool = False, _: str = Depends(verify_api_key)) -> PreRunDeclaration",
            "docstring": "Get PRE-RUN declaration before execution.\n\nReturns all information needed for customer to make an informed decision:\n- Stages that will execute (ordered)\n- Estimated cost range\n- Budget enforcement mode\n- Policy posture\n- Memory mode\n\nCustomer must acknowledge before execution can proceed.",
            "is_async": true,
            "line": 438
          },
          {
            "name": "acknowledge_declaration",
            "signature": "(request: AcknowledgementRequest, _: str = Depends(verify_api_key)) -> AcknowledgementResponse",
            "docstring": "Acknowledge PRE-RUN declaration.\n\nCustomer must acknowledge to proceed with execution.\nThis creates an audit trail of informed consent.",
            "is_async": true,
            "line": 504
          },
          {
            "name": "get_outcome_reconciliation",
            "signature": "(run_id: str, request: Request, _: str = Depends(verify_api_key)) -> OutcomeReconciliation",
            "docstring": "Get outcome reconciliation after execution.\n\nReturns decomposed results (never a single success flag):\n- Task completion status\n- Budget usage status\n- Policy compliance status\n- Recovery status",
            "is_async": true,
            "line": 560
          },
          {
            "name": "get_declaration",
            "signature": "(declaration_id: str, _: str = Depends(verify_api_key)) -> PreRunDeclaration",
            "docstring": "Retrieve a previously created PRE-RUN declaration.",
            "is_async": true,
            "line": 697
          }
        ],
        "classes": [
          {
            "name": "StageDeclaration",
            "docstring": "Single stage in the execution plan.",
            "methods": [],
            "line": 43
          },
          {
            "name": "CostDeclaration",
            "docstring": "Cost expectations before execution.",
            "methods": [],
            "line": 51
          },
          {
            "name": "BudgetDeclaration",
            "docstring": "Budget enforcement mode.",
            "methods": [],
            "line": 60
          },
          {
            "name": "PolicyDeclaration",
            "docstring": "Policy posture declaration.",
            "methods": [],
            "line": 68
          },
          {
            "name": "MemoryDeclaration",
            "docstring": "Memory mode declaration.",
            "methods": [],
            "line": 76
          },
          {
            "name": "EstimationMethodology",
            "docstring": "PIN-254 Phase C Fix (C3 Partial Truth): Explicit disclosure of estimation basis.\n\nEnsures API consumers know whether estimates are derived from:\n- Real planner output (planner_v1)\n- Hardcoded defaults (default_stages_v1)\n- Historical data (historical_avg)",
            "methods": [],
            "line": 83
          },
          {
            "name": "PreRunDeclaration",
            "docstring": "Complete PRE-RUN declaration for customer visibility.\n\nThis is what the customer sees BEFORE execution starts.\nExecution cannot proceed without acknowledgement.",
            "methods": [],
            "line": 99
          },
          {
            "name": "AcknowledgementRequest",
            "docstring": "Customer acknowledgement of PRE-RUN declaration.",
            "methods": [],
            "line": 134
          },
          {
            "name": "AcknowledgementResponse",
            "docstring": "Response after acknowledgement.",
            "methods": [],
            "line": 141
          },
          {
            "name": "OutcomeItem",
            "docstring": "Single outcome item.",
            "methods": [],
            "line": 155
          },
          {
            "name": "OutcomeReconciliation",
            "docstring": "Complete outcome reconciliation for customer visibility.\n\nThis is what the customer sees AFTER execution completes.\nDecomposed results, never a single success flag.",
            "methods": [],
            "line": 163
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "sqlalchemy",
            "names": [
              "create_engine",
              "text"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "sqlalchemy.exc",
            "names": [
              "SQLAlchemyError"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "app.auth",
            "names": [
              "verify_api_key"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.middleware.tenancy",
            "names": [
              "get_tenant_id"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "datasources.py",
        "file_path": "backend/app/hoc/api/cus/policies/datasources.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 305,
        "module_docstring": "DataSources API (L2)\n\nProvides data source operations:\n- POST /api/v1/datasources (create source)\n- GET /api/v1/datasources (list sources)\n- GET /api/v1/datasources/{id} (get source)\n- PUT /api/v1/datasources/{id} (update source)\n- DELETE /api/v1/datasources/{id} (delete source)\n- POST /api/v1/datasources/{id}/test (test connection)\n- POST /api/v1/datasources/{id}/activate (activate source)\n- POST /api/v1/datasources/{id}/deactivate (deactivate source)\n- GET /api/v1/datasources/stats (statistics)\n\nThis is the ONLY facade for data source operations.\nAll data source APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> DataSourcesFacade",
            "docstring": "Get the datasources facade.",
            "is_async": false,
            "line": 83
          },
          {
            "name": "create_source",
            "signature": "(request: CreateSourceRequest, ctx: TenantContext = Depends(get_tenant_context), facade: DataSourcesFacade = Depends(get_facade), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Create a data source (GAP-113).\n\n**Tier: REACT ($9)** - Data source management.\n\nSource types:\n- database: Relational databases (PostgreSQL, MySQL, etc.)\n- file: File storage (S3, GCS, local)\n- api: REST/GraphQL APIs\n- vector: Vector databases (Pinecone, Weaviate)\n- stream: Streaming sources (Kafka, etc.)\n- custom: Custom connectors",
            "is_async": true,
            "line": 94
          },
          {
            "name": "list_sources",
            "signature": "(source_type: Optional[str] = Query(None, description='Filter by type'), status: Optional[str] = Query(None, description='Filter by status'), tag: Optional[str] = Query(None, description='Filter by tag'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: DataSourcesFacade = Depends(get_facade), _tier: None = Depends(requires_feature('datasources.read')))",
            "docstring": "List data sources.",
            "is_async": true,
            "line": 127
          },
          {
            "name": "get_statistics",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: DataSourcesFacade = Depends(get_facade), _tier: None = Depends(requires_feature('datasources.read')))",
            "docstring": "Get data source statistics.",
            "is_async": true,
            "line": 158
          },
          {
            "name": "get_source",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: DataSourcesFacade = Depends(get_facade), _tier: None = Depends(requires_feature('datasources.read')))",
            "docstring": "Get a specific data source.",
            "is_async": true,
            "line": 172
          },
          {
            "name": "update_source",
            "signature": "(source_id: str, request: UpdateSourceRequest, ctx: TenantContext = Depends(get_tenant_context), facade: DataSourcesFacade = Depends(get_facade), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Update a data source.",
            "is_async": true,
            "line": 193
          },
          {
            "name": "delete_source",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: DataSourcesFacade = Depends(get_facade), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Delete a data source.",
            "is_async": true,
            "line": 219
          },
          {
            "name": "test_connection",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: DataSourcesFacade = Depends(get_facade), _tier: None = Depends(requires_feature('datasources.test')))",
            "docstring": "Test a data source connection.\n\nVerifies that the data source can be reached with the current configuration.",
            "is_async": true,
            "line": 240
          },
          {
            "name": "activate_source",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: DataSourcesFacade = Depends(get_facade), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Activate a data source.\n\nMakes the data source available for use.",
            "is_async": true,
            "line": 263
          },
          {
            "name": "deactivate_source",
            "signature": "(source_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: DataSourcesFacade = Depends(get_facade), _tier: None = Depends(requires_feature('datasources.write')))",
            "docstring": "Deactivate a data source.\n\nTemporarily disables the data source.",
            "is_async": true,
            "line": 286
          }
        ],
        "classes": [
          {
            "name": "CreateSourceRequest",
            "docstring": "Request to create a data source.",
            "methods": [],
            "line": 60
          },
          {
            "name": "UpdateSourceRequest",
            "docstring": "Request to update a data source.",
            "methods": [],
            "line": 70
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.datasources_facade",
            "names": [
              "DataSourcesFacade",
              "get_datasources_facade"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "detection.py",
        "file_path": "backend/app/hoc/api/cus/policies/detection.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 244,
        "module_docstring": "Detection API (L2)\n\nProvides anomaly detection operations:\n- POST /api/v1/detection/run (run detection on demand)\n- GET /api/v1/detection/anomalies (list anomalies)\n- GET /api/v1/detection/anomalies/{id} (get anomaly)\n- POST /api/v1/detection/anomalies/{id}/resolve (resolve anomaly)\n- POST /api/v1/detection/anomalies/{id}/acknowledge (acknowledge anomaly)\n- GET /api/v1/detection/status (detection engine status)\n\nThis is the ONLY facade for anomaly detection operations.\nAll detection APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> DetectionFacade",
            "docstring": "Get the detection facade.",
            "is_async": false,
            "line": 79
          },
          {
            "name": "run_detection",
            "signature": "(request: RunDetectionRequest, ctx: TenantContext = Depends(get_tenant_context), facade: DetectionFacade = Depends(get_facade), _tier: None = Depends(requires_feature('detection.run')))",
            "docstring": "Run anomaly detection on demand (GAP-102).\n\n**Tier: REACT ($9)** - Anomaly detection.\n\nDetection types:\n- cost: Cost anomalies (spikes, drift, budget issues)\n- behavioral: Behavioral anomalies (pattern changes)\n- drift: Model/data drift detection\n\nReturns detection results including anomalies found and incidents created.",
            "is_async": true,
            "line": 90
          },
          {
            "name": "list_anomalies",
            "signature": "(detection_type: Optional[str] = Query(None, description='Filter by type'), severity: Optional[str] = Query(None, description='Filter by severity'), status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: DetectionFacade = Depends(get_facade), _tier: None = Depends(requires_feature('detection.read')))",
            "docstring": "List anomalies for the tenant.\n\nReturns detected anomalies with optional filtering.",
            "is_async": true,
            "line": 120
          },
          {
            "name": "get_anomaly",
            "signature": "(anomaly_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: DetectionFacade = Depends(get_facade), _tier: None = Depends(requires_feature('detection.read')))",
            "docstring": "Get a specific anomaly by ID.",
            "is_async": true,
            "line": 153
          },
          {
            "name": "resolve_anomaly",
            "signature": "(anomaly_id: str, request: ResolveAnomalyRequest, ctx: TenantContext = Depends(get_tenant_context), facade: DetectionFacade = Depends(get_facade), _tier: None = Depends(requires_feature('detection.resolve')))",
            "docstring": "Resolve an anomaly.\n\nResolution options:\n- resolved: Anomaly has been addressed\n- dismissed: Anomaly is not actionable (false positive)",
            "is_async": true,
            "line": 174
          },
          {
            "name": "acknowledge_anomaly",
            "signature": "(anomaly_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: DetectionFacade = Depends(get_facade), _tier: None = Depends(requires_feature('detection.acknowledge')))",
            "docstring": "Acknowledge an anomaly.\n\nMarks the anomaly as seen but not yet resolved.",
            "is_async": true,
            "line": 205
          },
          {
            "name": "get_detection_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: DetectionFacade = Depends(get_facade))",
            "docstring": "Get detection engine status.\n\nReturns health status of detection engines:\n- cost: Cost anomaly detector\n- behavioral: Behavioral pattern detector\n- drift: Model/data drift detector",
            "is_async": true,
            "line": 231
          }
        ],
        "classes": [
          {
            "name": "RunDetectionRequest",
            "docstring": "Request to run anomaly detection.",
            "methods": [],
            "line": 57
          },
          {
            "name": "ResolveAnomalyRequest",
            "docstring": "Request to resolve an anomaly.",
            "methods": [],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.detection_facade",
            "names": [
              "DetectionFacade",
              "get_detection_facade"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "evidence.py",
        "file_path": "backend/app/hoc/api/cus/policies/evidence.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 299,
        "module_docstring": "Evidence API (L2)\n\nProvides evidence chain and export operations:\n- GET /api/v1/evidence/chains (list chains)\n- POST /api/v1/evidence/chains (create chain)\n- GET /api/v1/evidence/chains/{id} (get chain)\n- POST /api/v1/evidence/chains/{id}/evidence (add evidence)\n- GET /api/v1/evidence/chains/{id}/verify (verify chain)\n- POST /api/v1/evidence/export (create export)\n- GET /api/v1/evidence/exports (list exports)\n- GET /api/v1/evidence/exports/{id} (get export)\n\nThis is the ONLY facade for evidence operations.\nAll evidence APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> EvidenceFacade",
            "docstring": "Get the evidence facade.",
            "is_async": false,
            "line": 88
          },
          {
            "name": "list_chains",
            "signature": "(run_id: Optional[str] = Query(None, description='Filter by run'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: EvidenceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('evidence.read')))",
            "docstring": "List evidence chains.\n\nReturns evidence chains for the tenant.",
            "is_async": true,
            "line": 99
          },
          {
            "name": "create_chain",
            "signature": "(request: CreateChainRequest, ctx: TenantContext = Depends(get_tenant_context), facade: EvidenceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('evidence.write')))",
            "docstring": "Create an evidence chain (GAP-104).\n\n**Tier: REACT ($9)** - Evidence chain creation.\n\nCreates a new evidence chain, optionally with initial evidence.",
            "is_async": true,
            "line": 128
          },
          {
            "name": "get_chain",
            "signature": "(chain_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: EvidenceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('evidence.read')))",
            "docstring": "Get a specific evidence chain.",
            "is_async": true,
            "line": 151
          },
          {
            "name": "add_evidence",
            "signature": "(chain_id: str, request: AddEvidenceRequest, ctx: TenantContext = Depends(get_tenant_context), facade: EvidenceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('evidence.write')))",
            "docstring": "Add evidence to a chain.\n\nEvidence types:\n- execution: Run execution evidence\n- retrieval: Data retrieval evidence\n- policy: Policy decision evidence\n- cost: Cost event evidence\n- incident: Incident evidence",
            "is_async": true,
            "line": 172
          },
          {
            "name": "verify_chain",
            "signature": "(chain_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: EvidenceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('evidence.verify')))",
            "docstring": "Verify chain integrity.\n\nVerifies that all links in the chain have valid hashes\nand proper linkage.",
            "is_async": true,
            "line": 203
          },
          {
            "name": "create_export",
            "signature": "(request: CreateExportRequest, ctx: TenantContext = Depends(get_tenant_context), facade: EvidenceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('evidence.export')))",
            "docstring": "Create evidence export (GAP-105).\n\n**Tier: PREVENT ($199)** - Evidence export.\n\nExport formats:\n- json: JSON format with full chain data\n- csv: CSV format for spreadsheet import\n- pdf: PDF format for compliance reports",
            "is_async": true,
            "line": 229
          },
          {
            "name": "list_exports",
            "signature": "(chain_id: Optional[str] = Query(None, description='Filter by chain'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: EvidenceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('evidence.read')))",
            "docstring": "List evidence exports.",
            "is_async": true,
            "line": 255
          },
          {
            "name": "get_export",
            "signature": "(export_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: EvidenceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('evidence.read')))",
            "docstring": "Get export status.",
            "is_async": true,
            "line": 282
          }
        ],
        "classes": [
          {
            "name": "CreateChainRequest",
            "docstring": "Request to create evidence chain.",
            "methods": [],
            "line": 59
          },
          {
            "name": "AddEvidenceRequest",
            "docstring": "Request to add evidence to chain.",
            "methods": [],
            "line": 68
          },
          {
            "name": "CreateExportRequest",
            "docstring": "Request to create evidence export.",
            "methods": [],
            "line": 77
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.logs.L5_engines.evidence_facade",
            "names": [
              "EvidenceFacade",
              "get_evidence_facade"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "governance.py",
        "file_path": "backend/app/hoc/api/cus/policies/governance.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 290,
        "module_docstring": "Governance API (L2)\n\nProvides governance control operations:\n- POST /api/v1/governance/kill-switch (GAP-090)\n- POST /api/v1/governance/mode (GAP-091)\n- POST /api/v1/governance/resolve-conflict (GAP-092)\n- GET /api/v1/governance/boot-status (GAP-095)\n- GET /api/v1/governance/state\n\nThis is the ONLY facade for governance control operations.\nAll governance APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> GovernanceFacade",
            "docstring": "Get the governance facade.",
            "is_async": false,
            "line": 111
          },
          {
            "name": "get_governance_state",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: GovernanceFacade = Depends(get_facade))",
            "docstring": "Get current governance state.\n\nReturns the current governance mode, whether enforcement is active,\nand details about the last state change.",
            "is_async": true,
            "line": 122
          },
          {
            "name": "toggle_kill_switch",
            "signature": "(request: KillSwitchRequest, ctx: TenantContext = Depends(get_tenant_context), facade: GovernanceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('governance.kill_switch')))",
            "docstring": "Toggle the governance kill switch (GAP-090).\n\n**Tier: REACT ($9)** - Emergency governance control.\n\nWARNING: Enabling the kill switch disables ALL governance enforcement.\nThis is an emergency operation for incident response only.\n\n- enabled=true: Disable governance (emergency kill switch ON)\n- enabled=false: Re-enable governance (kill switch OFF)",
            "is_async": true,
            "line": 137
          },
          {
            "name": "set_governance_mode",
            "signature": "(request: ModeRequest, ctx: TenantContext = Depends(get_tenant_context), facade: GovernanceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('governance.mode')))",
            "docstring": "Set governance mode (GAP-091).\n\n**Tier: REACT ($9)** - Emergency governance control.\n\nModes:\n- NORMAL: Full governance enforcement\n- DEGRADED: Limited enforcement, new runs blocked\n- KILL: All governance disabled (emergency)",
            "is_async": true,
            "line": 174
          },
          {
            "name": "resolve_conflict",
            "signature": "(request: ConflictResolutionRequest, ctx: TenantContext = Depends(get_tenant_context), facade: GovernanceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('governance.resolve_conflict')))",
            "docstring": "Manually resolve a policy conflict (GAP-092).\n\n**Tier: PREVENT ($199)** - Policy management.\n\nResolution strategies:\n- accept_first: Accept the first policy in the conflict\n- accept_second: Accept the second policy in the conflict\n- merge: Attempt to merge conflicting policies\n- defer: Defer resolution to later",
            "is_async": true,
            "line": 216
          },
          {
            "name": "list_conflicts",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), status: Optional[str] = Query(None, description='Filter by status'), ctx: TenantContext = Depends(get_tenant_context), facade: GovernanceFacade = Depends(get_facade), _tier: None = Depends(requires_feature('governance.read')))",
            "docstring": "List policy conflicts.\n\nReturns pending and resolved policy conflicts.",
            "is_async": true,
            "line": 252
          },
          {
            "name": "get_boot_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: GovernanceFacade = Depends(get_facade))",
            "docstring": "Get SPINE component health status (GAP-095).\n\nReturns health status of core governance components:\n- governance: Kill switch state\n- policy_engine: Policy evaluation engine\n- audit_store: Audit event storage\n- policy_facade: Policy facade availability",
            "is_async": true,
            "line": 276
          }
        ],
        "classes": [
          {
            "name": "KillSwitchRequest",
            "docstring": "Request to toggle kill switch.",
            "methods": [],
            "line": 58
          },
          {
            "name": "ModeRequest",
            "docstring": "Request to set governance mode.",
            "methods": [],
            "line": 64
          },
          {
            "name": "ConflictResolutionRequest",
            "docstring": "Request to resolve a policy conflict.",
            "methods": [],
            "line": 70
          },
          {
            "name": "GovernanceStateResponse",
            "docstring": "Governance state response.",
            "methods": [],
            "line": 77
          },
          {
            "name": "KillSwitchResponse",
            "docstring": "Kill switch operation response.",
            "methods": [],
            "line": 87
          },
          {
            "name": "BootStatusResponse",
            "docstring": "Boot status response.",
            "methods": [],
            "line": 98
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.governance_facade",
            "names": [
              "GovernanceFacade",
              "GovernanceMode",
              "get_governance_facade"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard.py",
        "file_path": "backend/app/hoc/api/cus/policies/guard.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 2220,
        "module_docstring": "Guard API - Customer Console Backend\n\nThis router provides endpoints for the Customer Console (guard.agenticverz.com).\nFocused on TRUST and CONTROL - customers can see what's protecting them and stop it if needed.\n\nEndpoints:\n- GET  /guard/status          - Protection status (am I safe?)\n- GET  /guard/snapshot/today  - Today's metrics\n- POST /guard/killswitch/activate   - Stop all traffic\n- POST /guard/killswitch/deactivate - Resume traffic\n- GET  /guard/incidents       - List incidents\n- GET  /guard/incidents/{id}  - Incident detail with timeline\n- POST /guard/incidents/{id}/acknowledge - Acknowledge incident\n- POST /guard/incidents/{id}/resolve     - Resolve incident\n- POST /guard/replay/{call_id} - Replay a call\n- GET  /guard/keys            - List API keys\n- POST /guard/keys/{id}/freeze   - Freeze key\n- POST /guard/keys/{id}/unfreeze - Unfreeze key\n- GET  /guard/settings        - Read-only settings",
        "functions": [
          {
            "name": "utc_now",
            "signature": "() -> datetime",
            "docstring": null,
            "is_async": false,
            "line": 285
          },
          {
            "name": "get_tenant_from_auth",
            "signature": "(session: Session, tenant_id: str) -> Tenant",
            "docstring": "Get tenant or raise 404.",
            "is_async": false,
            "line": 289
          },
          {
            "name": "get_guard_status",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "Get protection status - \"Am I safe right now?\"\n\nReturns:\n- Freeze state\n- Active guardrails\n- 24h incident count\n- Last incident time\n\nCached for 5 seconds to reduce cross-region DB latency.",
            "is_async": true,
            "line": 305
          },
          {
            "name": "get_today_snapshot",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "Get today's metrics - \"What did it cost/save me?\"\n\nCached for 10 seconds to reduce cross-region DB latency.",
            "is_async": true,
            "line": 373
          },
          {
            "name": "activate_killswitch",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "Stop all traffic - Emergency kill switch.\n\nImmediate. All requests blocked until manually resumed.\n\nPIN-281: Uses L3 CustomerKillswitchAdapter for tenant-scoped operations.",
            "is_async": true,
            "line": 439
          },
          {
            "name": "deactivate_killswitch",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "Resume traffic - Deactivate kill switch.\n\nGuardrails will continue protecting.\n\nPIN-281: Uses L3 CustomerKillswitchAdapter for tenant-scoped operations.",
            "is_async": true,
            "line": 468
          },
          {
            "name": "list_incidents",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), limit: int = Query(default=50, le=100), offset: int = Query(default=0), session: Session = Depends(get_session))",
            "docstring": "List incidents - \"What did you stop for me?\"\n\nHuman narrative, not logs.\n\nPIN-281: Uses L3 CustomerIncidentsAdapter for tenant-scoped operations.",
            "is_async": true,
            "line": 499
          },
          {
            "name": "get_incident_detail",
            "signature": "(incident_id: str, tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "Get incident detail with timeline.\n\nOne-screen explanation readable at 2am.\n\nPIN-281: Uses L3 CustomerIncidentsAdapter with tenant isolation.",
            "is_async": true,
            "line": 545
          },
          {
            "name": "acknowledge_incident",
            "signature": "(incident_id: str, tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "Acknowledge an incident.\n\nPIN-281: Uses L3 CustomerIncidentsAdapter with tenant isolation.",
            "is_async": true,
            "line": 599
          },
          {
            "name": "resolve_incident",
            "signature": "(incident_id: str, tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "Resolve an incident.\n\nPIN-281: Uses L3 CustomerIncidentsAdapter with tenant isolation.",
            "is_async": true,
            "line": 620
          },
          {
            "name": "get_customer_incident_narrative",
            "signature": "(incident_id: str, token: CustomerToken = Depends(verify_console_token), session: Session = Depends(get_session)) -> CustomerIncidentNarrativeDTO",
            "docstring": "GET /guard/incidents/{id}/narrative\n\nCustomer Incident Narrative - Calm, reassuring summary.\n\nM29 Category 5: Incident Console Contrast\n\nAnswers:\n- What happened? (plain language)\n- Did it affect me? (yes/no/some)\n- Is it fixed? (status + message)\n- Do I need to act? (only if necessary)\n\nIMPORTANT: Uses CALM vocabulary only.\n- No internal terminology (policy names, thresholds)\n- No cross-tenant data\n- No raw metrics that could cause panic",
            "is_async": true,
            "line": 646
          },
          {
            "name": "_generate_plain_title",
            "signature": "(incident: Incident) -> str",
            "docstring": "Generate plain language title - no internal terminology.",
            "is_async": false,
            "line": 709
          },
          {
            "name": "_generate_calm_summary",
            "signature": "(incident: Incident) -> str",
            "docstring": "Generate calm, reassuring summary - no internal terms.",
            "is_async": false,
            "line": 726
          },
          {
            "name": "_build_customer_impact",
            "signature": "(incident: Incident) -> CustomerIncidentImpactDTO",
            "docstring": "Build impact assessment with calm vocabulary.",
            "is_async": false,
            "line": 749
          },
          {
            "name": "_build_customer_resolution",
            "signature": "(incident: Incident) -> CustomerIncidentResolutionDTO",
            "docstring": "Build resolution status with reassuring message.",
            "is_async": false,
            "line": 785
          },
          {
            "name": "_build_customer_actions",
            "signature": "(incident: Incident) -> list",
            "docstring": "Build customer actions - only if necessary.",
            "is_async": false,
            "line": 817
          },
          {
            "name": "replay_call",
            "signature": "(call_id: str, level: str = Query('logical', description='Determinism level: strict, logical, or semantic'), session: Session = Depends(get_session), auth: AuthorityResult = Depends(require_replay_execute))",
            "docstring": "Replay a call - Trust builder.\n\nM23: Uses real ReplayValidator from replay_determinism.py\n\nDeterminism Levels:\n- strict: Byte-for-byte exact match (only works for cached/local)\n- logical: Policy decision equivalence (default - proves guardrails work)\n- semantic: Meaning-equivalent match (for content validation)\n\nShows:\n- Original outcome\n- Replay outcome\n- Policy decisions (same/different)\n- Model drift detection",
            "is_async": true,
            "line": 868
          },
          {
            "name": "list_api_keys",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "List API keys with status.\n\nCustomer can freeze/unfreeze individual keys.\n\nPIN-281: Uses L3 CustomerKeysAdapter for tenant-scoped operations.",
            "is_async": true,
            "line": 1082
          },
          {
            "name": "freeze_api_key",
            "signature": "(key_id: str, tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "Freeze an API key.\n\nPIN-281: Uses L3 CustomerKeysAdapter with tenant isolation.",
            "is_async": true,
            "line": 1121
          },
          {
            "name": "unfreeze_api_key",
            "signature": "(key_id: str, tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "Unfreeze an API key.\n\nPIN-281: Uses L3 CustomerKeysAdapter with tenant isolation.",
            "is_async": true,
            "line": 1142
          },
          {
            "name": "get_settings",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "Get read-only settings.\n\nCustomers can see what's configured but can't change it.\nContact support to modify.\n\nIn demo mode (tenant_demo or non-existent tenant), returns demo defaults.",
            "is_async": true,
            "line": 1168
          },
          {
            "name": "search_incidents",
            "signature": "(request: IncidentSearchRequest, tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "Search incidents with filters - M23 component map spec.\n\nSupports:\n- Free text search in title/description\n- Filter by user_id (from related calls)\n- Filter by policy status (passed/failed)\n- Filter by severity\n- Filter by time range\n- Filter by model",
            "is_async": true,
            "line": 1341
          },
          {
            "name": "get_decision_timeline",
            "signature": "(incident_id: str, session: Session = Depends(get_session))",
            "docstring": "Get decision timeline - M23 component map spec.\n\nReturns step-by-step trace:\n1. INPUT_RECEIVED - What the user asked\n2. CONTEXT_RETRIEVED - What data was fetched\n3. POLICY_EVALUATED - Each policy check (PASS/FAIL/WARN)\n4. MODEL_CALLED - LLM invocation\n5. OUTPUT_GENERATED - Final response\n6. LOGGED - Audit trail\n\nPlus root cause identification if policy failed.",
            "is_async": true,
            "line": 1475
          },
          {
            "name": "export_incident_evidence",
            "signature": "(incident_id: str, tenant_id: str = Query(..., description='Tenant ID'), include_replay: bool = Query(True, description='Include replay verification'), include_prevention: bool = Query(True, description='Include prevention proof'), is_demo: bool = Query(True, description='Add demo watermark'), session: Session = Depends(get_session))",
            "docstring": "Export incident as a legal-grade PDF evidence report.\n\nThis document is designed to survive:\n- Legal review\n- Audit compliance\n- Executive briefing\n- Hostile questioning\n\nSections included:\n1. Executive Summary (for lawyers/leadership)\n2. Factual Reconstruction (pure evidence)\n3. Policy Evaluation Record\n4. Decision Timeline (deterministic trace)\n5. Replay Verification (cryptographic proof)\n6. Prevention Proof (counterfactual)\n7. Remediation & Controls\n8. Legal Attestation\n\nReturns: PDF file with Content-Disposition header",
            "is_async": true,
            "line": 1805
          },
          {
            "name": "onboarding_verify",
            "signature": "(request: OnboardingVerifyRequest, tenant_id: str = Query(..., description='Tenant ID'), session: Session = Depends(get_session))",
            "docstring": "REAL safety verification for onboarding.\n\nThis endpoint:\n1. Fires a REAL request through the proxy (not simulated)\n2. Uses a prompt designed to trigger a guardrail\n3. Creates a REAL incident if blocked\n4. Sends a REAL alert if configured\n\nThe user will see:\n- A real API call being made\n- Real tokens being consumed (minimal)\n- A real incident in their console\n- A real alert (if Slack/email configured)\n\nTest types:\n- guardrail_block: Triggers prompt injection guardrail (blocked, no cost)\n- killswitch_demo: Shows what happens when kill switch fires",
            "is_async": true,
            "line": 2040
          }
        ],
        "classes": [
          {
            "name": "GuardStatus",
            "docstring": "Protection status response.",
            "methods": [],
            "line": 128
          },
          {
            "name": "TodaySnapshot",
            "docstring": "Today's metrics snapshot.",
            "methods": [],
            "line": 139
          },
          {
            "name": "IncidentSummary",
            "docstring": "Incident list item.",
            "methods": [],
            "line": 149
          },
          {
            "name": "IncidentEventResponse",
            "docstring": "Timeline event.",
            "methods": [],
            "line": 167
          },
          {
            "name": "IncidentDetailResponse",
            "docstring": "Full incident detail with timeline.",
            "methods": [],
            "line": 177
          },
          {
            "name": "ApiKeyResponse",
            "docstring": "API key for customer console.",
            "methods": [],
            "line": 184
          },
          {
            "name": "PaginatedResponse",
            "docstring": "Generic paginated response.",
            "methods": [],
            "line": 197
          },
          {
            "name": "GuardrailConfig",
            "docstring": "Guardrail configuration for settings page.",
            "methods": [],
            "line": 206
          },
          {
            "name": "TenantSettings",
            "docstring": "Read-only tenant settings.",
            "methods": [],
            "line": 219
          },
          {
            "name": "PolicyDecision",
            "docstring": "Policy decision for replay.",
            "methods": [],
            "line": 235
          },
          {
            "name": "ReplayCallSnapshot",
            "docstring": "Call snapshot for replay comparison.",
            "methods": [],
            "line": 244
          },
          {
            "name": "ReplayCertificate",
            "docstring": "M23: Cryptographic certificate proving deterministic replay.",
            "methods": [],
            "line": 255
          },
          {
            "name": "ReplayResult",
            "docstring": "Replay result response.",
            "methods": [],
            "line": 267
          },
          {
            "name": "IncidentSearchRequest",
            "docstring": "Search incidents with filters.",
            "methods": [],
            "line": 1237
          },
          {
            "name": "IncidentSearchResult",
            "docstring": "Search result item matching component map spec.",
            "methods": [],
            "line": 1251
          },
          {
            "name": "IncidentSearchResponse",
            "docstring": "Search response.",
            "methods": [],
            "line": 1265
          },
          {
            "name": "TimelineEvent",
            "docstring": "Decision timeline event - step by step policy evaluation.",
            "methods": [],
            "line": 1274
          },
          {
            "name": "PolicyEvaluation",
            "docstring": "Individual policy evaluation result.",
            "methods": [],
            "line": 1283
          },
          {
            "name": "CARERoutingInfo",
            "docstring": "M17 CARE routing information for decision timeline.",
            "methods": [],
            "line": 1293
          },
          {
            "name": "FailureCatalogMatch",
            "docstring": "M9 Failure Catalog match information.",
            "methods": [],
            "line": 1308
          },
          {
            "name": "DecisionTimelineResponse",
            "docstring": "Full decision timeline for an incident/call.",
            "methods": [],
            "line": 1320
          },
          {
            "name": "EvidenceExportRequest",
            "docstring": "Request for evidence report export.",
            "methods": [],
            "line": 1795
          },
          {
            "name": "OnboardingVerifyRequest",
            "docstring": "Request for onboarding safety verification.",
            "methods": [],
            "line": 2016
          },
          {
            "name": "OnboardingVerifyResponse",
            "docstring": "Response from onboarding verification.",
            "methods": [],
            "line": 2023
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "cast"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.adapters.customer_incidents_adapter",
            "names": [
              "get_customer_incidents_adapter"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.adapters.customer_keys_adapter",
            "names": [
              "get_customer_keys_adapter"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.adapters.customer_killswitch_adapter",
            "names": [
              "get_customer_killswitch_adapter"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "emit_authority_audit",
              "require_replay_execute"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "CustomerToken",
              "verify_console_token"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.contracts.guard",
            "names": [
              "CustomerIncidentActionDTO",
              "CustomerIncidentImpactDTO",
              "CustomerIncidentNarrativeDTO",
              "CustomerIncidentResolutionDTO"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "app.db",
            "names": [
              "get_session"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "DefaultGuardrail",
              "Incident",
              "IncidentEvent",
              "IncidentSeverity",
              "KillSwitchState",
              "ProxyCall"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "app.models.tenant",
            "names": [
              "Tenant"
            ],
            "is_relative": false,
            "line": 79
          },
          {
            "module": "app.hoc.cus.logs.L5_engines.certificate",
            "names": [
              "CertificateService"
            ],
            "is_relative": false,
            "line": 83
          },
          {
            "module": "app.hoc.cus.general.L5_controls.drivers.guard_write_driver",
            "names": [
              "GuardWriteDriver"
            ],
            "is_relative": false,
            "line": 89
          },
          {
            "module": "app.hoc.cus.logs.L5_engines.replay_determinism",
            "names": [
              "DeterminismLevel",
              "ReplayContextBuilder"
            ],
            "is_relative": false,
            "line": 93
          },
          {
            "module": "app.hoc.cus.logs.L5_engines.replay_determinism",
            "names": [
              "ReplayValidator"
            ],
            "is_relative": false,
            "line": 97
          },
          {
            "module": "app.utils.guard_cache",
            "names": [
              "get_guard_cache"
            ],
            "is_relative": false,
            "line": 102
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 1787
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 1788
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard_policies.py",
        "file_path": "backend/app/hoc/api/cus/policies/guard_policies.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 128,
        "module_docstring": "Guard Policies API - Customer Console Policy Constraints Endpoint\n\nThis router provides endpoints for the Customer Console (guard.agenticverz.com).\nFocused on POLICY VISIBILITY - customers can see their constraints and limits.\n\nEndpoints:\n- GET  /guard/policies          - Policy constraints summary\n- GET  /guard/policies/guardrails/{id}  - Guardrail detail\n\nPIN-281 Promotion:\n- L4\u2192L3: customer_policies_adapter.py (boundary adapter)\n- L3\u2192L2: This file (API route)\n\nRule: One adapter per route. No business logic here.",
        "functions": [
          {
            "name": "get_policy_constraints",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID (required)'))",
            "docstring": "Get policy constraints for customer.\n\nReturns summary of:\n- Budget constraints (limit, usage, remaining)\n- Rate limits\n- Active guardrails\n\nCustomer can only see their own tenant's constraints (enforced by adapter).\n\nThis endpoint answers:\n- What are my limits?\n- How much have I used?\n- What protection is active?\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 57
          },
          {
            "name": "get_guardrail_detail",
            "signature": "(guardrail_id: str, tenant_id: str = Query(..., description='Tenant ID (required)'))",
            "docstring": "Get guardrail detail.\n\nReturns information about a specific guardrail:\n- Name and description\n- Whether it's enabled\n- Action on trigger (block, warn, log)\n\nNo threshold values exposed (internal implementation detail).\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 93
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "app.adapters.customer_policies_adapter",
            "names": [
              "CustomerGuardrail",
              "CustomerPolicyConstraints",
              "get_customer_policies_adapter"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "verify_console_token"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lifecycle.py",
        "file_path": "backend/app/hoc/api/cus/policies/lifecycle.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 401,
        "module_docstring": "Lifecycle API (L2)\n\nProvides lifecycle operations:\n- POST /api/v1/lifecycle/agents (create agent)\n- GET /api/v1/lifecycle/agents (list agents)\n- GET /api/v1/lifecycle/agents/{id} (get agent)\n- POST /api/v1/lifecycle/agents/{id}/start (start agent)\n- POST /api/v1/lifecycle/agents/{id}/stop (stop agent)\n- POST /api/v1/lifecycle/agents/{id}/terminate (terminate agent)\n- POST /api/v1/lifecycle/runs (create run)\n- GET /api/v1/lifecycle/runs (list runs)\n- GET /api/v1/lifecycle/runs/{id} (get run)\n- POST /api/v1/lifecycle/runs/{id}/pause (pause run)\n- POST /api/v1/lifecycle/runs/{id}/resume (resume run)\n- POST /api/v1/lifecycle/runs/{id}/cancel (cancel run)\n- GET /api/v1/lifecycle/summary (lifecycle summary)\n\nThis is the ONLY facade for lifecycle operations.\nAll lifecycle APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> LifecycleFacade",
            "docstring": "Get the lifecycle facade.",
            "is_async": false,
            "line": 85
          },
          {
            "name": "create_agent",
            "signature": "(request: CreateAgentRequest, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.write')))",
            "docstring": "Create a new agent (GAP-131).",
            "is_async": true,
            "line": 96
          },
          {
            "name": "list_agents",
            "signature": "(state: Optional[str] = Query(None, description='Filter by state'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "List agents (GAP-131).\n\nReturns all agents for the tenant.",
            "is_async": true,
            "line": 116
          },
          {
            "name": "get_agent",
            "signature": "(agent_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "Get a specific agent (GAP-131).",
            "is_async": true,
            "line": 145
          },
          {
            "name": "start_agent",
            "signature": "(agent_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Start an agent (GAP-132).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 166
          },
          {
            "name": "stop_agent",
            "signature": "(agent_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Stop an agent (GAP-132).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 189
          },
          {
            "name": "terminate_agent",
            "signature": "(agent_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Terminate an agent (GAP-132).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 212
          },
          {
            "name": "create_run",
            "signature": "(request: CreateRunRequest, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.write')))",
            "docstring": "Create a new run (GAP-133).",
            "is_async": true,
            "line": 240
          },
          {
            "name": "list_runs",
            "signature": "(agent_id: Optional[str] = Query(None, description='Filter by agent'), state: Optional[str] = Query(None, description='Filter by state'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "List runs (GAP-133).\n\nReturns all runs for the tenant.",
            "is_async": true,
            "line": 263
          },
          {
            "name": "get_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "Get a specific run (GAP-133).",
            "is_async": true,
            "line": 294
          },
          {
            "name": "pause_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Pause a run (GAP-134).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 315
          },
          {
            "name": "resume_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Resume a paused run (GAP-135).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 338
          },
          {
            "name": "cancel_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.admin')))",
            "docstring": "Cancel a run (GAP-136).\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 361
          },
          {
            "name": "get_summary",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: LifecycleFacade = Depends(get_facade), _tier: None = Depends(requires_feature('lifecycle.read')))",
            "docstring": "Get lifecycle summary.\n\nReturns summary of agents and runs for the tenant.",
            "is_async": true,
            "line": 389
          }
        ],
        "classes": [
          {
            "name": "CreateAgentRequest",
            "docstring": "Request to create an agent.",
            "methods": [],
            "line": 66
          },
          {
            "name": "CreateRunRequest",
            "docstring": "Request to create a run.",
            "methods": [],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.general.L5_engines.lifecycle_facade",
            "names": [
              "LifecycleFacade",
              "get_lifecycle_facade"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "logs.py",
        "file_path": "backend/app/hoc/api/cus/policies/logs.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1433,
        "module_docstring": "Unified Logs API (L2) - LOGS Domain V2\n\nCustomer-facing endpoints for viewing logs: audit ledger, LLM run records, and system records.\nAll requests are tenant-scoped via auth_context.\n\nTopics & O-Levels (per LOGS_DOMAIN_V2_CONTRACT.md):\n\nLLM_RUNS:\n- GET /logs/llm-runs                          \u2192 List runs\n- GET /logs/llm-runs/{run_id}/envelope        \u2192 O1 canonical record\n- GET /logs/llm-runs/{run_id}/trace           \u2192 O2 step-by-step trace\n- GET /logs/llm-runs/{run_id}/governance      \u2192 O3 policy interaction\n- GET /logs/llm-runs/{run_id}/replay          \u2192 O4 60-second window\n- GET /logs/llm-runs/{run_id}/export          \u2192 O5 evidence bundle\n\nSYSTEM_LOGS:\n- GET /logs/system                            \u2192 List events\n- GET /logs/system/{run_id}/snapshot          \u2192 O1 environment baseline\n- GET /logs/system/{run_id}/telemetry         \u2192 O2 (STUB)\n- GET /logs/system/{run_id}/events            \u2192 O3 infra events\n- GET /logs/system/{run_id}/replay            \u2192 O4 infra replay\n- GET /logs/system/audit                      \u2192 O5 infra attribution\n\nAUDIT:\n- GET /logs/audit                             \u2192 List entries\n- GET /logs/audit/identity                    \u2192 O1 identity lifecycle\n- GET /logs/audit/authorization               \u2192 O2 access decisions\n- GET /logs/audit/access                      \u2192 O3 log access audit\n- GET /logs/audit/integrity                   \u2192 O4 tamper detection\n- GET /logs/audit/exports                     \u2192 O5 compliance exports\n\nAll records are:\n- APPEND-ONLY (enforced by DB trigger)\n- WRITE-ONCE (no UPDATE, no DELETE)\n- Trust anchors for verification",
        "functions": [
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 132
          },
          {
            "name": "list_llm_run_records",
            "signature": "(request: Request, run_id: Annotated[Optional[str], Query(description='Filter by run ID')] = None, provider: Annotated[Optional[str], Query(description='Filter by provider')] = None, model: Annotated[Optional[str], Query(description='Filter by model')] = None, execution_status: Annotated[Optional[str], Query(description='Filter by status')] = None, is_synthetic: Annotated[Optional[bool], Query(description='Filter synthetic')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter created_at >=')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter created_at <=')] = None, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> LLMRunRecordsResponse",
            "docstring": "List LLM run records. READ-ONLY customer facade.",
            "is_async": true,
            "line": 516
          },
          {
            "name": "get_llm_run_envelope",
            "signature": "(request: Request, run_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> LLMRunEnvelope",
            "docstring": "O1: Canonical immutable run record. READ-ONLY customer facade.",
            "is_async": true,
            "line": 581
          },
          {
            "name": "get_llm_run_trace",
            "signature": "(request: Request, run_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> LLMRunTrace",
            "docstring": "O2: Step-by-step execution trace. READ-ONLY customer facade.",
            "is_async": true,
            "line": 631
          },
          {
            "name": "get_llm_run_governance",
            "signature": "(request: Request, run_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> LLMRunGovernance",
            "docstring": "O3: Policy interaction trace. READ-ONLY customer facade.",
            "is_async": true,
            "line": 684
          },
          {
            "name": "get_llm_run_replay",
            "signature": "(request: Request, run_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> LLMRunReplay",
            "docstring": "O4: 60-second replay window. READ-ONLY customer facade.",
            "is_async": true,
            "line": 732
          },
          {
            "name": "get_llm_run_export",
            "signature": "(request: Request, run_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> LLMRunExport",
            "docstring": "O5: Export information. READ-ONLY customer facade.",
            "is_async": true,
            "line": 784
          },
          {
            "name": "list_system_records",
            "signature": "(request: Request, component: Annotated[Optional[str], Query(description='Filter by component')] = None, event_type: Annotated[Optional[str], Query(description='Filter by event type')] = None, severity: Annotated[Optional[str], Query(description='Filter by severity')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter created_at >=')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter created_at <=')] = None, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> SystemRecordsResponse",
            "docstring": "List system records. READ-ONLY customer facade.",
            "is_async": true,
            "line": 829
          },
          {
            "name": "get_system_snapshot",
            "signature": "(request: Request, run_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> SystemSnapshot",
            "docstring": "O1: Environment baseline snapshot. READ-ONLY customer facade.",
            "is_async": true,
            "line": 885
          },
          {
            "name": "get_system_telemetry",
            "signature": "(request: Request, run_id: str) -> TelemetryStub",
            "docstring": "O2: Telemetry stub - producer not implemented. READ-ONLY customer facade.",
            "is_async": true,
            "line": 929
          },
          {
            "name": "get_system_events",
            "signature": "(request: Request, run_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> SystemEvents",
            "docstring": "O3: Infra events affecting run. READ-ONLY customer facade.",
            "is_async": true,
            "line": 947
          },
          {
            "name": "get_system_replay",
            "signature": "(request: Request, run_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> SystemReplay",
            "docstring": "O4: Infra replay window. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1000
          },
          {
            "name": "get_system_audit",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> SystemAudit",
            "docstring": "O5: Infra attribution. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1054
          },
          {
            "name": "list_audit_entries",
            "signature": "(request: Request, event_type: Annotated[Optional[str], Query(description='Filter by event type')] = None, entity_type: Annotated[Optional[str], Query(description='Filter by entity type')] = None, actor_type: Annotated[Optional[str], Query(description='Filter by actor type')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter created_at >=')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter created_at <=')] = None, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> AuditLedgerResponse",
            "docstring": "List audit entries. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1112
          },
          {
            "name": "get_audit_entry",
            "signature": "(request: Request, entry_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> AuditLedgerDetailItem",
            "docstring": "Get audit entry detail. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1167
          },
          {
            "name": "get_audit_identity",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, session: AsyncSession = Depends(get_async_session_dep)) -> AuditIdentity",
            "docstring": "O1: Identity lifecycle. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1206
          },
          {
            "name": "get_audit_authorization",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, session: AsyncSession = Depends(get_async_session_dep)) -> AuditAuthorization",
            "docstring": "O2: Authorization decisions. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1254
          },
          {
            "name": "get_audit_access",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, session: AsyncSession = Depends(get_async_session_dep)) -> AuditAccess",
            "docstring": "O3: Log access audit. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1304
          },
          {
            "name": "get_audit_integrity",
            "signature": "(request: Request) -> AuditIntegrity",
            "docstring": "O4: Tamper detection. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1354
          },
          {
            "name": "get_audit_exports",
            "signature": "(request: Request, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> AuditExports",
            "docstring": "O5: Compliance exports. READ-ONLY customer facade.",
            "is_async": true,
            "line": 1389
          }
        ],
        "classes": [
          {
            "name": "EvidenceMetadata",
            "docstring": "Global metadata contract for all Logs responses.\n\nPer LOGS_DOMAIN_V2_CONTRACT.md, every Logs response MUST include this.\nAbsence is a contract violation.",
            "methods": [],
            "line": 89
          },
          {
            "name": "LLMRunEnvelope",
            "docstring": "O1: Canonical immutable run record.",
            "methods": [],
            "line": 161
          },
          {
            "name": "TraceStep",
            "docstring": "Individual trace step.",
            "methods": [],
            "line": 182
          },
          {
            "name": "LLMRunTrace",
            "docstring": "O2: Step-by-step trace.",
            "methods": [],
            "line": 194
          },
          {
            "name": "GovernanceEvent",
            "docstring": "Policy interaction event.",
            "methods": [],
            "line": 204
          },
          {
            "name": "LLMRunGovernance",
            "docstring": "O3: Policy interaction trace.",
            "methods": [],
            "line": 216
          },
          {
            "name": "ReplayEvent",
            "docstring": "Replay window event.",
            "methods": [],
            "line": 225
          },
          {
            "name": "LLMRunReplay",
            "docstring": "O4: 60-second replay window.",
            "methods": [],
            "line": 235
          },
          {
            "name": "LLMRunExport",
            "docstring": "O5: Export metadata.",
            "methods": [],
            "line": 246
          },
          {
            "name": "LLMRunRecordItem",
            "docstring": "Single LLM run record entry (list view).",
            "methods": [],
            "line": 256
          },
          {
            "name": "LLMRunRecordsResponse",
            "docstring": "Response envelope for LLM run records.",
            "methods": [],
            "line": 275
          },
          {
            "name": "SystemSnapshot",
            "docstring": "O1: Environment snapshot.",
            "methods": [],
            "line": 289
          },
          {
            "name": "TelemetryStub",
            "docstring": "O2: Telemetry stub response.",
            "methods": [],
            "line": 302
          },
          {
            "name": "SystemEvent",
            "docstring": "System event record.",
            "methods": [],
            "line": 312
          },
          {
            "name": "SystemEvents",
            "docstring": "O3: Infra events affecting run.",
            "methods": [],
            "line": 325
          },
          {
            "name": "SystemReplay",
            "docstring": "O4: Infra replay window.",
            "methods": [],
            "line": 334
          },
          {
            "name": "SystemAudit",
            "docstring": "O5: Infra attribution record.",
            "methods": [],
            "line": 344
          },
          {
            "name": "SystemRecordItem",
            "docstring": "Single system record entry.",
            "methods": [],
            "line": 352
          },
          {
            "name": "SystemRecordsResponse",
            "docstring": "Response envelope for system records.",
            "methods": [],
            "line": 366
          },
          {
            "name": "AuditLedgerItem",
            "docstring": "Single audit ledger entry.",
            "methods": [],
            "line": 380
          },
          {
            "name": "AuditLedgerDetailItem",
            "docstring": "Audit ledger entry with state snapshots.",
            "methods": [],
            "line": 393
          },
          {
            "name": "AuditLedgerResponse",
            "docstring": "Response envelope for audit ledger.",
            "methods": [],
            "line": 401
          },
          {
            "name": "IdentityEvent",
            "docstring": "Identity lifecycle event.",
            "methods": [],
            "line": 410
          },
          {
            "name": "AuditIdentity",
            "docstring": "O1: Identity lifecycle.",
            "methods": [],
            "line": 420
          },
          {
            "name": "AuthorizationDecision",
            "docstring": "Authorization decision record.",
            "methods": [],
            "line": 428
          },
          {
            "name": "AuditAuthorization",
            "docstring": "O2: Access decisions.",
            "methods": [],
            "line": 440
          },
          {
            "name": "AccessEvent",
            "docstring": "Log access event.",
            "methods": [],
            "line": 448
          },
          {
            "name": "AuditAccess",
            "docstring": "O3: Log access audit.",
            "methods": [],
            "line": 460
          },
          {
            "name": "IntegrityCheck",
            "docstring": "Integrity verification record.",
            "methods": [],
            "line": 468
          },
          {
            "name": "AuditIntegrity",
            "docstring": "O4: Tamper detection.",
            "methods": [],
            "line": 477
          },
          {
            "name": "ExportRecord",
            "docstring": "Export record.",
            "methods": [],
            "line": 484
          },
          {
            "name": "AuditExports",
            "docstring": "O5: Compliance exports.",
            "methods": [],
            "line": 497
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Literal",
              "Optional"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session_dep"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "app.hoc.cus.logs.L5_engines.logs_facade",
            "names": [
              "get_logs_facade"
            ],
            "is_relative": false,
            "line": 71
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "monitors.py",
        "file_path": "backend/app/hoc/api/cus/policies/monitors.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 298,
        "module_docstring": "Monitors API (L2)\n\nProvides monitoring operations:\n- POST /api/v1/monitors (create monitor)\n- GET /api/v1/monitors (list monitors)\n- GET /api/v1/monitors/{id} (get monitor)\n- PUT /api/v1/monitors/{id} (update monitor)\n- DELETE /api/v1/monitors/{id} (delete monitor)\n- POST /api/v1/monitors/{id}/check (run health check)\n- GET /api/v1/monitors/{id}/history (check history)\n- GET /api/v1/monitors/status (overall status)\n\nThis is the ONLY facade for monitoring operations.\nAll monitor APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> MonitorsFacade",
            "docstring": "Get the monitors facade.",
            "is_async": false,
            "line": 89
          },
          {
            "name": "create_monitor",
            "signature": "(request: CreateMonitorRequest, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.write')))",
            "docstring": "Create a monitor (GAP-121).\n\n**Tier: REACT ($9)** - Monitor configuration.\n\nMonitor types:\n- http: HTTP endpoint monitoring\n- tcp: TCP port monitoring\n- dns: DNS resolution monitoring\n- heartbeat: Passive heartbeat monitoring\n- custom: Custom check implementation",
            "is_async": true,
            "line": 100
          },
          {
            "name": "list_monitors",
            "signature": "(monitor_type: Optional[str] = Query(None, description='Filter by type'), status: Optional[str] = Query(None, description='Filter by status'), enabled_only: bool = Query(False, description='Only enabled monitors'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.read')))",
            "docstring": "List monitors.",
            "is_async": true,
            "line": 134
          },
          {
            "name": "get_status",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.read')))",
            "docstring": "Get overall monitoring status (GAP-120).\n\nReturns aggregate health status across all monitors.",
            "is_async": true,
            "line": 165
          },
          {
            "name": "get_monitor",
            "signature": "(monitor_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.read')))",
            "docstring": "Get a specific monitor.",
            "is_async": true,
            "line": 181
          },
          {
            "name": "update_monitor",
            "signature": "(monitor_id: str, request: UpdateMonitorRequest, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.write')))",
            "docstring": "Update a monitor.",
            "is_async": true,
            "line": 202
          },
          {
            "name": "delete_monitor",
            "signature": "(monitor_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.write')))",
            "docstring": "Delete a monitor.",
            "is_async": true,
            "line": 231
          },
          {
            "name": "run_check",
            "signature": "(monitor_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.check')))",
            "docstring": "Run a health check (GAP-120).\n\nManually triggers a health check for the monitor.",
            "is_async": true,
            "line": 252
          },
          {
            "name": "get_history",
            "signature": "(monitor_id: str, limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: MonitorsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('monitors.read')))",
            "docstring": "Get health check history.",
            "is_async": true,
            "line": 275
          }
        ],
        "classes": [
          {
            "name": "CreateMonitorRequest",
            "docstring": "Request to create a monitor.",
            "methods": [],
            "line": 61
          },
          {
            "name": "UpdateMonitorRequest",
            "docstring": "Request to update a monitor.",
            "methods": [],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.general.L5_engines.monitors_facade",
            "names": [
              "MonitorsFacade",
              "get_monitors_facade"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "notifications.py",
        "file_path": "backend/app/hoc/api/cus/policies/notifications.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 244,
        "module_docstring": "Notifications API (L2)\n\nProvides notification operations:\n- POST /api/v1/notifications (send notification)\n- GET /api/v1/notifications (list notifications)\n- GET /api/v1/notifications/{id} (get notification)\n- POST /api/v1/notifications/{id}/read (mark as read)\n- GET /api/v1/notifications/channels (list channels)\n- GET /api/v1/notifications/preferences (get preferences)\n- PUT /api/v1/notifications/preferences (update preferences)\n\nThis is the ONLY facade for notification operations.\nAll notification APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> NotificationsFacade",
            "docstring": "Get the notifications facade.",
            "is_async": false,
            "line": 78
          },
          {
            "name": "send_notification",
            "signature": "(request: SendNotificationRequest, ctx: TenantContext = Depends(get_tenant_context), facade: NotificationsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('notifications.send')))",
            "docstring": "Send a notification (GAP-109).\n\n**Tier: REACT ($9)** - Notification sending.\n\nChannels:\n- email: Email notifications\n- slack: Slack messages\n- webhook: Webhook callbacks\n- in_app: In-app notifications\n- sms: SMS messages (requires configuration)",
            "is_async": true,
            "line": 89
          },
          {
            "name": "list_notifications",
            "signature": "(channel: Optional[str] = Query(None, description='Filter by channel'), status: Optional[str] = Query(None, description='Filter by status'), recipient: Optional[str] = Query(None, description='Filter by recipient'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: NotificationsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('notifications.read')))",
            "docstring": "List notifications for the tenant.",
            "is_async": true,
            "line": 121
          },
          {
            "name": "list_channels",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: NotificationsFacade = Depends(get_facade))",
            "docstring": "List available notification channels.",
            "is_async": true,
            "line": 152
          },
          {
            "name": "get_preferences",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: NotificationsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('notifications.read')))",
            "docstring": "Get notification preferences for the current user.",
            "is_async": true,
            "line": 167
          },
          {
            "name": "update_preferences",
            "signature": "(request: UpdatePreferencesRequest, ctx: TenantContext = Depends(get_tenant_context), facade: NotificationsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('notifications.write')))",
            "docstring": "Update notification preferences for the current user.",
            "is_async": true,
            "line": 185
          },
          {
            "name": "get_notification",
            "signature": "(notification_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: NotificationsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('notifications.read')))",
            "docstring": "Get a specific notification.",
            "is_async": true,
            "line": 206
          },
          {
            "name": "mark_as_read",
            "signature": "(notification_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: NotificationsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('notifications.write')))",
            "docstring": "Mark a notification as read.",
            "is_async": true,
            "line": 227
          }
        ],
        "classes": [
          {
            "name": "SendNotificationRequest",
            "docstring": "Request to send notification.",
            "methods": [],
            "line": 57
          },
          {
            "name": "UpdatePreferencesRequest",
            "docstring": "Request to update notification preferences.",
            "methods": [],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.hoc.cus.account.L5_engines.notifications_facade",
            "names": [
              "NotificationsFacade",
              "get_notifications_facade"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "override.py",
        "file_path": "backend/app/hoc/api/cus/policies/override.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 335,
        "module_docstring": "Limit Override API (PIN-LIM-05)\n\nTemporary limit override request endpoints.\n\nAllows authorized users to request temporary increases to limits,\nwith approval workflow and automatic expiry.\n\nEndpoints:\n    POST /api/v1/limits/overrides         \u2192 Request new override\n    GET  /api/v1/limits/overrides         \u2192 List overrides for tenant\n    GET  /api/v1/limits/overrides/{id}    \u2192 Get specific override\n    DELETE /api/v1/limits/overrides/{id}  \u2192 Cancel override",
        "functions": [
          {
            "name": "create_override",
            "signature": "(request: Request, body: CreateOverrideRequest, session: AsyncSession = Depends(get_async_session_dep)) -> OverrideDetail",
            "docstring": "Request a temporary limit override.\n\n- Requires justification (reason)\n- Maximum 5 active overrides per tenant\n- Maximum duration: 168 hours (1 week)\n- Cannot stack multiple overrides on same limit",
            "is_async": true,
            "line": 129
          },
          {
            "name": "list_overrides",
            "signature": "(request: Request, status: Optional[str] = Query(default=None, description='Filter by status'), limit: int = Query(default=20, ge=1, le=100), offset: int = Query(default=0, ge=0), session: AsyncSession = Depends(get_async_session_dep)) -> OverrideListResponse",
            "docstring": "List overrides for the tenant.",
            "is_async": true,
            "line": 194
          },
          {
            "name": "get_override",
            "signature": "(request: Request, override_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> OverrideDetail",
            "docstring": "Get override by ID.",
            "is_async": true,
            "line": 235
          },
          {
            "name": "cancel_override",
            "signature": "(request: Request, override_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> OverrideDetail",
            "docstring": "Cancel a pending or active override.",
            "is_async": true,
            "line": 263
          },
          {
            "name": "_to_detail",
            "signature": "(result: LimitOverrideResponse) -> OverrideDetail",
            "docstring": "Convert service response to API response.",
            "is_async": false,
            "line": 300
          },
          {
            "name": "_to_list_item",
            "signature": "(result: LimitOverrideResponse) -> OverrideListItem",
            "docstring": "Convert service response to list item.",
            "is_async": false,
            "line": 322
          }
        ],
        "classes": [
          {
            "name": "CreateOverrideRequest",
            "docstring": "Request to create a limit override.",
            "methods": [],
            "line": 61
          },
          {
            "name": "OverrideListItem",
            "docstring": "Override summary for list view.",
            "methods": [],
            "line": 72
          },
          {
            "name": "OverrideDetail",
            "docstring": "Full override details.",
            "methods": [],
            "line": 87
          },
          {
            "name": "OverrideListResponse",
            "docstring": "Response for override list.",
            "methods": [],
            "line": 108
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session_dep"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.schemas.limits.overrides",
            "names": [
              "LimitOverrideRequest",
              "LimitOverrideResponse",
              "OverrideStatus"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.hoc.cus.controls.L6_drivers.override_driver",
            "names": [
              "LimitNotFoundError",
              "LimitOverrideService",
              "LimitOverrideServiceError",
              "OverrideNotFoundError",
              "OverrideValidationError",
              "StackingAbuseError"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policies.py",
        "file_path": "backend/app/hoc/api/cus/policies/policies.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1531,
        "module_docstring": "Unified Policies API (L2)\n\nCustomer-facing endpoints for viewing policy rules and limits.\nAll requests are tenant-scoped via auth_context.\n\nEndpoints:\n- GET /api/v1/policies/rules           \u2192 O2 list of policy rules\n- GET /api/v1/policies/rules/{rule_id} \u2192 O3 rule detail\n- GET /api/v1/policies/limits          \u2192 O2 list of limits\n- GET /api/v1/policies/limits/{limit_id} \u2192 O3 limit detail\n\nArchitecture:\n- ONE facade for all POLICIES needs (rules + limits)\n- Queries PolicyRule, PolicyRuleIntegrity, Limit, LimitIntegrity tables\n- Tenant isolation via auth_context (not header)\n- SDSR validates this same production API",
        "functions": [
          {
            "name": "require_preflight",
            "signature": "() -> None",
            "docstring": "Guard for preflight-only endpoints (O4, O5).",
            "is_async": false,
            "line": 61
          },
          {
            "name": "get_tenant_id_from_auth",
            "signature": "(request: Request) -> str",
            "docstring": "Extract tenant_id from auth_context. Raises 401/403 if missing.",
            "is_async": false,
            "line": 201
          },
          {
            "name": "list_policy_rules",
            "signature": "(request: Request, status: Annotated[str, Query(description='Rule status: ACTIVE or RETIRED', pattern='^(ACTIVE|RETIRED)$')] = 'ACTIVE', enforcement_mode: Annotated[Optional[str], Query(description='Filter by enforcement mode: BLOCK, WARN, AUDIT, DISABLED', pattern='^(BLOCK|WARN|AUDIT|DISABLED)$')] = None, scope: Annotated[Optional[str], Query(description='Filter by scope: GLOBAL, TENANT, PROJECT, AGENT', pattern='^(GLOBAL|TENANT|PROJECT|AGENT)$')] = None, source: Annotated[Optional[str], Query(description='Filter by source: MANUAL, SYSTEM, LEARNED', pattern='^(MANUAL|SYSTEM|LEARNED)$')] = None, rule_type: Annotated[Optional[str], Query(description='Filter by rule type: SYSTEM, SAFETY, ETHICAL, TEMPORAL (PIN-411 Gap Closure)', pattern='^(SYSTEM|SAFETY|ETHICAL|TEMPORAL)$')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter by created_at >= value')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter by created_at <= value')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max rules to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of rules to skip')] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> RulesListResponse",
            "docstring": "List policy rules with unified query filters. READ-ONLY.",
            "is_async": true,
            "line": 240
          },
          {
            "name": "get_policy_rule_detail",
            "signature": "(request: Request, rule_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> PolicyRuleDetailResponse",
            "docstring": "Get policy rule detail (O3). Tenant isolation enforced.",
            "is_async": true,
            "line": 350
          },
          {
            "name": "list_limits",
            "signature": "(request: Request, category: Annotated[str, Query(alias='type', description='Limit category: BUDGET, RATE, or THRESHOLD', pattern='^(BUDGET|RATE|THRESHOLD)$')] = 'BUDGET', status: Annotated[str, Query(description='Limit status: ACTIVE or DISABLED', pattern='^(ACTIVE|DISABLED)$')] = 'ACTIVE', scope: Annotated[Optional[str], Query(description='Filter by scope: GLOBAL, TENANT, PROJECT, AGENT, PROVIDER', pattern='^(GLOBAL|TENANT|PROJECT|AGENT|PROVIDER)$')] = None, enforcement: Annotated[Optional[str], Query(description='Filter by enforcement: BLOCK, WARN, REJECT, QUEUE, DEGRADE, ALERT', pattern='^(BLOCK|WARN|REJECT|QUEUE|DEGRADE|ALERT)$')] = None, limit_type: Annotated[Optional[str], Query(description='Filter by limit_type. Supports prefix match, e.g. RUNS_*, TOKENS_*, RISK_CEILING, COOLDOWN (PIN-411 Gap Closure)')] = None, created_after: Annotated[Optional[datetime], Query(description='Filter by created_at >= value')] = None, created_before: Annotated[Optional[datetime], Query(description='Filter by created_at <= value')] = None, max_limit: Annotated[int, Query(ge=1, le=100, alias='limit', description='Max limits to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of limits to skip')] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> LimitsListResponse",
            "docstring": "List limits with unified query filters. READ-ONLY.",
            "is_async": true,
            "line": 413
          },
          {
            "name": "get_limit_detail",
            "signature": "(request: Request, limit_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> LimitDetailResponse",
            "docstring": "Get limit detail (O3). Tenant isolation enforced.",
            "is_async": true,
            "line": 527
          },
          {
            "name": "get_rule_evidence",
            "signature": "(request: Request, rule_id: str) -> dict[str, Any]",
            "docstring": "Get rule evidence (O4). Preflight console only.",
            "is_async": true,
            "line": 588
          },
          {
            "name": "get_limit_evidence",
            "signature": "(request: Request, limit_id: str) -> dict[str, Any]",
            "docstring": "Get limit evidence (O4). Preflight console only.",
            "is_async": true,
            "line": 614
          },
          {
            "name": "list_lessons",
            "signature": "(request: Request, lesson_type: Annotated[Optional[str], Query(description='Filter by type: failure, near_threshold, critical_success', pattern='^(failure|near_threshold|critical_success)$')] = None, status: Annotated[Optional[str], Query(description='Filter by status: pending, converted_to_draft, deferred, dismissed', pattern='^(pending|converted_to_draft|deferred|dismissed)$')] = None, severity: Annotated[Optional[str], Query(description='Filter by severity: CRITICAL, HIGH, MEDIUM, LOW', pattern='^(CRITICAL|HIGH|MEDIUM|LOW)$')] = None, limit: Annotated[int, Query(ge=1, le=100, description='Max lessons to return')] = 20, offset: Annotated[int, Query(ge=0, description='Number of lessons to skip')] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> LessonsListResponse",
            "docstring": "List lessons learned (O2). READ-ONLY customer facade.",
            "is_async": true,
            "line": 695
          },
          {
            "name": "get_lesson_stats",
            "signature": "(request: Request, session: AsyncSession = Depends(get_async_session_dep)) -> LessonStatsResponse",
            "docstring": "Get lesson statistics (O1). READ-ONLY customer facade.",
            "is_async": true,
            "line": 767
          },
          {
            "name": "get_lesson_detail",
            "signature": "(request: Request, lesson_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> LessonDetailResponse",
            "docstring": "Get lesson detail (O3). READ-ONLY customer facade.",
            "is_async": true,
            "line": 793
          },
          {
            "name": "get_policy_state",
            "signature": "(request: Request, session: AsyncSession = Depends(get_async_session_dep)) -> PolicyStateResponse",
            "docstring": "Get policy layer state (ACT-O4). Customer facade.",
            "is_async": true,
            "line": 856
          },
          {
            "name": "get_policy_metrics",
            "signature": "(request: Request, hours: Annotated[int, Query(ge=1, le=720, description='Time window in hours')] = 24, session: AsyncSession = Depends(get_async_session_dep)) -> PolicyMetricsResponse",
            "docstring": "Get policy metrics (ACT-O5). Customer facade.",
            "is_async": true,
            "line": 914
          },
          {
            "name": "list_policy_conflicts",
            "signature": "(request: Request, policy_id: Annotated[Optional[str], Query(description='Filter to conflicts involving this policy')] = None, severity: Annotated[Optional[str], Query(description='Filter by severity: BLOCKING, WARNING')] = None, include_resolved: Annotated[bool, Query(description='Include resolved conflicts')] = False, session: AsyncSession = Depends(get_async_session_dep)) -> ConflictsListResponse",
            "docstring": "Detect policy conflicts (DFT-O4). Uses PolicyConflictEngine via facade.",
            "is_async": true,
            "line": 996
          },
          {
            "name": "get_policy_dependencies",
            "signature": "(request: Request, policy_id: Annotated[Optional[str], Query(description='Filter to dependencies involving this policy')] = None, session: AsyncSession = Depends(get_async_session_dep)) -> DependencyGraphResponse",
            "docstring": "Get policy dependency graph (DFT-O5). Uses PolicyDependencyEngine via facade.",
            "is_async": true,
            "line": 1123
          },
          {
            "name": "list_policy_violations",
            "signature": "(request: Request, violation_type: Annotated[Optional[str], Query(description='Filter by type: cost, quota, rate, temporal, safety, ethical', pattern='^(cost|quota|rate|temporal|safety|ethical)$')] = None, source: Annotated[Optional[str], Query(description='Filter by source: guard, sim, runtime, cost (PIN-411 Gap Closure)', pattern='^(guard|sim|runtime|cost)$')] = None, severity_min: Annotated[Optional[float], Query(ge=0.0, le=1.0, description='Minimum severity (0.0-1.0)')] = None, violation_kind: Annotated[Optional[str], Query(description='Filter by violation kind: STANDARD, ANOMALY, DIVERGENCE (PIN-411 Gap Closure)', pattern='^(STANDARD|ANOMALY|DIVERGENCE)$')] = None, hours: Annotated[int, Query(ge=1, le=720, description='Time window in hours')] = 24, include_synthetic: Annotated[bool, Query(description='Include synthetic/simulated')] = False, limit: Annotated[int, Query(ge=1, le=100, description='Max items')] = 50, offset: Annotated[int, Query(ge=0, description='Offset')] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> ViolationsListResponse",
            "docstring": "List policy violations (VIO-O1). Unified customer facade.",
            "is_async": true,
            "line": 1238
          },
          {
            "name": "list_budget_definitions",
            "signature": "(request: Request, scope: Annotated[Optional[str], Query(description='Filter by scope: GLOBAL, TENANT, PROJECT, AGENT', pattern='^(GLOBAL|TENANT|PROJECT|AGENT)$')] = None, status: Annotated[str, Query(description='Filter by status: ACTIVE, DISABLED', pattern='^(ACTIVE|DISABLED)$')] = 'ACTIVE', limit: Annotated[int, Query(ge=1, le=100)] = 20, offset: Annotated[int, Query(ge=0)] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> BudgetsListResponse",
            "docstring": "List budget definitions (THR-O2). Customer facade.",
            "is_async": true,
            "line": 1357
          },
          {
            "name": "list_policy_requests",
            "signature": "(request: Request, status: Annotated[str, Query(description='Filter by status: draft, approved, rejected (default: draft)', pattern='^(draft|approved|rejected)$')] = 'draft', proposal_type: Annotated[Optional[str], Query(description='Filter by proposal type: rate_limit, cost_cap, retry_policy')] = None, days_old: Annotated[Optional[int], Query(ge=1, le=365, description='Filter to requests older than N days')] = None, include_synthetic: Annotated[bool, Query()] = False, limit: Annotated[int, Query(ge=1, le=100)] = 50, offset: Annotated[int, Query(ge=0)] = 0, session: AsyncSession = Depends(get_async_session_dep)) -> PolicyRequestsListResponse",
            "docstring": "List pending policy requests (ACT-O3). Customer facade.",
            "is_async": true,
            "line": 1460
          }
        ],
        "classes": [
          {
            "name": "PolicyRuleSummary",
            "docstring": "O2 Result Shape for policy rules.",
            "methods": [],
            "line": 78
          },
          {
            "name": "RulesListResponse",
            "docstring": "GET /rules response (O2).",
            "methods": [],
            "line": 95
          },
          {
            "name": "PolicyRuleDetailResponse",
            "docstring": "GET /rules/{rule_id} response (O3).",
            "methods": [],
            "line": 104
          },
          {
            "name": "LimitSummary",
            "docstring": "O2 Result Shape for limits.",
            "methods": [],
            "line": 131
          },
          {
            "name": "LimitsListResponse",
            "docstring": "GET /limits response (O2).",
            "methods": [],
            "line": 151
          },
          {
            "name": "LimitDetailResponse",
            "docstring": "GET /limits/{limit_id} response (O3).",
            "methods": [],
            "line": 160
          },
          {
            "name": "LessonSummaryResponse",
            "docstring": "O2 Result Shape for lessons.",
            "methods": [],
            "line": 636
          },
          {
            "name": "LessonsListResponse",
            "docstring": "GET /lessons response (O2).",
            "methods": [],
            "line": 649
          },
          {
            "name": "LessonDetailResponse",
            "docstring": "GET /lessons/{id} response (O3).",
            "methods": [],
            "line": 658
          },
          {
            "name": "LessonStatsResponse",
            "docstring": "Lesson statistics response.",
            "methods": [],
            "line": 678
          },
          {
            "name": "PolicyStateResponse",
            "docstring": "Policy layer state summary (ACT-O4).",
            "methods": [],
            "line": 835
          },
          {
            "name": "PolicyMetricsResponse",
            "docstring": "Policy enforcement metrics (ACT-O5).",
            "methods": [],
            "line": 892
          },
          {
            "name": "PolicyConflictResponse",
            "docstring": "Policy conflict summary (DFT-O4 spec).",
            "methods": [],
            "line": 955
          },
          {
            "name": "ConflictsListResponse",
            "docstring": "GET /conflicts response (DFT-O4).",
            "methods": [],
            "line": 969
          },
          {
            "name": "PolicyDependencyRelation",
            "docstring": "A dependency relationship detail.",
            "methods": [],
            "line": 1059
          },
          {
            "name": "PolicyNodeResponse",
            "docstring": "A node in the dependency graph (DFT-O5 spec).",
            "methods": [],
            "line": 1068
          },
          {
            "name": "PolicyDependencyEdge",
            "docstring": "A dependency edge in the graph.",
            "methods": [],
            "line": 1081
          },
          {
            "name": "DependencyGraphResponse",
            "docstring": "GET /dependencies response (DFT-O5).",
            "methods": [],
            "line": 1092
          },
          {
            "name": "PolicyViolationSummary",
            "docstring": "Policy violation summary (VIO-O1).",
            "methods": [],
            "line": 1205
          },
          {
            "name": "ViolationsListResponse",
            "docstring": "GET /violations response (VIO-O1).",
            "methods": [],
            "line": 1220
          },
          {
            "name": "BudgetDefinitionSummary",
            "docstring": "Budget definition summary (THR-O2).",
            "methods": [],
            "line": 1326
          },
          {
            "name": "BudgetsListResponse",
            "docstring": "GET /budgets response (THR-O2).",
            "methods": [],
            "line": 1340
          },
          {
            "name": "PolicyRequestSummary",
            "docstring": "Summary of a pending policy request (draft proposal).",
            "methods": [],
            "line": 1426
          },
          {
            "name": "PolicyRequestsListResponse",
            "docstring": "Response for policy requests list (ACT-O3).",
            "methods": [],
            "line": 1440
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Annotated",
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session_dep"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.policies_facade",
            "names": [
              "get_policies_facade"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [
          {
            "name": "_CURRENT_ENVIRONMENT",
            "line": 58
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "policy.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 2042,
        "module_docstring": "Policy API Endpoints (M5)\n\nProvides:\n1. Policy sandbox evaluation (/api/v1/policy/eval)\n2. Approval workflow endpoints (/api/v1/policy/requests/*)\n3. Webhook callbacks for async approvals\n\nIntegrates with:\n- PolicyEnforcer from workflow/policies.py\n- PolicyApprovalLevel and ApprovalRequest from db.py\n- Workflow metrics for observability\n- CostSim V2 for simulation\n\nNOTE: Policy subsystem MUST use AsyncSession - async endpoints + M17/M19 routing.\n      Do NOT import sync Session from sqlmodel. See test_m19_policy.py guardrail tests.\n\nTier Gating (M32 - PIN-158):\n- PREVENT ($199): Policy evaluation sandbox (pre-execution decisions)\n- ASSIST ($1.5k+): Approval workflows (advanced orchestration)",
        "functions": [
          {
            "name": "_get_policy_adapter",
            "signature": "()",
            "docstring": "Get the L3 policy adapter.\n\nThis is the ONLY way L2 should access policy functionality.\nF-P-RULE-1: Policy Decisions Live Only in L4.",
            "is_async": false,
            "line": 76
          },
          {
            "name": "_record_policy_decision",
            "signature": "(decision: str, policy_type: str) -> None",
            "docstring": "Record policy decision metric via L3 adapter.",
            "is_async": false,
            "line": 94
          },
          {
            "name": "_record_capability_violation",
            "signature": "(violation_type: str, skill_id: str, tenant_id: Optional[str] = None) -> None",
            "docstring": "Record capability violation metric via L3 adapter.",
            "is_async": false,
            "line": 100
          },
          {
            "name": "_record_budget_rejection",
            "signature": "(resource_type: str, skill_id: str) -> None",
            "docstring": "Record budget rejection metric via L3 adapter.",
            "is_async": false,
            "line": 106
          },
          {
            "name": "_record_approval_request_created",
            "signature": "(policy_type: str) -> None",
            "docstring": "Record approval request creation metric via L3 adapter.",
            "is_async": false,
            "line": 112
          },
          {
            "name": "_record_approval_action",
            "signature": "(result: str) -> None",
            "docstring": "Record approval action metric via L3 adapter.",
            "is_async": false,
            "line": 118
          },
          {
            "name": "_record_approval_escalation",
            "signature": "() -> None",
            "docstring": "Record approval escalation metric via L3 adapter.",
            "is_async": false,
            "line": 124
          },
          {
            "name": "_record_webhook_fallback",
            "signature": "() -> None",
            "docstring": "Record webhook fallback metric via L3 adapter.",
            "is_async": false,
            "line": 130
          },
          {
            "name": "_check_rate_limit",
            "signature": "(tenant_id: str, endpoint: str = 'policy') -> None",
            "docstring": "Check rate limit for tenant. Raises HTTPException if exceeded.\n\nArgs:\n    tenant_id: Tenant identifier for rate limiting\n    endpoint: Endpoint category for different limits\n\nRaises:\n    HTTPException: 429 if rate limit exceeded",
            "is_async": false,
            "line": 277
          },
          {
            "name": "_get_policy_version",
            "signature": "() -> str",
            "docstring": "Get current policy version.",
            "is_async": false,
            "line": 321
          },
          {
            "name": "_hash_webhook_secret",
            "signature": "(secret: str) -> str",
            "docstring": "Hash webhook secret for storage.",
            "is_async": false,
            "line": 326
          },
          {
            "name": "_get_approval_level_config",
            "signature": "(session: AsyncSession, policy_type: PolicyType, tenant_id: str, agent_id: Optional[str] = None, skill_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Get approval level configuration from PolicyApprovalLevel table.",
            "is_async": true,
            "line": 331
          },
          {
            "name": "_config_to_dict",
            "signature": "(config) -> Dict[str, Any]",
            "docstring": "Convert PolicyApprovalLevel to dict.",
            "is_async": false,
            "line": 370
          },
          {
            "name": "_simulate_cost",
            "signature": "(skill_id: str, tenant_id: str, payload: Dict[str, Any]) -> Optional[int]",
            "docstring": "Simulate cost for a skill execution via L3 adapter.\n\nPhase F-3: This replaces the direct L5 CostSimulator import.\nF-P-RULE-4: No Dual Ownership - CostSimulator logic stays intact in L5.",
            "is_async": true,
            "line": 381
          },
          {
            "name": "_check_policy_violations",
            "signature": "(skill_id: str, tenant_id: str, agent_id: Optional[str], payload: Dict[str, Any], simulated_cost: Optional[int]) -> List[Dict[str, Any]]",
            "docstring": "Check for policy violations via L3 adapter.\n\nPhase F-3: This replaces the direct L5 PolicyEnforcer import.\nF-P-RULE-1: Policy Decisions Live Only in L4 - L4 handles enforcement.\nF-P-RULE-2: Metrics Are Effects - L4 emits metrics via L5.",
            "is_async": true,
            "line": 396
          },
          {
            "name": "_compute_webhook_signature",
            "signature": "(payload: str, secret: str) -> str",
            "docstring": "Compute HMAC-SHA256 signature for webhook.",
            "is_async": false,
            "line": 416
          },
          {
            "name": "_send_webhook",
            "signature": "(url: str, payload: Dict[str, Any], secret: Optional[str] = None, key_version: Optional[str] = None, retry_count: int = 0) -> bool",
            "docstring": "Send webhook callback with retry logic and key versioning.\n\nArgs:\n    url: Webhook endpoint URL\n    payload: JSON payload to send\n    secret: HMAC secret for signing\n    key_version: Version of the key used for signing (for rotation support)\n    retry_count: Current retry attempt\n\nReturns:\n    True if webhook delivered successfully",
            "is_async": true,
            "line": 423
          },
          {
            "name": "verify_webhook_signature",
            "signature": "(body: str, signature: str, key_version: str, secrets: Dict[str, str]) -> bool",
            "docstring": "Verify webhook signature with version support for rotation.\n\nDuring key rotation, accepts signatures from:\n1. Current key version\n2. Any version in grace period (WEBHOOK_KEY_GRACE_VERSIONS)\n\nArgs:\n    body: Raw request body\n    signature: Signature from X-Webhook-Signature header (sha256=...)\n    key_version: Version from X-Webhook-Key-Version header\n    secrets: Dict mapping version -> secret\n\nReturns:\n    True if signature is valid",
            "is_async": false,
            "line": 478
          },
          {
            "name": "evaluate_policy",
            "signature": "(request: PolicyEvalRequest, session: AsyncSession = Depends(get_async_session), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('policy.audit'))) -> PolicyEvalResponse",
            "docstring": "Sandbox evaluation of policy for a skill execution.\n\n**Tier: PREVENT ($199)** - Pre-execution policy evaluation. \"You stop the fire.\"",
            "is_async": true,
            "line": 522
          },
          {
            "name": "create_approval_request",
            "signature": "(request: ApprovalRequestCreate, background_tasks: BackgroundTasks, session: AsyncSession = Depends(get_async_session)) -> ApprovalRequestResponse",
            "docstring": "Create a new approval request (persisted to DB).",
            "is_async": true,
            "line": 597
          },
          {
            "name": "get_approval_request",
            "signature": "(request_id: str, session: AsyncSession = Depends(get_async_session)) -> ApprovalStatusResponse",
            "docstring": "Get the current status of an approval request.",
            "is_async": true,
            "line": 674
          },
          {
            "name": "_check_approver_authorization",
            "signature": "(approver_id: str, level: int, tenant_id: Optional[str] = None) -> None",
            "docstring": "RBAC: Verify approver has permission to approve at the given level.\n\nUses the RBAC module when RBAC_ENABLED=true, otherwise allows all approvals.\n\nApproval Levels:\n- Level 1-2: Any authenticated user (team_member, engineer)\n- Level 3: Team lead, senior_engineer, tech_lead\n- Level 4: Manager, director, policy_admin\n- Level 5: Owner override (requires audit)\n\nRaises:\n    HTTPException: If approver lacks required permissions",
            "is_async": false,
            "line": 721
          },
          {
            "name": "approve_request",
            "signature": "(request_id: str, action: ApprovalAction, background_tasks: BackgroundTasks, session: AsyncSession = Depends(get_async_session)) -> ApprovalStatusResponse",
            "docstring": "Approve an approval request.",
            "is_async": true,
            "line": 795
          },
          {
            "name": "reject_request",
            "signature": "(request_id: str, action: ApprovalAction, background_tasks: BackgroundTasks, session: AsyncSession = Depends(get_async_session)) -> ApprovalStatusResponse",
            "docstring": "Reject an approval request.",
            "is_async": true,
            "line": 862
          },
          {
            "name": "list_approval_requests",
            "signature": "(status: Optional[ApprovalStatus] = None, tenant_id: Optional[str] = None, limit: int = 50, offset: int = 0, session: AsyncSession = Depends(get_async_session)) -> List[ApprovalStatusResponse]",
            "docstring": "List approval requests with optional filtering.",
            "is_async": true,
            "line": 909
          },
          {
            "name": "run_escalation_check",
            "signature": "(session: AsyncSession) -> int",
            "docstring": "Check for pending requests that need escalation.\nCalled by external scheduler (cron/celery).",
            "is_async": true,
            "line": 981
          },
          {
            "name": "run_escalation_task",
            "signature": "()",
            "docstring": "Entry point for scheduled escalation check.\nCan be called from cron, celery, or APScheduler.",
            "is_async": false,
            "line": 1042
          },
          {
            "name": "_build_policy_metadata_from_rule",
            "signature": "(rule) -> PolicyMetadata",
            "docstring": "Build PolicyMetadata from a PolicyRule model instance.\n\nMaps available model fields to governance metadata schema.\nFields not in the model are left as None (to be populated when\nthe underlying schema evolves).",
            "is_async": false,
            "line": 1124
          },
          {
            "name": "_build_policy_metadata_from_limit",
            "signature": "(limit) -> PolicyMetadata",
            "docstring": "Build PolicyMetadata from a Limit model instance.\n\nMaps available model fields to governance metadata schema.",
            "is_async": false,
            "line": 1145
          },
          {
            "name": "_build_policy_metadata_from_violation",
            "signature": "(v) -> PolicyMetadata",
            "docstring": "Build PolicyMetadata from a violation object (from policy engine).\n\nViolations are system-generated enforcement events.",
            "is_async": false,
            "line": 1164
          },
          {
            "name": "_build_policy_metadata_from_lesson",
            "signature": "(lesson: dict) -> PolicyMetadata",
            "docstring": "Build PolicyMetadata from a lesson dict (from lessons_learned_engine).\n\nMaps available dict fields to governance metadata schema.",
            "is_async": false,
            "line": 1183
          },
          {
            "name": "get_active_policies",
            "signature": "(scope: Optional[str] = None, enforcement_mode: Optional[str] = None, limit: int = 50, offset: int = 0, session: AsyncSession = Depends(get_async_session), ctx: TenantContext = Depends(get_tenant_context)) -> ActivePoliciesResponse",
            "docstring": "V2 Facade: What governs execution now?",
            "is_async": true,
            "line": 1363
          },
          {
            "name": "get_active_policy_detail",
            "signature": "(policy_id: str, session: AsyncSession = Depends(get_async_session), ctx: TenantContext = Depends(get_tenant_context)) -> dict",
            "docstring": "V2 Facade: Policy detail for cross-domain navigation.",
            "is_async": true,
            "line": 1450
          },
          {
            "name": "get_policy_library",
            "signature": "(status: Optional[str] = None, rule_type: Optional[str] = None, limit: int = 50, offset: int = 0, session: AsyncSession = Depends(get_async_session), ctx: TenantContext = Depends(get_tenant_context)) -> PolicyLibraryResponse",
            "docstring": "V2 Facade: What patterns are available?",
            "is_async": true,
            "line": 1527
          },
          {
            "name": "get_policy_lessons",
            "signature": "(status: Optional[str] = None, lesson_type: Optional[str] = None, limit: int = 50, offset: int = 0, ctx: TenantContext = Depends(get_tenant_context)) -> LessonsResponse",
            "docstring": "V2 Facade: What governance emerged?",
            "is_async": true,
            "line": 1610
          },
          {
            "name": "get_policy_lesson_detail",
            "signature": "(lesson_id: str, ctx: TenantContext = Depends(get_tenant_context)) -> dict",
            "docstring": "V2 Facade: Lesson detail for cross-domain navigation.",
            "is_async": true,
            "line": 1674
          },
          {
            "name": "get_policy_thresholds",
            "signature": "(limit_category: Optional[str] = None, scope: Optional[str] = None, status: str = 'ACTIVE', limit: int = 50, offset: int = 0, session: AsyncSession = Depends(get_async_session), ctx: TenantContext = Depends(get_tenant_context)) -> ThresholdsResponse",
            "docstring": "V2 Facade: What limits are enforced?",
            "is_async": true,
            "line": 1740
          },
          {
            "name": "get_policy_threshold_detail",
            "signature": "(threshold_id: str, session: AsyncSession = Depends(get_async_session), ctx: TenantContext = Depends(get_tenant_context)) -> dict",
            "docstring": "V2 Facade: Threshold detail for cross-domain navigation.",
            "is_async": true,
            "line": 1824
          },
          {
            "name": "get_policy_violations_v2",
            "signature": "(violation_type: Optional[str] = None, severity_min: Optional[float] = None, hours: int = 24, limit: int = 50, offset: int = 0, session: AsyncSession = Depends(get_async_session), ctx: TenantContext = Depends(get_tenant_context)) -> ViolationsResponse",
            "docstring": "V2 Facade: What enforcement occurred?",
            "is_async": true,
            "line": 1905
          },
          {
            "name": "get_policy_violation_detail",
            "signature": "(violation_id: str, session: AsyncSession = Depends(get_async_session), ctx: TenantContext = Depends(get_tenant_context)) -> dict",
            "docstring": "V2 Facade: Violation detail for cross-domain navigation.",
            "is_async": true,
            "line": 1985
          }
        ],
        "classes": [
          {
            "name": "PolicyType",
            "docstring": "Types of policies that can be evaluated.",
            "methods": [],
            "line": 141
          },
          {
            "name": "ApprovalStatus",
            "docstring": "Status of an approval request.",
            "methods": [],
            "line": 150
          },
          {
            "name": "PolicyEvalRequest",
            "docstring": "Request for policy sandbox evaluation.",
            "methods": [],
            "line": 161
          },
          {
            "name": "PolicyEvalResponse",
            "docstring": "Response from policy sandbox evaluation.",
            "methods": [],
            "line": 172
          },
          {
            "name": "ApprovalRequestCreate",
            "docstring": "Request to create an approval request.",
            "methods": [],
            "line": 184
          },
          {
            "name": "ApprovalRequestResponse",
            "docstring": "Response when creating an approval request.",
            "methods": [],
            "line": 199
          },
          {
            "name": "ApprovalAction",
            "docstring": "Action to approve or reject a request.",
            "methods": [],
            "line": 210
          },
          {
            "name": "ApprovalStatusResponse",
            "docstring": "Full status of an approval request.",
            "methods": [],
            "line": 218
          },
          {
            "name": "PolicyMetadata",
            "docstring": "Governance metadata for policy artifacts (aos_sdk-grade).\n\nSTATUS: DECLARED (PARTIALLY MATERIALIZED)\nReference: docs/contracts/CROSS_DOMAIN_INVARIANTS.md Section IX\nMaturity: docs/contracts/METADATA_MATURITY.md\n\nProvides provenance, lifecycle, and accountability traceability\nfor cross-domain consumers per CROSS_DOMAIN_INVARIANTS.md.\n\nNULL SEMANTICS (INV-META-NULL-001):\n===================================\nA null field means \"NOT YET MATERIALIZED\", not \"NOT APPLICABLE\" or \"DENIED\".\nConsumers MUST NOT:\n- Branch on `field is None` to infer absence\n- Treat null as negative truth (e.g., null approved_by \u2260 rejected)\n- Auto-populate nulls with system actors\n\nFIELD CLASSIFICATION:\n=====================\nClass A (Immutable Provenance) \u2014 DB-backed, never changes once written:\n  - created_by, created_at, origin, source_proposal_id\n\nClass B (Governance Decisions) \u2014 Human-gated, requires workflow:\n  - approved_by, approved_at (null until proposal workflow is real)\n\nClass C (Temporal Validity) \u2014 Required before historical analytics:\n  - effective_from, effective_until (default: effective_from = created_at)",
            "methods": [],
            "line": 1075
          },
          {
            "name": "PolicyContextSummary",
            "docstring": "Summary of an active policy for cross-domain consumption.",
            "methods": [],
            "line": 1219
          },
          {
            "name": "ActivePoliciesResponse",
            "docstring": "GET /policy/active response \u2014 What governs execution now?",
            "methods": [],
            "line": 1235
          },
          {
            "name": "PolicyLibrarySummary",
            "docstring": "Summary of a policy rule in the library.",
            "methods": [],
            "line": 1245
          },
          {
            "name": "PolicyLibraryResponse",
            "docstring": "GET /policy/library response \u2014 What patterns are available?",
            "methods": [],
            "line": 1261
          },
          {
            "name": "PolicyLessonSummary",
            "docstring": "Summary of a lesson or draft for cross-domain consumption.",
            "methods": [],
            "line": 1269
          },
          {
            "name": "LessonsResponse",
            "docstring": "GET /policy/lessons response \u2014 What governance emerged?",
            "methods": [],
            "line": 1285
          },
          {
            "name": "ThresholdSummary",
            "docstring": "Summary of an enforced limit/threshold.",
            "methods": [],
            "line": 1295
          },
          {
            "name": "ThresholdsResponse",
            "docstring": "GET /policy/thresholds response \u2014 What limits are enforced?",
            "methods": [],
            "line": 1311
          },
          {
            "name": "ViolationSummary",
            "docstring": "Summary of a policy violation for cross-domain consumption.",
            "methods": [],
            "line": 1319
          },
          {
            "name": "ViolationsResponse",
            "docstring": "GET /policy/violations response \u2014 What enforcement occurred?",
            "methods": [],
            "line": 1336
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "cast"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "BackgroundTasks",
              "Depends",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "TenantTier",
              "requires_feature",
              "requires_tier"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.db_async",
            "names": [
              "get_async_session"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 64
          }
        ],
        "constants": [
          {
            "name": "WEBHOOK_MAX_RETRIES",
            "line": 247
          },
          {
            "name": "WEBHOOK_RETRY_DELAYS",
            "line": 248
          },
          {
            "name": "WEBHOOK_CURRENT_KEY_VERSION",
            "line": 257
          },
          {
            "name": "WEBHOOK_KEY_GRACE_VERSIONS",
            "line": 264
          },
          {
            "name": "WEBHOOK_KEY_GRACE_VERSIONS",
            "line": 265
          },
          {
            "name": "RATE_LIMIT_ENABLED",
            "line": 272
          },
          {
            "name": "RATE_LIMIT_DEFAULT_RPM",
            "line": 273
          },
          {
            "name": "RATE_LIMIT_BURST_RPM",
            "line": 274
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "policy_layer.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy_layer.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1465,
        "module_docstring": null,
        "functions": [
          {
            "name": "evaluate_action",
            "signature": "(request: EvaluateRequest, db: AsyncSession = Depends(get_async_session)) -> PolicyEvaluationResult",
            "docstring": "Evaluate a proposed action against all applicable policies.\n\nThis is the primary endpoint that agents MUST call before:\n- Routing decisions (CARE)\n- Task/skill execution\n- Strategy adaptation (SBA)\n- Escalation to humans\n- Self-modification\n- Agent spawning/invocation\n- Data access\n- External API calls\n\nReturns ALLOW, BLOCK, or MODIFY with detailed reasoning.",
            "is_async": true,
            "line": 138
          },
          {
            "name": "simulate_evaluation",
            "signature": "(request: SimulateRequest, db: AsyncSession = Depends(get_async_session)) -> PolicyEvaluationResult",
            "docstring": "Simulate policy evaluation without side effects.\n\nUseful for:\n- Testing policy configurations\n- Debugging why actions are blocked\n- Pre-flight checks before batch operations\n\nDoes NOT:\n- Record the evaluation\n- Update risk ceiling counters\n- Create violation records\n- Route to governor",
            "is_async": true,
            "line": 178
          },
          {
            "name": "get_policy_state",
            "signature": "(db: AsyncSession = Depends(get_async_session)) -> PolicyState",
            "docstring": "Get the current state of the policy layer.\n\nReturns summary of:\n- Active policies by category\n- Evaluation statistics\n- Violation counts\n- Risk ceiling status",
            "is_async": true,
            "line": 214
          },
          {
            "name": "reload_policies",
            "signature": "(db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Hot-reload policies from database.\n\nUse this after updating policies to apply changes immediately\nwithout restarting the service.",
            "is_async": true,
            "line": 232
          },
          {
            "name": "list_violations",
            "signature": "(violation_type: Optional[ViolationType] = None, agent_id: Optional[str] = None, tenant_id: Optional[str] = None, severity_min: Optional[float] = Query(None, ge=0.0, le=1.0), hours: int = Query(24, ge=1, le=720), limit: int = Query(100, ge=1, le=1000), db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "List policy violations with filtering.\n\nDefault: violations from last 24 hours.",
            "is_async": true,
            "line": 261
          },
          {
            "name": "get_violation",
            "signature": "(violation_id: str, db: AsyncSession = Depends(get_async_session)) -> PolicyViolation",
            "docstring": "Get a specific violation by ID.",
            "is_async": true,
            "line": 291
          },
          {
            "name": "acknowledge_violation",
            "signature": "(violation_id: str, notes: Optional[str] = None, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Acknowledge a violation (mark as reviewed).\n\nThis does NOT dismiss the violation - it records that\na human has reviewed it.",
            "is_async": true,
            "line": 304
          },
          {
            "name": "list_risk_ceilings",
            "signature": "(tenant_id: Optional[str] = None, include_inactive: bool = False, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "List all risk ceilings with current values.",
            "is_async": true,
            "line": 328
          },
          {
            "name": "get_risk_ceiling",
            "signature": "(ceiling_id: str, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Get a specific risk ceiling with current utilization.",
            "is_async": true,
            "line": 355
          },
          {
            "name": "update_risk_ceiling",
            "signature": "(ceiling_id: str, update: RiskCeilingUpdate, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Update a risk ceiling configuration.",
            "is_async": true,
            "line": 382
          },
          {
            "name": "reset_risk_ceiling",
            "signature": "(ceiling_id: str, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Reset a risk ceiling's current value to 0.",
            "is_async": true,
            "line": 402
          },
          {
            "name": "list_safety_rules",
            "signature": "(tenant_id: Optional[str] = None, include_inactive: bool = False, db: AsyncSession = Depends(get_async_session)) -> List[Dict[str, Any]]",
            "docstring": "List all safety rules.",
            "is_async": true,
            "line": 421
          },
          {
            "name": "update_safety_rule",
            "signature": "(rule_id: str, update: SafetyRuleUpdate, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Update a safety rule configuration.",
            "is_async": true,
            "line": 446
          },
          {
            "name": "list_ethical_constraints",
            "signature": "(include_inactive: bool = False, db: AsyncSession = Depends(get_async_session)) -> List[Dict[str, Any]]",
            "docstring": "List all ethical constraints.",
            "is_async": true,
            "line": 470
          },
          {
            "name": "list_active_cooldowns",
            "signature": "(agent_id: Optional[str] = None, db: AsyncSession = Depends(get_async_session)) -> List[CooldownInfo]",
            "docstring": "List all active cooldowns.",
            "is_async": true,
            "line": 498
          },
          {
            "name": "clear_cooldowns",
            "signature": "(agent_id: str, rule_name: Optional[str] = None, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Clear cooldowns for an agent.\n\nUse with caution - bypasses safety cooldowns.",
            "is_async": true,
            "line": 509
          },
          {
            "name": "get_policy_metrics",
            "signature": "(hours: int = Query(24, ge=1, le=720), db: AsyncSession = Depends(get_async_session)) -> PolicyMetrics",
            "docstring": "Get policy engine metrics for the specified time window.",
            "is_async": true,
            "line": 530
          },
          {
            "name": "evaluate_batch",
            "signature": "(requests: List[EvaluateRequest], db: AsyncSession = Depends(get_async_session)) -> List[PolicyEvaluationResult]",
            "docstring": "Evaluate multiple actions in a single call.\n\nUseful for pre-flight checks on batch operations.\nLimited to 50 requests per batch.",
            "is_async": true,
            "line": 546
          },
          {
            "name": "list_policy_versions",
            "signature": "(limit: int = Query(20, ge=1, le=100), include_inactive: bool = False, db: AsyncSession = Depends(get_async_session)) -> List[Dict[str, Any]]",
            "docstring": "List all policy versions.\n\nReturns version history for audit and rollback purposes.",
            "is_async": true,
            "line": 601
          },
          {
            "name": "get_current_version",
            "signature": "(db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Get the currently active policy version.\n\nThis is the version being used for all evaluations.",
            "is_async": true,
            "line": 617
          },
          {
            "name": "create_policy_version",
            "signature": "(request: CreateVersionRequest, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Create a new policy version snapshot.\n\nThis captures the current state of all policies for audit\nand potential rollback.",
            "is_async": true,
            "line": 633
          },
          {
            "name": "rollback_to_version",
            "signature": "(request: RollbackRequest, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Rollback to a previous policy version.\n\nThis restores all policies to the state captured in\nthe specified version.",
            "is_async": true,
            "line": 658
          },
          {
            "name": "get_version_provenance",
            "signature": "(version_id: str, db: AsyncSession = Depends(get_async_session)) -> List[Dict[str, Any]]",
            "docstring": "Get the provenance (change history) for a policy version.\n\nShows what changes were made and by whom.",
            "is_async": true,
            "line": 683
          },
          {
            "name": "get_dependency_graph",
            "signature": "(db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Get the policy dependency graph.\n\nShows relationships and potential conflicts between policies.",
            "is_async": true,
            "line": 703
          },
          {
            "name": "list_conflicts",
            "signature": "(include_resolved: bool = False, db: AsyncSession = Depends(get_async_session)) -> List[Dict[str, Any]]",
            "docstring": "List policy conflicts.\n\nConflicts occur when policies have contradictory rules.",
            "is_async": true,
            "line": 744
          },
          {
            "name": "resolve_conflict",
            "signature": "(conflict_id: str, request: ResolveConflictRequest, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Resolve a policy conflict.\n\nDocuments how the conflict should be handled during evaluation.",
            "is_async": true,
            "line": 781
          },
          {
            "name": "list_temporal_policies",
            "signature": "(metric: Optional[str] = None, include_inactive: bool = False, db: AsyncSession = Depends(get_async_session)) -> List[Dict[str, Any]]",
            "docstring": "List temporal (sliding window) policies.\n\nThese policies track cumulative metrics over time windows.",
            "is_async": true,
            "line": 826
          },
          {
            "name": "create_temporal_policy",
            "signature": "(request: TemporalPolicyCreate, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Create a new temporal policy.\n\nTemporal policies track cumulative metrics over sliding windows.",
            "is_async": true,
            "line": 856
          },
          {
            "name": "get_temporal_utilization",
            "signature": "(policy_id: str, agent_id: Optional[str] = None, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Get current utilization for a temporal policy.\n\nShows how much of the limit has been consumed in the current window.",
            "is_async": true,
            "line": 876
          },
          {
            "name": "evaluate_with_context",
            "signature": "(request: ContextAwareEvaluateRequest, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Context-aware policy evaluation (GAP 4).\n\nEvaluates with full agent/tenant context, action chain tracking,\nand temporal policy awareness. Returns updated context for\nuse in subsequent evaluations.",
            "is_async": true,
            "line": 926
          },
          {
            "name": "validate_dependency_dag",
            "signature": "(db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Validate that policy dependencies form a valid DAG.\n\nChecks for cycles in the dependency graph. Cycles cause:\n- Infinite recursion in override resolution\n- Oscillation in dependency evaluation\n- Rule folding failures\n- MODIFY rule loops\n\nReturns:\n- is_dag: True if graph is acyclic\n- cycles: List of detected cycles (if any)\n- topological_order: Evaluation order (if DAG is valid)",
            "is_async": true,
            "line": 1000
          },
          {
            "name": "add_dependency_with_dag_check",
            "signature": "(request: AddDependencyRequest, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Add a policy dependency with DAG validation.\n\nBlocks the addition if it would create a cycle in the\ndependency graph. This ensures the graph remains a\nvalid DAG (Directed Acyclic Graph).\n\nReturns:\n- success: True if added\n- error: Error message if blocked due to cycle\n- blocked: True if cycle detected\n- cycle_path: The path that would form a cycle",
            "is_async": true,
            "line": 1034
          },
          {
            "name": "get_evaluation_order",
            "signature": "(db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Get the topological evaluation order for policies.\n\nReturns the order in which policies should be evaluated\nbased on their dependencies. Policies that depend on\nothers are evaluated after their dependencies.",
            "is_async": true,
            "line": 1077
          },
          {
            "name": "prune_temporal_metrics",
            "signature": "(request: PruneTemporalMetricsRequest, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Prune and compact temporal metric events.\n\nThis prevents storage explosion by:\n1. Deleting events older than retention period\n2. Downsampling older events to hourly aggregates\n3. Capping maximum events per policy\n\nShould be run periodically (e.g., via cron job).",
            "is_async": true,
            "line": 1119
          },
          {
            "name": "get_temporal_storage_stats",
            "signature": "(db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Get storage statistics for temporal metrics.\n\nUse this to monitor storage growth and determine\nwhen pruning is needed.",
            "is_async": true,
            "line": 1148
          },
          {
            "name": "activate_policy_version",
            "signature": "(request: ActivateVersionRequest, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Activate a policy version with pre-activation integrity checks.\n\nPerforms comprehensive checks before activation:\n1. Dependency closure - all dependencies exist\n2. Conflict scan - no unresolved critical conflicts\n3. DAG validation - no cycles\n4. Temporal integrity - valid window configurations\n5. Severity compatibility - escalation paths exist\n6. Simulation - dry-run against test cases\n\nUse dry_run=True to test without activating.\n\nReturns:\n- success: True if activated (or would be, for dry_run)\n- all_checks_passed: True if all integrity checks pass\n- checks: Detailed results of each check\n- activated_version: The version that was activated",
            "is_async": true,
            "line": 1176
          },
          {
            "name": "check_version_integrity",
            "signature": "(version_id: str, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Run integrity checks on a version without activating.\n\nShortcut for activate with dry_run=True.\nUseful for validating a version before scheduling activation.",
            "is_async": true,
            "line": 1223
          },
          {
            "name": "list_lessons",
            "signature": "(tenant_id: Optional[str] = None, lesson_type: Optional[str] = Query(None, description='Filter: failure, near_threshold, critical_success'), status: Optional[str] = Query(None, description='Filter: pending, converted_to_draft, deferred, dismissed'), severity: Optional[str] = Query(None, description='Filter: CRITICAL, HIGH, MEDIUM, LOW'), limit: int = Query(50, ge=1, le=500), offset: int = Query(0, ge=0), db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "List lessons learned.\n\nReturns lessons with optional filtering by type, status, and severity.\nThis endpoint is for the policy-layer (L3) - internal use.\n\nReference: PIN-411, POLICIES_DOMAIN_AUDIT.md Section 11",
            "is_async": true,
            "line": 1268
          },
          {
            "name": "get_lesson_stats",
            "signature": "(tenant_id: str, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Get lesson statistics for a tenant.\n\nReturns counts by type and status.\n\nReference: PIN-411",
            "is_async": true,
            "line": 1315
          },
          {
            "name": "get_lesson",
            "signature": "(lesson_id: str, tenant_id: str, db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Get a specific lesson by ID.\n\nReturns detailed lesson information.\n\nReference: PIN-411",
            "is_async": true,
            "line": 1336
          },
          {
            "name": "convert_lesson_to_draft",
            "signature": "(lesson_id: str, request: LessonConvertRequest, tenant_id: str = Query(..., description='Tenant ID'), db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Convert a lesson to a draft policy proposal.\n\nCreates a new draft proposal and updates the lesson status.\nPB-S4 compliant: drafts require human approval.\n\nReference: PIN-411, PB-S4",
            "is_async": true,
            "line": 1362
          },
          {
            "name": "defer_lesson",
            "signature": "(lesson_id: str, request: LessonDeferRequest, tenant_id: str = Query(..., description='Tenant ID'), db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Defer a lesson until a future date.\n\nThe lesson will resurface for review after the defer date.\n\nReference: PIN-411",
            "is_async": true,
            "line": 1398
          },
          {
            "name": "dismiss_lesson",
            "signature": "(lesson_id: str, request: LessonDismissRequest, tenant_id: str = Query(..., description='Tenant ID'), db: AsyncSession = Depends(get_async_session)) -> Dict[str, Any]",
            "docstring": "Dismiss a lesson (mark as not actionable).\n\nDismissed lessons are preserved for audit but won't resurface.\n\nReference: PIN-411",
            "is_async": true,
            "line": 1433
          }
        ],
        "classes": [
          {
            "name": "EvaluateRequest",
            "docstring": "Request to evaluate an action against policies.",
            "methods": [],
            "line": 49
          },
          {
            "name": "SimulateRequest",
            "docstring": "Request to simulate policy evaluation (dry run).",
            "methods": [],
            "line": 65
          },
          {
            "name": "ViolationQuery",
            "docstring": "Query parameters for violations.",
            "methods": [],
            "line": 80
          },
          {
            "name": "RiskCeilingUpdate",
            "docstring": "Update for a risk ceiling.",
            "methods": [],
            "line": 91
          },
          {
            "name": "SafetyRuleUpdate",
            "docstring": "Update for a safety rule.",
            "methods": [],
            "line": 100
          },
          {
            "name": "CooldownInfo",
            "docstring": "Information about an active cooldown.",
            "methods": [],
            "line": 109
          },
          {
            "name": "PolicyMetrics",
            "docstring": "Metrics from the policy engine.",
            "methods": [],
            "line": 119
          },
          {
            "name": "CreateVersionRequest",
            "docstring": "Request to create a new policy version.",
            "methods": [],
            "line": 585
          },
          {
            "name": "RollbackRequest",
            "docstring": "Request to rollback to a previous version.",
            "methods": [],
            "line": 592
          },
          {
            "name": "ResolveConflictRequest",
            "docstring": "Request to resolve a policy conflict.",
            "methods": [],
            "line": 773
          },
          {
            "name": "TemporalPolicyCreate",
            "docstring": "Request to create a temporal policy.",
            "methods": [],
            "line": 810
          },
          {
            "name": "ContextAwareEvaluateRequest",
            "docstring": "Request for context-aware policy evaluation (GAP 4).",
            "methods": [],
            "line": 896
          },
          {
            "name": "AddDependencyRequest",
            "docstring": "Request to add a policy dependency with DAG validation.",
            "methods": [],
            "line": 1022
          },
          {
            "name": "PruneTemporalMetricsRequest",
            "docstring": "Request to prune temporal metrics.",
            "methods": [],
            "line": 1110
          },
          {
            "name": "ActivateVersionRequest",
            "docstring": "Request to activate a policy version.",
            "methods": [],
            "line": 1167
          },
          {
            "name": "LessonConvertRequest",
            "docstring": "Request to convert a lesson to draft proposal.",
            "methods": [],
            "line": 1248
          },
          {
            "name": "LessonDeferRequest",
            "docstring": "Request to defer a lesson.",
            "methods": [],
            "line": 1254
          },
          {
            "name": "LessonDismissRequest",
            "docstring": "Request to dismiss a lesson.",
            "methods": [],
            "line": 1260
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "app.db_async",
            "names": [
              "get_async_session"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.policy",
            "names": [
              "ActionType",
              "PolicyEvaluationRequest",
              "PolicyEvaluationResult",
              "PolicyState",
              "PolicyViolation",
              "ViolationType"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.policy_driver",
            "names": [
              "get_policy_facade"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_limits_crud.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy_limits_crud.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 539,
        "module_docstring": "Policy Limits CRUD API (PIN-LIM-01)\n\nMutating endpoints for policy limits.\n\nExtends the read-only policies.py facade with write operations.\n\nEndpoints:\n    POST   /api/v1/policies/limits              \u2192 Create limit\n    PUT    /api/v1/policies/limits/{limit_id}   \u2192 Update limit\n    DELETE /api/v1/policies/limits/{limit_id}   \u2192 Soft-delete limit",
        "functions": [
          {
            "name": "create_limit",
            "signature": "(request: Request, body: CreateLimitRequest, session: AsyncSession = Depends(get_async_session_dep)) -> LimitDetail",
            "docstring": "Create a new policy limit.\n\n- Category and type are immutable after creation\n- BUDGET limits require reset_period\n- RATE limits require window_seconds",
            "is_async": true,
            "line": 168
          },
          {
            "name": "update_limit",
            "signature": "(request: Request, limit_id: str, body: UpdateLimitRequest, session: AsyncSession = Depends(get_async_session_dep)) -> LimitDetail",
            "docstring": "Update an existing policy limit.\n\n- Category and type are immutable (cannot be changed)\n- Other fields can be updated",
            "is_async": true,
            "line": 237
          },
          {
            "name": "delete_limit",
            "signature": "(request: Request, limit_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> None",
            "docstring": "Soft-delete a policy limit.\n\nSets status to DISABLED. The limit is not actually removed.",
            "is_async": true,
            "line": 307
          },
          {
            "name": "get_threshold_params",
            "signature": "(request: Request, limit_id: str, session: AsyncSession = Depends(get_async_session_dep)) -> ThresholdParamsResponse",
            "docstring": "Get threshold parameters for a limit.\n\nReturns both raw params and effective params (with defaults applied).\nOnly valid for limits with limit_category = THRESHOLD.",
            "is_async": true,
            "line": 353
          },
          {
            "name": "set_threshold_params",
            "signature": "(request: Request, limit_id: str, body: ThresholdParamsRequest, session: AsyncSession = Depends(get_async_session_dep)) -> ThresholdParamsResponse",
            "docstring": "Set threshold parameters for a limit.\n\nThis is the authoritative input surface for:\n- Policies \u2192 Limits \u2192 Thresholds \u2192 Set Params panel\n\nThese params drive LLM run governance signals.\n\nValidation Rules (Hard Stop):\n- max_execution_time_ms: 1000-300000 (1s to 5min)\n- max_tokens: 256-200000\n- max_cost_usd: 0.01-100.00\n- failure_signal: boolean\n\nNo partial garbage. No unknown keys. No absurd values.",
            "is_async": true,
            "line": 419
          },
          {
            "name": "_to_detail",
            "signature": "(result: PolicyLimitResponse) -> LimitDetail",
            "docstring": "Convert service response to API response.",
            "is_async": false,
            "line": 521
          }
        ],
        "classes": [
          {
            "name": "CreateLimitRequest",
            "docstring": "API request to create a policy limit.",
            "methods": [],
            "line": 62
          },
          {
            "name": "UpdateLimitRequest",
            "docstring": "API request to update a policy limit.",
            "methods": [],
            "line": 77
          },
          {
            "name": "ThresholdParamsRequest",
            "docstring": "API request to set execution threshold parameters.\n\nUsed for: Policies \u2192 Limits \u2192 Thresholds \u2192 Set Params panel.\n\nThese params drive LLM run governance:\n- Activity \u2192 LLM Runs \u2192 Live \u2192 Signals\n- Activity \u2192 LLM Runs \u2192 Completed \u2192 Signals",
            "methods": [],
            "line": 89
          },
          {
            "name": "ThresholdParamsResponse",
            "docstring": "Response with effective threshold params.",
            "methods": [],
            "line": 126
          },
          {
            "name": "LimitDetail",
            "docstring": "Full limit response.",
            "methods": [],
            "line": 136
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session_dep"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.schemas.limits.policy_limits",
            "names": [
              "CreatePolicyLimitRequest",
              "LimitCategoryEnum",
              "LimitEnforcementEnum",
              "LimitScopeEnum",
              "PolicyLimitResponse",
              "ResetPeriodEnum",
              "UpdatePolicyLimitRequest"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.policy_limits_engine",
            "names": [
              "ImmutableFieldError",
              "LimitNotFoundError",
              "LimitValidationError",
              "PolicyLimitsService",
              "PolicyLimitsServiceError"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_proposals.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy_proposals.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 465,
        "module_docstring": "PB-S4 Policy Proposals API\n\nExposes policy_proposals and policy_versions data with human-controlled approval.\n\nPB-S4 Contract:\n- Policies are proposed, never auto-enforced\n- Human approval is mandatory\n- Proposals have provenance to triggering feedback\n- Rejection preserved for audit trail\n\nO1: API endpoint exists \u2713\nO2: List visible with pagination \u2713\nO3: Detail accessible \u2713\nO4: Approve/Reject actions (human-controlled) \u2713 (PIN-373)",
        "functions": [
          {
            "name": "list_proposals",
            "signature": "(request: Request, tenant_id: Optional[str] = Query(None, description='Filter by tenant'), status: Optional[str] = Query(None, description='Filter by status (draft/approved/rejected)'), proposal_type: Optional[str] = Query(None, description='Filter by proposal type'), limit: int = Query(50, ge=1, le=200, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'))",
            "docstring": "List policy proposals (PB-S4).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 119
          },
          {
            "name": "get_proposal_stats",
            "signature": "(request: Request, tenant_id: Optional[str] = Query(None, description='Filter by tenant'))",
            "docstring": "Get policy proposal statistics (PB-S4).\n\nREAD-ONLY: This endpoint only reads aggregated data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 190
          },
          {
            "name": "get_proposal",
            "signature": "(request: Request, proposal_id: str)",
            "docstring": "Get detailed policy proposal by ID (PB-S4).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 237
          },
          {
            "name": "list_proposal_versions",
            "signature": "(request: Request, proposal_id: str)",
            "docstring": "List all versions of a policy proposal (PB-S4).\n\nREAD-ONLY: This endpoint only reads data.\nShows the evolution of a policy through approvals.",
            "is_async": true,
            "line": 297
          },
          {
            "name": "approve_proposal",
            "signature": "(http_request: Request, proposal_id: str, request: ApproveRejectRequest, role: TenantRole = Depends(require_role(TenantRole.MEMBER, TenantRole.ADMIN, TenantRole.OWNER)))",
            "docstring": "Approve a policy proposal (PIN-373).\n\nHUMAN ACTION: This creates a policy_rules entry when approved.\nOnly draft proposals can be approved.\n\nPB-S4 Contract: Human approval is mandatory - system cannot auto-approve.",
            "is_async": true,
            "line": 357
          },
          {
            "name": "reject_proposal",
            "signature": "(http_request: Request, proposal_id: str, request: ApproveRejectRequest, role: TenantRole = Depends(require_role(TenantRole.MEMBER, TenantRole.ADMIN, TenantRole.OWNER)))",
            "docstring": "Reject a policy proposal (PIN-373).\n\nHUMAN ACTION: This marks the proposal as rejected.\nRejection is preserved for audit trail.\nOnly draft proposals can be rejected.\n\nPB-S4 Contract: Human decision is mandatory - system cannot auto-reject.",
            "is_async": true,
            "line": 412
          }
        ],
        "classes": [
          {
            "name": "ProposalSummaryResponse",
            "docstring": "Summary of a policy proposal.",
            "methods": [],
            "line": 55
          },
          {
            "name": "ProposalListResponse",
            "docstring": "Paginated list of policy proposals.",
            "methods": [],
            "line": 71
          },
          {
            "name": "ProposalDetailResponse",
            "docstring": "Detailed policy proposal record.",
            "methods": [],
            "line": 82
          },
          {
            "name": "VersionResponse",
            "docstring": "Policy version record.",
            "methods": [],
            "line": 101
          },
          {
            "name": "ApproveRejectRequest",
            "docstring": "Request body for approve/reject actions.",
            "methods": [],
            "line": 339
          },
          {
            "name": "ApprovalResponse",
            "docstring": "Response for approve/reject actions.",
            "methods": [],
            "line": 346
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": true,
            "line": 37
          },
          {
            "module": "auth.role_guard",
            "names": [
              "require_role"
            ],
            "is_relative": true,
            "line": 38
          },
          {
            "module": "auth.tenant_roles",
            "names": [
              "TenantRole"
            ],
            "is_relative": true,
            "line": 39
          },
          {
            "module": "db",
            "names": [
              "get_async_session"
            ],
            "is_relative": true,
            "line": 40
          },
          {
            "module": "models.policy",
            "names": [
              "PolicyApprovalRequest",
              "PolicyProposal",
              "PolicyVersion"
            ],
            "is_relative": true,
            "line": 41
          },
          {
            "module": "schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": true,
            "line": 42
          },
          {
            "module": "services.policy_proposal",
            "names": [
              "review_policy_proposal"
            ],
            "is_relative": true,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_rules_crud.py",
        "file_path": "backend/app/hoc/api/cus/policies/policy_rules_crud.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 263,
        "module_docstring": "Policy Rules CRUD API (PIN-LIM-02)\n\nMutating endpoints for policy rules.\n\nExtends the read-only policies.py facade with write operations.\n\nEndpoints:\n    POST /api/v1/policies/rules              \u2192 Create rule\n    PUT  /api/v1/policies/rules/{rule_id}    \u2192 Update rule\n\nRules are never deleted - they are retired with reason.",
        "functions": [
          {
            "name": "create_rule",
            "signature": "(request: Request, body: CreateRuleRequest, session: AsyncSession = Depends(get_async_session_dep)) -> RuleDetail",
            "docstring": "Create a new policy rule.\n\nRules can be created from:\n- MANUAL: User-defined rules\n- SYSTEM: System-generated rules\n- LEARNED: ML/AI proposed rules (from policy proposals)",
            "is_async": true,
            "line": 119
          },
          {
            "name": "update_rule",
            "signature": "(request: Request, rule_id: str, body: UpdateRuleRequest, session: AsyncSession = Depends(get_async_session_dep)) -> RuleDetail",
            "docstring": "Update an existing policy rule.\n\nTo retire a rule:\n- Set status to \"RETIRED\"\n- Provide retirement_reason (required)\n- Optionally set superseded_by\n\nRules are never deleted, only retired.",
            "is_async": true,
            "line": 177
          },
          {
            "name": "_to_detail",
            "signature": "(result: PolicyRuleResponse) -> RuleDetail",
            "docstring": "Convert service response to API response.",
            "is_async": false,
            "line": 241
          }
        ],
        "classes": [
          {
            "name": "CreateRuleRequest",
            "docstring": "API request to create a policy rule.",
            "methods": [],
            "line": 57
          },
          {
            "name": "UpdateRuleRequest",
            "docstring": "API request to update a policy rule.",
            "methods": [],
            "line": 71
          },
          {
            "name": "RuleDetail",
            "docstring": "Full rule response.",
            "methods": [],
            "line": 83
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session_dep"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.schemas.limits.policy_rules",
            "names": [
              "CreatePolicyRuleRequest",
              "PolicyRuleResponse",
              "UpdatePolicyRuleRequest"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.policy_rules_engine",
            "names": [
              "PolicyRulesService",
              "PolicyRulesServiceError",
              "RuleNotFoundError",
              "RuleValidationError"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "rate_limits.py",
        "file_path": "backend/app/hoc/api/cus/policies/rate_limits.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 225,
        "module_docstring": "Rate Limits API (L2) - GAP-122\n\nProvides rate limit and quota operations:\n- GET /api/v1/rate-limits (list rate limits)\n- GET /api/v1/rate-limits/usage (current usage)\n- GET /api/v1/rate-limits/{id} (get rate limit)\n- PUT /api/v1/rate-limits/{id} (update rate limit)\n- POST /api/v1/rate-limits/check (check rate limit)\n- POST /api/v1/rate-limits/{id}/reset (reset usage)\n\nThis is the ONLY facade for rate limit/quota operations.\nDistinct from PIN-LIM policy limits (app/api/limits/).",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> LimitsFacade",
            "docstring": "Get the limits facade.",
            "is_async": false,
            "line": 77
          },
          {
            "name": "list_limits",
            "signature": "(limit_type: Optional[str] = Query(None, description='Filter by type'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: LimitsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('limits.read')))",
            "docstring": "List limits (GAP-122).\n\nReturns all configured limits for the tenant.",
            "is_async": true,
            "line": 88
          },
          {
            "name": "get_usage",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), facade: LimitsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('limits.read')))",
            "docstring": "Get current usage summary.\n\nReturns usage across all limits with aggregated totals.",
            "is_async": true,
            "line": 117
          },
          {
            "name": "check_limit",
            "signature": "(request: CheckLimitRequest, ctx: TenantContext = Depends(get_tenant_context), facade: LimitsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('limits.check')))",
            "docstring": "Check if a limit allows an operation.\n\nIf allowed, increments the usage counter.",
            "is_async": true,
            "line": 133
          },
          {
            "name": "get_limit",
            "signature": "(limit_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LimitsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('limits.read')))",
            "docstring": "Get a specific limit.",
            "is_async": true,
            "line": 154
          },
          {
            "name": "update_limit",
            "signature": "(limit_id: str, request: UpdateLimitRequest, ctx: TenantContext = Depends(get_tenant_context), facade: LimitsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('limits.write')))",
            "docstring": "Update a limit configuration.",
            "is_async": true,
            "line": 175
          },
          {
            "name": "reset_limit",
            "signature": "(limit_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: LimitsFacade = Depends(get_facade), _tier: None = Depends(requires_feature('limits.admin')))",
            "docstring": "Reset a limit's usage counter.\n\n**Requires admin permissions.**",
            "is_async": true,
            "line": 200
          }
        ],
        "classes": [
          {
            "name": "UpdateLimitRequest",
            "docstring": "Request to update a limit.",
            "methods": [],
            "line": 59
          },
          {
            "name": "CheckLimitRequest",
            "docstring": "Request to check a limit.",
            "methods": [],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.limits_facade",
            "names": [
              "LimitsFacade",
              "get_limits_facade"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "rbac_api.py",
        "file_path": "backend/app/hoc/api/cus/policies/rbac_api.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 344,
        "module_docstring": "RBAC Management API\n\nProvides endpoints for managing RBAC policies:\n- GET /api/v1/rbac/info - Get current policy info\n- POST /api/v1/rbac/reload - Hot-reload policies from file\n- GET /api/v1/rbac/matrix - Get current permission matrix\n- GET /api/v1/rbac/audit - Query audit logs\n\nRequires RBAC permission: rbac:read or rbac:reload\n\nNOTE (PIN-310): Authorization now routes through M28 via authorization_choke.py.\nPolicy introspection (info, matrix, reload) still uses rbac_engine for admin functions.",
        "functions": [
          {
            "name": "get_policy_info",
            "signature": "(request: Request)",
            "docstring": "Get current RBAC policy information.\n\nReturns version, hash, loaded timestamp, roles, and resources.\n\nRequires RBAC permission: rbac:read",
            "is_async": true,
            "line": 104
          },
          {
            "name": "reload_policies",
            "signature": "(request: Request)",
            "docstring": "Hot-reload RBAC policies from file.\n\nReloads the policy file and updates the in-memory policy matrix.\nReturns the previous and new policy hashes for verification.\n\nRequires RBAC permission: rbac:reload",
            "is_async": true,
            "line": 134
          },
          {
            "name": "get_permission_matrix",
            "signature": "(request: Request) -> Dict[str, Any]",
            "docstring": "Get current permission matrix.\n\nReturns the full role->resource->actions mapping.\n\nRequires RBAC permission: rbac:read",
            "is_async": true,
            "line": 184
          },
          {
            "name": "query_audit_logs",
            "signature": "(request: Request, resource: Optional[str] = Query(default=None, description='Filter by resource'), action: Optional[str] = Query(default=None, description='Filter by action'), allowed: Optional[bool] = Query(default=None, description='Filter by decision'), subject: Optional[str] = Query(default=None, description='Filter by subject'), tenant_id: Optional[str] = Query(default=None, description='Filter by tenant'), since: Optional[datetime] = Query(default=None, description='Filter since timestamp'), limit: int = Query(default=100, ge=1, le=1000), offset: int = Query(default=0, ge=0), db = Depends(get_db_session))",
            "docstring": "Query RBAC audit logs.\n\nSupports filtering by resource, action, decision, subject, tenant, and time.\n\nRequires RBAC permission: rbac:read",
            "is_async": true,
            "line": 207
          },
          {
            "name": "cleanup_audit_logs",
            "signature": "(request: Request, retention_days: int = Query(default=90, ge=1, le=365), db = Depends(get_db_session))",
            "docstring": "Clean up old audit logs.\n\nDeletes audit entries older than retention_days.\n\nRequires RBAC permission: rbac:reload (admin action)",
            "is_async": true,
            "line": 307
          }
        ],
        "classes": [
          {
            "name": "PolicyInfoResponse",
            "docstring": "Current policy information.",
            "methods": [],
            "line": 50
          },
          {
            "name": "ReloadResponse",
            "docstring": "Policy reload response.",
            "methods": [],
            "line": 62
          },
          {
            "name": "AuditEntry",
            "docstring": "Single audit log entry.",
            "methods": [],
            "line": 72
          },
          {
            "name": "AuditResponse",
            "docstring": "Audit log query response.",
            "methods": [],
            "line": 89
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "auth.authorization_choke",
            "names": [
              "check_permission_request"
            ],
            "is_relative": true,
            "line": 35
          },
          {
            "module": "auth.rbac_engine",
            "names": [
              "get_rbac_engine"
            ],
            "is_relative": true,
            "line": 36
          },
          {
            "module": "db",
            "names": [
              "get_session"
            ],
            "is_relative": true,
            "line": 37
          },
          {
            "module": "schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": true,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "replay.py",
        "file_path": "backend/app/hoc/api/cus/policies/replay.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 610,
        "module_docstring": "Replay UX API (H1)\n\nProvides READ-ONLY endpoints for replay visualization:\n- Time-windowed slice of incident data\n- Grouped view: inputs, decisions, actions, side-effects\n- Immutable, paginated responses\n\nINVARIANTS:\n1. All endpoints are READ-ONLY (no mutations)\n2. Uses existing RBAC v2 enforcement (require_replay_read)\n3. Tenant isolation enforced\n4. No execution or write capabilities\n\nReference: Phase H1 - Replay UX Enablement",
        "functions": [
          {
            "name": "_categorize_proxy_call",
            "signature": "(call: ProxyCall) -> ReplayCategory",
            "docstring": "Categorize a proxy call into replay category.\n\nCategories:\n- INPUT: Request data, model selection\n- DECISION: Policy decisions, guardrail evaluations\n- ACTION: Actual API call execution\n- SIDE_EFFECT: Cost tracking, logging, notifications",
            "is_async": false,
            "line": 132
          },
          {
            "name": "_proxy_call_to_replay_item",
            "signature": "(call: ProxyCall) -> ReplayItem",
            "docstring": "Convert ProxyCall to ReplayItem for visualization.",
            "is_async": false,
            "line": 152
          },
          {
            "name": "_incident_event_to_replay_item",
            "signature": "(event: IncidentEvent) -> ReplayItem",
            "docstring": "Convert IncidentEvent to ReplayItem for visualization.",
            "is_async": false,
            "line": 203
          },
          {
            "name": "get_replay_slice",
            "signature": "(request: Request, incident_id: str, window: int = Query(30, ge=5, le=300, description='Time window in seconds (\u00b1window from incident)'), center_time: Optional[str] = Query(None, description='Center time ISO8601 (default: incident start)'), page: int = Query(1, ge=1, description='Page number'), page_size: int = Query(50, ge=10, le=200, description='Items per page'), auth: AuthorityResult = Depends(require_replay_read), session: Session = Depends(get_db_session))",
            "docstring": "Get time-windowed replay slice of an incident.\n\nReturns grouped, immutable data for replay visualization:\n- inputs: What the agent saw (requests, context)\n- decisions: Policy evaluations, guardrail checks\n- actions: Actual executions, API calls\n- side_effects: Cost tracking, notifications, logging\n\nThis endpoint is READ-ONLY and does not modify any data.\n\nRBAC: Requires read:replay permission\nTenant Isolation: Enforced",
            "is_async": true,
            "line": 233
          },
          {
            "name": "get_incident_summary",
            "signature": "(request: Request, incident_id: str, auth: AuthorityResult = Depends(require_replay_read), session: Session = Depends(get_db_session))",
            "docstring": "Get incident summary for replay context.\n\nProvides high-level information about an incident before\ndiving into detailed replay visualization.\n\nThis endpoint is READ-ONLY.\n\nRBAC: Requires read:replay permission\nTenant Isolation: Enforced",
            "is_async": true,
            "line": 365
          },
          {
            "name": "get_replay_timeline",
            "signature": "(request: Request, incident_id: str, limit: int = Query(100, ge=10, le=500, description='Maximum items to return'), auth: AuthorityResult = Depends(require_replay_read), session: Session = Depends(get_db_session))",
            "docstring": "Get full timeline for an incident (unpaginated for scrubbing UI).\n\nReturns all replay items in chronological order for\ntimeline scrubbing and playback visualization.\n\nThis endpoint is READ-ONLY.\n\nRBAC: Requires read:replay permission\nTenant Isolation: Enforced",
            "is_async": true,
            "line": 412
          },
          {
            "name": "explain_replay_item",
            "signature": "(request: Request, incident_id: str, item_id: str, auth: AuthorityResult = Depends(require_replay_read), session: Session = Depends(get_db_session))",
            "docstring": "Get detailed explanation for a single replay item.\n\nProvides expanded context for:\n- What the agent saw (inputs)\n- Why it decided (decision rationale)\n- What it executed (action details)\n\nThis endpoint is READ-ONLY.\n\nRBAC: Requires read:replay permission\nTenant Isolation: Enforced via incident",
            "is_async": true,
            "line": 491
          }
        ],
        "classes": [
          {
            "name": "ReplayCategory",
            "docstring": "Categories for replay data grouping.",
            "methods": [],
            "line": 56
          },
          {
            "name": "ReplayItem",
            "docstring": "Single item in replay timeline.",
            "methods": [],
            "line": 65
          },
          {
            "name": "ReplaySliceResponse",
            "docstring": "Paginated, grouped replay slice response.",
            "methods": [],
            "line": 78
          },
          {
            "name": "IncidentSummaryResponse",
            "docstring": "Summary of incident for replay context.",
            "methods": [],
            "line": 111
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "select"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "auth.authority",
            "names": [
              "AuthorityResult",
              "require_replay_read",
              "verify_tenant_access"
            ],
            "is_relative": true,
            "line": 41
          },
          {
            "module": "db",
            "names": [
              "get_session"
            ],
            "is_relative": true,
            "line": 42
          },
          {
            "module": "schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": true,
            "line": 43
          },
          {
            "module": "models.killswitch",
            "names": [
              "Incident",
              "IncidentEvent",
              "ProxyCall"
            ],
            "is_relative": true,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "retrieval.py",
        "file_path": "backend/app/hoc/api/cus/policies/retrieval.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 243,
        "module_docstring": "Retrieval API (L2)\n\nProvides mediated data retrieval operations:\n- POST /api/v1/retrieval/access (mediated data access)\n- GET /api/v1/retrieval/planes (list available planes)\n- POST /api/v1/retrieval/planes (register plane)\n- GET /api/v1/retrieval/planes/{id} (get plane)\n- GET /api/v1/retrieval/evidence (list evidence records)\n- GET /api/v1/retrieval/evidence/{id} (get evidence)\n\nThis is the ONLY facade for mediated data retrieval.\nAll data access from LLM-controlled code MUST flow through this router.\n\nINVARIANT: Deny-by-default. All access blocked unless explicitly allowed by policy.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> RetrievalFacade",
            "docstring": "Get the retrieval facade.",
            "is_async": false,
            "line": 80
          },
          {
            "name": "access_data",
            "signature": "(request: AccessDataRequest, ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.access')))",
            "docstring": "Mediated data access (GAP-094).\n\n**Tier: REACT ($9)** - Mediated data access.\n\nAll data access from LLM-controlled code MUST go through this endpoint.\nImplements deny-by-default policy enforcement.\n\nINVARIANT: Access is BLOCKED unless explicitly allowed by policy.",
            "is_async": true,
            "line": 91
          },
          {
            "name": "list_planes",
            "signature": "(connector_type: Optional[str] = Query(None, description='Filter by connector type'), status: Optional[str] = Query(None, description='Filter by status'), ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.read')))",
            "docstring": "List available knowledge planes.\n\nReturns all registered knowledge planes for the tenant.",
            "is_async": true,
            "line": 125
          },
          {
            "name": "register_plane",
            "signature": "(request: RegisterPlaneRequest, ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.write')))",
            "docstring": "Register a knowledge plane.\n\nRegisters a new knowledge plane that maps to a connector\nfor mediated data access.",
            "is_async": true,
            "line": 150
          },
          {
            "name": "get_plane",
            "signature": "(plane_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.read')))",
            "docstring": "Get a specific knowledge plane.",
            "is_async": true,
            "line": 174
          },
          {
            "name": "list_evidence",
            "signature": "(run_id: Optional[str] = Query(None, description='Filter by run'), plane_id: Optional[str] = Query(None, description='Filter by plane'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.evidence')))",
            "docstring": "List retrieval evidence records.\n\nReturns evidence of data accesses for audit and compliance.",
            "is_async": true,
            "line": 195
          },
          {
            "name": "get_evidence",
            "signature": "(evidence_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: RetrievalFacade = Depends(get_facade), _tier: None = Depends(requires_feature('retrieval.evidence')))",
            "docstring": "Get a specific evidence record.",
            "is_async": true,
            "line": 226
          }
        ],
        "classes": [
          {
            "name": "AccessDataRequest",
            "docstring": "Request for mediated data access.",
            "methods": [],
            "line": 59
          },
          {
            "name": "RegisterPlaneRequest",
            "docstring": "Request to register a knowledge plane.",
            "methods": [],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.general.L5_engines.retrieval_facade",
            "names": [
              "RetrievalFacade",
              "get_retrieval_facade"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "runtime.py",
        "file_path": "backend/app/hoc/api/cus/policies/runtime.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 716,
        "module_docstring": "Machine-Native Runtime API Endpoints (M5.5)\n\nProvides REST API exposure for machine-native runtime primitives:\n1. POST /api/v1/runtime/simulate - Pre-execution plan simulation\n2. POST /api/v1/runtime/query - Runtime state queries\n3. GET /api/v1/runtime/skills - List available skills\n4. GET /api/v1/runtime/skills/{skill_id} - Describe a skill\n5. GET /api/v1/runtime/capabilities - Get capabilities for an agent\n\nDesign Principles (from PIN-005):\n- Queryable state: Agent asks questions, gets structured answers\n- Capability awareness: Agent knows what it can do and what it costs\n- Pre-execution simulation: Evaluate plans before committing\n- Self-describing skills: Skills explain their behavior and constraints\n- Resource contracts: Boundaries declared upfront\n\nTier Gating (M32 - PIN-158):\n- OBSERVE ($0): Query, list skills, capabilities (observability)\n- PREVENT ($199): Simulate, replay (pre-execution decisions)",
        "functions": [
          {
            "name": "_get_cost_simulator",
            "signature": "()",
            "docstring": "Get CostSimulator instance.",
            "is_async": false,
            "line": 163
          },
          {
            "name": "_get_runtime_adapter",
            "signature": "()",
            "docstring": "Get RuntimeAdapter instance (L3).\n\nThis is the compliant way to access runtime functionality.\nL2 calls L3 (adapter), not L5 (worker).\n\nReference: PIN-258 Phase F-3 Runtime Cluster\n\nReturns:\n    RuntimeAdapter instance",
            "is_async": false,
            "line": 174
          },
          {
            "name": "_get_skill_registry",
            "signature": "()",
            "docstring": "Get skill registry.",
            "is_async": false,
            "line": 191
          },
          {
            "name": "simulate_plan",
            "signature": "(request: SimulateRequest, _http_request: Request = None, _rate_limited: bool = Depends(rate_limit_dependency), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('sdk.simulate.full')))",
            "docstring": "Simulate a plan before execution.\n\n**Tier: PREVENT ($199)** - Pre-execution simulation is the core \"decision tier\"\nfeature that lets you stop problems before they happen.\n\nReturns cost estimates, latency estimates, risk assessment, and feasibility check.\nThis allows agents to evaluate plans before committing resources.\n\nExample:\n```json\n{\n  \"plan\": [\n    {\"skill\": \"http_call\", \"params\": {\"url\": \"https://api.example.com/data\"}},\n    {\"skill\": \"llm_invoke\", \"params\": {\"prompt\": \"Summarize this data\"}}\n  ],\n  \"budget_cents\": 100\n}\n```",
            "is_async": true,
            "line": 212
          },
          {
            "name": "query_runtime",
            "signature": "(request: QueryRequest, ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('traces.read')))",
            "docstring": "Query runtime state.\n\n**Tier: OBSERVE ($0)** - Basic observability for all tiers.\n\nSupported query types:\n- remaining_budget_cents: Current budget status\n- what_did_i_try_already: Previous execution attempts\n- allowed_skills: List of available skills\n- last_step_outcome: Most recent execution result\n- skills_available_for_goal: Skills matching a goal\n\nExample:\n```json\n{\n  \"query_type\": \"remaining_budget_cents\",\n  \"params\": {}\n}\n```",
            "is_async": true,
            "line": 358
          },
          {
            "name": "list_available_skills",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "List all available skills.\n\n**Tier: OBSERVE ($0)** - Basic capability discovery.\n\nReturns skill IDs and basic descriptors for each skill.",
            "is_async": true,
            "line": 404
          },
          {
            "name": "describe_skill",
            "signature": "(skill_id: str, ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get detailed descriptor for a skill.\n\n**Tier: OBSERVE ($0)** - Basic capability discovery.\n\nReturns full metadata including:\n- Input/output schemas\n- Cost model\n- Failure modes with recovery hints\n- Constraints\n- Composition hints (what skills often precede/follow)",
            "is_async": true,
            "line": 441
          },
          {
            "name": "get_capabilities",
            "signature": "(agent_id: Optional[str] = Query(default=None, description='Agent ID'), tenant_id: Optional[str] = Query(default=None, description='Tenant ID'), ctx: TenantContext = Depends(get_tenant_context))",
            "docstring": "Get available capabilities for an agent/tenant.\n\n**Tier: OBSERVE ($0)** - Basic capability awareness.\n\nReturns:\n- Available skills with their current status\n- Budget information\n- Rate limit information\n- Permissions\n\nThis allows agents to know exactly what they can do before attempting.",
            "is_async": true,
            "line": 486
          },
          {
            "name": "get_resource_contract",
            "signature": "(resource_id: str)",
            "docstring": "Get resource contract for a specific resource.\n\nReturns budget, rate limits, and concurrency constraints.",
            "is_async": true,
            "line": 518
          },
          {
            "name": "replay_run",
            "signature": "(run_id: str, request: ReplayRequest = ReplayRequest(), _rate_limited: bool = Depends(rate_limit_dependency), ctx: TenantContext = Depends(get_tenant_context), _tier: None = Depends(requires_feature('evidence.replay')), auth: AuthorityResult = Depends(require_replay_execute))",
            "docstring": "Replay a stored plan and optionally verify determinism parity.\n\n**Tier: PREVENT ($199)** - Replay for evidence and compliance verification.\n**Authority: execute:replay** - RBAC v2 enforced.\n\nM6 Deliverable: Re-execute stored plans without re-planning.\n\nParity verification checks:\n- Same skill calls in same order\n- Same parameters to each skill\n- Same retry decisions\n- Same error classifications\n\nDoes NOT verify:\n- External API responses (vary between runs)\n- LLM output content (non-deterministic)\n- Timestamps (always different)\n- Execution duration (timing varies)\n\nArgs:\n    run_id: The original run ID to replay\n    request: Replay options\n\nReturns:\n    ReplayResponse with parity check result",
            "is_async": true,
            "line": 575
          },
          {
            "name": "list_traces",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), limit: int = Query(100, ge=1, le=1000, description='Max traces to return'), offset: int = Query(0, ge=0, description='Pagination offset'))",
            "docstring": "List stored traces for a tenant.\n\nM6 Deliverable: Access to execution traces for debugging and replay.\n\nArgs:\n    tenant_id: Filter by tenant (optional)\n    limit: Maximum traces to return\n    offset: Pagination offset\n\nReturns:\n    List of trace summaries",
            "is_async": true,
            "line": 642
          },
          {
            "name": "get_trace",
            "signature": "(run_id: str)",
            "docstring": "Get a specific trace by run ID.\n\nM6 Deliverable: Access to full execution trace for debugging.\n\nArgs:\n    run_id: The run ID to retrieve\n\nReturns:\n    Full trace record with all steps",
            "is_async": true,
            "line": 686
          }
        ],
        "classes": [
          {
            "name": "PlanStep",
            "docstring": "A single step in a plan to simulate.",
            "methods": [],
            "line": 67
          },
          {
            "name": "SimulateRequest",
            "docstring": "Request to simulate a plan before execution.",
            "methods": [],
            "line": 75
          },
          {
            "name": "SimulateResponse",
            "docstring": "Response from plan simulation.",
            "methods": [],
            "line": 88
          },
          {
            "name": "QueryRequest",
            "docstring": "Request to query runtime state.",
            "methods": [],
            "line": 108
          },
          {
            "name": "QueryResponse",
            "docstring": "Response from runtime query.",
            "methods": [],
            "line": 117
          },
          {
            "name": "SkillDescriptorResponse",
            "docstring": "Response describing a skill.",
            "methods": [],
            "line": 125
          },
          {
            "name": "SkillListResponse",
            "docstring": "Response listing available skills.",
            "methods": [],
            "line": 140
          },
          {
            "name": "CapabilitiesResponse",
            "docstring": "Response with agent capabilities.",
            "methods": [],
            "line": 148
          },
          {
            "name": "ReplayRequest",
            "docstring": "Request to replay a stored run.",
            "methods": [],
            "line": 555
          },
          {
            "name": "ReplayResponse",
            "docstring": "Response from replay operation.",
            "methods": [],
            "line": 563
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "require_replay_execute"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.middleware.rate_limit",
            "names": [
              "rate_limit_dependency"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.commands.runtime_command",
            "names": [
              "DEFAULT_SKILL_METADATA"
            ],
            "is_relative": false,
            "line": 204
          }
        ],
        "constants": [
          {
            "name": "AOS_WORKSPACE_ROOT",
            "line": 57
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "scheduler.py",
        "file_path": "backend/app/hoc/api/cus/policies/scheduler.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 341,
        "module_docstring": "Scheduler API (L2)\n\nProvides scheduled job operations:\n- POST /api/v1/scheduler/jobs (create job)\n- GET /api/v1/scheduler/jobs (list jobs)\n- GET /api/v1/scheduler/jobs/{id} (get job)\n- PUT /api/v1/scheduler/jobs/{id} (update job)\n- DELETE /api/v1/scheduler/jobs/{id} (delete job)\n- POST /api/v1/scheduler/jobs/{id}/trigger (trigger job)\n- POST /api/v1/scheduler/jobs/{id}/pause (pause job)\n- POST /api/v1/scheduler/jobs/{id}/resume (resume job)\n- GET /api/v1/scheduler/jobs/{id}/runs (job runs)\n- GET /api/v1/scheduler/runs/{id} (get run)\n\nThis is the ONLY facade for scheduler operations.\nAll scheduler APIs flow through this router.",
        "functions": [
          {
            "name": "get_facade",
            "signature": "() -> SchedulerFacade",
            "docstring": "Get the scheduler facade.",
            "is_async": false,
            "line": 85
          },
          {
            "name": "create_job",
            "signature": "(request: CreateJobRequest, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Create a scheduled job (GAP-112).\n\n**Tier: REACT ($9)** - Scheduled jobs.\n\nSchedule format: Standard cron expression\n- Minute (0-59)\n- Hour (0-23)\n- Day of month (1-31)\n- Month (1-12)\n- Day of week (0-7, 0 and 7 are Sunday)\n\nExample: \"0 9 * * *\" = Every day at 9:00 AM",
            "is_async": true,
            "line": 96
          },
          {
            "name": "list_jobs",
            "signature": "(status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.read')))",
            "docstring": "List scheduled jobs.",
            "is_async": true,
            "line": 130
          },
          {
            "name": "get_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.read')))",
            "docstring": "Get a specific scheduled job.",
            "is_async": true,
            "line": 157
          },
          {
            "name": "update_job",
            "signature": "(job_id: str, request: UpdateJobRequest, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Update a scheduled job.",
            "is_async": true,
            "line": 178
          },
          {
            "name": "delete_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Delete a scheduled job.",
            "is_async": true,
            "line": 205
          },
          {
            "name": "trigger_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.trigger')))",
            "docstring": "Trigger a job to run immediately.\n\nBypasses the schedule and runs the job now.",
            "is_async": true,
            "line": 226
          },
          {
            "name": "pause_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Pause a scheduled job.\n\nStops the job from running on schedule until resumed.",
            "is_async": true,
            "line": 249
          },
          {
            "name": "resume_job",
            "signature": "(job_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.write')))",
            "docstring": "Resume a paused job.\n\nRestarts the job's schedule.",
            "is_async": true,
            "line": 272
          },
          {
            "name": "list_job_runs",
            "signature": "(job_id: str, status: Optional[str] = Query(None, description='Filter by status'), limit: int = Query(100, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.read')))",
            "docstring": "List job run history.",
            "is_async": true,
            "line": 295
          },
          {
            "name": "get_run",
            "signature": "(run_id: str, ctx: TenantContext = Depends(get_tenant_context), facade: SchedulerFacade = Depends(get_facade), _tier: None = Depends(requires_feature('scheduler.read')))",
            "docstring": "Get a specific job run.",
            "is_async": true,
            "line": 324
          }
        ],
        "classes": [
          {
            "name": "CreateJobRequest",
            "docstring": "Request to create scheduled job.",
            "methods": [],
            "line": 61
          },
          {
            "name": "UpdateJobRequest",
            "docstring": "Request to update scheduled job.",
            "methods": [],
            "line": 71
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.tier_gating",
            "names": [
              "requires_feature"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.general.L5_engines.scheduler_facade",
            "names": [
              "SchedulerFacade",
              "get_scheduler_facade"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "simulate.py",
        "file_path": "backend/app/hoc/api/cus/policies/simulate.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 156,
        "module_docstring": "Limit Simulation API (PIN-LIM-04)\n\nPre-execution limit check endpoint.\n\nAllows callers to test whether an execution would be permitted\nbefore actually running it.\n\nEndpoint:\n    POST /api/v1/limits/simulate\n\nReturns:\n    - decision: ALLOW | BLOCK | WARN\n    - blocking_limit_id (if blocked)\n    - headroom (remaining capacity)\n    - warnings (soft limit warnings)",
        "functions": [
          {
            "name": "simulate_execution",
            "signature": "(request: Request, body: SimulateRequest, session: AsyncSession = Depends(get_async_session_dep)) -> SimulateResponse",
            "docstring": "Simulate an execution against all limits.\n\nThis endpoint allows callers to check whether an execution would be\npermitted BEFORE actually running it. Useful for:\n- SDK pre-checks\n- UI feedback on resource availability\n- Worker admission control",
            "is_async": true,
            "line": 95
          }
        ],
        "classes": [
          {
            "name": "SimulateRequest",
            "docstring": "Wrapper for simulation request.",
            "methods": [],
            "line": 57
          },
          {
            "name": "SimulateResponse",
            "docstring": "Simulation response with decision and details.",
            "methods": [],
            "line": 70
          }
        ],
        "imports": [
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session_dep"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.simulation",
            "names": [
              "LimitSimulationRequest",
              "LimitSimulationResponse",
              "SimulationDecision"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.limits_simulation_service",
            "names": [
              "LimitsSimulationService",
              "LimitsSimulationServiceError",
              "TenantNotFoundError"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "status_history.py",
        "file_path": "backend/app/hoc/api/cus/policies/status_history.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 466,
        "module_docstring": "API endpoints for immutable status history audit trail.\n\nEndpoints:\n- GET /status_history - Query status history with filters\n- GET /status_history/{entity_type}/{entity_id} - Get history for specific entity\n- GET /status_history/export - Export to CSV/JSONL with signed URL\n- GET /status_history/stats - Get statistics for audit reporting\n\nSecurity:\n- Tenant isolation via tenant_id filter\n- Audit logging for all access\n- Signed URLs for exports (time-limited)",
        "functions": [
          {
            "name": "generate_signed_url",
            "signature": "(export_id: str, format: str) -> tuple[str, datetime]",
            "docstring": "Generate a signed URL for export download.\n\nArgs:\n    export_id: Export file identifier\n    format: Export format (csv/jsonl)\n\nReturns:\n    Tuple of (signed_url, expires_at)",
            "is_async": false,
            "line": 130
          },
          {
            "name": "verify_signed_url",
            "signature": "(export_id: str, format: str, expires_ts: int, signature: str) -> bool",
            "docstring": "Verify a signed URL signature.\n\nArgs:\n    export_id: Export file identifier\n    format: Export format\n    expires_ts: Expiration timestamp\n    signature: Provided signature\n\nReturns:\n    True if valid, False otherwise",
            "is_async": false,
            "line": 154
          },
          {
            "name": "query_status_history",
            "signature": "(entity_type: Optional[str] = Query(None, description='Filter by entity type'), entity_id: Optional[str] = Query(None, description='Filter by entity ID'), tenant_id: Optional[str] = Query(None, description='Filter by tenant'), actor_type: Optional[str] = Query(None, description='Filter by actor type'), new_status: Optional[str] = Query(None, description='Filter by new status'), start_time: Optional[datetime] = Query(None, description='Filter from this time'), end_time: Optional[datetime] = Query(None, description='Filter until this time'), limit: int = Query(100, ge=1, le=1000, description='Max results'), offset: int = Query(0, ge=0, description='Offset for pagination'), session: Session = Depends(get_session))",
            "docstring": "Query status history with filters.\n\nSupports filtering by:\n- entity_type: run, agent, approval, workflow, costsim\n- entity_id: Specific entity ID\n- tenant_id: Tenant scope (required in production)\n- actor_type: system, user, agent, scheduler\n- new_status: Target status\n- start_time/end_time: Time range",
            "is_async": true,
            "line": 180
          },
          {
            "name": "get_entity_history",
            "signature": "(entity_type: str, entity_id: str, limit: int = Query(100, ge=1, le=1000), session: Session = Depends(get_session))",
            "docstring": "Get complete status history for a specific entity.\n\nReturns all status transitions in chronological order.",
            "is_async": true,
            "line": 257
          },
          {
            "name": "create_export",
            "signature": "(request: ExportRequest, session: Session = Depends(get_session))",
            "docstring": "Create an export of status history records.\n\nReturns a signed URL for download that expires in 1 hour.\n\nSupported formats:\n- csv: Comma-separated values\n- jsonl: JSON Lines (one JSON object per line)",
            "is_async": true,
            "line": 305
          },
          {
            "name": "download_export",
            "signature": "(export_id: str, format: str = Query(..., description='Export format'), expires: int = Query(..., description='Expiration timestamp'), sig: str = Query(..., description='Signature'))",
            "docstring": "Download an exported file using signed URL.\n\nThis endpoint verifies the signature and expiration before\nreturning the file contents.",
            "is_async": true,
            "line": 372
          },
          {
            "name": "get_stats",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), session: Session = Depends(get_session))",
            "docstring": "Get statistics about status history records.\n\nUseful for audit reporting and monitoring.",
            "is_async": true,
            "line": 409
          }
        ],
        "classes": [
          {
            "name": "StatusHistoryQuery",
            "docstring": "Query parameters for status history.",
            "methods": [],
            "line": 55
          },
          {
            "name": "StatusHistoryResponse",
            "docstring": "Single status history record.",
            "methods": [],
            "line": 68
          },
          {
            "name": "StatusHistoryListResponse",
            "docstring": "Paginated list of status history records.",
            "methods": [],
            "line": 86
          },
          {
            "name": "ExportRequest",
            "docstring": "Request for status history export.",
            "methods": [],
            "line": 96
          },
          {
            "name": "ExportResponse",
            "docstring": "Response with signed URL for export download.",
            "methods": [],
            "line": 107
          },
          {
            "name": "StatsResponse",
            "docstring": "Statistics for audit reporting.",
            "methods": [],
            "line": 117
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "csv",
            "names": [
              "csv"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "cast"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Response"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.db",
            "names": [
              "StatusHistory",
              "get_session"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [
          {
            "name": "EXPORT_DIR",
            "line": 49
          },
          {
            "name": "SIGNED_URL_SECRET",
            "line": 50
          },
          {
            "name": "SIGNED_URL_TTL_SECONDS",
            "line": 51
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "workers.py",
        "file_path": "backend/app/hoc/api/cus/policies/workers.py",
        "layer": "L2_api",
        "domain": "policies",
        "lines": 1607,
        "module_docstring": "API endpoints for Business Builder Worker.\n\nEndpoints:\n- POST /api/v1/workers/business-builder/run - Execute the worker\n- POST /api/v1/workers/business-builder/replay - Replay a previous execution\n- GET /api/v1/workers/business-builder/runs/{run_id} - Get run details\n- GET /api/v1/workers/business-builder/runs - List recent runs\n- POST /api/v1/workers/business-builder/validate-brand - Validate brand schema\n- GET /api/v1/workers/business-builder/stream/{run_id} - SSE stream for real-time updates\n\nAll endpoints require authentication via API key or Bearer token.",
        "functions": [
          {
            "name": "_get_workers_adapter",
            "signature": "()",
            "docstring": "Get the L3 workers adapter.\n\nThis is the ONLY way L2 should access worker functionality.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": false,
            "line": 73
          },
          {
            "name": "_calculate_cost_cents",
            "signature": "(model: str, input_tokens: int, output_tokens: int) -> int",
            "docstring": "Calculate LLM cost in cents via L3 adapter.\n\nPhase F-3: This replaces the direct L5 import.",
            "is_async": false,
            "line": 85
          },
          {
            "name": "_store_run",
            "signature": "(run_id: str, data: Dict[str, Any], tenant_id: str = 'default') -> None",
            "docstring": "Persist a run to PostgreSQL.\n\nP0-005 Fix: Database is the source of truth, not memory.",
            "is_async": true,
            "line": 253
          },
          {
            "name": "_insert_cost_record",
            "signature": "(run_id: str, tenant_id: str, model: str, input_tokens: int, output_tokens: int, cost_cents: int) -> None",
            "docstring": "Insert a cost record for a worker run.\n\nP0-006 Fix: Cost must be recorded as part of worker execution.\nThis creates the authoritative cost fact that S2 requires.",
            "is_async": true,
            "line": 294
          },
          {
            "name": "_check_and_emit_cost_advisory",
            "signature": "(run_id: str, tenant_id: str, cost_cents: int) -> Dict[str, Any]",
            "docstring": "Check if cost threshold is crossed and emit advisory if needed.\n\nS2 Advisory Invariant:\n- If threshold crossed AND hard_limit_enabled=false \u2192 exactly 1 advisory\n- If threshold NOT crossed \u2192 exactly 0 advisories\n- If hard_limit_enabled=true \u2192 this is an incident, not advisory (out of S2 scope)\n\nReturns dict with:\n- threshold_crossed: bool\n- advisory_emitted: bool\n- advisory_id: str | None\n- budget_id: str | None",
            "is_async": true,
            "line": 332
          },
          {
            "name": "_verify_advisory_invariant",
            "signature": "(run_id: str, tenant_id: str, advisory_result: Dict[str, Any]) -> None",
            "docstring": "Verify advisory emission invariant in VERIFICATION_MODE.\n\nS2 Invariant:\n- If threshold_crossed=true AND hard_limit_enabled=false \u2192 advisory_count must be 1\n- If threshold_crossed=false \u2192 advisory_count must be 0\n\nRaises RuntimeError if invariant violated.",
            "is_async": true,
            "line": 467
          },
          {
            "name": "_get_run",
            "signature": "(run_id: str) -> Optional[Dict[str, Any]]",
            "docstring": "Get a run from PostgreSQL.\n\nReturns dict format matching WorkerRunResponse for API compatibility.",
            "is_async": true,
            "line": 530
          },
          {
            "name": "_list_runs",
            "signature": "(limit: int = 20, tenant_id: Optional[str] = None) -> List[Dict[str, Any]]",
            "docstring": "List recent runs from PostgreSQL.",
            "is_async": true,
            "line": 563
          },
          {
            "name": "get_event_bus",
            "signature": "() -> WorkerEventBus",
            "docstring": "Get the global event bus instance.",
            "is_async": false,
            "line": 654
          },
          {
            "name": "_brand_request_to_schema",
            "signature": "(brand_req: BrandRequest)",
            "docstring": "Convert API request to BrandSchema via L3 adapter.\n\nPhase F-3: This replaces the direct L5 schema import.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": false,
            "line": 685
          },
          {
            "name": "_execute_worker_async",
            "signature": "(run_id: str, request: WorkerRunRequest) -> None",
            "docstring": "Execute worker in background and update run store.\n\nPhase F-3: Uses L3 adapter instead of direct L5 worker import.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": true,
            "line": 696
          },
          {
            "name": "run_worker",
            "signature": "(request: WorkerRunRequest, background_tasks: BackgroundTasks, _: str = Depends(verify_api_key))",
            "docstring": "Execute the Business Builder Worker.\n\nTakes a business idea and optionally brand constraints, produces a complete\nlaunch package including:\n- Market research\n- Brand strategy\n- Landing page copy\n- HTML/CSS assets\n- Replay token for deterministic reproduction\n\nIntegrates with:\n- M4: Golden replay (deterministic execution)\n- M9: Failure catalog (pattern detection)\n- M10: Recovery engine (auto-recovery)\n- M15: SBA (strategy-bound agents)\n- M17: CARE (complexity-aware routing)\n- M18: Drift detection\n- M19/M20: Policy governance",
            "is_async": true,
            "line": 832
          },
          {
            "name": "replay_execution_endpoint",
            "signature": "(request: ReplayRequest, auth: AuthorityResult = Depends(require_replay_execute))",
            "docstring": "Replay a previous execution using Golden Replay (M4).\n\nDeterministically reproduces the same outputs given the same replay token.\n\nPhase F-3: Uses L3 adapter instead of direct L5 worker import.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": true,
            "line": 1041
          },
          {
            "name": "get_run",
            "signature": "(run_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Get details of a worker run.\n\nUse this to poll for async run completion or inspect past runs.",
            "is_async": true,
            "line": 1088
          },
          {
            "name": "list_runs",
            "signature": "(limit: int = 20, tenant_id: Optional[str] = None, _: str = Depends(verify_api_key))",
            "docstring": "List recent worker runs.\n\nReturns summary information for recent executions.\nOptionally filter by tenant_id.",
            "is_async": true,
            "line": 1105
          },
          {
            "name": "retry_run",
            "signature": "(run_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Retry a completed or failed run - Phase-2.5.\n\nCreates a new run linked to the original via parent_run_id.\nThis is a lifecycle event, not execution - the run is queued only.\n\nRules:\n- Original run must be COMPLETED or FAILED\n- No agent execution triggered\n- DB write only, deterministic",
            "is_async": true,
            "line": 1134
          },
          {
            "name": "validate_brand",
            "signature": "(request: BrandRequest, _: str = Depends(verify_api_key))",
            "docstring": "Validate a brand schema without executing the worker.\n\nChecks:\n- Schema validity\n- Policy rules generation (M19)\n- Drift anchors extraction (M18)",
            "is_async": true,
            "line": 1200
          },
          {
            "name": "worker_health",
            "signature": "()",
            "docstring": "Health check for Business Builder Worker.\n\nReturns status of all integrated moats.",
            "is_async": true,
            "line": 1251
          },
          {
            "name": "delete_run",
            "signature": "(run_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Delete a run from storage.\n\nNote: In production, this would require admin privileges.",
            "is_async": true,
            "line": 1318
          },
          {
            "name": "get_brand_schema",
            "signature": "()",
            "docstring": "Get the JSON schema for BrandRequest.\n\nUseful for clients to understand the expected format.",
            "is_async": true,
            "line": 1340
          },
          {
            "name": "get_run_schema",
            "signature": "()",
            "docstring": "Get the JSON schema for WorkerRunRequest.",
            "is_async": true,
            "line": 1350
          },
          {
            "name": "_sse_event_generator",
            "signature": "(run_id: str, queue: asyncio.Queue) -> AsyncGenerator[str, None]",
            "docstring": "Generate SSE events from the queue.",
            "is_async": true,
            "line": 1362
          },
          {
            "name": "stream_run_events",
            "signature": "(run_id: str, request: Request)",
            "docstring": "Stream real-time events for a worker run via Server-Sent Events (SSE).\n\nEvents include:\n- run_started: Worker execution began\n- stage_started/completed/failed: Stage lifecycle\n- log: Agent output logs\n- routing_decision: CARE routing decisions\n- policy_check/violation: M19 policy events\n- drift_detected: M18 drift detection\n- failure_detected: M9 failure pattern match\n- recovery_started/completed: M10 recovery actions\n- artifact_created: New artifact generated\n- run_completed/failed: Terminal state\n\nUsage (JavaScript):\n```js\nconst sse = new EventSource('/api/v1/workers/business-builder/stream/{run_id}');\nsse.onmessage = (event) => console.log(JSON.parse(event.data));\nsse.addEventListener('stage_completed', (event) => { ... });\n```",
            "is_async": true,
            "line": 1395
          },
          {
            "name": "get_run_events",
            "signature": "(run_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Get all events for a run (non-streaming).\n\nUseful for replaying events or debugging.",
            "is_async": true,
            "line": 1441
          },
          {
            "name": "_execute_worker_with_events",
            "signature": "(run_id: str, request: WorkerRunRequest) -> None",
            "docstring": "Execute worker with REAL event emission from worker itself.\n\nv0.4: Worker is source of truth. PostgreSQL persistence. No in-memory storage.\n\nPhase F-3: Uses L3 adapter instead of direct L5 worker import.\nF-W-RULE-4: L3 Adapter Is the Only Entry.",
            "is_async": true,
            "line": 1463
          },
          {
            "name": "run_worker_streaming",
            "signature": "(request: WorkerRunRequest, background_tasks: BackgroundTasks, _: str = Depends(verify_api_key))",
            "docstring": "Execute the Business Builder Worker with real-time event streaming.\n\nReturns immediately with run_id. Connect to /stream/{run_id} for real-time events.\n\nThis is the preferred endpoint for UI-driven execution where you want to\nshow progress, routing decisions, and artifacts building in real-time.",
            "is_async": true,
            "line": 1560
          }
        ],
        "classes": [
          {
            "name": "ToneRuleRequest",
            "docstring": "Tone rule for brand.",
            "methods": [],
            "line": 103
          },
          {
            "name": "ForbiddenClaimRequest",
            "docstring": "Forbidden claim definition.",
            "methods": [],
            "line": 112
          },
          {
            "name": "VisualIdentityRequest",
            "docstring": "Visual identity for brand.",
            "methods": [],
            "line": 120
          },
          {
            "name": "BrandRequest",
            "docstring": "Brand schema for worker execution.",
            "methods": [],
            "line": 130
          },
          {
            "name": "WorkerRunRequest",
            "docstring": "Request to run the Business Builder Worker.",
            "methods": [],
            "line": 148
          },
          {
            "name": "PolicyStatusModel",
            "docstring": "Phase 5B: Policy pre-check status for PRE-RUN declaration.",
            "methods": [],
            "line": 167
          },
          {
            "name": "WorkerRunResponse",
            "docstring": "Response from worker execution.",
            "methods": [],
            "line": 178
          },
          {
            "name": "ReplayRequest",
            "docstring": "Request to replay a previous execution.",
            "methods": [],
            "line": 200
          },
          {
            "name": "BrandValidationResponse",
            "docstring": "Response from brand validation.",
            "methods": [],
            "line": 206
          },
          {
            "name": "RunListItem",
            "docstring": "Summary item for run listing.",
            "methods": [],
            "line": 216
          },
          {
            "name": "RunListResponse",
            "docstring": "Response for listing runs.",
            "methods": [],
            "line": 227
          },
          {
            "name": "RunRetryResponse",
            "docstring": "Response for run retry - Phase-2.5.",
            "methods": [],
            "line": 234
          },
          {
            "name": "WorkerEventBus",
            "docstring": "Event bus for real-time worker execution streaming.\n\nSupports multiple subscribers per run_id.\nEvents are JSON-serialized and sent as SSE.",
            "methods": [
              "__init__",
              "subscribe",
              "unsubscribe",
              "emit",
              "get_history",
              "cleanup"
            ],
            "line": 593
          },
          {
            "name": "EventType",
            "docstring": "Constants for SSE event types.",
            "methods": [],
            "line": 660
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "collections",
            "names": [
              "defaultdict"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "AsyncGenerator",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "BackgroundTasks",
              "Depends",
              "HTTPException",
              "Request"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "fastapi.responses",
            "names": [
              "StreamingResponse"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.auth",
            "names": [
              "verify_api_key"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.auth.authority",
            "names": [
              "AuthorityResult",
              "emit_authority_audit",
              "require_replay_execute"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.contracts.decisions",
            "names": [
              "emit_policy_precheck_decision"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.db",
            "names": [
              "CostBudget",
              "get_async_session"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.core.execution_context",
            "names": [
              "ExecutionContext",
              "EvidenceSource"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.evidence.capture",
            "names": [
              "capture_environment_evidence"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.policy.engine",
            "names": [
              "PolicyEngine"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.hoc.cus.general.L6_drivers.worker_write_service_async",
            "names": [
              "WorkerWriteServiceAsync"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [
          {
            "name": "VERIFICATION_MODE",
            "line": 247
          },
          {
            "name": "COST_ENFORCEMENT_ENABLED",
            "line": 250
          }
        ],
        "all_exports": null
      }
    ],
    "l3_adapters": [
      {
        "file_name": "founder_contract_review_adapter.py",
        "file_path": "backend/app/hoc/cus/policies/L3_adapters/founder_contract_review_adapter.py",
        "layer": "L3_adapters",
        "domain": "policies",
        "lines": 307,
        "module_docstring": "Founder Review Adapter (L3)\n\nTranslates L4 Contract domain models to Founder-facing review views.\n\nL4 (ContractService) \u2192 L3 (this adapter) \u2192 L2 (founder_review.py)\n\nThe adapter:\n1. Receives ContractState domain models from L4\n2. Selects/renames fields for Founder audience\n3. Returns FounderReviewView for L2\n\nHARD RULES (from PART2_CRM_WORKFLOW_CHARTER.md):\n- NO business logic (that's L4's job)\n- NO state transitions (that's L4's job)\n- NO eligibility decisions (that's L4's job)\n- NO permissions logic (that's L2's job)\n- ONLY field selection, translation, formatting\n\nReference: PIN-293, PART2_CRM_WORKFLOW_CHARTER.md, part2-design-v1",
        "functions": [],
        "classes": [
          {
            "name": "FounderContractSummaryView",
            "docstring": "Founder-facing contract summary for the review queue.\n\nThis is what Founder Console sees in the list view.\nDistinct from ContractState (L4 domain model).",
            "methods": [],
            "line": 47
          },
          {
            "name": "FounderContractDetailView",
            "docstring": "Founder-facing contract detail for review.\n\nThis is what Founder sees when they click into a contract.\nIncludes full context for making APPROVE/REJECT decision.",
            "methods": [],
            "line": 69
          },
          {
            "name": "FounderReviewQueueResponse",
            "docstring": "Response for GET /fdr/contracts/review-queue.\n\nList of ELIGIBLE contracts awaiting founder review.",
            "methods": [],
            "line": 119
          },
          {
            "name": "FounderReviewDecision",
            "docstring": "Input for founder review decision.\n\nThis is what L2 receives from the Founder Console.",
            "methods": [],
            "line": 132
          },
          {
            "name": "FounderReviewResult",
            "docstring": "Result of a founder review action.\n\nReturned after APPROVE or REJECT.",
            "methods": [],
            "line": 144
          },
          {
            "name": "FounderReviewAdapter",
            "docstring": "Boundary adapter for Founder Review contract views.\n\nThis class provides the ONLY interface that L2 (founder_review.py) may use\nto access Contract data for review. It translates domain models to\nFounder-facing views.\n\nPIN-293 L3 Rule: Translation only, no business logic.",
            "methods": [
              "to_summary_view",
              "to_detail_view",
              "to_queue_response",
              "to_review_result"
            ],
            "line": 164
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.hoc.cus.general.L5_workflow.contracts.engines.contract_engine",
            "names": [
              "ContractState"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_adapter.py",
        "file_path": "backend/app/hoc/cus/policies/L3_adapters/policy_adapter.py",
        "layer": "L3_adapters",
        "domain": "policies",
        "lines": 267,
        "module_docstring": "Policy Boundary Adapter (L3)\n\nThis adapter sits between L2 (policy.py API) and L4 (policy_command.py).\n\nL2 (API) \u2192 L3 (this adapter) \u2192 L4 (command) \u2192 L5 (workflow execution)\n\nThe adapter:\n1. Receives API requests with execution context\n2. Translates to domain facts\n3. Delegates to L4 commands\n4. Returns results to L2\n\nThis is a thin translation layer - no branching, no thresholds, no interpretation.\n\nReference: PIN-258 Phase F-3 Policy Cluster",
        "functions": [
          {
            "name": "get_policy_adapter",
            "signature": "() -> PolicyAdapter",
            "docstring": "Get the singleton PolicyAdapter instance.\n\nThis is the ONLY way L2 should obtain a policy adapter.\nDirect instantiation is discouraged.\n\nReturns:\n    PolicyAdapter singleton instance\n\nReference: PIN-258 Phase F-3 (F-P-RULE-3: L3 Is the Only Entry)",
            "is_async": false,
            "line": 239
          }
        ],
        "classes": [
          {
            "name": "PolicyAdapter",
            "docstring": "Boundary adapter for policy operations.\n\nThis class provides the ONLY interface that L2 (policy.py) may use\nto access policy functionality. It translates API context to domain\nfacts and delegates to L4 commands.\n\nF-P-RULE-3: L3 Is Translation Only",
            "methods": [
              "simulate_cost",
              "check_policy_violations",
              "evaluate_policy",
              "record_approval_created",
              "record_approval_outcome",
              "record_escalation",
              "record_webhook_used"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.commands.policy_command",
            "names": [
              "PolicyEvaluationResult",
              "PolicyViolation",
              "check_policy_violations",
              "evaluate_policy",
              "record_approval_created",
              "record_approval_outcome",
              "record_escalation",
              "record_webhook_used",
              "simulate_cost"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyAdapter",
          "get_policy_adapter",
          "PolicyEvaluationResult",
          "PolicyViolation"
        ]
      }
    ],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "ast.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/ast.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 381,
        "module_docstring": "Policy DSL Abstract Syntax Tree (AST) Definitions\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- All nodes are IMMUTABLE (frozen dataclasses)\n- No dynamic fields\n- No generic dicts (typed structures only)\n- No runtime evaluation logic\n- Must be serializable to JSON\n\nGOVERNANCE:\n- These types define the MEANING of policy structure\n- No authority, no execution, no side effects",
        "functions": [
          {
            "name": "is_predicate",
            "signature": "(condition: Condition) -> bool",
            "docstring": "Check if condition is a simple predicate.",
            "is_async": false,
            "line": 354
          },
          {
            "name": "is_exists_predicate",
            "signature": "(condition: Condition) -> bool",
            "docstring": "Check if condition is an exists predicate.",
            "is_async": false,
            "line": 359
          },
          {
            "name": "is_logical_condition",
            "signature": "(condition: Condition) -> bool",
            "docstring": "Check if condition is a compound logical condition.",
            "is_async": false,
            "line": 364
          },
          {
            "name": "is_warn_action",
            "signature": "(action: Action) -> bool",
            "docstring": "Check if action is a WARN action.",
            "is_async": false,
            "line": 369
          },
          {
            "name": "is_block_action",
            "signature": "(action: Action) -> bool",
            "docstring": "Check if action is a BLOCK action.",
            "is_async": false,
            "line": 374
          },
          {
            "name": "is_require_approval_action",
            "signature": "(action: Action) -> bool",
            "docstring": "Check if action is a REQUIRE_APPROVAL action.",
            "is_async": false,
            "line": 379
          }
        ],
        "classes": [
          {
            "name": "Scope",
            "docstring": "Policy scope determines visibility boundaries.",
            "methods": [],
            "line": 48
          },
          {
            "name": "Mode",
            "docstring": "Policy mode determines enforcement semantics.\n\nMONITOR: Can only WARN, cannot BLOCK or REQUIRE_APPROVAL\nENFORCE: Can WARN, BLOCK, or REQUIRE_APPROVAL",
            "methods": [],
            "line": 55
          },
          {
            "name": "Comparator",
            "docstring": "Comparison operators for predicates.",
            "methods": [],
            "line": 67
          },
          {
            "name": "LogicalOperator",
            "docstring": "Logical operators for compound conditions.",
            "methods": [],
            "line": 78
          },
          {
            "name": "WarnAction",
            "docstring": "Emit a warning message.\nAllowed in both MONITOR and ENFORCE modes.",
            "methods": [
              "to_dict"
            ],
            "line": 91
          },
          {
            "name": "BlockAction",
            "docstring": "Block execution.\nONLY allowed in ENFORCE mode (validated by validator.py).",
            "methods": [
              "to_dict"
            ],
            "line": 105
          },
          {
            "name": "RequireApprovalAction",
            "docstring": "Require human approval before proceeding.\nONLY allowed in ENFORCE mode (validated by validator.py).",
            "methods": [
              "to_dict"
            ],
            "line": 118
          },
          {
            "name": "Predicate",
            "docstring": "A simple comparison predicate.\n\nExample: cost_per_hour > 200",
            "methods": [
              "to_dict"
            ],
            "line": 140
          },
          {
            "name": "ExistsPredicate",
            "docstring": "Check if a metric exists.\n\nExample: exists(anomaly_flag)",
            "methods": [
              "to_dict"
            ],
            "line": 161
          },
          {
            "name": "LogicalCondition",
            "docstring": "A compound condition combining two conditions with AND/OR.\n\nExample: cost_per_hour > 200 AND error_rate > 0.1",
            "methods": [
              "to_dict"
            ],
            "line": 178
          },
          {
            "name": "Clause",
            "docstring": "A single when-then clause.\n\nStructure:\n    when <condition>\n    then <action>+",
            "methods": [
              "__post_init__",
              "to_dict"
            ],
            "line": 208
          },
          {
            "name": "PolicyMetadata",
            "docstring": "Policy metadata header.\n\nRequired fields per PIN-341:\n- name: Policy identifier\n- version: Version number (monotonically increasing)\n- scope: ORG or PROJECT\n- mode: MONITOR or ENFORCE",
            "methods": [
              "__post_init__",
              "to_dict"
            ],
            "line": 238
          },
          {
            "name": "PolicyAST",
            "docstring": "Root AST node for a complete policy.\n\nStructure:\n    policy <name>\n    version <n>\n    scope <ORG|PROJECT>\n    mode <MONITOR|ENFORCE>\n\n    when <condition>\n    then <action>+\n    [... more clauses ...]\n\nIMMUTABILITY: This entire structure is frozen.\nSERIALIZATION: Use to_dict() or to_json() for serialization.\nHASHING: Use compute_hash() for deterministic content hash.",
            "methods": [
              "__post_init__",
              "to_dict",
              "to_json",
              "compute_hash",
              "name",
              "version",
              "scope",
              "mode"
            ],
            "line": 277
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Literal",
              "Union"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "authority_checker.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/authority_checker.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 284,
        "module_docstring": "Module: authority_checker\nPurpose: Check override authority status for prevention engine.\n\nThe prevention engine must check override authority before enforcing\nany policy actions. If an override is active, enforcement is skipped.\n\nIntegration Flow:\n    1. Prevention engine receives policy ID\n    2. Calls OverrideAuthorityChecker.check()\n    3. If override is active, skip enforcement\n    4. If no override, proceed with enforcement\n\nExports:\n    - OverrideStatus: Enum of override states\n    - OverrideCheckResult: Result of an override check\n    - OverrideAuthorityChecker: Main integration class\n    - should_skip_enforcement: Quick helper function",
        "functions": [
          {
            "name": "should_skip_enforcement",
            "signature": "(override_authority: Any) -> bool",
            "docstring": "Quick helper to check if enforcement should be skipped.\n\nArgs:\n    override_authority: OverrideAuthority model instance or None\n\nReturns:\n    True if enforcement should be skipped, False otherwise",
            "is_async": false,
            "line": 272
          }
        ],
        "classes": [
          {
            "name": "OverrideStatus",
            "docstring": "Status of an override check.",
            "methods": [],
            "line": 46
          },
          {
            "name": "OverrideCheckResult",
            "docstring": "Result of an override authority check.\n\nContains the status and metadata about any active override.",
            "methods": [
              "to_dict"
            ],
            "line": 56
          },
          {
            "name": "OverrideAuthorityChecker",
            "docstring": "Checks override authority status for the prevention engine.\n\nThe prevention engine must call this before enforcing any\npolicy actions to respect active overrides.\n\nGAP-034: Wire OverrideAuthority to prevention.\n\nUsage:\n    checker = OverrideAuthorityChecker()\n    result = checker.check(override_authority)\n    if result.skip_enforcement:\n        # Skip policy enforcement\n        log.info(f\"Skipping enforcement: override by {result.override_by}\")\n    else:\n        # Proceed with enforcement\n        enforce_policy()",
            "methods": [
              "check",
              "_is_override_active",
              "check_from_dict"
            ],
            "line": 90
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "binding_moment_enforcer.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/binding_moment_enforcer.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 276,
        "module_docstring": "Module: binding_moment_enforcer\nPurpose: Ensures policies are evaluated at the correct binding moment.\n\nBinding moments define WHEN a policy is evaluated:\n- RUN_START: Evaluate once at run start (snapshot-based)\n- STEP_START: Evaluate before each step\n- STEP_END: Evaluate after each step\n- ON_CHANGE: Evaluate when specific fields change\n\nIf a policy has bind_at=RUN_START, it should NOT be re-evaluated mid-run.\n\nImports (Dependencies):\n    - None (standalone)\n\nExports (Provides):\n    - should_evaluate_policy(policy, context) -> bool\n    - BindingMoment: Enum\n    - get_binding_moment(policy) -> BindingMoment\n\nWiring Points:\n    - Called from: prevention_engine.py before evaluating each policy\n\nAcceptance Criteria:\n    - [x] AC-031-01: RUN_START binding respected\n    - [x] AC-031-02: STEP_START binding respected\n    - [x] AC-031-03: Mid-run re-eval blocked for RUN_START\n    - [x] AC-031-04: Binding moment logged",
        "functions": [
          {
            "name": "should_evaluate_policy",
            "signature": "(policy: Any, context: Dict[str, Any], evaluation_point: EvaluationPoint) -> BindingDecision",
            "docstring": "Determine if a policy should be evaluated at this point.\n\nRespects the policy's bind_at setting:\n- RUN_START: Only evaluate once per run, at initialization\n- STEP_START: Evaluate before each step\n- STEP_END: Evaluate after each step\n- ON_CHANGE: Evaluate only when monitored fields change\n- ALWAYS: Evaluate at every point\n\nArgs:\n    policy: Policy object with bind_at attribute\n    context: Evaluation context with run_id, step info, etc.\n    evaluation_point: Current point in execution\n\nReturns:\n    BindingDecision with should_evaluate and reason",
            "is_async": false,
            "line": 89
          },
          {
            "name": "get_binding_moment",
            "signature": "(policy: Any) -> BindingMoment",
            "docstring": "Get the binding moment for a policy.\n\nArgs:\n    policy: Policy object\n\nReturns:\n    BindingMoment enum value",
            "is_async": false,
            "line": 201
          },
          {
            "name": "clear_run_cache",
            "signature": "(run_id: str) -> None",
            "docstring": "Clear the evaluation cache for a run (call on run completion).",
            "is_async": false,
            "line": 242
          },
          {
            "name": "_mark_evaluated",
            "signature": "(run_id: str, policy_id: str) -> None",
            "docstring": "Mark a policy as evaluated for a run.",
            "is_async": false,
            "line": 248
          },
          {
            "name": "_was_evaluated",
            "signature": "(run_id: str, policy_id: str) -> bool",
            "docstring": "Check if a policy was already evaluated for a run.",
            "is_async": false,
            "line": 255
          },
          {
            "name": "_check_fields_changed",
            "signature": "(policy: Any, context: Dict[str, Any]) -> bool",
            "docstring": "Check if monitored fields changed (for ON_CHANGE binding).",
            "is_async": false,
            "line": 260
          }
        ],
        "classes": [
          {
            "name": "BindingMoment",
            "docstring": "When a policy should be evaluated.",
            "methods": [],
            "line": 58
          },
          {
            "name": "EvaluationPoint",
            "docstring": "Current point in execution where evaluation is requested.",
            "methods": [],
            "line": 67
          },
          {
            "name": "BindingDecision",
            "docstring": "Decision about whether to evaluate a policy.",
            "methods": [],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "Optional",
              "Any",
              "Dict",
              "Set"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "claim_decision_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/claim_decision_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 123,
        "module_docstring": "Domain engine for recovery claim decisions.\n\nThis L4 engine defines the authoritative rules for:\n1. Claim eligibility - what candidates qualify for evaluation\n2. Status determination - how evaluation results map to status\n\nPhase R-4 Note:\nL5 workers no longer import this module. Configuration is shared via\nenvironment variables. Simple data extractions are inlined in L5.\n\nReference: PIN-257 Phase R-4\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md",
        "functions": [
          {
            "name": "is_candidate_claimable",
            "signature": "(confidence: Optional[float]) -> bool",
            "docstring": "Determine if a candidate is eligible for claiming based on confidence.\n\nThis is an L4 domain decision. L5 workers must NOT hardcode thresholds.\n\nA candidate is claimable if:\n- confidence is None (never evaluated), OR\n- confidence is at or below the eligibility threshold\n\nArgs:\n    confidence: Current confidence score (0.0 to 1.0), or None if never evaluated\n\nReturns:\n    True if candidate is eligible for claiming and evaluation\n\nReference: PIN-257 Phase E-4 Extraction #4",
            "is_async": false,
            "line": 47
          },
          {
            "name": "determine_claim_status",
            "signature": "(evaluation_result: Dict[str, Any]) -> str",
            "docstring": "Determine the execution status from an evaluation result.\n\nThis is an L4 domain decision. L5 workers must NOT implement status logic.\n\nStatus mapping:\n- \"succeeded\": No error in result\n- \"failed\": Error present in result\n\nArgs:\n    evaluation_result: Result dict from evaluation, may contain \"error\" key\n\nReturns:\n    Status string: \"succeeded\" or \"failed\"\n\nReference: PIN-257 Phase E-4 Extraction #4",
            "is_async": false,
            "line": 75
          },
          {
            "name": "get_result_confidence",
            "signature": "(evaluation_result: Dict[str, Any]) -> float",
            "docstring": "Extract confidence from evaluation result with default fallback.\n\nThis is an L4 domain decision for confidence extraction.\n\nArgs:\n    evaluation_result: Result dict from evaluation\n\nReturns:\n    Confidence score (defaults to 0.2 if not present)\n\nReference: PIN-257 Phase E-4 Extraction #4",
            "is_async": false,
            "line": 97
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          }
        ],
        "constants": [],
        "all_exports": [
          "CLAIM_ELIGIBILITY_THRESHOLD",
          "is_candidate_claimable",
          "determine_claim_status",
          "get_result_confidence"
        ]
      },
      {
        "file_name": "compiler_parser.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/compiler_parser.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 460,
        "module_docstring": "Parser for PLang v2.0 with M19 category support.\n\nProduces an AST from tokens, supporting:\n- Policy declarations with categories\n- Rule declarations with priorities\n- Condition blocks (when/then)\n- Action blocks (deny/allow/escalate/route)\n- Expression evaluation",
        "functions": [],
        "classes": [
          {
            "name": "ParseError",
            "docstring": "Error during parsing.",
            "methods": [
              "__init__"
            ],
            "line": 57
          },
          {
            "name": "Parser",
            "docstring": "Parser for PLang v2.0.\n\nConverts tokens into an AST with M19 governance metadata.",
            "methods": [
              "__init__",
              "from_source",
              "current",
              "peek",
              "advance",
              "expect",
              "match",
              "parse",
              "parse_policy_decl",
              "parse_category",
              "parse_policy_body",
              "parse_rule_decl",
              "parse_rule_body",
              "parse_rule_ref",
              "parse_condition_block",
              "parse_action_block",
              "parse_route_target",
              "parse_priority",
              "parse_import",
              "parse_expr",
              "parse_or_expr",
              "parse_and_expr",
              "parse_not_expr",
              "parse_comparison",
              "parse_value",
              "parse_func_call"
            ],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.policy.ast.nodes",
            "names": [
              "ActionBlockNode",
              "ASTNode",
              "AttrAccessNode",
              "BinaryOpNode",
              "ConditionBlockNode",
              "ExprNode",
              "FuncCallNode",
              "IdentNode",
              "ImportNode",
              "LiteralNode",
              "PolicyDeclNode",
              "PriorityNode",
              "ProgramNode",
              "RouteTargetNode",
              "RuleDeclNode",
              "RuleRefNode",
              "UnaryOpNode"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.policy.compiler.tokenizer",
            "names": [
              "Token",
              "Tokenizer",
              "TokenType"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "content_accuracy.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/content_accuracy.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 386,
        "module_docstring": null,
        "functions": [
          {
            "name": "validate_content_accuracy",
            "signature": "(output: str, context: Dict[str, Any], user_query: Optional[str] = None, strict_mode: bool = True) -> ContentAccuracyResult",
            "docstring": "Convenience function to validate content accuracy.\n\nUsage:\n    result = validate_content_accuracy(\n        output=\"Yes, your contract is set to auto-renew on January 1, 2026.\",\n        context={\"auto_renew\": None, \"customer_id\": \"cust_8372\"},\n        user_query=\"Is my contract auto-renewed?\"\n    )\n\n    if result.result == ValidationResult.FAIL:\n        # Block the response or create incident\n        pass",
            "is_async": false,
            "line": 344
          }
        ],
        "classes": [
          {
            "name": "AssertionType",
            "docstring": "Types of assertions detected in output.",
            "methods": [],
            "line": 36
          },
          {
            "name": "ValidationResult",
            "docstring": "Result of content accuracy validation.",
            "methods": [],
            "line": 45
          },
          {
            "name": "AssertionCheck",
            "docstring": "A single assertion check result.",
            "methods": [],
            "line": 54
          },
          {
            "name": "ContentAccuracyResult",
            "docstring": "Complete result of content accuracy validation.",
            "methods": [
              "to_dict"
            ],
            "line": 67
          },
          {
            "name": "ContentAccuracyValidator",
            "docstring": "Validates that LLM output does not make assertions about missing data.\n\nPrevention mechanism for the CONTENT_ACCURACY policy gap:\n- Detects when output makes definitive claims\n- Checks if the claimed data exists in context\n- Blocks/warns when assertions are made about NULL/missing fields",
            "methods": [
              "__init__",
              "validate",
              "_detect_assertion_type",
              "_get_nested_value",
              "_extract_claim",
              "_claims_affirmative"
            ],
            "line": 158
          }
        ],
        "imports": [
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          }
        ],
        "constants": [
          {
            "name": "DEFINITIVE_PATTERNS",
            "line": 104
          },
          {
            "name": "UNCERTAINTY_PATTERNS",
            "line": 119
          },
          {
            "name": "HEDGED_PATTERNS",
            "line": 135
          },
          {
            "name": "CONTRACT_TERMS",
            "line": 149
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "cus_enforcement_service.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/cus_enforcement_service.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 80,
        "module_docstring": "CusEnforcementService (SWEEP-03 Batch 2)\n\nPURPOSE:\n    Enforcement policy evaluation for customer LLM integrations.\n    Called by cus_enforcement.py API endpoints.\n\nINTERFACE:\n    - CusEnforcementService (alias for CusEnforcementEngine)\n    - EnforcementResult (enum)\n    - EnforcementReason (dataclass)\n    - EnforcementDecision (dataclass)\n    - get_cus_enforcement_service(session) -> CusEnforcementService\n\nIMPLEMENTATION NOTES:\n    Re-exports from existing cus_enforcement_engine.py which is already\n    properly structured with L4/L6 separation.\n    Future work may fully migrate the implementation to HOC.",
        "functions": [
          {
            "name": "get_cus_enforcement_service",
            "signature": "() -> CusEnforcementService",
            "docstring": "Get the CusEnforcementService instance.\n\nReturns:\n    CusEnforcementService instance\n\nNote:\n    Delegates to get_cus_enforcement_engine() which creates the engine\n    with proper L6 driver injection.",
            "is_async": false,
            "line": 59
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.services.cus_enforcement_engine",
            "names": [
              "CusEnforcementEngine",
              "EnforcementDecision",
              "EnforcementReason",
              "EnforcementResult",
              "get_cus_enforcement_engine"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": [
          "CusEnforcementService",
          "CusEnforcementEngine",
          "EnforcementResult",
          "EnforcementReason",
          "EnforcementDecision",
          "get_cus_enforcement_service",
          "get_cus_enforcement_engine"
        ]
      },
      {
        "file_name": "customer_policy_read_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/customer_policy_read_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 343,
        "module_docstring": "Customer Policy Read Service (L4)\n\nThis service provides all READ operations for the Policy domain.\nIt delegates DB access to PolicyReadDriver (L6) and applies business logic.\n\nL3 (Adapter) \u2192 L4 (this service) \u2192 L6 (PolicyReadDriver)\n\nResponsibilities:\n- Calculate period bounds (business logic)\n- Calculate budget remaining/percentage (business logic)\n- Assemble customer-safe DTOs\n- Rate limits defaults (business logic)\n- Delegate DB queries to driver\n\nBusiness Logic (stays in L4):\n- _calculate_period_bounds() - daily/weekly/monthly period calculation\n- Budget remaining calculation\n- Percentage calculation\n- Rate limit defaults\n\nReference: PIN-281, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_customer_policy_read_service",
            "signature": "(session: 'Session') -> CustomerPolicyReadService",
            "docstring": "Factory function for CustomerPolicyReadService.\n\nArgs:\n    session: SQLModel session (REQUIRED - must be provided by L3 adapter)\n\nReturns:\n    Configured CustomerPolicyReadService instance\n\nNote:\n    Session must be provided by caller. This engine does not create sessions.\n    Session creation is the responsibility of L3 adapters.",
            "is_async": false,
            "line": 329
          }
        ],
        "classes": [
          {
            "name": "BudgetConstraint",
            "docstring": "Customer-visible budget constraint.\n\nIMPORTANT: No internal threshold multipliers, no warning levels.\nThis is what customers see for their budget status.",
            "methods": [],
            "line": 67
          },
          {
            "name": "RateLimit",
            "docstring": "Customer-visible rate limit.\n\nIMPORTANT: No internal bucket configuration exposed.",
            "methods": [],
            "line": 84
          },
          {
            "name": "GuardrailSummary",
            "docstring": "Customer-visible guardrail summary.\n\nIMPORTANT: No threshold values, no rule_config, no priority.\nCustomers see what guardrails exist and their actions, not how they're implemented.",
            "methods": [],
            "line": 98
          },
          {
            "name": "PolicyConstraints",
            "docstring": "Customer-visible policy constraints summary.\n\nThis is the aggregate view of all constraints affecting a tenant.",
            "methods": [],
            "line": 115
          },
          {
            "name": "CustomerPolicyReadService",
            "docstring": "L4 service for policy constraint read operations.\n\nDelegates DB operations to PolicyReadDriver (L6).\nApplies business logic for period calculation, budget math, etc.\n\nINVARIANT: tenant_id is REQUIRED for budget operations.\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "get_policy_constraints",
              "get_guardrail_detail",
              "_get_budget_constraint",
              "_calculate_period_bounds",
              "_get_rate_limits",
              "_get_guardrails"
            ],
            "line": 129
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_read_driver",
            "names": [
              "PolicyReadDriver",
              "get_policy_read_driver"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "decorator.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/decorator.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 192,
        "module_docstring": "@governed Decorator - PIN-337 Optional Ergonomic Wrapper\n\nThis decorator provides convenient syntax for routing execution\nthrough the ExecutionKernel.\n\nIMPORTANT:\n- This decorator is OPTIONAL, not required\n- CI does NOT enforce decorator presence\n- CI enforces KERNEL usage (semantic), not syntax\n- The decorator is CONVENIENCE, the kernel is PHYSICS",
        "functions": [
          {
            "name": "governed",
            "signature": "(capability: str, execution_vector: str = 'HTTP', extract_tenant: Optional[Callable[..., str]] = None, extract_subject: Optional[Callable[..., str]] = None, reason: Optional[str] = None) -> Callable[[F], F]",
            "docstring": "Decorator that routes execution through the ExecutionKernel.\n\nUsage:\n    @governed(capability=\"CAP-019\", execution_vector=\"HTTP_ADMIN\")\n    @app.post(\"/admin/retry\")\n    async def retry_run(payload: RetryRequest):\n        # Business logic here\n        ...\n\nArgs:\n    capability: The capability ID (e.g., \"CAP-019\")\n    execution_vector: Where execution is coming from (HTTP, CLI, SDK, etc.)\n    extract_tenant: Optional callable to extract tenant_id from args/kwargs\n    extract_subject: Optional callable to extract subject from args/kwargs\n    reason: Optional reason for the execution\n\nReturns:\n    Decorated function that routes through kernel\n\nIMPORTANT:\n    - This decorator is OPTIONAL\n    - CI does not enforce decorator presence\n    - CI enforces kernel usage (semantic check)",
            "is_async": false,
            "line": 49
          },
          {
            "name": "_extract_tenant_id",
            "signature": "(args: tuple, kwargs: dict, extractor: Optional[Callable[..., str]]) -> str",
            "docstring": "Extract tenant_id from function arguments.",
            "is_async": false,
            "line": 139
          },
          {
            "name": "_extract_subject",
            "signature": "(args: tuple, kwargs: dict, extractor: Optional[Callable[..., str]]) -> str",
            "docstring": "Extract subject from function arguments.",
            "is_async": false,
            "line": 168
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "functools",
            "names": [
              "functools"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "inspect",
            "names": [
              "inspect"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Optional",
              "TypeVar"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.governance.kernel",
            "names": [
              "ExecutionKernel",
              "InvocationContext"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [
          {
            "name": "F",
            "line": 46
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "degraded_mode.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/degraded_mode.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 217,
        "module_docstring": "Degraded Mode - Graceful Governance Degradation\n\nWhen governance systems are partially unavailable, the system\ncan enter degraded mode:\n- New runs are blocked\n- Existing runs continue with WARN action\n- Telemetry and logging continue\n\nThis prevents cascading failures while maintaining visibility.",
        "functions": [
          {
            "name": "enter_degraded_mode",
            "signature": "(reason: str, entered_by: str, existing_runs_action: str = 'WARN') -> DegradedModeTransition",
            "docstring": "Enter degraded mode.\n\nNew runs will be blocked, existing runs continue with warnings.\n\nArgs:\n    reason: Why degraded mode is being entered\n    entered_by: Identifier of operator/system entering\n    existing_runs_action: Action for in-flight runs (WARN, ALLOW, BLOCK)\n\nReturns:\n    DegradedModeTransition result",
            "is_async": false,
            "line": 71
          },
          {
            "name": "exit_degraded_mode",
            "signature": "(exited_by: str = 'system') -> DegradedModeTransition",
            "docstring": "Exit degraded mode.\n\nRestores normal governance operation.\n\nArgs:\n    exited_by: Identifier of operator/system exiting\n\nReturns:\n    DegradedModeTransition result",
            "is_async": false,
            "line": 120
          },
          {
            "name": "is_degraded_mode_active",
            "signature": "() -> bool",
            "docstring": "Check if degraded mode is currently active.\n\nReturns:\n    True if system is in degraded mode",
            "is_async": false,
            "line": 159
          },
          {
            "name": "get_degraded_mode_status",
            "signature": "() -> DegradedModeStatus",
            "docstring": "Get current degraded mode status.\n\nReturns:\n    Current DegradedModeStatus",
            "is_async": false,
            "line": 170
          },
          {
            "name": "should_allow_new_run",
            "signature": "(run_id: str) -> bool",
            "docstring": "Check if a new run should be allowed.\n\nIn degraded mode, new runs are blocked.\n\nArgs:\n    run_id: ID of the run being started\n\nReturns:\n    True if run should be allowed, False to block",
            "is_async": false,
            "line": 185
          },
          {
            "name": "get_existing_run_action",
            "signature": "() -> str",
            "docstring": "Get action for existing/in-flight runs in degraded mode.\n\nReturns:\n    Action string: WARN, ALLOW, or BLOCK",
            "is_async": false,
            "line": 207
          }
        ],
        "classes": [
          {
            "name": "DegradedModeStatus",
            "docstring": "Current status of degraded mode.",
            "methods": [
              "get_inactive"
            ],
            "line": 47
          },
          {
            "name": "DegradedModeTransition",
            "docstring": "Result of degraded mode transition.",
            "methods": [],
            "line": 63
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "threading",
            "names": [
              "Lock"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "deterministic_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/deterministic_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 513,
        "module_docstring": "Deterministic execution engine for PLang v2.0.\n\nKey principles:\n- NO RANDOMNESS: Every execution is reproducible\n- GOVERNANCE-FIRST: Safety checks before any action\n- AUDITABLE: Full execution trace for debugging\n- DETERMINISTIC: Same input = same output\n\nIntegration points:\n- M18: Intent emission for execution\n- M19: Policy validation before actions\n- M4: Execution plan generation",
        "functions": [],
        "classes": [
          {
            "name": "ExecutionStatus",
            "docstring": "Status of policy execution.",
            "methods": [],
            "line": 63
          },
          {
            "name": "ExecutionContext",
            "docstring": "Execution context for policy evaluation.\n\nContains all runtime state needed for deterministic execution.",
            "methods": [
              "__post_init__",
              "_generate_id",
              "get_variable",
              "set_variable",
              "push_call",
              "pop_call",
              "add_trace"
            ],
            "line": 74
          },
          {
            "name": "ExecutionResult",
            "docstring": "Result of policy execution.\n\nContains final decision, intents, and audit trail.",
            "methods": [
              "to_dict"
            ],
            "line": 157
          },
          {
            "name": "DeterministicEngine",
            "docstring": "Deterministic policy execution engine.\n\nExecutes compiled IR with:\n- No randomness (reproducible)\n- Governance validation\n- Intent emission\n- Full audit trail",
            "methods": [
              "__init__",
              "_register_builtins",
              "execute",
              "_execute_function",
              "_execute_instruction",
              "_eval_binary_op",
              "_eval_unary_op",
              "_eval_compare",
              "_call_function",
              "_action_to_intent_type"
            ],
            "line": 187
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRAction",
              "IRBinaryOp",
              "IRCall",
              "IRCheckPolicy",
              "IRCompare",
              "IREmitIntent",
              "IRFunction",
              "IRInstruction",
              "IRJump",
              "IRJumpIf",
              "IRLoadConst",
              "IRLoadVar",
              "IRModule",
              "IRReturn",
              "IRStoreVar",
              "IRUnaryOp"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.policy.runtime.intent",
            "names": [
              "Intent",
              "IntentEmitter",
              "IntentPayload",
              "IntentType"
            ],
            "is_relative": false,
            "line": 60
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "dsl_parser.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/dsl_parser.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 523,
        "module_docstring": "Policy DSL Parser\n\nConverts DSL text into typed, immutable AST nodes.\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- Single-pass recursive descent parser\n- No external parser libraries (no PLY, no ANTLR)\n- All errors must be position-aware\n- Must produce valid AST or raise ParseError\n\nGRAMMAR (Simplified EBNF):\n    policy      := header clause+\n    header      := 'policy' NAME 'version' INT 'scope' SCOPE 'mode' MODE\n    clause      := 'when' condition 'then' action+\n    condition   := or_expr\n    or_expr     := and_expr ('OR' and_expr)*\n    and_expr    := atom ('AND' atom)*\n    atom        := predicate | exists_pred | '(' or_expr ')'\n    predicate   := METRIC comparator value\n    exists_pred := 'exists' '(' METRIC ')'\n    comparator  := '>' | '>=' | '<' | '<=' | '==' | '!='\n    value       := INT | FLOAT | STRING | BOOL\n    action      := 'WARN' STRING | 'BLOCK' | 'REQUIRE_APPROVAL'\n\nGOVERNANCE:\n- Pure parsing logic\n- No side effects\n- No I/O, no DB",
        "functions": [
          {
            "name": "parse",
            "signature": "(source: str) -> PolicyAST",
            "docstring": "Parse Policy DSL text into AST.\n\nArgs:\n    source: The DSL source text\n\nReturns:\n    PolicyAST: The parsed AST\n\nRaises:\n    ParseError: If the source is invalid\n\nExample:\n    >>> ast = parse('''\n    ... policy CostGuard\n    ... version 1\n    ... scope PROJECT\n    ... mode MONITOR\n    ...\n    ... when cost_per_hour > 200\n    ... then WARN \"Cost exceeded threshold\"\n    ... ''')\n    >>> ast.name\n    'CostGuard'",
            "is_async": false,
            "line": 467
          },
          {
            "name": "parse_condition",
            "signature": "(source: str) -> Condition",
            "docstring": "Parse a standalone condition expression.\n\nUseful for testing or building conditions programmatically.\n\nArgs:\n    source: The condition expression\n\nReturns:\n    Condition: The parsed condition\n\nExample:\n    >>> cond = parse_condition(\"cost > 100 AND error_rate > 0.1\")\n    >>> is_logical_condition(cond)\n    True",
            "is_async": false,
            "line": 499
          }
        ],
        "classes": [
          {
            "name": "ParseLocation",
            "docstring": "Source location for error reporting.",
            "methods": [
              "__str__"
            ],
            "line": 81
          },
          {
            "name": "ParseError",
            "docstring": "Raised when parsing fails.\n\nContains position information for helpful error messages.",
            "methods": [
              "__init__"
            ],
            "line": 91
          },
          {
            "name": "Token",
            "docstring": "A lexical token with position info.",
            "methods": [],
            "line": 113
          },
          {
            "name": "Lexer",
            "docstring": "Tokenizer for Policy DSL.\n\nProduces tokens from source text for the parser.",
            "methods": [
              "__init__",
              "tokenize",
              "_advance",
              "_convert_value"
            ],
            "line": 122
          },
          {
            "name": "Parser",
            "docstring": "Recursive descent parser for Policy DSL.\n\nConverts token stream to typed AST.",
            "methods": [
              "__init__",
              "current",
              "error",
              "expect",
              "accept",
              "parse",
              "_parse_header",
              "_parse_clauses",
              "_parse_clause",
              "_parse_condition",
              "_parse_or_expr",
              "_parse_and_expr",
              "_parse_atom",
              "_parse_predicate",
              "_parse_value",
              "_parse_actions",
              "_try_parse_action"
            ],
            "line": 244
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.dsl.ast",
            "names": [
              "Action",
              "BlockAction",
              "Clause",
              "Comparator",
              "Condition",
              "ExistsPredicate",
              "LogicalCondition",
              "LogicalOperator",
              "Mode",
              "PolicyAST",
              "PolicyMetadata",
              "Predicate",
              "RequireApprovalAction",
              "Scope",
              "WarnAction"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "eligibility_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/eligibility_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 836,
        "module_docstring": "Part-2 Eligibility Engine (L4)\n\nApplies eligibility rules to determine if a validated proposal MAY or\nMAY_NOT become a System Contract. The engine is pure - it receives data\nvia lookups, does not fetch externally.\n\nResponsibilities:\n1. Evaluate MAY_NOT rules (rejection rules)\n2. Evaluate MAY rules (acceptance rules)\n3. Produce deterministic verdicts\n4. Track rule evaluation for auditing\n\nInvariants (from ELIGIBILITY_RULES.md):\n- ELIG-001: Eligibility is deterministic (pure function, no side effects)\n- ELIG-002: Every verdict has a reason (required field)\n- ELIG-003: MAY_NOT rules take precedence (evaluation order)\n- ELIG-004: Health degradation blocks all (E-104 priority)\n- ELIG-005: Frozen capabilities are inviolable (E-102 check)\n\nReference: PIN-289, ELIGIBILITY_RULES.md, part2-design-v1",
        "functions": [],
        "classes": [
          {
            "name": "EligibilityDecision",
            "docstring": "Binary eligibility decision.\n\nReference: ELIGIBILITY_RULES.md",
            "methods": [],
            "line": 94
          },
          {
            "name": "SystemHealthStatus",
            "docstring": "System health status for E-104 rule.",
            "methods": [],
            "line": 110
          },
          {
            "name": "EligibilityConfig",
            "docstring": "Eligibility engine configuration.\n\nReference: ELIGIBILITY_RULES.md Configuration",
            "methods": [],
            "line": 125
          },
          {
            "name": "CapabilityLookup",
            "docstring": "Protocol for capability registry lookups.",
            "methods": [
              "exists",
              "is_frozen"
            ],
            "line": 157
          },
          {
            "name": "GovernanceSignalLookup",
            "docstring": "Protocol for governance signal lookups.",
            "methods": [
              "has_blocking_signal"
            ],
            "line": 169
          },
          {
            "name": "SystemHealthLookup",
            "docstring": "Protocol for system health lookups.",
            "methods": [
              "get_status"
            ],
            "line": 183
          },
          {
            "name": "ContractLookup",
            "docstring": "Protocol for contract lookups.",
            "methods": [
              "has_similar_pending"
            ],
            "line": 191
          },
          {
            "name": "PreApprovalLookup",
            "docstring": "Protocol for pre-approval lookups.",
            "methods": [
              "has_system_pre_approval"
            ],
            "line": 209
          },
          {
            "name": "DefaultCapabilityLookup",
            "docstring": "Default capability lookup using provided registry.\n\nFor production, inject a database-backed lookup.",
            "methods": [
              "__init__",
              "exists",
              "is_frozen"
            ],
            "line": 222
          },
          {
            "name": "DefaultGovernanceSignalLookup",
            "docstring": "Default governance signal lookup with no blocking signals.\n\nFor production, inject a database-backed lookup.",
            "methods": [
              "__init__",
              "has_blocking_signal"
            ],
            "line": 244
          },
          {
            "name": "DefaultSystemHealthLookup",
            "docstring": "Default system health lookup returning HEALTHY.\n\nFor production, inject a real health service lookup.",
            "methods": [
              "__init__",
              "get_status"
            ],
            "line": 260
          },
          {
            "name": "DefaultContractLookup",
            "docstring": "Default contract lookup with no pending contracts.\n\nFor production, inject a database-backed lookup.",
            "methods": [
              "__init__",
              "has_similar_pending"
            ],
            "line": 274
          },
          {
            "name": "DefaultPreApprovalLookup",
            "docstring": "Default pre-approval lookup with no pre-approvals.\n\nFor production, inject a database-backed lookup.",
            "methods": [
              "__init__",
              "has_system_pre_approval"
            ],
            "line": 299
          },
          {
            "name": "EligibilityInput",
            "docstring": "Input to the eligibility engine.\n\nReference: ELIGIBILITY_RULES.md",
            "methods": [],
            "line": 319
          },
          {
            "name": "RuleResult",
            "docstring": "Result of evaluating a single rule.",
            "methods": [],
            "line": 340
          },
          {
            "name": "EligibilityVerdict",
            "docstring": "Output from the eligibility engine.\n\nReference: ELIGIBILITY_RULES.md Eligibility Verdict Schema\n\nInvariant ELIG-002: Every verdict has a reason (required field)",
            "methods": [],
            "line": 356
          },
          {
            "name": "EligibilityEngine",
            "docstring": "Part-2 Eligibility Engine (L4)\n\nEvaluates eligibility rules to determine if a proposal MAY or MAY_NOT\nbecome a System Contract.\n\nProperties:\n- DETERMINISTIC: Same input produces same output (ELIG-001)\n- BINARY: MAY or MAY_NOT, no \"maybe\"\n- AUDITABLE: Every decision has a reason (ELIG-002)\n- PURE: No side effects, no writes\n\nRule Evaluation Order:\n1. MAY_NOT rules (E-100 series) evaluated first\n2. If any MAY_NOT triggers \u2192 immediate MAY_NOT verdict\n3. MAY rules (E-001 series) evaluated in order\n4. If all MAY rules pass \u2192 MAY verdict\n5. If any MAY rule fails \u2192 MAY_NOT verdict\n\nReference: ELIGIBILITY_RULES.md, part2-design-v1",
            "methods": [
              "__init__",
              "evaluate",
              "_evaluate_e104_health_degraded",
              "_evaluate_e100_below_minimum_confidence",
              "_evaluate_e101_critical_without_escalation",
              "_evaluate_e102_frozen_capability",
              "_evaluate_e103_system_scope_without_preapproval",
              "_evaluate_e001_confidence_threshold",
              "_evaluate_e002_known_capability",
              "_evaluate_e003_no_blocking_signal",
              "_evaluate_e004_actionable_type",
              "_evaluate_e005_source_allowlist",
              "_evaluate_e006_not_duplicate",
              "_create_verdict"
            ],
            "line": 381
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional",
              "Protocol"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "app.hoc.cus.general.L4_runtime.engines",
            "names": [
              "IssueType",
              "RecommendedAction",
              "Severity",
              "ValidatorVerdict"
            ],
            "is_relative": false,
            "line": 75
          }
        ],
        "constants": [
          {
            "name": "ELIGIBILITY_ENGINE_VERSION",
            "line": 86
          },
          {
            "name": "DEFAULT_ELIGIBILITY_CONFIG",
            "line": 149
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 2843,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_policy_engine",
            "signature": "() -> PolicyEngine",
            "docstring": "Get singleton policy engine with M18 Governor integration.",
            "is_async": false,
            "line": 2825
          }
        ],
        "classes": [
          {
            "name": "PolicyEngine",
            "docstring": "M19 Policy Engine - Constitutional Governance Layer.\n\nEvery agent decision must go through policy.evaluate() before execution.\n\nResponsibilities:\n- Enforce compliance rules\n- Enforce ethical constraints\n- Enforce risk ceilings\n- Enforce safety rules\n- Enforce business rules\n- Route violations to M18 Governor\n- Audit all evaluations",
            "methods": [
              "__init__",
              "evaluate",
              "pre_check",
              "_check_ethical_constraints",
              "_evaluate_ethical_constraint",
              "_extract_text_content",
              "_check_safety_rules",
              "_evaluate_safety_rule",
              "_check_cooldown",
              "_check_risk_ceilings",
              "_evaluate_risk_ceiling",
              "_get_windowed_value",
              "_add_windowed_value",
              "_check_compliance",
              "_evaluate_compliance_rule",
              "_check_business_rules",
              "_evaluate_business_rule",
              "_route_to_governor",
              "_load_policies",
              "_load_default_policies",
              "_is_cache_stale",
              "_persist_evaluation",
              "get_state",
              "reload_policies",
              "set_governor",
              "get_violations",
              "get_violation",
              "acknowledge_violation",
              "get_risk_ceilings",
              "get_risk_ceiling",
              "update_risk_ceiling",
              "reset_risk_ceiling",
              "get_safety_rules",
              "update_safety_rule",
              "get_ethical_constraints",
              "get_active_cooldowns",
              "clear_cooldowns",
              "get_metrics",
              "get_policy_versions",
              "get_current_version",
              "create_policy_version",
              "rollback_to_version",
              "get_version_provenance",
              "get_dependency_graph",
              "get_policy_conflicts",
              "resolve_conflict",
              "get_temporal_policies",
              "create_temporal_policy",
              "get_temporal_utilization",
              "evaluate_with_context",
              "_classify_severity",
              "_classify_recoverability",
              "validate_dependency_dag",
              "add_dependency_with_dag_check",
              "get_topological_evaluation_order",
              "prune_temporal_metrics",
              "get_temporal_storage_stats",
              "activate_policy_version"
            ],
            "line": 154
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 80
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 82
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 83
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 84
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 85
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 86
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 87
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 88
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 89
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_engine_driver",
            "names": [
              "PolicyEngineDriver",
              "get_policy_engine_driver"
            ],
            "is_relative": false,
            "line": 95
          },
          {
            "module": "sqlalchemy.exc",
            "names": [
              "SQLAlchemyError"
            ],
            "is_relative": false,
            "line": 102
          },
          {
            "module": "app.policy.models",
            "names": [
              "ActionType",
              "BusinessRule",
              "BusinessRuleType",
              "EthicalConstraint",
              "EthicalConstraintType",
              "Policy",
              "PolicyCategory",
              "PolicyDecision",
              "PolicyEvaluationRequest",
              "PolicyEvaluationResult",
              "PolicyLoadResult",
              "PolicyModification",
              "PolicyRule",
              "PolicyState",
              "PolicyViolation",
              "RiskCeiling",
              "SafetyRule",
              "SafetyRuleType",
              "ViolationType"
            ],
            "is_relative": false,
            "line": 104
          },
          {
            "module": "app.contracts.decisions",
            "names": [
              "emit_policy_decision"
            ],
            "is_relative": false,
            "line": 129
          }
        ],
        "constants": [
          {
            "name": "POLICY_SIGNING_SECRET",
            "line": 136
          },
          {
            "name": "MAX_EVALUATION_TIME_MS",
            "line": 139
          },
          {
            "name": "CACHE_TTL_SECONDS",
            "line": 140
          },
          {
            "name": "DEFAULT_COST_CEILING_PER_HOUR",
            "line": 143
          },
          {
            "name": "DEFAULT_RETRY_CEILING_PER_MINUTE",
            "line": 144
          },
          {
            "name": "DEFAULT_CASCADE_DEPTH",
            "line": 145
          },
          {
            "name": "DEFAULT_CONCURRENT_AGENTS",
            "line": 146
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "failure_mode_handler.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/failure_mode_handler.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 273,
        "module_docstring": "Module: failure_mode_handler\nPurpose: Handles failure modes when policy evaluation fails or is uncertain.\n\nKey Principle: FAIL-CLOSED by default.\nIf policy evaluation fails, the system MUST block the action, not allow it.\n\nImports (Dependencies):\n    - app.services.governance.profile: get_governance_config\n\nExports (Provides):\n    - handle_policy_failure(error, context) -> FailureDecision\n    - FailureMode: Enum of failure modes\n    - FailureDecision: Decision when failure occurs\n\nWiring Points:\n    - Called from: prevention_engine.py when evaluation fails\n    - Logs: All failures for audit\n\nAcceptance Criteria:\n    - [x] AC-035-01: Default is fail-closed\n    - [x] AC-035-02: Missing policy = blocked\n    - [x] AC-035-03: Evaluation error = blocked\n    - [x] AC-035-04: All failures logged\n    - [x] AC-035-05: No hardcoded fail-open",
        "functions": [
          {
            "name": "get_failure_mode",
            "signature": "() -> FailureMode",
            "docstring": "Get configured failure mode.\n\nReturns:\n    FailureMode from governance config, defaulting to FAIL_CLOSED",
            "is_async": false,
            "line": 88
          },
          {
            "name": "handle_policy_failure",
            "signature": "(error: Optional[Exception], context: Dict[str, Any], failure_type: FailureType = FailureType.UNKNOWN) -> FailureDecision",
            "docstring": "Handle a policy evaluation failure.\n\nThis function determines what action to take when policy evaluation\nfails. The default is FAIL-CLOSED (block the action).\n\nArgs:\n    error: The exception that occurred, if any\n    context: Evaluation context (run_id, tenant_id, etc.)\n    failure_type: Type of failure\n\nReturns:\n    FailureDecision with action to take",
            "is_async": false,
            "line": 122
          },
          {
            "name": "handle_missing_policy",
            "signature": "(context: Dict[str, Any]) -> FailureDecision",
            "docstring": "Handle case where no policy exists for the action.\n\nBy default, missing policy = BLOCK (fail-closed).\n\nArgs:\n    context: Evaluation context\n\nReturns:\n    FailureDecision",
            "is_async": false,
            "line": 221
          },
          {
            "name": "handle_evaluation_error",
            "signature": "(error: Exception, context: Dict[str, Any]) -> FailureDecision",
            "docstring": "Handle policy evaluation error.\n\nArgs:\n    error: The exception that occurred\n    context: Evaluation context\n\nReturns:\n    FailureDecision",
            "is_async": false,
            "line": 240
          },
          {
            "name": "handle_timeout",
            "signature": "(context: Dict[str, Any], timeout_seconds: float) -> FailureDecision",
            "docstring": "Handle policy evaluation timeout.\n\nArgs:\n    context: Evaluation context\n    timeout_seconds: How long before timeout\n\nReturns:\n    FailureDecision",
            "is_async": false,
            "line": 258
          }
        ],
        "classes": [
          {
            "name": "FailureMode",
            "docstring": "Failure mode for policy evaluation.",
            "methods": [],
            "line": 55
          },
          {
            "name": "FailureType",
            "docstring": "Type of failure encountered.",
            "methods": [],
            "line": 62
          },
          {
            "name": "FailureDecision",
            "docstring": "Decision made when failure occurs.",
            "methods": [],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Optional",
              "Any",
              "Dict"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_FAILURE_MODE",
            "line": 85
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "folds.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/folds.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 403,
        "module_docstring": "IR optimizations for PLang v2.0.\n\nOptimizations:\n- Constant folding: Evaluate constant expressions at compile time\n- Dead code elimination: Remove unreachable code\n- Policy simplification: Merge compatible policies",
        "functions": [],
        "classes": [
          {
            "name": "FoldResult",
            "docstring": "Result of a folding operation.",
            "methods": [],
            "line": 50
          },
          {
            "name": "ConstantFolder",
            "docstring": "Constant folding optimization.\n\nEvaluates constant expressions at compile time without\naffecting governance semantics.",
            "methods": [
              "__init__",
              "fold_module",
              "fold_function",
              "fold_block",
              "try_fold",
              "_fold_binary_op",
              "_fold_unary_op",
              "_fold_compare"
            ],
            "line": 58
          },
          {
            "name": "DeadCodeEliminator",
            "docstring": "Dead code elimination.\n\nRemoves unreachable code and unused definitions while\npreserving governance-critical paths.",
            "methods": [
              "__init__",
              "eliminate",
              "_mark_governance_critical",
              "_eliminate_function",
              "_find_reachable_blocks",
              "_find_used_instructions"
            ],
            "line": 196
          },
          {
            "name": "PolicySimplifier",
            "docstring": "Policy-specific simplifications.\n\nMerges compatible policies based on governance rules\nwhile preserving semantic correctness.",
            "methods": [
              "__init__",
              "simplify",
              "_find_mergeable_policies",
              "_merge_policies"
            ],
            "line": 325
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRAction",
              "IRBinaryOp",
              "IRBlock",
              "IRCompare",
              "IRFunction",
              "IRInstruction",
              "IRJump",
              "IRJumpIf",
              "IRLoadConst",
              "IRModule",
              "IRUnaryOp"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "governance_facade.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/governance_facade.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 618,
        "module_docstring": "Governance Facade (L4 Domain Logic)\n\nThis facade provides the external interface for governance control operations.\nAll governance APIs MUST use this facade instead of directly importing\ninternal governance modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes governance control logic\n- Provides unified access to kill switch, degraded mode, conflict resolution\n- Single point for audit emission\n\nWrapped Services:\n- runtime_switch: Kill switch and degraded mode (GAP-069, GAP-070)\n- ConflictResolver: Policy conflict resolution (GAP-068)\n- BootGuard: SPINE component health (GAP-067)\n\nL2 API Routes (GAP-090 to GAP-095):\n- POST /api/v1/governance/kill-switch (GAP-090)\n- POST /api/v1/governance/mode (GAP-091)\n- POST /api/v1/governance/resolve-conflict (GAP-092)\n- GET /api/v1/governance/boot-status (GAP-095)\n\nUsage:\n    from app.hoc.cus.policies.L5_engines.governance_facade import get_governance_facade\n\n    facade = get_governance_facade()\n\n    # Check governance state\n    state = facade.get_governance_state()\n\n    # Enable kill switch\n    facade.enable_kill_switch(reason=\"Emergency\", actor=\"operator\")\n\n    # Enter degraded mode\n    facade.set_mode(mode=\"DEGRADED\", reason=\"High load\", actor=\"system\")",
        "functions": [
          {
            "name": "get_governance_facade",
            "signature": "() -> GovernanceFacade",
            "docstring": "Get the governance facade instance.\n\nThis is the recommended way to access governance control operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    GovernanceFacade instance",
            "is_async": false,
            "line": 605
          }
        ],
        "classes": [
          {
            "name": "GovernanceMode",
            "docstring": "Governance operation modes.",
            "methods": [],
            "line": 62
          },
          {
            "name": "GovernanceStateResult",
            "docstring": "Result of governance state query.",
            "methods": [
              "to_dict"
            ],
            "line": 70
          },
          {
            "name": "KillSwitchResult",
            "docstring": "Result of kill switch operation.",
            "methods": [
              "to_dict"
            ],
            "line": 92
          },
          {
            "name": "ConflictResolutionResult",
            "docstring": "Result of conflict resolution.",
            "methods": [
              "to_dict"
            ],
            "line": 116
          },
          {
            "name": "BootStatusResult",
            "docstring": "Result of boot status check.",
            "methods": [
              "to_dict"
            ],
            "line": 140
          },
          {
            "name": "GovernanceFacade",
            "docstring": "Facade for governance control operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ngovernance control services.\n\nLayer: L4 (Domain Logic)\nCallers: governance.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "enable_kill_switch",
              "disable_kill_switch",
              "set_mode",
              "get_governance_state",
              "resolve_conflict",
              "list_conflicts",
              "get_boot_status"
            ],
            "line": 157
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "grammar.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/grammar.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 216,
        "module_docstring": "PLang v2.0 Grammar (EBNF):\n\nprogram         ::= statement*\nstatement       ::= policy_decl | rule_decl | import_stmt\npolicy_decl     ::= 'policy' IDENT ':' category '{' policy_body '}'\ncategory        ::= 'SAFETY' | 'PRIVACY' | 'OPERATIONAL' | 'ROUTING' | 'CUSTOM'\npolicy_body     ::= (rule_ref | condition_block | action_block)*\nrule_ref        ::= 'rule' IDENT\ncondition_block ::= 'when' expr 'then' action_block\naction_block    ::= 'deny' | 'allow' | 'escalate' | 'route' route_target\nroute_target    ::= 'to' IDENT\nexpr            ::= or_expr\nor_expr         ::= and_expr ('or' and_expr)*\nand_expr        ::= not_expr ('and' not_expr)*\nnot_expr        ::= 'not' not_expr | comparison\ncomparison      ::= value (comp_op value)?\ncomp_op         ::= '==' | '!=' | '<' | '>' | '<=' | '>='\nvalue           ::= IDENT | NUMBER | STRING | 'true' | 'false' | func_call | attr_access\nattr_access     ::= value '.' IDENT\nfunc_call       ::= IDENT '(' args? ')'\nargs            ::= expr (',' expr)*\nrule_decl       ::= 'rule' IDENT ':' category '{' rule_body '}'\nrule_body       ::= (priority_decl | condition_block | action_block)*\npriority_decl   ::= 'priority' NUMBER\nimport_stmt     ::= 'import' STRING",
        "functions": [],
        "classes": [
          {
            "name": "GrammarNodeType",
            "docstring": "Grammar node types for PLang v2.0.",
            "methods": [],
            "line": 55
          },
          {
            "name": "PolicyCategory",
            "docstring": "M19 Policy Categories.",
            "methods": [],
            "line": 86
          },
          {
            "name": "ActionType",
            "docstring": "Policy action types.",
            "methods": [],
            "line": 96
          },
          {
            "name": "GrammarProduction",
            "docstring": "A production rule in the grammar.",
            "methods": [],
            "line": 108
          },
          {
            "name": "PLangGrammar",
            "docstring": "PLang v2.0 Grammar Definition.",
            "methods": [
              "get_category_priority",
              "get_action_precedence",
              "is_keyword",
              "is_operator",
              "is_category",
              "is_action"
            ],
            "line": 118
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "List",
              "Set"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [
          {
            "name": "PLANG_GRAMMAR",
            "line": 216
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "intent.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/intent.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 365,
        "module_docstring": "Intent system for PLang v2.0 runtime.\n\nIntents are the bridge between policy decisions and M18 execution:\n- Policy compiler emits intents based on actions\n- M18 executes intents with governance constraints\n- M19 validates intents before execution\n\nIntent types:\n- ROUTE: Route to specific agent\n- ESCALATE: Escalate to higher authority\n- EXECUTE: Execute with constraints\n- DENY: Block execution with reason\n- ALLOW: Permit execution",
        "functions": [],
        "classes": [
          {
            "name": "IntentType",
            "docstring": "Types of intents emitted by policy runtime.",
            "methods": [],
            "line": 45
          },
          {
            "name": "IntentPayload",
            "docstring": "Payload data for an intent.\n\nContains all data needed for M18 to execute the intent.",
            "methods": [
              "to_dict",
              "from_dict"
            ],
            "line": 58
          },
          {
            "name": "Intent",
            "docstring": "An intent emitted by the policy runtime.\n\nRepresents a governance-validated action to be executed by M18.",
            "methods": [
              "__post_init__",
              "_generate_id",
              "to_dict",
              "from_dict"
            ],
            "line": 118
          },
          {
            "name": "IntentEmitter",
            "docstring": "Emits intents from policy runtime to M18.\n\nHandles:\n- Intent creation\n- M19 validation\n- M18 delivery\n- Audit logging",
            "methods": [
              "__init__",
              "create_intent",
              "validate_intent",
              "emit",
              "emit_all",
              "register_handler",
              "get_pending",
              "get_emitted",
              "clear"
            ],
            "line": 199
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "interpreter.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/interpreter.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 562,
        "module_docstring": "Policy DSL Interpreter\n\nPure evaluation of compiled IR against runtime facts.\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- PURE: No side effects, no I/O, no DB, no network\n- NO CONTEXT: No tenants, actors, permissions, time\n- DESCRIPTIVE OUTPUT: Returns what is true, not what to do\n- STACK-BASED: Explicit stack for condition evaluation\n- NO COERCION: Type mismatches raise errors\n\nINPUT:\n- PolicyIR: Compiled intermediate representation\n- Facts: dict[str, value] - runtime metric values\n\nOUTPUT:\n- EvaluationResult: Describes which clauses matched and what actions apply\n\nGOVERNANCE:\n- Interpreter output defines policy truth\n- IR compiler and future JIT must conform to this\n- Replay uses interpreter, always",
        "functions": [
          {
            "name": "evaluate",
            "signature": "(ir: PolicyIR, facts: dict[str, Any]) -> EvaluationResult",
            "docstring": "Evaluate policy IR against facts.\n\nThis is the CANONICAL evaluation function.\nAll other evaluation paths (JIT, cached, etc.) must produce\nidentical results.\n\nArgs:\n    ir: Compiled PolicyIR\n    facts: dict mapping metric names to values\n\nReturns:\n    EvaluationResult describing what matched\n\nRaises:\n    EvaluationError: On runtime errors\n\nExample:\n    >>> from app.dsl import parse, validate, compile_policy\n    >>> ast = parse('''\n    ... policy CostGuard\n    ... version 1\n    ... scope PROJECT\n    ... mode MONITOR\n    ...\n    ... when cost > 100\n    ... then WARN \"High cost\"\n    ... ''')\n    >>> ir = compile_policy(ast)\n    >>> result = evaluate(ir, {\"cost\": 150})\n    >>> result.any_matched\n    True\n    >>> result.all_actions[0].type\n    'WARN'",
            "is_async": false,
            "line": 447
          },
          {
            "name": "evaluate_policy",
            "signature": "(ir: PolicyIR, facts: dict[str, Any], strict: bool = True) -> EvaluationResult",
            "docstring": "Evaluate policy with optional strict mode.\n\nArgs:\n    ir: Compiled PolicyIR\n    facts: dict mapping metric names to values\n    strict: If True, missing metrics raise error.\n            If False, missing metrics treated as not-exists.\n\nReturns:\n    EvaluationResult describing what matched\n\nNote: strict=False is useful for partial evaluation,\n      but strict=True is required for audit-grade evaluation.",
            "is_async": false,
            "line": 490
          }
        ],
        "classes": [
          {
            "name": "EvaluationError",
            "docstring": "Raised when evaluation fails.\n\nThis is NOT a policy violation - it's a runtime error\n(e.g., type mismatch, missing required metric).",
            "methods": [
              "__init__"
            ],
            "line": 62
          },
          {
            "name": "TypeMismatchError",
            "docstring": "Raised when types are incompatible for comparison.",
            "methods": [],
            "line": 79
          },
          {
            "name": "MissingMetricError",
            "docstring": "Raised when a required metric is not in facts.",
            "methods": [],
            "line": 85
          },
          {
            "name": "ActionResult",
            "docstring": "A single action from evaluation.\n\nThis is DESCRIPTIVE - it says what action applies,\nnot what to do about it.",
            "methods": [
              "to_dict"
            ],
            "line": 97
          },
          {
            "name": "ClauseResult",
            "docstring": "Evaluation result for a single clause.\n\nDESCRIPTIVE: Says whether the clause matched and what actions apply.",
            "methods": [
              "to_dict"
            ],
            "line": 116
          },
          {
            "name": "EvaluationResult",
            "docstring": "Complete evaluation result for a policy.\n\nDESCRIPTIVE OUTPUT:\n- any_matched: Did any clause match?\n- clauses: Per-clause results\n- all_actions: Aggregated actions from all matching clauses\n\nThis tells you WHAT IS TRUE, not what to do about it.",
            "methods": [
              "to_dict",
              "has_block",
              "has_require_approval",
              "warnings"
            ],
            "line": 134
          },
          {
            "name": "Interpreter",
            "docstring": "Pure interpreter for Policy IR.\n\nPURITY GUARANTEE:\n- No side effects\n- No access to DB, time, network, globals\n- No knowledge of tenants, actors, permissions\n\nInput = IR + facts\nOutput = EvaluationResult",
            "methods": [
              "__init__",
              "evaluate",
              "_evaluate_clause",
              "_evaluate_condition",
              "_execute_instruction",
              "_compare",
              "_types_compatible",
              "_collect_actions"
            ],
            "line": 178
          },
          {
            "name": "_LenientInterpreter",
            "docstring": "Lenient interpreter that treats missing metrics as non-matching.\n\nNOT for audit-grade evaluation - only for previews/simulation.",
            "methods": [
              "_execute_instruction",
              "_compare"
            ],
            "line": 519
          },
          {
            "name": "_MissingSentinel",
            "docstring": "Sentinel value for missing metrics.",
            "methods": [],
            "line": 556
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.dsl.ir_compiler",
            "names": [
              "CompiledClause",
              "Instruction",
              "OpCode",
              "PolicyIR"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [
          {
            "name": "_MISSING_SENTINEL",
            "line": 562
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "ir_builder.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/ir_builder.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 408,
        "module_docstring": "IR Builder for PLang v2.0.\n\nTransforms AST nodes into IR with:\n- M19 category propagation\n- Symbol table population\n- Basic block construction\n- Governance metadata attachment",
        "functions": [],
        "classes": [
          {
            "name": "IRBuilder",
            "docstring": "Builds IR from PLang AST.\n\nTransforms AST into IR with governance metadata propagation.",
            "methods": [
              "__init__",
              "build",
              "_next_id",
              "_next_block_name",
              "_emit",
              "_new_block",
              "visit_program",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_import",
              "visit_rule_ref",
              "visit_priority",
              "visit_condition_block",
              "visit_action_block",
              "visit_route_target",
              "visit_binary_op",
              "visit_unary_op",
              "visit_ident",
              "visit_literal",
              "visit_func_call",
              "visit_attr_access"
            ],
            "line": 78
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.policy.ast.nodes",
            "names": [
              "ActionBlockNode",
              "AttrAccessNode",
              "BinaryOpNode",
              "ConditionBlockNode",
              "FuncCallNode",
              "IdentNode",
              "ImportNode",
              "LiteralNode",
              "PolicyDeclNode",
              "PriorityNode",
              "ProgramNode",
              "RouteTargetNode",
              "RuleDeclNode",
              "RuleRefNode",
              "UnaryOpNode"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.policy.ast.visitors",
            "names": [
              "BaseVisitor"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRAction",
              "IRBinaryOp",
              "IRBlock",
              "IRCall",
              "IRCompare",
              "IREmitIntent",
              "IRFunction",
              "IRGovernance",
              "IRInstruction",
              "IRJump",
              "IRJumpIf",
              "IRLoadConst",
              "IRLoadVar",
              "IRModule",
              "IRReturn",
              "IRType",
              "IRUnaryOp"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.policy.ir.symbol_table",
            "names": [
              "Symbol",
              "SymbolTable",
              "SymbolType"
            ],
            "is_relative": false,
            "line": 71
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "ir_compiler.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/ir_compiler.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 460,
        "module_docstring": "Policy DSL Intermediate Representation (IR) Compiler\n\nCompiles validated AST into deterministic bytecode for the interpreter.\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- CLOSED instruction set (exactly 10 opcodes)\n- Deterministic: Same AST \u2192 Same IR \u2192 Same hash\n- No evaluation logic (pure compilation)\n- No jumps, labels, or control flow\n- IR structure is hashable for audit identity\n\nINSTRUCTION SET (CLOSED - NO ADDITIONS):\n    LOAD_METRIC     - Load metric value onto stack\n    LOAD_CONST      - Load constant value onto stack\n    COMPARE         - Compare two values (metric CMP const)\n    EXISTS          - Check if metric exists\n    AND             - Logical AND of two booleans\n    OR              - Logical OR of two booleans\n    EMIT_WARN       - Emit warning action\n    EMIT_BLOCK      - Emit block action\n    EMIT_REQUIRE_APPROVAL - Emit require approval action\n    END             - End of clause/program\n\nSAFE OPTIMIZATIONS (ALLOWED):\n- Constant folding (evaluate known constants)\n- Dead action elimination (unreachable code)\n- Metric de-duplication (load once, reference many)\n\nFORBIDDEN OPTIMIZATIONS:\n- Short-circuit evaluation\n- Any semantic changes\n- Execution logic\n\nGOVERNANCE:\n- IR is the audit identity of a policy\n- Replay uses IR, not DSL text",
        "functions": [
          {
            "name": "compile_policy",
            "signature": "(ast: PolicyAST, optimize: bool = False) -> PolicyIR",
            "docstring": "Compile PolicyAST to PolicyIR.\n\nArgs:\n    ast: Validated PolicyAST\n    optimize: Enable safe optimizations (default False for max determinism)\n\nReturns:\n    PolicyIR: Compiled intermediate representation\n\nExample:\n    >>> from app.dsl import parse, validate\n    >>> ast = parse('''\n    ... policy CostGuard\n    ... version 1\n    ... scope PROJECT\n    ... mode MONITOR\n    ...\n    ... when cost > 100\n    ... then WARN \"High cost\"\n    ... ''')\n    >>> result = validate(ast)\n    >>> assert result.is_valid\n    >>> ir = compile_policy(ast)\n    >>> ir.compute_hash()\n    'a1b2c3...'",
            "is_async": false,
            "line": 418
          },
          {
            "name": "ir_hash",
            "signature": "(ast: PolicyAST) -> str",
            "docstring": "Convenience function to get IR hash from AST.\n\nThis is the audit identity of the policy.",
            "is_async": false,
            "line": 453
          }
        ],
        "classes": [
          {
            "name": "OpCode",
            "docstring": "Closed instruction set for Policy IR.\n\nGUARANTEE: This enum will never grow beyond these 10 opcodes.\nAny new functionality requires a new IR version.",
            "methods": [],
            "line": 89
          },
          {
            "name": "Instruction",
            "docstring": "A single IR instruction.\n\nImmutable to ensure IR integrity after compilation.",
            "methods": [
              "to_dict"
            ],
            "line": 115
          },
          {
            "name": "CompiledClause",
            "docstring": "Compiled form of a single when-then clause.\n\nContains:\n- condition_ir: Instructions to evaluate the condition\n- action_ir: Instructions to emit actions (if condition true)",
            "methods": [
              "to_dict"
            ],
            "line": 134
          },
          {
            "name": "PolicyIR",
            "docstring": "Complete IR for a policy.\n\nGUARANTEE: Same AST \u2192 Same IR \u2192 Same hash",
            "methods": [
              "to_dict",
              "to_json",
              "compute_hash",
              "instruction_count"
            ],
            "line": 155
          },
          {
            "name": "IRCompiler",
            "docstring": "Compiles PolicyAST to PolicyIR.\n\nThe compiler is stateless - each compile() call is independent.",
            "methods": [
              "__init__",
              "compile",
              "_compile_clause",
              "_compile_condition",
              "_emit_condition",
              "_emit_predicate",
              "_emit_exists",
              "_emit_logical",
              "_compile_actions"
            ],
            "line": 209
          },
          {
            "name": "OptimizingIRCompiler",
            "docstring": "IR Compiler with safe optimizations.\n\nSAFE OPTIMIZATIONS:\n- Metric de-duplication: Track loaded metrics, reuse references\n- Constant folding: Pre-compute known constant operations\n\nFORBIDDEN:\n- Short-circuit evaluation\n- Dead code elimination that changes observable behavior\n- Any semantic modifications",
            "methods": [
              "__init__",
              "compile"
            ],
            "line": 388
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.dsl.ast",
            "names": [
              "Action",
              "Clause",
              "Condition",
              "ExistsPredicate",
              "LogicalCondition",
              "LogicalOperator",
              "PolicyAST",
              "Predicate",
              "is_block_action",
              "is_exists_predicate",
              "is_logical_condition",
              "is_predicate",
              "is_require_approval_action",
              "is_warn_action"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "ir_nodes.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/ir_nodes.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 404,
        "module_docstring": "IR nodes for PLang v2.0 compilation.\n\nIR design principles:\n- Category-aware: Every node carries governance metadata\n- SSA-like: Single assignment for optimization\n- Intent-oriented: Designed for M18 intent emission\n- Deterministic: Reproducible execution paths",
        "functions": [],
        "classes": [
          {
            "name": "IRType",
            "docstring": "IR value types.",
            "methods": [],
            "line": 40
          },
          {
            "name": "IRGovernance",
            "docstring": "Governance metadata for IR nodes.\n\nPropagated from AST through compilation to runtime.\nUsed by M19 policy engine for validation.",
            "methods": [
              "from_ast",
              "to_dict"
            ],
            "line": 55
          },
          {
            "name": "IRNode",
            "docstring": "Base class for all IR nodes.",
            "methods": [
              "__str__"
            ],
            "line": 95
          },
          {
            "name": "IRInstruction",
            "docstring": "Base class for IR instructions.",
            "methods": [],
            "line": 112
          },
          {
            "name": "IRLoadConst",
            "docstring": "Load constant value.",
            "methods": [
              "__str__"
            ],
            "line": 119
          },
          {
            "name": "IRLoadVar",
            "docstring": "Load variable value.",
            "methods": [
              "__str__"
            ],
            "line": 129
          },
          {
            "name": "IRStoreVar",
            "docstring": "Store value to variable.",
            "methods": [
              "__str__"
            ],
            "line": 139
          },
          {
            "name": "IRBinaryOp",
            "docstring": "Binary operation.",
            "methods": [
              "__str__"
            ],
            "line": 150
          },
          {
            "name": "IRUnaryOp",
            "docstring": "Unary operation.",
            "methods": [
              "__str__"
            ],
            "line": 162
          },
          {
            "name": "IRCompare",
            "docstring": "Comparison operation.",
            "methods": [
              "__str__"
            ],
            "line": 173
          },
          {
            "name": "IRJump",
            "docstring": "Unconditional jump.",
            "methods": [
              "__str__"
            ],
            "line": 186
          },
          {
            "name": "IRJumpIf",
            "docstring": "Conditional jump.",
            "methods": [
              "__str__"
            ],
            "line": 196
          },
          {
            "name": "IRCall",
            "docstring": "Function call.",
            "methods": [
              "__str__"
            ],
            "line": 208
          },
          {
            "name": "IRReturn",
            "docstring": "Return from function.",
            "methods": [
              "__str__"
            ],
            "line": 220
          },
          {
            "name": "IRAction",
            "docstring": "Policy action instruction.\n\nActions: deny, allow, escalate, route",
            "methods": [
              "__str__"
            ],
            "line": 232
          },
          {
            "name": "IRCheckPolicy",
            "docstring": "Check against M19 policy engine.\n\nEmits validation request to policy engine before action.",
            "methods": [
              "__str__"
            ],
            "line": 253
          },
          {
            "name": "IREmitIntent",
            "docstring": "Emit intent to M18 execution layer.\n\nIntents are executed by M18 with governance constraints.",
            "methods": [
              "__str__"
            ],
            "line": 270
          },
          {
            "name": "IRBlock",
            "docstring": "Basic block in IR.\n\nContains a sequence of instructions with single entry/exit.",
            "methods": [
              "add_instruction",
              "is_terminated",
              "__str__"
            ],
            "line": 298
          },
          {
            "name": "IRFunction",
            "docstring": "Function in IR.\n\nRepresents a policy or rule as a callable unit.",
            "methods": [
              "add_block",
              "get_block",
              "__str__"
            ],
            "line": 330
          },
          {
            "name": "IRModule",
            "docstring": "Module in IR.\n\nRepresents a complete compiled PLang program.",
            "methods": [
              "add_function",
              "get_function",
              "get_functions_by_category",
              "__str__"
            ],
            "line": 362
          }
        ],
        "imports": [
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "kernel.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/kernel.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 623,
        "module_docstring": "ExecutionKernel - PIN-337 Governance Enforcement Infrastructure\n\nThis is the MANDATORY choke point for all EXECUTE-power paths.\nAll execution must flow through this kernel.\n\nINVARIANTS:\n- Every EXECUTE path MUST call ExecutionKernel.invoke()\n- Kernel MUST NOT block execution in v1 (PERMISSIVE mode)\n- Kernel MUST emit ExecutionEnvelope for attribution\n- Kernel MUST record invocation metrics\n- Unknown capability_id = CI FAIL (compile-time), not runtime block\n\nThe kernel is PHYSICS, not POLICY.\nIf code doesn't call the kernel, it doesn't execute.",
        "functions": [
          {
            "name": "get_enforcement_mode",
            "signature": "(capability_id: str) -> EnforcementMode",
            "docstring": "Get enforcement mode for a capability.\n\nArgs:\n    capability_id: The capability ID (e.g., \"CAP-019\")\n\nReturns:\n    EnforcementMode for this capability (default: PERMISSIVE)",
            "is_async": false,
            "line": 75
          },
          {
            "name": "set_enforcement_mode",
            "signature": "(capability_id: str, mode: EnforcementMode) -> None",
            "docstring": "Set enforcement mode for a capability.\n\nThis is CONFIG-DRIVEN, not code-driven.\nUsed for gradual rollout of strictness.\n\nArgs:\n    capability_id: The capability ID\n    mode: The enforcement mode to set",
            "is_async": false,
            "line": 88
          }
        ],
        "classes": [
          {
            "name": "EnforcementMode",
            "docstring": "Enforcement mode for capability execution.\n\nPERMISSIVE: Log and allow (v1 default)\nSTRICT: Enforce authority and policy (v2+, opt-in per capability)",
            "methods": [],
            "line": 55
          },
          {
            "name": "InvocationContext",
            "docstring": "Context for an execution invocation.\n\nCaptures WHO is invoking, WHAT they're invoking, and WHERE from.",
            "methods": [],
            "line": 115
          },
          {
            "name": "ExecutionResult",
            "docstring": "Result of an execution through the kernel.\n\nWraps the actual result with governance metadata.",
            "methods": [],
            "line": 149
          },
          {
            "name": "ExecutionKernel",
            "docstring": "Mandatory execution kernel - single choke point for all EXECUTE power.\n\nAll EXECUTE-power paths MUST route through this kernel:\n- HTTP handlers that mutate state\n- CLI commands that execute logic\n- SDK methods that trigger execution\n- Workers that process jobs\n- AUTO_EXECUTE recovery paths\n\nINVARIANTS:\n- v1: PERMISSIVE (log and allow, never block)\n- Envelope emission is ALWAYS on\n- Invocation recording is ALWAYS on\n- Strictness is capability-scoped, never global\n\nThe kernel is PHYSICS, not POLICY.",
            "methods": [
              "invoke",
              "invoke_async",
              "_emit_envelope",
              "_record_invocation_start",
              "_record_invocation_complete",
              "is_known_capability",
              "get_known_capabilities"
            ],
            "line": 182
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Optional",
              "TypeVar"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [
          {
            "name": "T",
            "line": 47
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "keys_shim.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/keys_shim.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 152,
        "module_docstring": "Keys Service (L4) \u2014 DEPRECATED SHIM\n\nThis service delegates all operations to KeysDriver.\nMaintained for backward compatibility with existing callers.\n\nUse KeysDriver directly for new code.",
        "functions": [
          {
            "name": "get_keys_read_service",
            "signature": "(session: 'Session') -> KeysReadService",
            "docstring": "Factory function to get KeysReadService instance.",
            "is_async": false,
            "line": 137
          },
          {
            "name": "get_keys_write_service",
            "signature": "(session: 'Session') -> KeysWriteService",
            "docstring": "Factory function to get KeysWriteService instance.",
            "is_async": false,
            "line": 142
          }
        ],
        "classes": [
          {
            "name": "KeysReadService",
            "docstring": "L4 service for API key read operations.\n\nDEPRECATED: Use KeysDriver directly.\nThis class delegates all operations to KeysDriver.",
            "methods": [
              "__init__",
              "list_keys",
              "get_key",
              "get_key_usage_today"
            ],
            "line": 52
          },
          {
            "name": "KeysWriteService",
            "docstring": "L4 service for API key write operations.\n\nDEPRECATED: Use KeysDriver directly.\nThis class delegates all operations to KeysDriver.",
            "methods": [
              "__init__",
              "freeze_key",
              "unfreeze_key"
            ],
            "line": 102
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.apis.L6_drivers.keys_driver",
            "names": [
              "KeysDriver",
              "get_keys_driver"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.models.tenant",
            "names": [
              "APIKey"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": [
          "KeysReadService",
          "KeysWriteService",
          "get_keys_read_service",
          "get_keys_write_service"
        ]
      },
      {
        "file_name": "kill_switch.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/kill_switch.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 223,
        "module_docstring": "Kill Switch - Runtime Governance Bypass\n\nProvides emergency governance disable capability without restart.\nWhen active, all governance checks are bypassed (fail-open mode).\n\nUse cases:\n- Emergency maintenance\n- Security incident response\n- Governance system failures\n\nSecurity considerations:\n- Activation requires authenticated operator\n- All activations are logged\n- Automatic timeout for safety",
        "functions": [
          {
            "name": "activate_kill_switch",
            "signature": "(reason: str, activated_by: str, auto_expire_minutes: int = 60) -> KillSwitchActivation",
            "docstring": "Activate the runtime kill switch.\n\nWhen active, governance checks are bypassed (fail-open).\n\nArgs:\n    reason: Why the kill switch is being activated\n    activated_by: Identifier of operator activating\n    auto_expire_minutes: Auto-deactivate after this many minutes\n\nReturns:\n    KillSwitchActivation result",
            "is_async": false,
            "line": 90
          },
          {
            "name": "deactivate_kill_switch",
            "signature": "(deactivated_by: str = 'system') -> KillSwitchDeactivation",
            "docstring": "Deactivate the runtime kill switch.\n\nRestores normal governance enforcement.\n\nArgs:\n    deactivated_by: Identifier of operator deactivating\n\nReturns:\n    KillSwitchDeactivation result",
            "is_async": false,
            "line": 147
          },
          {
            "name": "is_kill_switch_active",
            "signature": "() -> bool",
            "docstring": "Check if kill switch is currently active.\n\nAlso handles auto-expiration.\n\nReturns:\n    True if governance should be bypassed",
            "is_async": false,
            "line": 186
          },
          {
            "name": "should_bypass_governance",
            "signature": "() -> bool",
            "docstring": "Check if governance should be bypassed.\n\nAlias for is_kill_switch_active() for clearer intent.\n\nReturns:\n    True if governance checks should be skipped",
            "is_async": false,
            "line": 214
          }
        ],
        "classes": [
          {
            "name": "KillSwitchStatus",
            "docstring": "Current status of the kill switch.",
            "methods": [
              "get_current"
            ],
            "line": 52
          },
          {
            "name": "KillSwitchActivation",
            "docstring": "Result of kill switch activation.",
            "methods": [],
            "line": 72
          },
          {
            "name": "KillSwitchDeactivation",
            "docstring": "Result of kill switch deactivation.",
            "methods": [],
            "line": 82
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "threading",
            "names": [
              "Lock"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "learning_proof_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/learning_proof_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 850,
        "module_docstring": "M25 Learning Proof System\n\nThis module provides the evidence that the integration loop actually LEARNS,\nnot just executes. It tracks:\n\n1. PREVENTION PROOF - Did a policy actually prevent a second incident?\n2. REGRET TRACKING - Did a policy cause harm? Auto-demote if so.\n3. ADAPTIVE CONFIDENCE - Calibrate thresholds based on outcomes, not assumptions.\n4. CHECKPOINT PRIORITY - Make human decisions tractable, not noisy.\n\n\"A system that can safely attempt to improve itself\" is different from\n\"A system that demonstrably improves itself.\" This module proves the latter.",
        "functions": [],
        "classes": [
          {
            "name": "PreventionOutcome",
            "docstring": "Outcome of a prevention attempt.",
            "methods": [],
            "line": 47
          },
          {
            "name": "PreventionRecord",
            "docstring": "Evidence that a policy prevented a recurrence.\n\nThis is THE critical proof that M25 works. Without this,\nwe have plumbing, not learning.",
            "methods": [
              "create_prevention",
              "to_console_timeline"
            ],
            "line": 57
          },
          {
            "name": "PreventionTracker",
            "docstring": "Tracks prevention effectiveness across policies.\n\nAnswers: \"Are our policies actually preventing incidents?\"",
            "methods": [
              "record_prevention",
              "record_failure",
              "prevention_rate",
              "has_proven_prevention",
              "get_top_preventing_patterns"
            ],
            "line": 125
          },
          {
            "name": "RegretType",
            "docstring": "Types of policy regret.",
            "methods": [],
            "line": 171
          },
          {
            "name": "RegretEvent",
            "docstring": "A single regret event - when a policy caused harm.\n\n\"Regret\" is the opposite of prevention. It's when our attempt\nto improve made things worse.",
            "methods": [],
            "line": 182
          },
          {
            "name": "PolicyRegretTracker",
            "docstring": "Tracks regret for individual policies.\n\nImplements automatic demotion when regret threshold exceeded.",
            "methods": [
              "add_regret",
              "_trigger_demotion",
              "decay_regret",
              "is_demoted",
              "to_rollback_timeline"
            ],
            "line": 209
          },
          {
            "name": "GlobalRegretTracker",
            "docstring": "System-wide regret tracking.\n\nAnswers: \"Is the system causing harm?\"",
            "methods": [
              "get_or_create_tracker",
              "record_regret",
              "has_proven_rollback",
              "system_regret_rate"
            ],
            "line": 279
          },
          {
            "name": "PatternCalibration",
            "docstring": "Per-pattern confidence calibration based on actual outcomes.\n\nReplaces static 0.85/0.60 thresholds with empirical ones.",
            "methods": [
              "record_outcome",
              "_recalibrate",
              "accuracy",
              "is_calibrated",
              "get_calibrated_band"
            ],
            "line": 324
          },
          {
            "name": "AdaptiveConfidenceSystem",
            "docstring": "System-wide adaptive confidence management.\n\nMoves from \"cargo cult math\" to empirical calibration.",
            "methods": [
              "get_or_create_calibration",
              "record_outcome",
              "get_threshold_for_pattern",
              "get_confidence_report"
            ],
            "line": 412
          },
          {
            "name": "CheckpointPriority",
            "docstring": "Priority levels for human checkpoints.",
            "methods": [],
            "line": 475
          },
          {
            "name": "CheckpointConfig",
            "docstring": "Per-tenant checkpoint configuration.\n\nPrevents checkpoint fatigue by allowing customization.",
            "methods": [
              "is_blocking",
              "get_priority",
              "should_auto_dismiss"
            ],
            "line": 486
          },
          {
            "name": "PrioritizedCheckpoint",
            "docstring": "Enhanced checkpoint with priority and configurability.",
            "methods": [
              "create",
              "check_auto_dismiss"
            ],
            "line": 557
          },
          {
            "name": "M25GraduationStatus",
            "docstring": "The three gates that graduate M25 from \"loop-enabled\" to \"loop-proven\".\n\nUntil all three gates pass, M25 is alpha.",
            "methods": [
              "gate1_passed",
              "gate2_passed",
              "gate3_passed",
              "is_graduated",
              "status_label",
              "to_dashboard",
              "_get_next_action"
            ],
            "line": 625
          },
          {
            "name": "PreventionTimeline",
            "docstring": "Console-ready timeline showing the learning loop in action.\n\nGate 3 requirement: User must SEE the system learn.",
            "methods": [
              "add_incident_created",
              "add_policy_born",
              "add_prevention",
              "add_regret",
              "add_rollback",
              "to_console",
              "_generate_narrative"
            ],
            "line": 727
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "collections",
            "names": [
              "defaultdict"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lessons_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/lessons_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 1080,
        "module_docstring": "Lessons Learned Engine (L4 Domain Logic)\n\nThis engine implements the learning-driven governance pattern:\n- Failures (all severities) \u2192 Lesson created\n- Near-threshold events \u2192 Lesson created\n- Critical success events \u2192 Lesson created\n\nLessons are the memory substrate for policy evolution.\nOnly human action (via PolicyProposalEngine) converts lessons to drafts.\n\nReference: PIN-411, POLICIES_DOMAIN_AUDIT.md Section 11",
        "functions": [
          {
            "name": "is_valid_transition",
            "signature": "(from_status: str, to_status: str) -> bool",
            "docstring": "Check if a state transition is valid.",
            "is_async": false,
            "line": 119
          },
          {
            "name": "get_threshold_band",
            "signature": "(utilization: float) -> str",
            "docstring": "Get the threshold band for a utilization percentage.",
            "is_async": false,
            "line": 153
          },
          {
            "name": "get_lessons_learned_engine",
            "signature": "() -> LessonsLearnedEngine",
            "docstring": "Get the singleton LessonsLearnedEngine instance.",
            "is_async": false,
            "line": 1075
          }
        ],
        "classes": [
          {
            "name": "LessonsLearnedEngine",
            "docstring": "L4 Domain Engine for lesson creation and management.\n\nThis engine implements the learning-driven governance pattern:\n- Detect learning opportunities from system events\n- Create lesson records (memory substrate)\n- Support human-driven conversion to draft proposals\n\nSDSR Contract (PIN-370):\n- This engine is called when events occur\n- It creates lesson records automatically\n- Lessons are NEVER created by scenarios directly\n- If lessons don't appear for events, THIS ENGINE is broken\n\nCallers:\n- IncidentEngine (on failures)\n- Worker runtime (on near-threshold, success)\n- API endpoints (for queries)",
            "methods": [
              "__init__",
              "_get_driver",
              "detect_lesson_from_failure",
              "detect_lesson_from_near_threshold",
              "detect_lesson_from_critical_success",
              "emit_near_threshold",
              "emit_critical_success",
              "list_lessons",
              "get_lesson",
              "convert_lesson_to_draft",
              "defer_lesson",
              "dismiss_lesson",
              "get_lesson_stats",
              "reactivate_deferred_lesson",
              "_is_debounced",
              "_create_lesson",
              "_generate_failure_description",
              "_generate_failure_proposed_action",
              "get_expired_deferred_lessons",
              "reactivate_expired_deferred_lessons"
            ],
            "line": 162
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "uuid",
            "names": [
              "UUID",
              "uuid4"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "prometheus_client",
            "names": [
              "Counter"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.hoc.cus.incidents.L6_drivers.lessons_driver",
            "names": [
              "LessonsDriver",
              "get_lessons_driver"
            ],
            "is_relative": false,
            "line": 66
          }
        ],
        "constants": [
          {
            "name": "LESSONS_CREATION_FAILED",
            "line": 80
          },
          {
            "name": "LESSON_TYPE_FAILURE",
            "line": 91
          },
          {
            "name": "LESSON_TYPE_NEAR_THRESHOLD",
            "line": 92
          },
          {
            "name": "LESSON_TYPE_CRITICAL_SUCCESS",
            "line": 93
          },
          {
            "name": "LESSON_STATUS_PENDING",
            "line": 95
          },
          {
            "name": "LESSON_STATUS_CONVERTED",
            "line": 96
          },
          {
            "name": "LESSON_STATUS_DEFERRED",
            "line": 97
          },
          {
            "name": "LESSON_STATUS_DISMISSED",
            "line": 98
          },
          {
            "name": "SEVERITY_CRITICAL",
            "line": 127
          },
          {
            "name": "SEVERITY_HIGH",
            "line": 128
          },
          {
            "name": "SEVERITY_MEDIUM",
            "line": 129
          },
          {
            "name": "SEVERITY_LOW",
            "line": 130
          },
          {
            "name": "SEVERITY_NONE",
            "line": 131
          },
          {
            "name": "NEAR_THRESHOLD_PERCENT",
            "line": 141
          },
          {
            "name": "DEBOUNCE_WINDOW_HOURS",
            "line": 142
          },
          {
            "name": "THRESHOLD_BANDS",
            "line": 146
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "limits.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/limits.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 157,
        "module_docstring": "Phase-6 Limits \u2014 Derived from Plan (Not Stored)\n\nPIN-399 Phase-6: Limits are derived from plan at runtime, never hand-edited.\n\nDESIGN INVARIANTS (LOCKED):\n- BILLING-002: Limits are derived, not stored\n\nENFORCEMENT SEMANTICS:\n- Limits are evaluated at runtime\n- Limits are enforced after onboarding COMPLETE\n- Limits may emit warnings before enforcement\n\nWHAT LIMITS CAN DO:\n- Throttle\n- Reject with explicit error\n- Emit usage warnings\n\nWHAT LIMITS MUST NOT DO:\n- Mutate onboarding state\n- Revoke API keys silently\n- Affect auth or roles",
        "functions": [
          {
            "name": "derive_limits",
            "signature": "(limits_profile: str) -> Limits",
            "docstring": "Derive limits from a limits profile key.\n\nINVARIANT: This is the single source of limit derivation.\n\nArgs:\n    limits_profile: Profile key from Plan.limits_profile\n\nReturns:\n    Limits instance (immutable)",
            "is_async": false,
            "line": 137
          }
        ],
        "classes": [
          {
            "name": "Limits",
            "docstring": "Phase-6 Limits Model (Immutable, Derived).\n\nLimits are computed from a plan's limits_profile.\nNEVER stored directly in database.\n\nAttributes:\n    max_requests_per_day: Maximum API requests per day\n    max_active_agents: Maximum concurrent agents\n    max_storage_mb: Maximum storage in megabytes\n    max_monthly_cost_usd: Maximum monthly compute cost (soft limit)\n    max_runs_per_day: Maximum run executions per day\n    max_policies: Maximum policy rules\n\nINVARIANTS:\n- All limits are optional (None = unlimited)\n- Limits are derived from limits_profile at runtime\n- Limits are never directly persisted",
            "methods": [
              "is_unlimited"
            ],
            "line": 49
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_LIMITS",
            "line": 127
          }
        ],
        "all_exports": [
          "Limits",
          "derive_limits",
          "LIMITS_PROFILES",
          "DEFAULT_LIMITS"
        ]
      },
      {
        "file_name": "limits_facade.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/limits_facade.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 459,
        "module_docstring": "Limits Facade (L4 Domain Logic)\n\nThis facade provides the external interface for limit operations.\nAll limit APIs MUST use this facade instead of directly importing\ninternal limit modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes rate limit and quota logic\n- Provides unified access to usage tracking\n- Single point for audit emission\n\nL2 API Routes (GAP-122):\n- GET /api/v1/limits (list limits)\n- GET /api/v1/limits/{id} (get limit)\n- PUT /api/v1/limits/{id} (update limit)\n- GET /api/v1/limits/usage (current usage)\n- POST /api/v1/limits/check (check limit)\n- POST /api/v1/limits/reset (reset usage)\n\nUsage:\n    from app.hoc.cus.policies.L5_engines.limits_facade import get_limits_facade\n\n    facade = get_limits_facade()\n\n    # Check a limit\n    result = await facade.check_limit(\n        tenant_id=\"...\",\n        limit_type=\"api_calls\",\n    )",
        "functions": [
          {
            "name": "get_limits_facade",
            "signature": "() -> LimitsFacade",
            "docstring": "Get the limits facade instance.\n\nThis is the recommended way to access limit operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    LimitsFacade instance",
            "is_async": false,
            "line": 446
          }
        ],
        "classes": [
          {
            "name": "LimitType",
            "docstring": "Types of limits.",
            "methods": [],
            "line": 63
          },
          {
            "name": "LimitPeriod",
            "docstring": "Limit period.",
            "methods": [],
            "line": 73
          },
          {
            "name": "LimitConfig",
            "docstring": "Limit configuration.",
            "methods": [
              "to_dict"
            ],
            "line": 82
          },
          {
            "name": "LimitCheckResult",
            "docstring": "Result of checking a limit.",
            "methods": [
              "to_dict"
            ],
            "line": 118
          },
          {
            "name": "UsageSummary",
            "docstring": "Usage summary across all limits.",
            "methods": [
              "to_dict"
            ],
            "line": 142
          },
          {
            "name": "LimitsFacade",
            "docstring": "Facade for limit operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nlimit services.\n\nLayer: L4 (Domain Logic)\nCallers: limits.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "_get_or_create_limit",
              "list_limits",
              "get_limit",
              "update_limit",
              "check_limit",
              "get_usage",
              "reset_limit"
            ],
            "line": 161
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "limits_simulation_service.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/limits_simulation_service.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 80,
        "module_docstring": "LimitsSimulationService (SWEEP-03 Batch 2)\n\nPURPOSE:\n    Pre-execution limit simulation for cost, quota, and policy limits.\n    Called by simulate.py before execution.\n\nINTERFACE:\n    - LimitsSimulationService (alias for LimitsSimulationEngine)\n    - LimitsSimulationServiceError (base exception)\n    - TenantNotFoundError (tenant not found)\n    - get_limits_simulation_service(session) -> LimitsSimulationService\n\nIMPLEMENTATION NOTES:\n    Re-exports from existing simulation_engine.py which is already\n    properly structured with L4/L6 separation.\n    Future work may fully migrate the implementation to HOC.",
        "functions": [
          {
            "name": "get_limits_simulation_service",
            "signature": "(session: 'AsyncSession') -> LimitsSimulationService",
            "docstring": "Get the LimitsSimulationService instance.\n\nArgs:\n    session: AsyncSession for database access\n\nReturns:\n    LimitsSimulationService instance\n\nNote:\n    Delegates to get_limits_simulation_engine() which creates the engine\n    with proper L6 driver injection.",
            "is_async": false,
            "line": 57
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.services.limits.simulation_engine",
            "names": [
              "LimitsSimulationEngine",
              "LimitsSimulationServiceError",
              "TenantNotFoundError",
              "get_limits_simulation_engine"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "LimitsSimulationService",
          "LimitsSimulationEngine",
          "LimitsSimulationServiceError",
          "TenantNotFoundError",
          "get_limits_simulation_service",
          "get_limits_simulation_engine"
        ]
      },
      {
        "file_name": "llm_policy_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/llm_policy_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 442,
        "module_docstring": "L4 LLM Policy Engine - Domain Authority for LLM Safety and Cost Controls\n\nB01/B05 FIX: Moved from L3 adapters to L4 domain engine.\nThis engine is the authoritative source for:\n- Safety limits (max tokens, max cost, rate limits)\n- Model selection policy\n- Budget enforcement\n- Model restrictions\n\nL3 adapters must delegate all policy decisions to this engine.\n\nEnvironment Variables:\n- LLM_MAX_TOKENS_PER_REQUEST: Max tokens per request (default: 16000)\n- LLM_MAX_COST_CENTS_PER_REQUEST: Max cost in cents per request (default: 50)\n- LLM_REQUESTS_PER_MINUTE: Rate limit (default: 60)\n- LLM_ALLOWED_MODELS: Comma-separated list of allowed models (optional)",
        "functions": [
          {
            "name": "estimate_tokens",
            "signature": "(text: str) -> int",
            "docstring": "Estimate token count for text (L4 domain function).\n\nUses rough approximation of 4 chars per token.",
            "is_async": false,
            "line": 199
          },
          {
            "name": "estimate_cost_cents",
            "signature": "(model: str, input_tokens: int, output_tokens: int) -> float",
            "docstring": "Estimate cost in cents (L4 domain function).\n\nArgs:\n    model: Model identifier\n    input_tokens: Number of input tokens\n    output_tokens: Number of output tokens\n\nReturns:\n    Estimated cost in cents",
            "is_async": false,
            "line": 208
          },
          {
            "name": "check_safety_limits",
            "signature": "(model: str, max_tokens: int, estimated_input_tokens: int, provider: str = 'default', max_tokens_limit: Optional[int] = None, max_cost_cents_limit: Optional[float] = None) -> SafetyCheckResult",
            "docstring": "Check safety limits before making LLM API call (L4 domain function).\n\nL3 adapters must call this before invoking LLM APIs.\nThey must NOT implement their own safety checks.\n\nArgs:\n    model: Model identifier\n    max_tokens: Requested max tokens for completion\n    estimated_input_tokens: Estimated input token count\n    provider: Provider name for rate limiter\n    max_tokens_limit: Override max tokens limit\n    max_cost_cents_limit: Override max cost limit\n\nReturns:\n    SafetyCheckResult indicating if request is allowed",
            "is_async": false,
            "line": 226
          },
          {
            "name": "is_model_allowed",
            "signature": "(model: str, tenant_allowed_models: Optional[List[str]] = None) -> bool",
            "docstring": "Check if a model is allowed (L4 domain function).\n\nArgs:\n    model: Model identifier\n    tenant_allowed_models: Optional tenant-specific allowed list\n\nReturns:\n    True if model is allowed",
            "is_async": false,
            "line": 314
          },
          {
            "name": "is_expensive_model",
            "signature": "(model: str) -> bool",
            "docstring": "Check if a model is classified as expensive (L4 domain function).",
            "is_async": false,
            "line": 337
          },
          {
            "name": "get_model_for_task",
            "signature": "(task_type: str, requested_model: Optional[str] = None, tenant_allowed_models: Optional[List[str]] = None, allow_expensive: bool = False) -> str",
            "docstring": "Get appropriate model for a task type (L4 policy decision).\n\nL3 TenantLLMConfig must delegate model selection to this function.\n\nArgs:\n    task_type: Type of task (planning, execution, high_value, default)\n    requested_model: Explicitly requested model\n    tenant_allowed_models: Tenant-specific allowed models\n    allow_expensive: Whether expensive models are permitted\n\nReturns:\n    Model identifier to use",
            "is_async": false,
            "line": 342
          },
          {
            "name": "get_effective_model",
            "signature": "(requested_model: Optional[str], preferred_model: str, fallback_model: str, allowed_models: List[str]) -> str",
            "docstring": "Get effective model based on request and tenant config (L4 policy decision).\n\nL3 TenantLLMConfig.get_effective_model() must delegate to this.\n\nArgs:\n    requested_model: Model explicitly requested\n    preferred_model: Tenant's preferred model\n    fallback_model: Tenant's fallback model\n    allowed_models: Tenant's allowed models list\n\nReturns:\n    Model identifier to use",
            "is_async": false,
            "line": 385
          }
        ],
        "classes": [
          {
            "name": "SafetyCheckResult",
            "docstring": "Result of a safety limit check.",
            "methods": [],
            "line": 130
          },
          {
            "name": "LLMRateLimiter",
            "docstring": "Sliding window rate limiter for LLM requests (L4 policy enforcement).\n\nL3 adapters must use this instead of implementing their own.",
            "methods": [
              "get_instance",
              "__init__",
              "check_and_record",
              "requests_remaining"
            ],
            "line": 140
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "threading",
            "names": [
              "threading"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "collections",
            "names": [
              "deque"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          }
        ],
        "constants": [
          {
            "name": "LLM_MAX_TOKENS_PER_REQUEST",
            "line": 56
          },
          {
            "name": "LLM_MAX_COST_CENTS_PER_REQUEST",
            "line": 59
          },
          {
            "name": "LLM_REQUESTS_PER_MINUTE",
            "line": 62
          },
          {
            "name": "DEFAULT_MODELS",
            "line": 76
          },
          {
            "name": "FALLBACK_MODEL",
            "line": 82
          }
        ],
        "all_exports": [
          "LLM_MAX_TOKENS_PER_REQUEST",
          "LLM_MAX_COST_CENTS_PER_REQUEST",
          "LLM_REQUESTS_PER_MINUTE",
          "LLM_ALLOWED_MODELS",
          "LLM_COST_MODEL",
          "SYSTEM_ALLOWED_MODELS",
          "EXPENSIVE_MODELS",
          "TASK_MODEL_POLICY",
          "SafetyCheckResult",
          "LLMRateLimiter",
          "estimate_tokens",
          "estimate_cost_cents",
          "check_safety_limits",
          "is_model_allowed",
          "is_expensive_model",
          "get_model_for_task",
          "get_effective_model"
        ]
      },
      {
        "file_name": "nodes.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/nodes.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 379,
        "module_docstring": "AST nodes for PLang v2.0.\n\nEach node includes:\n- Source location (line, column)\n- Governance metadata where applicable\n- Type-safe structure for analysis",
        "functions": [],
        "classes": [
          {
            "name": "GovernanceMetadata",
            "docstring": "M19 Governance metadata attached to AST nodes.\n\nThis metadata is carried through compilation to runtime\nfor governance-aware execution.",
            "methods": [
              "merge_with"
            ],
            "line": 39
          },
          {
            "name": "ASTNode",
            "docstring": "Base class for all AST nodes.",
            "methods": [
              "accept",
              "location"
            ],
            "line": 70
          },
          {
            "name": "ExprNode",
            "docstring": "Base class for expression nodes.",
            "methods": [],
            "line": 89
          },
          {
            "name": "ProgramNode",
            "docstring": "Root node representing a complete PLang program.",
            "methods": [
              "accept"
            ],
            "line": 101
          },
          {
            "name": "PolicyDeclNode",
            "docstring": "Policy declaration node.",
            "methods": [
              "__post_init__",
              "accept"
            ],
            "line": 111
          },
          {
            "name": "RuleDeclNode",
            "docstring": "Rule declaration node.",
            "methods": [
              "__post_init__",
              "accept"
            ],
            "line": 133
          },
          {
            "name": "ImportNode",
            "docstring": "Import statement node.",
            "methods": [
              "accept"
            ],
            "line": 154
          },
          {
            "name": "RuleRefNode",
            "docstring": "Reference to a named rule.",
            "methods": [
              "accept"
            ],
            "line": 164
          },
          {
            "name": "PriorityNode",
            "docstring": "Priority declaration node.",
            "methods": [
              "accept"
            ],
            "line": 174
          },
          {
            "name": "ConditionBlockNode",
            "docstring": "When/then condition block.",
            "methods": [
              "accept"
            ],
            "line": 189
          },
          {
            "name": "ActionBlockNode",
            "docstring": "Action block (deny, allow, escalate, route).",
            "methods": [
              "accept"
            ],
            "line": 200
          },
          {
            "name": "RouteTargetNode",
            "docstring": "Route target specification.",
            "methods": [
              "accept"
            ],
            "line": 211
          },
          {
            "name": "BinaryOpNode",
            "docstring": "Binary operation (and, or, ==, !=, etc.).",
            "methods": [
              "accept"
            ],
            "line": 226
          },
          {
            "name": "UnaryOpNode",
            "docstring": "Unary operation (not).",
            "methods": [
              "accept"
            ],
            "line": 238
          },
          {
            "name": "ValueNode",
            "docstring": "Base class for value nodes.",
            "methods": [],
            "line": 249
          },
          {
            "name": "IdentNode",
            "docstring": "Identifier node.",
            "methods": [
              "accept"
            ],
            "line": 256
          },
          {
            "name": "LiteralNode",
            "docstring": "Literal value node (number, string, boolean).",
            "methods": [
              "accept"
            ],
            "line": 266
          },
          {
            "name": "FuncCallNode",
            "docstring": "Function call node.",
            "methods": [
              "accept"
            ],
            "line": 276
          },
          {
            "name": "AttrAccessNode",
            "docstring": "Attribute access node (obj.attr).",
            "methods": [
              "accept"
            ],
            "line": 287
          },
          {
            "name": "ASTVisitor",
            "docstring": "Abstract base class for AST visitors.\n\nConcrete implementations must define all visit_* methods.\nThis enables the visitor pattern for AST traversal.",
            "methods": [
              "visit_program",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_import",
              "visit_rule_ref",
              "visit_priority",
              "visit_condition_block",
              "visit_action_block",
              "visit_route_target",
              "visit_binary_op",
              "visit_unary_op",
              "visit_ident",
              "visit_literal",
              "visit_func_call",
              "visit_attr_access"
            ],
            "line": 298
          }
        ],
        "imports": [
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "phase_status_invariants.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/phase_status_invariants.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 360,
        "module_docstring": "Module: phase_status_invariants\nPurpose: Enforce phase-status invariants using GovernanceConfig.\n\nThe phase_status_invariant_enforce flag in GovernanceConfig controls\nwhether invalid phase-status combinations are blocked.\n\nPhase-Status Invariants:\n    - CREATED, AUTHORIZED: status must be \"queued\"\n    - EXECUTING, GOVERNANCE_CHECK, FINALIZING: status must be \"running\"\n    - COMPLETED: status must be \"succeeded\"\n    - FAILED: status must be \"failed\", \"failed_policy\", \"cancelled\", or \"retry\"\n\nWhen enforcement is enabled, attempting an invalid combination raises\nPhaseStatusInvariantEnforcementError.\n\nExports:\n    - PhaseStatusInvariantEnforcementError: Raised on violation\n    - PhaseStatusInvariantChecker: Main checker class\n    - check_phase_status_invariant: Quick helper function",
        "functions": [
          {
            "name": "check_phase_status_invariant",
            "signature": "(phase: str, status: str, enforcement_enabled: bool = True) -> InvariantCheckResponse",
            "docstring": "Quick helper to check a phase-status invariant.\n\nArgs:\n    phase: Phase name\n    status: Status value\n    enforcement_enabled: Whether enforcement is enabled\n\nReturns:\n    InvariantCheckResponse with validation result",
            "is_async": false,
            "line": 323
          },
          {
            "name": "ensure_phase_status_invariant",
            "signature": "(phase: str, status: str, enforcement_enabled: bool = True) -> None",
            "docstring": "Quick helper to ensure phase-status invariant or raise error.\n\nArgs:\n    phase: Phase name\n    status: Status value\n    enforcement_enabled: Whether enforcement is enabled\n\nRaises:\n    PhaseStatusInvariantEnforcementError: If invalid and enforcement enabled",
            "is_async": false,
            "line": 343
          }
        ],
        "classes": [
          {
            "name": "InvariantCheckResult",
            "docstring": "Result of an invariant check.",
            "methods": [],
            "line": 46
          },
          {
            "name": "PhaseStatusInvariantEnforcementError",
            "docstring": "Raised when phase-status invariant enforcement fails.\n\nThis error indicates that an invalid phase-status combination\nwas attempted when enforcement is enabled.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 67
          },
          {
            "name": "InvariantCheckResponse",
            "docstring": "Response from an invariant check.",
            "methods": [
              "to_dict"
            ],
            "line": 102
          },
          {
            "name": "PhaseStatusInvariantChecker",
            "docstring": "Checks and enforces phase-status invariants.\n\nGAP-051: Add invariant checks to ROK.\n\nThe checker validates that phase-status combinations are valid\nand can raise errors when enforcement is enabled.\n\nUsage:\n    checker = PhaseStatusInvariantChecker(enforcement_enabled=True)\n\n    # Before a phase transition\n    checker.ensure_valid(\"EXECUTING\", \"running\")\n\n    # Or check without raising\n    response = checker.check(\"EXECUTING\", \"running\")\n    if not response.is_valid and response.enforcement_enabled:\n        handle_invariant_violation()",
            "methods": [
              "__init__",
              "from_governance_config",
              "enforcement_enabled",
              "get_allowed_statuses",
              "is_valid_combination",
              "check",
              "ensure_valid",
              "should_allow_transition"
            ],
            "line": 126
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "FrozenSet",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "plan.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/plan.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 145,
        "module_docstring": "Phase-6 Plan Model \u2014 Named Contracts (Not Pricing Logic)\n\nPIN-399 Phase-6: Plans are named contracts, not pricing logic.\n\nEXPLICIT NON-GOALS:\n- No prices\n- No currency\n- No billing cycle assumptions\n- No gateway IDs\n- No subscriptions\n- No coupons / proration / invoices\n- No taxes\n\nThose come in future phases, if ever.\n\nThis module defines the abstract Plan model used for limit derivation.",
        "functions": [],
        "classes": [
          {
            "name": "PlanTier",
            "docstring": "Plan tier hierarchy.\n\nTiers represent capability levels, not prices.",
            "methods": [
              "from_string"
            ],
            "line": 44
          },
          {
            "name": "Plan",
            "docstring": "Phase-6 Plan Model (Immutable).\n\nPlans define what a tenant is entitled to, not what they pay.\n\nAttributes:\n    id: Unique plan identifier (e.g., \"free-v1\", \"pro-v1\")\n    name: Human-readable name (e.g., \"Free\", \"Pro\")\n    tier: Capability tier (FREE, PRO, ENTERPRISE)\n    limits_profile: Key for deriving limits (e.g., \"free\", \"pro\", \"enterprise\")\n    description: Optional human-readable description\n\nINVARIANTS:\n- Plans are immutable after creation\n- Plans do not contain pricing information\n- Plans do not reference gateway IDs\n- Limits are derived from limits_profile, not stored on the plan",
            "methods": [
              "__post_init__"
            ],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [
          {
            "name": "PLAN_FREE",
            "line": 110
          },
          {
            "name": "PLAN_PRO",
            "line": 118
          },
          {
            "name": "PLAN_ENTERPRISE",
            "line": 126
          },
          {
            "name": "DEFAULT_PLAN",
            "line": 135
          }
        ],
        "all_exports": [
          "PlanTier",
          "Plan",
          "PLAN_FREE",
          "PLAN_PRO",
          "PLAN_ENTERPRISE",
          "DEFAULT_PLAN"
        ]
      },
      {
        "file_name": "plan_generation_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/plan_generation_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 257,
        "module_docstring": "Domain engine for plan generation.\n\nThis L4 engine contains the authoritative logic for:\n1. Memory context retrieval\n2. Plan generation via planner\n3. Plan validation\n\nL5 workers must receive plans from this engine (via run.plan_json),\nnot generate their own plans.\n\nReference: PIN-257 Phase R-2\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md",
        "functions": [
          {
            "name": "generate_plan_for_run",
            "signature": "(agent_id: str, goal: str, run_id: str) -> PlanGenerationResult",
            "docstring": "Convenience function to generate a plan for a run.\n\nThis is the L4 entry point for plan generation. It should be called\nby the run creation flow (in L2 API) to generate plans before\nthe run is queued for execution.\n\nArgs:\n    agent_id: Agent ID\n    goal: Run goal\n    run_id: Run ID\n\nReturns:\n    PlanGenerationResult with the generated plan\n\nReference: PIN-257 Phase R-2",
            "is_async": false,
            "line": 211
          }
        ],
        "classes": [
          {
            "name": "PlanGenerationContext",
            "docstring": "Context for plan generation.",
            "methods": [],
            "line": 55
          },
          {
            "name": "PlanGenerationResult",
            "docstring": "Result of plan generation.",
            "methods": [],
            "line": 65
          },
          {
            "name": "PlanGenerationEngine",
            "docstring": "L4 Domain Engine for plan generation.\n\nThis engine contains ALL plan generation logic that was previously\nscattered in L5 runner.py. It generates plans from goals using\nmemory context and the configured planner.\n\nL5 workers must NOT:\n- Import memory.get_retriever()\n- Import planners.get_planner()\n- Generate plans inline\n\nL5 workers must ONLY:\n- Execute plans provided via run.plan_json\n- Fail if no plan is provided\n\nReference: PIN-257 Phase R-2\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md Section 3.2",
            "methods": [
              "__init__",
              "generate"
            ],
            "line": 82
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.memory",
            "names": [
              "get_retriever"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.planners",
            "names": [
              "get_planner"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.skills",
            "names": [
              "get_skill_manifest"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.utils.budget_tracker",
            "names": [
              "get_budget_tracker"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.utils.plan_inspector",
            "names": [
              "validate_plan"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": [
          "PlanGenerationContext",
          "PlanGenerationResult",
          "PlanGenerationEngine",
          "generate_plan_for_run"
        ]
      },
      {
        "file_name": "policies_facade.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policies_facade.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 111,
        "module_docstring": "PoliciesFacade (SWEEP-03 Batch 3)\n\nPURPOSE:\n    HOC wrapper for policies facade - unified policy management.\n    Called by L2 policies API.\n\nINTERFACE:\n    - PoliciesFacade\n    - get_policies_facade() -> PoliciesFacade\n\nIMPLEMENTATION NOTES:\n    Re-exports from existing app.services.policies_facade which is\n    already properly structured as an L4/L5 facade.",
        "functions": [],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.services.policies_facade",
            "names": [
              "PoliciesFacade",
              "get_policies_facade",
              "PolicyRuleSummaryResult",
              "PolicyRulesListResult",
              "PolicyRuleDetailResult",
              "LimitSummaryResult",
              "LimitsListResult",
              "LimitDetailResult",
              "PolicyStateResult",
              "PolicyMetricsResult",
              "PolicyConflictResult",
              "ConflictsListResult",
              "PolicyDependencyRelation",
              "PolicyNodeResult",
              "PolicyDependencyEdge",
              "DependencyGraphResult",
              "PolicyViolationResult",
              "ViolationsListResult",
              "BudgetDefinitionResult",
              "BudgetsListResult",
              "PolicyRequestResult",
              "PolicyRequestsListResult",
              "LessonSummaryResult",
              "LessonsListResult",
              "LessonDetailResult",
              "LessonStatsResult"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": [
          "PoliciesFacade",
          "get_policies_facade",
          "PolicyRuleSummaryResult",
          "PolicyRulesListResult",
          "PolicyRuleDetailResult",
          "LimitSummaryResult",
          "LimitsListResult",
          "LimitDetailResult",
          "PolicyStateResult",
          "PolicyMetricsResult",
          "PolicyConflictResult",
          "ConflictsListResult",
          "PolicyDependencyRelation",
          "PolicyNodeResult",
          "PolicyDependencyEdge",
          "DependencyGraphResult",
          "PolicyViolationResult",
          "ViolationsListResult",
          "BudgetDefinitionResult",
          "BudgetsListResult",
          "PolicyRequestResult",
          "PolicyRequestsListResult",
          "LessonSummaryResult",
          "LessonsListResult",
          "LessonDetailResult",
          "LessonStatsResult"
        ]
      },
      {
        "file_name": "policies_limits_query_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policies_limits_query_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 318,
        "module_docstring": "Limits Query Engine (L5)\n\nRead-only query operations for limits and budget definitions.\nProvides list, get detail, filtering, and budget queries.\n\nInvariant: This engine is READ-ONLY. No writes. No state mutation.",
        "functions": [
          {
            "name": "get_limits_query_engine",
            "signature": "(session: 'AsyncSession') -> LimitsQueryEngine",
            "docstring": "Get a LimitsQueryEngine instance.",
            "is_async": false,
            "line": 301
          }
        ],
        "classes": [
          {
            "name": "LimitSummaryResult",
            "docstring": "Limit summary for list view (O2).",
            "methods": [],
            "line": 46
          },
          {
            "name": "LimitsListResult",
            "docstring": "Limits list response.",
            "methods": [],
            "line": 67
          },
          {
            "name": "LimitDetailResult",
            "docstring": "Limit detail response (O3).",
            "methods": [],
            "line": 77
          },
          {
            "name": "BudgetDefinitionResult",
            "docstring": "Budget definition summary (THR-O2).",
            "methods": [],
            "line": 102
          },
          {
            "name": "BudgetsListResult",
            "docstring": "Budget definitions list response.",
            "methods": [],
            "line": 117
          },
          {
            "name": "LimitsQueryEngine",
            "docstring": "L5 Query Engine for limits.\n\nProvides read-only operations:\n- List limits with filters\n- Get limit detail\n- List budget definitions\n\nAll data access is delegated to L6 driver.",
            "methods": [
              "__init__",
              "list_limits",
              "get_limit_detail",
              "list_budgets"
            ],
            "line": 130
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.hoc.cus.controls.L6_drivers.limits_read_driver",
            "names": [
              "LimitsReadDriver",
              "get_limits_read_driver"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "LimitsQueryEngine",
          "get_limits_query_engine",
          "LimitSummaryResult",
          "LimitsListResult",
          "LimitDetailResult",
          "BudgetDefinitionResult",
          "BudgetsListResult"
        ]
      },
      {
        "file_name": "policies_proposals_query_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policies_proposals_query_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 224,
        "module_docstring": "Proposals Query Engine (L5)\n\nRead-only query operations for policy proposals (list view).\nProvides list, get detail, and draft counts.\n\nNote: This engine is for the \"Proposals\" tab UI.\nFor proposal lifecycle operations (create, approve, reject),\nsee policy_proposal_engine.py.\n\nInvariant: This engine is READ-ONLY. No writes. No state mutation.",
        "functions": [
          {
            "name": "get_proposals_query_engine",
            "signature": "(session: 'AsyncSession') -> ProposalsQueryEngine",
            "docstring": "Get a ProposalsQueryEngine instance.",
            "is_async": false,
            "line": 209
          }
        ],
        "classes": [
          {
            "name": "PolicyRequestResult",
            "docstring": "Pending policy request summary (ACT-O3).",
            "methods": [],
            "line": 49
          },
          {
            "name": "PolicyRequestsListResult",
            "docstring": "Policy requests list response.",
            "methods": [],
            "line": 64
          },
          {
            "name": "PolicyRequestDetailResult",
            "docstring": "Policy request detail response.",
            "methods": [],
            "line": 74
          },
          {
            "name": "ProposalsQueryEngine",
            "docstring": "L5 Query Engine for policy proposals.\n\nProvides read-only operations:\n- List proposals with filters\n- Get proposal detail\n- Count draft proposals\n\nAll data access is delegated to L6 driver.",
            "methods": [
              "__init__",
              "list_policy_requests",
              "get_policy_request_detail",
              "count_drafts"
            ],
            "line": 98
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.proposals_read_driver",
            "names": [
              "ProposalsReadDriver",
              "get_proposals_read_driver"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": [
          "ProposalsQueryEngine",
          "get_proposals_query_engine",
          "PolicyRequestResult",
          "PolicyRequestsListResult",
          "PolicyRequestDetailResult"
        ]
      },
      {
        "file_name": "policies_rules_query_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policies_rules_query_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 246,
        "module_docstring": "Policy Rules Query Engine (L5)\n\nRead-only query operations for policy rules.\nProvides list, get detail, filtering, and counts.\n\nInvariant: This engine is READ-ONLY. No writes. No state mutation.",
        "functions": [
          {
            "name": "get_policy_rules_query_engine",
            "signature": "(session: 'AsyncSession') -> PolicyRulesQueryEngine",
            "docstring": "Get a PolicyRulesQueryEngine instance.",
            "is_async": false,
            "line": 229
          }
        ],
        "classes": [
          {
            "name": "PolicyRuleSummaryResult",
            "docstring": "Policy rule summary for list view (O2).",
            "methods": [],
            "line": 46
          },
          {
            "name": "PolicyRulesListResult",
            "docstring": "Policy rules list response.",
            "methods": [],
            "line": 64
          },
          {
            "name": "PolicyRuleDetailResult",
            "docstring": "Policy rule detail response (O3).",
            "methods": [],
            "line": 74
          },
          {
            "name": "PolicyRulesQueryEngine",
            "docstring": "L5 Query Engine for policy rules.\n\nProvides read-only operations:\n- List rules with filters\n- Get rule detail\n- Count rules\n\nAll data access is delegated to L6 driver.",
            "methods": [
              "__init__",
              "list_policy_rules",
              "get_policy_rule_detail",
              "count_rules"
            ],
            "line": 100
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_rules_read_driver",
            "names": [
              "PolicyRulesReadDriver",
              "get_policy_rules_read_driver"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyRulesQueryEngine",
          "get_policy_rules_query_engine",
          "PolicyRuleSummaryResult",
          "PolicyRulesListResult",
          "PolicyRuleDetailResult"
        ]
      },
      {
        "file_name": "policy_command.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_command.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 478,
        "module_docstring": "Policy Command (L4)\n\nDomain command for policy evaluation and approval workflow. This L4 command:\n1. Owns all policy decisions (cost feasibility, violations, outcomes)\n2. Delegates to L5 for execution (metrics, simulation, enforcement)\n3. Returns result objects to L3 adapter\n\nThis command may import L5 (workflow.metrics, workflow.cost_sim, workflow.policies)\nbecause L4 \u2192 L5 is allowed per layer rules.\n\nReference: PIN-258 Phase F-3 Policy Cluster",
        "functions": [
          {
            "name": "simulate_cost",
            "signature": "(skill_id: str, tenant_id: str, payload: Dict[str, Any]) -> Optional[int]",
            "docstring": "Simulate cost for a skill execution.\n\nThis L4 command delegates to L5 CostSimulator.\nL4 \u2192 L5 is allowed per layer rules.\n\nArgs:\n    skill_id: Skill to simulate\n    tenant_id: Tenant context\n    payload: Execution payload\n\nReturns:\n    Estimated cost in cents, or fallback estimate\n\nReference: PIN-258 Phase F-3 (F-P-RULE-4: No Dual Ownership)",
            "is_async": true,
            "line": 88
          },
          {
            "name": "check_policy_violations",
            "signature": "(skill_id: str, tenant_id: str, agent_id: Optional[str], payload: Dict[str, Any], simulated_cost: Optional[int]) -> List[PolicyViolation]",
            "docstring": "Check for policy violations.\n\nThis L4 command delegates to L5 PolicyEnforcer.\nL4 \u2192 L5 is allowed per layer rules.\n\nArgs:\n    skill_id: Skill being evaluated\n    tenant_id: Tenant context\n    agent_id: Optional agent context\n    payload: Execution payload\n    simulated_cost: Cost estimate from simulation\n\nReturns:\n    List of policy violations found\n\nReference: PIN-258 Phase F-3 (F-P-RULE-1: Policy Decisions in L4)",
            "is_async": true,
            "line": 129
          },
          {
            "name": "evaluate_policy",
            "signature": "(skill_id: str, tenant_id: str, agent_id: Optional[str], payload: Dict[str, Any], auto_approve_max_cost_cents: int = 0, approval_level: int = 1) -> PolicyEvaluationResult",
            "docstring": "Evaluate policy for a skill execution.\n\nThis L4 command orchestrates:\n1. Cost simulation (via L5)\n2. Policy violation check (via L5)\n3. Decision determination\n4. Metrics emission (via L5)\n\nL4 \u2192 L5 is allowed per layer rules.\n\nArgs:\n    skill_id: Skill to evaluate\n    tenant_id: Tenant context\n    agent_id: Optional agent context\n    payload: Execution payload\n    auto_approve_max_cost_cents: Threshold for auto-approval\n    approval_level: Required approval level\n\nReturns:\n    PolicyEvaluationResult with decision and details\n\nReference: PIN-258 Phase F-3 (F-P-RULE-1: Policy Decisions in L4)",
            "is_async": true,
            "line": 228
          },
          {
            "name": "_record_policy_decision",
            "signature": "(decision: str, policy_type: str) -> None",
            "docstring": "Record policy decision metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 315
          },
          {
            "name": "_record_capability_violation",
            "signature": "(violation_type: str, skill_id: str, tenant_id: Optional[str] = None) -> None",
            "docstring": "Record capability violation metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 329
          },
          {
            "name": "_record_budget_rejection",
            "signature": "(resource_type: str, skill_id: str) -> None",
            "docstring": "Record budget rejection metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 343
          },
          {
            "name": "_record_approval_request_created",
            "signature": "(policy_type: str) -> None",
            "docstring": "Record approval request creation metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 357
          },
          {
            "name": "_record_approval_action",
            "signature": "(result: str) -> None",
            "docstring": "Record approval action metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 371
          },
          {
            "name": "_record_approval_escalation",
            "signature": "() -> None",
            "docstring": "Record approval escalation metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 385
          },
          {
            "name": "_record_webhook_fallback",
            "signature": "() -> None",
            "docstring": "Record webhook fallback metric.\n\nL4 \u2192 L5 is allowed. This is an effect, not a decision.",
            "is_async": false,
            "line": 399
          },
          {
            "name": "record_approval_created",
            "signature": "(policy_type: str) -> None",
            "docstring": "Record that an approval request was created.\n\nThis is a public L4 command for L3 to call.\nDelegates metric emission to L5.",
            "is_async": false,
            "line": 418
          },
          {
            "name": "record_approval_outcome",
            "signature": "(result: str) -> None",
            "docstring": "Record approval outcome (approved/rejected/expired).\n\nThis is a public L4 command for L3 to call.\nDelegates metric emission to L5.",
            "is_async": false,
            "line": 428
          },
          {
            "name": "record_escalation",
            "signature": "() -> None",
            "docstring": "Record that an escalation occurred.\n\nThis is a public L4 command for L3 to call.\nDelegates metric emission to L5.",
            "is_async": false,
            "line": 438
          },
          {
            "name": "record_webhook_used",
            "signature": "() -> None",
            "docstring": "Record that webhook fallback was used.\n\nThis is a public L4 command for L3 to call.\nDelegates metric emission to L5.",
            "is_async": false,
            "line": 448
          }
        ],
        "classes": [
          {
            "name": "PolicyViolation",
            "docstring": "A policy violation detected during evaluation.",
            "methods": [],
            "line": 50
          },
          {
            "name": "PolicyEvaluationResult",
            "docstring": "Result from policy evaluation command.",
            "methods": [],
            "line": 60
          },
          {
            "name": "ApprovalConfig",
            "docstring": "Approval level configuration.",
            "methods": [],
            "line": 72
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyViolation",
          "PolicyEvaluationResult",
          "ApprovalConfig",
          "simulate_cost",
          "check_policy_violations",
          "evaluate_policy",
          "record_approval_created",
          "record_approval_outcome",
          "record_escalation",
          "record_webhook_used"
        ]
      },
      {
        "file_name": "policy_conflict_resolver.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_conflict_resolver.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 267,
        "module_docstring": "Module: conflict_resolver\nPurpose: Defines explicit rules for resolving policy conflicts.\n\nImplements INV-005: Policy Conflict Determinism (CONFLICT-DET-001)\n> When multiple policies apply to the same action, the most restrictive action wins.\n> If two policies have equal restrictiveness, the policy with the lowest policy_id wins\n> (deterministic tiebreaker).\n\nImports (Dependencies):\n    - None (standalone)\n\nExports (Provides):\n    - resolve_policy_conflict(actions: List[PolicyAction]) -> ResolvedAction\n    - ConflictResolutionStrategy: Enum\n    - PolicyConflictLog: Audit record of conflict resolution\n\nWiring Points:\n    - Called from: prevention_engine.py:evaluate_policies()\n    - Emits: PolicyConflictLog to audit ledger\n\nConflict Resolution Rules (INV-005):\n    1. Higher precedence wins (lower number = higher priority)\n    2. Within same precedence, more restrictive action wins\n    3. Action restrictiveness order: KILL > STOP > PAUSE > WARN > CONTINUE\n    4. If precedence and action are equal, lowest policy_id wins (deterministic tiebreaker)\n\nAcceptance Criteria:\n    - [x] AC-068-01: Single policy returns without conflict\n    - [x] AC-068-02: Multiple policies same action no conflict\n    - [x] AC-068-03: Precedence resolves conflict\n    - [x] AC-068-04: Severity resolves same-precedence\n    - [x] AC-068-05: Conflict logged to audit\n    - [x] AC-068-06: Wired to prevention_engine\n    - [x] AC-068-07: Deterministic tiebreaker (INV-005)",
        "functions": [
          {
            "name": "resolve_policy_conflict",
            "signature": "(actions: List[PolicyAction], strategy: ConflictResolutionStrategy = ConflictResolutionStrategy.PRECEDENCE_FIRST) -> ResolvedAction",
            "docstring": "Resolve conflict when multiple policies trigger.\n\nImplements INV-005: Policy Conflict Determinism\n\nResolution Algorithm:\n1. Sort by precedence (lower number = higher priority)\n2. Within same precedence, sort by action severity (higher = more restrictive)\n3. Within same precedence and severity, sort by policy_id (deterministic tiebreaker)\n4. Return the winning action\n\nArgs:\n    actions: List of triggered policy actions\n    strategy: Resolution strategy to use\n\nReturns:\n    ResolvedAction with winning policy and audit trail",
            "is_async": false,
            "line": 133
          },
          {
            "name": "create_conflict_log",
            "signature": "(run_id: str, resolved: ResolvedAction, strategy: ConflictResolutionStrategy) -> PolicyConflictLog",
            "docstring": "Create audit log entry for conflict resolution.\n\nArgs:\n    run_id: ID of the run being evaluated\n    resolved: Resolution result\n    strategy: Strategy used\n\nReturns:\n    PolicyConflictLog for audit trail",
            "is_async": false,
            "line": 217
          },
          {
            "name": "get_action_severity",
            "signature": "(action: str) -> int",
            "docstring": "Get the severity level for an action.\n\nArgs:\n    action: Action string (CONTINUE, WARN, PAUSE, STOP, KILL)\n\nReturns:\n    Severity level (0-4)",
            "is_async": false,
            "line": 243
          },
          {
            "name": "is_more_restrictive",
            "signature": "(action_a: str, action_b: str) -> bool",
            "docstring": "Check if action_a is more restrictive than action_b.\n\nArgs:\n    action_a: First action\n    action_b: Second action\n\nReturns:\n    True if action_a is more restrictive",
            "is_async": false,
            "line": 256
          }
        ],
        "classes": [
          {
            "name": "ActionSeverity",
            "docstring": "Action severity for conflict resolution. Higher = more restrictive.\n\nINV-005 Restrictiveness Order: KILL > STOP > PAUSE > WARN > CONTINUE",
            "methods": [],
            "line": 66
          },
          {
            "name": "ConflictResolutionStrategy",
            "docstring": "Resolution strategy for policy conflicts.",
            "methods": [],
            "line": 82
          },
          {
            "name": "PolicyAction",
            "docstring": "A triggered policy action.",
            "methods": [],
            "line": 90
          },
          {
            "name": "ResolvedAction",
            "docstring": "Result of conflict resolution.",
            "methods": [],
            "line": 100
          },
          {
            "name": "PolicyConflictLog",
            "docstring": "Audit log entry for conflict resolution.",
            "methods": [],
            "line": 110
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum",
              "IntEnum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [
          {
            "name": "ACTION_SEVERITY",
            "line": 121
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "policy_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_driver.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 415,
        "module_docstring": "Policy Domain Driver (INTERNAL)\n\nThis driver provides the internal interface for policy evaluation operations.\nUsed by policy_layer API, governance services, and worker runtime.\n\nFor CUSTOMER policy CRUD operations, use policies_facade.py instead.\n\nWhy Drivers (not Facades for internal use):\n- Facades are API projection layers (CUSTOMER-facing)\n- Drivers are orchestration layers (INTERNAL)\n- Clear separation prevents confusion\n- Import rules become enforceable\n\nUsage:\n    from app.hoc.cus.policies.L5_engines.policy_driver import get_policy_driver\n\n    driver = get_policy_driver()\n    result = await driver.evaluate(eval_request, db)",
        "functions": [
          {
            "name": "get_policy_driver",
            "signature": "(db_url: Optional[str] = None) -> PolicyDriver",
            "docstring": "Get the PolicyDriver singleton.\n\nThis is the recommended way to access policy evaluation from\ninternal code (policy_layer, governance services).\n\nFor CUSTOMER API CRUD operations, use get_policies_facade() instead.\n\nArgs:\n    db_url: Optional database URL override\n\nReturns:\n    PolicyDriver singleton instance",
            "is_async": false,
            "line": 384
          },
          {
            "name": "reset_policy_driver",
            "signature": "() -> None",
            "docstring": "Reset the driver singleton (for testing).",
            "is_async": false,
            "line": 405
          }
        ],
        "classes": [
          {
            "name": "PolicyDriver",
            "docstring": "Driver for Policy domain operations (INTERNAL).\n\nThis is the entry point for internal code (policy_layer, governance)\nto interact with policy evaluation services.\n\nCUSTOMER-facing CRUD code should use policies_facade.py instead.",
            "methods": [
              "__init__",
              "_engine",
              "evaluate",
              "pre_check",
              "get_state",
              "reload_policies",
              "get_violations",
              "get_violation",
              "acknowledge_violation",
              "get_risk_ceilings",
              "get_risk_ceiling",
              "update_risk_ceiling",
              "reset_risk_ceiling",
              "get_safety_rules",
              "update_safety_rule",
              "get_ethical_constraints",
              "get_active_cooldowns",
              "clear_cooldowns",
              "get_metrics",
              "get_policy_versions",
              "get_current_version",
              "create_policy_version",
              "rollback_to_version",
              "get_version_provenance",
              "activate_policy_version",
              "get_dependency_graph",
              "get_policy_conflicts",
              "resolve_conflict",
              "validate_dependency_dag",
              "add_dependency_with_dag_check",
              "get_topological_evaluation_order",
              "get_temporal_policies",
              "create_temporal_policy",
              "get_temporal_utilization",
              "prune_temporal_metrics",
              "get_temporal_storage_stats",
              "evaluate_with_context"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_graph_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_graph_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 797,
        "module_docstring": "Policy Graph Engine \u2014 Conflict Detection & Dependency Analysis\n\nThis module implements:\n- PolicyConflictEngine: Detects logical contradictions between policies (DFT-O4)\n- PolicyDependencyEngine: Computes structural relationships between policies (DFT-O5)\n\nThese engines answer STATIC governance questions, not runtime enforcement.\nThey must be deterministic, explainable, and replayable.\n\nReference: PIN-411 Gap Closure Spec (Part A)",
        "functions": [
          {
            "name": "get_conflict_engine",
            "signature": "(tenant_id: str) -> PolicyConflictEngine",
            "docstring": "Get a PolicyConflictEngine instance for a tenant.",
            "is_async": false,
            "line": 790
          },
          {
            "name": "get_dependency_engine",
            "signature": "(tenant_id: str) -> PolicyDependencyEngine",
            "docstring": "Get a PolicyDependencyEngine instance for a tenant.",
            "is_async": false,
            "line": 795
          }
        ],
        "classes": [
          {
            "name": "ConflictType",
            "docstring": "Conflict taxonomy (LOCKED).",
            "methods": [],
            "line": 53
          },
          {
            "name": "ConflictSeverity",
            "docstring": "Conflict severity levels.",
            "methods": [],
            "line": 62
          },
          {
            "name": "DependencyType",
            "docstring": "Dependency types (LOCKED).",
            "methods": [],
            "line": 69
          },
          {
            "name": "PolicyConflict",
            "docstring": "A detected conflict between two policies.",
            "methods": [
              "to_dict"
            ],
            "line": 83
          },
          {
            "name": "PolicyDependency",
            "docstring": "A dependency relationship between policies.",
            "methods": [
              "to_dict"
            ],
            "line": 111
          },
          {
            "name": "PolicyNode",
            "docstring": "A node in the dependency graph.",
            "methods": [
              "to_dict"
            ],
            "line": 135
          },
          {
            "name": "DependencyGraphResult",
            "docstring": "Result of dependency graph computation.",
            "methods": [
              "to_dict"
            ],
            "line": 161
          },
          {
            "name": "ConflictDetectionResult",
            "docstring": "Result of conflict detection.",
            "methods": [
              "to_dict"
            ],
            "line": 177
          },
          {
            "name": "PolicyConflictEngine",
            "docstring": "Detects logical contradictions, overlaps, or unsafe coexistence between policies.\n\nThis engine prevents:\n- Mutually exclusive policies being active together\n- Silent overrides\n- Temporal deadlocks\n\nConflicts are TYPED, not inferred.",
            "methods": [
              "__init__",
              "detect_conflicts",
              "_detect_scope_overlaps",
              "_detect_threshold_contradictions",
              "_detect_temporal_conflicts",
              "_detect_priority_overrides",
              "_has_contradicting_conditions",
              "_time_windows_overlap",
              "_involves_policy"
            ],
            "line": 198
          },
          {
            "name": "PolicyDependencyEngine",
            "docstring": "Computes structural relationships between policies.\n\nExposes dependencies so that:\n- Deletions don't break enforcement\n- Activations are ordered\n- Impact analysis is possible\n\nThe graph is a computed view (DAG), not persisted edges.",
            "methods": [
              "__init__",
              "compute_dependency_graph",
              "_detect_explicit_dependencies",
              "_detect_implicit_scope_dependencies",
              "_detect_implicit_limit_dependencies",
              "check_can_delete",
              "check_can_activate"
            ],
            "line": 494
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_graph_driver",
            "names": [
              "PolicyGraphDriver",
              "get_policy_graph_driver"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_limits_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_limits_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 371,
        "module_docstring": "Policy Limits Service (PIN-LIM-01)\n\nAuthoritative writer for policy limits table.\n\nResponsibilities:\n- Create/update/delete limits\n- Validate scope (tenant / worker / global)\n- Enforce immutables (category, type cannot change after creation)\n- Emit audit events\n\nAll DB operations delegated to PolicyLimitsDriver.",
        "functions": [],
        "classes": [
          {
            "name": "PolicyLimitsServiceError",
            "docstring": "Base exception for policy limits service.",
            "methods": [],
            "line": 80
          },
          {
            "name": "LimitNotFoundError",
            "docstring": "Raised when limit is not found.",
            "methods": [],
            "line": 85
          },
          {
            "name": "LimitValidationError",
            "docstring": "Raised when limit validation fails.",
            "methods": [],
            "line": 90
          },
          {
            "name": "ImmutableFieldError",
            "docstring": "Raised when attempting to modify immutable fields.",
            "methods": [],
            "line": 95
          },
          {
            "name": "PolicyLimitsService",
            "docstring": "Service for policy limit CRUD operations.\n\nINVARIANTS:\n- Limits are tenant-scoped\n- limit_category and limit_type are immutable after creation\n- Every active limit MUST have an integrity record\n- Deletions are soft (status = DISABLED)",
            "methods": [
              "__init__",
              "create",
              "update",
              "delete",
              "get",
              "_get_limit",
              "_validate_category_fields",
              "_to_response"
            ],
            "line": 100
          }
        ],
        "imports": [
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.hoc.cus.general.L6_drivers.cross_domain",
            "names": [
              "generate_uuid"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.hoc.cus.controls.L6_drivers.policy_limits_driver",
            "names": [
              "PolicyLimitsDriver",
              "get_policy_limits_driver"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitIntegrity",
              "LimitStatus"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "ActorType"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.policy_limits",
            "names": [
              "CreatePolicyLimitRequest",
              "UpdatePolicyLimitRequest",
              "PolicyLimitResponse"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "app.hoc.cus.logs.L6_drivers.audit_ledger_service_async",
            "names": [
              "AuditLedgerServiceAsync"
            ],
            "is_relative": false,
            "line": 77
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_mapper.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_mapper.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 490,
        "module_docstring": "Module: policy_mapper\nPurpose: Map MCP tool invocations to policy gates.\n\nWires:\n    - Source: app/services/mcp/server_registry.py (tools)\n    - Source: app/services/policies/policy_engine.py (policy evaluation)\n    - Target: Tool invocations are gated by policy\n\nThis module:\n    1. Maps MCP tool invocations to policy checks\n    2. Determines required permissions for each tool\n    3. Evaluates policy before allowing invocation\n    4. Provides deny-by-default for unknown tools\n\nAcceptance Criteria:\n    - AC-142-01: Tools are mapped to policies\n    - AC-142-02: Deny-by-default for unmapped tools\n    - AC-142-03: Dangerous tools require explicit allow\n    - AC-142-04: Policy decisions are logged\n    - AC-142-05: Tenant policies are respected",
        "functions": [
          {
            "name": "get_mcp_policy_mapper",
            "signature": "() -> MCPPolicyMapper",
            "docstring": "Get or create the singleton MCPPolicyMapper.\n\nReturns:\n    MCPPolicyMapper instance",
            "is_async": false,
            "line": 447
          },
          {
            "name": "configure_mcp_policy_mapper",
            "signature": "(policy_engine: Optional[Any] = None) -> MCPPolicyMapper",
            "docstring": "Configure the singleton MCPPolicyMapper.\n\nArgs:\n    policy_engine: Policy engine to use\n\nReturns:\n    Configured MCPPolicyMapper",
            "is_async": false,
            "line": 463
          },
          {
            "name": "reset_mcp_policy_mapper",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 487
          }
        ],
        "classes": [
          {
            "name": "MCPPolicyDecisionType",
            "docstring": "Types of policy decisions for MCP tools.",
            "methods": [],
            "line": 54
          },
          {
            "name": "MCPDenyReason",
            "docstring": "Reasons for denying MCP tool invocation.",
            "methods": [],
            "line": 62
          },
          {
            "name": "MCPPolicyDecision",
            "docstring": "Policy decision for MCP tool invocation.\n\nContains the decision and context for audit.",
            "methods": [
              "to_dict",
              "allow",
              "deny"
            ],
            "line": 75
          },
          {
            "name": "MCPToolPolicy",
            "docstring": "Policy configuration for an MCP tool.\n\nDefines what permissions are required to invoke the tool.",
            "methods": [],
            "line": 138
          },
          {
            "name": "MCPPolicyMapper",
            "docstring": "Maps MCP tool invocations to policy gates.\n\nThis service:\n1. Maintains tool\u2192policy mappings\n2. Evaluates policies before tool invocation\n3. Enforces deny-by-default\n4. Handles dangerous tool restrictions",
            "methods": [
              "__init__",
              "check_tool_invocation",
              "register_tool_policy",
              "_evaluate_policy",
              "_check_explicit_allow",
              "_check_rate_limit",
              "_get_policy_engine"
            ],
            "line": 155
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_models.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_models.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 739,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "PolicyCategory",
            "docstring": "Categories of policies in the M19 Policy Layer.",
            "methods": [],
            "line": 37
          },
          {
            "name": "PolicyDecision",
            "docstring": "Possible decisions from policy evaluation.",
            "methods": [],
            "line": 47
          },
          {
            "name": "ActionType",
            "docstring": "Types of actions that require policy evaluation.",
            "methods": [],
            "line": 55
          },
          {
            "name": "ViolationType",
            "docstring": "Types of policy violations.",
            "methods": [],
            "line": 69
          },
          {
            "name": "ViolationSeverity",
            "docstring": "Enhanced violation severity classifications (GAP 5).",
            "methods": [],
            "line": 81
          },
          {
            "name": "RecoverabilityType",
            "docstring": "Whether a violation is recoverable.",
            "methods": [],
            "line": 102
          },
          {
            "name": "SafetyRuleType",
            "docstring": "Types of safety rules.",
            "methods": [],
            "line": 111
          },
          {
            "name": "EthicalConstraintType",
            "docstring": "Types of ethical constraints.",
            "methods": [],
            "line": 121
          },
          {
            "name": "BusinessRuleType",
            "docstring": "Types of business rules.",
            "methods": [],
            "line": 130
          },
          {
            "name": "PolicyEvaluationRequest",
            "docstring": "Request for policy evaluation.",
            "methods": [],
            "line": 145
          },
          {
            "name": "PolicyModification",
            "docstring": "Modification applied to an action by policy engine.",
            "methods": [],
            "line": 171
          },
          {
            "name": "PolicyEvaluationResult",
            "docstring": "Result of policy evaluation.",
            "methods": [],
            "line": 180
          },
          {
            "name": "PolicyViolation",
            "docstring": "A policy violation record.",
            "methods": [],
            "line": 203
          },
          {
            "name": "PolicyRule",
            "docstring": "A single rule within a policy.",
            "methods": [],
            "line": 231
          },
          {
            "name": "Policy",
            "docstring": "A policy definition.",
            "methods": [],
            "line": 241
          },
          {
            "name": "RiskCeiling",
            "docstring": "A risk ceiling definition.",
            "methods": [],
            "line": 268
          },
          {
            "name": "SafetyRule",
            "docstring": "A safety rule definition.",
            "methods": [],
            "line": 293
          },
          {
            "name": "EthicalConstraint",
            "docstring": "An ethical constraint definition.",
            "methods": [],
            "line": 318
          },
          {
            "name": "BusinessRule",
            "docstring": "A business rule definition.",
            "methods": [],
            "line": 340
          },
          {
            "name": "PolicyState",
            "docstring": "Current state of the policy layer.",
            "methods": [],
            "line": 365
          },
          {
            "name": "PolicyLoadResult",
            "docstring": "Result of loading policies from database.",
            "methods": [],
            "line": 388
          },
          {
            "name": "PolicyVersion",
            "docstring": "A versioned snapshot of a policy set (GAP 1).",
            "methods": [],
            "line": 406
          },
          {
            "name": "PolicyProvenance",
            "docstring": "Audit trail for policy changes (GAP 1).",
            "methods": [],
            "line": 434
          },
          {
            "name": "PolicyDependency",
            "docstring": "Dependency relationship between policies (GAP 2).",
            "methods": [],
            "line": 460
          },
          {
            "name": "PolicyConflict",
            "docstring": "A detected conflict between policies (GAP 2).",
            "methods": [],
            "line": 476
          },
          {
            "name": "DependencyGraph",
            "docstring": "The complete policy dependency graph (GAP 2).",
            "methods": [],
            "line": 498
          },
          {
            "name": "TemporalPolicyType",
            "docstring": "Types of temporal policies.",
            "methods": [],
            "line": 512
          },
          {
            "name": "TemporalPolicy",
            "docstring": "A temporal/sliding window policy (GAP 3).",
            "methods": [],
            "line": 522
          },
          {
            "name": "TemporalMetricWindow",
            "docstring": "A sliding window of metric values (GAP 3).",
            "methods": [],
            "line": 551
          },
          {
            "name": "PolicyContext",
            "docstring": "Complete policy context passed through the decision cycle (GAP 4).\n\nThis object provides the full state needed for policy evaluation,\nenabling multi-agent coordination and trajectory-based decisions.",
            "methods": [],
            "line": 574
          },
          {
            "name": "EnhancedPolicyEvaluationRequest",
            "docstring": "Enhanced evaluation request with full context (GAP 4).",
            "methods": [],
            "line": 634
          },
          {
            "name": "EnhancedPolicyViolation",
            "docstring": "Enhanced violation with severity classification (GAP 5).",
            "methods": [],
            "line": 659
          },
          {
            "name": "EnhancedPolicyEvaluationResult",
            "docstring": "Enhanced evaluation result with full context (GAPs 1-5).",
            "methods": [],
            "line": 696
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 30
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_proposal_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_proposal_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 713,
        "module_docstring": "Policy Proposal Engine (L5)\n\nProposes policy changes based on observed feedback WITHOUT auto-enforcement.\n\nPB-S4 Contract:\n- Observe feedback patterns \u2192 propose policy \u2192 wait for human\n- NO auto-enforcement\n- NO execution modification\n- Human approval is MANDATORY\n\nRule: Propose \u2192 Review \u2192 Decide (Human)\n\nState Machine:\n    DRAFT \u2192 PENDING \u2192 APPROVED/REJECTED\n                \u2193\n            ACTIVE (on activation)",
        "functions": [
          {
            "name": "generate_default_rule",
            "signature": "(policy_type: str, feedback_type: str) -> dict",
            "docstring": "Generate a default rule template based on policy type.\n\nPB-S4: These are SUGGESTIONS only. Human must review.",
            "is_async": false,
            "line": 585
          },
          {
            "name": "get_policy_proposal_engine",
            "signature": "(session: 'AsyncSession') -> PolicyProposalEngine",
            "docstring": "Get a PolicyProposalEngine instance with drivers.",
            "is_async": false,
            "line": 620
          },
          {
            "name": "check_proposal_eligibility",
            "signature": "(session: 'AsyncSession', tenant_id: Optional[UUID] = None, feedback_type: Optional[str] = None, threshold: int = FEEDBACK_THRESHOLD_FOR_PROPOSAL) -> list[dict]",
            "docstring": "Backward-compatible wrapper for eligibility checking.",
            "is_async": true,
            "line": 635
          },
          {
            "name": "create_policy_proposal",
            "signature": "(session: 'AsyncSession', proposal: PolicyProposalCreate) -> str",
            "docstring": "Backward-compatible wrapper for proposal creation.",
            "is_async": true,
            "line": 650
          },
          {
            "name": "review_policy_proposal",
            "signature": "(session: 'AsyncSession', proposal_id: UUID, review: PolicyApprovalRequest) -> dict",
            "docstring": "Backward-compatible wrapper for proposal review.",
            "is_async": true,
            "line": 659
          },
          {
            "name": "delete_policy_rule",
            "signature": "(session: 'AsyncSession', rule_id: str, tenant_id: str, deleted_by: str) -> bool",
            "docstring": "Backward-compatible wrapper for rule deletion.",
            "is_async": true,
            "line": 669
          },
          {
            "name": "get_proposal_summary",
            "signature": "(session: 'AsyncSession', tenant_id: Optional[UUID] = None, status: Optional[str] = None, limit: int = 50) -> dict",
            "docstring": "Backward-compatible wrapper for proposal summary.",
            "is_async": true,
            "line": 680
          }
        ],
        "classes": [
          {
            "name": "PolicyActivationBlockedError",
            "docstring": "GOV-POL-001: Raised when policy activation is blocked due to BLOCKING conflicts.\n\nThis exception is CONSTITUTIONAL - it cannot be caught and ignored.\nThe caller must surface the conflict to the human reviewer.",
            "methods": [
              "__init__"
            ],
            "line": 69
          },
          {
            "name": "PolicyDeletionBlockedError",
            "docstring": "GOV-POL-002: Raised when policy deletion is blocked due to dependents.\n\nThis exception is CONSTITUTIONAL - it cannot be caught and ignored.\nThe caller must resolve dependencies before deletion.",
            "methods": [
              "__init__"
            ],
            "line": 82
          },
          {
            "name": "PolicyProposalEngine",
            "docstring": "L5 Domain Engine for policy proposal lifecycle management.\n\nResponsibilities:\n- Eligibility checking (business logic)\n- Proposal creation orchestration\n- State machine transitions (DRAFT \u2192 APPROVED/REJECTED)\n- Conflict detection coordination\n- Approval workflow\n\nDoes NOT own:\n- Direct DB queries (delegated to L6 drivers)\n- HTTP concerns (that's L2/L3)",
            "methods": [
              "__init__",
              "check_proposal_eligibility",
              "create_proposal",
              "review_proposal",
              "_create_policy_rule_from_proposal",
              "delete_policy_rule",
              "get_proposal_summary"
            ],
            "line": 108
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_proposal_read_driver",
            "names": [
              "PolicyProposalReadDriver",
              "get_policy_proposal_read_driver"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_proposal_write_driver",
            "names": [
              "PolicyProposalWriteDriver",
              "get_policy_proposal_write_driver"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "ActorType"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyApprovalRequest",
              "PolicyProposalCreate"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.logs.L6_drivers.audit_ledger_service_async",
            "names": [
              "AuditLedgerServiceAsync"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.policy_graph_engine",
            "names": [
              "ConflictSeverity",
              "get_conflict_engine",
              "get_dependency_engine"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [
          {
            "name": "FEEDBACK_THRESHOLD_FOR_PROPOSAL",
            "line": 96
          },
          {
            "name": "PROPOSAL_TYPES",
            "line": 97
          }
        ],
        "all_exports": [
          "PolicyProposalEngine",
          "get_policy_proposal_engine",
          "PolicyActivationBlockedError",
          "PolicyDeletionBlockedError",
          "FEEDBACK_THRESHOLD_FOR_PROPOSAL",
          "PROPOSAL_TYPES",
          "generate_default_rule",
          "check_proposal_eligibility",
          "create_policy_proposal",
          "review_policy_proposal",
          "delete_policy_rule",
          "get_proposal_summary"
        ]
      },
      {
        "file_name": "policy_rules_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/policy_rules_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 394,
        "module_docstring": "Policy Rules Service (PIN-LIM-02)\n\nPersist and validate policy rule logic.\n\nResponsibilities:\n- Create/update rules\n- Rule syntax validation\n- Link rules \u2192 limits\n- Handle retirement (rules are never deleted)\n- Emit audit events\n\nAll DB operations delegated to PolicyRulesDriver.",
        "functions": [],
        "classes": [
          {
            "name": "PolicyRulesServiceError",
            "docstring": "Base exception for policy rules service.",
            "methods": [],
            "line": 81
          },
          {
            "name": "RuleNotFoundError",
            "docstring": "Raised when rule is not found.",
            "methods": [],
            "line": 86
          },
          {
            "name": "RuleValidationError",
            "docstring": "Raised when rule validation fails.",
            "methods": [],
            "line": 91
          },
          {
            "name": "PolicyRulesService",
            "docstring": "Service for policy rule CRUD operations.\n\nINVARIANTS:\n- Rules are tenant-scoped\n- Rules are never deleted, only retired\n- Every active rule MUST have an integrity record\n- Retirement creates audit trail",
            "methods": [
              "__init__",
              "create",
              "update",
              "get",
              "_get_rule",
              "_validate_conditions",
              "_compute_hash",
              "_to_response"
            ],
            "line": 96
          }
        ],
        "imports": [
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.hoc.cus.general.L6_drivers.cross_domain",
            "names": [
              "generate_uuid"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.policy_rules_driver",
            "names": [
              "PolicyRulesDriver",
              "get_policy_rules_driver"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "PolicyRule",
              "PolicyRuleIntegrity",
              "PolicyRuleStatus"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "ActorType"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "app.hoc.cus.policies.L5_schemas.policy_rules",
            "names": [
              "CreatePolicyRuleRequest",
              "UpdatePolicyRuleRequest",
              "PolicyRuleResponse"
            ],
            "is_relative": false,
            "line": 73
          },
          {
            "module": "app.hoc.cus.logs.L6_drivers.audit_ledger_service_async",
            "names": [
              "AuditLedgerServiceAsync"
            ],
            "is_relative": false,
            "line": 78
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "prevention_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/prevention_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 521,
        "module_docstring": "Prevention Engine\n\nEvaluates policies DURING run execution at each step checkpoint.\nUses the policy snapshot captured at run start (not live policies)\nto ensure consistent enforcement throughout the run.\n\nKey Responsibilities:\n1. Evaluate step against policy thresholds\n2. Determine action (ALLOW, WARN, BLOCK)\n3. Return structured result for runner to act on\n\nRemediation: GAP-001 (Prevention hook integration), GAP-002 (Run stop on violation)",
        "functions": [
          {
            "name": "create_policy_snapshot_for_run",
            "signature": "(tenant_id: str, run_id: str) -> Optional[str]",
            "docstring": "Create a policy snapshot at run start.\n\nCaptures all active policies and thresholds for consistent\nevaluation throughout the run.\n\nArgs:\n    tenant_id: Tenant ID\n    run_id: Run ID for reference\n\nReturns:\n    snapshot_id if created, None on failure",
            "is_async": false,
            "line": 462
          }
        ],
        "classes": [
          {
            "name": "PreventionAction",
            "docstring": "Action to take based on policy evaluation.",
            "methods": [],
            "line": 44
          },
          {
            "name": "ViolationType",
            "docstring": "Types of policy violations.",
            "methods": [],
            "line": 51
          },
          {
            "name": "PreventionContext",
            "docstring": "Context for policy evaluation at a step checkpoint.\n\nImmutable snapshot of execution state at evaluation time.",
            "methods": [],
            "line": 61
          },
          {
            "name": "PreventionResult",
            "docstring": "Result of policy evaluation.\n\nContains the action to take and details about any violation.",
            "methods": [
              "allow",
              "warn",
              "block"
            ],
            "line": 94
          },
          {
            "name": "PolicyViolationError",
            "docstring": "Exception raised when a policy violation stops a run.\n\nContains the full PreventionResult for the violation.",
            "methods": [
              "__init__"
            ],
            "line": 145
          },
          {
            "name": "PreventionEngine",
            "docstring": "Evaluates policies at runtime checkpoints.\n\nUses policy snapshot from run start for consistent enforcement.",
            "methods": [
              "__init__",
              "load_snapshot",
              "evaluate_step",
              "_evaluate_step_inner",
              "_evaluate_custom_policy"
            ],
            "line": 157
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "prevention_hook.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/prevention_hook.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 302,
        "module_docstring": null,
        "functions": [
          {
            "name": "create_prevention_hook",
            "signature": "(strict_mode: bool = True, block_on_fail: bool = True) -> PreventionHook",
            "docstring": "Factory function to create a prevention hook.",
            "is_async": false,
            "line": 240
          },
          {
            "name": "get_prevention_hook",
            "signature": "() -> PreventionHook",
            "docstring": "Get the global prevention hook instance.",
            "is_async": false,
            "line": 255
          },
          {
            "name": "evaluate_response",
            "signature": "(tenant_id: str, call_id: str, user_query: str, context_data: Dict[str, Any], llm_output: str, model: str = 'unknown', user_id: Optional[str] = None) -> PreventionResult",
            "docstring": "Convenience function to evaluate an LLM response.\n\nUsage:\n    result = evaluate_response(\n        tenant_id=\"tenant_123\",\n        call_id=\"call_abc\",\n        user_query=\"Is my contract auto-renewed?\",\n        context_data={\"auto_renew\": None},\n        llm_output=\"Yes, your contract is set to auto-renew...\",\n    )\n\n    if result.action != PreventionAction.ALLOW:\n        # Handle blocked/modified response\n        pass",
            "is_async": false,
            "line": 263
          }
        ],
        "classes": [
          {
            "name": "PreventionAction",
            "docstring": "Action to take when prevention hook triggers.",
            "methods": [],
            "line": 43
          },
          {
            "name": "PreventionContext",
            "docstring": "Context for prevention hook evaluation.",
            "methods": [
              "__post_init__"
            ],
            "line": 54
          },
          {
            "name": "PreventionResult",
            "docstring": "Result of prevention hook evaluation.",
            "methods": [
              "__post_init__",
              "to_dict"
            ],
            "line": 82
          },
          {
            "name": "PreventionHook",
            "docstring": "Prevention hook for pre-response validation.\n\nUsage:\n    hook = PreventionHook(strict_mode=True)\n\n    # Before sending response to client\n    result = hook.evaluate(PreventionContext(\n        tenant_id=\"tenant_123\",\n        call_id=\"call_abc\",\n        user_id=\"cust_8372\",\n        model=\"gpt-4.1\",\n        user_query=\"Is my contract auto-renewed?\",\n        system_prompt=\"You are a helpful assistant.\",\n        context_data={\"auto_renew\": None, \"contract_status\": \"active\"},\n        llm_output=\"Yes, your contract is set to auto-renew...\",\n        output_tokens=18,\n    ))\n\n    if result.action == PreventionAction.BLOCK:\n        # Don't send response, return error or safe message\n        pass\n    elif result.action == PreventionAction.MODIFY:\n        # Send modified response\n        pass",
            "methods": [
              "__init__",
              "evaluate",
              "get_safe_response"
            ],
            "line": 117
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.policy.validators.content_accuracy",
            "names": [
              "ContentAccuracyValidator",
              "ValidationResult"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "protection_provider.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/protection_provider.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 388,
        "module_docstring": "Phase-7 Abuse Protection Provider \u2014 Interface and Mock Implementation\n\nPIN-399 Phase-7: Mock provider must be behavior-compatible with real provider.\n\nDESIGN INVARIANTS (LOCKED):\n- ABUSE-004: Protection providers are swappable behind a fixed interface\n- ABUSE-005: Mock provider must be behavior-compatible with real provider\n\nIMPLEMENTATION CONSTRAINTS:\n- Deterministic thresholds\n- Static configs\n- No external calls\n- No ML\n\nORDERING RULE (Critical):\n    Checks execute in this order:\n    1. Rate limit\n    2. Burst control\n    3. Cost guard\n    4. Anomaly detection\n\n    First REJECT stops evaluation.\n    This order is LOCKED to preserve predictability.",
        "functions": [
          {
            "name": "get_protection_provider",
            "signature": "() -> AbuseProtectionProvider",
            "docstring": "Get the abuse protection provider instance.\n\nReturns MockAbuseProtectionProvider by default.\nCan be replaced for testing or production.",
            "is_async": false,
            "line": 360
          },
          {
            "name": "set_protection_provider",
            "signature": "(provider: AbuseProtectionProvider) -> None",
            "docstring": "Set the abuse protection provider instance.\n\nUsed for testing or to swap in a real provider.",
            "is_async": false,
            "line": 373
          }
        ],
        "classes": [
          {
            "name": "AbuseProtectionProvider",
            "docstring": "Phase-7 Abuse Protection Provider Protocol.\n\nAll protection providers (mock and real) must implement this interface.\n\nThis protocol is LOCKED per ABUSE-004.",
            "methods": [
              "check_rate_limit",
              "check_burst",
              "check_cost",
              "detect_anomaly",
              "check_all"
            ],
            "line": 63
          },
          {
            "name": "MockAbuseProtectionProvider",
            "docstring": "Phase-7 Mock Abuse Protection Provider.\n\nImplements AbuseProtectionProvider protocol with deterministic behavior.\n\nIMPLEMENTATION CONSTRAINTS:\n- Deterministic thresholds\n- Static configs\n- No external calls\n- No ML\n- No adaptive behavior\n\nPROTECTION DIMENSIONS:\n- Rate limits: 1000 req/min default\n- Burst control: 100 req/sec default\n- Cost guards: Read from billing limits\n- Anomaly detection: 10x jump threshold",
            "methods": [
              "__init__",
              "check_rate_limit",
              "check_burst",
              "check_cost",
              "detect_anomaly",
              "check_all",
              "add_cost",
              "reset",
              "reset_rate_limits"
            ],
            "line": 148
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Protocol",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.protection.decisions",
            "names": [
              "Decision",
              "ProtectionResult",
              "AnomalySignal",
              "allow",
              "reject_rate_limit",
              "reject_cost_limit",
              "throttle"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.billing",
            "names": [
              "get_billing_provider",
              "Limits"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": [
          "AbuseProtectionProvider",
          "MockAbuseProtectionProvider",
          "get_protection_provider",
          "set_protection_provider"
        ]
      },
      {
        "file_name": "recovery_evaluation_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/recovery_evaluation_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 411,
        "module_docstring": "Domain engine for recovery evaluation decisions.\n\nThis L4 engine contains the authoritative decision logic for:\n1. Rule evaluation - evaluate_rules()\n2. Pattern matching - RecoveryMatcher\n3. Confidence combination - combine_confidences()\n4. Action selection threshold - should_select_action()\n5. Auto-execution threshold - should_auto_execute()\n6. Decision record emission - emit_recovery_decision()\n\nL5 workers must call this engine and execute the returned decisions,\nnot implement their own decision logic.\n\nReference: PIN-257 Phase R-1\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md",
        "functions": [
          {
            "name": "evaluate_recovery",
            "signature": "(failure_match_id: str, error_code: str, error_message: str, **kwargs) -> RecoveryDecision",
            "docstring": "Convenience function to evaluate a failure and get a decision.\n\nThis is the L4 entry point for recovery evaluation. It returns\na RecoveryDecision that L5 must execute.\n\nArgs:\n    failure_match_id: ID of the failure match record\n    error_code: Error code\n    error_message: Error message\n    **kwargs: Additional context fields\n\nReturns:\n    RecoveryDecision with all domain decisions\n\nReference: PIN-257 Phase R-1",
            "is_async": false,
            "line": 287
          },
          {
            "name": "evaluate_and_execute",
            "signature": "(failure_match_id: str, error_code: str, error_message: str, **kwargs) -> 'EvaluationOutcome'",
            "docstring": "Full entry point: evaluate failure and execute decision.\n\nThis L4 function:\n1. Creates FailureContext from input\n2. Evaluates using RecoveryEvaluationEngine (L4 domain decisions)\n3. Calls L5 RecoveryExecutor to execute the decision\n4. Emits decision record (L4 responsibility)\n5. Returns EvaluationOutcome\n\nThis replaces the old evaluate_failure() in L5 recovery_evaluator.py.\n\nArgs:\n    failure_match_id: ID of the failure match record\n    error_code: Error code\n    error_message: Error message\n    **kwargs: Additional context fields\n\nReturns:\n    EvaluationOutcome with execution result\n\nReference: PIN-257 Phase R-1 (L5\u2192L4 Violation Fix)",
            "is_async": true,
            "line": 325
          }
        ],
        "classes": [
          {
            "name": "FailureContext",
            "docstring": "Context for recovery evaluation (mirrors L5 FailureEvent for L4 use).",
            "methods": [
              "__post_init__"
            ],
            "line": 69
          },
          {
            "name": "RecoveryDecision",
            "docstring": "Domain decision DTO returned by L4 engine to L5 executor.\n\nThis dataclass contains all decisions made by L4 domain logic.\nL5 must execute based on these decisions without reimplementing logic.\n\nReference: PIN-257 Phase R-1",
            "methods": [
              "to_dict"
            ],
            "line": 90
          },
          {
            "name": "RecoveryEvaluationEngine",
            "docstring": "L4 Domain Engine for recovery evaluation decisions.\n\nThis engine contains ALL domain decision logic that was previously\nscattered in L5 recovery_evaluator.py. It evaluates failure context\nand returns a RecoveryDecision DTO that L5 must execute.\n\nL5 may NOT:\n- Re-implement rule evaluation\n- Re-calculate confidence scores\n- Make action selection decisions\n- Make auto-execution decisions\n- Emit decision records\n\nL5 may ONLY:\n- Execute the decision returned by this engine\n- Perform DB operations (L6)\n- Trigger execution hooks\n\nReference: PIN-257 Phase R-1\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md Section 3.4",
            "methods": [
              "__init__",
              "evaluate",
              "emit_decision_record"
            ],
            "line": 136
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.contracts.decisions",
            "names": [
              "emit_recovery_decision"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.hoc.cus.policies.L6_drivers.recovery_matcher",
            "names": [
              "RecoveryMatcher"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.hoc.cus.incidents.L5_engines.recovery_rule_engine",
            "names": [
              "combine_confidences",
              "evaluate_rules",
              "should_auto_execute",
              "should_select_action"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [],
        "all_exports": [
          "FailureContext",
          "RecoveryDecision",
          "RecoveryEvaluationEngine",
          "evaluate_recovery",
          "evaluate_and_execute"
        ]
      },
      {
        "file_name": "runtime_command.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/runtime_command.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 561,
        "module_docstring": "Runtime Domain Commands (L4)\n\nDomain engine for runtime-related decisions. Provides authoritative answers for:\n1. Skill descriptions - what skills exist and their metadata\n2. Runtime queries - budget, history, capability information\n3. Resource contracts - budget, rate limits, constraints\n\nThis is an L4 domain engine. It makes decisions based on domain facts.\nIt does NOT execute skills. Execution is L5's responsibility.\n\nReference: PIN-258 Phase F-3 Runtime Cluster",
        "functions": [
          {
            "name": "get_supported_query_types",
            "signature": "() -> List[str]",
            "docstring": "Get list of supported query types.\n\nThis is an L4 domain decision - defining what queries the system supports.\n\nReturns:\n    List of supported query type strings",
            "is_async": false,
            "line": 230
          },
          {
            "name": "query_remaining_budget",
            "signature": "(spent_cents: int = 0, total_cents: int = DEFAULT_BUDGET_CENTS) -> QueryResult",
            "docstring": "Query remaining budget.\n\nL4 domain decision: How to calculate and present budget information.\n\nArgs:\n    spent_cents: Amount already spent\n    total_cents: Total budget available\n\nReturns:\n    QueryResult with budget information",
            "is_async": false,
            "line": 242
          },
          {
            "name": "query_execution_history",
            "signature": "(history: Optional[List[Dict[str, Any]]] = None) -> QueryResult",
            "docstring": "Query execution history.\n\nL4 domain decision: How to present execution history.\n\nArgs:\n    history: Execution history records\n\nReturns:\n    QueryResult with history",
            "is_async": false,
            "line": 268
          },
          {
            "name": "query_allowed_skills",
            "signature": "() -> QueryResult",
            "docstring": "Query list of allowed skills.\n\nL4 domain decision: What skills are available.\n\nReturns:\n    QueryResult with skill list",
            "is_async": false,
            "line": 286
          },
          {
            "name": "query_last_step_outcome",
            "signature": "(outcome: Optional[Dict[str, Any]] = None) -> QueryResult",
            "docstring": "Query last step outcome.\n\nL4 domain decision: How to present last outcome.\n\nArgs:\n    outcome: Last execution outcome\n\nReturns:\n    QueryResult with outcome",
            "is_async": false,
            "line": 305
          },
          {
            "name": "query_skills_for_goal",
            "signature": "(goal: str) -> QueryResult",
            "docstring": "Query skills available for a goal.\n\nL4 domain decision: Deterministic skill matching based on goal.\n\nArgs:\n    goal: Goal description\n\nReturns:\n    QueryResult with matched skills",
            "is_async": false,
            "line": 323
          },
          {
            "name": "execute_query",
            "signature": "(query_type: str, params: Optional[Dict[str, Any]] = None) -> QueryResult",
            "docstring": "Execute a runtime query.\n\nL4 domain command: Routes query to appropriate handler.\n\nArgs:\n    query_type: Type of query\n    params: Query parameters\n\nReturns:\n    QueryResult with query response",
            "is_async": false,
            "line": 350
          },
          {
            "name": "get_skill_info",
            "signature": "(skill_id: str) -> Optional[SkillInfo]",
            "docstring": "Get domain information about a skill.\n\nL4 domain decision: Skill metadata and capabilities.\n\nArgs:\n    skill_id: Skill identifier\n\nReturns:\n    SkillInfo if skill exists, None otherwise",
            "is_async": false,
            "line": 391
          },
          {
            "name": "list_skills",
            "signature": "() -> List[str]",
            "docstring": "List all available skill IDs.\n\nL4 domain decision: What skills are known to the system.\n\nReturns:\n    List of skill IDs",
            "is_async": false,
            "line": 420
          },
          {
            "name": "get_all_skill_descriptors",
            "signature": "() -> Dict[str, Dict[str, Any]]",
            "docstring": "Get descriptors for all skills.\n\nL4 domain decision: Comprehensive skill information.\n\nReturns:\n    Dict mapping skill_id to descriptor dict",
            "is_async": false,
            "line": 432
          },
          {
            "name": "get_resource_contract",
            "signature": "(resource_id: str) -> ResourceContractInfo",
            "docstring": "Get resource contract information.\n\nL4 domain decision: Default resource constraints.\n\nArgs:\n    resource_id: Resource identifier\n\nReturns:\n    ResourceContractInfo with contract details",
            "is_async": false,
            "line": 460
          },
          {
            "name": "get_capabilities",
            "signature": "(agent_id: Optional[str] = None, tenant_id: Optional[str] = None) -> CapabilitiesInfo",
            "docstring": "Get capabilities for an agent/tenant.\n\nL4 domain decision: What capabilities are available.\n\nArgs:\n    agent_id: Optional agent ID\n    tenant_id: Optional tenant ID\n\nReturns:\n    CapabilitiesInfo with capability details",
            "is_async": false,
            "line": 485
          }
        ],
        "classes": [
          {
            "name": "QueryResult",
            "docstring": "Result from a runtime query command.",
            "methods": [],
            "line": 72
          },
          {
            "name": "SkillInfo",
            "docstring": "Domain information about a skill.",
            "methods": [],
            "line": 81
          },
          {
            "name": "ResourceContractInfo",
            "docstring": "Domain information about a resource contract.",
            "methods": [],
            "line": 98
          },
          {
            "name": "CapabilitiesInfo",
            "docstring": "Domain information about available capabilities.",
            "methods": [],
            "line": 108
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "DEFAULT_BUDGET_CENTS",
          "DEFAULT_RATE_LIMIT_PER_MINUTE",
          "DEFAULT_MAX_CONCURRENT",
          "SUPPORTED_QUERY_TYPES",
          "DEFAULT_SKILL_METADATA",
          "QueryResult",
          "SkillInfo",
          "ResourceContractInfo",
          "CapabilitiesInfo",
          "get_supported_query_types",
          "query_remaining_budget",
          "query_execution_history",
          "query_allowed_skills",
          "query_last_step_outcome",
          "query_skills_for_goal",
          "execute_query",
          "get_skill_info",
          "list_skills",
          "get_all_skill_descriptors",
          "get_resource_contract",
          "get_capabilities"
        ]
      },
      {
        "file_name": "sandbox_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/sandbox_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 551,
        "module_docstring": "Sandbox Service (GAP-174)\n\nHigh-level service for managing sandbox execution:\n- Policy-based isolation level selection\n- Execution quota management\n- Audit logging\n- Result caching",
        "functions": [],
        "classes": [
          {
            "name": "SandboxPolicy",
            "docstring": "Policy for sandbox execution.",
            "methods": [
              "to_resource_limits",
              "to_dict"
            ],
            "line": 51
          },
          {
            "name": "ExecutionRequest",
            "docstring": "Request to execute code in a sandbox.",
            "methods": [],
            "line": 113
          },
          {
            "name": "ExecutionRecord",
            "docstring": "Record of a sandbox execution for audit.",
            "methods": [
              "to_dict"
            ],
            "line": 134
          },
          {
            "name": "SandboxService",
            "docstring": "High-level sandbox service.\n\nFeatures:\n- Policy-based execution management\n- Quota enforcement\n- Audit logging\n- Multiple executor support",
            "methods": [
              "__init__",
              "_setup_default_policies",
              "_get_executor",
              "execute",
              "_get_policy",
              "_check_quota",
              "_track_execution",
              "define_policy",
              "get_policy",
              "list_policies",
              "get_execution_records",
              "get_execution_stats"
            ],
            "line": 180
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "sandbox_executor",
            "names": [
              "ExecutionResult",
              "IsolationLevel",
              "NetworkPolicy",
              "ResourceLimits",
              "SandboxExecutor",
              "SandboxStatus",
              "create_sandbox_executor"
            ],
            "is_relative": true,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "snapshot_engine.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/snapshot_engine.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 594,
        "module_docstring": "Policy Snapshot Immutability Engine (GAP-029).\n\nProvides immutable policy snapshot management with:\n- Immutability enforcement (no modifications after creation)\n- Snapshot versioning and history\n- Integrity verification\n- Tenant isolation",
        "functions": [
          {
            "name": "get_snapshot_registry",
            "signature": "() -> PolicySnapshotRegistry",
            "docstring": "Get the singleton registry instance.",
            "is_async": false,
            "line": 535
          },
          {
            "name": "_reset_snapshot_registry",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 543
          },
          {
            "name": "create_policy_snapshot",
            "signature": "(tenant_id: str, policies: list[dict[str, Any]], thresholds: dict[str, Any], policy_version: Optional[str] = None, description: Optional[str] = None) -> PolicySnapshotData",
            "docstring": "Create a new immutable policy snapshot.",
            "is_async": false,
            "line": 552
          },
          {
            "name": "get_policy_snapshot",
            "signature": "(snapshot_id: str) -> Optional[PolicySnapshotData]",
            "docstring": "Get a policy snapshot by ID.",
            "is_async": false,
            "line": 570
          },
          {
            "name": "get_active_snapshot",
            "signature": "(tenant_id: str) -> Optional[PolicySnapshotData]",
            "docstring": "Get the active policy snapshot for a tenant.",
            "is_async": false,
            "line": 576
          },
          {
            "name": "get_snapshot_history",
            "signature": "(tenant_id: str, limit: int = 100) -> List[PolicySnapshotData]",
            "docstring": "Get snapshot version history for a tenant.",
            "is_async": false,
            "line": 582
          },
          {
            "name": "verify_snapshot",
            "signature": "(snapshot_id: str) -> dict[str, Any]",
            "docstring": "Verify snapshot integrity.",
            "is_async": false,
            "line": 591
          }
        ],
        "classes": [
          {
            "name": "SnapshotStatus",
            "docstring": "Status of a policy snapshot.",
            "methods": [],
            "line": 39
          },
          {
            "name": "ImmutabilityViolation",
            "docstring": "Types of immutability violations.",
            "methods": [],
            "line": 48
          },
          {
            "name": "PolicySnapshotData",
            "docstring": "Immutable policy snapshot data.\n\nOnce created, the content cannot be modified.\nOnly status can transition through allowed paths.",
            "methods": [
              "compute_hash",
              "verify_integrity",
              "verify_threshold_integrity",
              "get_policies",
              "get_thresholds",
              "to_dict"
            ],
            "line": 59
          },
          {
            "name": "PolicySnapshotError",
            "docstring": "Exception for policy snapshot errors.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 139
          },
          {
            "name": "SnapshotRegistryStats",
            "docstring": "Statistics for snapshot registry.",
            "methods": [
              "to_dict"
            ],
            "line": 165
          },
          {
            "name": "PolicySnapshotRegistry",
            "docstring": "Registry for managing immutable policy snapshots.\n\nFeatures:\n- Immutability enforcement (no content modifications)\n- Version tracking per tenant\n- Automatic supersession of old snapshots\n- Integrity verification\n- Tenant isolation",
            "methods": [
              "__init__",
              "create",
              "get",
              "get_active",
              "get_by_version",
              "list",
              "get_history",
              "archive",
              "verify",
              "attempt_modify",
              "delete",
              "get_statistics",
              "clear_tenant",
              "reset",
              "_get_next_version",
              "_supersede_active"
            ],
            "line": 193
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "state.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/state.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 108,
        "module_docstring": "Phase-6 Billing State \u2014 Commercial State Model\n\nPIN-399 Phase-6: Billing never blocks onboarding.\n\nDESIGN INVARIANTS (LOCKED):\n- BILLING-001: Billing never blocks onboarding\n- BILLING-002: Limits are derived, not stored\n- BILLING-003: Billing state does not affect roles\n- BILLING-004: No billing mutation without audit\n- BILLING-005: Mock provider must satisfy same interface as real provider\n\nAPPLICABILITY GATE:\n    Billing logic is evaluated ONLY IF tenant.onboarding_state == COMPLETE.\n    Before COMPLETE:\n    - Billing APIs return neutral placeholders\n    - Limits are not enforced\n    - Usage is tracked but not blocked\n\nThis enum is the single source of truth for billing states.",
        "functions": [],
        "classes": [
          {
            "name": "BillingState",
            "docstring": "Phase-6 Billing States (Tenant-scoped).\n\nStates represent the commercial standing of a tenant.\nNOT tied to any specific payment gateway.\n\nSEMANTICS (LOCKED):\n- TRIAL: Default after onboarding COMPLETE\n- ACTIVE: Valid paid plan\n- PAST_DUE: Payment issue, grace period active\n- SUSPENDED: Usage blocked, data intact\n\nNo other states allowed in v1.",
            "methods": [
              "from_string",
              "default",
              "allows_usage",
              "is_in_good_standing"
            ],
            "line": 45
          }
        ],
        "imports": [
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "BillingState"
        ]
      },
      {
        "file_name": "tokenizer.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/tokenizer.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 352,
        "module_docstring": "Tokenizer for PLang v2.0 with M19 category support.\n\nToken types include:\n- Keywords: policy, rule, when, then, deny, allow, etc.\n- Categories: SAFETY, PRIVACY, OPERATIONAL, ROUTING, CUSTOM\n- Identifiers: user-defined names\n- Literals: numbers, strings, booleans\n- Operators: ==, !=, <, >, etc.\n- Delimiters: {, }, (, ), :, ,",
        "functions": [],
        "classes": [
          {
            "name": "TokenType",
            "docstring": "Token types for PLang v2.0.",
            "methods": [],
            "line": 39
          },
          {
            "name": "Token",
            "docstring": "A token in PLang source code.",
            "methods": [
              "__repr__",
              "is_category",
              "is_action"
            ],
            "line": 123
          },
          {
            "name": "TokenizerError",
            "docstring": "Error during tokenization.",
            "methods": [
              "__init__"
            ],
            "line": 151
          },
          {
            "name": "Tokenizer",
            "docstring": "Tokenizer for PLang v2.0.\n\nConverts source code into a stream of tokens for parsing.\nSupports M19 governance categories and policy-specific syntax.",
            "methods": [
              "__init__",
              "current_char",
              "peek",
              "advance",
              "skip_whitespace",
              "skip_comment",
              "read_string",
              "read_number",
              "read_identifier",
              "read_operator",
              "tokenize",
              "__iter__"
            ],
            "line": 161
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Iterator",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [
          {
            "name": "KEYWORD_TOKENS",
            "line": 96
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "validator.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/validator.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 386,
        "module_docstring": "Policy DSL Semantic Validator\n\nValidates AST against semantic rules. Does NOT parse.\n\nDESIGN CONSTRAINTS (BLOCKING - PIN-341):\n- Pure validation logic\n- No side effects\n- No I/O, no DB\n- Must produce validation result (errors/warnings), not exceptions\n\nSEMANTIC RULES:\n1. Mode Enforcement:\n   - MONITOR mode: Only WARN actions allowed\n   - ENFORCE mode: WARN, BLOCK, REQUIRE_APPROVAL allowed\n\n2. Metric Validation (optional):\n   - If metric registry provided, validate metrics exist\n\n3. Version Validation:\n   - Version must be >= 1\n\n4. Structural Validation:\n   - At least one clause\n   - At least one action per clause\n\nGOVERNANCE:\n- Validator is the authority on policy correctness\n- All enforcement decisions derive from validator",
        "functions": [
          {
            "name": "validate",
            "signature": "(policy: PolicyAST, allowed_metrics: set[str] | None = None) -> ValidationResult",
            "docstring": "Validate a policy AST.\n\nArgs:\n    policy: The PolicyAST to validate\n    allowed_metrics: If provided, validate metrics against this set\n\nReturns:\n    ValidationResult with all issues found\n\nExample:\n    >>> from app.dsl import parse\n    >>> ast = parse('''\n    ... policy Test\n    ... version 1\n    ... scope ORG\n    ... mode MONITOR\n    ...\n    ... when x > 0\n    ... then BLOCK\n    ... ''')\n    >>> result = validate(ast)\n    >>> result.is_valid\n    False\n    >>> result.errors[0].code\n    'V001'",
            "is_async": false,
            "line": 336
          },
          {
            "name": "is_valid",
            "signature": "(policy: PolicyAST, allowed_metrics: set[str] | None = None) -> bool",
            "docstring": "Quick check if a policy is valid.\n\nArgs:\n    policy: The PolicyAST to validate\n    allowed_metrics: If provided, validate metrics against this set\n\nReturns:\n    True if valid, False otherwise",
            "is_async": false,
            "line": 371
          }
        ],
        "classes": [
          {
            "name": "Severity",
            "docstring": "Severity level for validation issues.",
            "methods": [],
            "line": 73
          },
          {
            "name": "ValidationIssue",
            "docstring": "A single validation issue found in the policy.",
            "methods": [
              "__str__"
            ],
            "line": 81
          },
          {
            "name": "ValidationResult",
            "docstring": "Result of policy validation.",
            "methods": [
              "__post_init__",
              "errors",
              "warnings",
              "__bool__"
            ],
            "line": 95
          },
          {
            "name": "PolicyValidator",
            "docstring": "Validates PolicyAST against semantic rules.\n\nUsage:\n    validator = PolicyValidator()\n    result = validator.validate(ast)\n    if not result.is_valid:\n        for error in result.errors:\n            print(error)",
            "methods": [
              "__init__",
              "validate",
              "_validate_mode_enforcement",
              "_validate_metrics",
              "_extract_metrics",
              "_validate_structure",
              "_check_warnings"
            ],
            "line": 146
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Callable"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.dsl.ast",
            "names": [
              "Condition",
              "Mode",
              "PolicyAST",
              "is_block_action",
              "is_exists_predicate",
              "is_logical_condition",
              "is_predicate",
              "is_require_approval_action"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [
          {
            "name": "V001",
            "line": 126
          },
          {
            "name": "V002",
            "line": 127
          },
          {
            "name": "V010",
            "line": 130
          },
          {
            "name": "V020",
            "line": 133
          },
          {
            "name": "V021",
            "line": 134
          },
          {
            "name": "W001",
            "line": 137
          },
          {
            "name": "W002",
            "line": 138
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "visitors.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/visitors.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 307,
        "module_docstring": "AST visitors for PLang v2.0.\n\nVisitors for:\n- Pretty printing\n- Category collection\n- Rule extraction\n- Governance analysis",
        "functions": [],
        "classes": [
          {
            "name": "BaseVisitor",
            "docstring": "Base visitor with default implementations.",
            "methods": [
              "visit_program",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_import",
              "visit_rule_ref",
              "visit_priority",
              "visit_condition_block",
              "visit_action_block",
              "visit_route_target",
              "visit_binary_op",
              "visit_unary_op",
              "visit_ident",
              "visit_literal",
              "visit_func_call",
              "visit_attr_access"
            ],
            "line": 54
          },
          {
            "name": "PrintVisitor",
            "docstring": "Visitor that prints AST in readable format.",
            "methods": [
              "__init__",
              "_emit",
              "get_output",
              "visit_program",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_import",
              "visit_rule_ref",
              "visit_priority",
              "visit_condition_block",
              "visit_action_block",
              "visit_route_target",
              "visit_binary_op",
              "visit_unary_op",
              "visit_ident",
              "visit_literal",
              "visit_func_call",
              "visit_attr_access"
            ],
            "line": 118
          },
          {
            "name": "CategoryCollector",
            "docstring": "Visitor that collects all categories used in the AST.\n\nUsed for governance analysis and category-based routing.",
            "methods": [
              "__init__",
              "get_categories",
              "visit_policy_decl",
              "visit_rule_decl"
            ],
            "line": 222
          },
          {
            "name": "RuleExtractor",
            "docstring": "Visitor that extracts all rules with their governance metadata.\n\nUsed for building the symbol table and IR.",
            "methods": [
              "__init__",
              "get_rules",
              "visit_policy_decl",
              "visit_rule_decl",
              "visit_condition_block"
            ],
            "line": 250
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.policy.ast.nodes",
            "names": [
              "ActionBlockNode",
              "ASTVisitor",
              "AttrAccessNode",
              "BinaryOpNode",
              "ConditionBlockNode",
              "FuncCallNode",
              "IdentNode",
              "ImportNode",
              "LiteralNode",
              "PolicyDeclNode",
              "PriorityNode",
              "ProgramNode",
              "RouteTargetNode",
              "RuleDeclNode",
              "RuleRefNode",
              "UnaryOpNode"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "worker_execution_command.py",
        "file_path": "backend/app/hoc/cus/policies/L5_engines/worker_execution_command.py",
        "layer": "L5_engines",
        "domain": "policies",
        "lines": 353,
        "module_docstring": "Worker Execution Command (L4)\n\nDomain command for Business Builder Worker execution. This L4 command:\n1. Takes domain facts (task, brand, budget, etc.)\n2. Provides authorization for execution\n3. Delegates to L5 workers (since L4 \u2192 L5 is allowed)\n4. Returns results\n\nThis is NOT an execution layer. It authorizes and delegates.\nAll execution logic remains in L5 workers.\n\nReference: PIN-258 Phase F-3 Workers Cluster",
        "functions": [
          {
            "name": "calculate_cost_cents",
            "signature": "(model: str, input_tokens: int, output_tokens: int) -> int",
            "docstring": "Calculate LLM cost in cents.\n\nThis L4 command delegates to L5 cost calculation.\nL4 \u2192 L5 is an allowed import per layer rules.\n\nArgs:\n    model: Model name\n    input_tokens: Number of input tokens\n    output_tokens: Number of output tokens\n\nReturns:\n    Cost in cents\n\nReference: PIN-258 Phase F-3 (F-W-RULE-1: No semantic changes)",
            "is_async": false,
            "line": 90
          },
          {
            "name": "get_brand_schema_types",
            "signature": "()",
            "docstring": "Get brand schema types from L5.\n\nL4 \u2192 L5 is an allowed import per layer rules.\nReturns the schema types needed for brand conversion.\n\nReference: PIN-258 Phase F-3 (F-W-RULE-1: No semantic changes)",
            "is_async": false,
            "line": 118
          },
          {
            "name": "convert_brand_request",
            "signature": "(brand_req) -> Any",
            "docstring": "Convert API brand request to BrandSchema.\n\nThis L4 command handles the conversion logic using L5 schemas.\nL4 \u2192 L5 is an allowed import per layer rules.\n\nArgs:\n    brand_req: Brand request from API\n\nReturns:\n    BrandSchema instance\n\nReference: PIN-258 Phase F-3 (F-W-RULE-1: No semantic changes)",
            "is_async": false,
            "line": 146
          },
          {
            "name": "execute_worker",
            "signature": "(task: str, brand: Optional[Any] = None, budget: Optional[int] = None, strict_mode: bool = False, depth: int = 2, run_id: Optional[str] = None, event_bus: Optional[Any] = None) -> WorkerExecutionResult",
            "docstring": "Execute Business Builder Worker.\n\nThis L4 command authorizes and delegates execution to L5.\nL4 \u2192 L5 is an allowed import per layer rules.\n\nF-W-RULE-2: Worker is a blind executor. This command delegates to it.\nF-W-RULE-3: This command authorizes, L5 executes.\n\nArgs:\n    task: Business/product idea\n    brand: Optional brand schema\n    budget: Optional budget\n    strict_mode: Whether to use strict mode\n    depth: Execution depth\n    run_id: Optional run ID\n    event_bus: Optional event bus\n\nReturns:\n    WorkerExecutionResult with execution outcome\n\nReference: PIN-258 Phase F-3 Workers Cluster",
            "is_async": true,
            "line": 229
          },
          {
            "name": "replay_execution",
            "signature": "(replay_token: str, run_id: str) -> ReplayResult",
            "docstring": "Replay a previous execution.\n\nThis L4 command authorizes and delegates replay to L5.\nL4 \u2192 L5 is an allowed import per layer rules.\n\nArgs:\n    replay_token: Token from previous execution\n    run_id: New run ID for this replay\n\nReturns:\n    ReplayResult with replay outcome\n\nReference: PIN-258 Phase F-3 Workers Cluster",
            "is_async": true,
            "line": 298
          }
        ],
        "classes": [
          {
            "name": "WorkerExecutionResult",
            "docstring": "Result from worker execution command.",
            "methods": [],
            "line": 46
          },
          {
            "name": "ReplayResult",
            "docstring": "Result from replay command.",
            "methods": [],
            "line": 66
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": [
          "WorkerExecutionResult",
          "ReplayResult",
          "calculate_cost_cents",
          "get_brand_schema_types",
          "convert_brand_request",
          "execute_worker",
          "replay_execution"
        ]
      }
    ],
    "l5_schemas": [
      {
        "file_name": "policy_rules.py",
        "file_path": "backend/app/hoc/cus/policies/L5_schemas/policy_rules.py",
        "layer": "L5_schemas",
        "domain": "policies",
        "lines": 160,
        "module_docstring": "Policy Rules Schemas (PIN-LIM-02)\n\nRequest and response models for policy rule CRUD operations.\nRules define governance constraints that govern LLM Run behavior.",
        "functions": [],
        "classes": [
          {
            "name": "EnforcementModeEnum",
            "docstring": "Policy rule enforcement modes.",
            "methods": [],
            "line": 25
          },
          {
            "name": "PolicyScopeEnum",
            "docstring": "Policy rule scope levels.",
            "methods": [],
            "line": 33
          },
          {
            "name": "PolicySourceEnum",
            "docstring": "Policy rule creation source.",
            "methods": [],
            "line": 41
          },
          {
            "name": "CreatePolicyRuleRequest",
            "docstring": "Request model for creating a policy rule.",
            "methods": [],
            "line": 48
          },
          {
            "name": "UpdatePolicyRuleRequest",
            "docstring": "Request model for updating a policy rule.",
            "methods": [],
            "line": 97
          },
          {
            "name": "PolicyRuleResponse",
            "docstring": "Response model for policy rule operations.",
            "methods": [],
            "line": 136
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 22
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "arbitrator.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/arbitrator.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 339,
        "module_docstring": "Policy Arbitrator Engine\n\nResolves conflicts when multiple policies apply to the same run:\n1. Sort policies by precedence (lower = higher priority)\n2. Resolve limit conflicts using conflict strategy\n3. Resolve action conflicts (harshest action wins)\n4. Return effective limits and actions\n\nArbitration Rules:\n- MOST_RESTRICTIVE: Smallest limit, harshest action wins\n- EXPLICIT_PRIORITY: Higher precedence (lower number) wins\n- FAIL_CLOSED: If ambiguous, deny/stop",
        "functions": [
          {
            "name": "get_policy_arbitrator",
            "signature": "() -> PolicyArbitrator",
            "docstring": "Get or create PolicyArbitrator singleton.",
            "is_async": false,
            "line": 334
          }
        ],
        "classes": [
          {
            "name": "PolicyLimit",
            "docstring": "Represents a policy limit.",
            "methods": [],
            "line": 56
          },
          {
            "name": "PolicyAction",
            "docstring": "Represents a policy breach action.",
            "methods": [],
            "line": 66
          },
          {
            "name": "ArbitrationInput",
            "docstring": "Input for policy arbitration.",
            "methods": [],
            "line": 83
          },
          {
            "name": "PolicyArbitrator",
            "docstring": "Resolves conflicts between multiple applicable policies.\n\nThe arbitrator determines effective limits and actions when\nmultiple policies apply to the same run.",
            "methods": [
              "__init__",
              "arbitrate",
              "_load_precedence_map",
              "_get_precedence_map",
              "_resolve_limit_conflict",
              "_resolve_action_conflict"
            ],
            "line": 93
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.db",
            "names": [
              "engine"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.policy_precedence",
            "names": [
              "ArbitrationResult",
              "ConflictStrategy",
              "PolicyPrecedence"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [
          {
            "name": "ACTION_SEVERITY",
            "line": 75
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "optimizer_conflict_resolver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/optimizer_conflict_resolver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 390,
        "module_docstring": "Conflict resolution for PLang v2.0.\n\nConflict types:\n- Action conflicts: Different actions for same condition\n- Priority conflicts: Same priority for different policies\n- Category conflicts: Cross-category interactions\n\nResolution strategies:\n- Category precedence: SAFETY > PRIVACY > OPERATIONAL > ROUTING > CUSTOM\n- Priority ordering: Higher priority wins\n- Action precedence: deny > escalate > route > allow",
        "functions": [],
        "classes": [
          {
            "name": "ConflictType",
            "docstring": "Types of policy conflicts.",
            "methods": [],
            "line": 51
          },
          {
            "name": "PolicyConflict",
            "docstring": "A detected conflict between policies.\n\nIncludes conflict type, involved policies, and resolution.",
            "methods": [
              "__str__"
            ],
            "line": 61
          },
          {
            "name": "ConflictResolver",
            "docstring": "Resolves conflicts between policies.\n\nUses M19 governance rules to determine winning policy\nwhen conflicts are detected.",
            "methods": [
              "__init__",
              "resolve",
              "_detect_action_conflicts",
              "_detect_priority_conflicts",
              "_detect_category_conflicts",
              "_detect_circular_dependencies",
              "_get_condition_signature",
              "_might_override",
              "_get_actions",
              "_resolve_conflict",
              "_resolve_action_conflict",
              "_resolve_priority_conflict",
              "_resolve_category_conflict",
              "_resolve_circular_conflict"
            ],
            "line": 81
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "List",
              "Optional",
              "Set",
              "Tuple"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "PLANG_GRAMMAR",
              "ActionType",
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.policy.ir.ir_nodes",
            "names": [
              "IRAction",
              "IRBlock",
              "IRFunction",
              "IRModule"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_engine_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_engine_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 1411,
        "module_docstring": "Policy Engine Driver (L6)\n\nPure data access for PolicyEngine operations.\nNo business logic - only DB operations.\n\nAuthority: POLICY_ENGINE_PERSISTENCE\nTables:\n  - policy.evaluations (write)\n  - policy.violations (read/write)\n  - policy.ethical_constraints (read)\n  - policy.risk_ceilings (read/write)\n  - policy.safety_rules (read/write)\n  - policy.business_rules (read)\n  - policy.policy_versions (read/write)\n  - policy.policy_provenance (read/write)\n  - policy.policy_dependencies (read/write)\n  - policy.policy_conflicts (read/write)\n  - policy.temporal_policies (read/write)\n  - policy.temporal_metric_events (read/write)\n  - policy.temporal_metric_windows (read/write)",
        "functions": [
          {
            "name": "get_policy_engine_driver",
            "signature": "(db_url: str) -> PolicyEngineDriver",
            "docstring": "Factory function for PolicyEngineDriver.",
            "is_async": false,
            "line": 1403
          }
        ],
        "classes": [
          {
            "name": "PolicyEngineDriver",
            "docstring": "L6 driver for PolicyEngine data access.\n\nINVARIANTS (L6):\n- No business branching\n- No validation\n- No cross-domain calls\n- Pure persistence operations only",
            "methods": [
              "__init__",
              "_get_engine",
              "fetch_ethical_constraints",
              "fetch_risk_ceilings",
              "fetch_safety_rules",
              "fetch_business_rules",
              "insert_evaluation",
              "insert_violation",
              "fetch_violations",
              "fetch_violation_by_id",
              "update_violation_acknowledged",
              "update_risk_ceiling",
              "reset_risk_ceiling",
              "update_safety_rule",
              "fetch_policy_versions",
              "fetch_current_active_version",
              "fetch_policy_version_by_id",
              "fetch_policy_version_by_id_or_version",
              "deactivate_all_versions",
              "insert_policy_version",
              "fetch_version_for_rollback",
              "mark_version_rolled_back",
              "activate_version",
              "insert_provenance",
              "fetch_provenance",
              "fetch_dependencies",
              "fetch_dependency_edges",
              "fetch_dependency_edges_with_type",
              "insert_dependency",
              "fetch_conflicts",
              "fetch_unresolved_conflicts",
              "resolve_conflict",
              "fetch_temporal_policies",
              "insert_temporal_policy",
              "fetch_temporal_policy_for_utilization",
              "fetch_temporal_metric_sum",
              "delete_old_temporal_events",
              "compact_temporal_events",
              "cap_temporal_events",
              "fetch_temporal_stats",
              "fetch_temporal_storage_stats",
              "fetch_active_policies_for_integrity",
              "fetch_temporal_policies_for_integrity",
              "fetch_ethical_constraints_for_integrity"
            ],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "sqlalchemy",
            "names": [
              "create_engine",
              "text"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "sqlalchemy.engine",
            "names": [
              "Connection",
              "Engine"
            ],
            "is_relative": false,
            "line": 62
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyEngineDriver",
          "get_policy_engine_driver"
        ]
      },
      {
        "file_name": "policy_graph_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_graph_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 226,
        "module_docstring": "Policy Graph Driver (L6 Data Access)\n\nHandles database operations for policy graph computation:\n- Fetching policies for conflict detection\n- Fetching limits for threshold analysis\n- Fetching resolved conflict pairs\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_policy_graph_driver",
            "signature": "(session: AsyncSession) -> PolicyGraphDriver",
            "docstring": "Get a PolicyGraphDriver instance.",
            "is_async": false,
            "line": 224
          }
        ],
        "classes": [
          {
            "name": "PolicyGraphDriver",
            "docstring": "L6 Driver for policy graph data operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (conflict detection, graph computation) stay in L5.",
            "methods": [
              "__init__",
              "fetch_active_policies",
              "fetch_all_policies",
              "fetch_active_limits",
              "fetch_all_limits",
              "fetch_resolved_conflicts"
            ],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_proposal_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_proposal_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 201,
        "module_docstring": "Policy Proposal Read Driver (L6)\n\nPure data access layer for policy proposal read operations.\nNo business logic - only query execution and data retrieval.",
        "functions": [
          {
            "name": "get_policy_proposal_read_driver",
            "signature": "(session: AsyncSession) -> PolicyProposalReadDriver",
            "docstring": "Factory function for PolicyProposalReadDriver.",
            "is_async": false,
            "line": 193
          }
        ],
        "classes": [
          {
            "name": "PolicyProposalReadDriver",
            "docstring": "Read operations for policy proposals.",
            "methods": [
              "__init__",
              "fetch_unacknowledged_feedback",
              "fetch_proposal_by_id",
              "fetch_proposal_status",
              "count_versions_for_proposal",
              "fetch_proposals",
              "check_rule_exists",
              "fetch_rule_by_id"
            ],
            "line": 34
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select",
              "text"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.models.feedback",
            "names": [
              "PatternFeedback"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyProposal",
              "PolicyVersion"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyProposalReadDriver",
          "get_policy_proposal_read_driver"
        ]
      },
      {
        "file_name": "policy_proposal_write_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_proposal_write_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 229,
        "module_docstring": "Policy Proposal Write Driver (L6)\n\nPure data access layer for policy proposal write operations.\nNo business logic - only persistence and mutations.",
        "functions": [
          {
            "name": "get_policy_proposal_write_driver",
            "signature": "(session: AsyncSession) -> PolicyProposalWriteDriver",
            "docstring": "Factory function for PolicyProposalWriteDriver.",
            "is_async": false,
            "line": 219
          }
        ],
        "classes": [
          {
            "name": "PolicyProposalWriteDriver",
            "docstring": "Write operations for policy proposals.",
            "methods": [
              "__init__",
              "create_proposal",
              "update_proposal_status",
              "create_version",
              "create_policy_rule",
              "delete_policy_rule"
            ],
            "line": 36
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyProposal",
              "PolicyVersion"
            ],
            "is_relative": false,
            "line": 33
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyProposalWriteDriver",
          "get_policy_proposal_write_driver"
        ]
      },
      {
        "file_name": "policy_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 243,
        "module_docstring": "Policy Read Driver (L6)\n\nPure data access layer for customer policy read operations.\nNo business logic - only query construction and data retrieval.\n\nArchitecture:\n    L3 (Adapter) \u2192 L4 (Engine) \u2192 L6 (this driver) \u2192 Database\n\nOperations:\n- Query tenant settings\n- Query usage totals (ProxyCall sum)\n- Query guardrails\n- No mutations (read-only)\n\nReference: PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_policy_read_driver",
            "signature": "(session: Session) -> PolicyReadDriver",
            "docstring": "Get PolicyReadDriver instance.\n\nArgs:\n    session: SQLModel session\n\nReturns:\n    PolicyReadDriver instance",
            "is_async": false,
            "line": 219
          }
        ],
        "classes": [
          {
            "name": "TenantBudgetDataDTO",
            "docstring": "Raw tenant budget settings from database.",
            "methods": [],
            "line": 68
          },
          {
            "name": "UsageSumDTO",
            "docstring": "Raw usage sum from database.",
            "methods": [],
            "line": 76
          },
          {
            "name": "GuardrailDTO",
            "docstring": "Raw guardrail data from database.",
            "methods": [],
            "line": 82
          },
          {
            "name": "PolicyReadDriver",
            "docstring": "L6 driver for customer policy read operations.\n\nPure data access - no business logic.\nAll methods provide raw database data for L4 engine to process.",
            "methods": [
              "__init__",
              "get_tenant_budget_settings",
              "get_usage_sum_since",
              "get_guardrail_by_id",
              "list_all_guardrails",
              "_to_guardrail_dto"
            ],
            "line": 99
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "DefaultGuardrail",
              "ProxyCall"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.models.tenant",
            "names": [
              "Tenant"
            ],
            "is_relative": false,
            "line": 60
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyReadDriver",
          "get_policy_read_driver",
          "TenantBudgetDataDTO",
          "UsageSumDTO",
          "GuardrailDTO"
        ]
      },
      {
        "file_name": "policy_rules_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_rules_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 117,
        "module_docstring": "Policy Rules Driver\n\nPure data access for policy rules table.\nNo business logic - only DB operations.\n\nAuthority: RULE_PERSISTENCE\nTables: policy_rules, policy_rule_integrity",
        "functions": [
          {
            "name": "get_policy_rules_driver",
            "signature": "(session: AsyncSession) -> PolicyRulesDriver",
            "docstring": "Factory function for PolicyRulesDriver.",
            "is_async": false,
            "line": 115
          }
        ],
        "classes": [
          {
            "name": "PolicyRulesDriver",
            "docstring": "Data access driver for policy rules.\n\nINVARIANTS (L6):\n- No business branching\n- No validation\n- No cross-domain calls\n- Pure persistence operations only",
            "methods": [
              "__init__",
              "fetch_rule_by_id",
              "add_rule",
              "add_integrity",
              "flush"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_rules_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/policy_rules_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 256,
        "module_docstring": "Policy Rules Read Driver (L6)\n\nPure data access layer for policy rules read operations.\nAll SQLAlchemy queries live here. No business logic.",
        "functions": [
          {
            "name": "get_policy_rules_read_driver",
            "signature": "(session: AsyncSession) -> PolicyRulesReadDriver",
            "docstring": "Factory function for PolicyRulesReadDriver.",
            "is_async": false,
            "line": 248
          }
        ],
        "classes": [
          {
            "name": "PolicyRulesReadDriver",
            "docstring": "Read operations for policy rules.",
            "methods": [
              "__init__",
              "fetch_policy_rules",
              "fetch_policy_rule_by_id",
              "count_policy_rules"
            ],
            "line": 39
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "PolicyEnforcement",
              "PolicyRule",
              "PolicyRuleIntegrity"
            ],
            "is_relative": false,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": [
          "PolicyRulesReadDriver",
          "get_policy_rules_read_driver"
        ]
      },
      {
        "file_name": "proposals_read_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/proposals_read_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 205,
        "module_docstring": "Proposals Read Driver (L6)\n\nPure data access layer for policy proposals read operations (list view).\nThis driver is for the \"Proposals\" tab in the policies domain.\n\nNote: This is separate from policy_proposal_read_driver.py which handles\nthe proposal lifecycle engine operations.\n\nAll SQLAlchemy queries live here. No business logic.",
        "functions": [
          {
            "name": "get_proposals_read_driver",
            "signature": "(session: AsyncSession) -> ProposalsReadDriver",
            "docstring": "Factory function for ProposalsReadDriver.",
            "is_async": false,
            "line": 197
          }
        ],
        "classes": [
          {
            "name": "ProposalsReadDriver",
            "docstring": "Read operations for policy proposals (list view).",
            "methods": [
              "__init__",
              "fetch_proposals",
              "fetch_proposal_by_id",
              "count_draft_proposals"
            ],
            "line": 39
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.models.policy",
            "names": [
              "PolicyProposal"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": [
          "ProposalsReadDriver",
          "get_proposals_read_driver"
        ]
      },
      {
        "file_name": "recovery_matcher.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/recovery_matcher.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 953,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "MatchResult",
            "docstring": "Result from matching a failure to a recovery suggestion.",
            "methods": [],
            "line": 80
          },
          {
            "name": "RecoveryMatcher",
            "docstring": "Matches failures to recovery suggestions using pattern matching\nand confidence scoring.\n\nTransaction Boundary: L6 drivers DO NOT commit.\nThe caller (L5 engine or L4 coordinator) owns the transaction.\nThis driver only calls session.add()/session.execute() \u2014 never session.commit().",
            "methods": [
              "__init__",
              "_normalize_error",
              "_calculate_time_weight",
              "_compute_confidence",
              "_generate_suggestion",
              "_find_similar_failures",
              "_count_occurrences",
              "_get_cached_recovery",
              "_set_cached_recovery",
              "_find_similar_by_embedding",
              "_escalate_to_llm",
              "suggest_hybrid",
              "_upsert_candidate",
              "suggest",
              "get_candidates",
              "approve_candidate"
            ],
            "line": 93
          }
        ],
        "imports": [
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "math",
            "names": [
              "math"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.security.sanitize",
            "names": [
              "sanitize_error_message"
            ],
            "is_relative": false,
            "line": 60
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 32
          },
          {
            "name": "RETRY_POLICY",
            "line": 33
          },
          {
            "name": "HALF_LIFE_DAYS",
            "line": 68
          },
          {
            "name": "EMBEDDING_SIMILARITY_THRESHOLD",
            "line": 69
          },
          {
            "name": "LLM_ESCALATION_THRESHOLD",
            "line": 70
          },
          {
            "name": "CACHE_TTL_SECONDS",
            "line": 71
          },
          {
            "name": "LAMBDA",
            "line": 72
          },
          {
            "name": "ALPHA",
            "line": 73
          },
          {
            "name": "MIN_CONFIDENCE_THRESHOLD",
            "line": 74
          },
          {
            "name": "NO_HISTORY_CONFIDENCE",
            "line": 75
          },
          {
            "name": "EXACT_MATCH_CONFIDENCE",
            "line": 76
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "recovery_write_driver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/recovery_write_driver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 265,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "RecoveryWriteService",
            "docstring": "Sync DB write operations for Recovery APIs.\n\nWrite-only facade. No policy logic, no branching beyond DB operations.\nRaw SQL preserved exactly as extracted from API files.",
            "methods": [
              "__init__",
              "upsert_recovery_candidate",
              "get_candidate_by_idempotency_key",
              "enqueue_evaluation_db_fallback",
              "update_recovery_candidate",
              "insert_suggestion_provenance"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 30
          },
          {
            "name": "RETRY_POLICY",
            "line": 31
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "scope_resolver.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/scope_resolver.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 259,
        "module_docstring": "Scope Resolver Engine\n\nResolves which policies apply to a run based on:\n- Tenant ID (always required)\n- Agent ID (for AGENT scope)\n- API Key ID (for API_KEY scope)\n- Human Actor ID (for HUMAN_ACTOR scope)\n\nResolution happens BEFORE run starts and the result is frozen\ninto the policy snapshot for audit purposes.",
        "functions": [
          {
            "name": "get_scope_resolver",
            "signature": "() -> ScopeResolver",
            "docstring": "Get or create ScopeResolver singleton.",
            "is_async": false,
            "line": 254
          }
        ],
        "classes": [
          {
            "name": "RunContext",
            "docstring": "Context for scope resolution.",
            "methods": [],
            "line": 48
          },
          {
            "name": "ScopeResolutionResult",
            "docstring": "Result of scope resolution.",
            "methods": [
              "to_snapshot"
            ],
            "line": 59
          },
          {
            "name": "ScopeResolver",
            "docstring": "Resolves which policies apply to a given run context.\n\nThe resolver evaluates all active policy scopes for a tenant\nand returns the list of policies that match the run context.",
            "methods": [
              "__init__",
              "resolve_applicable_policies",
              "_load_scopes",
              "matches_scope",
              "get_scope_for_policy",
              "_get_scope"
            ],
            "line": 97
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.db",
            "names": [
              "engine"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.models.policy_scope",
            "names": [
              "PolicyScope",
              "ScopeType"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "symbol_table.py",
        "file_path": "backend/app/hoc/cus/policies/L6_drivers/symbol_table.py",
        "layer": "L6_drivers",
        "domain": "policies",
        "lines": 309,
        "module_docstring": "Symbol table for PLang v2.0 compilation.\n\nFeatures:\n- Hierarchical scoping (global, policy, rule, block)\n- Category-aware symbol lookup\n- Governance metadata tracking\n- M19 policy reference resolution",
        "functions": [],
        "classes": [
          {
            "name": "SymbolType",
            "docstring": "Types of symbols in PLang.",
            "methods": [],
            "line": 41
          },
          {
            "name": "Symbol",
            "docstring": "A symbol in the symbol table.\n\nRepresents named entities in PLang: policies, rules, variables, etc.",
            "methods": [
              "__repr__"
            ],
            "line": 54
          },
          {
            "name": "Scope",
            "docstring": "A scope in the symbol table.\n\nScopes form a hierarchy: global -> policy -> rule -> block",
            "methods": [
              "define",
              "lookup",
              "lookup_by_category",
              "get_all_symbols"
            ],
            "line": 79
          },
          {
            "name": "SymbolTable",
            "docstring": "Symbol table for PLang compilation.\n\nManages scopes and symbol resolution with M19 category awareness.",
            "methods": [
              "__init__",
              "_define_builtins",
              "enter_scope",
              "exit_scope",
              "define",
              "lookup",
              "lookup_policy",
              "lookup_rule",
              "get_symbols_by_category",
              "get_policies",
              "get_rules",
              "add_reference",
              "get_unreferenced_symbols",
              "__str__"
            ],
            "line": 131
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum",
              "auto"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.policy.compiler.grammar",
            "names": [
              "PolicyCategory"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 116,
    "violation_count": 42,
    "gap_count": 3
  },
  "controls": {
    "l2_1_facade": null,
    "l2_apis": [],
    "l3_adapters": [
      {
        "file_name": "customer_killswitch_adapter.py",
        "file_path": "backend/app/hoc/cus/controls/L3_adapters/customer_killswitch_adapter.py",
        "layer": "L3_adapters",
        "domain": "controls",
        "lines": 259,
        "module_docstring": "Customer Killswitch Boundary Adapter (L3)\n\nThis adapter sits between L2 (guard.py API) and L4 services.\n\nL2 (Guard API) \u2192 L3 (this adapter) \u2192 L4 (CustomerKillswitchReadService, GuardWriteService)\n\nThe adapter:\n1. Receives API requests with tenant context\n2. Enforces tenant isolation\n3. Delegates to L4 for all operations\n4. Transforms results to customer-safe DTOs\n\nReference: PIN-280 (L2 Promotion Governance), PIN-281 (Claude Task TODO)",
        "functions": [
          {
            "name": "get_customer_killswitch_adapter",
            "signature": "(session: Session) -> CustomerKillswitchAdapter",
            "docstring": "Get a CustomerKillswitchAdapter instance.\n\nArgs:\n    session: Database session (required for write operations)\n\nReturns:\n    CustomerKillswitchAdapter instance",
            "is_async": false,
            "line": 236
          }
        ],
        "classes": [
          {
            "name": "CustomerKillswitchStatus",
            "docstring": "Customer-safe killswitch status.",
            "methods": [],
            "line": 56
          },
          {
            "name": "CustomerKillswitchAction",
            "docstring": "Result of a killswitch action.",
            "methods": [],
            "line": 67
          },
          {
            "name": "CustomerKillswitchAdapter",
            "docstring": "Boundary adapter for customer killswitch operations.\n\nThis class provides the ONLY interface that L2 (guard.py) may use\nto access killswitch functionality. It enforces tenant isolation and\ndelegates to L4 for all operations.\n\nPIN-280 Rule: L3 Is Translation Only + Tenant Scoping",
            "methods": [
              "__init__",
              "_get_read_service",
              "get_status",
              "activate",
              "deactivate"
            ],
            "line": 80
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "TriggerType"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.general.L5_controls.engines.guard_write_engine",
            "names": [
              "GuardWriteService"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.controls.L5_controls.engines.customer_killswitch_read_engine",
            "names": [
              "CustomerKillswitchReadService",
              "get_customer_killswitch_read_service"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": [
          "CustomerKillswitchAdapter",
          "get_customer_killswitch_adapter",
          "CustomerKillswitchStatus",
          "CustomerKillswitchAction"
        ]
      }
    ],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "alert_fatigue.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/alert_fatigue.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 535,
        "module_docstring": "Alert Fatigue Controller\n\nProvides deduplication and fatigue controls for alerts:\n\n1. Same-domain alert deduplication (within configurable window)\n2. Per-domain cooldown periods\n3. Per-tenant fatigue settings\n4. Sliding window rate limiting\n\nDesign Principles:\n1. Alerts are important - but too many alerts = no alerts\n2. Configurable per-tenant and per-domain\n3. Feature flag controlled for safe rollout\n4. Redis-backed for distributed deployment (optional)\n\nUsage:\n    from app.services.alert_fatigue import get_alert_fatigue_controller\n\n    controller = get_alert_fatigue_controller()\n\n    # Check if alert should be sent\n    if controller.should_send_alert(\n        alert_key=\"incidents:high_failure_rate\",\n        tenant_id=\"tenant-123\",\n        domain=\"incidents\",\n    ):\n        # Send the alert\n        ...\n\n    # Record that alert was sent\n    controller.record_alert_sent(\n        alert_key=\"incidents:high_failure_rate\",\n        tenant_id=\"tenant-123\",\n        domain=\"incidents\",\n    )",
        "functions": [
          {
            "name": "get_alert_fatigue_controller",
            "signature": "(redis_client = None) -> AlertFatigueController",
            "docstring": "Get or create AlertFatigueController singleton.\n\nArgs:\n    redis_client: Optional Redis client (only used on first call)\n\nReturns:\n    AlertFatigueController instance",
            "is_async": false,
            "line": 516
          },
          {
            "name": "reset_alert_fatigue_controller",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 532
          }
        ],
        "classes": [
          {
            "name": "AlertSuppressReason",
            "docstring": "Reason why an alert was suppressed.",
            "methods": [],
            "line": 97
          },
          {
            "name": "AlertRecord",
            "docstring": "Record of a sent alert for deduplication tracking.",
            "methods": [
              "__post_init__",
              "age"
            ],
            "line": 109
          },
          {
            "name": "TenantFatigueSettings",
            "docstring": "Per-tenant fatigue settings.",
            "methods": [
              "get_domain_cooldown"
            ],
            "line": 131
          },
          {
            "name": "AlertCheckResult",
            "docstring": "Result of checking whether an alert should be sent.",
            "methods": [
              "to_dict"
            ],
            "line": 148
          },
          {
            "name": "AlertFatigueController",
            "docstring": "Controls alert deduplication and fatigue.\n\nPer PIN-454 Section 3.3, this provides:\n- Same-domain alert deduplication\n- Configurable cooldowns per domain\n- Per-tenant fatigue settings\n- Sliding window rate limiting\n\nLayer: L4 (Domain Engine)",
            "methods": [
              "__init__",
              "check_alert",
              "should_send_alert",
              "record_alert_sent",
              "set_tenant_settings",
              "get_tenant_stats",
              "_get_tenant_settings",
              "_check_deduplication",
              "_check_domain_cooldown",
              "_check_tenant_rate_limit",
              "_cleanup_old_records"
            ],
            "line": 168
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "threading",
            "names": [
              "Lock"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "FrozenSet",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 65
          }
        ],
        "constants": [
          {
            "name": "ALERT_FATIGUE_ENABLED",
            "line": 74
          },
          {
            "name": "DEFAULT_DOMAIN_COOLDOWNS",
            "line": 77
          },
          {
            "name": "DEDUP_WINDOW_SECONDS",
            "line": 87
          },
          {
            "name": "MAX_ALERTS_PER_TENANT_PER_HOUR",
            "line": 90
          },
          {
            "name": "REDIS_KEY_PREFIX",
            "line": 93
          },
          {
            "name": "REDIS_TTL_SECONDS",
            "line": 94
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "budget_enforcement_engine.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/budget_enforcement_engine.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 341,
        "module_docstring": "Domain engine for budget enforcement decisions.\n\nThis L4 engine contains the authoritative logic for:\n1. Identifying runs halted due to budget enforcement\n2. Emitting budget_enforcement decision records\n\nL5 workers must halt runs when budget is exhausted but must NOT\nemit decision records directly. Decision emission is L4 responsibility.\n\nReference: PIN-257 Phase R-3\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md",
        "functions": [
          {
            "name": "emit_budget_halt_decision",
            "signature": "(run_id: str, budget_limit_cents: int, budget_consumed_cents: int, step_cost_cents: int, completed_steps: int, total_steps: int, tenant_id: str = 'default') -> bool",
            "docstring": "Convenience function to emit a budget enforcement decision.\n\nThis is the L4 entry point for budget enforcement decision emission.\nIt should be called by L4 orchestration code (e.g., background tasks,\nevent handlers) when a run is halted due to budget enforcement.\n\nArgs:\n    run_id: ID of the halted run\n    budget_limit_cents: Budget limit in cents\n    budget_consumed_cents: Total consumed including this run\n    step_cost_cents: Cost of the last step before halt\n    completed_steps: Number of steps completed before halt\n    total_steps: Total steps in the plan\n    tenant_id: Tenant ID\n\nReturns:\n    True if decision was emitted, False if skipped or failed\n\nReference: PIN-257 Phase R-3",
            "is_async": false,
            "line": 274
          },
          {
            "name": "process_pending_budget_decisions",
            "signature": "() -> int",
            "docstring": "Process all pending budget halt decisions.\n\nThis function is intended to be called by a background task at startup\nor periodically to ensure all budget halts have corresponding decision\nrecords.\n\nReturns:\n    Number of decision records emitted\n\nReference: PIN-257 Phase R-3",
            "is_async": true,
            "line": 316
          }
        ],
        "classes": [
          {
            "name": "BudgetEnforcementEngine",
            "docstring": "L4 Domain Engine for budget enforcement decisions.\n\nThis engine contains the decision emission logic that was previously\nin L5 runner.py. It processes halted runs and emits budget_enforcement\ndecision records.\n\nL5 may NOT:\n- Import app.contracts.decisions\n- Emit decision records directly\n- Call emit_budget_enforcement_decision()\n\nL5 may ONLY:\n- Check budget and halt execution when exhausted\n- Update run status to \"halted\"\n- Publish run.halted events\n- Store halt information in provenance\n\nReference: PIN-257 Phase R-3\nGovernance: PHASE_R_L5_L4_VIOLATIONS.md Section 3.2",
            "methods": [
              "__init__",
              "emit_decision_for_halt",
              "process_pending_halts",
              "_parse_budget_from_error"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.contracts.decisions",
            "names": [
              "emit_budget_enforcement_decision"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.controls.L6_drivers.budget_enforcement_driver",
            "names": [
              "BudgetEnforcementDriver",
              "get_budget_enforcement_driver"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": [
          "BudgetEnforcementEngine",
          "emit_budget_halt_decision",
          "process_pending_budget_decisions"
        ]
      },
      {
        "file_name": "cb_sync_wrapper.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/cb_sync_wrapper.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 169,
        "module_docstring": "Thread-safe sync wrapper for async circuit breaker functions.\n\nThis module provides sync-compatible wrappers that safely execute\nasync circuit breaker functions from sync contexts, including when\nan event loop is already running.\n\nWhy this exists:\n- The async circuit breaker functions use asyncpg which requires an event loop\n- Some callers may be sync (e.g., middleware, legacy code)\n- Calling asyncio.run() from a running event loop raises RuntimeError\n- The naive workaround of returning True (disabled) is too conservative\n  and causes false-positive V2 disables\n\nUsage:\n    from app.costsim.cb_sync_wrapper import is_v2_disabled_sync, get_state_sync\n\n    # Safe from any context (sync or async)\n    if is_v2_disabled_sync():\n        return use_v1_only()",
        "functions": [
          {
            "name": "_get_executor",
            "signature": "() -> concurrent.futures.ThreadPoolExecutor",
            "docstring": "Get or create the shared thread pool executor.",
            "is_async": false,
            "line": 54
          },
          {
            "name": "_run_async_in_thread",
            "signature": "(coro, timeout: float = 5.0)",
            "docstring": "Run an async coroutine in a separate thread with its own event loop.\n\nThis is safe to call from any context, including:\n- Sync functions with no event loop\n- Sync functions called from within an async context\n- The main thread of an async application\n\nArgs:\n    coro: The coroutine to run\n    timeout: Maximum time to wait for result\n\nReturns:\n    The result of the coroutine\n\nRaises:\n    TimeoutError: If the operation times out\n    Exception: Any exception raised by the coroutine",
            "is_async": false,
            "line": 62
          },
          {
            "name": "is_v2_disabled_sync",
            "signature": "(timeout: float = 5.0) -> bool",
            "docstring": "Sync wrapper for is_v2_disabled().\n\nSafe to call from any context. Runs the async function in a\nseparate thread with its own event loop.\n\nArgs:\n    timeout: Maximum time to wait for DB query\n\nReturns:\n    True if V2 is disabled, False otherwise\n\nNote:\n    On error, returns False (V2 enabled) to avoid false-positive\n    disables. This is the opposite of the previous conservative\n    approach which returned True on error.",
            "is_async": false,
            "line": 96
          },
          {
            "name": "get_state_sync",
            "signature": "(timeout: float = 5.0)",
            "docstring": "Sync wrapper for get_state().\n\nSafe to call from any context.\n\nArgs:\n    timeout: Maximum time to wait for DB query\n\nReturns:\n    CircuitBreakerState or None on error",
            "is_async": false,
            "line": 135
          },
          {
            "name": "shutdown_executor",
            "signature": "()",
            "docstring": "Shutdown the thread pool executor gracefully.",
            "is_async": false,
            "line": 164
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "concurrent.futures",
            "names": [
              "concurrent.futures"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "controls_facade.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/controls_facade.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 438,
        "module_docstring": "Controls Facade (L4 Domain Logic)\n\nThis facade provides the external interface for control operations.\nAll control APIs MUST use this facade instead of directly importing\ninternal control modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes killswitch and control logic\n- Provides unified access to system controls\n- Single point for audit emission\n\nL2 API Routes (GAP-123):\n- GET /api/v1/controls (list controls)\n- GET /api/v1/controls/{id} (get control)\n- PUT /api/v1/controls/{id} (update control)\n- POST /api/v1/controls/{id}/enable (enable control)\n- POST /api/v1/controls/{id}/disable (disable control)\n- GET /api/v1/controls/status (overall status)\n\nUsage:\n    from app.services.controls.facade import get_controls_facade\n\n    facade = get_controls_facade()\n\n    # Get control status\n    status = await facade.get_status(tenant_id=\"...\")",
        "functions": [
          {
            "name": "get_controls_facade",
            "signature": "() -> ControlsFacade",
            "docstring": "Get the controls facade instance.\n\nThis is the recommended way to access control operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    ControlsFacade instance",
            "is_async": false,
            "line": 425
          }
        ],
        "classes": [
          {
            "name": "ControlType",
            "docstring": "Types of controls.",
            "methods": [],
            "line": 60
          },
          {
            "name": "ControlState",
            "docstring": "Control state.",
            "methods": [],
            "line": 69
          },
          {
            "name": "ControlConfig",
            "docstring": "Control configuration.",
            "methods": [
              "to_dict"
            ],
            "line": 77
          },
          {
            "name": "ControlStatusSummary",
            "docstring": "Overall control status summary.",
            "methods": [
              "to_dict"
            ],
            "line": 115
          },
          {
            "name": "ControlsFacade",
            "docstring": "Facade for control operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ncontrol services.\n\nLayer: L4 (Domain Logic)\nCallers: controls.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "_ensure_default_controls",
              "list_controls",
              "get_control",
              "update_control",
              "enable_control",
              "disable_control",
              "get_status"
            ],
            "line": 140
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 55
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cost_safety_rails.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/cost_safety_rails.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 402,
        "module_docstring": "M27 Cost Safety Rails\n=====================\n\nPer-tenant auto-apply caps and blast-radius limits.\n\nTHE INVARIANT:\n    No automatic cost action may exceed:\n    - Per-tenant daily cap\n    - Per-org daily cap\n    - Blast-radius scope limits\n\nGPT Analysis Warning (2025-12-23):\n    \"Confidence >=90% can auto-apply, Zero confirmations required in some paths.\n     Once customers are live, you'll need:\n     - Per-tenant auto-apply caps\n     - Blast-radius limits (per org/day)\"",
        "functions": [
          {
            "name": "get_safety_rails",
            "signature": "(config: SafetyConfig | None = None) -> CostSafetyRails",
            "docstring": "Get or create default safety rails instance.",
            "is_async": false,
            "line": 397
          }
        ],
        "classes": [
          {
            "name": "SafetyConfig",
            "docstring": "M27 Safety Configuration.\n\nThese limits prevent runaway automation.",
            "methods": [
              "production",
              "testing"
            ],
            "line": 57
          },
          {
            "name": "CostSafetyRails",
            "docstring": "Enforces M27 safety limits.\n\nTracks auto-applied actions per tenant and enforces caps.",
            "methods": [
              "__init__",
              "can_auto_apply_policy",
              "can_auto_apply_recovery",
              "can_auto_apply_routing",
              "record_action",
              "_get_action_count",
              "get_status"
            ],
            "line": 119
          },
          {
            "name": "SafeCostLoopOrchestrator",
            "docstring": "Wraps CostLoopOrchestrator with safety rails.\n\nMANDATORY GOVERNANCE: Incident creation requires db_session.\nUse this in production instead of raw CostLoopOrchestrator.",
            "methods": [
              "__init__",
              "process_anomaly_safe"
            ],
            "line": 307
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "decisions.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/decisions.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 221,
        "module_docstring": "Phase-7 Abuse Protection \u2014 Decision Types\n\nPIN-399 Phase-7: Abuse protection constrains behavior, not identity.\n\nDESIGN INVARIANTS (LOCKED):\n- ABUSE-001: Protection does not affect onboarding, roles, or billing state\n- ABUSE-002: All enforcement outcomes are explicit (no silent failure)\n- ABUSE-003: Anomaly detection never blocks user traffic\n- ABUSE-004: Protection providers are swappable behind a fixed interface\n- ABUSE-005: Mock provider must be behavior-compatible with real provider\n\nDECISION OUTCOMES (Finite, Locked):\n- ALLOW: Proceed\n- THROTTLE: Delay / slow\n- REJECT: Hard stop\n- WARN: Allow + emit signal\n\nNo silent drops. No implicit retries.",
        "functions": [
          {
            "name": "allow",
            "signature": "() -> ProtectionResult",
            "docstring": "Create an ALLOW result.",
            "is_async": false,
            "line": 161
          },
          {
            "name": "reject_rate_limit",
            "signature": "(dimension: str, retry_after_ms: int, message: Optional[str] = None) -> ProtectionResult",
            "docstring": "Create a REJECT result for rate limiting.",
            "is_async": false,
            "line": 166
          },
          {
            "name": "reject_cost_limit",
            "signature": "(current_value: float, allowed_value: float, message: Optional[str] = None) -> ProtectionResult",
            "docstring": "Create a REJECT result for cost limit.",
            "is_async": false,
            "line": 178
          },
          {
            "name": "throttle",
            "signature": "(dimension: str, retry_after_ms: int, message: Optional[str] = None) -> ProtectionResult",
            "docstring": "Create a THROTTLE result.",
            "is_async": false,
            "line": 191
          },
          {
            "name": "warn",
            "signature": "(dimension: str, message: Optional[str] = None) -> ProtectionResult",
            "docstring": "Create a WARN result (non-blocking).",
            "is_async": false,
            "line": 203
          }
        ],
        "classes": [
          {
            "name": "Decision",
            "docstring": "Phase-7 Protection Decisions (Finite, Locked).\n\nEvery protection check returns exactly one of these.\n\nSEMANTICS (LOCKED):\n- ALLOW: Proceed normally\n- THROTTLE: Proceed with delay\n- REJECT: Hard stop, return error\n- WARN: Proceed + emit signal (non-blocking)",
            "methods": [
              "blocks_request",
              "is_warning_only"
            ],
            "line": 45
          },
          {
            "name": "ProtectionResult",
            "docstring": "Result of a protection check.\n\nAttributes:\n    decision: The enforcement decision (ALLOW, THROTTLE, REJECT, WARN)\n    dimension: Which protection dimension triggered (rate, burst, cost)\n    retry_after_ms: Milliseconds to wait before retry (for THROTTLE/REJECT)\n    current_value: Current usage value that triggered the check\n    allowed_value: The limit that was exceeded\n    message: Human-readable explanation",
            "methods": [
              "to_error_response"
            ],
            "line": 73
          },
          {
            "name": "AnomalySignal",
            "docstring": "Anomaly detection signal (non-blocking per ABUSE-003).\n\nAnomaly signals are warnings only, never user-blocking.\n\nAttributes:\n    baseline: Expected baseline value\n    observed: Observed value\n    window: Time window (e.g., \"5m\", \"1h\")\n    severity: Severity level (low, medium, high)",
            "methods": [
              "to_signal_response"
            ],
            "line": 124
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "Decision",
          "ProtectionResult",
          "AnomalySignal",
          "allow",
          "reject_rate_limit",
          "reject_cost_limit",
          "throttle",
          "warn"
        ]
      },
      {
        "file_name": "killswitch.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/killswitch.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 262,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_killswitch",
            "signature": "() -> KillSwitch",
            "docstring": "Get the global kill-switch instance.",
            "is_async": false,
            "line": 249
          },
          {
            "name": "reset_killswitch_for_testing",
            "signature": "() -> None",
            "docstring": "Reset kill-switch state. FOR TESTING ONLY.",
            "is_async": false,
            "line": 258
          }
        ],
        "classes": [
          {
            "name": "KillSwitchState",
            "docstring": "Global kill-switch state. Exactly two values. No partial states.",
            "methods": [],
            "line": 43
          },
          {
            "name": "KillSwitchTrigger",
            "docstring": "What triggered the kill-switch.",
            "methods": [],
            "line": 50
          },
          {
            "name": "RollbackStatus",
            "docstring": "Status of rollback operation.",
            "methods": [],
            "line": 58
          },
          {
            "name": "KillSwitchEvent",
            "docstring": "Immutable audit record for kill-switch events.\n\nRequired by C3_KILLSWITCH_ROLLBACK_MODEL.md section 8.",
            "methods": [],
            "line": 67
          },
          {
            "name": "KillSwitch",
            "docstring": "Global, authoritative kill-switch for C3 optimization.\n\nProperties:\n- Global: Disables ALL envelopes (no per-envelope switches)\n- Immediate: No grace period, no batching, no retries\n- Independent: Does not require predictions or redeploy\n- Auditable: Every activation emits an audit record\n\nThread-safe implementation.",
            "methods": [
              "__init__",
              "state",
              "is_enabled",
              "is_disabled",
              "activate",
              "mark_rollback_complete",
              "rearm",
              "on_activate",
              "get_events",
              "get_last_event"
            ],
            "line": 83
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "threading",
            "names": [
              "threading"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Callable",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "s2_cost_smoothing.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/s2_cost_smoothing.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 220,
        "module_docstring": null,
        "functions": [
          {
            "name": "create_s2_envelope",
            "signature": "(baseline_value: float = 10.0, reference_id: str = 'scheduler_v2') -> Envelope",
            "docstring": "Create a fresh S2 envelope instance with specified baseline.\n\nArgs:\n    baseline_value: The baseline max_concurrent_jobs value\n    reference_id: Version/hash of the baseline config\n\nReturns:\n    New Envelope instance ready for validation",
            "is_async": false,
            "line": 104
          },
          {
            "name": "validate_s2_envelope",
            "signature": "(envelope: Envelope) -> None",
            "docstring": "Validate S2-specific rules (additive to V1-V5).\n\nS2 Rules:\n- S2-V1: Increase forbidden (max_increase = 0)\n- S2-V2: Absolute floor required (value >= 1)\n- S2-V3: Timebox \u2264 15 minutes\n- S2-V4: Confidence \u2265 0.75\n- S2-V5: Baseline must be concurrency-safe (>= absolute floor)\n\nRaises:\n    EnvelopeValidationError: If S2 validation fails",
            "is_async": false,
            "line": 156
          },
          {
            "name": "calculate_s2_bounded_value",
            "signature": "(baseline: float, max_decrease_pct: float, prediction_confidence: float) -> float",
            "docstring": "Calculate the bounded value for S2 (decrease only).\n\nS2 can only DECREASE concurrency, never increase.\nResult is floored at S2_ABSOLUTE_FLOOR.\n\nArgs:\n    baseline: The baseline max_concurrent_jobs value\n    max_decrease_pct: Maximum decrease percentage (e.g., 10.0 for -10%)\n    prediction_confidence: The prediction confidence (0.0-1.0)\n\nReturns:\n    The bounded decreased value (never below S2_ABSOLUTE_FLOOR)",
            "is_async": false,
            "line": 191
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "app.optimization.envelope",
            "names": [
              "BaselineSource",
              "DeltaType",
              "Envelope",
              "EnvelopeBaseline",
              "EnvelopeBounds",
              "EnvelopeClass",
              "EnvelopeScope",
              "EnvelopeTimebox",
              "EnvelopeTrigger",
              "EnvelopeValidationError",
              "RevertReason"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [
          {
            "name": "S2_COST_SMOOTHING_ENVELOPE",
            "line": 54
          },
          {
            "name": "S2_ABSOLUTE_FLOOR",
            "line": 101
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "threshold_engine.py",
        "file_path": "backend/app/hoc/cus/controls/L5_engines/threshold_engine.py",
        "layer": "L5_engines",
        "domain": "controls",
        "lines": 708,
        "module_docstring": "Threshold Decision Engine (L5)\n\nProvides:\n- ThresholdParams: Validated threshold configuration (decision contract)\n- LLMRunThresholdResolver: Resolves effective params using precedence rules\n- LLMRunEvaluator: Evaluates runs against thresholds, determines signals\n- Signal helpers: Create and collect threshold signal records\n\nThis engine owns the DECISION logic:\n- Precedence rules (AGENT > PROJECT > TENANT > GLOBAL)\n- Threshold evaluation (compare metrics to limits)\n- Signal determination (which signals to emit)\n\nThe engine does NOT own:\n- Database queries (delegated to ThresholdDriver in L6)\n- Signal persistence (delegated to L6)\n\nReference: ACTIVITY_PHASE2.5_IMPLEMENTATION_PLAN.md",
        "functions": [
          {
            "name": "create_threshold_signal_record",
            "signature": "(tenant_id: str, run_id: str, state: str, signal: ThresholdSignal, params_used: dict) -> ThresholdSignalRecord",
            "docstring": "Create a threshold signal record for activity domain.\n\nThis creates a record that surfaces in:\n- Activity \u2192 LLM Runs \u2192 Live \u2192 Signals\n- Activity \u2192 LLM Runs \u2192 Completed \u2192 Signals\n\nArgs:\n    tenant_id: Tenant identifier\n    run_id: Run identifier\n    state: Run state (live or completed)\n    signal: The threshold signal triggered\n    params_used: The params that were evaluated against\n\nReturns:\n    ThresholdSignalRecord for persistence/emission",
            "is_async": false,
            "line": 638
          },
          {
            "name": "collect_signals_from_evaluation",
            "signature": "(evaluation: ThresholdEvaluationResult, tenant_id: str, state: str) -> list[ThresholdSignalRecord]",
            "docstring": "Collect all signals from an evaluation result into records.\n\nArgs:\n    evaluation: The evaluation result\n    tenant_id: Tenant identifier\n    state: Run state (live or completed)\n\nReturns:\n    List of ThresholdSignalRecord for persistence",
            "is_async": false,
            "line": 681
          }
        ],
        "classes": [
          {
            "name": "ThresholdParams",
            "docstring": "Validated threshold parameters for LLM run governance.\n\nValidation Rules (Hard Stop):\n- max_execution_time_ms: 1000-300000 (1s to 5min)\n- max_tokens: 256-200000\n- max_cost_usd: 0.01-100.00\n- failure_signal: boolean\n\nNo partial garbage. No unknown keys. No absurd values.",
            "methods": [
              "coerce_decimal_to_float"
            ],
            "line": 85
          },
          {
            "name": "ThresholdParamsUpdate",
            "docstring": "Partial update for threshold params.\nAll fields optional - only provided fields are updated.",
            "methods": [],
            "line": 132
          },
          {
            "name": "ThresholdSignal",
            "docstring": "Signals emitted when runs breach thresholds.\nThese appear in Activity \u2192 LLM Runs \u2192 Signal panels.",
            "methods": [],
            "line": 153
          },
          {
            "name": "ThresholdEvaluationResult",
            "docstring": "Result of threshold evaluation.",
            "methods": [],
            "line": 166
          },
          {
            "name": "ThresholdDriverProtocol",
            "docstring": "Protocol defining the interface for threshold drivers.",
            "methods": [
              "get_active_threshold_limits"
            ],
            "line": 180
          },
          {
            "name": "ThresholdDriverSyncProtocol",
            "docstring": "Protocol defining the interface for sync threshold drivers.",
            "methods": [
              "get_active_threshold_limits"
            ],
            "line": 190
          },
          {
            "name": "LLMRunThresholdResolver",
            "docstring": "Resolves effective threshold params for an LLM run\nusing Policy \u2192 Limit \u2192 Threshold precedence.\n\nResolution order (highest to lowest precedence):\n1. Agent-scoped threshold (scope=AGENT, scope_id=agent_id)\n2. Project-scoped threshold (scope=PROJECT, scope_id=project_id)\n3. Tenant-scoped threshold (scope=TENANT)\n4. Global defaults (DEFAULT_LLM_RUN_PARAMS)\n\nProperties:\n- Deterministic\n- Merge-based (higher precedence overrides)\n- Safe if nothing exists\n\nL4 CONTRACT: This class contains ONLY precedence logic.\nDB queries are delegated to the ThresholdDriver (L6).",
            "methods": [
              "__init__",
              "resolve"
            ],
            "line": 205
          },
          {
            "name": "LLMRunEvaluator",
            "docstring": "Evaluates LLM runs against threshold params.\n\nSupports:\n- Live run evaluation (execution time, tokens)\n- Completed run evaluation (all metrics + failure)\n\nSignals are determined but evaluation is non-blocking.\n\nL4 CONTRACT: Pure evaluation logic, no DB operations.",
            "methods": [
              "__init__",
              "evaluate_live_run",
              "evaluate_completed_run"
            ],
            "line": 305
          },
          {
            "name": "LLMRunThresholdResolverSync",
            "docstring": "Sync version of LLMRunThresholdResolver for worker context.\n\nUses ThresholdDriverSync for DB access since the worker runs\nin a ThreadPoolExecutor which doesn't support async.\n\nL4 CONTRACT: Same precedence logic as async version.",
            "methods": [
              "__init__",
              "resolve"
            ],
            "line": 465
          },
          {
            "name": "LLMRunEvaluatorSync",
            "docstring": "Sync version of LLMRunEvaluator for worker context.\n\nUses LLMRunThresholdResolverSync instead of the async resolver.\n\nL4 CONTRACT: Pure evaluation logic, no DB operations.",
            "methods": [
              "__init__",
              "evaluate_completed_run"
            ],
            "line": 541
          },
          {
            "name": "ThresholdSignalRecord",
            "docstring": "Record of a threshold signal for activity domain.\n\nThis structure is used for:\n- Activity \u2192 LLM Runs \u2192 Live \u2192 Signals\n- Activity \u2192 LLM Runs \u2192 Completed \u2192 Signals",
            "methods": [],
            "line": 621
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional",
              "Protocol"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_LLM_RUN_PARAMS",
            "line": 72
          }
        ],
        "all_exports": null
      }
    ],
    "l5_schemas": [
      {
        "file_name": "overrides.py",
        "file_path": "backend/app/hoc/cus/controls/L5_schemas/overrides.py",
        "layer": "L5_schemas",
        "domain": "controls",
        "lines": 187,
        "module_docstring": "Limit Override Schemas (PIN-LIM-05)\n\nRequest and response models for temporary limit increases.\nOverrides allow customers to request and apply temporary limit increases\nwith proper audit trail.",
        "functions": [],
        "classes": [
          {
            "name": "OverrideStatus",
            "docstring": "Override lifecycle status.",
            "methods": [],
            "line": 28
          },
          {
            "name": "LimitOverrideRequest",
            "docstring": "Request model for requesting a temporary limit override.",
            "methods": [
              "validate_override_value"
            ],
            "line": 38
          },
          {
            "name": "LimitOverrideResponse",
            "docstring": "Response model for limit override operations.",
            "methods": [],
            "line": 80
          },
          {
            "name": "OverrideApprovalRequest",
            "docstring": "Request model for approving/rejecting an override.",
            "methods": [
              "validate_rejection_reason"
            ],
            "line": 145
          },
          {
            "name": "OverrideListResponse",
            "docstring": "Response model for listing overrides.",
            "methods": [],
            "line": 175
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 25
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_limits.py",
        "file_path": "backend/app/hoc/cus/controls/L5_schemas/policy_limits.py",
        "layer": "L5_schemas",
        "domain": "controls",
        "lines": 189,
        "module_docstring": "Policy Limits Schemas (PIN-LIM-01)\n\nRequest and response models for policy limit CRUD operations.\nEnforces schema contract between API and service layer.",
        "functions": [],
        "classes": [
          {
            "name": "LimitCategoryEnum",
            "docstring": "Limit categories.",
            "methods": [],
            "line": 27
          },
          {
            "name": "LimitScopeEnum",
            "docstring": "Limit scope levels.",
            "methods": [],
            "line": 34
          },
          {
            "name": "LimitEnforcementEnum",
            "docstring": "Limit enforcement behaviors.",
            "methods": [],
            "line": 43
          },
          {
            "name": "ResetPeriodEnum",
            "docstring": "Budget limit reset periods.",
            "methods": [],
            "line": 53
          },
          {
            "name": "CreatePolicyLimitRequest",
            "docstring": "Request model for creating a policy limit.",
            "methods": [
              "validate_reset_period",
              "validate_window_seconds"
            ],
            "line": 61
          },
          {
            "name": "UpdatePolicyLimitRequest",
            "docstring": "Request model for updating a policy limit.",
            "methods": [],
            "line": 130
          },
          {
            "name": "PolicyLimitResponse",
            "docstring": "Response model for policy limit operations.",
            "methods": [],
            "line": 169
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "simulation.py",
        "file_path": "backend/app/hoc/cus/controls/L5_schemas/simulation.py",
        "layer": "L5_schemas",
        "domain": "controls",
        "lines": 216,
        "module_docstring": "Limit Simulation Schemas (PIN-LIM-04)\n\nRequest and response models for pre-execution limit checks.\nThe simulation endpoint allows dry-run verification against all limits\nbefore actually executing a run.",
        "functions": [],
        "classes": [
          {
            "name": "SimulationDecision",
            "docstring": "Simulation outcome decision.",
            "methods": [],
            "line": 27
          },
          {
            "name": "MessageCode",
            "docstring": "Standardized message codes (no free-text messages).",
            "methods": [],
            "line": 34
          },
          {
            "name": "LimitSimulationRequest",
            "docstring": "Request model for limit simulation (pre-execution check).",
            "methods": [],
            "line": 59
          },
          {
            "name": "LimitCheckResult",
            "docstring": "Result of a single limit check.",
            "methods": [],
            "line": 107
          },
          {
            "name": "HeadroomInfo",
            "docstring": "Remaining headroom before hitting limits.",
            "methods": [],
            "line": 140
          },
          {
            "name": "LimitWarning",
            "docstring": "Warning for soft limit approaching.",
            "methods": [],
            "line": 157
          },
          {
            "name": "LimitSimulationResponse",
            "docstring": "Response model for limit simulation.",
            "methods": [],
            "line": 175
          }
        ],
        "imports": [
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_other": [
      {
        "file_name": "killswitch_read_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L5_controls/drivers/killswitch_read_driver.py",
        "layer": "L5_other",
        "domain": "controls",
        "lines": 229,
        "module_docstring": "Killswitch Read Driver (L6)\n\nPure data access layer for killswitch read operations.\nNo business logic - only query construction and data retrieval.\n\nArchitecture:\n    L3 (Adapter) \u2192 L4 (Engine) \u2192 L6 (this driver) \u2192 Database\n\nOperations:\n- Query killswitch state for tenant\n- Query active guardrails\n- Query incident statistics\n- No mutations (read-only)\n\nReference: PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_killswitch_read_driver",
            "signature": "(session: Optional[Session] = None) -> KillswitchReadDriver",
            "docstring": "Get KillswitchReadDriver instance.\n\nArgs:\n    session: Optional SQLModel session. If not provided, creates one internally.\n\nReturns:\n    KillswitchReadDriver instance",
            "is_async": false,
            "line": 204
          }
        ],
        "classes": [
          {
            "name": "KillswitchStateDTO",
            "docstring": "Killswitch state information.",
            "methods": [],
            "line": 52
          },
          {
            "name": "GuardrailInfoDTO",
            "docstring": "Active guardrail information.",
            "methods": [],
            "line": 60
          },
          {
            "name": "IncidentStatsDTO",
            "docstring": "Incident statistics for a tenant.",
            "methods": [],
            "line": 66
          },
          {
            "name": "KillswitchStatusDTO",
            "docstring": "Complete killswitch status information.",
            "methods": [],
            "line": 73
          },
          {
            "name": "KillswitchReadDriver",
            "docstring": "L6 driver for killswitch read operations.\n\nPure data access - no business logic.\nAll methods require tenant_id for isolation.",
            "methods": [
              "__init__",
              "_get_session",
              "get_killswitch_status",
              "_get_killswitch_state",
              "_get_active_guardrails",
              "_get_incident_stats"
            ],
            "line": 86
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.db",
            "names": [
              "get_session"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "DefaultGuardrail",
              "Incident",
              "KillSwitchState"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": [
          "KillswitchReadDriver",
          "get_killswitch_read_driver",
          "KillswitchStateDTO",
          "GuardrailInfoDTO",
          "IncidentStatsDTO",
          "KillswitchStatusDTO"
        ]
      },
      {
        "file_name": "customer_killswitch_read_engine.py",
        "file_path": "backend/app/hoc/cus/controls/L5_controls/engines/customer_killswitch_read_engine.py",
        "layer": "L5_other",
        "domain": "controls",
        "lines": 179,
        "module_docstring": "Customer Killswitch Read Service (L4)\n\nThis service provides read operations for customer killswitch status.\nIt delegates to KillswitchReadDriver (L6) for all database access.\n\nL3 (customer_killswitch_adapter.py) \u2192 L4 (this service) \u2192 L6 (KillswitchReadDriver)\n\nResponsibilities:\n- Delegate to L6 driver for data access\n- Apply business rules (if any)\n- Maintain backward compatibility for callers\n\nReference: PIN-280, PIN-281, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_customer_killswitch_read_service",
            "signature": "() -> CustomerKillswitchReadService",
            "docstring": "Get the singleton CustomerKillswitchReadService instance.\n\nThis is the ONLY way L3 should obtain a killswitch read service.\nDirect instantiation is discouraged.\n\nReturns:\n    CustomerKillswitchReadService singleton instance",
            "is_async": false,
            "line": 151
          }
        ],
        "classes": [
          {
            "name": "KillswitchState",
            "docstring": "Killswitch state information.",
            "methods": [],
            "line": 58
          },
          {
            "name": "GuardrailInfo",
            "docstring": "Active guardrail information.",
            "methods": [],
            "line": 66
          },
          {
            "name": "IncidentStats",
            "docstring": "Incident statistics for a tenant.",
            "methods": [],
            "line": 72
          },
          {
            "name": "KillswitchStatusInfo",
            "docstring": "Complete killswitch status information.",
            "methods": [],
            "line": 79
          },
          {
            "name": "CustomerKillswitchReadService",
            "docstring": "Read operations for customer killswitch status.\n\nDelegates all database operations to KillswitchReadDriver (L6).\nMaintains backward compatibility for existing callers.\n\nINVARIANT: All methods require tenant_id for isolation.\nINVARIANT: Read-only - no mutations.\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "get_killswitch_status"
            ],
            "line": 92
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.policies.controls.drivers.killswitch_read_driver",
            "names": [
              "KillswitchReadDriver",
              "get_killswitch_read_driver"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": [
          "CustomerKillswitchReadService",
          "get_customer_killswitch_read_service",
          "KillswitchState",
          "GuardrailInfo",
          "IncidentStats",
          "KillswitchStatusInfo"
        ]
      }
    ],
    "l6_drivers": [
      {
        "file_name": "budget_enforcement_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/budget_enforcement_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 124,
        "module_docstring": "Budget Enforcement Driver (L6 Data Access)\n\nHandles database operations for budget enforcement:\n- Fetching halted runs that lack decision records\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_budget_enforcement_driver",
            "signature": "(db_url: Optional[str] = None) -> BudgetEnforcementDriver",
            "docstring": "Get a BudgetEnforcementDriver instance.",
            "is_async": false,
            "line": 122
          }
        ],
        "classes": [
          {
            "name": "BudgetEnforcementDriver",
            "docstring": "L6 Driver for budget enforcement data operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (parsing, emit logic) stay in L4.",
            "methods": [
              "__init__",
              "_get_engine",
              "fetch_pending_budget_halts",
              "dispose"
            ],
            "line": 45
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlalchemy",
            "names": [
              "create_engine",
              "text"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "circuit_breaker.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/circuit_breaker.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 983,
        "module_docstring": null,
        "functions": [
          {
            "name": "create_circuit_breaker",
            "signature": "(session: Session, failure_threshold: Optional[int] = None, drift_threshold: Optional[float] = None, name: str = CB_NAME) -> CircuitBreaker",
            "docstring": "Create CircuitBreaker with required session.\n\nL6 drivers are NOT singletons \u2014 each operation gets its own instance\nbecause the caller owns the session/transaction lifecycle.\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    failure_threshold: Consecutive failures to trip breaker (default from config)\n    drift_threshold: Override drift threshold (default from config)\n    name: Circuit breaker name (default: costsim_v2)\n\nReturns:\n    CircuitBreaker instance bound to the provided session",
            "is_async": false,
            "line": 917
          },
          {
            "name": "is_v2_disabled",
            "signature": "(session: Session) -> bool",
            "docstring": "Check if CostSim V2 is disabled.",
            "is_async": true,
            "line": 952
          },
          {
            "name": "disable_v2",
            "signature": "(session: Session, reason: str, disabled_by: str, disabled_until: Optional[datetime] = None) -> Tuple[bool, Optional[Incident]]",
            "docstring": "Disable CostSim V2.",
            "is_async": true,
            "line": 958
          },
          {
            "name": "enable_v2",
            "signature": "(session: Session, enabled_by: str, reason: Optional[str] = None) -> bool",
            "docstring": "Enable CostSim V2.",
            "is_async": true,
            "line": 973
          }
        ],
        "classes": [
          {
            "name": "CircuitBreakerState",
            "docstring": "Current state of the circuit breaker (in-memory representation).",
            "methods": [
              "to_dict"
            ],
            "line": 96
          },
          {
            "name": "Incident",
            "docstring": "Incident record for circuit breaker trip.",
            "methods": [
              "to_dict"
            ],
            "line": 123
          },
          {
            "name": "CircuitBreaker",
            "docstring": "DB-backed circuit breaker for CostSim V2 auto-disable.\n\nUses PostgreSQL for centralized state management across replicas.\nSends alerts to Alertmanager when state changes.\n\nTransaction Boundary: L6 drivers DO NOT commit.\nThe caller (L5 engine or L4 coordinator) owns the transaction.\nThis driver only calls session.add() \u2014 never session.commit().\n\nUsage:\n    breaker = create_circuit_breaker(session=session)\n\n    # Check before running V2\n    if not await breaker.is_disabled():\n        result = await v2_adapter.simulate(plan)\n\n    # Report drift after comparison\n    incident = await breaker.report_drift(\n        drift_score=0.25,\n        sample_count=100,\n        details={\"kl_divergence\": 0.3}\n    )\n\n    # Manual reset\n    await breaker.reset(reason=\"Fixed V2 model coefficients\", reset_by=\"admin\")",
            "methods": [
              "__init__",
              "_get_or_create_state",
              "is_disabled",
              "_auto_recover",
              "is_open",
              "is_closed",
              "get_state",
              "report_drift",
              "report_schema_error",
              "disable_v2",
              "enable_v2",
              "reset",
              "_trip",
              "_resolve_incident_db",
              "_save_incident_file",
              "get_incidents",
              "_send_alert_disable",
              "_send_alert_enable",
              "_post_alertmanager"
            ],
            "line": 159
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 73
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple",
              "cast"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 79
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 80
          },
          {
            "module": "app.costsim.config",
            "names": [
              "get_config"
            ],
            "is_relative": false,
            "line": 82
          },
          {
            "module": "app.db",
            "names": [
              "CostSimCBIncident",
              "CostSimCBState",
              "log_status_change"
            ],
            "is_relative": false,
            "line": 83
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 28
          },
          {
            "name": "RETRY_POLICY",
            "line": 29
          },
          {
            "name": "CB_NAME",
            "line": 92
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "circuit_breaker_async.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/circuit_breaker_async.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 999,
        "module_docstring": null,
        "functions": [
          {
            "name": "_get_or_create_state",
            "signature": "(session: AsyncSession, lock: bool = False) -> CostSimCBStateModel",
            "docstring": "Get or create circuit breaker state row.\n\nArgs:\n    session: Async database session\n    lock: If True, use SELECT FOR UPDATE to lock the row\n\nReturns:\n    CostSimCBStateModel instance",
            "is_async": true,
            "line": 157
          },
          {
            "name": "is_v2_disabled",
            "signature": "(session: Optional[AsyncSession] = None) -> bool",
            "docstring": "Check if V2 is disabled.\n\nNon-blocking async check that also handles TTL-based auto-recovery.\n\nReturns True if:\n- disabled=True AND disabled_until is None (permanent disable)\n- disabled=True AND disabled_until > now (TTL not expired)\n\nReturns False if:\n- disabled=False\n- disabled=True AND disabled_until <= now (TTL expired, auto-recover)\n\nArgs:\n    session: Optional async session (creates new if None)\n\nReturns:\n    True if V2 is disabled",
            "is_async": true,
            "line": 195
          },
          {
            "name": "_try_auto_recover",
            "signature": "(state_id: int) -> bool",
            "docstring": "Attempt auto-recovery with proper locking to avoid TOCTOU race.\n\nUses SELECT FOR UPDATE to ensure only one worker performs recovery.\nReturns True if recovery was performed (or already done by another worker).\n\nArgs:\n    state_id: ID of the state row to recover\n\nReturns:\n    True if recovered (or already recovered), False if still disabled",
            "is_async": true,
            "line": 256
          },
          {
            "name": "_auto_recover",
            "signature": "(session: AsyncSession, state: CostSimCBStateModel) -> None",
            "docstring": "Legacy auto-recover function (deprecated).\n\nUse _try_auto_recover() instead for proper locking.",
            "is_async": true,
            "line": 348
          },
          {
            "name": "get_state",
            "signature": "() -> CircuitBreakerState",
            "docstring": "Get current circuit breaker state.",
            "is_async": true,
            "line": 395
          },
          {
            "name": "report_drift",
            "signature": "(drift_score: float, sample_count: int = 1, details: Optional[Dict[str, Any]] = None) -> Optional[Incident]",
            "docstring": "Report drift observation.\n\nIf drift exceeds threshold, trips the circuit breaker.\n\nArgs:\n    drift_score: Observed drift score (0.0 - 1.0)\n    sample_count: Number of samples in observation\n    details: Additional details\n\nReturns:\n    Incident if circuit breaker tripped, None otherwise",
            "is_async": true,
            "line": 415
          },
          {
            "name": "report_schema_error",
            "signature": "(error_count: int = 1, details: Optional[Dict[str, Any]] = None) -> Optional[Incident]",
            "docstring": "Report schema validation errors.\n\nArgs:\n    error_count: Number of schema errors\n    details: Error details\n\nReturns:\n    Incident if threshold exceeded, None otherwise",
            "is_async": true,
            "line": 477
          },
          {
            "name": "disable_v2",
            "signature": "(reason: str, disabled_by: str, disabled_until: Optional[datetime] = None) -> Tuple[bool, Optional[Incident]]",
            "docstring": "Manually disable CostSim V2.\n\nIdempotent: returns False if already disabled with same params.\n\nArgs:\n    reason: Reason for disabling\n    disabled_by: Who disabled (user_id, system, etc.)\n    disabled_until: Optional TTL (None = use default from config)\n\nReturns:\n    Tuple of (state_changed, incident)",
            "is_async": true,
            "line": 515
          },
          {
            "name": "enable_v2",
            "signature": "(enabled_by: str, reason: Optional[str] = None) -> bool",
            "docstring": "Manually enable CostSim V2.\n\nIdempotent: returns False if already enabled.\n\nArgs:\n    enabled_by: Who enabled (user_id, system, etc.)\n    reason: Optional reason for enabling\n\nReturns:\n    True if state changed, False otherwise",
            "is_async": true,
            "line": 556
          },
          {
            "name": "_trip",
            "signature": "(session: AsyncSession, state: CostSimCBStateModel, reason: str, drift_score: float, sample_count: int, details: Optional[Dict[str, Any]] = None, severity: str = 'P1', disabled_by: str = 'circuit_breaker', disabled_until: Optional[datetime] = None) -> Incident",
            "docstring": "Trip the circuit breaker.\n\nArgs:\n    session: Database session\n    state: Circuit breaker state model\n    reason: Reason for tripping\n    drift_score: Drift score that triggered trip\n    sample_count: Number of samples\n    details: Additional details\n    severity: Alert severity (P1, P2, P3)\n    disabled_by: Who disabled\n    disabled_until: Optional TTL\n\nReturns:\n    Created Incident",
            "is_async": true,
            "line": 625
          },
          {
            "name": "_resolve_incident",
            "signature": "(session: AsyncSession, incident_id: str, resolved_by: str, resolution_notes: str) -> None",
            "docstring": "Resolve an incident.",
            "is_async": true,
            "line": 721
          },
          {
            "name": "get_incidents",
            "signature": "(include_resolved: bool = False, limit: int = 10) -> List[Incident]",
            "docstring": "Get recent incidents.\n\nArgs:\n    include_resolved: Include resolved incidents\n    limit: Maximum incidents to return\n\nReturns:\n    List of incidents",
            "is_async": true,
            "line": 739
          },
          {
            "name": "_enqueue_alert",
            "signature": "(session: AsyncSession, alert_type: str, payload: List[Dict[str, Any]], incident_id: Optional[str] = None) -> None",
            "docstring": "Enqueue alert for reliable delivery.\n\nArgs:\n    session: Database session\n    alert_type: Type of alert (disable, enable, canary_fail)\n    payload: Alertmanager payload\n    incident_id: Associated incident ID",
            "is_async": true,
            "line": 789
          },
          {
            "name": "_build_disable_alert_payload",
            "signature": "(incident: Incident, disabled_until: Optional[datetime]) -> List[Dict[str, Any]]",
            "docstring": "Build Alertmanager payload for disable alert.",
            "is_async": false,
            "line": 817
          },
          {
            "name": "_build_enable_alert_payload",
            "signature": "(enabled_by: str, reason: Optional[str] = None) -> List[Dict[str, Any]]",
            "docstring": "Build Alertmanager payload for enable/resolved alert.",
            "is_async": false,
            "line": 849
          },
          {
            "name": "get_async_circuit_breaker",
            "signature": "() -> AsyncCircuitBreaker",
            "docstring": "Get the global async circuit breaker instance.",
            "is_async": false,
            "line": 994
          }
        ],
        "classes": [
          {
            "name": "CircuitBreakerState",
            "docstring": "Current state of the circuit breaker.",
            "methods": [
              "to_dict"
            ],
            "line": 91
          },
          {
            "name": "Incident",
            "docstring": "Incident record for circuit breaker trip.",
            "methods": [
              "to_dict"
            ],
            "line": 118
          },
          {
            "name": "AsyncCircuitBreaker",
            "docstring": "Async circuit breaker class for compatibility with existing code.\n\nProvides the same interface as the sync CircuitBreaker but uses\nasync operations internally.",
            "methods": [
              "__init__",
              "is_disabled",
              "is_open",
              "is_closed",
              "get_state",
              "report_drift",
              "report_schema_error",
              "disable_v2",
              "enable_v2",
              "reset",
              "reset_v2",
              "get_incidents"
            ],
            "line": 879
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 73
          },
          {
            "module": "app.costsim.config",
            "names": [
              "get_config"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "app.costsim.metrics",
            "names": [
              "get_metrics"
            ],
            "is_relative": false,
            "line": 76
          },
          {
            "module": "app.db_async",
            "names": [
              "AsyncSessionLocal",
              "async_session_context"
            ],
            "is_relative": false,
            "line": 77
          },
          {
            "module": "app.models.costsim_cb",
            "names": [
              "CostSimAlertQueueModel",
              "CostSimCBIncidentModel",
              "CostSimCBStateModel"
            ],
            "is_relative": false,
            "line": 78
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 27
          },
          {
            "name": "RETRY_POLICY",
            "line": 28
          },
          {
            "name": "CB_NAME",
            "line": 87
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "limits_read_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/limits_read_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 281,
        "module_docstring": "Limits Read Driver (L6)\n\nPure data access layer for limits read operations.\nAll SQLAlchemy queries live here. No business logic.",
        "functions": [
          {
            "name": "get_limits_read_driver",
            "signature": "(session: AsyncSession) -> LimitsReadDriver",
            "docstring": "Factory function for LimitsReadDriver.",
            "is_async": false,
            "line": 273
          }
        ],
        "classes": [
          {
            "name": "LimitsReadDriver",
            "docstring": "Read operations for limits.",
            "methods": [
              "__init__",
              "fetch_limits",
              "fetch_limit_by_id",
              "fetch_budget_limits"
            ],
            "line": 34
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitBreach",
              "LimitIntegrity"
            ],
            "is_relative": false,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": [
          "LimitsReadDriver",
          "get_limits_read_driver"
        ]
      },
      {
        "file_name": "override_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/override_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 266,
        "module_docstring": "Limit Override Service (PIN-LIM-05)\n\nLifecycle of temporary limit overrides.\n\nResponsibilities:\n- Create override requests\n- Handle approval workflow\n- Expiry handling\n- Attach justification & requester\n- Emit signals to runtime evaluator\n- Audit events",
        "functions": [],
        "classes": [
          {
            "name": "LimitOverrideServiceError",
            "docstring": "Base exception for override service.",
            "methods": [],
            "line": 56
          },
          {
            "name": "LimitNotFoundError",
            "docstring": "Raised when limit is not found.",
            "methods": [],
            "line": 61
          },
          {
            "name": "OverrideNotFoundError",
            "docstring": "Raised when override is not found.",
            "methods": [],
            "line": 66
          },
          {
            "name": "OverrideValidationError",
            "docstring": "Raised when override validation fails.",
            "methods": [],
            "line": 71
          },
          {
            "name": "StackingAbuseError",
            "docstring": "Raised when too many overrides are active.",
            "methods": [],
            "line": 76
          },
          {
            "name": "LimitOverrideService",
            "docstring": "Service for limit override lifecycle.\n\nINVARIANTS:\n- One override per limit (no stacking)\n- Override cannot exceed plan quota cap\n- Max 5 active overrides per tenant\n- All overrides require justification",
            "methods": [
              "__init__",
              "request_override",
              "get_override",
              "list_overrides",
              "cancel_override",
              "_get_limit",
              "_to_response"
            ],
            "line": 86
          }
        ],
        "imports": [
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "select"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.general.L6_drivers.cross_domain",
            "names": [
              "generate_uuid"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.controls.L5_schemas.overrides",
            "names": [
              "LimitOverrideRequest",
              "LimitOverrideResponse",
              "OverrideStatus"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "policy_limits_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/policy_limits_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 117,
        "module_docstring": "Policy Limits Driver\n\nPure data access for policy limits table.\nNo business logic - only DB operations.\n\nAuthority: LIMIT_PERSISTENCE\nTables: limits, limit_integrity",
        "functions": [
          {
            "name": "get_policy_limits_driver",
            "signature": "(session: AsyncSession) -> PolicyLimitsDriver",
            "docstring": "Factory function for PolicyLimitsDriver.",
            "is_async": false,
            "line": 115
          }
        ],
        "classes": [
          {
            "name": "PolicyLimitsDriver",
            "docstring": "Data access driver for policy limits.\n\nINVARIANTS (L6):\n- No business branching\n- No validation\n- No cross-domain calls\n- Pure persistence operations only",
            "methods": [
              "__init__",
              "fetch_limit_by_id",
              "add_limit",
              "add_integrity",
              "flush"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "scoped_execution.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/scoped_execution.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 696,
        "module_docstring": "M6: Scoped Execution Context Service (P2FC-4)\n\nPre-execution gate for MEDIUM+ risk recovery actions.\n\nCORE INVARIANT (M6):\n> \"No recovery action may execute without an explicit, bounded execution\n>  scope derived from incident context.\"\n\nThe Scoped Execution primitive provides:\n1. Scope creation with incident binding, cost ceiling, action limits, expiry\n2. Scope-gated execution (no execution without valid scope)\n3. Scope exhaustion tracking (single-use by default)\n4. Scope tampering detection (action must match scope)\n5. Audit trail for all scope operations\n\nScope Model MUST bind:\n- Action type (what can be done)\n- Target (agent / resource)\n- Cost ceiling (tokens / spend)\n- Duration / count limit\n- Intent (why this is allowed)\n\nRelated PINs:\n- PIN-148: Incident lifecycle\n- PIN-161: Evidence completeness (Replay feeds scope)\n- PIN-172: Scoped execution invariant",
        "functions": [
          {
            "name": "get_scope_store",
            "signature": "() -> ScopeStore",
            "docstring": "Get the global scope store.",
            "is_async": false,
            "line": 499
          },
          {
            "name": "create_recovery_scope",
            "signature": "(incident_id: str, action: str, intent: str = '', max_cost_usd: float = 0.5, max_attempts: int = 1, ttl_seconds: int = 300, target_agents: Optional[List[str]] = None, created_by: str = 'system') -> Dict[str, Any]",
            "docstring": "Create a bound execution scope for recovery action.\n\nThis is the gate step (Step A2 in test script).",
            "is_async": true,
            "line": 509
          },
          {
            "name": "execute_with_scope",
            "signature": "(scope_id: str, action: str, incident_id: str, parameters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]",
            "docstring": "Execute a recovery action within a valid scope.\n\nThis enforces all P2FC-4 gates:\n- Scope must exist\n- Scope must not be exhausted/expired\n- Action must match scope's allowed actions\n- Incident must match scope's bound incident",
            "is_async": true,
            "line": 544
          },
          {
            "name": "validate_scope_required",
            "signature": "(incident_id: str, action: str) -> None",
            "docstring": "Validate that execution without scope should fail.\n\nCalled by /recovery/execute when no scope_id provided.\nAlways raises ScopedExecutionRequired.",
            "is_async": true,
            "line": 601
          },
          {
            "name": "requires_scoped_execution",
            "signature": "(risk_threshold: RiskClass = RiskClass.MEDIUM)",
            "docstring": "Decorator to enforce scoped pre-execution for risky recovery actions.\n\nUsage:\n    @requires_scoped_execution(risk_threshold=RiskClass.MEDIUM)\n    async def execute_recovery(action: RecoveryAction):\n        ...\n\nThe decorated function must accept `skip_scope: bool = False` parameter.\nIf skip_scope=True and risk >= threshold, ScopedExecutionRequired is raised.",
            "is_async": false,
            "line": 618
          },
          {
            "name": "test_recovery_scope",
            "signature": "(action_id: str, action_name: str, action_type: str, risk_class: str, parameters: Dict[str, Any], scope_type: str = 'dry_run', scope_fraction: float = 0.1) -> Dict[str, Any]",
            "docstring": "Test a recovery action in scoped execution.\n\nReturns dict with execution result for API response.",
            "is_async": true,
            "line": 658
          }
        ],
        "classes": [
          {
            "name": "RiskClass",
            "docstring": "Risk classification for recovery actions.",
            "methods": [],
            "line": 66
          },
          {
            "name": "ExecutionScope",
            "docstring": "Type of scoped execution.",
            "methods": [],
            "line": 75
          },
          {
            "name": "ScopedExecutionResult",
            "docstring": "Result of a scoped execution test.",
            "methods": [],
            "line": 85
          },
          {
            "name": "RecoveryAction",
            "docstring": "A recovery action to be tested in scoped execution.",
            "methods": [],
            "line": 100
          },
          {
            "name": "ScopedExecutionContext",
            "docstring": "M6 Scoped Execution primitive.\n\nProvides pre-execution testing for recovery actions before global rollout.",
            "methods": [
              "__init__",
              "execute",
              "_dry_run_validate",
              "_execute_scoped",
              "_estimate_cost",
              "_elapsed_ms",
              "_compute_hash"
            ],
            "line": 112
          },
          {
            "name": "ScopedExecutionRequired",
            "docstring": "Raised when a MEDIUM+ risk action is attempted without scoped pre-execution.",
            "methods": [],
            "line": 262
          },
          {
            "name": "ScopeNotFound",
            "docstring": "Raised when a scope ID does not exist.",
            "methods": [],
            "line": 268
          },
          {
            "name": "ScopeExhausted",
            "docstring": "Raised when a scope has been fully consumed.",
            "methods": [],
            "line": 274
          },
          {
            "name": "ScopeExpired",
            "docstring": "Raised when a scope has expired.",
            "methods": [],
            "line": 280
          },
          {
            "name": "ScopeActionMismatch",
            "docstring": "Raised when action does not match scope's allowed actions.",
            "methods": [],
            "line": 286
          },
          {
            "name": "ScopeIncidentMismatch",
            "docstring": "Raised when execution targets a different incident than scope.",
            "methods": [],
            "line": 292
          },
          {
            "name": "BoundExecutionScope",
            "docstring": "A bound execution scope that gates recovery actions.\n\nThis is the core P2FC-4 primitive. Every recovery action MUST have\na valid scope before execution.",
            "methods": [
              "is_valid",
              "can_execute",
              "consume",
              "to_dict"
            ],
            "line": 304
          },
          {
            "name": "ScopeStore",
            "docstring": "Thread-safe in-memory store for execution scopes.\n\nIn production, this would be backed by Redis or PostgreSQL.",
            "methods": [
              "__new__",
              "create_scope",
              "get_scope",
              "get_scopes_for_incident",
              "revoke_scope",
              "cleanup_expired"
            ],
            "line": 404
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "secrets",
            "names": [
              "secrets"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "threading",
            "names": [
              "threading"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "functools",
            "names": [
              "wraps"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "threshold_driver.py",
        "file_path": "backend/app/hoc/cus/controls/L6_drivers/threshold_driver.py",
        "layer": "L6_drivers",
        "domain": "controls",
        "lines": 380,
        "module_docstring": "Threshold Driver (L6)\n\nProvides:\n- LimitSnapshot: Immutable snapshot returned to engines\n- ThresholdDriver: Async DB operations for threshold limits\n- ThresholdDriverSync: Sync DB operations for worker context\n- Signal emission functions for dual console output\n\nThis driver owns the DATA ACCESS logic:\n- Query active threshold limits from database\n- Emit signals to ops_events table\n- Update run risk levels\n\nThe driver does NOT own:\n- Precedence resolution (delegated to L4 engine)\n- Threshold evaluation (delegated to L4 engine)\n- Signal determination (delegated to L4 engine)\n\nReference: ACTIVITY_PHASE2.5_IMPLEMENTATION_PLAN.md",
        "functions": [
          {
            "name": "emit_threshold_signal_sync",
            "signature": "(session: Any, tenant_id: str, run_id: str, state: str, signal: Any, params_used: dict) -> None",
            "docstring": "Emit a threshold signal to ops_events table (sync).\n\nFor use in sync contexts (e.g., worker callbacks).\n\nL6 CONTRACT: Pure DB write, no business logic.\n\nArgs:\n    session: Sync SQLAlchemy Session\n    tenant_id: Tenant identifier\n    run_id: Run identifier\n    state: Run state (live or completed)\n    signal: ThresholdSignal enum value\n    params_used: The params that were evaluated against",
            "is_async": false,
            "line": 256
          },
          {
            "name": "emit_and_persist_threshold_signal",
            "signature": "(session: Any, tenant_id: str, run_id: str, state: str, signals: list, params_used: dict) -> None",
            "docstring": "Emit threshold signals to both Founder and Customer consoles.\n\nThis function performs DUAL emission:\n1. ops_events (Founder Console) - via emit_threshold_signal_sync()\n   - For operational monitoring in Founder Console\n   - Protected by verify_fops_token() in api/ops.py\n   - NOTE: ops_events is FOUNDER CONSOLE ONLY - not transmitted to customer endpoints\n\n2. runs.risk_level (Customer Console) - via RunSignalService\n   - For Activity panels in Customer Console\n   - Consumed by v_runs_o2 -> api/activity.py -> Customer Console\n\nL6 CONTRACT: Pure DB writes, no business logic.\n\nArgs:\n    session: SQLAlchemy sync session\n    tenant_id: Tenant identifier\n    run_id: Run identifier\n    state: Run state (\"live\" or \"completed\")\n    signals: List of ThresholdSignal values\n    params_used: The threshold params that were evaluated against\n\nReference: Threshold Signal Wiring to Customer Console Plan",
            "is_async": false,
            "line": 327
          }
        ],
        "classes": [
          {
            "name": "LimitSnapshot",
            "docstring": "Immutable snapshot of a Limit record returned to engines.\n\nThis is the boundary contract between L6 (driver) and L4 (engine).\nEngines receive snapshots, not ORM models.",
            "methods": [],
            "line": 69
          },
          {
            "name": "ThresholdDriver",
            "docstring": "Async database driver for threshold limit operations.\n\nL6 CONTRACT:\n- Pure data access, no business logic\n- Returns LimitSnapshot objects, not ORM models\n- No precedence resolution (that's L4)",
            "methods": [
              "__init__",
              "get_active_threshold_limits",
              "get_threshold_limit_by_scope"
            ],
            "line": 91
          },
          {
            "name": "ThresholdDriverSync",
            "docstring": "Sync database driver for threshold limit operations.\n\nUsed in worker context (ThreadPoolExecutor) which doesn't support async.\n\nL6 CONTRACT:\n- Pure data access, no business logic\n- Returns LimitSnapshot objects\n- Uses raw SQL for sync compatibility",
            "methods": [
              "__init__",
              "get_active_threshold_limits"
            ],
            "line": 191
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "uuid",
            "names": [
              "uuid_module"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "sqlmodel",
            "names": [
              "select"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.models.policy_control_plane",
            "names": [
              "Limit",
              "LimitCategory",
              "LimitStatus"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 23,
    "violation_count": 5,
    "gap_count": 2
  },
  "logs": {
    "l2_1_facade": null,
    "l2_apis": [
      {
        "file_name": "cost_intelligence.py",
        "file_path": "backend/app/hoc/api/cus/logs/cost_intelligence.py",
        "layer": "L2_api",
        "domain": "logs",
        "lines": 1287,
        "module_docstring": "M26 Cost Intelligence API\n\nCore Objective:\nEvery token spent is attributable to tenant \u2192 user \u2192 feature \u2192 request.\nEvery anomaly must trigger an action, not a chart.\n\nThis is not reporting. This is CONTROL.",
        "functions": [
          {
            "name": "get_tenant_id",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID')) -> str",
            "docstring": "Extract tenant_id from query parameter.",
            "is_async": false,
            "line": 46
          },
          {
            "name": "create_feature_tag",
            "signature": "(data: FeatureTagCreate, tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> FeatureTagResponse",
            "docstring": "Register a new feature tag.\n\nFeature tags are MANDATORY for cost attribution.\nNo tag \u2192 request defaulted to 'unclassified' (and flagged).",
            "is_async": true,
            "line": 289
          },
          {
            "name": "list_feature_tags",
            "signature": "(include_inactive: bool = False, tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> List[FeatureTagResponse]",
            "docstring": "List all feature tags for the tenant.",
            "is_async": true,
            "line": 343
          },
          {
            "name": "update_feature_tag",
            "signature": "(tag: str, data: FeatureTagUpdate, tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> FeatureTagResponse",
            "docstring": "Update a feature tag.",
            "is_async": true,
            "line": 373
          },
          {
            "name": "record_cost",
            "signature": "(data: CostRecordCreate, tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> dict",
            "docstring": "Record a cost entry.\n\nThis is called internally after each LLM invocation.\nFeature tag validation: if tag doesn't exist, default to 'unclassified'.",
            "is_async": true,
            "line": 419
          },
          {
            "name": "get_cost_dashboard",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> CostDashboard",
            "docstring": "Get complete cost dashboard.\n\nIf a CTO can't answer \"what burned money yesterday?\" in 10 seconds, this failed.",
            "is_async": true,
            "line": 470
          },
          {
            "name": "get_cost_summary",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> CostSummary",
            "docstring": "Get cost summary for the period.",
            "is_async": true,
            "line": 521
          },
          {
            "name": "get_costs_by_feature",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> CostByFeatureEnvelope",
            "docstring": "Get cost breakdown by feature tag.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 542
          },
          {
            "name": "get_costs_by_user",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> CostByUserEnvelope",
            "docstring": "Get cost breakdown by user with anomaly detection.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 586
          },
          {
            "name": "get_costs_by_model",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> CostByModelEnvelope",
            "docstring": "Get cost breakdown by model.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 630
          },
          {
            "name": "get_anomalies",
            "signature": "(days: int = Query(7, ge=1, le=90), include_resolved: bool = False, tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> CostAnomaliesEnvelope",
            "docstring": "Get detected cost anomalies.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 673
          },
          {
            "name": "get_projection",
            "signature": "(lookback_days: int = Query(7, ge=1, le=30), forecast_days: int = Query(7, ge=1, le=30), tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> CostProjection",
            "docstring": "Get cost projection based on historical data.",
            "is_async": true,
            "line": 701
          },
          {
            "name": "create_or_update_budget",
            "signature": "(data: BudgetCreate, tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> BudgetResponse",
            "docstring": "Create or update a budget.",
            "is_async": true,
            "line": 717
          },
          {
            "name": "list_budgets",
            "signature": "(tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> List[BudgetResponse]",
            "docstring": "List all budgets for the tenant.",
            "is_async": true,
            "line": 770
          },
          {
            "name": "_get_cost_summary",
            "signature": "(session: Session, tenant_id: str, period_start: datetime, period_end: datetime, days: int) -> CostSummary",
            "docstring": "Get cost summary for a period.",
            "is_async": true,
            "line": 809
          },
          {
            "name": "_get_costs_by_feature",
            "signature": "(session: Session, tenant_id: str, period_start: datetime, total_cost: float) -> List[CostByFeature]",
            "docstring": "Get costs grouped by feature tag.",
            "is_async": true,
            "line": 887
          },
          {
            "name": "_get_costs_by_user",
            "signature": "(session: Session, tenant_id: str, period_start: datetime, total_cost: float) -> List[CostByUser]",
            "docstring": "Get costs grouped by user with anomaly detection.",
            "is_async": true,
            "line": 927
          },
          {
            "name": "_get_costs_by_model",
            "signature": "(session: Session, tenant_id: str, period_start: datetime, total_cost: float) -> List[CostByModel]",
            "docstring": "Get costs grouped by model.",
            "is_async": true,
            "line": 970
          },
          {
            "name": "_get_recent_anomalies",
            "signature": "(session: Session, tenant_id: str, days: int = 7, include_resolved: bool = False) -> List[CostAnomalyResponse]",
            "docstring": "Get recent anomalies.",
            "is_async": true,
            "line": 1008
          },
          {
            "name": "_get_cost_projection",
            "signature": "(session: Session, tenant_id: str, lookback_days: int = 7, forecast_days: int = 7) -> CostProjection",
            "docstring": "Calculate cost projection based on historical trend.",
            "is_async": true,
            "line": 1048
          },
          {
            "name": "_get_current_spend",
            "signature": "(session: Session, tenant_id: str, budget_type: str, entity_id: Optional[str]) -> dict",
            "docstring": "Get current daily and monthly spend for a budget entity.",
            "is_async": true,
            "line": 1150
          },
          {
            "name": "trigger_anomaly_detection",
            "signature": "(request: AnomalyDetectionRequest = AnomalyDetectionRequest(), tenant_id: str = Depends(get_tenant_id), session: Session = Depends(get_session)) -> AnomalyDetectionResponse",
            "docstring": "Trigger anomaly detection for this tenant.\n\nThis endpoint:\n1. Scans for USER_SPIKE, FEATURE_SPIKE, BUDGET_WARNING, BUDGET_EXCEEDED\n2. Persists detected anomalies to database\n3. Optionally escalates HIGH/CRITICAL anomalies to M25 incident loop\n\nM25 Integration:\nWhen escalate_to_m25=True (default), HIGH and CRITICAL anomalies are:\n- Converted to M25 incidents\n- Processed through the M25 loop (Pattern \u2192 Recovery \u2192 Policy \u2192 Routing)\n- Resulting in automated policies to prevent future cost anomalies",
            "is_async": true,
            "line": 1221
          }
        ],
        "classes": [
          {
            "name": "FeatureTagCreate",
            "docstring": "Create a new feature tag.",
            "methods": [],
            "line": 61
          },
          {
            "name": "FeatureTagResponse",
            "docstring": "Feature tag response.",
            "methods": [],
            "line": 70
          },
          {
            "name": "FeatureTagUpdate",
            "docstring": "Update a feature tag.",
            "methods": [],
            "line": 84
          },
          {
            "name": "CostRecordCreate",
            "docstring": "Record a cost entry.",
            "methods": [],
            "line": 93
          },
          {
            "name": "CostProvenance",
            "docstring": "Provenance metadata for cost interpretation panels.",
            "methods": [],
            "line": 107
          },
          {
            "name": "CostSummary",
            "docstring": "Cost summary for a period.",
            "methods": [],
            "line": 116
          },
          {
            "name": "CostByFeature",
            "docstring": "Cost breakdown by feature.",
            "methods": [],
            "line": 132
          },
          {
            "name": "CostByUser",
            "docstring": "Cost breakdown by user.",
            "methods": [],
            "line": 144
          },
          {
            "name": "CostByModel",
            "docstring": "Cost breakdown by model.",
            "methods": [],
            "line": 155
          },
          {
            "name": "CostProjection",
            "docstring": "Cost projection for upcoming period.",
            "methods": [],
            "line": 166
          },
          {
            "name": "CostAnomalyResponse",
            "docstring": "Cost anomaly response.",
            "methods": [],
            "line": 180
          },
          {
            "name": "AnalyticsProvenance",
            "docstring": "Provenance envelope for analytics interpretation panels.\n\nSDSR requires provenance metadata on all interpretation panels to ensure\nthe UI can correctly display how data was derived.",
            "methods": [],
            "line": 204
          },
          {
            "name": "CostByUserEnvelope",
            "docstring": "Envelope response for cost by user with provenance.",
            "methods": [],
            "line": 217
          },
          {
            "name": "CostByModelEnvelope",
            "docstring": "Envelope response for cost by model with provenance.",
            "methods": [],
            "line": 224
          },
          {
            "name": "CostByFeatureEnvelope",
            "docstring": "Envelope response for cost by feature with provenance.",
            "methods": [],
            "line": 231
          },
          {
            "name": "CostAnomaliesEnvelope",
            "docstring": "Envelope response for cost anomalies with provenance.",
            "methods": [],
            "line": 238
          },
          {
            "name": "CostDashboard",
            "docstring": "Complete cost dashboard data.",
            "methods": [],
            "line": 245
          },
          {
            "name": "BudgetCreate",
            "docstring": "Create or update a budget.",
            "methods": [],
            "line": 256
          },
          {
            "name": "BudgetResponse",
            "docstring": "Budget response.",
            "methods": [],
            "line": 267
          },
          {
            "name": "AnomalyDetectionRequest",
            "docstring": "Request to trigger anomaly detection.",
            "methods": [],
            "line": 1205
          },
          {
            "name": "AnomalyDetectionResponse",
            "docstring": "Response from anomaly detection.",
            "methods": [],
            "line": 1211
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional",
              "cast"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "app.db",
            "names": [
              "CostAnomaly",
              "CostBudget",
              "FeatureTag",
              "get_session",
              "utc_now"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.services.cost_write_service",
            "names": [
              "CostWriteService"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "guard_logs.py",
        "file_path": "backend/app/hoc/api/cus/logs/guard_logs.py",
        "layer": "L2_api",
        "domain": "logs",
        "lines": 215,
        "module_docstring": "Guard Logs API - Customer Console Logs Endpoint\n\nThis router provides endpoints for the Customer Console (guard.agenticverz.com).\nFocused on LOG VISIBILITY - customers can see their execution audit trail.\n\nEndpoints:\n- GET  /guard/logs          - List customer logs (execution audit trail)\n- GET  /guard/logs/export   - Export logs (JSON or CSV)\n- GET  /guard/logs/{id}     - Log detail with steps\n\nPIN-281 Promotion:\n- L4\u2192L3: customer_logs_adapter.py (boundary adapter)\n- L3\u2192L2: This file (API route)\n\nRule: One adapter per route. No business logic here.",
        "functions": [
          {
            "name": "list_logs",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID (required)'), agent_id: Optional[str] = Query(None, description='Filter by agent ID'), status: Optional[str] = Query(None, description='Filter by status (running, completed, failed)'), from_date: Optional[str] = Query(None, description='Filter from date (ISO format)'), to_date: Optional[str] = Query(None, description='Filter to date (ISO format)'), limit: int = Query(50, le=100, description='Page size (max 100)'), offset: int = Query(0, ge=0, description='Pagination offset'))",
            "docstring": "List execution logs for customer.\n\nReturns paginated list of customer logs (execution audit trail).\nCustomer can only see their own tenant's logs (enforced by adapter).\n\nThis endpoint:\n- Shows what ran / is running\n- Provides step counts and status\n- Enables filtering by agent, status, date range\n- Supports pagination\n\nNo internal fields exposed (cost_cents, hashes, replay data).\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 67
          },
          {
            "name": "export_logs",
            "signature": "(tenant_id: str = Query(..., description='Tenant ID (required)'), format: str = Query('json', description='Export format (json, csv)'), from_date: Optional[str] = Query(None, description='Filter from date (ISO format)'), to_date: Optional[str] = Query(None, description='Filter to date (ISO format)'), limit: int = Query(1000, le=10000, description='Max records (max 10000)'))",
            "docstring": "Export logs for customer.\n\nReturns logs in requested format (JSON or CSV).\nCustomer can only export their own tenant's logs (enforced by adapter).\n\nSupports:\n- JSON format (default)\n- CSV format for spreadsheet import\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 116
          },
          {
            "name": "get_log",
            "signature": "(log_id: str, tenant_id: str = Query(..., description='Tenant ID (required)'))",
            "docstring": "Get log detail with execution steps.\n\nReturns detailed view of a single log including all steps.\nCustomer can only see their own tenant's logs (enforced by adapter).\n\nThis endpoint:\n- Shows step-by-step execution trace\n- Shows outcome categories and codes\n- Shows duration per step\n- No cost or internal hash data\n\nReference: PIN-281 Phase 5 (L3\u2192L2 promotion)",
            "is_async": true,
            "line": 178
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi.responses",
            "names": [
              "StreamingResponse"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.adapters.customer_logs_adapter",
            "names": [
              "CustomerLogDetail",
              "CustomerLogListResponse",
              "get_customer_logs_adapter"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.console_auth",
            "names": [
              "verify_console_token"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "tenants.py",
        "file_path": "backend/app/hoc/api/cus/logs/tenants.py",
        "layer": "L2_api",
        "domain": "logs",
        "lines": 636,
        "module_docstring": "Tenant & API Key Management API (M21)\n\nProvides:\n- Tenant management endpoints\n- API key CRUD operations\n- Usage and quota queries\n- Worker registry endpoints",
        "functions": [
          {
            "name": "get_db",
            "signature": "()",
            "docstring": "Get database session.",
            "is_async": false,
            "line": 51
          },
          {
            "name": "get_services",
            "signature": "(session: Session = Depends(get_db))",
            "docstring": "Get tenant and worker registry services.",
            "is_async": false,
            "line": 58
          },
          {
            "name": "_maybe_advance_to_api_key_created",
            "signature": "(tenant_id: str) -> None",
            "docstring": "PIN-399: Trigger onboarding state transition on first API key creation.\n\nCalled after successful API key creation to potentially advance\na tenant from IDENTITY_VERIFIED to API_KEY_CREATED.\n\nTRIGGER: First successful API key creation.\n\nThis is idempotent - if tenant is already at or past API_KEY_CREATED,\nthis is a no-op.",
            "is_async": true,
            "line": 72
          },
          {
            "name": "get_current_tenant",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Get information about the current tenant (from API key).",
            "is_async": true,
            "line": 260
          },
          {
            "name": "get_tenant_usage",
            "signature": "(period: str = Query('24h', regex='^(24h|7d|30d)$'), ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Get usage summary for the current tenant.\n\nReturns envelope with provenance for SDSR ANALYTICS domain compliance.",
            "is_async": true,
            "line": 290
          },
          {
            "name": "check_run_quota",
            "signature": "(ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Check if the tenant can create a new run.",
            "is_async": true,
            "line": 318
          },
          {
            "name": "check_token_quota",
            "signature": "(tokens_needed: int = Query(default=10000, ge=1), ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Check if the tenant has token budget for an operation.",
            "is_async": true,
            "line": 338
          },
          {
            "name": "list_api_keys",
            "signature": "(include_revoked: bool = False, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "List all API keys for the current tenant.\n\nRequires admin permission.",
            "is_async": true,
            "line": 362
          },
          {
            "name": "create_api_key",
            "signature": "(request: APIKeyCreateRequest, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Create a new API key for the current tenant.\n\n**Important:** The full API key is only shown once in this response.\nStore it securely!\n\nRequires admin permission.",
            "is_async": true,
            "line": 395
          },
          {
            "name": "revoke_api_key",
            "signature": "(key_id: str, reason: str = Query(default='Manual revocation'), ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Revoke an API key.\n\nThe key cannot be un-revoked. Create a new key instead.\n\nRequires admin permission.",
            "is_async": true,
            "line": 447
          },
          {
            "name": "list_workers",
            "signature": "(status: Optional[str] = None, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "List all available workers.",
            "is_async": true,
            "line": 481
          },
          {
            "name": "list_available_workers_for_tenant",
            "signature": "(include_disabled: bool = False, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "List workers available to the current tenant with their configurations.",
            "is_async": true,
            "line": 494
          },
          {
            "name": "get_worker_details",
            "signature": "(worker_id: str, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Get detailed information about a specific worker.",
            "is_async": true,
            "line": 510
          },
          {
            "name": "get_worker_config",
            "signature": "(worker_id: str, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Get the effective configuration for a worker (tenant overrides merged with defaults).",
            "is_async": true,
            "line": 526
          },
          {
            "name": "set_worker_config",
            "signature": "(worker_id: str, request: WorkerConfigRequest, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "Set tenant-specific configuration for a worker.\n\nRequires admin permission.",
            "is_async": true,
            "line": 542
          },
          {
            "name": "list_runs",
            "signature": "(limit: int = Query(default=20, ge=1, le=100), offset: int = Query(default=0, ge=0), status: Optional[str] = None, worker_id: Optional[str] = None, ctx: TenantContext = Depends(get_tenant_context), services: dict = Depends(get_services))",
            "docstring": "List runs for the current tenant.",
            "is_async": true,
            "line": 582
          },
          {
            "name": "tenant_health",
            "signature": "()",
            "docstring": "Health check for tenant system.",
            "is_async": true,
            "line": 622
          }
        ],
        "classes": [
          {
            "name": "TenantResponse",
            "docstring": "Tenant information response.",
            "methods": [],
            "line": 114
          },
          {
            "name": "APIKeyCreateRequest",
            "docstring": "Request to create an API key.",
            "methods": [],
            "line": 133
          },
          {
            "name": "APIKeyResponse",
            "docstring": "API key information (without the actual key).",
            "methods": [],
            "line": 144
          },
          {
            "name": "APIKeyCreatedResponse",
            "docstring": "Response when creating an API key (includes the key once).",
            "methods": [],
            "line": 157
          },
          {
            "name": "AnalyticsProvenance",
            "docstring": "Provenance envelope for analytics interpretation panels.\n\nSDSR requires provenance metadata on all interpretation panels to ensure\nthe UI can correctly display how data was derived.",
            "methods": [],
            "line": 163
          },
          {
            "name": "UsageSummaryResponse",
            "docstring": "Usage summary for a tenant with provenance for SDSR ANALYTICS domain.",
            "methods": [],
            "line": 176
          },
          {
            "name": "WorkerSummaryResponse",
            "docstring": "Worker summary information.",
            "methods": [],
            "line": 186
          },
          {
            "name": "WorkerDetailResponse",
            "docstring": "Detailed worker information.",
            "methods": [],
            "line": 199
          },
          {
            "name": "WorkerConfigRequest",
            "docstring": "Request to configure a worker for a tenant.",
            "methods": [],
            "line": 210
          },
          {
            "name": "WorkerConfigResponse",
            "docstring": "Worker configuration response.",
            "methods": [],
            "line": 220
          },
          {
            "name": "RunHistoryItem",
            "docstring": "Run history item.",
            "methods": [],
            "line": 231
          },
          {
            "name": "QuotaCheckResponse",
            "docstring": "Quota check response.",
            "methods": [],
            "line": 246
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "status"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "auth.tenant_auth",
            "names": [
              "TenantContext",
              "get_tenant_context"
            ],
            "is_relative": true,
            "line": 30
          },
          {
            "module": "db",
            "names": [
              "utc_now"
            ],
            "is_relative": true,
            "line": 31
          },
          {
            "module": "services.tenant_service",
            "names": [
              "QuotaExceededError",
              "TenantService",
              "TenantServiceError"
            ],
            "is_relative": true,
            "line": 32
          },
          {
            "module": "schemas.response",
            "names": [
              "wrap_dict",
              "wrap_list"
            ],
            "is_relative": true,
            "line": 37
          },
          {
            "module": "services.worker_registry_service",
            "names": [
              "WorkerNotFoundError",
              "WorkerRegistryService"
            ],
            "is_relative": true,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "traces.py",
        "file_path": "backend/app/hoc/api/cus/logs/traces.py",
        "layer": "L2_api",
        "domain": "logs",
        "lines": 1205,
        "module_docstring": "Trace Query API\nM8 Deliverable: Trace storage, indexing, and query endpoints\n\nProvides REST API for:\n- Listing and searching traces\n- Getting trace details\n- Finding traces by root_hash (for replay verification)\n- Comparing traces for determinism validation\n- RBAC-protected access via JWT/OIDC\n- PII redaction on storage",
        "functions": [
          {
            "name": "get_current_user",
            "signature": "(request: Request, token: TokenPayload = Depends(_jwt_auth)) -> User",
            "docstring": "Get current authenticated user from JWT token.\n\nSupports:\n- Bearer JWT tokens (OIDC/Keycloak)\n- X-API-Key header (legacy/backwards compatible)\n- Development tokens (dev:xxx prefix)",
            "is_async": true,
            "line": 101
          },
          {
            "name": "require_role",
            "signature": "(user: User, role: str) -> bool",
            "docstring": "Check if user has required role.",
            "is_async": false,
            "line": 113
          },
          {
            "name": "get_trace_store",
            "signature": "() -> TraceStoreType",
            "docstring": "Get the trace store instance.",
            "is_async": false,
            "line": 125
          },
          {
            "name": "list_traces",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant ID'), agent_id: Optional[str] = Query(None, description='Filter by agent ID'), status: Optional[str] = Query(None, description='Filter by status'), root_hash: Optional[str] = Query(None, description='Filter by root hash'), plan_hash: Optional[str] = Query(None, description='Filter by plan hash'), seed: Optional[int] = Query(None, description='Filter by random seed'), from_date: Optional[str] = Query(None, description='Filter from date (ISO8601)'), to_date: Optional[str] = Query(None, description='Filter to date (ISO8601)'), limit: int = Query(100, ge=1, le=1000, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "List and search traces with optional filters.\n\nRBAC: Users can only see traces from their tenant unless admin.",
            "is_async": true,
            "line": 235
          },
          {
            "name": "store_trace",
            "signature": "(request: StoreTraceRequest, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Store a client-provided trace.\n\nApplies PII redaction before storage.",
            "is_async": true,
            "line": 302
          },
          {
            "name": "list_all_mismatches",
            "signature": "(window: Optional[str] = Query(None, description='Time window (e.g., 24h, 7d)'), status: Optional[str] = Query(None, regex='^(open|resolved)$', description='Filter by status'), limit: int = Query(100, le=500, description='Max results'))",
            "docstring": "List all trace mismatches across the system.\n\nREAD-ONLY endpoint for observability. No side effects.\nReturns mismatches with summary counts.\n\nAuth: OBSERVER-safe (SDSR compatible)",
            "is_async": true,
            "line": 354
          },
          {
            "name": "get_trace",
            "signature": "(run_id: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Get a complete trace by run ID.\n\nRBAC: Users can only access their tenant's traces.",
            "is_async": true,
            "line": 457
          },
          {
            "name": "get_trace_by_hash",
            "signature": "(root_hash: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Get a trace by its deterministic root hash.\n\nUseful for replay verification.",
            "is_async": true,
            "line": 515
          },
          {
            "name": "compare_traces",
            "signature": "(run_id1: str, run_id2: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Compare two traces for deterministic equality.\n\nCompares root_hash and step hashes to verify replay parity.",
            "is_async": true,
            "line": 571
          },
          {
            "name": "delete_trace",
            "signature": "(run_id: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Delete a trace by run ID.\n\nRBAC: Requires admin or operator role.",
            "is_async": true,
            "line": 676
          },
          {
            "name": "cleanup_old_traces",
            "signature": "(days: int = Query(30, ge=1, le=365, description='Delete traces older than N days'), store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Delete traces older than specified number of days.\n\nRBAC: Requires admin role.",
            "is_async": true,
            "line": 701
          },
          {
            "name": "check_idempotency",
            "signature": "(idempotency_key: str, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Check if an idempotency key has been executed.\n\nReturns execution status and output if found.",
            "is_async": true,
            "line": 727
          },
          {
            "name": "bulk_report_mismatches",
            "signature": "(mismatch_ids: List[str] = Query(..., description='List of mismatch IDs to link'), github_issue: bool = Query(True, description='Create a GitHub issue for all'), user: User = Depends(get_current_user))",
            "docstring": "Create a single GitHub issue for multiple mismatches.\n\nUseful when a replay causes multiple step mismatches that should be tracked together.\n\nRBAC: Requires admin or operator role.",
            "is_async": true,
            "line": 783
          },
          {
            "name": "report_mismatch",
            "signature": "(trace_id: str, payload: MismatchReport, store: TraceStoreType = Depends(get_trace_store), user: User = Depends(get_current_user))",
            "docstring": "Report a replay mismatch for operator review.\n\nThis endpoint:\n1. Records the mismatch in the database\n2. Optionally creates a GitHub issue or sends a Slack notification\n3. Returns the mismatch ID for tracking\n\nRBAC: Requires authenticated user. Only allows reporting mismatches for user's tenant.",
            "is_async": true,
            "line": 908
          },
          {
            "name": "list_trace_mismatches",
            "signature": "(trace_id: str, user: User = Depends(get_current_user))",
            "docstring": "List all mismatches reported for a trace.",
            "is_async": true,
            "line": 1085
          },
          {
            "name": "resolve_mismatch",
            "signature": "(trace_id: str, mismatch_id: str, resolution_note: Optional[str] = Query(None, description='Optional note about the resolution'), user: User = Depends(get_current_user))",
            "docstring": "Mark a mismatch as resolved.\n\nRBAC: Requires admin or operator role.",
            "is_async": true,
            "line": 1145
          }
        ],
        "classes": [
          {
            "name": "User",
            "docstring": "User model for RBAC - wraps JWT TokenPayload for backwards compatibility.",
            "methods": [
              "__init__",
              "has_role",
              "from_token"
            ],
            "line": 69
          },
          {
            "name": "TraceSummaryResponse",
            "docstring": "Trace summary for list views.",
            "methods": [],
            "line": 141
          },
          {
            "name": "TraceStepResponse",
            "docstring": "Individual trace step.",
            "methods": [],
            "line": 161
          },
          {
            "name": "TraceDetailResponse",
            "docstring": "Full trace with all steps.",
            "methods": [],
            "line": 182
          },
          {
            "name": "TraceListResponse",
            "docstring": "Paginated trace list.",
            "methods": [],
            "line": 203
          },
          {
            "name": "TraceCompareResponse",
            "docstring": "Result of comparing two traces.",
            "methods": [],
            "line": 212
          },
          {
            "name": "StoreTraceRequest",
            "docstring": "Request to store a client-provided trace.",
            "methods": [],
            "line": 222
          },
          {
            "name": "MismatchReport",
            "docstring": "Report a replay mismatch for operator review.",
            "methods": [],
            "line": 761
          },
          {
            "name": "MismatchResponse",
            "docstring": "Response after reporting a mismatch.",
            "methods": [],
            "line": 771
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request",
              "Response",
              "status"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "auth.jwt_auth",
            "names": [
              "JWTAuthDependency",
              "JWTConfig",
              "TokenPayload"
            ],
            "is_relative": true,
            "line": 55
          },
          {
            "module": "schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": true,
            "line": 56
          },
          {
            "module": "traces.redact",
            "names": [
              "redact_trace_data"
            ],
            "is_relative": true,
            "line": 57
          }
        ],
        "constants": [
          {
            "name": "USE_POSTGRES",
            "line": 43
          }
        ],
        "all_exports": null
      }
    ],
    "l3_adapters": [
      {
        "file_name": "export_bundle_adapter.py",
        "file_path": "backend/app/hoc/cus/logs/L3_adapters/export_bundle_adapter.py",
        "layer": "L3_adapters",
        "domain": "logs",
        "lines": 422,
        "module_docstring": "Export Bundle Adapter (L3)\n\nGenerates structured export bundles from incidents, runs, and traces\nfor evidence export, SOC2 compliance, and executive debriefs.\n\nL3 CONTRACT:\n- NO sqlalchemy imports\n- NO direct database queries\n- Delegates all data access to L6 ExportBundleStore",
        "functions": [
          {
            "name": "get_export_bundle_adapter",
            "signature": "() -> ExportBundleAdapter",
            "docstring": "Get or create ExportBundleAdapter singleton.",
            "is_async": false,
            "line": 411
          }
        ],
        "classes": [
          {
            "name": "ExportBundleAdapter",
            "docstring": "L3 Adapter for generating export bundles.\n\nTranslates between API requests and L6 store,\ncomposing bundle structures from raw data.",
            "methods": [
              "__init__",
              "create_evidence_bundle",
              "create_soc2_bundle",
              "create_executive_debrief",
              "_compute_bundle_hash",
              "_generate_attestation",
              "_assess_risk_level",
              "_generate_incident_summary",
              "_assess_business_impact",
              "_generate_recommendations"
            ],
            "line": 62
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.hoc.cus.logs.L6_drivers.export_bundle_store",
            "names": [
              "ExportBundleStore",
              "IncidentSnapshot",
              "RunSnapshot",
              "TraceSummarySnapshot",
              "TraceStepSnapshot",
              "get_export_bundle_store"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.models.export_bundles",
            "names": [
              "DEFAULT_SOC2_CONTROLS",
              "EvidenceBundle",
              "ExecutiveDebriefBundle",
              "PolicyContext",
              "SOC2Bundle",
              "TraceStepEvidence"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": [
          "ExportBundleAdapter",
          "get_export_bundle_adapter"
        ]
      }
    ],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "audit_evidence.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/audit_evidence.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 671,
        "module_docstring": "Module: audit_evidence\nPurpose: Emit compliance-grade audit for MCP tool calls.\n\nWires:\n    - Source: app/services/mcp/policy_mapper.py (policy decisions)\n    - Source: app/services/mcp/server_registry.py (server/tool info)\n    - Target: app/events (event bus) / audit storage\n\nThis module:\n    1. Emits audit events for all MCP tool invocations\n    2. Records policy decisions for compliance\n    3. Captures input/output for forensic analysis\n    4. Provides tamper-evident audit trail\n\nAcceptance Criteria:\n    - AC-143-01: All tool invocations are audited\n    - AC-143-02: Policy decisions are recorded\n    - AC-143-03: Audit events are tamper-evident\n    - AC-143-04: Sensitive data is redacted\n    - AC-143-05: Events include full context",
        "functions": [
          {
            "name": "_hash_value",
            "signature": "(value: Any) -> str",
            "docstring": "Hash a value for audit purposes.",
            "is_async": false,
            "line": 170
          },
          {
            "name": "_contains_sensitive",
            "signature": "(key: str) -> bool",
            "docstring": "Check if key name suggests sensitive data.",
            "is_async": false,
            "line": 178
          },
          {
            "name": "_redact_sensitive",
            "signature": "(data: Dict[str, Any]) -> Dict[str, Any]",
            "docstring": "Redact sensitive fields from data for logging.",
            "is_async": false,
            "line": 184
          },
          {
            "name": "get_mcp_audit_emitter",
            "signature": "() -> MCPAuditEmitter",
            "docstring": "Get or create the singleton MCPAuditEmitter.\n\nReturns:\n    MCPAuditEmitter instance",
            "is_async": false,
            "line": 628
          },
          {
            "name": "configure_mcp_audit_emitter",
            "signature": "(publisher: Optional[Any] = None) -> MCPAuditEmitter",
            "docstring": "Configure the singleton MCPAuditEmitter.\n\nArgs:\n    publisher: Event publisher to use\n\nReturns:\n    Configured MCPAuditEmitter",
            "is_async": false,
            "line": 644
          },
          {
            "name": "reset_mcp_audit_emitter",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 668
          }
        ],
        "classes": [
          {
            "name": "MCPAuditEventType",
            "docstring": "Types of MCP audit events.",
            "methods": [],
            "line": 56
          },
          {
            "name": "MCPAuditEvent",
            "docstring": "Compliance-grade audit event for MCP operations.\n\nContains full context for forensic analysis and compliance reporting.\nIncludes integrity hash for tamper detection.",
            "methods": [
              "__post_init__",
              "_compute_integrity_hash",
              "to_dict",
              "verify_integrity"
            ],
            "line": 72
          },
          {
            "name": "MCPAuditEmitter",
            "docstring": "Emitter for compliance-grade MCP audit events.\n\nThis service:\n1. Emits audit events to event bus\n2. Maintains chain of audit events (previous hash)\n3. Redacts sensitive data\n4. Provides forensic context\n\nINVARIANT: All tool invocations must be audited.",
            "methods": [
              "__init__",
              "_generate_event_id",
              "emit_tool_requested",
              "emit_tool_allowed",
              "emit_tool_denied",
              "emit_tool_started",
              "emit_tool_completed",
              "emit_tool_failed",
              "emit_server_registered",
              "emit_server_unregistered",
              "_emit",
              "_get_publisher"
            ],
            "line": 205
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [
          {
            "name": "SENSITIVE_PATTERNS",
            "line": 153
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "audit_ledger_service.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/audit_ledger_service.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 220,
        "module_docstring": "Audit Ledger Service (Sync)\n\nPURPOSE:\n    Provides sync methods to write governance events to the AuditLedger table.\n    This is the APPEND-ONLY immutable governance action log.\n\nIMPLEMENTATION NOTES:\n    Created as part of SWEEP-03 Batch 3 to provide sync audit ledger\n    operations for incident_write_engine.py which uses sync sessions.\n\nINVARIANTS:\n    - All writes are INSERT only (no UPDATE, no DELETE)\n    - Each write is atomic within the caller's transaction\n    - Events use canonical AuditEventType values",
        "functions": [
          {
            "name": "get_audit_ledger_service",
            "signature": "(session: 'Session') -> AuditLedgerService",
            "docstring": "Get an AuditLedgerService instance.\n\nArgs:\n    session: Sync database session\n\nReturns:\n    AuditLedgerService instance",
            "is_async": false,
            "line": 200
          }
        ],
        "classes": [
          {
            "name": "AuditLedgerService",
            "docstring": "Sync service for writing to the audit ledger.\n\nL5 CONTRACT:\n- Pure database writes, no business logic\n- All methods are sync (for use with sqlmodel Session)\n- Writes happen within caller's transaction",
            "methods": [
              "__init__",
              "_emit",
              "incident_acknowledged",
              "incident_resolved",
              "incident_manually_closed"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional",
              "TYPE_CHECKING"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "ActorType",
              "AuditEntityType",
              "AuditEventType",
              "AuditLedger"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "AuditLedgerService",
          "get_audit_ledger_service"
        ]
      },
      {
        "file_name": "audit_reconciler.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/audit_reconciler.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 322,
        "module_docstring": "Audit Reconciler\n\nPerforms four-way validation of expectations vs acknowledgments:\n\n1. expected \u2212 acked \u2192 missing (audit alert)\n2. acked \u2212 expected \u2192 drift (unexpected action)\n3. missing finalization \u2192 stale run (liveness violation)\n4. expectations without deadline \u2192 invalid contract\n\nThis is the core of the Runtime Audit Contract (RAC).\n\nUsage:\n    reconciler = get_audit_reconciler()\n    result = reconciler.reconcile(run_id)\n\n    if not result.is_clean:\n        # Handle issues\n        if result.has_missing:\n            alert_missing_actions(result.missing_actions)\n        if result.stale_run:\n            alert_stale_run(run_id)",
        "functions": [
          {
            "name": "get_audit_reconciler",
            "signature": "(store: Optional[AuditStore] = None) -> AuditReconciler",
            "docstring": "Get the audit reconciler singleton.\n\nArgs:\n    store: Optional audit store (only used on first call)\n\nReturns:\n    AuditReconciler instance",
            "is_async": false,
            "line": 309
          }
        ],
        "classes": [
          {
            "name": "AuditReconciler",
            "docstring": "Reconciles expectations with acknowledgments.\n\nThis is the heart of the RAC system. It performs set operations\nto identify:\n- Missing actions (expected but not acked)\n- Drift actions (acked but not expected)\n- Stale runs (finalize_run never acked)\n\nLayer: L4 (Domain Logic)\nCallers: ROK (L5), Scheduler (L5)",
            "methods": [
              "__init__",
              "reconcile",
              "check_deadline_violations",
              "get_run_audit_summary",
              "_record_metrics"
            ],
            "line": 96
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Set",
              "Tuple"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "prometheus_client",
            "names": [
              "Counter",
              "Histogram"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.general.L5_schemas.rac_models",
            "names": [
              "AuditAction",
              "AuditDomain",
              "AuditExpectation",
              "AuditStatus",
              "DomainAck",
              "ReconciliationResult"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.general.L5_engines.audit_store",
            "names": [
              "AuditStore",
              "get_audit_store"
            ],
            "is_relative": false,
            "line": 58
          }
        ],
        "constants": [
          {
            "name": "RECONCILIATION_TOTAL",
            "line": 66
          },
          {
            "name": "MISSING_ACTIONS_TOTAL",
            "line": 72
          },
          {
            "name": "DRIFT_ACTIONS_TOTAL",
            "line": 78
          },
          {
            "name": "STALE_RUNS_TOTAL",
            "line": 84
          },
          {
            "name": "RECONCILIATION_DURATION",
            "line": 89
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "certificate.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/certificate.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 386,
        "module_docstring": "M23 Certificate Service - Cryptographic Evidence of Deterministic Replay\n\nUses M4 HMAC infrastructure to create signed certificates that prove:\n1. Policy decisions were evaluated at a specific time\n2. Replay validation passed at a specific determinism level\n3. No tampering occurred between original call and validation\n\nCertificate Structure:\n- Certificate ID (UUID)\n- Original call metadata\n- Replay validation result\n- HMAC signature (using M4 infrastructure)\n- Timestamp and expiry\n\nUsage:\n    from app.services.certificate import CertificateService, CertificateRequest\n\n    service = CertificateService()\n    cert = service.create_certificate(\n        call_id=\"abc123\",\n        validation_result=replay_result,\n        level=DeterminismLevel.LOGICAL,\n    )\n\n    # Verify later\n    is_valid = service.verify_certificate(cert)",
        "functions": [],
        "classes": [
          {
            "name": "CertificateType",
            "docstring": "Types of certificates that can be issued.",
            "methods": [],
            "line": 62
          },
          {
            "name": "CertificatePayload",
            "docstring": "The signed payload of a certificate.",
            "methods": [
              "to_dict",
              "canonical_json"
            ],
            "line": 71
          },
          {
            "name": "Certificate",
            "docstring": "A signed certificate proving deterministic replay or policy evaluation.",
            "methods": [
              "to_dict",
              "to_json",
              "from_dict"
            ],
            "line": 131
          },
          {
            "name": "CertificateService",
            "docstring": "Service for creating and verifying cryptographic certificates.\n\nUses M4 HMAC infrastructure (same secret as golden file signing).",
            "methods": [
              "__init__",
              "_sign",
              "_verify_signature",
              "create_replay_certificate",
              "create_policy_audit_certificate",
              "verify_certificate",
              "export_certificate"
            ],
            "line": 180
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.hoc.cus.logs.L5_engines.replay_determinism",
            "names": [
              "DeterminismLevel",
              "ReplayResult"
            ],
            "is_relative": false,
            "line": 56
          }
        ],
        "constants": [],
        "all_exports": [
          "CertificateService",
          "Certificate",
          "CertificatePayload",
          "CertificateType"
        ]
      },
      {
        "file_name": "completeness_checker.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/completeness_checker.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 518,
        "module_docstring": "Module: completeness_checker\nPurpose: Validate evidence bundle completeness before PDF generation.\n\nEvidence PDF exports require specific fields for SOC2 compliance.\nThis module validates that all required fields are present and\nnon-empty before allowing PDF generation.\n\nRequired Fields (Standard):\n    - incident_id, tenant_id, run_id, trace_id\n    - policy_snapshot_id, termination_reason\n    - total_steps, total_tokens, total_cost_cents\n\nSOC2 Required Fields (Enhanced):\n    - control_mappings, attestation_statement\n    - compliance_period_start, compliance_period_end\n\nExports:\n    - EvidenceCompletenessError: Raised when evidence is incomplete\n    - EvidenceCompletenessChecker: Main checker class\n    - check_evidence_completeness: Quick helper function\n    - ensure_evidence_completeness: Helper that raises on incomplete",
        "functions": [
          {
            "name": "check_evidence_completeness",
            "signature": "(bundle: Any, export_type: str = 'evidence', validation_enabled: bool = True, strict_mode: bool = False) -> CompletenessCheckResponse",
            "docstring": "Quick helper to check evidence completeness.\n\nArgs:\n    bundle: Evidence bundle to check\n    export_type: Type of export\n    validation_enabled: Whether validation is enforced\n    strict_mode: Whether recommended fields are required\n\nReturns:\n    CompletenessCheckResponse with validation result",
            "is_async": false,
            "line": 471
          },
          {
            "name": "ensure_evidence_completeness",
            "signature": "(bundle: Any, export_type: str = 'evidence', validation_enabled: bool = True, strict_mode: bool = False) -> None",
            "docstring": "Quick helper to ensure evidence completeness or raise error.\n\nArgs:\n    bundle: Evidence bundle to validate\n    export_type: Type of export\n    validation_enabled: Whether validation is enforced\n    strict_mode: Whether recommended fields are required\n\nRaises:\n    EvidenceCompletenessError: If incomplete and validation enabled",
            "is_async": false,
            "line": 496
          }
        ],
        "classes": [
          {
            "name": "CompletenessCheckResult",
            "docstring": "Result of a completeness check.",
            "methods": [],
            "line": 47
          },
          {
            "name": "EvidenceCompletenessError",
            "docstring": "Raised when evidence bundle is incomplete for PDF generation.\n\nThis error indicates that required fields are missing\nand the PDF cannot be generated without them.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 89
          },
          {
            "name": "CompletenessCheckResponse",
            "docstring": "Response from a completeness check.",
            "methods": [
              "to_dict"
            ],
            "line": 121
          },
          {
            "name": "EvidenceCompletenessChecker",
            "docstring": "Checks evidence bundle completeness before PDF generation.\n\nGAP-027: Ensure evidence PDFs contain all required fields for SOC2.\n\nThe checker validates that all required fields are present\nand non-empty before allowing PDF generation.\n\nUsage:\n    checker = EvidenceCompletenessChecker(validation_enabled=True)\n\n    # Before generating PDF\n    checker.ensure_complete(bundle, \"evidence\")\n\n    # Or check without raising\n    response = checker.check(bundle, \"evidence\")\n    if not response.is_complete and response.validation_enabled:\n        handle_incomplete_evidence()",
            "methods": [
              "__init__",
              "from_governance_config",
              "validation_enabled",
              "strict_mode",
              "get_required_fields",
              "get_field_value",
              "is_field_present",
              "check",
              "ensure_complete",
              "should_allow_export",
              "get_completeness_summary"
            ],
            "line": 147
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "FrozenSet",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "evidence_facade.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/evidence_facade.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 570,
        "module_docstring": "Evidence Facade (L5 Domain Engine)\n\nThis facade provides the external interface for evidence chain and export operations.\nAll evidence APIs MUST use this facade instead of directly importing\ninternal evidence modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes evidence chain management\n- Provides unified access to evidence export\n- Single point for audit emission\n\nL2 API Routes (GAP-104, GAP-105):\n- GET /api/v1/evidence/chains (list evidence chains)\n- GET /api/v1/evidence/chains/{id} (get evidence chain)\n- POST /api/v1/evidence/chains (create evidence chain)\n- GET /api/v1/evidence/chains/{id}/verify (verify chain integrity)\n- POST /api/v1/evidence/export (export evidence)\n- GET /api/v1/evidence/exports/{id} (get export status)\n\nUsage:\n    from app.services.evidence.facade import get_evidence_facade\n\n    facade = get_evidence_facade()\n\n    # List evidence chains\n    chains = await facade.list_chains(tenant_id=\"...\")\n\n    # Export evidence\n    export = await facade.create_export(tenant_id=\"...\", chain_id=\"...\")",
        "functions": [
          {
            "name": "get_evidence_facade",
            "signature": "() -> EvidenceFacade",
            "docstring": "Get the evidence facade instance.\n\nThis is the recommended way to access evidence operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    EvidenceFacade instance",
            "is_async": false,
            "line": 557
          }
        ],
        "classes": [
          {
            "name": "EvidenceType",
            "docstring": "Evidence types.",
            "methods": [],
            "line": 66
          },
          {
            "name": "ExportFormat",
            "docstring": "Export formats.",
            "methods": [],
            "line": 75
          },
          {
            "name": "ExportStatus",
            "docstring": "Export status.",
            "methods": [],
            "line": 82
          },
          {
            "name": "EvidenceLink",
            "docstring": "A link in an evidence chain.",
            "methods": [
              "to_dict"
            ],
            "line": 91
          },
          {
            "name": "EvidenceChain",
            "docstring": "An evidence chain.",
            "methods": [
              "to_dict"
            ],
            "line": 113
          },
          {
            "name": "VerificationResult",
            "docstring": "Result of chain verification.",
            "methods": [
              "to_dict"
            ],
            "line": 139
          },
          {
            "name": "EvidenceExport",
            "docstring": "Evidence export request.",
            "methods": [
              "to_dict"
            ],
            "line": 157
          },
          {
            "name": "EvidenceFacade",
            "docstring": "Facade for evidence chain and export operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nevidence services.\n\nLayer: L4 (Domain Logic)\nCallers: evidence.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "list_chains",
              "get_chain",
              "create_chain",
              "add_evidence",
              "verify_chain",
              "_create_link",
              "_hash_data",
              "create_export",
              "get_export",
              "list_exports"
            ],
            "line": 184
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "evidence_report.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/evidence_report.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 1164,
        "module_docstring": "Evidence Report Generator - Legal-Grade PDF Export\n\nGenerates deterministic, verifiable PDF evidence reports for AI incidents.\nThis document must survive legal review, audit, and hostile questioning.\n\nFeatures:\n- Cover page with metadata\n- Executive summary for legal/leadership\n- Factual reconstruction (pure evidence)\n- Policy evaluation record\n- Decision timeline (deterministic trace)\n- Replay verification with hash matching\n- Counterfactual prevention proof\n- Remediation & controls\n- Legal attestation with verification signature",
        "functions": [
          {
            "name": "generate_evidence_report",
            "signature": "(incident_id: str, tenant_id: str, tenant_name: str, user_id: str, product_name: str, model_id: str, timestamp: str, user_input: str, context_data: Dict[str, Any], ai_output: str, policy_results: List[Dict[str, Any]], timeline_events: List[Dict[str, Any]], replay_result: Optional[Dict[str, Any]] = None, prevention_result: Optional[Dict[str, Any]] = None, root_cause: str = 'Policy enforcement gap: system asserted fact when required data was NULL.', impact_assessment: Optional[List[str]] = None, certificate: Optional[Dict[str, Any]] = None, severity: str = 'HIGH', status: str = 'RESOLVED', is_demo: bool = True) -> bytes",
            "docstring": "Convenience function to generate an evidence report.\n\nReturns:\n    PDF file as bytes",
            "is_async": false,
            "line": 1089
          }
        ],
        "classes": [
          {
            "name": "CertificateEvidence",
            "docstring": "M23: Certificate data for cryptographic proof.",
            "methods": [],
            "line": 60
          },
          {
            "name": "IncidentEvidence",
            "docstring": "Evidence data for an incident.",
            "methods": [],
            "line": 77
          },
          {
            "name": "EvidenceReportGenerator",
            "docstring": "Generates legal-grade PDF evidence reports.\n\nThe report is structured for:\n- Legal review\n- Audit compliance\n- Executive briefing\n- Technical verification",
            "methods": [
              "__init__",
              "_setup_custom_styles",
              "generate",
              "_add_footer",
              "_build_incident_snapshot",
              "_build_cover_page",
              "_build_executive_summary",
              "_build_factual_reconstruction",
              "_build_policy_evaluation",
              "_build_decision_timeline",
              "_build_replay_verification",
              "_build_certificate_section",
              "_build_prevention_proof",
              "_build_remediation",
              "_build_legal_attestation",
              "_compute_hash",
              "_compute_report_hash"
            ],
            "line": 101
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "io",
            "names": [
              "io"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "reportlab.lib",
            "names": [
              "colors"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "reportlab.lib.enums",
            "names": [
              "TA_CENTER"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "reportlab.lib.pagesizes",
            "names": [
              "letter"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "reportlab.lib.styles",
            "names": [
              "ParagraphStyle",
              "getSampleStyleSheet"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "reportlab.lib.units",
            "names": [
              "inch"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "reportlab.platypus",
            "names": [
              "HRFlowable",
              "PageBreak",
              "Paragraph",
              "SimpleDocTemplate",
              "Spacer",
              "Table",
              "TableStyle"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "logs_facade.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/logs_facade.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 1407,
        "module_docstring": "Logs Domain Facade (L5)\n\nUnified facade for all logs domain operations:\n- LLM_RUNS: envelope, trace, governance, replay, export\n- SYSTEM_LOGS: snapshot, telemetry, events, replay, audit\n- AUDIT: identity, authorization, access, integrity, exports\n\nAll responses include EvidenceMetadata per INV-LOG-META-001.\n\nL5 CONTRACT:\n- NO sqlalchemy imports\n- NO direct database queries\n- Delegates all data access to L6 LogsDomainStore",
        "functions": [
          {
            "name": "get_logs_facade",
            "signature": "() -> LogsFacade",
            "docstring": "Get the singleton LogsFacade instance.",
            "is_async": false,
            "line": 1356
          }
        ],
        "classes": [
          {
            "name": "SourceDomain",
            "docstring": "Source domain for evidence metadata.",
            "methods": [],
            "line": 64
          },
          {
            "name": "Origin",
            "docstring": "Origin of the record.",
            "methods": [],
            "line": 74
          },
          {
            "name": "EvidenceMetadataResult",
            "docstring": "Global metadata contract for all Logs responses.",
            "methods": [],
            "line": 90
          },
          {
            "name": "LLMRunRecordResult",
            "docstring": "Single LLM run record.",
            "methods": [],
            "line": 130
          },
          {
            "name": "LLMRunRecordsResult",
            "docstring": "Response envelope for LLM run records.",
            "methods": [],
            "line": 150
          },
          {
            "name": "TraceStepResult",
            "docstring": "Individual trace step.",
            "methods": [],
            "line": 160
          },
          {
            "name": "LLMRunEnvelopeResult",
            "docstring": "O1: Canonical immutable run record.",
            "methods": [],
            "line": 173
          },
          {
            "name": "LLMRunTraceResult",
            "docstring": "O2: Step-by-step trace.",
            "methods": [],
            "line": 194
          },
          {
            "name": "GovernanceEventResult",
            "docstring": "Policy interaction event.",
            "methods": [],
            "line": 205
          },
          {
            "name": "LLMRunGovernanceResult",
            "docstring": "O3: Policy interaction trace.",
            "methods": [],
            "line": 218
          },
          {
            "name": "ReplayEventResult",
            "docstring": "Replay window event.",
            "methods": [],
            "line": 228
          },
          {
            "name": "LLMRunReplayResult",
            "docstring": "O4: 60-second replay window.",
            "methods": [],
            "line": 239
          },
          {
            "name": "LLMRunExportResult",
            "docstring": "O5: Export metadata.",
            "methods": [],
            "line": 251
          },
          {
            "name": "SystemRecordResult",
            "docstring": "Single system record entry.",
            "methods": [],
            "line": 262
          },
          {
            "name": "SystemRecordsResult",
            "docstring": "Response envelope for system records.",
            "methods": [],
            "line": 277
          },
          {
            "name": "SystemSnapshotResult",
            "docstring": "O1: Environment snapshot.",
            "methods": [],
            "line": 287
          },
          {
            "name": "TelemetryStubResult",
            "docstring": "O2: Telemetry stub response.",
            "methods": [],
            "line": 301
          },
          {
            "name": "SystemEventResult",
            "docstring": "System event record.",
            "methods": [],
            "line": 314
          },
          {
            "name": "SystemEventsResult",
            "docstring": "O3: Infra events affecting run.",
            "methods": [],
            "line": 328
          },
          {
            "name": "SystemReplayResult",
            "docstring": "O4: Infra replay window.",
            "methods": [],
            "line": 338
          },
          {
            "name": "SystemAuditResult",
            "docstring": "O5: Infra attribution record.",
            "methods": [],
            "line": 349
          },
          {
            "name": "AuditLedgerItemResult",
            "docstring": "Single audit ledger entry.",
            "methods": [],
            "line": 358
          },
          {
            "name": "AuditLedgerDetailResult",
            "docstring": "Audit ledger entry with state snapshots.",
            "methods": [],
            "line": 372
          },
          {
            "name": "AuditLedgerListResult",
            "docstring": "Response envelope for audit ledger.",
            "methods": [],
            "line": 389
          },
          {
            "name": "IdentityEventResult",
            "docstring": "Identity lifecycle event.",
            "methods": [],
            "line": 399
          },
          {
            "name": "AuditIdentityResult",
            "docstring": "O1: Identity lifecycle.",
            "methods": [],
            "line": 410
          },
          {
            "name": "AuthorizationDecisionResult",
            "docstring": "Authorization decision record.",
            "methods": [],
            "line": 419
          },
          {
            "name": "AuditAuthorizationResult",
            "docstring": "O2: Access decisions.",
            "methods": [],
            "line": 432
          },
          {
            "name": "AccessEventResult",
            "docstring": "Log access event.",
            "methods": [],
            "line": 441
          },
          {
            "name": "AuditAccessResult",
            "docstring": "O3: Log access audit.",
            "methods": [],
            "line": 454
          },
          {
            "name": "IntegrityCheckResult",
            "docstring": "Integrity verification record.",
            "methods": [],
            "line": 463
          },
          {
            "name": "AuditIntegrityResult",
            "docstring": "O4: Tamper detection.",
            "methods": [],
            "line": 473
          },
          {
            "name": "ExportRecordResult",
            "docstring": "Export record.",
            "methods": [],
            "line": 481
          },
          {
            "name": "AuditExportsResult",
            "docstring": "O5: Compliance exports.",
            "methods": [],
            "line": 495
          },
          {
            "name": "LogsFacade",
            "docstring": "Unified facade for all Logs domain operations.\n\nL4 CONTRACT:\n- Composition only - delegates to L6 driver\n- NO sqlalchemy imports\n- NO direct DB queries",
            "methods": [
              "__init__",
              "list_llm_run_records",
              "get_llm_run_envelope",
              "get_llm_run_trace",
              "get_llm_run_governance",
              "get_llm_run_replay",
              "get_llm_run_export",
              "list_system_records",
              "get_system_snapshot",
              "get_system_telemetry",
              "get_system_events",
              "get_system_replay",
              "get_system_audit",
              "list_audit_entries",
              "get_audit_entry",
              "get_audit_identity",
              "get_audit_authorization",
              "get_audit_access",
              "get_audit_integrity",
              "get_audit_exports",
              "_snapshot_to_record_result"
            ],
            "line": 508
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.logs.L6_drivers.logs_domain_store",
            "names": [
              "AuditLedgerSnapshot",
              "LLMRunSnapshot",
              "LogsDomainStore",
              "LogExportSnapshot",
              "QueryResult",
              "SystemRecordSnapshot",
              "TraceStepSnapshot",
              "get_logs_domain_store"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": [
          "LogsFacade",
          "get_logs_facade",
          "SourceDomain",
          "Origin",
          "EvidenceMetadataResult",
          "LLMRunRecordResult",
          "LLMRunRecordsResult",
          "TraceStepResult",
          "LLMRunEnvelopeResult",
          "LLMRunTraceResult",
          "GovernanceEventResult",
          "LLMRunGovernanceResult",
          "ReplayEventResult",
          "LLMRunReplayResult",
          "LLMRunExportResult",
          "SystemRecordResult",
          "SystemRecordsResult",
          "SystemSnapshotResult",
          "TelemetryStubResult",
          "SystemEventResult",
          "SystemEventsResult",
          "SystemReplayResult",
          "SystemAuditResult",
          "AuditLedgerItemResult",
          "AuditLedgerDetailResult",
          "AuditLedgerListResult",
          "IdentityEventResult",
          "AuditIdentityResult",
          "AuthorizationDecisionResult",
          "AuditAuthorizationResult",
          "AccessEventResult",
          "AuditAccessResult",
          "IntegrityCheckResult",
          "AuditIntegrityResult",
          "ExportRecordResult",
          "AuditExportsResult"
        ]
      },
      {
        "file_name": "logs_read_engine.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/logs_read_engine.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 215,
        "module_docstring": "Logs Read Engine (L5)\n\nThis service provides all READ operations for the Logs/Traces domain.\nIt sits between L3 (CustomerLogsAdapter) and L6 (PostgresTraceStore).\n\nL3 (Adapter) \u2192 L4 (this service) \u2192 L6 (PostgresTraceStore)\n\nResponsibilities:\n- Query traces with tenant isolation\n- Get trace details\n- Get trace counts\n- Search traces with filters\n- No write operations (writes go through runtime)\n\nReference: PIN-281 (L3 Adapter Closure - PHASE 1)",
        "functions": [
          {
            "name": "get_logs_read_service",
            "signature": "() -> LogsReadService",
            "docstring": "Factory function to get LogsReadService instance.\n\nThis is the ONLY way L3 should obtain a logs read service.",
            "is_async": false,
            "line": 200
          }
        ],
        "classes": [
          {
            "name": "LogsReadService",
            "docstring": "L4 service for logs/trace read operations.\n\nProvides tenant-scoped, bounded reads for the Logs domain.\nAll L3 adapters must use this service for log reads.",
            "methods": [
              "__init__",
              "_get_store",
              "search_traces",
              "get_trace",
              "get_trace_count",
              "get_trace_by_root_hash",
              "list_traces"
            ],
            "line": 51
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.traces.models",
            "names": [
              "TraceRecord",
              "TraceSummary"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.traces.pg_store",
            "names": [
              "PostgresTraceStore",
              "get_postgres_trace_store"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": [
          "LogsReadService",
          "get_logs_read_service"
        ]
      },
      {
        "file_name": "mapper.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/mapper.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 273,
        "module_docstring": "Module: mapper\nPurpose: Map incidents and evidence to SOC2 controls.\n\nProvides intelligent mapping of incident categories and evidence\nto the appropriate SOC2 Trust Service Criteria controls.\n\nExports:\n    - SOC2ControlMapper: Maps incidents to controls\n    - get_control_mappings_for_incident: Main entry point",
        "functions": [
          {
            "name": "get_control_mappings_for_incident",
            "signature": "(incident_category: str, incident_data: dict[str, Any]) -> list[dict[str, Any]]",
            "docstring": "Get SOC2 control mappings for an incident (GAP-025 main entry point).\n\nThis is the primary function for obtaining SOC2 control mappings\nfor incident exports and compliance reporting.\n\nArgs:\n    incident_category: Category of the incident\n    incident_data: Incident data dict\n\nReturns:\n    List of control mapping dicts suitable for API responses",
            "is_async": false,
            "line": 254
          }
        ],
        "classes": [
          {
            "name": "SOC2ControlMapper",
            "docstring": "Maps incidents to relevant SOC2 controls.\n\nProvides intelligent mapping based on incident category,\nseverity, and available evidence.\n\nGAP-025: Complete SOC2 control objective mapping.",
            "methods": [
              "__init__",
              "map_incident_to_controls",
              "_create_mapping",
              "_determine_compliance_status",
              "get_all_applicable_controls"
            ],
            "line": 87
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.hoc.cus.general.L5_engines.control_registry",
            "names": [
              "SOC2ComplianceStatus",
              "SOC2Control",
              "SOC2ControlMapping",
              "SOC2ControlRegistry",
              "get_control_registry"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "panel_response_assembler.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/panel_response_assembler.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 265,
        "module_docstring": "Panel Response Assembler \u2014 Assemble spec-compliant response envelope\n\nConstructs the final JSON response structure from evaluated slots,\nconsistency results, and metadata.",
        "functions": [
          {
            "name": "create_response_assembler",
            "signature": "(adapter_version: Optional[str] = None, schema_version: Optional[str] = None) -> PanelResponseAssembler",
            "docstring": "Create response assembler.",
            "is_async": false,
            "line": 257
          }
        ],
        "classes": [
          {
            "name": "PanelResponseAssembler",
            "docstring": "Assembles the final panel response envelope.\n\nUsage:\n    assembler = PanelResponseAssembler(adapter_version, schema_version)\n    response = assembler.assemble(panel_id, slots, consistency, eval_time_ms)",
            "methods": [
              "__init__",
              "assemble",
              "_slot_to_dict",
              "_aggregate_verification",
              "_determine_panel_state",
              "_determine_panel_authority",
              "assemble_error"
            ],
            "line": 41
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "dataclasses",
            "names": [
              "asdict"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "panel_consistency_checker",
            "names": [
              "ConsistencyCheckResult"
            ],
            "is_relative": true,
            "line": 30
          },
          {
            "module": "panel_types",
            "names": [
              "Authority",
              "PanelSlotResult",
              "SlotState",
              "VerificationSignals"
            ],
            "is_relative": true,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "pdf_renderer.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/pdf_renderer.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 687,
        "module_docstring": "PDF Renderer Service\n\nRenders export bundles to PDF format for compliance exports,\nexecutive debriefs, and evidence documentation.\n\nKey Responsibilities:\n1. Render EvidenceBundle to detailed PDF\n2. Render SOC2Bundle with control attestations\n3. Render ExecutiveDebriefBundle for leadership\n\nUses reportlab for PDF generation (same library as evidence_report.py).",
        "functions": [
          {
            "name": "get_pdf_renderer",
            "signature": "() -> PDFRenderer",
            "docstring": "Get or create PDFRenderer singleton.",
            "is_async": false,
            "line": 682
          }
        ],
        "classes": [
          {
            "name": "PDFRenderer",
            "docstring": "Render export bundles to PDF format.",
            "methods": [
              "__init__",
              "_setup_styles",
              "render_evidence_pdf",
              "render_soc2_pdf",
              "render_executive_debrief_pdf",
              "_build_evidence_cover",
              "_build_evidence_summary",
              "_build_trace_timeline",
              "_build_policy_section",
              "_build_integrity_section",
              "_build_soc2_cover",
              "_build_control_mappings",
              "_build_attestation",
              "_build_exec_cover",
              "_build_exec_summary",
              "_build_recommendations",
              "_build_exec_metrics"
            ],
            "line": 63
          }
        ],
        "imports": [
          {
            "module": "io",
            "names": [
              "io"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "reportlab.lib",
            "names": [
              "colors"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "reportlab.lib.enums",
            "names": [
              "TA_CENTER",
              "TA_LEFT"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "reportlab.lib.pagesizes",
            "names": [
              "letter"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "reportlab.lib.styles",
            "names": [
              "ParagraphStyle",
              "getSampleStyleSheet"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "reportlab.lib.units",
            "names": [
              "inch"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "reportlab.platypus",
            "names": [
              "HRFlowable",
              "PageBreak",
              "Paragraph",
              "SimpleDocTemplate",
              "Spacer",
              "Table",
              "TableStyle"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.models.export_bundles",
            "names": [
              "EvidenceBundle",
              "ExecutiveDebriefBundle",
              "SOC2Bundle"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "redact.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/redact.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 267,
        "module_docstring": "PII Redaction Utility for Trace Storage\nM8 Deliverable: Secure trace storage with PII masking\n\nRedacts sensitive data from traces before storage:\n- Passwords, API keys, tokens\n- Credit card numbers\n- Email addresses\n- Custom patterns via configuration",
        "functions": [
          {
            "name": "redact_json_string",
            "signature": "(json_str: str) -> str",
            "docstring": "Apply PII redaction patterns to a JSON string.\n\nArgs:\n    json_str: JSON string to redact\n\nReturns:\n    Redacted JSON string",
            "is_async": false,
            "line": 108
          },
          {
            "name": "redact_dict",
            "signature": "(data: dict[str, Any], depth: int = 0, max_depth: int = 20) -> dict[str, Any]",
            "docstring": "Recursively redact sensitive fields in a dictionary.\n\nArgs:\n    data: Dictionary to redact\n    depth: Current recursion depth\n    max_depth: Maximum recursion depth\n\nReturns:\n    Redacted dictionary (new copy)",
            "is_async": false,
            "line": 124
          },
          {
            "name": "redact_list",
            "signature": "(data: list[Any], depth: int = 0, max_depth: int = 20) -> list[Any]",
            "docstring": "Recursively redact sensitive fields in a list.",
            "is_async": false,
            "line": 157
          },
          {
            "name": "redact_string_value",
            "signature": "(value: str) -> str",
            "docstring": "Redact sensitive patterns in a string value.",
            "is_async": false,
            "line": 176
          },
          {
            "name": "redact_trace_data",
            "signature": "(trace: dict[str, Any]) -> dict[str, Any]",
            "docstring": "Redact PII from a complete trace object.\n\nThis is the main entry point for trace redaction.\nCreates a deep copy to avoid modifying the original.\n\nArgs:\n    trace: Trace object to redact\n\nReturns:\n    Redacted trace (new copy)",
            "is_async": false,
            "line": 200
          },
          {
            "name": "is_sensitive_field",
            "signature": "(field_name: str) -> bool",
            "docstring": "Check if a field name indicates sensitive data.",
            "is_async": false,
            "line": 255
          },
          {
            "name": "add_sensitive_field",
            "signature": "(field_name: str) -> None",
            "docstring": "Add a custom field name to the sensitive fields set.",
            "is_async": false,
            "line": 260
          },
          {
            "name": "add_redaction_pattern",
            "signature": "(pattern: str, replacement: str) -> None",
            "docstring": "Add a custom redaction pattern.",
            "is_async": false,
            "line": 265
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "copy",
            "names": [
              "copy"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [
          {
            "name": "PII_PATTERNS",
            "line": 44
          },
          {
            "name": "SENSITIVE_FIELD_NAMES",
            "line": 79
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "replay_determinism.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/replay_determinism.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 519,
        "module_docstring": "Replay Determinism Service - Defines and Enforces Determinism Semantics\n\nWatchpoint #2: Replay Determinism Across Model Versions\n\nThis service addresses the fundamental tension between:\n- \"Logical Determinism\": Same policy decision given same context\n- \"Byte-for-byte Determinism\": Exact same output bytes\n\nKey Insight: As upstream LLM models drift (model updates, temperature changes),\nwe cannot guarantee byte-for-byte determinism. However, we CAN guarantee:\n\n1. Policy decisions are deterministic (same rules -> same enforcement)\n2. Replay validates logical equivalence, not exact match\n3. Version tracking allows audit trail of what ran when\n\nDeterminism Levels:\n- STRICT: Byte-for-byte match required (only for local/cached responses)\n- LOGICAL: Policy decision match required (default for LLM calls)\n- SEMANTIC: Meaning-equivalent match (for content validation)\n\nUsage:\n    from app.hoc.cus.logs.L5_engines.replay_determinism import (\n        ReplayValidator,\n        DeterminismLevel,\n        ReplayResult\n    )\n\n    validator = ReplayValidator()\n    result = validator.validate_replay(\n        original_call=original,\n        replayed_call=replayed,\n        level=DeterminismLevel.LOGICAL\n    )",
        "functions": [],
        "classes": [
          {
            "name": "DeterminismLevel",
            "docstring": "Levels of determinism for replay validation.\n\nSTRICT: Byte-for-byte exact match\n    - Use for: Cached responses, local transformations\n    - Fails if: Any byte differs\n\nLOGICAL: Policy decision equivalence\n    - Use for: LLM calls with policy enforcement\n    - Passes if: Same policy triggered, same action taken\n    - Fails if: Different policy decision\n\nSEMANTIC: Meaning-equivalent match\n    - Use for: Content validation, safety checks\n    - Passes if: Semantic meaning preserved\n    - Fails if: Meaning fundamentally changed",
            "methods": [],
            "line": 68
          },
          {
            "name": "ModelVersion",
            "docstring": "Track the model version used for a call.",
            "methods": [
              "to_dict",
              "from_dict"
            ],
            "line": 96
          },
          {
            "name": "PolicyDecision",
            "docstring": "Record of a policy enforcement decision.",
            "methods": [
              "to_dict"
            ],
            "line": 129
          },
          {
            "name": "ReplayMatch",
            "docstring": "Result of replay comparison.",
            "methods": [],
            "line": 153
          },
          {
            "name": "ReplayResult",
            "docstring": "Result of replay validation.",
            "methods": [
              "to_dict"
            ],
            "line": 163
          },
          {
            "name": "CallRecord",
            "docstring": "Record of a call for replay validation.",
            "methods": [
              "to_dict"
            ],
            "line": 204
          },
          {
            "name": "ReplayValidator",
            "docstring": "Validates replay determinism at configurable levels.\n\nThe key insight is that LLM outputs will drift over time as models\nare updated. We don't try to fight this - instead we:\n\n1. Track model versions explicitly\n2. Define determinism in terms of POLICY DECISIONS, not raw output\n3. Provide clear audit trails when drift is detected\n4. Allow operators to choose their determinism level",
            "methods": [
              "__init__",
              "validate_replay",
              "_detect_model_drift",
              "_compare_policies",
              "_semantic_equivalent",
              "_level_meets_requirement",
              "hash_content"
            ],
            "line": 242
          },
          {
            "name": "ReplayContextBuilder",
            "docstring": "Builds replay context from API calls.\n\nUsed to capture all information needed for replay validation:\n- Request details\n- Response details\n- Model version\n- Policy decisions",
            "methods": [
              "__init__",
              "build_call_record"
            ],
            "line": 434
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 60
          }
        ],
        "constants": [],
        "all_exports": [
          "DeterminismLevel",
          "ModelVersion",
          "PolicyDecision",
          "ReplayMatch",
          "ReplayResult",
          "CallRecord",
          "ReplayValidator",
          "ReplayContextBuilder"
        ]
      },
      {
        "file_name": "trace_facade.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/trace_facade.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 297,
        "module_docstring": "Trace Domain Facade (L5 Domain Engine)\n\nThis facade provides the external interface to the Trace domain.\nIt wraps TraceStore operations and emits RAC acknowledgments.\n\nWhy This Facade Exists (PIN-454):\n- Centralized RAC acknowledgment emission for trace operations\n- Clean interface between L5 execution and L6 platform\n- Domain encapsulation for trace operations\n\nRAC Integration:\n- Emits START_TRACE ack after trace creation\n- Emits COMPLETE_TRACE ack after trace completion\n\nUsage:\n    from app.services.observability.trace_facade import get_trace_facade\n\n    facade = get_trace_facade()\n    trace_id = await facade.start_trace(run_id, tenant_id, agent_id)",
        "functions": [
          {
            "name": "get_trace_facade",
            "signature": "(trace_store = None) -> TraceFacade",
            "docstring": "Get the trace facade singleton.\n\nArgs:\n    trace_store: Optional trace store (only used on first call)\n\nReturns:\n    TraceFacade instance",
            "is_async": false,
            "line": 284
          }
        ],
        "classes": [
          {
            "name": "TraceFacade",
            "docstring": "Facade for trace domain operations.\n\nWraps TraceStore (L6) operations and emits RAC acknowledgments.\n\nLayer: L4 (Domain Logic)\nCallers: RunRunner (L5), ObservabilityGuard (L5)",
            "methods": [
              "__init__",
              "_store",
              "start_trace",
              "complete_trace",
              "add_step",
              "_emit_ack"
            ],
            "line": 54
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [
          {
            "name": "RAC_ENABLED",
            "line": 51
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "traces_metrics.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/traces_metrics.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 297,
        "module_docstring": "Prometheus Metrics for AOS Traces API\n\nM8 Deliverable: Comprehensive observability for trace operations.\n\nMetrics:\n- aos_trace_request_duration_seconds: Histogram of trace API latencies\n- aos_trace_requests_total: Counter of trace requests by operation/status\n- aos_trace_parity_status: Gauge for parity check results (1=pass, 0=fail)\n- aos_replay_enforcement_total: Counter of replay enforcement outcomes\n- aos_idempotency_total: Counter of idempotency check outcomes",
        "functions": [
          {
            "name": "get_traces_metrics",
            "signature": "() -> TracesMetrics",
            "docstring": "Get or create global traces metrics instance.",
            "is_async": false,
            "line": 235
          },
          {
            "name": "instrument_trace_request",
            "signature": "(operation: str)",
            "docstring": "Decorator to instrument trace API endpoints.",
            "is_async": false,
            "line": 243
          },
          {
            "name": "instrument_replay_check",
            "signature": "(func: Callable) -> Callable",
            "docstring": "Decorator to instrument replay enforcement.",
            "is_async": false,
            "line": 261
          },
          {
            "name": "instrument_parity_check",
            "signature": "(func: Callable) -> Callable",
            "docstring": "Decorator to instrument parity checks.",
            "is_async": false,
            "line": 281
          }
        ],
        "classes": [
          {
            "name": "TracesMetrics",
            "docstring": "Centralized metrics manager for traces API.",
            "methods": [
              "__init__",
              "measure_request",
              "record_trace_stored",
              "record_replay_enforcement",
              "record_idempotency_check",
              "record_parity_check",
              "measure_storage"
            ],
            "line": 176
          }
        ],
        "imports": [
          {
            "module": "functools",
            "names": [
              "functools"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "contextlib",
            "names": [
              "contextmanager"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Callable",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [
          {
            "name": "TRACE_LATENCY_HISTOGRAM",
            "line": 87
          },
          {
            "name": "TRACE_REQUESTS_COUNTER",
            "line": 98
          },
          {
            "name": "TRACE_PARITY_GAUGE",
            "line": 108
          },
          {
            "name": "REPLAY_ENFORCEMENT_COUNTER",
            "line": 114
          },
          {
            "name": "IDEMPOTENCY_COUNTER",
            "line": 124
          },
          {
            "name": "TRACE_STEPS_HISTOGRAM",
            "line": 130
          },
          {
            "name": "TRACE_SIZE_HISTOGRAM",
            "line": 141
          },
          {
            "name": "PARITY_FAILURES_COUNTER",
            "line": 152
          },
          {
            "name": "TRACE_STORAGE_LATENCY",
            "line": 159
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "traces_models.py",
        "file_path": "backend/app/hoc/cus/logs/L5_engines/traces_models.py",
        "layer": "L5_engines",
        "domain": "logs",
        "lines": 420,
        "module_docstring": "Trace Models for AOS\nM6 Deliverable: Run traces with correlation IDs\n\nThese models define the structure of execution traces used for:\n- Debugging and inspection\n- Replay verification\n- Determinism testing\n\nDeterminism Invariant (PIN-126):\n- Given the same trace input, replay must produce identical output hash\n- Or fail loudly with a classified reason",
        "functions": [
          {
            "name": "_normalize_for_determinism",
            "signature": "(value: Any) -> Any",
            "docstring": "Normalize a value for deterministic hashing.\n\nHandles:\n- Floats: Round to 6 decimal places to avoid precision drift\n- Dicts: Recursively normalize values\n- Lists: Recursively normalize elements\n- Other types: Pass through unchanged",
            "is_async": false,
            "line": 42
          },
          {
            "name": "compare_traces",
            "signature": "(original: TraceRecord, replay: TraceRecord) -> ParityResult",
            "docstring": "Compare two traces to verify replay parity.\n\nChecks:\n- Same number of steps\n- Same skill calls in same order\n- Same parameters\n- Same status (success/failure)\n- Same retry counts\n\nDoes NOT check:\n- outcome_data (external responses vary)\n- timestamps (always different)\n- duration_ms (timing varies)\n- cost_cents (may vary with pricing changes)",
            "is_async": false,
            "line": 353
          }
        ],
        "classes": [
          {
            "name": "TraceStatus",
            "docstring": "Status of a trace step.",
            "methods": [],
            "line": 61
          },
          {
            "name": "TraceStep",
            "docstring": "A single step in an execution trace.\n\nCaptures everything needed to replay and verify determinism.",
            "methods": [
              "to_dict",
              "from_dict",
              "determinism_hash"
            ],
            "line": 71
          },
          {
            "name": "TraceSummary",
            "docstring": "Summary of a trace for listing purposes.\n\nInflection Fields (BACKEND_REMEDIATION_PLAN GAP-003):\n- violation_step_index: Step where policy violation occurred\n- violation_timestamp: When the violation was detected\n- violation_policy_id: ID of the violated policy\n- violation_reason: Human-readable violation description",
            "methods": [
              "to_dict"
            ],
            "line": 152
          },
          {
            "name": "TraceRecord",
            "docstring": "Complete trace record with all steps.\n\nUsed for replay verification and debugging.\n\nv1.1 Determinism fields:\n- seed: Random seed for deterministic simulation\n- frozen_timestamp: Frozen time for deterministic context\n- root_hash: Merkle root of deterministic fields (for replay verification)\n\nv1.2 Schema versioning (PIN-126):\n- SCHEMA_VERSION: Version of trace format for compatibility checks\n- schema_version in to_dict(): Included in serialization\n- checksum: determinism_signature() for integrity verification",
            "methods": [
              "total_cost_cents",
              "total_duration_ms",
              "success_count",
              "failure_count",
              "to_dict",
              "from_dict",
              "to_summary",
              "determinism_signature"
            ],
            "line": 206
          },
          {
            "name": "ParityResult",
            "docstring": "Result of comparing two traces for replay parity.",
            "methods": [
              "to_dict"
            ],
            "line": 333
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "ClassVar"
            ],
            "is_relative": false,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [],
    "l5_other": [
      {
        "file_name": "audit_engine.py",
        "file_path": "backend/app/hoc/cus/logs/L5_support/CRM/engines/audit_engine.py",
        "layer": "L5_other",
        "domain": "logs",
        "lines": 888,
        "module_docstring": "Part-2 Governance Audit Service (L8)\n\nVerifies that job execution matched contract intent.\n\nAudit is:\n- Post-execution (runs after job completes)\n- Deterministic (same evidence \u2192 same verdict)\n- Authoritative (verdicts cannot be overridden)\n- Mandatory (no rollout without audit)\n\nInvariants:\n- AUDIT-001: All completed jobs require audit\n- AUDIT-002: PASS required for COMPLETED\n- AUDIT-003: FAIL triggers rollback\n- AUDIT-004: Verdicts are immutable\n- AUDIT-005: Evidence is preserved\n- AUDIT-006: Health snapshots required\n\nReference: PIN-295, GOVERNANCE_AUDIT_MODEL.md, part2-design-v1",
        "functions": [
          {
            "name": "audit_result_to_record",
            "signature": "(result: AuditResult) -> dict[str, Any]",
            "docstring": "Convert AuditResult to database record format.\n\nThis is what gets persisted.",
            "is_async": false,
            "line": 803
          },
          {
            "name": "create_audit_input_from_evidence",
            "signature": "(job_id: UUID, contract_id: UUID, job_status: str, contract_scope: list[str], proposed_changes: dict[str, Any], execution_result: dict[str, Any], activation_window_start: Optional[datetime] = None, activation_window_end: Optional[datetime] = None) -> AuditInput",
            "docstring": "Create AuditInput from job execution evidence.\n\nHelper to transform evidence into audit-ready format.",
            "is_async": false,
            "line": 838
          }
        ],
        "classes": [
          {
            "name": "CheckResult",
            "docstring": "Result of an individual audit check.",
            "methods": [],
            "line": 75
          },
          {
            "name": "AuditCheck",
            "docstring": "Result of a single audit check.\n\nEach check answers one question about execution integrity.",
            "methods": [],
            "line": 89
          },
          {
            "name": "AuditInput",
            "docstring": "Input to the audit process.\n\nThis is frozen evidence from job execution.\nThe auditor cannot modify this.",
            "methods": [],
            "line": 105
          },
          {
            "name": "AuditResult",
            "docstring": "Complete audit result with all checks and final verdict.\n\nThis is what the audit produces.",
            "methods": [],
            "line": 130
          },
          {
            "name": "AuditChecks",
            "docstring": "Individual audit check implementations.\n\nEach check answers one specific question about execution integrity.\nChecks are stateless and deterministic.",
            "methods": [
              "check_scope_compliance",
              "check_health_preservation",
              "_is_health_degraded",
              "check_execution_fidelity",
              "check_timing_compliance",
              "check_rollback_availability",
              "check_signal_consistency",
              "check_no_unauthorized_mutations"
            ],
            "line": 159
          },
          {
            "name": "AuditService",
            "docstring": "Part-2 Governance Audit Service (L8)\n\nVerifies that job execution matched contract intent.\n\nKey Properties (GOVERNANCE_AUDIT_MODEL.md):\n- Post-execution verification\n- Deterministic verdicts\n- Authoritative and final\n- Cannot modify execution\n\nInvariants:\n- AUDIT-001: All completed jobs require audit\n- AUDIT-002: PASS required for COMPLETED\n- AUDIT-003: FAIL triggers rollback\n- AUDIT-004: Verdicts are immutable\n- AUDIT-005: Evidence is preserved\n- AUDIT-006: Health snapshots required\n\nUsage:\n    auditor = AuditService()\n    result = auditor.audit(audit_input)",
            "methods": [
              "__init__",
              "version",
              "audit",
              "_run_all_checks",
              "_determine_verdict"
            ],
            "line": 576
          },
          {
            "name": "RolloutGate",
            "docstring": "Gate that determines if rollout is authorized.\n\nThis is a simple policy enforcer:\n- PASS verdict \u2192 rollout authorized\n- FAIL verdict \u2192 rollout blocked\n- INCONCLUSIVE verdict \u2192 rollout blocked\n\nThe gate does NOT modify the audit or verdict.",
            "methods": [
              "is_rollout_authorized",
              "get_rollout_status"
            ],
            "line": 733
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "uuid",
            "names": [
              "UUID",
              "uuid4"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.models.contract",
            "names": [
              "AuditVerdict"
            ],
            "is_relative": false,
            "line": 64
          }
        ],
        "constants": [
          {
            "name": "AUDIT_SERVICE_VERSION",
            "line": 67
          }
        ],
        "all_exports": null
      }
    ],
    "l6_drivers": [
      {
        "file_name": "audit_ledger_service_async.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/audit_ledger_service_async.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 329,
        "module_docstring": "Audit Ledger Service (Async)\n\nProvides async methods to write governance events to the AuditLedger table.\nThis is the APPEND-ONLY immutable governance action log.\n\nINVARIANTS:\n- All writes are INSERT only (no UPDATE, no DELETE)\n- Each write is atomic within the caller's transaction\n- Events use canonical AuditEventType values",
        "functions": [
          {
            "name": "get_audit_ledger_service_async",
            "signature": "(session: AsyncSession) -> AuditLedgerServiceAsync",
            "docstring": "Get an AuditLedgerServiceAsync instance.\n\nArgs:\n    session: Async database session\n\nReturns:\n    AuditLedgerServiceAsync instance",
            "is_async": false,
            "line": 309
          }
        ],
        "classes": [
          {
            "name": "AuditLedgerServiceAsync",
            "docstring": "Async service for writing to the audit ledger.\n\nL6 CONTRACT:\n- Pure database writes, no business logic\n- All methods are async (for use with AsyncSession)\n- Writes happen within caller's transaction",
            "methods": [
              "__init__",
              "_emit",
              "limit_created",
              "limit_updated",
              "limit_breached",
              "policy_rule_created",
              "policy_rule_modified",
              "policy_rule_retired",
              "policy_proposal_approved",
              "policy_proposal_rejected"
            ],
            "line": 48
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "ActorType",
              "AuditEntityType",
              "AuditEventType",
              "AuditLedger"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": [
          "AuditLedgerServiceAsync",
          "get_audit_ledger_service_async"
        ]
      },
      {
        "file_name": "bridges_driver.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/bridges_driver.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 104,
        "module_docstring": "M25 Bridges Driver\n\nDatabase operations for integration bridge audit trails.\n\nFROZEN: 2025-12-23\nDo NOT modify without explicit approval.",
        "functions": [
          {
            "name": "record_policy_activation",
            "signature": "(db_factory, policy_id: str, source_pattern_id: str, source_recovery_id: str, confidence: float, approval_path: str, loop_trace_id: str, tenant_id: str) -> PolicyActivationAudit",
            "docstring": "Record policy activation for audit trail.\n\nEvery ACTIVE policy must have an audit record.",
            "is_async": true,
            "line": 42
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "schemas.audit_schemas",
            "names": [
              "PolicyActivationAudit"
            ],
            "is_relative": true,
            "line": 36
          },
          {
            "module": "schemas.loop_events",
            "names": [
              "ConfidenceCalculator"
            ],
            "is_relative": true,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "capture.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/capture.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 869,
        "module_docstring": "Taxonomy Evidence Capture Service (v1.1)\n\nSingle entry point for all governance taxonomy evidence writes (Classes B-J).\n\nTransaction Boundary: L6 drivers DO NOT commit.\nThe caller (L5 engine or L4 coordinator) owns the transaction.\nAll functions receive session from caller and only call session.execute().\n\nRules:\n- All taxonomy writes go through this file\n- All functions require ExecutionContext (except integrity)\n- All functions require Session (caller owns transaction)\n- No context \u2192 No evidence (hard failure, not best-effort)\n- No business logic - thin DB writes only\n- No inference - fields must be provided explicitly\n- Best-effort semantics for DB writes - failures logged, not blocking\n\nArchitecture:\n- Layer 1 (Operational): contracts.decision_records, routing_decisions, etc.\n- Layer 2 (Governance): activity_evidence, policy_decisions, provider_evidence, etc.\n- Layer 3 (Integrity): integrity_evidence (terminal-only seal)\n\nThis file serves Layer 2 and Layer 3.\n\nv1.1 Changes:\n- compute_integrity() now delegates to compute_integrity_v2() (split architecture)\n- IntegrityAssembler gathers facts, IntegrityEvaluator applies policy\n- Backward compatible: returns same dict structure with extra fields\n\nv1.2 Changes (HOC Authority Enforcement):\n- All functions now require session parameter (caller owns transaction)\n- Removed all conn.commit() / session.commit() calls\n- Removed create_engine usage (session provided by caller)",
        "functions": [
          {
            "name": "_assert_context_exists",
            "signature": "(ctx: ExecutionContext, evidence_type: str) -> None",
            "docstring": "Hard guard: Fail fast if context is None.\n\nPhase-1 Closure (PIN-405):\nThis guard closes the evidence forgery vector by ensuring no evidence\ncan be captured without valid execution context.\n\nRaises:\n    EvidenceContextError: If ctx is None (blocks execution)",
            "is_async": false,
            "line": 102
          },
          {
            "name": "_record_capture_failure",
            "signature": "(session: Session, run_id: str, evidence_type: str, failure_reason: str, error_message: Optional[str] = None, resolution: Optional[str] = None) -> None",
            "docstring": "Record an evidence capture failure for later integrity reporting.\n\nWatch-out #3: Best-effort evidence failures must surface in integrity.\n\nCategory C3: Failures have resolution semantics:\n- transient: May recover with retry\n- permanent: Cannot recover\n- superseded: Later capture succeeded\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    run_id: Run identifier (scope)\n    evidence_type: Evidence class (B/D/G/H/I scope)\n    failure_reason: Why capture failed\n    error_message: Detailed error for debugging\n    resolution: Override default resolution (transient/permanent/superseded)\n\nThis is a fire-and-forget operation - failures here are logged but don't\npropagate.",
            "is_async": false,
            "line": 181
          },
          {
            "name": "_hash_content",
            "signature": "(content: str) -> str",
            "docstring": "Generate SHA256 fingerprint of content.",
            "is_async": false,
            "line": 249
          },
          {
            "name": "capture_environment_evidence",
            "signature": "(session: Session, ctx: ExecutionContext) -> Optional[str]",
            "docstring": "Capture environment evidence (Class H) at run creation.\n\nCalled once per run, immediately after run is persisted.\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    ctx: ExecutionContext (required)\n    sdk_mode: SDK invocation mode (inline, async, degraded, offline)\n    execution_environment: Environment context (prod, staging, dev, sandbox)\n    sdk_version: SDK version string\n    telemetry_delivery_status: Telemetry status (sent, dropped, buffered, unknown)\n    capture_confidence_score: Confidence in evidence capture (0.0-1.0)\n\nReturns:\n    Evidence ID if successful, None on failure\n\nRaises:\n    EvidenceContextError: If ctx is None (Phase-1 guardrail)",
            "is_async": false,
            "line": 259
          },
          {
            "name": "capture_activity_evidence",
            "signature": "(session: Session, ctx: ExecutionContext) -> Optional[str]",
            "docstring": "Capture activity evidence (Class B) before/after LLM calls.\n\nTAXONOMY RULE: Activity evidence is only for externally consequential\nactions (LLM calls, HTTP calls, tool invocations). Pure transforms\ndo not require activity evidence.\n\nCalled BEFORE each LLM/tool invocation (with prompt info),\nand optionally updated AFTER with response info.\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    ctx: ExecutionContext (required)\n    skill_id: Skill identifier\n    model_name: LLM model name\n    prompt_fingerprint: SHA256 hash of canonical prompt\n    prompt_token_length: Token count of prompt\n    response_fingerprint: SHA256 hash of response (optional, after call)\n    response_token_length: Token count of response (optional)\n\nReturns:\n    Evidence ID if successful, None on failure\n\nRaises:\n    EvidenceContextError: If ctx is None (Phase-1 guardrail)",
            "is_async": false,
            "line": 381
          },
          {
            "name": "capture_provider_evidence",
            "signature": "(session: Session, ctx: ExecutionContext) -> Optional[str]",
            "docstring": "Capture provider evidence (Class G) after LLM provider response.\n\nCalled AFTER each provider interaction.\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    ctx: ExecutionContext (required)\n    provider_name: Provider identifier (anthropic, openai, etc.)\n    model_name: Model name used\n    input_tokens: Input token count\n    output_tokens: Output token count\n    provider_latency_ms: Provider response latency in milliseconds\n\nReturns:\n    Evidence ID if successful, None on failure\n\nRaises:\n    EvidenceContextError: If ctx is None (Phase-1 guardrail)",
            "is_async": false,
            "line": 506
          },
          {
            "name": "capture_policy_decision_evidence",
            "signature": "(session: Session, ctx: ExecutionContext) -> Optional[str]",
            "docstring": "Capture policy decision evidence (Class D) during policy evaluation.\n\nThis bridges operational decision records to governance taxonomy.\nCalled whenever a policy/guardrail is evaluated.\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    ctx: ExecutionContext (required)\n    policy_type: Type of policy (budget, rate_limit, capability, permission)\n    decision: Decision outcome (GRANTED, DENIED, PENDING_APPROVAL)\n    policies_evaluated: List of policy IDs evaluated\n    policy_results: Aggregated result (pass, warn, fail, skip)\n\nReturns:\n    Evidence ID if successful, None on failure\n\nRaises:\n    EvidenceContextError: If ctx is None (Phase-1 guardrail)",
            "is_async": false,
            "line": 633
          },
          {
            "name": "compute_integrity",
            "signature": "(run_id: str) -> Dict[str, Any]",
            "docstring": "Compute integrity payload by examining evidence tables.\n\nv1.1: Delegates to compute_integrity_v2 which uses the split architecture\n(IntegrityAssembler + IntegrityEvaluator).\n\nWatch-out #3: Checks for recorded capture failures and includes them\nin missing_reasons with specific failure codes.\n\nReturns dictionary with expected/observed/missing artifacts and integrity score.\nBackward compatible - same dict structure as v1.0, with optional extra fields.",
            "is_async": false,
            "line": 750
          },
          {
            "name": "capture_integrity_evidence",
            "signature": "(session: Session, run_id: str) -> Optional[str]",
            "docstring": "Capture integrity evidence (Class J) at terminal state.\n\nCalled EXACTLY ONCE when run reaches terminal state.\nThis is the truth seal - computed from all observed evidence.\n\nNOTE: This function does NOT require ExecutionContext by design.\nIntegrity is computed from run_id after execution ends.\n\nArgs:\n    session: SQLModel session (REQUIRED \u2014 caller owns transaction)\n    run_id: Run identifier\n    is_synthetic: Whether this is SDSR execution\n    synthetic_scenario_id: SDSR scenario ID if synthetic\n\nReturns:\n    Evidence ID if successful, None on failure",
            "is_async": false,
            "line": 774
          },
          {
            "name": "hash_prompt",
            "signature": "(prompt: str) -> str",
            "docstring": "Generate SHA256 fingerprint of prompt content.",
            "is_async": false,
            "line": 867
          }
        ],
        "classes": [
          {
            "name": "EvidenceContextError",
            "docstring": "Hard failure when evidence capture is attempted without ExecutionContext.\n\nPhase-1 Closure Guardrail (PIN-405):\n- Evidence capture REQUIRES execution context\n- No context = no evidence (by force, not convention)\n- This closes the evidence forgery vector permanently\n\nThis is a blocking exception - callers must handle it explicitly.\nIt is NOT a best-effort failure that gets logged and ignored.",
            "methods": [
              "__init__"
            ],
            "line": 83
          },
          {
            "name": "CaptureFailureReason",
            "docstring": "Standard failure reasons for integrity evidence.\n\nResolution Semantics (Category C3):\n- TRANSIENT: Temporary failure, may recover (network blip, retry possible)\n- PERMANENT: Unrecoverable failure (schema mismatch, invalid data)\n- SUPERSEDED: Later capture succeeded, this failure can be ignored\n\nMapping to default resolution:\n- capture_failed \u2192 transient\n- provider_timeout \u2192 transient\n- pre_attach \u2192 permanent (context doesn't exist yet)\n- network_partition \u2192 transient\n- database_error \u2192 transient\n- context_invalid \u2192 permanent",
            "methods": [],
            "line": 137
          },
          {
            "name": "FailureResolution",
            "docstring": "Resolution semantics for capture failures.",
            "methods": [],
            "line": 163
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "sqlalchemy.exc",
            "names": [
              "SQLAlchemyError"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "app.core.execution_context",
            "names": [
              "ExecutionContext"
            ],
            "is_relative": false,
            "line": 73
          }
        ],
        "constants": [
          {
            "name": "_FAILURE_RESOLUTION_MAP",
            "line": 171
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "export_bundle_store.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/export_bundle_store.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 242,
        "module_docstring": "Export Bundle Store (L6)\n\nDatabase driver for export bundle data access:\n- Incidents\n- Runs\n- Trace summaries and steps\n\nAll methods return immutable snapshots, never ORM models.",
        "functions": [
          {
            "name": "get_export_bundle_store",
            "signature": "() -> ExportBundleStore",
            "docstring": "Get the singleton ExportBundleStore instance.",
            "is_async": false,
            "line": 227
          }
        ],
        "classes": [
          {
            "name": "IncidentSnapshot",
            "docstring": "Immutable snapshot of incident.",
            "methods": [],
            "line": 53
          },
          {
            "name": "RunSnapshot",
            "docstring": "Immutable snapshot of run.",
            "methods": [],
            "line": 67
          },
          {
            "name": "TraceSummarySnapshot",
            "docstring": "Immutable snapshot of trace summary.",
            "methods": [],
            "line": 82
          },
          {
            "name": "TraceStepSnapshot",
            "docstring": "Immutable snapshot of trace step.",
            "methods": [],
            "line": 93
          },
          {
            "name": "ExportBundleStore",
            "docstring": "L6 Database Driver for export bundle data.\n\nAll methods:\n- Use sync Session (for sqlmodel compatibility)\n- Return immutable snapshots\n- Contain NO business logic",
            "methods": [
              "__init__",
              "trace_store",
              "get_incident",
              "get_run_by_run_id",
              "get_trace_summary",
              "get_trace_steps"
            ],
            "line": 111
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.db",
            "names": [
              "Incident",
              "Run",
              "engine"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.traces.store",
            "names": [
              "TraceStore"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": [
          "ExportBundleStore",
          "get_export_bundle_store",
          "IncidentSnapshot",
          "RunSnapshot",
          "TraceSummarySnapshot",
          "TraceStepSnapshot"
        ]
      },
      {
        "file_name": "idempotency.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/idempotency.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 398,
        "module_docstring": "Redis Idempotency Store for AOS Traces\n\nM8 Deliverable: Atomic idempotency enforcement using Redis + Lua scripts.\n\nFeatures:\n- Atomic check-and-set with Lua scripts\n- Configurable TTL per key\n- Conflict detection with hash comparison\n- Async Redis support",
        "functions": [
          {
            "name": "_load_lua_script",
            "signature": "() -> str",
            "docstring": "Load Lua script from file.",
            "is_async": false,
            "line": 79
          },
          {
            "name": "canonical_json",
            "signature": "(obj: Any) -> str",
            "docstring": "Produce canonical JSON (sorted keys, compact format).",
            "is_async": false,
            "line": 130
          },
          {
            "name": "hash_request",
            "signature": "(data: Dict[str, Any]) -> str",
            "docstring": "Hash request data for idempotency comparison.",
            "is_async": false,
            "line": 135
          },
          {
            "name": "get_idempotency_store",
            "signature": "() -> Any",
            "docstring": "Get or create idempotency store based on environment.",
            "is_async": true,
            "line": 374
          }
        ],
        "classes": [
          {
            "name": "IdempotencyResult",
            "docstring": "Result of idempotency check.",
            "methods": [],
            "line": 45
          },
          {
            "name": "IdempotencyResponse",
            "docstring": "Response from idempotency check.",
            "methods": [
              "is_new",
              "is_duplicate",
              "is_conflict"
            ],
            "line": 54
          },
          {
            "name": "RedisIdempotencyStore",
            "docstring": "Redis-backed idempotency store with Lua script for atomicity.\n\nUsage:\n    store = RedisIdempotencyStore(redis_client)\n    response = await store.check(\"my-key\", request_data, tenant_id=\"acme\")\n\n    if response.is_new:\n        # Process request\n        await store.mark_completed(\"my-key\", trace_id)\n    elif response.is_duplicate:\n        # Return cached response\n        pass\n    elif response.is_conflict:\n        # Reject with 409 Conflict\n        raise HTTPException(409, \"Idempotency conflict\")",
            "methods": [
              "__init__",
              "_make_key",
              "_ensure_script_loaded",
              "check",
              "mark_completed",
              "mark_failed",
              "delete",
              "get_status"
            ],
            "line": 141
          },
          {
            "name": "InMemoryIdempotencyStore",
            "docstring": "In-memory idempotency store for testing and development.\n\nNot suitable for production (no persistence, no distributed support).",
            "methods": [
              "__init__",
              "_make_key",
              "check",
              "mark_completed",
              "mark_failed",
              "delete",
              "get_status"
            ],
            "line": 299
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [
          {
            "name": "_LUA_SCRIPT_PATH",
            "line": 75
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "integrity.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/integrity.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 523,
        "module_docstring": "Integrity Computation Module (v1.1)\n\nSeparated concerns for integrity evidence:\n- IntegrityAssembler: Gathers facts from evidence tables\n- IntegrityEvaluator: Applies policy to compute state/grade\n- IntegritySerializer: Persists integrity evidence\n\nDesign rationale (Category C2 fix):\n    compute_integrity() was becoming a god function.\n    Split responsibilities enable:\n    - Policy-driven integrity (enterprise tiers)\n    - Explainable integrity decisions\n    - Testable components\n\nState Model (Category B2 fix):\n    Execution Status: SUCCEEDED | FAILED | ABORTED (run outcome)\n    Integrity State:  PENDING | SEALED (evidence completeness)\n    Integrity Grade:  PASS | WARN | FAIL (quality judgment)\n\n    These are distinct axes - do not collapse them.",
        "functions": [
          {
            "name": "compute_integrity_v2",
            "signature": "(run_id: str) -> Dict[str, Any]",
            "docstring": "Compute integrity using the new split architecture.\n\nReturns dict compatible with the original compute_integrity().",
            "is_async": false,
            "line": 500
          }
        ],
        "classes": [
          {
            "name": "IntegrityState",
            "docstring": "Evidence completeness state.\n\nThis is about WHETHER we have evidence, not quality.",
            "methods": [],
            "line": 67
          },
          {
            "name": "IntegrityGrade",
            "docstring": "Quality judgment on the evidence.\n\nThis is about HOW GOOD the evidence is.",
            "methods": [],
            "line": 77
          },
          {
            "name": "EvidenceClass",
            "docstring": "Taxonomy of evidence classes.\n\nActivity Evidence (B) Scope Rule:\n    Activity evidence is required only for externally consequential actions\n    (e.g., LLM calls, tool invocations), not pure transforms.\n\n    - llm_invoke: REQUIRES activity evidence (decision-bearing)\n    - http_call: REQUIRES activity evidence (external effect)\n    - json_transform: NO activity evidence (pure transform)\n    - postgres_query: OPTIONAL (depends on mutation)",
            "methods": [],
            "line": 93
          },
          {
            "name": "FailureResolution",
            "docstring": "Resolution semantics for capture failures.\n\nFormalizes how to interpret a capture failure for integrity grading.",
            "methods": [],
            "line": 137
          },
          {
            "name": "CaptureFailure",
            "docstring": "Structured representation of an evidence capture failure.",
            "methods": [
              "to_dict"
            ],
            "line": 149
          },
          {
            "name": "IntegrityFacts",
            "docstring": "Raw facts gathered from evidence tables.\n\nThis is pure data gathering - no policy applied.",
            "methods": [
              "has_required_evidence",
              "has_capture_failures",
              "unresolved_failures"
            ],
            "line": 173
          },
          {
            "name": "IntegrityAssembler",
            "docstring": "Gathers facts from evidence tables.\n\nThis class only collects data - it does not apply policy.",
            "methods": [
              "__init__",
              "gather",
              "_count_evidence",
              "_gather_failures",
              "_resolve_superseded",
              "_table_to_class",
              "_string_to_class"
            ],
            "line": 203
          },
          {
            "name": "IntegrityEvaluation",
            "docstring": "Result of integrity policy evaluation.",
            "methods": [
              "integrity_status"
            ],
            "line": 347
          },
          {
            "name": "IntegrityEvaluator",
            "docstring": "Applies policy to integrity facts.\n\nThis class makes quality judgments based on collected facts.\nPolicy can be customized for enterprise tiers.",
            "methods": [
              "evaluate",
              "_find_failure",
              "_compute_grade",
              "_build_explanation"
            ],
            "line": 369
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "sqlalchemy",
            "names": [
              "create_engine",
              "text"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "sqlalchemy.exc",
            "names": [
              "SQLAlchemyError"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 55
          }
        ],
        "constants": [
          {
            "name": "DATABASE_URL",
            "line": 59
          },
          {
            "name": "REQUIRED_EVIDENCE",
            "line": 118
          },
          {
            "name": "EXPECTED_EVIDENCE",
            "line": 125
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "job_execution.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/job_execution.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 880,
        "module_docstring": "Module: job_execution\nPurpose: Job execution support services.\n\nProvides:\n    - GAP-156: Retry logic with exponential backoff\n    - GAP-157: Progress reporting and tracking\n    - GAP-158: Audit evidence emission\n\nAcceptance Criteria:\n    - AC-156-01: Exponential backoff with jitter\n    - AC-156-02: Max retries respected\n    - AC-156-03: Retry history recorded\n    - AC-157-01: Progress percentage tracked\n    - AC-157-02: Progress events emitted\n    - AC-157-03: ETA calculation\n    - AC-158-01: Job lifecycle audited\n    - AC-158-02: Audit events are tamper-evident\n    - AC-158-03: Audit includes execution context",
        "functions": [
          {
            "name": "_hash_value",
            "signature": "(value: Any) -> str",
            "docstring": "Hash a value for audit purposes.",
            "is_async": false,
            "line": 652
          },
          {
            "name": "get_job_retry_manager",
            "signature": "() -> JobRetryManager",
            "docstring": "Get the singleton JobRetryManager.",
            "is_async": false,
            "line": 851
          },
          {
            "name": "get_job_progress_tracker",
            "signature": "() -> JobProgressTracker",
            "docstring": "Get the singleton JobProgressTracker.",
            "is_async": false,
            "line": 859
          },
          {
            "name": "get_job_audit_emitter",
            "signature": "() -> JobAuditEmitter",
            "docstring": "Get the singleton JobAuditEmitter.",
            "is_async": false,
            "line": 867
          },
          {
            "name": "reset_job_execution_services",
            "signature": "() -> None",
            "docstring": "Reset all singletons (for testing).",
            "is_async": false,
            "line": 875
          }
        ],
        "classes": [
          {
            "name": "RetryStrategy",
            "docstring": "Retry strategy types.",
            "methods": [],
            "line": 67
          },
          {
            "name": "RetryConfig",
            "docstring": "Configuration for job retry.",
            "methods": [],
            "line": 77
          },
          {
            "name": "RetryAttempt",
            "docstring": "Record of a retry attempt.",
            "methods": [],
            "line": 89
          },
          {
            "name": "JobRetryManager",
            "docstring": "Manages job retry logic with configurable strategies.\n\nGAP-156: Job Retry Logic\n\nSupports:\n- Exponential backoff with jitter\n- Configurable max retries\n- Retry history tracking\n- Error classification",
            "methods": [
              "__init__",
              "should_retry",
              "calculate_delay",
              "record_retry",
              "get_retry_history",
              "clear_history"
            ],
            "line": 100
          },
          {
            "name": "ProgressStage",
            "docstring": "Standard progress stages.",
            "methods": [],
            "line": 269
          },
          {
            "name": "ProgressUpdate",
            "docstring": "A progress update for a job.",
            "methods": [
              "to_dict"
            ],
            "line": 282
          },
          {
            "name": "JobProgressTracker",
            "docstring": "Tracks and reports job progress.\n\nGAP-157: Job Progress Reporting\n\nProvides:\n- Percentage tracking\n- Step-based progress\n- ETA calculation\n- Progress event emission",
            "methods": [
              "__init__",
              "start",
              "update",
              "complete",
              "fail",
              "get_progress",
              "register_callback",
              "_calculate_eta",
              "_emit_progress",
              "_get_publisher"
            ],
            "line": 312
          },
          {
            "name": "JobAuditEventType",
            "docstring": "Types of job audit events.",
            "methods": [],
            "line": 573
          },
          {
            "name": "JobAuditEvent",
            "docstring": "Audit event for job execution.\n\nProvides tamper-evident audit trail for compliance.",
            "methods": [
              "__post_init__",
              "_compute_integrity_hash",
              "to_dict",
              "verify_integrity"
            ],
            "line": 588
          },
          {
            "name": "JobAuditEmitter",
            "docstring": "Emits audit events for job execution.\n\nGAP-158: Job Audit Evidence\n\nProvides:\n- Compliance-grade audit trail\n- Tamper-evident event chain\n- Execution context capture",
            "methods": [
              "__init__",
              "_generate_event_id",
              "emit_created",
              "emit_started",
              "emit_completed",
              "emit_failed",
              "emit_retried",
              "_emit",
              "_get_publisher"
            ],
            "line": 660
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "random",
            "names": [
              "random"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "logs_domain_store.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/logs_domain_store.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 673,
        "module_docstring": "Logs Domain Store (L6)\n\nDatabase driver for all Logs domain data access:\n- LLM Run Records\n- System Records\n- Audit Ledger\n- Log Exports\n\nAll methods return immutable snapshots, never ORM models.",
        "functions": [
          {
            "name": "get_logs_domain_store",
            "signature": "() -> LogsDomainStore",
            "docstring": "Get the singleton LogsDomainStore instance.",
            "is_async": false,
            "line": 655
          }
        ],
        "classes": [
          {
            "name": "LLMRunSnapshot",
            "docstring": "Immutable snapshot of LLM run record.",
            "methods": [],
            "line": 56
          },
          {
            "name": "SystemRecordSnapshot",
            "docstring": "Immutable snapshot of system record.",
            "methods": [],
            "line": 77
          },
          {
            "name": "AuditLedgerSnapshot",
            "docstring": "Immutable snapshot of audit ledger entry.",
            "methods": [],
            "line": 93
          },
          {
            "name": "LogExportSnapshot",
            "docstring": "Immutable snapshot of log export record.",
            "methods": [],
            "line": 111
          },
          {
            "name": "TraceStepSnapshot",
            "docstring": "Immutable snapshot of trace step.",
            "methods": [],
            "line": 126
          },
          {
            "name": "QueryResult",
            "docstring": "Generic query result with pagination info.",
            "methods": [],
            "line": 139
          },
          {
            "name": "LogsDomainStore",
            "docstring": "L6 Database Driver for Logs domain.\n\nAll methods:\n- Accept AsyncSession as parameter\n- Return immutable snapshots\n- Contain NO business logic",
            "methods": [
              "list_llm_runs",
              "get_llm_run",
              "_to_llm_run_snapshot",
              "get_trace_id_for_run",
              "get_trace_steps",
              "get_replay_window_events",
              "list_system_records",
              "get_system_record_by_correlation",
              "get_system_records_in_window",
              "_to_system_record_snapshot",
              "list_audit_entries",
              "get_audit_entry",
              "get_governance_events",
              "_to_audit_snapshot",
              "list_log_exports",
              "_to_export_snapshot"
            ],
            "line": 152
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select",
              "text"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.models.audit_ledger",
            "names": [
              "AuditLedger"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.models.log_exports",
            "names": [
              "LogExport"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.models.logs_records",
            "names": [
              "LLMRunRecord",
              "SystemRecord"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": [
          "LogsDomainStore",
          "get_logs_domain_store",
          "LLMRunSnapshot",
          "SystemRecordSnapshot",
          "AuditLedgerSnapshot",
          "LogExportSnapshot",
          "TraceStepSnapshot",
          "QueryResult"
        ]
      },
      {
        "file_name": "panel_consistency_checker.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/panel_consistency_checker.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 250,
        "module_docstring": "Panel Consistency Checker \u2014 Cross-slot consistency rules\n\nChecks that output signals across slots in a panel are consistent.\nInconsistencies are violations, not warnings.",
        "functions": [
          {
            "name": "create_consistency_checker",
            "signature": "(rules: Optional[List[Dict[str, Any]]] = None) -> PanelConsistencyChecker",
            "docstring": "Create consistency checker with optional custom rules.",
            "is_async": false,
            "line": 246
          }
        ],
        "classes": [
          {
            "name": "ConsistencyViolation",
            "docstring": "A consistency violation between slots.",
            "methods": [],
            "line": 37
          },
          {
            "name": "ConsistencyCheckResult",
            "docstring": "Result of consistency checking.",
            "methods": [],
            "line": 48
          },
          {
            "name": "PanelConsistencyChecker",
            "docstring": "Checks cross-slot consistency within a panel.\n\nUsage:\n    checker = PanelConsistencyChecker(rules)\n    result = checker.check(panel_id, slot_results)",
            "methods": [
              "__init__",
              "_default_rules",
              "check",
              "_check_rule",
              "_evaluate_condition",
              "_eval_expr"
            ],
            "line": 56
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "panel_types",
            "names": [
              "PanelSlotResult"
            ],
            "is_relative": true,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "pg_store.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/pg_store.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 769,
        "module_docstring": "PostgreSQL Trace Store for AOS\nM8 Deliverable: Production-grade trace storage with PostgreSQL\n\nProvides:\n- Async PostgreSQL storage with connection pooling\n- RBAC-aware trace access\n- PII redaction before storage\n- Efficient indexing for query API\n\nFROZEN SEMANTICS (PIN-198, S6 Trace Integrity Truth):\n- All trace INSERTs use ON CONFLICT DO NOTHING (Invariant #15: First Truth Wins)\n- No UPDATE on aos_trace_steps (Invariant #13: Trace Ledger Semantics)\n- Only status/completed_at UPDATE allowed on aos_traces\n- DELETE requires archive-first (Invariant #13)\nSee LESSONS_ENFORCED.md Invariants #13, #15",
        "functions": [
          {
            "name": "_status_to_level",
            "signature": "(status: str) -> str",
            "docstring": "Derive log level from step status.\n\nMapping per PIN-378 (Canonical Logs System):\n- success \u2192 INFO\n- skipped \u2192 INFO\n- retry \u2192 WARN\n- failure \u2192 ERROR",
            "is_async": false,
            "line": 55
          },
          {
            "name": "get_postgres_trace_store",
            "signature": "() -> PostgresTraceStore",
            "docstring": "Get singleton PostgreSQL trace store.",
            "is_async": false,
            "line": 764
          }
        ],
        "classes": [
          {
            "name": "PostgresTraceStore",
            "docstring": "PostgreSQL-based trace storage for production.\n\nUses asyncpg for async database operations.\nSupports multi-tenant isolation and RBAC.",
            "methods": [
              "__init__",
              "_get_pool",
              "close",
              "start_trace",
              "record_step",
              "complete_trace",
              "mark_trace_aborted",
              "store_trace",
              "get_trace",
              "get_trace_by_root_hash",
              "search_traces",
              "list_traces",
              "delete_trace",
              "get_trace_count",
              "cleanup_old_traces",
              "check_idempotency_key"
            ],
            "line": 74
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "models",
            "names": [
              "TraceRecord",
              "TraceStatus",
              "TraceStep",
              "TraceSummary"
            ],
            "is_relative": true,
            "line": 51
          },
          {
            "module": "redact",
            "names": [
              "redact_trace_data"
            ],
            "is_relative": true,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "replay.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/replay.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 329,
        "module_docstring": "Server-Side Replay Enforcement\nM8 Deliverable: Enforce replay_behavior during trace execution\n\nProvides:\n- Replay behavior enforcement (execute, skip, check)\n- Idempotency key validation\n- Output verification for \"check\" mode\n- Replay mismatch detection",
        "functions": [
          {
            "name": "hash_output",
            "signature": "(data: Any) -> str",
            "docstring": "Compute hash of output data for comparison.",
            "is_async": false,
            "line": 86
          },
          {
            "name": "get_replay_enforcer",
            "signature": "(use_redis: bool = False) -> ReplayEnforcer",
            "docstring": "Get singleton replay enforcer.",
            "is_async": false,
            "line": 320
          }
        ],
        "classes": [
          {
            "name": "ReplayBehavior",
            "docstring": "Replay behavior options.",
            "methods": [],
            "line": 38
          },
          {
            "name": "ReplayMismatchError",
            "docstring": "Raised when replay output doesn't match original.",
            "methods": [
              "__init__"
            ],
            "line": 46
          },
          {
            "name": "IdempotencyViolationError",
            "docstring": "Raised when idempotency key is violated.",
            "methods": [
              "__init__"
            ],
            "line": 62
          },
          {
            "name": "ReplayResult",
            "docstring": "Result of a replay operation.",
            "methods": [],
            "line": 75
          },
          {
            "name": "ReplayEnforcer",
            "docstring": "Server-side replay behavior enforcer.\n\nEnsures that:\n- \"skip\" steps are not re-executed\n- \"check\" steps verify output matches\n- Idempotency keys are respected",
            "methods": [
              "__init__",
              "enforce_step",
              "enforce_trace"
            ],
            "line": 94
          },
          {
            "name": "IdempotencyStore",
            "docstring": "Abstract base for idempotency storage.",
            "methods": [
              "get",
              "set",
              "delete"
            ],
            "line": 234
          },
          {
            "name": "InMemoryIdempotencyStore",
            "docstring": "In-memory idempotency store for testing.",
            "methods": [
              "__init__",
              "_make_key",
              "get",
              "set",
              "delete",
              "clear"
            ],
            "line": 247
          },
          {
            "name": "RedisIdempotencyStore",
            "docstring": "Redis-based idempotency store for production.",
            "methods": [
              "__init__",
              "_get_client",
              "_make_key",
              "get",
              "set",
              "delete"
            ],
            "line": 276
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Awaitable",
              "Callable",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "traces_store.py",
        "file_path": "backend/app/hoc/cus/logs/L6_drivers/traces_store.py",
        "layer": "L6_drivers",
        "domain": "logs",
        "lines": 757,
        "module_docstring": "Trace Storage for AOS\nM6 Deliverable: Run traces with correlation IDs\n\nProvides persistent storage for execution traces used in:\n- Debugging and inspection\n- Replay verification\n- Determinism testing",
        "functions": [
          {
            "name": "generate_correlation_id",
            "signature": "() -> str",
            "docstring": "Generate a unique correlation ID for tracing.",
            "is_async": false,
            "line": 750
          },
          {
            "name": "generate_run_id",
            "signature": "() -> str",
            "docstring": "Generate a unique run ID.",
            "is_async": false,
            "line": 755
          }
        ],
        "classes": [
          {
            "name": "TraceStore",
            "docstring": "Abstract base class for trace storage.",
            "methods": [
              "start_trace",
              "record_step",
              "complete_trace",
              "get_trace",
              "list_traces",
              "delete_trace"
            ],
            "line": 42
          },
          {
            "name": "SQLiteTraceStore",
            "docstring": "SQLite-based trace storage.\n\nDefault storage for v1. Simple, local, and sufficient for\nsingle-instance deployments.",
            "methods": [
              "__init__",
              "_init_db",
              "_get_conn",
              "start_trace",
              "record_step",
              "complete_trace",
              "get_trace",
              "list_traces",
              "delete_trace",
              "get_trace_count",
              "cleanup_old_traces",
              "search_traces",
              "get_trace_by_root_hash",
              "find_matching_traces",
              "update_trace_determinism"
            ],
            "line": 106
          },
          {
            "name": "InMemoryTraceStore",
            "docstring": "In-memory trace storage for testing.\n\nAll data is lost when the process exits.",
            "methods": [
              "__init__",
              "start_trace",
              "record_step",
              "complete_trace",
              "get_trace",
              "list_traces",
              "delete_trace"
            ],
            "line": 603
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "sqlite3",
            "names": [
              "sqlite3"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "models",
            "names": [
              "TraceRecord",
              "TraceStatus",
              "TraceStep",
              "TraceSummary"
            ],
            "is_relative": true,
            "line": 39
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 35,
    "violation_count": 4,
    "gap_count": 2
  },
  "analytics": {
    "l2_1_facade": null,
    "l2_apis": [
      {
        "file_name": "costsim.py",
        "file_path": "backend/app/hoc/api/cus/analytics/costsim.py",
        "layer": "L2_api",
        "domain": "analytics",
        "lines": 913,
        "module_docstring": "API endpoints for CostSim V2 sandbox.\n\nEndpoints:\n- POST /costsim/v2/simulate - Run V2 simulation (sandbox mode)\n- GET /costsim/v2/status - Get V2 sandbox status\n- POST /costsim/v2/reset - Reset circuit breaker\n- GET /costsim/divergence - Get divergence report\n- POST /costsim/canary/run - Trigger canary run\n- GET /costsim/canary/reports - Get canary reports\n\nM7 Enhancements:\n- Memory context injection for simulations\n- Post-execution memory updates via rules engine\n- Drift detection between baseline and memory-enabled runs",
        "functions": [
          {
            "name": "get_memory_context",
            "signature": "(tenant_id: str, workflow_id: Optional[str] = None, agent_id: Optional[str] = None) -> Dict[str, Any]",
            "docstring": "Retrieve memory context for simulation.\n\nFetches relevant memory pins for the tenant, workflow, and agent.\nReturns empty dict if memory service unavailable (fail-open).",
            "is_async": true,
            "line": 262
          },
          {
            "name": "apply_post_execution_updates",
            "signature": "(tenant_id: str, workflow_id: Optional[str], agent_id: Optional[str], simulation_result: Dict[str, Any]) -> int",
            "docstring": "Apply deterministic post-execution memory updates.\n\nUses the update rules engine to apply memory updates based on\nsimulation results. Returns count of updates applied.",
            "is_async": true,
            "line": 318
          },
          {
            "name": "detect_simulation_drift",
            "signature": "(baseline_result: Dict[str, Any], memory_result: Dict[str, Any], workflow_id: Optional[str]) -> tuple[bool, float]",
            "docstring": "Detect drift between baseline and memory-enabled simulation.\n\nCompares results to identify if memory context significantly\nchanged the simulation outcome.",
            "is_async": true,
            "line": 373
          },
          {
            "name": "get_sandbox_status",
            "signature": "()",
            "docstring": "Get current V2 sandbox status.\n\nReturns information about:\n- Whether sandbox is enabled (feature flag)\n- Whether circuit breaker is open (auto-disabled due to drift)\n- Current model version\n- Drift thresholds",
            "is_async": true,
            "line": 431
          },
          {
            "name": "simulate_v2",
            "signature": "(request: SimulateRequest)",
            "docstring": "Run simulation through V2 sandbox.\n\nThis endpoint always runs V1 for production results.\nIf sandbox is enabled, also runs V2 in shadow mode\nand returns comparison metrics.\n\nThe V1 result is always the authoritative result.\nV2 is for validation only.\n\nM7 Enhancements:\n- Memory context injection for simulations\n- Post-execution memory updates via rules engine\n- Drift detection between baseline and memory-enabled runs",
            "is_async": true,
            "line": 458
          },
          {
            "name": "reset_circuit_breaker",
            "signature": "(reason: Optional[str] = Query(None, description='Reason for reset'))",
            "docstring": "Reset the V2 circuit breaker.\n\nThis re-enables V2 sandbox after it was auto-disabled due to drift.\nShould only be called after investigating and fixing the drift cause.\n\nReturns success status and updated circuit breaker state.",
            "is_async": true,
            "line": 630
          },
          {
            "name": "get_incidents",
            "signature": "(include_resolved: bool = Query(False, description='Include resolved incidents'), limit: int = Query(10, ge=1, le=100, description='Max incidents to return'))",
            "docstring": "Get circuit breaker incidents.\n\nReturns recent incidents that caused circuit breaker trips.\nUseful for investigating drift causes.",
            "is_async": true,
            "line": 664
          },
          {
            "name": "get_divergence_report",
            "signature": "(start_date: Optional[datetime] = Query(None, description='Start of analysis period'), end_date: Optional[datetime] = Query(None, description='End of analysis period'), tenant_id: Optional[str] = Query(None, description='Filter by tenant'), days: int = Query(7, ge=1, le=90, description='Days to analyze (if start_date not provided)'))",
            "docstring": "Get cost divergence report between V1 and V2.\n\nReturns metrics:\n- delta_p50: Median cost delta\n- delta_p90: 90th percentile cost delta\n- kl_divergence: KL divergence between distributions\n- outlier_count: Number of outlier samples\n- fail_ratio: Ratio of major drift samples\n- matching_rate: Ratio of matching samples",
            "is_async": true,
            "line": 687
          },
          {
            "name": "trigger_canary_run",
            "signature": "(sample_count: int = Query(100, ge=10, le=1000, description='Number of samples'), drift_threshold: float = Query(0.2, ge=0.0, le=1.0, description='Drift threshold'))",
            "docstring": "Trigger a canary run on-demand.\n\nThe canary run:\n1. Loads samples from recent provenance logs\n2. Runs both V1 and V2 on each sample\n3. Computes drift metrics\n4. Returns pass/fail verdict\n\nNote: Daily canary runs are automatic via systemd timer.\nThis endpoint is for manual testing.",
            "is_async": true,
            "line": 731
          },
          {
            "name": "get_canary_reports",
            "signature": "(limit: int = Query(10, ge=1, le=100, description='Max reports to return'))",
            "docstring": "Get recent canary run reports.\n\nReturns summaries of recent canary runs.\nFull artifacts are available at the artifact_paths.",
            "is_async": true,
            "line": 765
          },
          {
            "name": "list_datasets",
            "signature": "()",
            "docstring": "List all available reference datasets.\n\nReference datasets are used to validate V2 accuracy:\n- low_variance: Simple, predictable plans\n- high_variance: Complex, variable plans\n- mixed_city: Real-world mixed workloads\n- noise_injected: Edge cases and invalid inputs\n- historical: Real production patterns",
            "is_async": true,
            "line": 814
          },
          {
            "name": "get_dataset_info",
            "signature": "(dataset_id: str)",
            "docstring": "Get information about a specific dataset.",
            "is_async": true,
            "line": 840
          },
          {
            "name": "validate_against_dataset",
            "signature": "(dataset_id: str)",
            "docstring": "Validate V2 against a specific reference dataset.\n\nRuns V2 on all samples in the dataset and compares\nagainst expected values. Returns metrics and verdict.\n\nVerdict is \"acceptable\" if all metrics are within thresholds.",
            "is_async": true,
            "line": 859
          },
          {
            "name": "validate_all",
            "signature": "()",
            "docstring": "Validate V2 against ALL reference datasets.\n\nThis is a comprehensive validation that runs all 5 datasets.\nUse for pre-release validation or debugging.",
            "is_async": true,
            "line": 889
          }
        ],
        "classes": [
          {
            "name": "SimulationStep",
            "docstring": "A single step in a simulation plan.",
            "methods": [],
            "line": 116
          },
          {
            "name": "SimulateRequest",
            "docstring": "Request for V2 simulation.",
            "methods": [],
            "line": 124
          },
          {
            "name": "SimulationStepResult",
            "docstring": "Result for a single step.",
            "methods": [],
            "line": 137
          },
          {
            "name": "V2SimulationResponse",
            "docstring": "Response from V2 simulation.",
            "methods": [],
            "line": 147
          },
          {
            "name": "ComparisonResponse",
            "docstring": "Comparison between V1 and V2.",
            "methods": [],
            "line": 163
          },
          {
            "name": "SideEffectDisclosure",
            "docstring": "PIN-254 Phase C Fix (C5 Implicit Side-Effect): Explicit disclosure of side effects.\n\nThe /simulate endpoint can trigger memory writes when MEMORY_POST_UPDATE=true.\nThis violates the implicit contract that \"simulation\" is side-effect-free.\n\nThis disclosure makes the side-effect conditions explicit in the response.",
            "methods": [],
            "line": 175
          },
          {
            "name": "SandboxSimulateResponse",
            "docstring": "Response from sandbox simulation.",
            "methods": [],
            "line": 191
          },
          {
            "name": "SandboxStatusResponse",
            "docstring": "Status of V2 sandbox.",
            "methods": [],
            "line": 217
          },
          {
            "name": "DivergenceReportResponse",
            "docstring": "Divergence report response.",
            "methods": [],
            "line": 228
          },
          {
            "name": "CanaryRunResponse",
            "docstring": "Canary run response.",
            "methods": [],
            "line": 244
          },
          {
            "name": "DatasetInfo",
            "docstring": "Dataset information.",
            "methods": [],
            "line": 787
          },
          {
            "name": "ValidationResultResponse",
            "docstring": "Validation result response.",
            "methods": [],
            "line": 797
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.costsim",
            "names": [
              "get_circuit_breaker",
              "is_v2_disabled_by_drift",
              "is_v2_sandbox_enabled",
              "run_canary",
              "simulate_with_sandbox"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.costsim.config",
            "names": [
              "get_config"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.costsim.divergence",
            "names": [
              "generate_divergence_report"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.costsim.datasets",
            "names": [
              "get_dataset_validator",
              "validate_all_datasets"
            ],
            "is_relative": false,
            "line": 783
          },
          {
            "module": "app.costsim.datasets",
            "names": [
              "validate_dataset"
            ],
            "is_relative": false,
            "line": 784
          }
        ],
        "constants": [
          {
            "name": "MEMORY_CONTEXT_INJECTION",
            "line": 53
          },
          {
            "name": "MEMORY_POST_UPDATE",
            "line": 54
          },
          {
            "name": "DRIFT_DETECTION_ENABLED",
            "line": 55
          },
          {
            "name": "MEMORY_FAIL_OPEN_OVERRIDE",
            "line": 57
          },
          {
            "name": "MEMORY_POST_UPDATE_SYNC",
            "line": 59
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "feedback.py",
        "file_path": "backend/app/hoc/api/cus/analytics/feedback.py",
        "layer": "L2_api",
        "domain": "analytics",
        "lines": 260,
        "module_docstring": "PB-S3 Pattern Feedback API (READ-ONLY)\n\nExposes pattern_feedback data for observability without modification.\n\nPB-S3 Contract:\n- Feedback observes but never mutates\n- Provenance references runs (read-only)\n- No execution data modification allowed\n\nREAD_ONLY = True\n\nO1: API endpoint exists \u2713\nO2: List visible with pagination \u2713\nO3: Detail accessible \u2713\nO4: Execution unchanged \u2713 (no POST/PUT/DELETE)",
        "functions": [
          {
            "name": "list_feedback",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), pattern_type: Optional[str] = Query(None, description='Filter by pattern type'), severity: Optional[str] = Query(None, description='Filter by severity'), acknowledged: Optional[bool] = Query(None, description='Filter by acknowledgement status'), limit: int = Query(50, ge=1, le=200, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), _: str = Depends(verify_api_key))",
            "docstring": "List pattern feedback records (PB-S3).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 106
          },
          {
            "name": "get_feedback",
            "signature": "(feedback_id: str, _: str = Depends(verify_api_key))",
            "docstring": "Get detailed feedback record by ID (PB-S3).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 179
          },
          {
            "name": "get_feedback_stats",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), _: str = Depends(verify_api_key))",
            "docstring": "Get feedback statistics summary (PB-S3).\n\nREAD-ONLY: This endpoint only reads aggregated data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 222
          }
        ],
        "classes": [
          {
            "name": "FeedbackSummaryResponse",
            "docstring": "Summary of a feedback record.",
            "methods": [],
            "line": 53
          },
          {
            "name": "FeedbackListResponse",
            "docstring": "Paginated list of feedback records.",
            "methods": [],
            "line": 68
          },
          {
            "name": "FeedbackDetailResponse",
            "docstring": "Detailed feedback record.",
            "methods": [],
            "line": 79
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "auth",
            "names": [
              "verify_api_key"
            ],
            "is_relative": true,
            "line": 38
          },
          {
            "module": "db",
            "names": [
              "get_async_session"
            ],
            "is_relative": true,
            "line": 39
          },
          {
            "module": "models.feedback",
            "names": [
              "PatternFeedback"
            ],
            "is_relative": true,
            "line": 40
          },
          {
            "module": "schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": true,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "predictions.py",
        "file_path": "backend/app/hoc/api/cus/analytics/predictions.py",
        "layer": "L2_api",
        "domain": "analytics",
        "lines": 348,
        "module_docstring": "PB-S5 Predictions API (READ-ONLY)\n\nExposes prediction_events data for observability without modification.\n\nPB-S5 Contract:\n- Predictions are advisory only\n- Predictions have zero side-effects\n- Predictions never modify execution, scheduling, or history\n- Rule: Advise, don't influence\n\nREAD_ONLY = True\n\nO1: API endpoint exists \u2713\nO2: List visible with pagination \u2713\nO3: Detail accessible \u2713\nO4: Execution unchanged \u2713 (no POST/PUT/DELETE)",
        "functions": [
          {
            "name": "list_predictions",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), prediction_type: Optional[str] = Query(None, description='Filter by type (failure_likelihood/cost_overrun)'), subject_type: Optional[str] = Query(None, description='Filter by subject type (worker/run/tenant)'), subject_id: Optional[str] = Query(None, description='Filter by subject ID'), include_expired: bool = Query(False, description='Include expired predictions'), limit: int = Query(50, ge=1, le=200, description='Maximum results'), offset: int = Query(0, ge=0, description='Pagination offset'), auth: AuthorityResult = Depends(require_predictions_read))",
            "docstring": "List prediction events (PB-S5).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.\nAll predictions are ADVISORY only.",
            "is_async": true,
            "line": 105
          },
          {
            "name": "get_prediction",
            "signature": "(prediction_id: str, auth: AuthorityResult = Depends(require_predictions_read))",
            "docstring": "Get detailed prediction by ID (PB-S5).\n\nREAD-ONLY: This endpoint only reads data.\nNo execution data is modified by this query.\nThis prediction is ADVISORY only.",
            "is_async": true,
            "line": 187
          },
          {
            "name": "get_predictions_for_subject",
            "signature": "(subject_type: str, subject_id: str, include_expired: bool = Query(False, description='Include expired predictions'), limit: int = Query(20, ge=1, le=100, description='Maximum results'), auth: AuthorityResult = Depends(require_predictions_read))",
            "docstring": "Get all predictions for a specific subject (PB-S5).\n\nREAD-ONLY: This endpoint only reads data.\nReturns all advisory predictions for a worker/run/tenant.",
            "is_async": true,
            "line": 233
          },
          {
            "name": "get_prediction_stats",
            "signature": "(tenant_id: Optional[str] = Query(None, description='Filter by tenant'), include_expired: bool = Query(False, description='Include expired predictions'), auth: AuthorityResult = Depends(require_predictions_read))",
            "docstring": "Get prediction statistics (PB-S5).\n\nREAD-ONLY: This endpoint only reads aggregated data.\nNo execution data is modified by this query.",
            "is_async": true,
            "line": 290
          }
        ],
        "classes": [
          {
            "name": "PredictionSummaryResponse",
            "docstring": "Summary of a prediction event.",
            "methods": [],
            "line": 55
          },
          {
            "name": "PredictionListResponse",
            "docstring": "Paginated list of predictions.",
            "methods": [],
            "line": 70
          },
          {
            "name": "PredictionDetailResponse",
            "docstring": "Detailed prediction event record.",
            "methods": [],
            "line": 81
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "auth.authority",
            "names": [
              "AuthorityResult",
              "emit_authority_audit",
              "require_predictions_read"
            ],
            "is_relative": true,
            "line": 40
          },
          {
            "module": "db",
            "names": [
              "get_async_session"
            ],
            "is_relative": true,
            "line": 41
          },
          {
            "module": "models.prediction",
            "names": [
              "PredictionEvent"
            ],
            "is_relative": true,
            "line": 42
          },
          {
            "module": "schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": true,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "scenarios.py",
        "file_path": "backend/app/hoc/api/cus/analytics/scenarios.py",
        "layer": "L2_api",
        "domain": "analytics",
        "lines": 525,
        "module_docstring": "Scenario-based Cost Simulation API (H2)\n\nREAD-ONLY simulation endpoints for scenario planning.\n\nINVARIANTS:\n- Pure computation ONLY - no real budget changes\n- No side effects - no database writes for simulation results\n- Advisory only - results are informational, not actionable\n- Scenarios can be stored for re-use (stored in-memory for v1)\n\nEndpoints:\n- GET /scenarios - List available scenarios\n- POST /scenarios - Create new scenario\n- GET /scenarios/{id} - Get scenario details\n- DELETE /scenarios/{id} - Delete scenario\n- POST /scenarios/{id}/simulate - Run simulation (pure computation)\n- POST /scenarios/simulate-adhoc - Run one-off simulation without saving\n\nReference: Phase H2 - Cost Simulation v1",
        "functions": [
          {
            "name": "_init_default_scenarios",
            "signature": "()",
            "docstring": "Initialize default template scenarios for quick access.",
            "is_async": false,
            "line": 168
          },
          {
            "name": "_simulate_plan",
            "signature": "(plan: List[SimulationStepInput], budget_cents: int) -> SimulationResult",
            "docstring": "Run pure simulation on a plan.\n\nINVARIANT: This function has NO side effects.\n- No database writes\n- No external API calls\n- No budget mutations\n- Pure computation only",
            "is_async": false,
            "line": 220
          },
          {
            "name": "list_scenarios",
            "signature": "(include_templates: bool = Query(True, description='Include template scenarios'))",
            "docstring": "List all available scenarios.\n\nReturns both user-created scenarios and template scenarios.\nTemplates are pre-defined common scenarios for quick testing.",
            "is_async": true,
            "line": 338
          },
          {
            "name": "create_scenario",
            "signature": "(request: ScenarioCreate)",
            "docstring": "Create a new scenario.\n\nScenarios are stored in-memory for v1 (session-ephemeral).\nThis ensures no persistent side-effects from scenario creation.",
            "is_async": true,
            "line": 368
          },
          {
            "name": "get_scenario",
            "signature": "(scenario_id: str)",
            "docstring": "Get a specific scenario by ID.",
            "is_async": true,
            "line": 407
          },
          {
            "name": "delete_scenario",
            "signature": "(scenario_id: str)",
            "docstring": "Delete a scenario.\n\nTemplate scenarios cannot be deleted.",
            "is_async": true,
            "line": 428
          },
          {
            "name": "simulate_scenario",
            "signature": "(scenario_id: str, budget_override: Optional[int] = Query(None, ge=0, le=1000000, description='Override budget'))",
            "docstring": "Run simulation for a saved scenario.\n\nINVARIANT: Pure computation only.\n- No database writes\n- No budget mutations\n- No external side-effects\n- Results are advisory only",
            "is_async": true,
            "line": 451
          },
          {
            "name": "simulate_adhoc",
            "signature": "(request: AdhocSimulationRequest)",
            "docstring": "Run ad-hoc simulation without saving scenario.\n\nUse this for quick one-off simulations.\n\nINVARIANT: Pure computation only.\n- No database writes\n- No budget mutations\n- No external side-effects\n- Results are advisory only",
            "is_async": true,
            "line": 480
          },
          {
            "name": "get_immutability_info",
            "signature": "()",
            "docstring": "Get information about the immutability guarantees.\n\nThis endpoint documents the READ-ONLY nature of scenario simulations.",
            "is_async": true,
            "line": 507
          }
        ],
        "classes": [
          {
            "name": "SimulationStepInput",
            "docstring": "A single step in a simulation plan.",
            "methods": [],
            "line": 62
          },
          {
            "name": "ScenarioCreate",
            "docstring": "Request to create a new scenario.",
            "methods": [],
            "line": 70
          },
          {
            "name": "ScenarioModel",
            "docstring": "Stored scenario model.",
            "methods": [],
            "line": 79
          },
          {
            "name": "ScenarioResponse",
            "docstring": "Response for scenario operations.",
            "methods": [],
            "line": 92
          },
          {
            "name": "StepEstimate",
            "docstring": "Cost estimate for a single step.",
            "methods": [],
            "line": 105
          },
          {
            "name": "SimulationResult",
            "docstring": "Result of a scenario simulation (advisory only).",
            "methods": [],
            "line": 116
          },
          {
            "name": "AdhocSimulationRequest",
            "docstring": "Request for ad-hoc simulation without saving scenario.",
            "methods": [],
            "line": 156
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "auth.console_auth",
            "names": [
              "verify_fops_token"
            ],
            "is_relative": true,
            "line": 44
          },
          {
            "module": "schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": true,
            "line": 45
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l3_adapters": [
      {
        "file_name": "alert_delivery.py",
        "file_path": "backend/app/hoc/cus/analytics/L3_adapters/alert_delivery.py",
        "layer": "L3_adapters",
        "domain": "analytics",
        "lines": 167,
        "module_docstring": "Alert Delivery Adapter (L3)\n\nPure HTTP delivery to Alertmanager.\nAll business logic stays in L4 engine.\nAll database operations stay in L6 driver.\n\nOperations:\n- Send alert payload to Alertmanager\n- Handle HTTP errors and timeouts\n- Report delivery result\n\nNO business logic:\n- NO retry decisions (L4)\n- NO status updates (L6)\n- NO queue management (L6)\n\nReference: Phase-2.5A Analytics Extraction",
        "functions": [
          {
            "name": "get_alert_delivery_adapter",
            "signature": "(alertmanager_url: Optional[str] = None, timeout_seconds: float = 30.0) -> AlertDeliveryAdapter",
            "docstring": "Factory function to get AlertDeliveryAdapter instance.",
            "is_async": false,
            "line": 152
          }
        ],
        "classes": [
          {
            "name": "DeliveryResult",
            "docstring": "Result of alert delivery attempt.",
            "methods": [],
            "line": 49
          },
          {
            "name": "AlertDeliveryAdapter",
            "docstring": "L3 adapter for HTTP alert delivery.\n\nPure HTTP operations - no business logic, no database.",
            "methods": [
              "__init__",
              "_get_client",
              "close",
              "send_alert"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": [
          "AlertDeliveryAdapter",
          "DeliveryResult",
          "get_alert_delivery_adapter"
        ]
      },
      {
        "file_name": "v2_adapter.py",
        "file_path": "backend/app/hoc/cus/analytics/L3_adapters/v2_adapter.py",
        "layer": "L3_adapters",
        "domain": "analytics",
        "lines": 431,
        "module_docstring": "CostSim V2 Adapter - Enhanced simulation with confidence scoring.\n\nB02 FIX: Cost modeling logic moved to L4 CostModelEngine.\nThis adapter now delegates domain decisions to L4:\n- Step cost estimation \u2192 L4 estimate_step_cost()\n- Feasibility checks \u2192 L4 check_feasibility()\n- Drift classification \u2192 L4 classify_drift()\n\nL3 responsibility: shape, transport, provenance, context binding.\n\nThis adapter wraps V1 CostSimulator and adds:\n1. Confidence scoring (delegated to L4)\n2. V2-specific model calculations (delegated to L4)\n3. Provenance logging integration\n4. Comparison with V1 results",
        "functions": [
          {
            "name": "simulate_v2",
            "signature": "(plan: List[Dict[str, Any]], budget_cents: int = 1000, allowed_skills: Optional[List[str]] = None, tenant_id: Optional[str] = None, run_id: Optional[str] = None) -> V2SimulationResult",
            "docstring": "Convenience function for V2 simulation.\n\nArgs:\n    plan: List of steps\n    budget_cents: Available budget\n    allowed_skills: Optional skill allowlist\n    tenant_id: Tenant identifier\n    run_id: Run identifier\n\nReturns:\n    V2SimulationResult",
            "is_async": true,
            "line": 382
          },
          {
            "name": "simulate_v2_with_comparison",
            "signature": "(plan: List[Dict[str, Any]], budget_cents: int = 1000, allowed_skills: Optional[List[str]] = None) -> tuple[V2SimulationResult, ComparisonResult]",
            "docstring": "Convenience function for V2 simulation with V1 comparison.\n\nArgs:\n    plan: List of steps\n    budget_cents: Available budget\n    allowed_skills: Optional skill allowlist\n\nReturns:\n    Tuple of (V2SimulationResult, ComparisonResult)",
            "is_async": true,
            "line": 411
          }
        ],
        "classes": [
          {
            "name": "V2StepEstimate",
            "docstring": "Enhanced step estimate with confidence.",
            "methods": [],
            "line": 57
          },
          {
            "name": "CostSimV2Adapter",
            "docstring": "CostSim V2 Adapter with enhanced modeling.\n\nUsage:\n    adapter = CostSimV2Adapter(budget_cents=1000)\n    result = await adapter.simulate(plan)\n\n    # Or with V1 comparison\n    result, comparison = await adapter.simulate_with_comparison(plan)",
            "methods": [
              "__init__",
              "_get_coefficients",
              "_estimate_step_v2",
              "simulate",
              "simulate_with_comparison",
              "_compare_results"
            ],
            "line": 68
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.costsim.config",
            "names": [
              "get_commit_sha",
              "get_config"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.costsim.models",
            "names": [
              "ComparisonResult",
              "ComparisonVerdict",
              "V2SimulationResult",
              "V2SimulationStatus"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.costsim.provenance",
            "names": [
              "get_provenance_logger"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.worker.simulate",
            "names": [
              "CostSimulator",
              "SimulationResult"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "ai_console_panel_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/ai_console_panel_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 338,
        "module_docstring": "AI Console Panel Engine \u2014 Main orchestration for panel evaluation\n\nOrchestrates the complete panel evaluation pipeline:\n1. Load spec \u2192 resolve dependencies \u2192 collect signals\n2. Verify inputs \u2192 evaluate slots \u2192 check consistency\n3. Assemble response \u2192 emit metrics\n\nThis is Option A: Spec Interpreter pattern.",
        "functions": [
          {
            "name": "create_panel_engine",
            "signature": "(api_base_url: Optional[str] = None) -> AIConsolePanelEngine",
            "docstring": "Create and initialize panel engine.",
            "is_async": true,
            "line": 322
          },
          {
            "name": "get_panel_engine",
            "signature": "() -> AIConsolePanelEngine",
            "docstring": "Get singleton panel engine.",
            "is_async": true,
            "line": 333
          }
        ],
        "classes": [
          {
            "name": "AIConsolePanelEngine",
            "docstring": "Main orchestration engine for AI Console panel evaluation.\n\nUsage:\n    engine = AIConsolePanelEngine()\n    response = await engine.evaluate_panel(\"OVR-SUM-HL\", params)",
            "methods": [
              "__init__",
              "evaluate_panel",
              "_evaluate_panel_slots",
              "_create_short_circuit_response",
              "evaluate_all_panels",
              "get_panel_ids",
              "get_panel_spec",
              "close"
            ],
            "line": 47
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "panel_consistency_checker",
            "names": [
              "PanelConsistencyChecker",
              "create_consistency_checker"
            ],
            "is_relative": true,
            "line": 34
          },
          {
            "module": "panel_dependency_resolver",
            "names": [
              "PanelDependencyResolver"
            ],
            "is_relative": true,
            "line": 35
          },
          {
            "module": "panel_metrics_emitter",
            "names": [
              "PanelMetricsEmitter",
              "get_panel_metrics_emitter"
            ],
            "is_relative": true,
            "line": 36
          },
          {
            "module": "panel_response_assembler",
            "names": [
              "PanelResponseAssembler",
              "create_response_assembler"
            ],
            "is_relative": true,
            "line": 37
          },
          {
            "module": "panel_signal_collector",
            "names": [
              "PanelSignalCollector",
              "create_signal_collector"
            ],
            "is_relative": true,
            "line": 38
          },
          {
            "module": "panel_slot_evaluator",
            "names": [
              "PanelSlotEvaluator"
            ],
            "is_relative": true,
            "line": 39
          },
          {
            "module": "panel_spec_loader",
            "names": [
              "PanelSpecLoader",
              "get_panel_spec_loader"
            ],
            "is_relative": true,
            "line": 40
          },
          {
            "module": "panel_types",
            "names": [
              "PanelSlotResult",
              "SlotState",
              "VerificationSignals"
            ],
            "is_relative": true,
            "line": 41
          },
          {
            "module": "panel_verification_engine",
            "names": [
              "PanelVerificationEngine"
            ],
            "is_relative": true,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "analytics_facade.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/analytics_facade.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 639,
        "module_docstring": "Analytics Facade (L5)\n\nProvides unified access to analytics domain operations.\nThis is the single entry point for all analytics business logic.\n\nOperations:\n- get_usage_statistics: Get usage statistics for a time window\n- get_cost_statistics: Get cost statistics for a time window\n- get_status: Get analytics domain capability status\n\nSignal Sources:\n- cost_records (cost attribution)\n- llm.usage (LLM runs)\n- worker.execution (trace execution)\n- gateway.metrics (API gateway)\n\nReference: Analytics Domain Declaration v1",
        "functions": [
          {
            "name": "get_analytics_facade",
            "signature": "() -> AnalyticsFacade",
            "docstring": "Get the singleton AnalyticsFacade instance.",
            "is_async": false,
            "line": 634
          }
        ],
        "classes": [
          {
            "name": "ResolutionType",
            "docstring": "Time resolution for analytics data.",
            "methods": [],
            "line": 63
          },
          {
            "name": "ScopeType",
            "docstring": "Scope of analytics aggregation.",
            "methods": [],
            "line": 70
          },
          {
            "name": "TimeWindowResult",
            "docstring": "Time window specification.",
            "methods": [],
            "line": 84
          },
          {
            "name": "UsageTotalsResult",
            "docstring": "Aggregate usage totals.",
            "methods": [],
            "line": 93
          },
          {
            "name": "UsageDataPointResult",
            "docstring": "Single data point in usage time series.",
            "methods": [],
            "line": 102
          },
          {
            "name": "SignalSourceResult",
            "docstring": "Signal source metadata.",
            "methods": [],
            "line": 112
          },
          {
            "name": "UsageStatisticsResult",
            "docstring": "Usage statistics result.",
            "methods": [],
            "line": 120
          },
          {
            "name": "CostTotalsResult",
            "docstring": "Aggregate cost totals.",
            "methods": [],
            "line": 130
          },
          {
            "name": "CostDataPointResult",
            "docstring": "Single data point in cost time series.",
            "methods": [],
            "line": 141
          },
          {
            "name": "CostByModelResult",
            "docstring": "Cost breakdown by model.",
            "methods": [],
            "line": 152
          },
          {
            "name": "CostByFeatureResult",
            "docstring": "Cost breakdown by feature tag.",
            "methods": [],
            "line": 164
          },
          {
            "name": "CostStatisticsResult",
            "docstring": "Cost statistics result.",
            "methods": [],
            "line": 174
          },
          {
            "name": "TopicStatusResult",
            "docstring": "Status of a topic within a subdomain.",
            "methods": [],
            "line": 186
          },
          {
            "name": "AnalyticsStatusResult",
            "docstring": "Analytics domain status.",
            "methods": [],
            "line": 195
          },
          {
            "name": "SignalAdapter",
            "docstring": "Signal adapters for fetching data from various sources.\n\nFacade owns:\n- Time alignment\n- Cardinality control\n- Cross-signal reconciliation\n- Forward compatibility",
            "methods": [
              "fetch_cost_metrics",
              "fetch_llm_usage",
              "fetch_worker_execution",
              "fetch_cost_spend",
              "fetch_cost_by_model",
              "fetch_cost_by_feature"
            ],
            "line": 208
          },
          {
            "name": "AnalyticsFacade",
            "docstring": "Unified facade for Analytics domain operations.\n\nThis class provides a single entry point for all analytics business logic.",
            "methods": [
              "__init__",
              "get_usage_statistics",
              "get_cost_statistics",
              "get_status",
              "_calculate_freshness",
              "_calculate_freshness_from_cost"
            ],
            "line": 329
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.hoc.cus.analytics.L6_drivers.analytics_read_driver",
            "names": [
              "get_analytics_read_driver"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "canary.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/canary.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 648,
        "module_docstring": "Daily canary runner for CostSim V2 validation.\n\nThe canary runner:\n1. Acquires leader lock (only one instance runs at a time)\n2. Loads a sample of historical simulation requests\n3. Runs both V1 and V2 on each sample\n4. Computes drift metrics (KL divergence, percentiles, outliers)\n5. Compares V2 against golden reference datasets\n6. Produces a CanaryReport with pass/fail verdict\n7. Triggers circuit breaker if drift exceeds thresholds\n\nRuns daily via systemd timer or cron.\n\nLeader Election:\n    Only one replica should run the canary at a time. The runner uses\n    PostgreSQL advisory locks to ensure single execution across replicas.\n    If another instance holds the lock, run() returns immediately with\n    a skip status.",
        "functions": [
          {
            "name": "run_canary",
            "signature": "(sample_count: int = 100, drift_threshold: float = 0.2) -> CanaryReport",
            "docstring": "Convenience function to run canary.\n\nArgs:\n    sample_count: Number of samples to test\n    drift_threshold: Maximum acceptable drift\n\nReturns:\n    CanaryReport",
            "is_async": true,
            "line": 629
          }
        ],
        "classes": [
          {
            "name": "CanarySample",
            "docstring": "A single canary test sample.",
            "methods": [],
            "line": 75
          },
          {
            "name": "CanaryRunConfig",
            "docstring": "Configuration for a canary run.",
            "methods": [],
            "line": 86
          },
          {
            "name": "CanaryRunner",
            "docstring": "Daily canary runner for V2 validation.\n\nUsage:\n    runner = CanaryRunner()\n    report = await runner.run()\n\n    if report.passed:\n        print(\"Canary passed!\")\n    else:\n        print(f\"Canary failed: {report.failure_reasons}\")",
            "methods": [
              "__init__",
              "run",
              "_run_internal",
              "_load_samples",
              "_generate_synthetic_samples",
              "_run_single",
              "_calculate_metrics",
              "_approximate_kl_divergence",
              "_compare_with_golden",
              "_evaluate_results",
              "_save_artifacts"
            ],
            "line": 111
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "math",
            "names": [
              "math"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.costsim.circuit_breaker",
            "names": [
              "get_circuit_breaker"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.costsim.circuit_breaker_async",
            "names": [
              "report_drift"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.costsim.config",
            "names": [
              "get_config"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.costsim.leader",
            "names": [
              "LOCK_CANARY_RUNNER",
              "leader_election"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "app.costsim.models",
            "names": [
              "CanaryReport",
              "ComparisonResult",
              "ComparisonVerdict",
              "DiffResult"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "app.costsim.provenance",
            "names": [
              "get_provenance_logger"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "app.costsim.v2_adapter",
            "names": [
              "CostSimV2Adapter"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.worker.simulate",
            "names": [
              "CostSimulator"
            ],
            "is_relative": false,
            "line": 69
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "config.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/config.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 169,
        "module_docstring": "Feature flags and configuration for CostSim V2 sandbox.\n\nEnvironment Variables:\n- COSTSIM_V2_SANDBOX: Enable V2 sandbox path (default: false)\n- COSTSIM_V2_AUTO_DISABLE: Enable auto-disable on drift (default: true)\n- COSTSIM_DRIFT_THRESHOLD: Max acceptable drift score (default: 0.2)\n- COSTSIM_CANARY_ENABLED: Enable daily canary runner (default: true)\n- ALERTMANAGER_URL: Alertmanager API endpoint for alerts\n- INSTANCE_ID: Instance identifier for alerts",
        "functions": [
          {
            "name": "get_config",
            "signature": "() -> CostSimConfig",
            "docstring": "Get the global CostSim configuration.",
            "is_async": false,
            "line": 119
          },
          {
            "name": "is_v2_sandbox_enabled",
            "signature": "() -> bool",
            "docstring": "Check if V2 sandbox is enabled.\n\nReturns False if:\n- COSTSIM_V2_SANDBOX != true\n- Disable file exists (auto-disabled due to drift)",
            "is_async": false,
            "line": 127
          },
          {
            "name": "is_v2_disabled_by_drift",
            "signature": "() -> bool",
            "docstring": "Check if V2 was auto-disabled due to drift.",
            "is_async": false,
            "line": 148
          },
          {
            "name": "get_commit_sha",
            "signature": "() -> str",
            "docstring": "Get current git commit SHA.",
            "is_async": false,
            "line": 154
          }
        ],
        "classes": [
          {
            "name": "CostSimConfig",
            "docstring": "Configuration for CostSim V2.",
            "methods": [
              "from_env"
            ],
            "line": 42
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "coordinator.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/coordinator.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 565,
        "module_docstring": null,
        "functions": [],
        "classes": [
          {
            "name": "CoordinationError",
            "docstring": "Raised when coordination fails in an unrecoverable way.",
            "methods": [
              "__init__"
            ],
            "line": 64
          },
          {
            "name": "CoordinationManager",
            "docstring": "C4 Multi-Envelope Coordination Manager.\n\nThis class enforces all C4 coordination invariants:\n- Tracks active envelopes\n- Checks for conflicts before allowing application\n- Preempts lower-priority envelopes when higher-priority arrives\n- Handles kill-switch all-revert\n- Emits audit records for every decision\n\nThread Safety:\n    This implementation is NOT thread-safe. Production use\n    requires external synchronization or a thread-safe wrapper.",
            "methods": [
              "__init__",
              "active_envelope_count",
              "is_kill_switch_active",
              "get_active_envelopes",
              "get_audit_trail",
              "_get_parameter_key",
              "_emit_audit_record",
              "check_allowed",
              "_find_preemption_targets",
              "apply",
              "_revert_envelope",
              "revert",
              "kill_switch",
              "reset_kill_switch",
              "expire_envelope",
              "get_envelope_for_parameter",
              "get_envelopes_by_class",
              "get_coordination_stats"
            ],
            "line": 73
          }
        ],
        "imports": [
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.optimization.audit_persistence",
            "names": [
              "persist_audit_record"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.optimization.envelope",
            "names": [
              "CoordinationAuditRecord",
              "CoordinationDecision",
              "CoordinationDecisionType",
              "Envelope",
              "EnvelopeClass",
              "EnvelopeLifecycle",
              "RevertReason",
              "has_higher_priority"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 23
          },
          {
            "name": "RETRY_POLICY",
            "line": 24
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "cost_anomaly_detector.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/cost_anomaly_detector.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 1072,
        "module_docstring": "M29 Cost Anomaly Detector - Aligned Rules\n\nCategory 4 Anomaly Rules:\n1. Absolute spike: daily_spend > baseline * 1.4 FOR 2 consecutive daily intervals\n2. Sustained drift: 7d rolling avg > baseline_7d * 1.25 FOR >= 3 days\n3. Severity: LOW +15-25%, MEDIUM +25-40%, HIGH >40%\n\nTHE INVARIANT: Every anomaly triggers an action, not a chart.\n\nDetection Types:\n- ABSOLUTE_SPIKE: Consecutive daily breaches (user, feature, tenant)\n- SUSTAINED_DRIFT: Rolling average above baseline for multiple days\n- BUDGET_WARNING: Projected overrun (warn threshold)\n- BUDGET_EXCEEDED: Hard stop (budget exhausted)",
        "functions": [
          {
            "name": "classify_severity",
            "signature": "(deviation_pct: float) -> AnomalySeverity",
            "docstring": "Classify severity based on percentage deviation.\n\nPlan alignment:\n- LOW: +15% to +25%\n- MEDIUM: +25% to +40%\n- HIGH: >40%\n\nNote: Below 15% is not an anomaly.",
            "is_async": false,
            "line": 144
          },
          {
            "name": "run_anomaly_detection",
            "signature": "(session: Session, tenant_id: str) -> List[CostAnomaly]",
            "docstring": "Run anomaly detection and persist results.",
            "is_async": true,
            "line": 936
          },
          {
            "name": "run_anomaly_detection_with_facts",
            "signature": "(session: Session, tenant_id: str) -> dict",
            "docstring": "Run anomaly detection and emit CostAnomalyFact for HIGH anomalies.\n\nR1 RESOLUTION: Analytics no longer creates incidents directly.\nThis function returns pure facts that callers can pass to the\nincidents domain bridge for incident creation.\n\nAuthority model:\n- Analytics: Detect anomalies, compute severity/confidence (this function)\n- Incidents: Decide if anomaly warrants incident creation (bridge)\n\nReturns:\n    {\n        \"detected\": [CostAnomaly, ...],\n        \"facts\": [CostAnomalyFact, ...],  # Pure facts for HIGH+ anomalies\n    }\n\nNote:\n    Callers that need incident creation should use:\n    from app.hoc.cus.incidents.L3_adapters import AnomalyIncidentBridge\n    bridge = AnomalyIncidentBridge(session)\n    for fact in result[\"facts\"]:\n        incident_id = bridge.ingest(fact)",
            "is_async": true,
            "line": 952
          },
          {
            "name": "run_anomaly_detection_with_governance",
            "signature": "(session: Session, tenant_id: str) -> dict",
            "docstring": "DEPRECATED: Use run_anomaly_detection_with_facts + AnomalyIncidentBridge.\n\nThis function now emits facts and uses the bridge for incident creation.\nKept for backward compatibility during transition.\n\nAuthority model:\n- Analytics: Detect anomalies, emit facts\n- Incidents: Decide incident creation via bridge\n\nReturns:\n    {\n        \"detected\": [CostAnomaly, ...],\n        \"incidents_created\": [{\"anomaly_id\": str, \"incident_id\": str}, ...],\n    }",
            "is_async": true,
            "line": 1026
          }
        ],
        "classes": [
          {
            "name": "AnomalyType",
            "docstring": "Cost anomaly types - minimal set.",
            "methods": [],
            "line": 65
          },
          {
            "name": "AnomalySeverity",
            "docstring": "Aligned severity bands per plan.",
            "methods": [],
            "line": 74
          },
          {
            "name": "DerivedCause",
            "docstring": "Deterministic cause derivation.",
            "methods": [],
            "line": 82
          },
          {
            "name": "DetectedAnomaly",
            "docstring": "A detected cost anomaly.",
            "methods": [],
            "line": 123
          },
          {
            "name": "CostAnomalyDetector",
            "docstring": "Detects cost anomalies with aligned rules.\n\nPhase-2.5A Extraction: DB operations delegated to CostAnomalyDriver (L6).\nThis engine (L4) retains:\n- Threshold comparisons\n- Severity classification\n- Anomaly type decisions\n\nRules:\n1. ABSOLUTE_SPIKE: daily > baseline * 1.4 for 2 consecutive intervals\n2. SUSTAINED_DRIFT: 7d rolling avg > baseline_7d * 1.25 for >= 3 days\n3. BUDGET_WARNING: spend > warn_threshold_pct of budget\n4. BUDGET_EXCEEDED: spend >= 100% of budget",
            "methods": [
              "__init__",
              "detect_all",
              "detect_absolute_spikes",
              "_detect_entity_spikes",
              "_detect_tenant_spike",
              "detect_sustained_drift",
              "detect_budget_issues",
              "_check_budget_threshold",
              "_record_breach_and_get_consecutive_count",
              "_reset_breach_history",
              "_update_drift_tracking",
              "_reset_drift_tracking",
              "_derive_cause",
              "_format_spike_message",
              "persist_anomalies"
            ],
            "line": 171
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.db",
            "names": [
              "CostAnomaly",
              "CostBudget",
              "utc_now"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [
          {
            "name": "ABSOLUTE_SPIKE_THRESHOLD",
            "line": 98
          },
          {
            "name": "CONSECUTIVE_INTERVALS_REQUIRED",
            "line": 101
          },
          {
            "name": "SUSTAINED_DRIFT_THRESHOLD",
            "line": 104
          },
          {
            "name": "DRIFT_DAYS_REQUIRED",
            "line": 107
          },
          {
            "name": "SEVERITY_BANDS",
            "line": 110
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "cost_model_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/cost_model_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 455,
        "module_docstring": "L4 Cost Model Engine - Domain Authority for Cost/Risk Estimation\n\nB02 FIX: Moved from L3 CostSimV2Adapter to L4 domain engine.\nThis engine is the authoritative source for:\n- Cost model coefficients (per-skill pricing)\n- Risk estimation logic\n- Feasibility determination\n- Drift classification\n\nL3 adapters must delegate all domain decisions to this engine.",
        "functions": [
          {
            "name": "get_skill_coefficients",
            "signature": "(skill_id: str) -> Dict[str, float]",
            "docstring": "Get cost model coefficients for a skill (L4 domain function).\n\nArgs:\n    skill_id: Skill identifier\n\nReturns:\n    Coefficient dictionary",
            "is_async": false,
            "line": 193
          },
          {
            "name": "estimate_step_cost",
            "signature": "(step_index: int, skill_id: str, params: Dict[str, Any]) -> StepCostEstimate",
            "docstring": "Estimate cost and latency for a single step (L4 domain function).\n\nL3 adapters must NOT implement their own estimation logic.\n\nArgs:\n    step_index: Step position in plan\n    skill_id: Skill identifier\n    params: Step parameters\n\nReturns:\n    StepCostEstimate with cost, latency, confidence, and risks",
            "is_async": false,
            "line": 206
          },
          {
            "name": "calculate_cumulative_risk",
            "signature": "(risks: List[Dict[str, float]]) -> float",
            "docstring": "Calculate cumulative risk from individual risk factors (L4 domain function).\n\nUses probability complement formula: 1 - prod(1 - p_i)\n\nArgs:\n    risks: List of risk factor dictionaries\n\nReturns:\n    Cumulative risk probability (0.0 to 1.0)",
            "is_async": false,
            "line": 301
          },
          {
            "name": "check_feasibility",
            "signature": "(estimated_cost_cents: int, budget_cents: int, permission_gaps: List[str], cumulative_risk: float, risk_threshold: float = DEFAULT_RISK_THRESHOLD) -> FeasibilityResult",
            "docstring": "Check if a plan is feasible (L4 domain function).\n\nL3 adapters must NOT implement feasibility logic.\n\nArgs:\n    estimated_cost_cents: Estimated total cost\n    budget_cents: Available budget\n    permission_gaps: Skills without permission\n    cumulative_risk: Cumulative risk probability\n    risk_threshold: Maximum acceptable risk\n\nReturns:\n    FeasibilityResult with decision and reasons",
            "is_async": false,
            "line": 320
          },
          {
            "name": "classify_drift",
            "signature": "(v1_cost_cents: int, v2_cost_cents: int, v1_feasible: bool, v2_feasible: bool) -> DriftAnalysis",
            "docstring": "Classify drift between V1 and V2 simulation results (L4 domain function).\n\nL3 adapters must NOT implement drift classification.\n\nArgs:\n    v1_cost_cents: V1 estimated cost\n    v2_cost_cents: V2 estimated cost\n    v1_feasible: V1 feasibility\n    v2_feasible: V2 feasibility\n\nReturns:\n    DriftAnalysis with verdict and details",
            "is_async": false,
            "line": 366
          },
          {
            "name": "is_significant_risk",
            "signature": "(probability: float) -> bool",
            "docstring": "Check if a risk factor is significant enough to report (L4 domain function).",
            "is_async": false,
            "line": 424
          }
        ],
        "classes": [
          {
            "name": "DriftVerdict",
            "docstring": "Classification of drift between V1 and V2 simulation results.",
            "methods": [],
            "line": 128
          },
          {
            "name": "StepCostEstimate",
            "docstring": "Enhanced step estimate with confidence (L4 domain output).",
            "methods": [],
            "line": 159
          },
          {
            "name": "FeasibilityResult",
            "docstring": "Result of feasibility check (L4 domain output).",
            "methods": [],
            "line": 171
          },
          {
            "name": "DriftAnalysis",
            "docstring": "Result of drift analysis between V1 and V2 (L4 domain output).",
            "methods": [],
            "line": 183
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [
          {
            "name": "DRIFT_THRESHOLD_MATCH",
            "line": 138
          },
          {
            "name": "DRIFT_THRESHOLD_MINOR",
            "line": 139
          },
          {
            "name": "DRIFT_THRESHOLD_MAJOR",
            "line": 140
          },
          {
            "name": "DEFAULT_RISK_THRESHOLD",
            "line": 148
          },
          {
            "name": "SIGNIFICANT_RISK_THRESHOLD",
            "line": 151
          },
          {
            "name": "CONFIDENCE_DEGRADATION_LONG_PROMPT",
            "line": 154
          },
          {
            "name": "CONFIDENCE_DEGRADATION_VERY_LONG_PROMPT",
            "line": 155
          }
        ],
        "all_exports": [
          "SKILL_COST_COEFFICIENTS",
          "UNKNOWN_SKILL_COEFFICIENTS",
          "DEFAULT_RISK_THRESHOLD",
          "SIGNIFICANT_RISK_THRESHOLD",
          "DRIFT_THRESHOLD_MATCH",
          "DRIFT_THRESHOLD_MINOR",
          "DRIFT_THRESHOLD_MAJOR",
          "DriftVerdict",
          "StepCostEstimate",
          "FeasibilityResult",
          "DriftAnalysis",
          "get_skill_coefficients",
          "estimate_step_cost",
          "calculate_cumulative_risk",
          "check_feasibility",
          "classify_drift",
          "is_significant_risk"
        ]
      },
      {
        "file_name": "cost_snapshots.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/cost_snapshots.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 933,
        "module_docstring": "M27 Cost Snapshots - Deterministic Enforcement Barrier\n\nThis module provides the snapshot layer between async cost ingestion\nand synchronous anomaly detection.\n\nTHE INVARIANT:\n  Anomaly detection reads ONLY from complete snapshots, never from live data.\n\nArchitecture:\n  cost_records (streaming, async)\n         \u2193\n  SnapshotComputer.compute_snapshot()\n         \u2193\n  cost_snapshots (status='complete')\n         \u2193\n  CostAnomalyDetector.evaluate_from_snapshot()\n\nUsage:\n  # Scheduled job (e.g., every hour)\n  computer = SnapshotComputer(session)\n  snapshot = await computer.compute_hourly_snapshot(tenant_id)\n\n  # Anomaly detection (only reads complete snapshots)\n  detector = CostAnomalyDetector(session)\n  anomalies = await detector.evaluate_from_snapshot(snapshot.id)",
        "functions": [
          {
            "name": "run_hourly_snapshot_job",
            "signature": "(session: AsyncSession, tenant_ids: list[str]) -> dict",
            "docstring": "Run hourly snapshot job for multiple tenants.\n\nSchedule this via cron/systemd timer every hour at :05.",
            "is_async": true,
            "line": 869
          },
          {
            "name": "run_daily_snapshot_and_baseline_job",
            "signature": "(session: AsyncSession, tenant_ids: list[str]) -> dict",
            "docstring": "Run daily snapshot and baseline computation for multiple tenants.\n\nSchedule this via cron/systemd timer daily at 00:30.",
            "is_async": true,
            "line": 890
          }
        ],
        "classes": [
          {
            "name": "SnapshotComputer",
            "docstring": "Computes cost snapshots from raw cost_records.\n\nUsage:\n    computer = SnapshotComputer(session)\n    snapshot = await computer.compute_hourly_snapshot(tenant_id)\n    # snapshot.status == 'complete' if successful",
            "methods": [
              "__init__",
              "compute_hourly_snapshot",
              "compute_daily_snapshot",
              "_compute_snapshot",
              "_aggregate_cost_records",
              "_get_current_baseline",
              "_insert_snapshot",
              "_update_snapshot",
              "_insert_aggregate"
            ],
            "line": 84
          },
          {
            "name": "BaselineComputer",
            "docstring": "Computes rolling baselines from historical snapshots.\n\nRun daily after daily snapshot completes.\n\nUsage:\n    computer = BaselineComputer(session)\n    baselines = await computer.compute_baselines(tenant_id)",
            "methods": [
              "__init__",
              "compute_baselines",
              "_insert_baseline"
            ],
            "line": 534
          },
          {
            "name": "SnapshotAnomalyDetector",
            "docstring": "Detects anomalies from complete snapshots only.\n\nTHE INVARIANT:\n  This detector NEVER reads from cost_records.\n  It ONLY reads from complete snapshots.\n\nUsage:\n    detector = SnapshotAnomalyDetector(session)\n    anomalies = await detector.evaluate_snapshot(snapshot_id)",
            "methods": [
              "__init__",
              "evaluate_snapshot",
              "_get_snapshot",
              "_insert_evaluation",
              "_create_anomaly_from_evaluation"
            ],
            "line": 668
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "schemas.cost_snapshot_schemas",
            "names": [
              "SEVERITY_THRESHOLDS",
              "AnomalyEvaluation",
              "CostSnapshot",
              "EntityType",
              "SnapshotAggregate",
              "SnapshotBaseline",
              "SnapshotStatus",
              "SnapshotType"
            ],
            "is_relative": true,
            "line": 57
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cost_write_engine.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/cost_write_engine.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 161,
        "module_docstring": "Cost Write Engine (L5)\n\nDB write operations for Cost Intelligence API.\nDelegates to CostWriteDriver (L6) for all database access.\n\nL2 (API) \u2192 L4 (this service) \u2192 L6 (CostWriteDriver)\n\nResponsibilities:\n- Delegate to L6 driver for data access\n- Maintain backward compatibility for callers\n\nReference: PIN-250, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [],
        "classes": [
          {
            "name": "CostWriteService",
            "docstring": "DB write operations for Cost Intelligence.\n\nDelegates all operations to CostWriteDriver (L6).\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "create_feature_tag",
              "update_feature_tag",
              "create_cost_record",
              "create_or_update_budget"
            ],
            "line": 56
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.hoc.cus.analytics.L6_drivers.cost_write_driver",
            "names": [
              "CostWriteDriver",
              "get_cost_write_driver"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "costsim_models.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/costsim_models.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 305,
        "module_docstring": "Data models for CostSim V2 sandbox evaluation.",
        "functions": [],
        "classes": [
          {
            "name": "V2SimulationStatus",
            "docstring": "V2 simulation result status.",
            "methods": [],
            "line": 33
          },
          {
            "name": "ComparisonVerdict",
            "docstring": "Verdict from V1 vs V2 comparison.",
            "methods": [],
            "line": 42
          },
          {
            "name": "V2SimulationResult",
            "docstring": "Result from CostSim V2 simulation.",
            "methods": [
              "to_dict",
              "compute_output_hash"
            ],
            "line": 52
          },
          {
            "name": "ComparisonResult",
            "docstring": "Result of comparing V2 vs V1 simulation.",
            "methods": [
              "to_dict"
            ],
            "line": 109
          },
          {
            "name": "DiffResult",
            "docstring": "Detailed diff between two simulation results.",
            "methods": [
              "to_dict"
            ],
            "line": 150
          },
          {
            "name": "CanaryReport",
            "docstring": "Report from daily canary run.",
            "methods": [
              "to_dict"
            ],
            "line": 182
          },
          {
            "name": "DivergenceReport",
            "docstring": "Cost divergence report between V1 and V2.",
            "methods": [
              "to_dict"
            ],
            "line": 233
          },
          {
            "name": "ValidationResult",
            "docstring": "Result of validating V2 against a reference dataset.",
            "methods": [
              "to_dict"
            ],
            "line": 270
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 30
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "datasets.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/datasets.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 723,
        "module_docstring": "Reference datasets for V2 validation.\n\nRequired datasets (5):\n1. low_variance - Simple, predictable plans\n2. high_variance - Complex, high-variance plans\n3. mixed_city - Mixed workload patterns\n4. noise_injected - Plans with deliberate noise\n5. historical - Real historical data samples\n\nEach dataset provides:\n- Sample plans for testing\n- Expected V2 behavior\n- Validation metrics thresholds",
        "functions": [
          {
            "name": "get_dataset_validator",
            "signature": "() -> DatasetValidator",
            "docstring": "Get the global dataset validator.",
            "is_async": false,
            "line": 706
          },
          {
            "name": "validate_dataset",
            "signature": "(dataset_id: str) -> ValidationResult",
            "docstring": "Convenience function to validate a dataset.",
            "is_async": true,
            "line": 714
          },
          {
            "name": "validate_all_datasets",
            "signature": "() -> Dict[str, ValidationResult]",
            "docstring": "Convenience function to validate all datasets.",
            "is_async": true,
            "line": 720
          }
        ],
        "classes": [
          {
            "name": "DatasetSample",
            "docstring": "A single sample in a reference dataset.",
            "methods": [],
            "line": 50
          },
          {
            "name": "ReferenceDataset",
            "docstring": "A reference dataset for validation.",
            "methods": [
              "to_dict"
            ],
            "line": 63
          },
          {
            "name": "DatasetValidator",
            "docstring": "Validator for V2 against reference datasets.\n\nUsage:\n    validator = DatasetValidator()\n    result = await validator.validate_dataset(\"low_variance\")",
            "methods": [
              "__init__",
              "_build_datasets",
              "_build_low_variance_dataset",
              "_build_high_variance_dataset",
              "_build_mixed_city_dataset",
              "_build_noise_injected_dataset",
              "_build_historical_dataset",
              "list_datasets",
              "get_dataset",
              "validate_dataset",
              "_calculate_drift_score",
              "validate_all"
            ],
            "line": 83
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "math",
            "names": [
              "math"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "random",
            "names": [
              "random"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.costsim.models",
            "names": [
              "ValidationResult"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "app.costsim.v2_adapter",
            "names": [
              "CostSimV2Adapter"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "detection_facade.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/detection_facade.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 559,
        "module_docstring": "Detection Facade (L5 Domain Engine)\n\nThis facade provides the external interface for anomaly detection operations.\nAll detection APIs MUST use this facade instead of directly importing\ninternal detection modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes anomaly detection logic\n- Provides unified access to cost, behavioral, and policy anomalies\n- Single point for audit emission\n\nWrapped Services:\n- CostAnomalyDetector: Cost anomaly detection (GAP-066)\n- (Future) BehavioralDetector: Behavioral anomaly detection\n- (Future) DriftDetector: Model drift detection\n\nL2 API Routes (GAP-102):\n- POST /api/v1/detection/run (run detection on demand)\n- GET /api/v1/detection/anomalies (list anomalies)\n- GET /api/v1/detection/anomalies/{id} (get anomaly)\n- POST /api/v1/detection/anomalies/{id}/resolve (resolve anomaly)\n- GET /api/v1/detection/status (detection engine status)\n\nUsage:\n    from app.services.detection.facade import get_detection_facade\n\n    facade = get_detection_facade()\n\n    # Run detection\n    result = await facade.run_detection(tenant_id=\"...\", detection_type=\"cost\")\n\n    # List anomalies\n    anomalies = await facade.list_anomalies(tenant_id=\"...\")",
        "functions": [
          {
            "name": "get_detection_facade",
            "signature": "() -> DetectionFacade",
            "docstring": "Get the detection facade instance.\n\nThis is the recommended way to access detection operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    DetectionFacade instance",
            "is_async": false,
            "line": 546
          }
        ],
        "classes": [
          {
            "name": "DetectionType",
            "docstring": "Types of anomaly detection.",
            "methods": [],
            "line": 67
          },
          {
            "name": "AnomalyStatus",
            "docstring": "Anomaly resolution status.",
            "methods": [],
            "line": 82
          },
          {
            "name": "DetectionResult",
            "docstring": "Result of a detection run.",
            "methods": [
              "to_dict"
            ],
            "line": 91
          },
          {
            "name": "AnomalyInfo",
            "docstring": "Anomaly information.",
            "methods": [
              "to_dict"
            ],
            "line": 117
          },
          {
            "name": "DetectionStatusInfo",
            "docstring": "Detection engine status.",
            "methods": [
              "to_dict"
            ],
            "line": 161
          },
          {
            "name": "DetectionFacade",
            "docstring": "Facade for anomaly detection operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ndetection services.\n\nLayer: L4 (Domain Logic)\nCallers: detection.py (L2), aos_sdk, Worker",
            "methods": [
              "__init__",
              "cost_detector",
              "run_detection",
              "_run_cost_detection",
              "list_anomalies",
              "get_anomaly",
              "resolve_anomaly",
              "acknowledge_anomaly",
              "get_detection_status"
            ],
            "line": 178
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.hoc.cus.analytics.L5_engines.cost_anomaly_detector",
            "names": [
              "AnomalySeverity"
            ],
            "is_relative": false,
            "line": 77
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "divergence.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/divergence.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 365,
        "module_docstring": "Cost divergence reporting between V1 and V2.\n\nProvides:\n- delta_p50: Median cost delta\n- delta_p90: 90th percentile cost delta\n- kl_divergence: KL divergence between cost distributions\n- outlier_count: Number of outlier samples\n- fail_ratio: Ratio of major drift samples\n- matching_rate: Ratio of matching samples\n\nReports can be generated:\n- On-demand via API\n- Automatically by canary runner\n- Scheduled via cron/systemd timer",
        "functions": [
          {
            "name": "generate_divergence_report",
            "signature": "(start_date: Optional[datetime] = None, end_date: Optional[datetime] = None, tenant_id: Optional[str] = None) -> DivergenceReport",
            "docstring": "Convenience function to generate a divergence report.\n\nArgs:\n    start_date: Start of analysis period\n    end_date: End of analysis period\n    tenant_id: Filter by tenant\n\nReturns:\n    DivergenceReport",
            "is_async": true,
            "line": 344
          }
        ],
        "classes": [
          {
            "name": "DivergenceSample",
            "docstring": "A single sample for divergence analysis.",
            "methods": [],
            "line": 52
          },
          {
            "name": "DivergenceAnalyzer",
            "docstring": "Analyzer for V1 vs V2 cost divergence.\n\nUsage:\n    analyzer = DivergenceAnalyzer()\n    report = await analyzer.generate_report(\n        start_date=datetime.now() - timedelta(days=7),\n        end_date=datetime.now(),\n    )",
            "methods": [
              "__init__",
              "generate_report",
              "_load_samples",
              "_parse_provenance_log",
              "_calculate_metrics",
              "_calculate_kl_divergence"
            ],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "math",
            "names": [
              "math"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.costsim.config",
            "names": [
              "get_config"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.costsim.models",
            "names": [
              "DivergenceReport"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.costsim.provenance",
            "names": [
              "ProvenanceLog",
              "get_provenance_logger"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "envelope.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/envelope.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 436,
        "module_docstring": null,
        "functions": [
          {
            "name": "get_envelope_priority",
            "signature": "(envelope_class: EnvelopeClass) -> int",
            "docstring": "Get the priority of an envelope class (lower number = higher priority).",
            "is_async": false,
            "line": 82
          },
          {
            "name": "has_higher_priority",
            "signature": "(class_a: EnvelopeClass, class_b: EnvelopeClass) -> bool",
            "docstring": "Check if class_a has higher priority than class_b.",
            "is_async": false,
            "line": 87
          },
          {
            "name": "validate_envelope",
            "signature": "(envelope: Envelope) -> None",
            "docstring": "Validate envelope against hard gate rules (V1-V5 + CI-C4-1).\n\nThese rules are evaluated BEFORE an envelope can ever apply.\nIf any rule fails, the envelope is REJECTED.\n\nRaises:\n    EnvelopeValidationError: If validation fails",
            "is_async": false,
            "line": 298
          },
          {
            "name": "calculate_bounded_value",
            "signature": "(baseline: float, bounds: EnvelopeBounds, prediction_confidence: float) -> float",
            "docstring": "Calculate the bounded value based on prediction confidence.\n\nThe value is scaled linearly with confidence within bounds.\nHandles both increase (S1) and decrease (S2) scenarios.\n\nArgs:\n    baseline: The baseline value\n    bounds: The envelope bounds\n    prediction_confidence: The prediction confidence (0.0-1.0)\n\nReturns:\n    The bounded adjusted value",
            "is_async": false,
            "line": 374
          },
          {
            "name": "create_audit_record",
            "signature": "(envelope: Envelope, baseline_value: float) -> EnvelopeAuditRecord",
            "docstring": "Create an audit record for envelope application.",
            "is_async": false,
            "line": 423
          }
        ],
        "classes": [
          {
            "name": "DeltaType",
            "docstring": "How bounds are expressed.",
            "methods": [],
            "line": 46
          },
          {
            "name": "EnvelopeClass",
            "docstring": "C4 Envelope Class (FROZEN priority order).\n\nReference: C4_ENVELOPE_COORDINATION_CONTRACT.md Section 4\n\nPriority order (immutable):\n    SAFETY > RELIABILITY > COST > PERFORMANCE\n\nHigher priority always dominates lower priority.\nNo dynamic reprioritization. No confidence-based overrides.",
            "methods": [],
            "line": 53
          },
          {
            "name": "BaselineSource",
            "docstring": "Where baseline value comes from.",
            "methods": [],
            "line": 92
          },
          {
            "name": "EnvelopeLifecycle",
            "docstring": "Fixed envelope lifecycle states.\n\nLifecycle invariants:\n- Envelope may only be Applied once\n- Envelope may only be Active within timebox\n- Envelope must always end in Reverted or Expired\n- No terminal \"active\" state",
            "methods": [],
            "line": 99
          },
          {
            "name": "RevertReason",
            "docstring": "Why an envelope was reverted.",
            "methods": [],
            "line": 118
          },
          {
            "name": "EnvelopeTrigger",
            "docstring": "What prediction triggers this envelope.",
            "methods": [],
            "line": 133
          },
          {
            "name": "EnvelopeScope",
            "docstring": "What this envelope affects.",
            "methods": [],
            "line": 141
          },
          {
            "name": "EnvelopeBounds",
            "docstring": "Numerical bounds for the envelope.",
            "methods": [],
            "line": 149
          },
          {
            "name": "EnvelopeTimebox",
            "docstring": "Time constraints for the envelope.",
            "methods": [],
            "line": 159
          },
          {
            "name": "EnvelopeBaseline",
            "docstring": "Baseline value reference.",
            "methods": [],
            "line": 167
          },
          {
            "name": "EnvelopeAuditRecord",
            "docstring": "Immutable audit record for envelope lifecycle.\n\nRequired by C3_ENVELOPE_ABSTRACTION.md section 7.",
            "methods": [],
            "line": 176
          },
          {
            "name": "CoordinationDecisionType",
            "docstring": "C4 coordination decision types.",
            "methods": [],
            "line": 195
          },
          {
            "name": "CoordinationAuditRecord",
            "docstring": "C4 Coordination audit record.\n\nRequired by C4_ENVELOPE_COORDINATION_CONTRACT.md Section 7.\nEvery coordination decision must emit this record.",
            "methods": [],
            "line": 204
          },
          {
            "name": "CoordinationDecision",
            "docstring": "Result of a coordination check.\n\nUsed by CoordinationManager.check_allowed() to communicate\nwhether an envelope may apply.",
            "methods": [],
            "line": 224
          },
          {
            "name": "Envelope",
            "docstring": "Declarative optimization envelope.\n\nNothing implicit. Nothing inferred.\nIf any required field is missing, the envelope is INVALID.\n\nC4 additions:\n- envelope_class: Required classification (SAFETY/RELIABILITY/COST/PERFORMANCE)",
            "methods": [],
            "line": 240
          },
          {
            "name": "EnvelopeValidationError",
            "docstring": "Raised when envelope fails validation.",
            "methods": [
              "__init__"
            ],
            "line": 289
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "metrics.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/metrics.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 617,
        "module_docstring": "Prometheus metrics for CostSim V2 drift detection.\n\nMetrics (6 required):\n1. costsim_v2_drift_score - Drift score histogram\n2. costsim_v2_cost_delta_cents - Cost delta distribution\n3. costsim_v2_schema_errors_total - Schema validation errors\n4. costsim_v2_simulation_duration_ms - V2 simulation latency\n5. costsim_v2_comparison_verdict - Verdict distribution\n6. costsim_v2_circuit_breaker_state - Circuit breaker state\n\nAlert Rules:\n- P1: drift_score > 0.2 for 5m (auto-disable)\n- P2: drift_score > 0.15 for 15m (warning)\n- P3: schema_errors > 5 in 1h (investigate)",
        "functions": [
          {
            "name": "get_metrics",
            "signature": "() -> CostSimMetrics",
            "docstring": "Get the global CostSim metrics instance.",
            "is_async": false,
            "line": 485
          },
          {
            "name": "get_alert_rules",
            "signature": "() -> str",
            "docstring": "Get Prometheus alert rules YAML.",
            "is_async": false,
            "line": 615
          }
        ],
        "classes": [
          {
            "name": "CostSimMetrics",
            "docstring": "Prometheus metrics for CostSim V2.\n\nUsage:\n    metrics = CostSimMetrics()\n    metrics.record_drift(drift_score=0.15, verdict=\"minor_drift\")\n    metrics.record_cost_delta(delta_cents=25)\n    metrics.record_schema_error()",
            "methods": [
              "__init__",
              "_init_metrics",
              "record_drift",
              "record_cost_delta",
              "record_schema_error",
              "record_simulation_duration",
              "record_simulation",
              "set_circuit_breaker_state",
              "record_provenance_log",
              "record_canary_run",
              "set_kl_divergence",
              "record_cb_disabled",
              "record_cb_enabled",
              "record_cb_incident",
              "set_alert_queue_depth",
              "record_alert_send_failure",
              "record_auto_recovery",
              "set_consecutive_failures"
            ],
            "line": 59
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.costsim.config",
            "names": [
              "get_config"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [
          {
            "name": "DRIFT_SCORE_BUCKETS",
            "line": 54
          },
          {
            "name": "COST_DELTA_BUCKETS",
            "line": 55
          },
          {
            "name": "DURATION_BUCKETS",
            "line": 56
          },
          {
            "name": "ALERT_RULES_YAML",
            "line": 494
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "pattern_detection.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/pattern_detection.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 409,
        "module_docstring": "Pattern Detection Service (PB-S3)\n\nDetects patterns in execution data and emits feedback WITHOUT modifying history.\n\nPB-S3 Contract:\n- Observe patterns \u2192 create feedback \u2192 do nothing else\n- NO modification of worker_runs, traces, or costs\n- Feedback stored SEPARATELY in pattern_feedback table\n\nPattern Types:\n- failure_pattern: Same error signature N times\n- cost_spike: Abnormal cost increase detected",
        "functions": [
          {
            "name": "compute_error_signature",
            "signature": "(error: str) -> str",
            "docstring": "Compute a stable signature for an error message.\n\nStrips variable parts (IDs, timestamps) to group similar errors.",
            "is_async": false,
            "line": 73
          },
          {
            "name": "detect_failure_patterns",
            "signature": "(driver: PatternDetectionDriver, tenant_id: Optional[UUID] = None, threshold: int = FAILURE_PATTERN_THRESHOLD, window_hours: int = FAILURE_PATTERN_WINDOW_HOURS) -> list[dict]",
            "docstring": "Detect repeated failure patterns.\n\nPB-S3: This function READS execution data only. No modifications.\n\nReturns list of detected patterns with:\n- signature: error signature\n- count: number of occurrences\n- run_ids: list of affected runs (provenance)\n- sample_error: example error message",
            "is_async": true,
            "line": 96
          },
          {
            "name": "detect_cost_spikes",
            "signature": "(driver: PatternDetectionDriver, tenant_id: Optional[UUID] = None, spike_threshold_percent: float = COST_SPIKE_THRESHOLD_PERCENT, min_runs: int = COST_SPIKE_MIN_RUNS) -> list[dict]",
            "docstring": "Detect abnormal cost increases.\n\nPB-S3: This function READS cost data only. No modifications.\n\nReturns list of detected cost spikes with:\n- worker_id: affected worker\n- avg_cost: rolling average\n- recent_cost: recent run cost\n- spike_percent: percentage increase\n- run_ids: affected runs (provenance)",
            "is_async": true,
            "line": 159
          },
          {
            "name": "emit_feedback",
            "signature": "(driver: PatternDetectionDriver, feedback: PatternFeedbackCreate) -> dict",
            "docstring": "Emit a feedback record.\n\nPB-S3: This creates a NEW record in pattern_feedback.\nIt does NOT modify any execution data.\n\nReturns:\n    Dictionary with feedback record info",
            "is_async": true,
            "line": 235
          },
          {
            "name": "run_pattern_detection",
            "signature": "(tenant_id: Optional[UUID] = None) -> dict",
            "docstring": "Run full pattern detection cycle.\n\nPB-S3: Detects patterns and emits feedback. No execution modifications.\n\nReturns summary of detected patterns and emitted feedback.",
            "is_async": true,
            "line": 283
          },
          {
            "name": "get_feedback_summary",
            "signature": "(tenant_id: Optional[UUID] = None, acknowledged: Optional[bool] = None, limit: int = 50) -> dict",
            "docstring": "Get feedback summary for ops visibility.\n\nPB-S3: Read-only query of feedback table.",
            "is_async": true,
            "line": 366
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "datetime",
            "names": [
              "timedelta"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "app.models.feedback",
            "names": [
              "PatternFeedbackCreate"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "app.hoc.cus.analytics.L6_drivers.pattern_detection_driver",
            "names": [
              "PatternDetectionDriver",
              "get_pattern_detection_driver"
            ],
            "is_relative": false,
            "line": 59
          }
        ],
        "constants": [
          {
            "name": "FAILURE_PATTERN_THRESHOLD",
            "line": 67
          },
          {
            "name": "FAILURE_PATTERN_WINDOW_HOURS",
            "line": 68
          },
          {
            "name": "COST_SPIKE_THRESHOLD_PERCENT",
            "line": 69
          },
          {
            "name": "COST_SPIKE_MIN_RUNS",
            "line": 70
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "prediction.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/prediction.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 463,
        "module_docstring": "Prediction Service (PB-S5)\n\nGenerates predictions WITHOUT affecting execution behavior.\n\nPhase-2.5A Extraction:\n- PERSISTENCE: Delegated to PredictionDriver (L6)\n- DECISIONS: Retained in this engine (L4)\n\nPB-S5 Contract:\n- Advise \u2192 Observe \u2192 Do Nothing\n- Predictions are advisory only\n- Predictions have zero side-effects\n- Predictions never modify execution, scheduling, or history\n\nRule: Advise, don't influence.",
        "functions": [
          {
            "name": "predict_failure_likelihood",
            "signature": "(driver: 'PredictionDriver', tenant_id: Optional[UUID] = None, worker_id: Optional[str] = None) -> list[dict]",
            "docstring": "Predict likelihood of failure for upcoming runs.\n\nPhase-2.5A: Data fetching delegated to driver (L6).\n\nPB-S5: This function calculates predictions only. No modifications.\nPredictions are advisory and have ZERO side-effects.\n\nReturns list of predictions with:\n- subject_id: worker or tenant being predicted\n- confidence_score: likelihood of failure (0.0-1.0)\n- contributing_factors: signals used for prediction",
            "is_async": true,
            "line": 76
          },
          {
            "name": "predict_cost_overrun",
            "signature": "(driver: 'PredictionDriver', tenant_id: Optional[UUID] = None, worker_id: Optional[str] = None) -> list[dict]",
            "docstring": "Predict likelihood of cost overrun for upcoming runs.\n\nPhase-2.5A: Data fetching delegated to driver (L6).\n\nPB-S5: This function calculates predictions only. No modifications.\nPredictions are advisory and have ZERO side-effects.\n\nReturns list of predictions with:\n- subject_id: worker or tenant being predicted\n- confidence_score: likelihood of overrun (0.0-1.0)\n- projected_cost: expected cost\n- contributing_factors: signals used for prediction",
            "is_async": true,
            "line": 175
          },
          {
            "name": "emit_prediction",
            "signature": "(driver: 'PredictionDriver', tenant_id: str, prediction_type: str, subject_type: str, subject_id: str, confidence_score: float, prediction_value: dict, contributing_factors: list, notes: Optional[str] = None, valid_until: Optional['datetime'] = None) -> 'PredictionEvent'",
            "docstring": "Emit a prediction event.\n\nPhase-2.5A: Persistence delegated to driver (L6).\n\nPB-S5: This creates a NEW record in prediction_events.\nIt does NOT modify any execution data. Predictions are advisory only.",
            "is_async": true,
            "line": 274
          },
          {
            "name": "run_prediction_cycle",
            "signature": "(tenant_id: Optional[UUID] = None) -> dict",
            "docstring": "Run full prediction cycle.\n\nPhase-2.5A: Data access delegated to driver (L6).\nThis method orchestrates the prediction flow (L4 DECISION).\n\nPB-S5: Generates predictions. No execution modifications.\n\nReturns summary of generated predictions.",
            "is_async": true,
            "line": 329
          },
          {
            "name": "get_prediction_summary",
            "signature": "(tenant_id: Optional[UUID] = None, prediction_type: Optional[str] = None, include_expired: bool = False, limit: int = 50) -> dict",
            "docstring": "Get prediction summary for ops visibility.\n\nPhase-2.5A: Data fetching delegated to driver (L6).\n\nPB-S5: Read-only query of predictions table.",
            "is_async": true,
            "line": 410
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "datetime",
            "names": [
              "timedelta"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.db",
            "names": [
              "get_async_session"
            ],
            "is_relative": false,
            "line": 66
          }
        ],
        "constants": [
          {
            "name": "FAILURE_CONFIDENCE_THRESHOLD",
            "line": 71
          },
          {
            "name": "COST_OVERRUN_THRESHOLD_PERCENT",
            "line": 72
          },
          {
            "name": "PREDICTION_VALIDITY_HOURS",
            "line": 73
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "provenance.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/provenance.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 385,
        "module_docstring": "Full provenance logging for CostSim V2 sandbox.\n\nLogs:\n- input_hash: SHA256 of input\n- output_hash: SHA256 of output\n- input_json: Full input (optionally compressed)\n- output_json: Full output (optionally compressed)\n- model_version: V2 model version\n- adapter_version: Adapter version\n- commit_sha: Git commit\n- runtime_ms: Execution time\n- status: success/error/schema_error\n- tenant_id: Tenant if present",
        "functions": [
          {
            "name": "compute_hash",
            "signature": "(data: Any) -> str",
            "docstring": "Compute SHA256 hash of data.",
            "is_async": false,
            "line": 142
          },
          {
            "name": "compress_json",
            "signature": "(data: Any) -> str",
            "docstring": "Compress JSON data to base64-encoded gzip.",
            "is_async": false,
            "line": 151
          },
          {
            "name": "get_provenance_logger",
            "signature": "() -> ProvenanceLogger",
            "docstring": "Get the global provenance logger.",
            "is_async": false,
            "line": 380
          }
        ],
        "classes": [
          {
            "name": "ProvenanceLog",
            "docstring": "Single provenance log entry.",
            "methods": [
              "to_dict",
              "from_dict",
              "get_decompressed_input",
              "get_decompressed_output"
            ],
            "line": 55
          },
          {
            "name": "ProvenanceLogger",
            "docstring": "Logger for CostSim V2 provenance.\n\nStores provenance logs for every V2 simulation for:\n- Audit trail\n- Debugging\n- Drift analysis\n- Replay capability",
            "methods": [
              "__init__",
              "log",
              "_store",
              "_flush",
              "_write_to_file",
              "_write_to_db",
              "close",
              "query"
            ],
            "line": 158
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "base64",
            "names": [
              "base64"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "gzip",
            "names": [
              "gzip"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "pathlib",
            "names": [
              "Path"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.costsim.config",
            "names": [
              "get_commit_sha",
              "get_config"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "s1_retry_backoff.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/s1_retry_backoff.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 148,
        "module_docstring": null,
        "functions": [
          {
            "name": "create_s1_envelope",
            "signature": "(baseline_value: float = 100.0, reference_id: str = 'retry_policy_v3') -> Envelope",
            "docstring": "Create a fresh S1 envelope instance with specified baseline.\n\nArgs:\n    baseline_value: The baseline initial_backoff_ms value\n    reference_id: Version/hash of the baseline config\n\nReturns:\n    New Envelope instance ready for validation",
            "is_async": false,
            "line": 99
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "app.optimization.envelope",
            "names": [
              "BaselineSource",
              "DeltaType",
              "Envelope",
              "EnvelopeBaseline",
              "EnvelopeBounds",
              "EnvelopeClass",
              "EnvelopeScope",
              "EnvelopeTimebox",
              "EnvelopeTrigger",
              "RevertReason"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [
          {
            "name": "S1_RETRY_BACKOFF_ENVELOPE",
            "line": 52
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "sandbox.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_engines/sandbox.py",
        "layer": "L5_engines",
        "domain": "analytics",
        "lines": 307,
        "module_docstring": "Sandbox routing layer for CostSim V1 vs V2.\n\nFeature flag controlled routing:\n- COSTSIM_V2_SANDBOX=false (default): Only V1, no V2\n- COSTSIM_V2_SANDBOX=true: Run both V1 and V2, log comparison\n\nThe sandbox NEVER changes production behavior. V1 is always\nthe source of truth. V2 runs in shadow mode for validation.",
        "functions": [
          {
            "name": "simulate_with_sandbox",
            "signature": "(plan: List[Dict[str, Any]], budget_cents: int = 1000, allowed_skills: Optional[List[str]] = None, tenant_id: Optional[str] = None, run_id: Optional[str] = None) -> SandboxResult",
            "docstring": "Convenience function for sandbox simulation.\n\nArgs:\n    plan: List of steps\n    budget_cents: Available budget\n    allowed_skills: Optional skill allowlist\n    tenant_id: Tenant identifier\n    run_id: Run identifier\n\nReturns:\n    SandboxResult",
            "is_async": true,
            "line": 244
          },
          {
            "name": "get_sandbox",
            "signature": "(budget_cents: int = 1000, tenant_id: Optional[str] = None) -> CostSimSandbox",
            "docstring": "Get a sandbox instance.\n\nNote: For tenant isolation, always create a new instance\nwith the correct tenant_id rather than using the global.\n\nArgs:\n    budget_cents: Available budget\n    tenant_id: Tenant identifier\n\nReturns:\n    CostSimSandbox instance",
            "is_async": false,
            "line": 277
          }
        ],
        "classes": [
          {
            "name": "SandboxResult",
            "docstring": "Result from sandbox routing.",
            "methods": [
              "production_result"
            ],
            "line": 54
          },
          {
            "name": "CostSimSandbox",
            "docstring": "Sandbox router for CostSim V1 vs V2.\n\nUsage:\n    sandbox = CostSimSandbox(budget_cents=1000)\n    result = await sandbox.simulate(plan)\n\n    # Production code uses v1_result\n    if result.v1_result.feasible:\n        execute_plan(plan)\n\n    # V2 comparison logged for validation\n    if result.comparison:\n        logger.info(f\"V2 drift: {result.comparison.drift_score}\")",
            "methods": [
              "__init__",
              "_get_v2_adapter",
              "simulate",
              "_log_comparison"
            ],
            "line": 76
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "app.costsim.circuit_breaker_async",
            "names": [
              "is_v2_disabled",
              "report_drift"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.costsim.config",
            "names": [
              "is_v2_sandbox_enabled"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.costsim.models",
            "names": [
              "ComparisonResult",
              "ComparisonVerdict",
              "V2SimulationResult"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.costsim.v2_adapter",
            "names": [
              "CostSimV2Adapter"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.worker.simulate",
            "names": [
              "CostSimulator",
              "SimulationResult"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [
      {
        "file_name": "cost_snapshot_schemas.py",
        "file_path": "backend/app/hoc/cus/analytics/L5_schemas/cost_snapshot_schemas.py",
        "layer": "L5_schemas",
        "domain": "analytics",
        "lines": 243,
        "module_docstring": "M27 Cost Snapshot Schemas\n\nDataclasses and enums for the cost snapshot system.",
        "functions": [],
        "classes": [
          {
            "name": "SnapshotType",
            "docstring": null,
            "methods": [],
            "line": 32
          },
          {
            "name": "SnapshotStatus",
            "docstring": null,
            "methods": [],
            "line": 37
          },
          {
            "name": "EntityType",
            "docstring": null,
            "methods": [],
            "line": 44
          },
          {
            "name": "CostSnapshot",
            "docstring": "Point-in-time cost snapshot definition.",
            "methods": [
              "create",
              "to_dict"
            ],
            "line": 66
          },
          {
            "name": "SnapshotAggregate",
            "docstring": "Aggregated cost data for an entity within a snapshot.",
            "methods": [
              "create"
            ],
            "line": 119
          },
          {
            "name": "SnapshotBaseline",
            "docstring": "Rolling baseline for an entity (used for anomaly threshold).",
            "methods": [
              "create"
            ],
            "line": 170
          },
          {
            "name": "AnomalyEvaluation",
            "docstring": "Audit record for an anomaly evaluation.",
            "methods": [],
            "line": 227
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [
          {
            "name": "SEVERITY_THRESHOLDS",
            "line": 52
          }
        ],
        "all_exports": null
      }
    ],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "analytics_read_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/analytics_read_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 376,
        "module_docstring": "Analytics Read Driver (L6 Data Access)\n\nHandles database operations for analytics queries:\n- Fetching cost metrics from cost_records\n- Fetching LLM usage from runs\n- Fetching worker execution from aos_traces\n- Fetching cost breakdowns by model and feature\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_analytics_read_driver",
            "signature": "(session: AsyncSession) -> AnalyticsReadDriver",
            "docstring": "Get an AnalyticsReadDriver instance.",
            "is_async": false,
            "line": 374
          }
        ],
        "classes": [
          {
            "name": "AnalyticsReadDriver",
            "docstring": "L6 Driver for analytics read operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (time alignment, reconciliation) stay in L5.",
            "methods": [
              "__init__",
              "fetch_cost_metrics",
              "fetch_llm_usage",
              "fetch_worker_execution",
              "fetch_cost_spend",
              "fetch_cost_by_model",
              "fetch_cost_by_feature"
            ],
            "line": 49
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "audit_persistence.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/audit_persistence.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 169,
        "module_docstring": null,
        "functions": [
          {
            "name": "_now_utc",
            "signature": "() -> datetime",
            "docstring": "Get current UTC timestamp.",
            "is_async": false,
            "line": 52
          },
          {
            "name": "persist_audit_record",
            "signature": "(db: Session, audit_id: str, envelope_id: str, envelope_class: str, decision: str, reason: str, decision_timestamp: datetime, conflicting_envelope_id: Optional[str] = None, preempting_envelope_id: Optional[str] = None, active_envelopes_count: int = 0, tenant_id: Optional[str] = None, emit_traces: bool = True) -> bool",
            "docstring": "Persist a coordination audit record to the database.\n\nThis function is the ONLY legal path to write audit records.\n\nArgs:\n    db: Database session\n    audit_id: UUID of the audit record\n    envelope_id: ID of the envelope being coordinated\n    envelope_class: SAFETY, RELIABILITY, COST, or PERFORMANCE\n    decision: APPLIED, REJECTED, or PREEMPTED\n    reason: Human-readable reason for decision\n    decision_timestamp: When the decision was made\n    conflicting_envelope_id: For REJECTED, the conflicting envelope\n    preempting_envelope_id: For PREEMPTED, the preempting envelope\n    active_envelopes_count: Count of active envelopes at decision time\n    tenant_id: Optional tenant identifier\n    emit_traces: If False, skip persistence (replay mode)\n\nReturns:\n    True if persisted successfully, False otherwise",
            "is_async": false,
            "line": 80
          }
        ],
        "classes": [
          {
            "name": "CoordinationAuditRecordDB",
            "docstring": "SQLModel for coordination_audit_records table.\n\nThis is a read-only reflection of the table created by migration\n063_c4_coordination_audit.py. The model is for persistence only.",
            "methods": [],
            "line": 57
          }
        ],
        "imports": [
          {
            "module": "app.infra",
            "names": [
              "FeatureIntent",
              "RetryPolicy"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlmodel",
            "names": [
              "Field",
              "Session",
              "SQLModel"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [
          {
            "name": "FEATURE_INTENT",
            "line": 27
          },
          {
            "name": "RETRY_POLICY",
            "line": 28
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "cost_anomaly_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/cost_anomaly_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 992,
        "module_docstring": "Cost Anomaly Driver (L6)\n\nPure database operations for cost anomaly detection.\nAll business logic stays in L4 engine.\n\nOperations:\n- Read baseline/today aggregations for spike detection\n- Read rolling/baseline averages for drift detection\n- Read/write breach history for consecutive tracking\n- Read/write drift tracking state\n- Read cost metrics for cause derivation\n- Persist CostAnomaly records\n\nNO business logic:\n- NO threshold comparisons (L4)\n- NO severity classification (L4)\n- NO anomaly type decisions (L4)\n\nReference: Phase-2.5A Analytics Extraction",
        "functions": [
          {
            "name": "get_cost_anomaly_driver",
            "signature": "(session: Session) -> CostAnomalyDriver",
            "docstring": "Factory function to get CostAnomalyDriver instance.",
            "is_async": false,
            "line": 984
          }
        ],
        "classes": [
          {
            "name": "CostAnomalyDriver",
            "docstring": "L6 driver for cost anomaly detection data access.\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "fetch_entity_baseline",
              "fetch_entity_today_spend",
              "fetch_tenant_baseline",
              "fetch_tenant_today_spend",
              "fetch_rolling_avg",
              "fetch_baseline_avg",
              "fetch_daily_spend",
              "fetch_monthly_spend",
              "fetch_breach_exists_today",
              "insert_breach_history",
              "fetch_consecutive_breaches",
              "fetch_drift_tracking",
              "update_drift_tracking",
              "insert_drift_tracking",
              "reset_drift_tracking",
              "fetch_retry_comparison",
              "fetch_prompt_comparison",
              "fetch_feature_concentration",
              "fetch_request_comparison"
            ],
            "line": 95
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime"
            ],
            "is_relative": false,
            "line": 88
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 89
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 91
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 92
          }
        ],
        "constants": [],
        "all_exports": [
          "CostAnomalyDriver",
          "get_cost_anomaly_driver"
        ]
      },
      {
        "file_name": "cost_write_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/cost_write_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 251,
        "module_docstring": "Cost Write Driver (L6)\n\nPure database write operations for Cost Intelligence.\n\nL4 (CostWriteService) \u2192 L6 (this driver)\n\nResponsibilities:\n- Persist FeatureTag records\n- Persist CostRecord records\n- Persist CostBudget records\n- NO business logic (L4 responsibility)\n\nReference: PIN-250, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_cost_write_driver",
            "signature": "(session: Session) -> CostWriteDriver",
            "docstring": "Factory function to get CostWriteDriver instance.",
            "is_async": false,
            "line": 243
          }
        ],
        "classes": [
          {
            "name": "CostWriteDriver",
            "docstring": "L6 driver for cost write operations.\n\nPure database access - no business logic.",
            "methods": [
              "__init__",
              "create_feature_tag",
              "update_feature_tag",
              "create_cost_record",
              "create_or_update_budget"
            ],
            "line": 53
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.db",
            "names": [
              "CostBudget",
              "CostRecord",
              "FeatureTag"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": [
          "CostWriteDriver",
          "get_cost_write_driver"
        ]
      },
      {
        "file_name": "leader.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/leader.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 359,
        "module_docstring": "Leader election using PostgreSQL advisory locks.\n\nThis module provides a simple leader election mechanism for scenarios where\nonly one instance should run a task (e.g., daily canary runs). Uses\npg_try_advisory_lock() which is session-scoped and automatically released\nwhen the connection closes.\n\nUsage:\n    from app.costsim.leader import try_acquire_leader_lock, LeaderContext\n\n    # Simple check\n    async with AsyncSessionLocal() as session:\n        if await try_acquire_leader_lock(session, LOCK_CANARY_RUNNER):\n            # We are the leader - run the task\n            await run_canary()\n            # Lock is released when session closes\n\n    # Or with context manager for cleaner code\n    async with LeaderContext(LOCK_CANARY_RUNNER) as is_leader:\n        if is_leader:\n            await run_canary()\n\nLock IDs:\n    - LOCK_CANARY_RUNNER (7001): Daily canary execution\n    - LOCK_ALERT_WORKER (7002): Alert queue processor\n    - LOCK_PROVENANCE_ARCHIVER (7003): Provenance data archival\n\nNote:\n    Advisory locks are session-scoped. They are automatically released when:\n    - The session/connection is closed\n    - The transaction is rolled back (for xact-level locks)\n    - Explicitly released with pg_advisory_unlock()\n\n    For long-running processes, ensure the connection stays alive or\n    use heartbeat mechanisms.",
        "functions": [
          {
            "name": "try_acquire_leader_lock",
            "signature": "(session: AsyncSession, lock_id: int) -> bool",
            "docstring": "Try to acquire an advisory lock (non-blocking).\n\nUses pg_try_advisory_lock() which returns immediately with true/false.\nLock is held until the session is closed.\n\nArgs:\n    session: Async database session\n    lock_id: Unique lock identifier (use constants above)\n\nReturns:\n    True if lock acquired (we are the leader), False otherwise",
            "is_async": true,
            "line": 80
          },
          {
            "name": "release_leader_lock",
            "signature": "(session: AsyncSession, lock_id: int) -> bool",
            "docstring": "Explicitly release an advisory lock.\n\nUsually not needed since locks are released when session closes,\nbut useful for releasing early in long-running sessions.\n\nArgs:\n    session: Async database session\n    lock_id: Lock identifier to release\n\nReturns:\n    True if lock was released, False if we didn't hold it",
            "is_async": true,
            "line": 112
          },
          {
            "name": "is_lock_held",
            "signature": "(session: AsyncSession, lock_id: int) -> bool",
            "docstring": "Check if a lock is currently held by any session.\n\nNote: This is informational only. The lock state could change\nimmediately after this check returns.\n\nArgs:\n    session: Async database session\n    lock_id: Lock identifier to check\n\nReturns:\n    True if lock is held by any session",
            "is_async": true,
            "line": 144
          },
          {
            "name": "leader_election",
            "signature": "(lock_id: int, timeout_seconds: float = 5.0) -> AsyncGenerator[bool, None]",
            "docstring": "Context manager for leader election.\n\nAlternative to LeaderContext class, using a function-based approach.\n\nUsage:\n    async with leader_election(LOCK_CANARY_RUNNER) as is_leader:\n        if is_leader:\n            await run_canary()\n\nArgs:\n    lock_id: Advisory lock ID\n    timeout_seconds: Timeout for lock acquisition\n\nYields:\n    True if we are the leader, False otherwise",
            "is_async": true,
            "line": 261
          },
          {
            "name": "with_leader_lock",
            "signature": "(lock_id: int, callback, *args, **kwargs)",
            "docstring": "Execute callback only if we can acquire leadership.\n\nConvenience function for fire-and-forget leader tasks.\n\nArgs:\n    lock_id: Advisory lock ID\n    callback: Async function to execute if we become leader\n    *args: Arguments for callback\n    timeout_seconds: Lock acquisition timeout\n    **kwargs: Keyword arguments for callback\n\nReturns:\n    Result of callback if we were leader, None otherwise\n\nExample:\n    # Run canary only if we're the leader\n    result = await with_leader_lock(\n        LOCK_CANARY_RUNNER,\n        run_canary,\n        samples=100,\n    )",
            "is_async": true,
            "line": 310
          },
          {
            "name": "with_canary_lock",
            "signature": "(callback, *args, **kwargs)",
            "docstring": "Execute callback with canary runner lock.",
            "is_async": true,
            "line": 347
          },
          {
            "name": "with_alert_worker_lock",
            "signature": "(callback, *args, **kwargs)",
            "docstring": "Execute callback with alert worker lock.",
            "is_async": true,
            "line": 352
          },
          {
            "name": "with_archiver_lock",
            "signature": "(callback, *args, **kwargs)",
            "docstring": "Execute callback with provenance archiver lock.",
            "is_async": true,
            "line": 357
          }
        ],
        "classes": [
          {
            "name": "LeaderContext",
            "docstring": "Async context manager for leader election.\n\nAcquires a leader lock on entry, releases on exit. The context\nvariable indicates whether we successfully became the leader.\n\nUsage:\n    async with LeaderContext(LOCK_CANARY_RUNNER) as is_leader:\n        if is_leader:\n            # We won the election\n            await run_canary()\n        else:\n            # Another instance is the leader\n            logger.info(\"Not the leader, skipping\")\n\nThe lock is held for the duration of the context and automatically\nreleased when the context exits (via session close).",
            "methods": [
              "__init__",
              "__aenter__",
              "__aexit__",
              "is_leader"
            ],
            "line": 177
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "contextlib",
            "names": [
              "asynccontextmanager"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "typing",
            "names": [
              "AsyncGenerator",
              "Optional"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "app.db_async",
            "names": [
              "AsyncSessionLocal"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [
          {
            "name": "LOCK_CANARY_RUNNER",
            "line": 74
          },
          {
            "name": "LOCK_ALERT_WORKER",
            "line": 75
          },
          {
            "name": "LOCK_PROVENANCE_ARCHIVER",
            "line": 76
          },
          {
            "name": "LOCK_BASELINE_BACKFILL",
            "line": 77
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "pattern_detection_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/pattern_detection_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 209,
        "module_docstring": "Pattern Detection Driver (L6 Data Access)\n\nHandles all database operations for pattern detection:\n- Fetching failed runs for pattern analysis\n- Fetching completed runs for cost spike detection\n- Inserting pattern feedback records\n- Querying feedback summaries\n\nReference: PIN-470, Phase-3B SQLAlchemy Extraction",
        "functions": [
          {
            "name": "get_pattern_detection_driver",
            "signature": "(session: AsyncSession) -> PatternDetectionDriver",
            "docstring": "Get a PatternDetectionDriver instance.",
            "is_async": false,
            "line": 207
          }
        ],
        "classes": [
          {
            "name": "PatternDetectionDriver",
            "docstring": "L6 Driver for pattern detection data operations.\n\nAll methods are pure DB operations - no business logic.\nBusiness decisions (threshold checks, pattern grouping) stay in L5.",
            "methods": [
              "__init__",
              "fetch_failed_runs",
              "fetch_completed_runs_with_costs",
              "insert_feedback",
              "fetch_feedback_records"
            ],
            "line": 53
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.models.feedback",
            "names": [
              "PatternFeedback"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "prediction_driver.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/prediction_driver.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 319,
        "module_docstring": "Prediction Driver (L6)\n\nPure database operations for prediction management.\nAll business logic stays in L4 engine.\n\nOperations:\n- Read failure patterns from feedback\n- Read failed runs and totals\n- Read cost data for projections\n- Read prediction events\n- Insert new prediction events\n\nNO business logic:\n- NO prediction math (L4)\n- NO confidence calculations (L4)\n- NO threshold comparisons (L4)\n\nReference: Phase-2.5A Analytics Extraction",
        "functions": [
          {
            "name": "get_prediction_driver",
            "signature": "(session: AsyncSession) -> PredictionDriver",
            "docstring": "Factory function to get PredictionDriver instance.",
            "is_async": false,
            "line": 311
          }
        ],
        "classes": [
          {
            "name": "PredictionDriver",
            "docstring": "L6 driver for prediction data access.\n\nPure database access - no business logic.\nTransaction management is delegated to caller (L4 engine).",
            "methods": [
              "__init__",
              "fetch_failure_patterns",
              "fetch_failed_runs",
              "fetch_run_totals",
              "fetch_cost_runs",
              "fetch_predictions",
              "insert_prediction"
            ],
            "line": 75
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "app.models.feedback",
            "names": [
              "PatternFeedback"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "app.models.prediction",
            "names": [
              "PredictionEvent"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 72
          }
        ],
        "constants": [],
        "all_exports": [
          "PredictionDriver",
          "get_prediction_driver"
        ]
      },
      {
        "file_name": "provenance_async.py",
        "file_path": "backend/app/hoc/cus/analytics/L6_drivers/provenance_async.py",
        "layer": "L6_drivers",
        "domain": "analytics",
        "lines": 463,
        "module_docstring": "Async provenance logging for CostSim V2.\n\nThis module provides non-blocking database access for writing provenance\nrecords. Use this instead of the sync provenance.py for all async code paths.\n\nFeatures:\n- Non-blocking DB operations (won't hang event loop)\n- Batch writing support for high-throughput scenarios\n- Deduplication via input_hash\n- V1 baseline backfill support\n\nUsage:\n    from app.costsim.provenance_async import (\n        write_provenance,\n        write_provenance_batch,\n        query_provenance,\n    )\n\n    # Write single record\n    await write_provenance(\n        run_id=\"run_123\",\n        tenant_id=\"tenant_abc\",\n        variant_slug=\"v2\",\n        v1_cost=100.0,\n        v2_cost=105.0,\n        input_hash=\"abc123\",\n    )\n\n    # Batch write\n    records = [...]\n    await write_provenance_batch(records)\n\n    # Query records\n    records = await query_provenance(\n        tenant_id=\"tenant_abc\",\n        variant_slug=\"v2\",\n        start_date=start,\n        end_date=end,\n    )",
        "functions": [
          {
            "name": "write_provenance",
            "signature": "(run_id: Optional[str] = None, tenant_id: Optional[str] = None, variant_slug: str = 'v2', source: str = 'sandbox', model_version: Optional[str] = None, adapter_version: Optional[str] = None, commit_sha: Optional[str] = None, input_hash: Optional[str] = None, output_hash: Optional[str] = None, v1_cost: Optional[float] = None, v2_cost: Optional[float] = None, payload: Optional[Dict[str, Any]] = None, runtime_ms: Optional[int] = None, session: Optional[AsyncSession] = None) -> int",
            "docstring": "Write a single provenance record.\n\nArgs:\n    run_id: Run identifier\n    tenant_id: Tenant identifier\n    variant_slug: v1, v2, or canary\n    source: sandbox, canary, manual, backfill\n    model_version: Cost model version\n    adapter_version: Adapter version\n    commit_sha: Git commit SHA\n    input_hash: Hash of input for deduplication\n    output_hash: Hash of output\n    v1_cost: V1 simulation cost\n    v2_cost: V2 simulation cost\n    payload: Full simulation payload\n    runtime_ms: Execution time in milliseconds\n    session: Optional async session (creates new if None)\n\nReturns:\n    ID of created record",
            "is_async": true,
            "line": 79
          },
          {
            "name": "write_provenance_batch",
            "signature": "(records: List[Dict[str, Any]], session: Optional[AsyncSession] = None) -> List[int]",
            "docstring": "Write multiple provenance records in a single transaction.\n\nMore efficient than individual writes for high-throughput scenarios.\n\nArgs:\n    records: List of record dictionaries (same keys as write_provenance)\n    session: Optional async session\n\nReturns:\n    List of created record IDs",
            "is_async": true,
            "line": 163
          },
          {
            "name": "query_provenance",
            "signature": "(tenant_id: Optional[str] = None, variant_slug: Optional[str] = None, source: Optional[str] = None, input_hash: Optional[str] = None, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None, limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]",
            "docstring": "Query provenance records.\n\nArgs:\n    tenant_id: Filter by tenant\n    variant_slug: Filter by variant (v1, v2, canary)\n    source: Filter by source (sandbox, canary, manual, backfill)\n    input_hash: Filter by input hash (for deduplication check)\n    start_date: Start of time range\n    end_date: End of time range\n    limit: Maximum records to return\n    offset: Pagination offset\n\nReturns:\n    List of provenance records as dictionaries",
            "is_async": true,
            "line": 234
          },
          {
            "name": "count_provenance",
            "signature": "(tenant_id: Optional[str] = None, variant_slug: Optional[str] = None, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None) -> int",
            "docstring": "Count provenance records matching filters.\n\nArgs:\n    tenant_id: Filter by tenant\n    variant_slug: Filter by variant\n    start_date: Start of time range\n    end_date: End of time range\n\nReturns:\n    Count of matching records",
            "is_async": true,
            "line": 288
          },
          {
            "name": "get_drift_stats",
            "signature": "(start_date: Optional[datetime] = None, end_date: Optional[datetime] = None) -> Dict[str, Any]",
            "docstring": "Get drift statistics between V1 and V2 costs.\n\nArgs:\n    start_date: Start of time range\n    end_date: End of time range\n\nReturns:\n    Dictionary with drift statistics",
            "is_async": true,
            "line": 327
          },
          {
            "name": "check_duplicate",
            "signature": "(input_hash: str) -> bool",
            "docstring": "Check if a record with this input hash already exists.\n\nArgs:\n    input_hash: Hash to check\n\nReturns:\n    True if duplicate exists",
            "is_async": true,
            "line": 381
          },
          {
            "name": "compute_input_hash",
            "signature": "(payload: Dict[str, Any]) -> str",
            "docstring": "Compute deterministic hash of input payload.\n\nArgs:\n    payload: Input dictionary\n\nReturns:\n    SHA-256 hash string (first 16 chars)",
            "is_async": false,
            "line": 398
          },
          {
            "name": "backfill_v1_baseline",
            "signature": "(records: List[Dict[str, Any]], batch_size: int = 100) -> Dict[str, int]",
            "docstring": "Backfill V1 baseline records from historical data.\n\nArgs:\n    records: List of historical V1 simulation records\n    batch_size: Number of records per batch\n\nReturns:\n    Dictionary with counts (inserted, skipped, errors)",
            "is_async": true,
            "line": 418
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "app.db_async",
            "names": [
              "AsyncSessionLocal",
              "async_session_context"
            ],
            "is_relative": false,
            "line": 73
          },
          {
            "module": "app.models.costsim_cb",
            "names": [
              "CostSimProvenanceModel"
            ],
            "is_relative": false,
            "line": 74
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l7_models": [],
    "total_files": 35,
    "violation_count": 7,
    "gap_count": 7
  },
  "integrations": {
    "l2_1_facade": null,
    "l2_apis": [
      {
        "file_name": "cus_telemetry.py",
        "file_path": "backend/app/hoc/api/cus/integrations/cus_telemetry.py",
        "layer": "L2_api",
        "domain": "integrations",
        "lines": 337,
        "module_docstring": "Customer LLM Telemetry Ingestion API\n\nPURPOSE:\n    Receives telemetry data from customer SDKs reporting LLM usage.\n    This is the DATA PLANE ingestion surface - it records facts about\n    what happened during LLM calls.\n\nENDPOINTS:\n    POST /telemetry/llm-usage     - Single call telemetry\n    POST /telemetry/llm-usage/batch - Batch telemetry (up to 100 records)\n    GET  /telemetry/usage-summary  - Usage summary for dashboard\n\nSEMANTIC:\n    - Append-only: Telemetry records are never updated or deleted\n    - Idempotent: call_id prevents duplicate ingestion\n    - Tenant-isolated: All data scoped to authenticated tenant\n\nAUTHENTICATION:\n    Uses integration API key (X-CUS-Integration-Key header) to identify\n    both the tenant and the specific integration being reported.",
        "functions": [
          {
            "name": "get_telemetry_service",
            "signature": "() -> CusTelemetryService",
            "docstring": "Dependency to get telemetry service instance.",
            "is_async": false,
            "line": 57
          },
          {
            "name": "get_integration_context",
            "signature": "(request: Request, x_cus_integration_key: Optional[str] = Header(None, alias='X-CUS-Integration-Key')) -> dict",
            "docstring": "Extract and validate integration context from request.\n\nThe integration key encodes both tenant_id and integration_id,\nallowing SDK to authenticate and route telemetry.\n\nReturns:\n    dict with tenant_id and integration_id",
            "is_async": true,
            "line": 62
          },
          {
            "name": "ingest_llm_usage",
            "signature": "(payload: CusLLMUsageIngest, ctx: dict = Depends(get_integration_context), service: CusTelemetryService = Depends(get_telemetry_service))",
            "docstring": "Ingest a single LLM usage telemetry record.\n\nPURPOSE:\n    SDK calls this endpoint after each LLM call to report:\n    - Token counts (input/output)\n    - Cost calculation\n    - Latency measurement\n    - Policy enforcement result\n\nIDEMPOTENCY:\n    The call_id field serves as an idempotency key. If a record\n    with the same call_id already exists, this is a no-op.\n\nArgs:\n    payload: Telemetry data from SDK\n\nReturns:\n    Envelope with ingestion result",
            "is_async": true,
            "line": 109
          },
          {
            "name": "ingest_llm_usage_batch",
            "signature": "(payload: CusLLMUsageBatchIngest, ctx: dict = Depends(get_integration_context), service: CusTelemetryService = Depends(get_telemetry_service))",
            "docstring": "Ingest a batch of LLM usage telemetry records.\n\nPURPOSE:\n    SDK may buffer telemetry and send in batches for efficiency.\n    Maximum 100 records per batch.\n\nIDEMPOTENCY:\n    Each record's call_id is checked. Duplicates are silently ignored.\n\nArgs:\n    payload: Batch of telemetry records\n\nReturns:\n    Envelope with batch ingestion result (accepted/duplicates counts)",
            "is_async": true,
            "line": 161
          },
          {
            "name": "get_usage_summary",
            "signature": "(request: Request, integration_id: Optional[str] = Query(None, description='Filter by integration'), start_date: Optional[date] = Query(None, description='Period start (default: 30 days ago)'), end_date: Optional[date] = Query(None, description='Period end (default: today)'), ctx: dict = Depends(get_integration_context), service: CusTelemetryService = Depends(get_telemetry_service))",
            "docstring": "Get aggregated usage summary for dashboard.\n\nPURPOSE:\n    Provides rolled-up usage statistics for a tenant's integrations.\n    Used by dashboard to show cost, token, and call totals.\n\nArgs:\n    integration_id: Optional filter for specific integration\n    start_date: Period start (default: 30 days ago)\n    end_date: Period end (default: today)\n\nReturns:\n    CusUsageSummary with aggregated metrics",
            "is_async": true,
            "line": 204
          },
          {
            "name": "get_usage_history",
            "signature": "(request: Request, integration_id: Optional[str] = Query(None, description='Filter by integration'), limit: int = Query(50, ge=1, le=1000, description='Max records to return'), offset: int = Query(0, ge=0, description='Offset for pagination'), ctx: dict = Depends(get_integration_context), service: CusTelemetryService = Depends(get_telemetry_service))",
            "docstring": "Get detailed usage history records.\n\nPURPOSE:\n    Detailed view of individual LLM calls for audit and debugging.\n    Paginated for large datasets.\n\nArgs:\n    integration_id: Optional filter for specific integration\n    limit: Max records per page (default 50, max 1000)\n    offset: Pagination offset\n\nReturns:\n    List of CusLLMUsageResponse records",
            "is_async": true,
            "line": 250
          },
          {
            "name": "get_daily_aggregates",
            "signature": "(request: Request, integration_id: Optional[str] = Query(None, description='Filter by integration'), start_date: Optional[date] = Query(None, description='Period start'), end_date: Optional[date] = Query(None, description='Period end'), ctx: dict = Depends(get_integration_context), service: CusTelemetryService = Depends(get_telemetry_service))",
            "docstring": "Get daily aggregated usage for charts.\n\nPURPOSE:\n    Pre-computed daily aggregates for time-series visualization.\n    More efficient than computing from raw usage records.\n\nArgs:\n    integration_id: Optional filter for specific integration\n    start_date: Period start (default: 30 days ago)\n    end_date: Period end (default: today)\n\nReturns:\n    List of daily aggregate records",
            "is_async": true,
            "line": 295
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "date",
              "timedelta"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "Header",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "app.schemas.cus_schemas",
            "names": [
              "CusLLMUsageBatchIngest",
              "CusLLMUsageIngest",
              "CusLLMUsageResponse",
              "CusUsageSummary"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict",
              "wrap_error",
              "wrap_list"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.cus_telemetry_service",
            "names": [
              "CusTelemetryService"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "protection_dependencies.py",
        "file_path": "backend/app/hoc/api/cus/integrations/protection_dependencies.py",
        "layer": "L2_api",
        "domain": "integrations",
        "lines": 242,
        "module_docstring": "Phase-7 Protection Dependencies \u2014 FastAPI Integration\n\nProvides dependencies for protection checks in API endpoints.\n\nENFORCEMENT SURFACE:\n    Protection applies to:\n    - SDK endpoints\n    - Runtime execution paths\n    - Background workers\n\n    Protection does NOT apply to:\n    - Onboarding endpoints\n    - Auth endpoints\n    - Founder endpoints\n    - Internal ops endpoints\n\nDESIGN INVARIANTS:\n- ABUSE-001: Protection does not affect onboarding, roles, or billing state\n- ABUSE-002: All enforcement outcomes are explicit (no silent failure)\n- ABUSE-003: Anomaly detection never blocks user traffic",
        "functions": [
          {
            "name": "is_exempt_endpoint",
            "signature": "(path: str) -> bool",
            "docstring": "Check if an endpoint is exempt from protection.",
            "is_async": false,
            "line": 88
          },
          {
            "name": "check_protection",
            "signature": "(request: Request) -> ProtectionContext",
            "docstring": "FastAPI dependency: Run protection checks for current request.\n\nReturns ProtectionContext with decision and any anomaly signals.\nDoes NOT raise exceptions - caller decides how to handle.\n\nUsage:\n    @router.post(\"/runs\")\n    async def create_run(\n        protection: ProtectionContext = Depends(check_protection),\n    ):\n        if protection.result.decision == Decision.REJECT:\n            raise HTTPException(status_code=429, detail=protection.result.to_error_response())\n        ...",
            "is_async": false,
            "line": 93
          },
          {
            "name": "require_protection_allow",
            "signature": "(request: Request) -> ProtectionContext",
            "docstring": "FastAPI dependency: Require protection checks to pass.\n\nRaises HTTP 429 if protection rejects the request.\nRaises HTTP 503 if protection throttles (with Retry-After header).\n\nUsage:\n    @router.post(\"/runs\")\n    async def create_run(\n        protection: ProtectionContext = Depends(require_protection_allow),\n    ):\n        # Protection checks passed\n        ...",
            "is_async": false,
            "line": 175
          },
          {
            "name": "emit_protection_event",
            "signature": "(context: ProtectionContext) -> dict",
            "docstring": "Emit a structured protection event for observability.\n\nPer Phase-7 design Section 7.9, all rejections emit structured events.\n\nReturns:\n    Event dict suitable for logging/dashboards",
            "is_async": false,
            "line": 211
          }
        ],
        "classes": [
          {
            "name": "ProtectionContext",
            "docstring": "Protection context for a request.\n\nAttributes:\n    tenant_id: The tenant identifier\n    endpoint: The endpoint being accessed\n    operation: The operation being performed\n    result: Result of protection checks\n    anomaly: Anomaly signal if detected (non-blocking)\n    is_exempt: True if endpoint is exempt from protection",
            "methods": [],
            "line": 67
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "fastapi",
            "names": [
              "Request",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.protection.decisions",
            "names": [
              "Decision",
              "ProtectionResult",
              "AnomalySignal",
              "allow"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.protection.provider",
            "names": [
              "get_protection_provider"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.auth.onboarding_state",
            "names": [
              "OnboardingState"
            ],
            "is_relative": false,
            "line": 49
          }
        ],
        "constants": [
          {
            "name": "EXEMPT_PREFIXES",
            "line": 55
          }
        ],
        "all_exports": [
          "ProtectionContext",
          "check_protection",
          "require_protection_allow",
          "emit_protection_event",
          "is_exempt_endpoint",
          "EXEMPT_PREFIXES"
        ]
      },
      {
        "file_name": "session_context.py",
        "file_path": "backend/app/hoc/api/cus/integrations/session_context.py",
        "layer": "L2_api",
        "domain": "integrations",
        "lines": 156,
        "module_docstring": "Session Context API\n\nPIN-409: Provides verified session context to frontend.\n\nThis endpoint replaces frontend-derived authorization facts (isFounder, audience)\nwith backend-verified context. The frontend reads, never infers.\n\nEndpoint:\n    GET /api/v1/session/context - Get current session context\n\nResponse:\n    {\n        \"actor_type\": \"customer\" | \"founder\" | \"machine\",\n        \"tenant_id\": \"...\",\n        \"capabilities\": [...],  // for machine clients only\n        \"lifecycle_state\": \"ACTIVE\" | \"SUSPENDED\" | \"TERMINATED\" | \"ARCHIVED\",\n        \"onboarding_state\": \"CREATED\" | \"IDENTITY_VERIFIED\" | ... | \"COMPLETE\"\n    }\n\nRULE-AUTH-UI-001: Frontend never decides 'who I am' beyond signed-in vs not.\nThis endpoint is the single source of truth for authorization facts.",
        "functions": [
          {
            "name": "get_session_context",
            "signature": "(request: Request) -> Dict[str, Any]",
            "docstring": "Get verified session context for the current authenticated user.\n\nThis endpoint returns authorization facts derived from the verified\nbackend context. The frontend should use these values instead of\nderiving them locally.\n\nReturns:\n    actor_type: \"customer\" | \"founder\" | \"machine\"\n    tenant_id: Tenant ID if applicable (null for founders)\n    capabilities: List of scopes for machine clients (empty for humans)\n    lifecycle_state: Current tenant lifecycle state (for tenant-scoped actors)\n    onboarding_state: Current onboarding state (for tenant-scoped actors)\n\nRaises:\n    401: Not authenticated",
            "is_async": true,
            "line": 54
          },
          {
            "name": "_get_onboarding_state",
            "signature": "(tenant_id: str) -> str",
            "docstring": "Get onboarding state for a tenant.\n\nThis is a simplified implementation. In production, this would query\nthe tenant model from the database.\n\nFor now, we assume COMPLETE if the tenant exists and has authenticated.\n\nArgs:\n    tenant_id: The tenant ID to look up",
            "is_async": false,
            "line": 137
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Request",
              "HTTPException"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.auth.contexts",
            "names": [
              "FounderAuthContext",
              "HumanAuthContext",
              "MachineCapabilityContext"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.auth.gateway_middleware",
            "names": [
              "get_auth_context"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.auth.lifecycle_provider",
            "names": [
              "get_lifecycle_provider"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "app.auth.onboarding_state",
            "names": [
              "OnboardingState"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l3_adapters": [
      {
        "file_name": "cloud_functions_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/cloud_functions_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 313,
        "module_docstring": "Google Cloud Functions Serverless Adapter (GAP-150)\n\nProvides integration with Google Cloud Functions:\n- HTTP and event-triggered functions\n- Async invocation via Pub/Sub\n- Response parsing\n- Function management",
        "functions": [],
        "classes": [
          {
            "name": "CloudFunctionsAdapter",
            "docstring": "Google Cloud Functions serverless adapter.\n\nUses google-cloud-functions and httpx for async operations.",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "invoke",
              "invoke_batch",
              "get_function_info",
              "list_functions",
              "function_exists"
            ],
            "line": 39
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "base",
            "names": [
              "FunctionInfo",
              "InvocationRequest",
              "InvocationResult",
              "InvocationType",
              "ServerlessAdapter"
            ],
            "is_relative": true,
            "line": 28
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "customer_activity_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/customer_activity_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 332,
        "module_docstring": "Customer Activity Boundary Adapter (L3)\n\nThis adapter sits between L2 (Activity API routes) and L5 (ActivityFacade).\n\nL2 (API) \u2192 L3 (this adapter) \u2192 L5 (ActivityFacade)\n\nThe adapter:\n1. Receives API requests with tenant context\n2. Enforces tenant isolation (customer can only see their own activities)\n3. Transforms to customer-safe schema (no internal fields)\n4. Delegates to L5 facade\n5. Returns customer-friendly results to L2\n\nThis is a thin translation layer - no business logic, no domain decisions.\n\nReference: ACTIVITY Domain Qualification Task, SWEEP-03 Migration",
        "functions": [
          {
            "name": "get_customer_activity_adapter",
            "signature": "() -> CustomerActivityAdapter",
            "docstring": "Get the singleton CustomerActivityAdapter instance.\n\nThis is the ONLY way L2 should obtain an activity adapter.\nDirect instantiation is discouraged.\n\nReturns:\n    CustomerActivityAdapter singleton instance\n\nReference: ACTIVITY Domain Qualification (L2\u2192L3\u2192L5 pattern)",
            "is_async": false,
            "line": 307
          }
        ],
        "classes": [
          {
            "name": "CustomerActivitySummary",
            "docstring": "Customer-safe activity summary for list view.",
            "methods": [],
            "line": 66
          },
          {
            "name": "CustomerActivityDetail",
            "docstring": "Customer-safe activity detail.",
            "methods": [],
            "line": 81
          },
          {
            "name": "CustomerActivityListResponse",
            "docstring": "Paginated list of customer activities.",
            "methods": [],
            "line": 100
          },
          {
            "name": "CustomerActivityAdapter",
            "docstring": "L3 boundary adapter for customer activity operations.\n\nINVARIANT: All methods require tenant_id for isolation.\nINVARIANT: No L6 imports - delegates to L5 only.\n\nNOTE: This adapter now uses async methods to match HOC ActivityFacade.",
            "methods": [
              "__init__",
              "_get_facade",
              "list_activities",
              "get_activity",
              "_to_customer_summary",
              "_to_customer_detail"
            ],
            "line": 115
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.hoc.cus.activity.L5_engines.activity_facade",
            "names": [
              "ActivityFacade",
              "RunDetailResult",
              "RunListResult",
              "RunSummaryResult",
              "get_activity_facade"
            ],
            "is_relative": false,
            "line": 50
          }
        ],
        "constants": [],
        "all_exports": [
          "CustomerActivityAdapter",
          "CustomerActivitySummary",
          "CustomerActivityDetail",
          "CustomerActivityListResponse",
          "get_customer_activity_adapter"
        ]
      },
      {
        "file_name": "customer_incidents_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/customer_incidents_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 398,
        "module_docstring": "Customer Incidents Boundary Adapter (L3)\n\nThis adapter sits between L2 (guard.py API) and L4 (services).\n\nL2 (Guard API) \u2192 L3 (this adapter) \u2192 L4 (IncidentReadService/IncidentWriteService)\n\nThe adapter:\n1. Receives API requests with tenant context\n2. Enforces tenant isolation\n3. Transforms to customer-safe schema (calm vocabulary)\n4. Delegates to L4 services (no L6 access)\n5. Returns customer-friendly results\n\nReference: PIN-280 (L2 Promotion Governance), PIN-281 (PHASE 1 L3 Closure)",
        "functions": [
          {
            "name": "_translate_severity",
            "signature": "(internal_severity: str) -> str",
            "docstring": "Translate internal severity to calm customer vocabulary.",
            "is_async": false,
            "line": 98
          },
          {
            "name": "_translate_status",
            "signature": "(internal_status: str) -> str",
            "docstring": "Translate internal status to customer vocabulary.",
            "is_async": false,
            "line": 110
          },
          {
            "name": "get_customer_incidents_adapter",
            "signature": "(session: Session) -> CustomerIncidentsAdapter",
            "docstring": "Get a CustomerIncidentsAdapter instance.\n\nArgs:\n    session: Database session\n\nReturns:\n    CustomerIncidentsAdapter instance",
            "is_async": false,
            "line": 373
          }
        ],
        "classes": [
          {
            "name": "CustomerIncidentSummary",
            "docstring": "Customer-safe incident summary for list view.",
            "methods": [],
            "line": 50
          },
          {
            "name": "CustomerIncidentEvent",
            "docstring": "Customer-safe timeline event.",
            "methods": [],
            "line": 66
          },
          {
            "name": "CustomerIncidentDetail",
            "docstring": "Customer-safe incident detail.",
            "methods": [],
            "line": 76
          },
          {
            "name": "CustomerIncidentListResponse",
            "docstring": "Paginated customer incident list.",
            "methods": [],
            "line": 84
          },
          {
            "name": "CustomerIncidentsAdapter",
            "docstring": "Boundary adapter for customer incident operations.\n\nThis class provides the ONLY interface that L2 (guard.py) may use\nto access incident functionality. It enforces tenant isolation and\ntransforms data to customer-safe schemas.\n\nPIN-280 Rule: L3 Is Translation Only + Tenant Scoping\nPIN-281 Rule: L3 imports L4 only (no L6 direct access)",
            "methods": [
              "__init__",
              "list_incidents",
              "get_incident",
              "acknowledge_incident",
              "resolve_incident"
            ],
            "line": 127
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.hoc.cus.incidents.L5_engines.incident_read_engine",
            "names": [
              "get_incident_read_service"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "app.hoc.cus.incidents.L5_engines.incident_write_engine",
            "names": [
              "get_incident_write_service"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [],
        "all_exports": [
          "CustomerIncidentsAdapter",
          "get_customer_incidents_adapter",
          "CustomerIncidentSummary",
          "CustomerIncidentEvent",
          "CustomerIncidentDetail",
          "CustomerIncidentListResponse"
        ]
      },
      {
        "file_name": "customer_keys_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/customer_keys_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 305,
        "module_docstring": "Customer Keys Boundary Adapter (L3)\n\nThis adapter sits between L2 (guard.py API) and L4 (services).\n\nL2 (Guard API) \u2192 L3 (this adapter) \u2192 L4 (KeysReadService/KeysWriteService)\n\nThe adapter:\n1. Receives API requests with tenant context\n2. Enforces tenant isolation\n3. Transforms to customer-safe schema (prefix only, no full key)\n4. Delegates to L4 services (no L6 access)\n\nReference: PIN-280 (L2 Promotion Governance), PIN-281 (PHASE 1 L3 Closure)",
        "functions": [
          {
            "name": "get_customer_keys_adapter",
            "signature": "(session: Session) -> CustomerKeysAdapter",
            "docstring": "Get a CustomerKeysAdapter instance.\n\nArgs:\n    session: Database session\n\nReturns:\n    CustomerKeysAdapter instance",
            "is_async": false,
            "line": 281
          }
        ],
        "classes": [
          {
            "name": "CustomerKeyInfo",
            "docstring": "Customer-safe API key information.",
            "methods": [],
            "line": 51
          },
          {
            "name": "CustomerKeyListResponse",
            "docstring": "Customer key list response.",
            "methods": [],
            "line": 65
          },
          {
            "name": "CustomerKeyAction",
            "docstring": "Result of a key action (freeze/unfreeze).",
            "methods": [],
            "line": 72
          },
          {
            "name": "CustomerKeysAdapter",
            "docstring": "Boundary adapter for customer API key operations.\n\nThis class provides the ONLY interface that L2 (guard.py) may use\nto access API key functionality. It enforces tenant isolation and\ntransforms data to customer-safe schemas.\n\nPIN-280 Rule: L3 Is Translation Only + Tenant Scoping\nPIN-281 Rule: L3 imports L4 only (no L6 direct access)",
            "methods": [
              "__init__",
              "list_keys",
              "get_key",
              "freeze_key",
              "unfreeze_key"
            ],
            "line": 86
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.api_keys.L5_engines.keys_engine",
            "names": [
              "get_keys_read_engine",
              "get_keys_write_engine"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "CustomerKeysAdapter",
          "get_customer_keys_adapter",
          "CustomerKeyInfo",
          "CustomerKeyListResponse",
          "CustomerKeyAction"
        ]
      },
      {
        "file_name": "customer_logs_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/customer_logs_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 410,
        "module_docstring": "Customer Logs Boundary Adapter (L3)\n\nThis adapter sits between L2 (guard_logs.py API) and L4 (LogsReadService).\n\nL2 (Guard API) \u2192 L3 (this adapter) \u2192 L4 (LogsReadService)\n\nThe adapter:\n1. Receives API requests with tenant context\n2. Enforces tenant isolation (customer can only see their own logs)\n3. Transforms to customer-safe schema (no internal fields)\n4. Delegates to L4 service\n5. Returns customer-friendly results to L2\n\nThis is a thin translation layer - no business logic, no domain decisions.\n\nReference: PIN-280 (L2 Promotion Governance), PIN-281 (PHASE 1 L3 Closure)",
        "functions": [
          {
            "name": "get_customer_logs_adapter",
            "signature": "() -> CustomerLogsAdapter",
            "docstring": "Get the singleton CustomerLogsAdapter instance.\n\nThis is the ONLY way L2 should obtain a logs adapter.\nDirect instantiation is discouraged.\n\nReturns:\n    CustomerLogsAdapter singleton instance\n\nReference: PIN-281 (L3 Is the Only Entry for L2)",
            "is_async": false,
            "line": 380
          }
        ],
        "classes": [
          {
            "name": "CustomerLogSummary",
            "docstring": "Customer-safe log summary for list view.",
            "methods": [],
            "line": 49
          },
          {
            "name": "CustomerLogStep",
            "docstring": "Customer-safe log step for detail view.",
            "methods": [],
            "line": 66
          },
          {
            "name": "CustomerLogDetail",
            "docstring": "Customer-safe log detail.",
            "methods": [],
            "line": 80
          },
          {
            "name": "CustomerLogListResponse",
            "docstring": "Paginated customer log list.",
            "methods": [],
            "line": 99
          },
          {
            "name": "CustomerLogsAdapter",
            "docstring": "Boundary adapter for customer logs operations.\n\nThis class provides the ONLY interface that L2 (guard_logs.py) may use\nto access log/trace functionality. It enforces tenant isolation and\ntransforms data to customer-safe schemas.\n\nPIN-280 Rule: L3 Is Translation Only + Tenant Scoping\nPIN-281 Rule: L3 imports L4 only (no L6 direct access)",
            "methods": [
              "__init__",
              "_get_service",
              "list_logs",
              "get_log",
              "export_logs"
            ],
            "line": 113
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "CustomerLogsAdapter",
          "get_customer_logs_adapter",
          "CustomerLogSummary",
          "CustomerLogStep",
          "CustomerLogDetail",
          "CustomerLogListResponse"
        ]
      },
      {
        "file_name": "customer_policies_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/customer_policies_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 279,
        "module_docstring": "Customer Policies Boundary Adapter (L3)\n\nThis adapter sits between L2 (guard_policies.py API) and L4 (CustomerPolicyReadService).\n\nL2 (Guard API) \u2192 L3 (this adapter) \u2192 L4 (CustomerPolicyReadService)\n\nThe adapter:\n1. Receives API requests with tenant context\n2. Enforces tenant isolation\n3. Transforms to customer-safe policy view\n4. Delegates to L4 service\n5. Returns customer-friendly policy constraints to L2\n\nThis is a thin translation layer - no policy evaluation logic, no direct DB access.\n\nReference: PIN-280 (L2 Promotion Governance), PIN-281 (Claude Task TODO)",
        "functions": [
          {
            "name": "get_customer_policies_adapter",
            "signature": "() -> CustomerPoliciesAdapter",
            "docstring": "Get the singleton CustomerPoliciesAdapter instance.\n\nThis is the ONLY way L2 should obtain a policies adapter.\nDirect instantiation is discouraged.\n\nNote: Unlike the old version that took a session parameter,\nthis now uses the singleton pattern. The session is managed\ninternally by the L4 service.\n\nReturns:\n    CustomerPoliciesAdapter singleton instance\n\nReference: PIN-281 (L3 Is the Only Entry for L2)",
            "is_async": false,
            "line": 245
          }
        ],
        "classes": [
          {
            "name": "CustomerBudgetConstraint",
            "docstring": "Customer-visible budget constraint.",
            "methods": [],
            "line": 56
          },
          {
            "name": "CustomerRateLimit",
            "docstring": "Customer-visible rate limit.",
            "methods": [],
            "line": 67
          },
          {
            "name": "CustomerGuardrail",
            "docstring": "Customer-visible guardrail configuration.",
            "methods": [],
            "line": 76
          },
          {
            "name": "CustomerPolicyConstraints",
            "docstring": "Customer-visible policy constraints summary.",
            "methods": [],
            "line": 87
          },
          {
            "name": "CustomerPoliciesAdapter",
            "docstring": "Boundary adapter for customer policy constraints.\n\nThis class provides the ONLY interface that L2 (guard_policies.py) may use\nto access policy constraint information. It enforces tenant isolation and\ntransforms data to customer-safe schemas.\n\nINVARIANT: All methods require tenant_id for isolation.\nINVARIANT: No L6 imports - delegates to L4 only.\n\nPIN-280 Rule: L3 Is Translation Only + Tenant Scoping",
            "methods": [
              "__init__",
              "_get_service",
              "get_policy_constraints",
              "get_guardrail_detail",
              "_to_customer_policy_constraints",
              "_to_customer_guardrail"
            ],
            "line": 102
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.hoc.cus.policies.L5_engines.customer_policy_read_engine",
            "names": [
              "CustomerPolicyReadService",
              "GuardrailSummary",
              "PolicyConstraints",
              "get_customer_policy_read_service"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": [
          "CustomerPoliciesAdapter",
          "get_customer_policies_adapter",
          "CustomerBudgetConstraint",
          "CustomerRateLimit",
          "CustomerGuardrail",
          "CustomerPolicyConstraints"
        ]
      },
      {
        "file_name": "file_storage_base.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/file_storage_base.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 299,
        "module_docstring": "File Storage Base Adapter\n\nProvides abstract interface for file storage operations.\nAll file storage adapters must implement this interface.",
        "functions": [],
        "classes": [
          {
            "name": "FileMetadata",
            "docstring": "Metadata for a stored file.",
            "methods": [
              "to_dict"
            ],
            "line": 29
          },
          {
            "name": "UploadResult",
            "docstring": "Result of an upload operation.",
            "methods": [
              "success"
            ],
            "line": 52
          },
          {
            "name": "DownloadResult",
            "docstring": "Result of a download operation.",
            "methods": [
              "success"
            ],
            "line": 67
          },
          {
            "name": "ListResult",
            "docstring": "Result of a list operation.",
            "methods": [],
            "line": 79
          },
          {
            "name": "FileStorageAdapter",
            "docstring": "Abstract base class for file storage adapters.\n\nAll file storage implementations must implement these methods.",
            "methods": [
              "connect",
              "disconnect",
              "upload",
              "download",
              "download_stream",
              "delete",
              "delete_many",
              "exists",
              "get_metadata",
              "list_files",
              "generate_presigned_url",
              "copy",
              "health_check"
            ],
            "line": 87
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "AsyncIterator",
              "BinaryIO",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 23
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "founder_ops_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/founder_ops_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 145,
        "module_docstring": "Founder Ops Adapter (L3)\n\nTranslates L4 OpsIncident domain models to Founder-facing API views.\n\nL4 (OpsIncidentService) \u2192 L3 (this adapter) \u2192 L2 (ops.py)\n\nThe adapter:\n1. Receives OpsIncident domain models from L4\n2. Selects/renames fields for Founder audience\n3. Applies minimal redaction if needed\n4. Returns FounderIncidentSummaryView for L2\n\nHARD RULES (from PIN-264):\n- NO infra queries (that's L4's job)\n- NO aggregation (that's L4's job)\n- NO permissions logic (that's L2's job)\n- NO pagination (that's L2's job)\n- ONLY field selection, redaction, light renaming",
        "functions": [],
        "classes": [
          {
            "name": "FounderIncidentSummaryView",
            "docstring": "Founder-facing incident summary.\n\nThis is what L2 returns to Founder Console.\nDistinct from OpsIncident (L4 domain model).",
            "methods": [],
            "line": 45
          },
          {
            "name": "FounderIncidentsSummaryResponse",
            "docstring": "Response for GET /ops/incidents/summary.\n\nAggregated incident counts plus recent incidents.",
            "methods": [],
            "line": 66
          },
          {
            "name": "FounderOpsAdapter",
            "docstring": "Boundary adapter for Founder Ops incident views.\n\nThis class provides the ONLY interface that L2 (ops.py) may use\nto access OpsIncident data. It translates domain models to\nFounder-facing views.\n\nPIN-264 L3 Rule: Translation only, no business logic.",
            "methods": [
              "to_summary_view",
              "to_summary_response"
            ],
            "line": 85
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "typing",
            "names": [
              "List"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "app.hoc.fdr.ops.schemas.ops_domain_models",
            "names": [
              "OpsIncident"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "gcs_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/gcs_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 442,
        "module_docstring": "Google Cloud Storage File Storage Adapter (GAP-148)\n\nProvides integration with Google Cloud Storage:\n- Bucket operations\n- Resumable uploads for large files\n- Signed URLs\n- Object lifecycle management",
        "functions": [],
        "classes": [
          {
            "name": "GCSAdapter",
            "docstring": "Google Cloud Storage file storage adapter.\n\nUses google-cloud-storage with async wrappers.",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "upload",
              "download",
              "download_stream",
              "delete",
              "delete_many",
              "exists",
              "get_metadata",
              "list_files",
              "generate_presigned_url",
              "copy"
            ],
            "line": 38
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "AsyncIterator",
              "BinaryIO",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "base",
            "names": [
              "DownloadResult",
              "FileMetadata",
              "FileStorageAdapter",
              "ListResult",
              "UploadResult"
            ],
            "is_relative": true,
            "line": 27
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "lambda_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/lambda_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 281,
        "module_docstring": "AWS Lambda Serverless Adapter (GAP-149)\n\nProvides integration with AWS Lambda:\n- Sync and async invocation\n- Payload encoding/decoding\n- Log retrieval\n- Function management",
        "functions": [],
        "classes": [
          {
            "name": "LambdaAdapter",
            "docstring": "AWS Lambda serverless adapter.\n\nUses aioboto3 for async Lambda operations.",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "invoke",
              "invoke_batch",
              "get_function_info",
              "list_functions",
              "function_exists"
            ],
            "line": 42
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "base64",
            "names": [
              "base64"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "base",
            "names": [
              "FunctionInfo",
              "InvocationRequest",
              "InvocationResult",
              "InvocationType",
              "ServerlessAdapter"
            ],
            "is_relative": true,
            "line": 31
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "pgvector_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/pgvector_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 378,
        "module_docstring": "PGVector Production Adapter (GAP-146)\n\nProvides integration with PostgreSQL pgvector extension:\n- Native PostgreSQL integration\n- HNSW and IVFFlat indexes\n- SQL-based metadata filtering\n- Production-ready with connection pooling",
        "functions": [],
        "classes": [
          {
            "name": "PGVectorAdapter",
            "docstring": "PGVector production adapter.\n\nUses asyncpg for async PostgreSQL operations with pgvector extension.",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "upsert",
              "query",
              "delete",
              "get_stats",
              "create_namespace",
              "delete_namespace",
              "list_namespaces"
            ],
            "line": 38
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "base",
            "names": [
              "DeleteResult",
              "IndexStats",
              "QueryResult",
              "UpsertResult",
              "VectorRecord",
              "VectorStoreAdapter"
            ],
            "is_relative": true,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "pinecone_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/pinecone_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 283,
        "module_docstring": "Pinecone Vector Store Adapter (GAP-144)\n\nProvides integration with Pinecone vector database:\n- Serverless and pod-based indexes\n- Namespace support\n- Metadata filtering\n- Batch operations",
        "functions": [],
        "classes": [
          {
            "name": "PineconeAdapter",
            "docstring": "Pinecone vector store adapter.\n\nSupports both serverless and pod-based Pinecone indexes.",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "upsert",
              "query",
              "delete",
              "get_stats",
              "create_namespace",
              "delete_namespace",
              "list_namespaces"
            ],
            "line": 40
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "base",
            "names": [
              "DeleteResult",
              "IndexStats",
              "QueryResult",
              "UpsertResult",
              "VectorRecord",
              "VectorStoreAdapter"
            ],
            "is_relative": true,
            "line": 28
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "runtime_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/runtime_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 215,
        "module_docstring": "Runtime Boundary Adapter (L3)\n\nL3 adapter for runtime API operations. This is the boundary between:\n- L2 (API routes) - callers\n- L4 (Domain commands) - domain decisions\n\nThis adapter:\n1. Receives API requests from L2\n2. Translates them into L4 domain facts\n3. Calls L4 command functions\n4. Returns domain results to L2\n\nIt does NOT:\n- Import from L5 (workers)\n- Execute skills directly\n- Make domain decisions (that's L4's job)\n\nReference: PIN-258 Phase F-3 Runtime Cluster",
        "functions": [
          {
            "name": "get_runtime_adapter",
            "signature": "() -> RuntimeAdapter",
            "docstring": "Factory function to get RuntimeAdapter instance.\n\nThis is the entry point for L2 to get the adapter.\n\nReturns:\n    RuntimeAdapter instance\n\nReference: PIN-258 Phase F-3",
            "is_async": false,
            "line": 194
          }
        ],
        "classes": [
          {
            "name": "RuntimeAdapter",
            "docstring": "L3 Boundary Adapter for runtime operations.\n\nTranslates API requests into L4 domain commands.\nThis is the ONLY runtime interface L2 may call.\n\nReference: PIN-258 Phase F-3 Runtime Cluster",
            "methods": [
              "__init__",
              "query",
              "get_supported_queries",
              "describe_skill",
              "list_skills",
              "get_skill_descriptors",
              "get_resource_contract",
              "get_capabilities"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "app.commands.runtime_command",
            "names": [
              "CapabilitiesInfo",
              "QueryResult",
              "ResourceContractInfo",
              "SkillInfo",
              "execute_query",
              "get_all_skill_descriptors",
              "get_capabilities",
              "get_resource_contract",
              "get_skill_info",
              "get_supported_query_types",
              "list_skills"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "RuntimeAdapter",
          "get_runtime_adapter"
        ]
      },
      {
        "file_name": "s3_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/s3_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 393,
        "module_docstring": "AWS S3 File Storage Adapter (GAP-147)\n\nProvides integration with AWS S3:\n- Bucket operations\n- Multipart upload for large files\n- Presigned URLs\n- Server-side encryption",
        "functions": [],
        "classes": [
          {
            "name": "S3Adapter",
            "docstring": "AWS S3 file storage adapter.\n\nUses aioboto3 for async S3 operations.",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "upload",
              "download",
              "download_stream",
              "delete",
              "delete_many",
              "exists",
              "get_metadata",
              "list_files",
              "generate_presigned_url",
              "copy"
            ],
            "line": 39
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "AsyncIterator",
              "BinaryIO",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "base",
            "names": [
              "DownloadResult",
              "FileMetadata",
              "FileStorageAdapter",
              "ListResult",
              "UploadResult"
            ],
            "is_relative": true,
            "line": 28
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "serverless_base.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/serverless_base.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 236,
        "module_docstring": "Serverless Base Adapter\n\nProvides abstract interface for serverless function operations.\nAll serverless adapters must implement this interface.",
        "functions": [],
        "classes": [
          {
            "name": "InvocationType",
            "docstring": "Type of function invocation.",
            "methods": [],
            "line": 29
          },
          {
            "name": "InvocationRequest",
            "docstring": "Request to invoke a serverless function.",
            "methods": [
              "to_dict"
            ],
            "line": 37
          },
          {
            "name": "InvocationResult",
            "docstring": "Result of a serverless function invocation.",
            "methods": [
              "success",
              "to_dict"
            ],
            "line": 58
          },
          {
            "name": "FunctionInfo",
            "docstring": "Information about a serverless function.",
            "methods": [
              "to_dict"
            ],
            "line": 92
          },
          {
            "name": "ServerlessAdapter",
            "docstring": "Abstract base class for serverless adapters.\n\nAll serverless implementations must implement these methods.",
            "methods": [
              "connect",
              "disconnect",
              "invoke",
              "invoke_batch",
              "get_function_info",
              "list_functions",
              "function_exists",
              "health_check"
            ],
            "line": 118
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "slack_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/slack_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 305,
        "module_docstring": "Slack Notification Adapter (GAP-152)\n\nProvides Slack notifications:\n- Channel and DM messaging\n- Rich message formatting (blocks)\n- File uploads\n- Thread replies",
        "functions": [],
        "classes": [
          {
            "name": "SlackAdapter",
            "docstring": "Slack notification adapter.\n\nUses slack_sdk for async Slack API operations.",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "send",
              "_build_blocks",
              "_get_priority_emoji",
              "send_batch",
              "get_status",
              "send_thread_reply"
            ],
            "line": 39
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "base",
            "names": [
              "NotificationAdapter",
              "NotificationMessage",
              "NotificationPriority",
              "NotificationResult",
              "NotificationStatus"
            ],
            "is_relative": true,
            "line": 28
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "smtp_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/smtp_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 259,
        "module_docstring": "SMTP Notification Adapter (GAP-151)\n\nProvides email notifications via SMTP:\n- Async email sending via aiosmtplib\n- HTML and plain text support\n- Attachment handling\n- Connection pooling",
        "functions": [],
        "classes": [
          {
            "name": "SMTPAdapter",
            "docstring": "SMTP notification adapter for email.\n\nUses aiosmtplib for async email operations.",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "send",
              "_build_email",
              "send_batch",
              "get_status"
            ],
            "line": 42
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "email.mime.multipart",
            "names": [
              "MIMEMultipart"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "email.mime.text",
            "names": [
              "MIMEText"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "email.mime.base",
            "names": [
              "MIMEBase"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "email",
            "names": [
              "encoders"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "base",
            "names": [
              "NotificationAdapter",
              "NotificationMessage",
              "NotificationResult",
              "NotificationStatus"
            ],
            "is_relative": true,
            "line": 32
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "vector_stores_base.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/vector_stores_base.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 265,
        "module_docstring": "Vector Store Base Adapter\n\nProvides abstract interface for vector store operations.\nAll vector store adapters must implement this interface.",
        "functions": [],
        "classes": [
          {
            "name": "VectorRecord",
            "docstring": "A single vector record.",
            "methods": [
              "to_dict"
            ],
            "line": 29
          },
          {
            "name": "QueryResult",
            "docstring": "Result of a vector similarity query.",
            "methods": [
              "to_dict"
            ],
            "line": 50
          },
          {
            "name": "UpsertResult",
            "docstring": "Result of an upsert operation.",
            "methods": [
              "success"
            ],
            "line": 71
          },
          {
            "name": "DeleteResult",
            "docstring": "Result of a delete operation.",
            "methods": [
              "success"
            ],
            "line": 84
          },
          {
            "name": "IndexStats",
            "docstring": "Statistics about a vector index.",
            "methods": [
              "to_dict"
            ],
            "line": 96
          },
          {
            "name": "VectorStoreAdapter",
            "docstring": "Abstract base class for vector store adapters.\n\nAll vector store implementations must implement these methods.",
            "methods": [
              "connect",
              "disconnect",
              "upsert",
              "query",
              "delete",
              "get_stats",
              "health_check",
              "create_namespace",
              "delete_namespace",
              "list_namespaces"
            ],
            "line": 116
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 19
          },
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 20
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 23
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "weaviate_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/weaviate_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 399,
        "module_docstring": "Weaviate Vector Store Adapter (GAP-145)\n\nProvides integration with Weaviate vector database:\n- Schema-based collections\n- Hybrid search (vector + keyword)\n- GraphQL queries\n- Multi-tenancy support",
        "functions": [],
        "classes": [
          {
            "name": "WeaviateAdapter",
            "docstring": "Weaviate vector store adapter.\n\nSupports both Weaviate Cloud Services (WCS) and self-hosted instances.",
            "methods": [
              "__init__",
              "connect",
              "_create_collection",
              "disconnect",
              "upsert",
              "query",
              "_build_filter",
              "delete",
              "get_stats",
              "create_namespace",
              "delete_namespace",
              "list_namespaces"
            ],
            "line": 38
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "base",
            "names": [
              "DeleteResult",
              "IndexStats",
              "QueryResult",
              "UpsertResult",
              "VectorRecord",
              "VectorStoreAdapter"
            ],
            "is_relative": true,
            "line": 26
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "webhook_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/webhook_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 472,
        "module_docstring": "Webhook Notification Adapter with Retry Logic (GAP-153)\n\nProvides webhook notifications with robust retry:\n- Exponential backoff\n- Configurable retry policies\n- Circuit breaker pattern\n- Dead letter queue support",
        "functions": [],
        "classes": [
          {
            "name": "CircuitState",
            "docstring": "Circuit breaker states.",
            "methods": [],
            "line": 46
          },
          {
            "name": "CircuitBreakerConfig",
            "docstring": "Configuration for circuit breaker.",
            "methods": [],
            "line": 54
          },
          {
            "name": "CircuitBreaker",
            "docstring": "Circuit breaker for webhook endpoint.",
            "methods": [
              "can_execute",
              "record_success",
              "record_failure"
            ],
            "line": 64
          },
          {
            "name": "WebhookDeliveryAttempt",
            "docstring": "Record of a webhook delivery attempt.",
            "methods": [],
            "line": 121
          },
          {
            "name": "WebhookDelivery",
            "docstring": "Full record of webhook delivery with all attempts.",
            "methods": [
              "to_dict"
            ],
            "line": 133
          },
          {
            "name": "WebhookAdapter",
            "docstring": "Webhook notification adapter with retry logic.\n\nFeatures:\n- Exponential backoff with jitter\n- Circuit breaker per endpoint\n- HMAC signature verification\n- Dead letter queue callback",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "_get_circuit_breaker",
              "_sign_payload",
              "send",
              "_deliver_with_retry",
              "_attempt_delivery",
              "send_batch",
              "get_status",
              "get_delivery_details",
              "get_circuit_breaker_status"
            ],
            "line": 165
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 22
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "hmac",
            "names": [
              "hmac"
            ],
            "is_relative": false,
            "line": 24
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 25
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 26
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 27
          },
          {
            "module": "time",
            "names": [
              "time"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "base",
            "names": [
              "NotificationAdapter",
              "NotificationMessage",
              "NotificationResult",
              "NotificationStatus",
              "RetryConfig"
            ],
            "is_relative": true,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "workers_adapter.py",
        "file_path": "backend/app/hoc/cus/integrations/L3_adapters/workers_adapter.py",
        "layer": "L3_adapters",
        "domain": "integrations",
        "lines": 208,
        "module_docstring": "Workers Boundary Adapter (L3)\n\nThis adapter sits between L2 (workers.py API) and L4 (worker_execution_command.py).\n\nL2 (API) \u2192 L3 (this adapter) \u2192 L4 (command) \u2192 L5 (worker execution)\n\nThe adapter:\n1. Receives API requests with execution context\n2. Translates to domain facts\n3. Delegates to L4 commands\n4. Returns results to L2\n\nThis is a thin translation layer - no business logic, no state mutation.\n\nReference: PIN-258 Phase F-3 Workers Cluster",
        "functions": [
          {
            "name": "get_workers_adapter",
            "signature": "() -> WorkersAdapter",
            "docstring": "Get the singleton WorkersAdapter instance.\n\nThis is the ONLY way L2 should obtain a workers adapter.\nDirect instantiation is discouraged.\n\nReturns:\n    WorkersAdapter singleton instance\n\nReference: PIN-258 Phase F-3 (F-W-RULE-4: L3 Is the Only Entry)",
            "is_async": false,
            "line": 180
          }
        ],
        "classes": [
          {
            "name": "WorkersAdapter",
            "docstring": "Boundary adapter for worker operations.\n\nThis class provides the ONLY interface that L2 (workers.py) may use\nto access worker functionality. It translates API context to domain\nfacts and delegates to L4 commands.\n\nF-W-RULE-4: L3 Adapter Is the Only Entry",
            "methods": [
              "execute_worker",
              "replay_execution",
              "calculate_cost_cents",
              "convert_brand_request"
            ],
            "line": 56
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.commands.worker_execution_command",
            "names": [
              "ReplayResult",
              "WorkerExecutionResult",
              "calculate_cost_cents",
              "convert_brand_request",
              "execute_worker",
              "replay_execution"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "WorkersAdapter",
          "get_workers_adapter",
          "WorkerExecutionResult",
          "ReplayResult"
        ]
      }
    ],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "bridges.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/bridges.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 1229,
        "module_docstring": "M25 Integration Bridges\n\nFive bridges connecting the three pillars:\n1. Incident \u2192 Failure Catalog (with confidence bands)\n2. Pattern \u2192 Recovery (with template/generated distinction)\n3. Recovery \u2192 Policy (with shadow mode)\n4. Policy \u2192 CARE Routing (with guardrails)\n5. Loop Status \u2192 Console (with narrative artifacts)\n\nFROZEN: 2025-12-23\nDo NOT modify loop mechanics without explicit approval.",
        "functions": [
          {
            "name": "_check_frozen",
            "signature": "() -> None",
            "docstring": "Log that frozen mechanics are in use.",
            "is_async": false,
            "line": 75
          },
          {
            "name": "create_bridges",
            "signature": "(db_session_factory, redis_client, config = None) -> list[BaseBridge]",
            "docstring": "Create all bridges with shared configuration.",
            "is_async": false,
            "line": 1205
          },
          {
            "name": "register_all_bridges",
            "signature": "(dispatcher: 'IntegrationDispatcher', db_session_factory, redis_client, config = None) -> None",
            "docstring": "Register all bridges with the dispatcher.",
            "is_async": false,
            "line": 1220
          }
        ],
        "classes": [
          {
            "name": "BaseBridge",
            "docstring": "Base class for all integration bridges.",
            "methods": [
              "stage",
              "process",
              "register"
            ],
            "line": 94
          },
          {
            "name": "IncidentToCatalogBridge",
            "docstring": "Bridge 1: Route incidents to failure catalog.\n\nEnhanced with:\n- Confidence bands (strong/weak/novel)\n- Signature normalization for better matching\n- Pattern version tracking",
            "methods": [
              "__init__",
              "stage",
              "process",
              "_extract_signature",
              "_hash_signature",
              "_find_matching_pattern",
              "_calculate_fuzzy_confidence",
              "_increment_pattern_count",
              "_create_pattern"
            ],
            "line": 119
          },
          {
            "name": "PatternToRecoveryBridge",
            "docstring": "Bridge 2: Generate recovery suggestions from patterns.\n\nEnhanced with:\n- Template vs generated distinction\n- Confirmation requirements based on confidence\n- Auto-apply only for strong matches",
            "methods": [
              "__init__",
              "stage",
              "process",
              "_load_pattern",
              "_instantiate_template",
              "_generate_recovery",
              "_apply_recovery",
              "_queue_for_review",
              "_persist_recovery"
            ],
            "line": 392
          },
          {
            "name": "RecoveryToPolicyBridge",
            "docstring": "Bridge 3: Convert applied recovery into prevention policy.\n\nEnhanced with:\n- Shadow mode for safe observation\n- N-confirmation requirement\n- Policy regret tracking",
            "methods": [
              "__init__",
              "stage",
              "process",
              "_load_pattern",
              "_generate_policy",
              "_persist_policy"
            ],
            "line": 628
          },
          {
            "name": "PolicyToRoutingBridge",
            "docstring": "Bridge 4: Update CARE routing based on new policy.\n\nEnhanced with guardrails:\n- Max delta per adjustment (default 20%)\n- Decay window (default 7 days)\n- KPI regression rollback (default 10% threshold)",
            "methods": [
              "__init__",
              "stage",
              "process",
              "_identify_affected_agents",
              "_create_adjustment",
              "_get_active_adjustments",
              "_get_agent_kpi",
              "_persist_adjustment"
            ],
            "line": 833
          },
          {
            "name": "LoopStatusBridge",
            "docstring": "Bridge 5: Aggregate loop status for console display.\n\nEnhanced with:\n- Narrative artifacts for storytelling\n- Real-time SSE updates\n- Before/after comparisons",
            "methods": [
              "__init__",
              "stage",
              "process",
              "_build_loop_status",
              "_push_sse_update"
            ],
            "line": 1091
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "schemas.audit_schemas",
            "names": [
              "PolicyActivationAudit"
            ],
            "is_relative": true,
            "line": 49
          },
          {
            "module": "schemas.loop_events",
            "names": [
              "LOOP_MECHANICS_FROZEN_AT",
              "LOOP_MECHANICS_VERSION",
              "ConfidenceBand",
              "ConfidenceCalculator",
              "LoopEvent",
              "LoopFailureState",
              "LoopStage",
              "LoopStatus",
              "PatternMatchResult",
              "PolicyMode",
              "PolicyRule",
              "RecoverySuggestion",
              "RoutingAdjustment"
            ],
            "is_relative": true,
            "line": 50
          },
          {
            "module": "bridges_driver",
            "names": [
              "record_policy_activation"
            ],
            "is_relative": true,
            "line": 65
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "connectors_facade.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/connectors_facade.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 439,
        "module_docstring": "Connectors Facade (L4 Domain Logic)\n\nThis facade provides the external interface for connector operations.\nAll connector APIs MUST use this facade instead of directly importing\ninternal connector modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes connector management logic\n- Provides unified access to HTTP, SQL, MCP connectors\n- Single point for audit emission\n\nWrapped Services:\n- ConnectorRegistry: Connector registration and management\n- HTTPConnector: HTTP/REST connector (GAP-059)\n- SQLConnector: SQL database connector (GAP-060)\n- MCPConnector: MCP protocol connector (GAP-063)\n\nL2 API Routes (GAP-093):\n- GET /api/v1/connectors (list connectors)\n- POST /api/v1/connectors (register connector)\n- GET /api/v1/connectors/{id} (get connector)\n- PUT /api/v1/connectors/{id} (update connector)\n- DELETE /api/v1/connectors/{id} (delete connector)\n- POST /api/v1/connectors/{id}/test (test connector)\n\nUsage:\n    # L5 engine import (migrated to HOC per SWEEP-13)\n    from app.hoc.cus.integrations.L5_engines.connectors_facade import get_connectors_facade\n\n    facade = get_connectors_facade()\n\n    # List connectors\n    connectors = await facade.list_connectors(tenant_id=\"...\")\n\n    # Register a new connector\n    connector = await facade.register_connector(...)\n\n    # Test connection\n    result = await facade.test_connector(connector_id=\"...\")",
        "functions": [
          {
            "name": "get_connectors_facade",
            "signature": "() -> ConnectorsFacade",
            "docstring": "Get the connectors facade instance.\n\nThis is the recommended way to access connector operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    ConnectorsFacade instance",
            "is_async": false,
            "line": 426
          }
        ],
        "classes": [
          {
            "name": "ConnectorInfo",
            "docstring": "Connector information.",
            "methods": [
              "to_dict"
            ],
            "line": 73
          },
          {
            "name": "TestResult",
            "docstring": "Result of connector test.",
            "methods": [
              "to_dict"
            ],
            "line": 107
          },
          {
            "name": "ConnectorsFacade",
            "docstring": "Facade for connector operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nconnector services.\n\nLayer: L4 (Domain Logic)\nCallers: connectors.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "registry",
              "list_connectors",
              "get_connector",
              "register_connector",
              "update_connector",
              "delete_connector",
              "test_connector",
              "_get_capabilities_for_type"
            ],
            "line": 126
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 64
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 65
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 67
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cost_bridges_engine.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/cost_bridges_engine.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 1147,
        "module_docstring": "M27 Cost Loop Integration Bridges\n\nWires Cost Intelligence into M25 Integration Loop:\n- C1: Cost Anomaly \u2192 Incident\n- C2: Cost Pattern \u2192 Failure Catalog\n- C3: Cost Recovery Generator\n- C4: Cost Policy Generator\n- C5: Cost Routing Adjuster\n\nThe Invariant: Every cost anomaly enters the loop.\nEvery loop completion reduces future cost risk.",
        "functions": [],
        "classes": [
          {
            "name": "AnomalyType",
            "docstring": "Types of cost anomalies.",
            "methods": [],
            "line": 62
          },
          {
            "name": "AnomalySeverity",
            "docstring": "Severity levels for cost anomalies.",
            "methods": [],
            "line": 75
          },
          {
            "name": "CostAnomaly",
            "docstring": "Detected cost anomaly from M26 Cost Intelligence.\n\nThis is the input to the M27 Cost Loop.",
            "methods": [
              "create",
              "to_dict"
            ],
            "line": 85
          },
          {
            "name": "CostLoopBridge",
            "docstring": "Bridge C1: Cost Anomaly \u2192 Incident (MANDATORY GOVERNANCE).\n\nCreates real incidents from cost anomalies using mandatory governance.\nNo simulation. No optional dispatcher. Every HIGH+ anomaly creates an incident or crashes.",
            "methods": [
              "__init__",
              "on_anomaly_detected",
              "_map_severity_to_incident_severity"
            ],
            "line": 181
          },
          {
            "name": "CostPatternMatcher",
            "docstring": "Bridge C2: Match cost anomalies to failure patterns.\n\nCost patterns are categorized by:\n- Entity type (user, feature, model, tenant)\n- Anomaly type (spike, budget, unusual)\n- Severity threshold",
            "methods": [
              "__init__",
              "match_cost_pattern",
              "_build_signature",
              "_hash_signature",
              "_deviation_bucket",
              "_find_predefined_match",
              "_calculate_confidence"
            ],
            "line": 251
          },
          {
            "name": "CostRecoveryGenerator",
            "docstring": "Bridge C3: Generate recovery suggestions for cost anomalies.\n\nRecovery strategies by anomaly type:\n- USER_SPIKE \u2192 Rate limit, notify user, review usage\n- FEATURE_SPIKE \u2192 Optimize prompts, model downgrade, caching\n- BUDGET_EXCEEDED \u2192 Hard block, escalate, increase budget\n- UNUSUAL_MODEL \u2192 Route to cheaper model, review routing",
            "methods": [
              "__init__",
              "generate_recovery"
            ],
            "line": 420
          },
          {
            "name": "CostPolicyGenerator",
            "docstring": "Bridge C4: Generate policies from cost recoveries.\n\nPolicy categories:\n- operational: Rate limits, throttling\n- routing: Model selection, cost-aware routing\n- safety: Hard budget blocks",
            "methods": [
              "__init__",
              "generate_policy"
            ],
            "line": 632
          },
          {
            "name": "CostRoutingAdjuster",
            "docstring": "Bridge C5: Adjust CARE routing based on cost policies.\n\nRouting adjustments:\n- Add cost estimation probe before execution\n- Route expensive requests to cheaper models\n- Add budget-check middleware\n- Adjust agent confidence based on cost efficiency",
            "methods": [
              "__init__",
              "on_cost_policy_created",
              "_create_model_routing_adjustment",
              "_create_rate_limit_adjustment",
              "_create_budget_block_adjustment",
              "_create_token_limit_adjustment",
              "_create_throttle_adjustment",
              "_create_notify_adjustment",
              "_create_review_adjustment",
              "_create_escalation_adjustment"
            ],
            "line": 791
          },
          {
            "name": "CostEstimationProbe",
            "docstring": "CARE probe that estimates request cost before execution.\n\nUsed to:\n1. Route to cheaper models if estimate exceeds threshold\n2. Block requests that would exceed budget\n3. Warn users about expensive operations",
            "methods": [
              "__init__",
              "probe",
              "_calculate_cost",
              "_find_cheaper_model"
            ],
            "line": 956
          },
          {
            "name": "CostLoopOrchestrator",
            "docstring": "Orchestrates the full M27 cost loop:\nAnomaly \u2192 Incident \u2192 Pattern \u2192 Recovery \u2192 Policy \u2192 Routing\n\nMANDATORY GOVERNANCE: Incident creation is not optional.\nIf db_session is missing, initialization fails.",
            "methods": [
              "__init__",
              "process_anomaly"
            ],
            "line": 1069
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "schemas.loop_events",
            "names": [
              "LoopEvent",
              "LoopStage",
              "PatternMatchResult",
              "PolicyRule",
              "RecoverySuggestion",
              "RoutingAdjustment",
              "ensure_json_serializable"
            ],
            "is_relative": true,
            "line": 41
          },
          {
            "module": "app.hoc.cus.general.L4_runtime.engines",
            "names": [
              "create_incident_from_cost_anomaly_sync"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "protocol.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/credentials/protocol.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 63,
        "module_docstring": "CredentialService Protocol \u2014 Canonical Definition\n\nThis is the CANONICAL and ONLY authoritative definition of the\nCredentialService protocol used by connector services.\n\nHistory:\n    Previously duplicated in:\n    - http_connector.py (lines 106-112)\n    - mcp_connector.py (lines 97-103)\n    - sql_gateway.py (lines 121-127)\n\n    Consolidated here per INT-DUP-002 quarantine resolution.",
        "functions": [],
        "classes": [
          {
            "name": "CredentialService",
            "docstring": "Protocol for credential service.\n\nDefines the contract for services that retrieve credentials\nfrom a vault or other secure storage. Connector services\ndepend on this protocol for authentication.\n\nImplementations:\n    - CusCredentialService (vault/engines/cus_credential_service.py)\n    - Any vault adapter that provides credential retrieval",
            "methods": [
              "get"
            ],
            "line": 40
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Protocol",
              "runtime_checkable"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "types",
            "names": [
              "Credential"
            ],
            "is_relative": true,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_health_engine.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/cus_health_engine.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 534,
        "module_docstring": "Customer Health Engine\n\nPURPOSE:\n    Provider reachability and credential validation for customer LLM integrations.\n    Performs lightweight health checks without consuming significant quota.\n\nRESPONSIBILITIES:\n    - Test provider connectivity\n    - Validate credentials are still valid\n    - Measure response latency\n    - Update health state in integrations\n\nHEALTH STATES:\n    - UNKNOWN: Never checked or no recent data\n    - HEALTHY: Last check successful\n    - DEGRADED: Slow or partial responses\n    - UNHEALTHY: Check failed\n\nCHECK STRATEGY:\n    - OpenAI: GET /models endpoint (lightweight, no tokens)\n    - Anthropic: POST /messages with max_tokens=1 (minimal cost)\n    - Google: GET /models endpoint\n    - Others: Provider-specific lightweight calls\n\nRATE LIMITING:\n    - Maximum one check per integration per minute\n    - Batch checks spread over time\n    - Failed integrations checked less frequently",
        "functions": [],
        "classes": [
          {
            "name": "CusHealthService",
            "docstring": "Service for health checking customer LLM integrations.\n\nPhase 4: Provider reachability and credential validation.",
            "methods": [
              "__init__",
              "check_health",
              "_perform_health_check",
              "check_all_integrations",
              "get_health_summary",
              "_calculate_overall_health"
            ],
            "line": 69
          }
        ],
        "imports": [
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.db",
            "names": [
              "get_engine"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "app.models.cus_models",
            "names": [
              "CusHealthState",
              "CusIntegration"
            ],
            "is_relative": false,
            "line": 63
          },
          {
            "module": "app.hoc.cus.general.L5_engines.cus_credential_service",
            "names": [
              "CusCredentialService"
            ],
            "is_relative": false,
            "line": 64
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_integration_service.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/cus_integration_service.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 68,
        "module_docstring": "CusIntegrationService (SWEEP-03 Batch 3)\n\nPURPOSE:\n    Business logic for Customer Integration domain (LLM BYOK, SDK, RAG).\n    Called by integrations_facade.py.\n\nINTERFACE:\n    - CusIntegrationService (alias for CusIntegrationEngine)\n    - get_cus_integration_service() -> CusIntegrationService\n\nIMPLEMENTATION NOTES:\n    Re-exports from existing cus_integration_engine.py which is already\n    properly structured with L4/L6 separation.",
        "functions": [
          {
            "name": "get_cus_integration_service",
            "signature": "() -> CusIntegrationService",
            "docstring": "Get the CusIntegrationService instance.\n\nReturns:\n    CusIntegrationService instance",
            "is_async": false,
            "line": 51
          }
        ],
        "classes": [],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING"
            ],
            "is_relative": false,
            "line": 28
          },
          {
            "module": "app.services.cus_integration_engine",
            "names": [
              "CusIntegrationEngine",
              "CusIntegrationService",
              "DeleteResult",
              "EnableResult",
              "HealthCheckResult",
              "get_cus_integration_engine"
            ],
            "is_relative": false,
            "line": 37
          }
        ],
        "constants": [],
        "all_exports": [
          "CusIntegrationService",
          "CusIntegrationEngine",
          "EnableResult",
          "DeleteResult",
          "HealthCheckResult",
          "get_cus_integration_service",
          "get_cus_integration_engine"
        ]
      },
      {
        "file_name": "datasources_facade.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/datasources_facade.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 451,
        "module_docstring": "DataSources Facade (L4 Domain Logic)\n\nThis facade provides the external interface for data source operations.\nAll data source APIs MUST use this facade instead of directly importing\ninternal datasource modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes data source management\n- Provides unified access to source configuration\n- Single point for audit emission\n\nL2 API Routes (GAP-113):\n- POST /api/v1/datasources (create source)\n- GET /api/v1/datasources (list sources)\n- GET /api/v1/datasources/{id} (get source)\n- PUT /api/v1/datasources/{id} (update source)\n- DELETE /api/v1/datasources/{id} (delete source)\n- POST /api/v1/datasources/{id}/test (test connection)\n- POST /api/v1/datasources/{id}/activate (activate source)\n- POST /api/v1/datasources/{id}/deactivate (deactivate source)\n- GET /api/v1/datasources/stats (statistics)\n\nUsage:\n    from app.services.datasources.facade import get_datasources_facade\n\n    facade = get_datasources_facade()\n\n    # Register data source\n    source = await facade.register_source(\n        tenant_id=\"...\",\n        name=\"Production DB\",\n        source_type=\"database\",\n        config={...},\n    )",
        "functions": [
          {
            "name": "get_datasources_facade",
            "signature": "() -> DataSourcesFacade",
            "docstring": "Get the data sources facade instance.\n\nThis is the recommended way to access data source operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    DataSourcesFacade instance",
            "is_async": false,
            "line": 438
          }
        ],
        "classes": [
          {
            "name": "TestConnectionResult",
            "docstring": "Result of testing a data source connection.",
            "methods": [
              "to_dict"
            ],
            "line": 75
          },
          {
            "name": "DataSourcesFacade",
            "docstring": "Facade for data source operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\ndata source services.\n\nLayer: L4 (Domain Logic)\nCallers: datasources.py (L2), aos_sdk",
            "methods": [
              "__init__",
              "registry",
              "register_source",
              "list_sources",
              "get_source",
              "update_source",
              "delete_source",
              "test_connection",
              "activate_source",
              "deactivate_source",
              "get_statistics"
            ],
            "line": 92
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.integrations.L5_schemas.datasource_model",
            "names": [
              "CustomerDataSource",
              "DataSourceConfig",
              "DataSourceRegistry",
              "DataSourceStats",
              "DataSourceStatus",
              "DataSourceType",
              "get_datasource_registry"
            ],
            "is_relative": false,
            "line": 61
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "dispatcher.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/dispatcher.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 806,
        "module_docstring": "M25 Integration Dispatcher\n\nOrchestrates the feedback loop with:\n- Event-driven architecture (Redis pub/sub + PostgreSQL durability)\n- Failure state handling\n- Human checkpoint integration\n- Guardrail enforcement\n\nFROZEN: 2025-12-23\nDo NOT modify loop mechanics without explicit approval.",
        "functions": [],
        "classes": [
          {
            "name": "DispatcherConfig",
            "docstring": "Configuration for the integration dispatcher.",
            "methods": [
              "from_env"
            ],
            "line": 67
          },
          {
            "name": "IntegrationDispatcher",
            "docstring": "Central dispatcher for the M25 integration loop.\n\nResponsibilities:\n- Route events to appropriate bridge handlers\n- Persist events for durability\n- Publish events for real-time updates\n- Handle failures gracefully\n- Enforce guardrails\n- Create human checkpoints when needed",
            "methods": [
              "__init__",
              "register_handler",
              "is_bridge_enabled",
              "dispatch",
              "_check_db_idempotency",
              "_execute_handlers",
              "_check_human_checkpoint_needed",
              "resolve_checkpoint",
              "_get_or_create_loop_status",
              "_update_loop_status",
              "_trigger_next_stage",
              "_persist_event",
              "_persist_loop_status",
              "_persist_checkpoint",
              "_load_loop_status",
              "_load_checkpoint",
              "_publish_event",
              "_publish_checkpoint_needed",
              "get_loop_status",
              "get_pending_checkpoints",
              "retry_failed_stage",
              "revert_loop"
            ],
            "line": 121
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Callable",
              "Coroutine",
              "Optional"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "uuid",
            "names": [
              "uuid4"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "schemas.loop_events",
            "names": [
              "LOOP_MECHANICS_FROZEN_AT",
              "LOOP_MECHANICS_VERSION",
              "ConfidenceBand",
              "HumanCheckpoint",
              "HumanCheckpointType",
              "LoopEvent",
              "LoopFailureState",
              "LoopStage",
              "LoopStatus",
              "ensure_json_serializable"
            ],
            "is_relative": true,
            "line": 45
          },
          {
            "module": "schemas.loop_events",
            "names": [
              "PolicyMode"
            ],
            "is_relative": true,
            "line": 806
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "graduation_engine.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/graduation_engine.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 594,
        "module_docstring": "M25 Graduation Engine\n\nCRITICAL: This module ensures graduation is DERIVED, not DECLARED.\n\nGraduation is:\n- Computed from evidence (not manually set)\n- Re-evaluated periodically (not one-time)\n- Downgradable when evidence regresses\n- Separate from simulation state\n- Tied to real capability gates\n\n\"A badge you flip once and forget\" is worthless.\nGraduation must be continuously earned.",
        "functions": [],
        "classes": [
          {
            "name": "GraduationThresholds",
            "docstring": "Configurable thresholds for graduation gates.\n\nThese can be tightened as the system matures.",
            "methods": [],
            "line": 62
          },
          {
            "name": "GateEvidence",
            "docstring": "Evidence for a single gate - computed from database.",
            "methods": [],
            "line": 94
          },
          {
            "name": "GraduationEvidence",
            "docstring": "All evidence needed to compute graduation status.\n\nThis is a SNAPSHOT of database state - graduation is derived from this.",
            "methods": [],
            "line": 106
          },
          {
            "name": "GraduationLevel",
            "docstring": "Graduation levels - derived from evidence.",
            "methods": [],
            "line": 145
          },
          {
            "name": "ComputedGraduationStatus",
            "docstring": "Graduation status computed from evidence.\n\nThis is DERIVED - never set manually.",
            "methods": [
              "is_graduated",
              "is_degraded",
              "status_label",
              "to_api_response"
            ],
            "line": 156
          },
          {
            "name": "GraduationEngine",
            "docstring": "Computes graduation status from evidence.\n\nCRITICAL INVARIANTS:\n1. Graduation is derived, never manually set\n2. Graduation can degrade when evidence regresses\n3. Simulation state is separate from real graduation\n4. Re-evaluation happens periodically",
            "methods": [
              "__init__",
              "compute",
              "_evaluate_gate1",
              "_evaluate_gate2",
              "_evaluate_gate3",
              "_check_degradation"
            ],
            "line": 225
          },
          {
            "name": "CapabilityGates",
            "docstring": "Capabilities that are LOCKED until graduation passes specific gates.\n\nThis makes graduation meaningful, not decorative.",
            "methods": [
              "can_auto_apply_recovery",
              "can_auto_activate_policy",
              "can_full_auto_routing",
              "get_blocked_capabilities",
              "get_unlocked_capabilities"
            ],
            "line": 478
          },
          {
            "name": "SimulationState",
            "docstring": "Simulation state - SEPARATE from real graduation.\n\nSimulations are for demos only. They never affect real graduation.",
            "methods": [
              "is_demo_mode",
              "to_display"
            ],
            "line": 555
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "typing",
            "names": [
              "NamedTuple",
              "Optional"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "http_connector.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/http_connector.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 367,
        "module_docstring": "Module: http_connector\nPurpose: Machine-controlled HTTP connector (NOT LLM-controlled).\n\nKey Difference from HttpCallSkill:\n    - HttpCallSkill: LLM controls URL, headers, body (DANGEROUS)\n    - HttpConnectorService: Machine resolves URL from registry, LLM only provides action\n\nSecurity Model:\n    - Base URL: Machine-controlled (from connector config)\n    - Auth: Machine-controlled (from vault)\n    - Endpoints: Machine-controlled (action -> path mapping)\n    - Payload: LLM-controlled but validated against schema\n\nImports (Dependencies):\n    - None (credential service passed via constructor)\n\nExports (Provides):\n    - HttpConnectorService: Governed HTTP access\n    - HttpConnectorConfig: Configuration dataclass\n\nWiring Points:\n    - Called from: RetrievalMediator\n    - Registered in: ConnectorRegistry\n\nAcceptance Criteria:\n    - [x] AC-059-01: URL resolved from config, not LLM\n    - [x] AC-059-02: Auth from vault\n    - [x] AC-059-03: Method restrictions enforced\n    - [x] AC-059-04: Registered with connector registry\n    - [x] AC-059-05: Evidence emitted via mediator\n    - [x] AC-059-06: Tenant isolation (INV-003)\n    - [x] AC-059-07: Max response bytes enforced\n    - [x] AC-059-08: Max latency enforced\n    - [x] AC-059-09: Request rate limited",
        "functions": [],
        "classes": [
          {
            "name": "HttpMethod",
            "docstring": "Allowed HTTP methods.",
            "methods": [],
            "line": 76
          },
          {
            "name": "EndpointConfig",
            "docstring": "Configuration for a single endpoint.",
            "methods": [],
            "line": 86
          },
          {
            "name": "HttpConnectorConfig",
            "docstring": "Configuration for HTTP connector.",
            "methods": [],
            "line": 96
          },
          {
            "name": "HttpConnectorError",
            "docstring": "Error from HTTP connector.",
            "methods": [
              "__init__"
            ],
            "line": 119
          },
          {
            "name": "RateLimitExceededError",
            "docstring": "Rate limit exceeded.",
            "methods": [
              "__init__"
            ],
            "line": 127
          },
          {
            "name": "HttpConnectorService",
            "docstring": "Governed HTTP connector.\n\nMachine controls:\n- Base URL (from connector config)\n- Auth headers (from vault)\n- Allowed methods\n- Endpoint mapping (action -> URL path)\n\nLLM controls:\n- Action name (maps to endpoint)\n- Payload data (validated against schema)\n\nImplements Connector protocol for use with RetrievalMediator.",
            "methods": [
              "__init__",
              "id",
              "execute",
              "_resolve_endpoint",
              "_build_url",
              "_get_auth_headers",
              "_check_rate_limit",
              "_record_request"
            ],
            "line": 135
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.credentials",
            "names": [
              "Credential",
              "CredentialService"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_MAX_RESPONSE_BYTES",
            "line": 71
          },
          {
            "name": "DEFAULT_TIMEOUT_SECONDS",
            "line": 72
          },
          {
            "name": "DEFAULT_RATE_LIMIT_PER_MINUTE",
            "line": 73
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "iam_engine.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/iam_engine.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 440,
        "module_docstring": "IAM Engine (GAP-173)\n\nProvides unified IAM capabilities:\n- Identity resolution from multiple providers\n- Role and permission management\n- Access control decisions\n- Audit logging",
        "functions": [],
        "classes": [
          {
            "name": "IdentityProvider",
            "docstring": "Supported identity providers.",
            "methods": [],
            "line": 41
          },
          {
            "name": "ActorType",
            "docstring": "Types of actors in the system.",
            "methods": [],
            "line": 51
          },
          {
            "name": "Identity",
            "docstring": "Resolved identity from any provider.",
            "methods": [
              "has_role",
              "has_permission",
              "has_any_role",
              "has_all_roles",
              "to_dict"
            ],
            "line": 60
          },
          {
            "name": "AccessDecision",
            "docstring": "Result of an access control decision.",
            "methods": [
              "to_dict"
            ],
            "line": 122
          },
          {
            "name": "IAMService",
            "docstring": "IAM Service for identity and access management.\n\nFeatures:\n- Multi-provider identity resolution\n- Role-based access control (RBAC)\n- Permission checking\n- Access decision auditing",
            "methods": [
              "__init__",
              "_setup_default_roles",
              "resolve_identity",
              "_resolve_clerk_identity",
              "_resolve_api_key_identity",
              "_create_system_identity",
              "_expand_role_permissions",
              "check_access",
              "grant_role",
              "revoke_role",
              "define_role",
              "define_resource_permissions",
              "get_access_log",
              "list_roles",
              "list_resources"
            ],
            "line": 152
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Set"
            ],
            "is_relative": false,
            "line": 36
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "integrations_facade.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/integrations_facade.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 491,
        "module_docstring": "Integrations Domain Facade (L4)\n\nUnified facade for LLM integration management (BYOK - Bring Your Own Key).\n\nProvides:\n- CRUD: list, get, create, update, delete integrations\n- Lifecycle: enable, disable\n- Health: get health status, test credentials\n- Limits: get usage vs limits\n\nThis facade wraps the CusIntegrationService and provides dataclass result types\nfor consistency with other domain facades.",
        "functions": [
          {
            "name": "get_integrations_facade",
            "signature": "() -> IntegrationsFacade",
            "docstring": "Get the singleton IntegrationsFacade instance.",
            "is_async": false,
            "line": 470
          }
        ],
        "classes": [
          {
            "name": "IntegrationSummaryResult",
            "docstring": "Integration summary for list view.",
            "methods": [],
            "line": 50
          },
          {
            "name": "IntegrationListResult",
            "docstring": "Integration list response.",
            "methods": [],
            "line": 63
          },
          {
            "name": "IntegrationDetailResult",
            "docstring": "Integration detail response.",
            "methods": [],
            "line": 71
          },
          {
            "name": "IntegrationLifecycleResult",
            "docstring": "Result of enable/disable operation.",
            "methods": [],
            "line": 92
          },
          {
            "name": "IntegrationDeleteResult",
            "docstring": "Result of delete operation.",
            "methods": [],
            "line": 101
          },
          {
            "name": "HealthCheckResult",
            "docstring": "Health check result.",
            "methods": [],
            "line": 109
          },
          {
            "name": "HealthStatusResult",
            "docstring": "Cached health status.",
            "methods": [],
            "line": 120
          },
          {
            "name": "LimitsStatusResult",
            "docstring": "Usage vs limits status.",
            "methods": [],
            "line": 130
          },
          {
            "name": "IntegrationsFacade",
            "docstring": "Unified facade for LLM integration management.\n\nProvides:\n- CRUD: list, get, create, update, delete integrations\n- Lifecycle: enable, disable\n- Health: get health status, test credentials\n- Limits: get usage vs limits\n\nAll operations are tenant-scoped for isolation.",
            "methods": [
              "__init__",
              "list_integrations",
              "get_integration",
              "create_integration",
              "update_integration",
              "delete_integration",
              "enable_integration",
              "disable_integration",
              "get_health_status",
              "test_credentials",
              "get_limits_status"
            ],
            "line": 152
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.cus_integration_service",
            "names": [
              "CusIntegrationService"
            ],
            "is_relative": false,
            "line": 41
          }
        ],
        "constants": [],
        "all_exports": [
          "IntegrationsFacade",
          "get_integrations_facade",
          "IntegrationSummaryResult",
          "IntegrationListResult",
          "IntegrationDetailResult",
          "IntegrationLifecycleResult",
          "IntegrationDeleteResult",
          "HealthCheckResult",
          "HealthStatusResult",
          "LimitsStatusResult"
        ]
      },
      {
        "file_name": "mcp_connector.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/mcp_connector.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 423,
        "module_docstring": "Module: mcp_connector\nPurpose: Model Context Protocol (MCP) tool invocation with governance.\n\nMCP Spec: Tools are invoked via standardized JSON-RPC protocol.\nThis connector governs which tools can be called and with what parameters.\n\nSecurity Model:\n    - Tool allowlist: Machine-controlled\n    - Server URL: Machine-controlled\n    - Authentication: Machine-controlled (from vault)\n    - Parameter validation: Against JSON Schema\n\nImports (Dependencies):\n    - None (credential service passed via constructor)\n\nExports (Provides):\n    - McpConnectorService: Governed MCP tool invocation\n    - McpConnectorConfig: Configuration dataclass\n    - McpToolDefinition: Tool definition dataclass\n\nWiring Points:\n    - Called from: RetrievalMediator\n    - Registered in: ConnectorRegistry\n\nAcceptance Criteria:\n    - [x] AC-063-01: Tool allowlist enforced\n    - [x] AC-063-02: Parameters validated against schema\n    - [x] AC-063-03: MCP protocol followed\n    - [x] AC-063-04: Credentials from vault\n    - [x] AC-063-05: Evidence via mediator\n    - [x] AC-063-06: Tenant isolation (INV-003)\n    - [x] AC-063-07: Max response bytes enforced\n    - [x] AC-063-08: Tool timeout enforced\n    - [x] AC-063-09: Tool execution rate limited",
        "functions": [],
        "classes": [
          {
            "name": "McpToolDefinition",
            "docstring": "Definition of an MCP tool.",
            "methods": [],
            "line": 77
          },
          {
            "name": "McpConnectorConfig",
            "docstring": "Configuration for MCP connector.",
            "methods": [],
            "line": 89
          },
          {
            "name": "McpConnectorError",
            "docstring": "Error from MCP connector.",
            "methods": [
              "__init__"
            ],
            "line": 110
          },
          {
            "name": "McpApprovalRequiredError",
            "docstring": "Tool requires manual approval.",
            "methods": [
              "__init__"
            ],
            "line": 118
          },
          {
            "name": "McpRateLimitExceededError",
            "docstring": "Rate limit exceeded.",
            "methods": [
              "__init__"
            ],
            "line": 126
          },
          {
            "name": "McpSchemaValidationError",
            "docstring": "Schema validation failed.",
            "methods": [
              "__init__"
            ],
            "line": 134
          },
          {
            "name": "McpConnectorService",
            "docstring": "Governed MCP tool invocation.\n\nMachine controls:\n- Tool allowlist\n- Server URL\n- Authentication\n- Parameter validation against schema\n- Rate limiting\n\nLLM controls:\n- Tool selection (from allowlist)\n- Parameter values (validated against JSON Schema)\n\nImplements Connector protocol for use with RetrievalMediator.",
            "methods": [
              "__init__",
              "id",
              "execute",
              "_resolve_tool",
              "_validate_against_schema",
              "_build_mcp_request",
              "_get_api_key",
              "_check_rate_limit",
              "_record_request",
              "get_available_tools"
            ],
            "line": 142
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.credentials",
            "names": [
              "Credential",
              "CredentialService"
            ],
            "is_relative": false,
            "line": 62
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_MAX_RESPONSE_BYTES",
            "line": 70
          },
          {
            "name": "DEFAULT_TIMEOUT_SECONDS",
            "line": 71
          },
          {
            "name": "DEFAULT_RATE_LIMIT_PER_MINUTE",
            "line": 72
          },
          {
            "name": "DEFAULT_MAX_RETRIES",
            "line": 73
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "prevention_contract.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/prevention_contract.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 201,
        "module_docstring": "M25 Prevention Contract Enforcement\n\n# =============================================================================\n# M25_FROZEN - DO NOT MODIFY\n# =============================================================================\n# Any changes here require explicit M25 reopen approval.\n# Changes invalidate all prior graduation evidence.\n# See PIN-140 for freeze rationale.\n# PREVENTION_CONTRACT_VERSION = \"1.0.0\"\n# =============================================================================\n\nFrom PIN-136, prevention records can ONLY be written when:\n1. Same pattern signature matches\n2. Same tenant\n3. Same feature path\n4. Policy is ACTIVE (not SHADOW, not PENDING)\n5. No incident is created (blocked before INSERT)\n6. Prevention record is written (append-only, immutable)\n\nThis module enforces these rules programmatically.",
        "functions": [
          {
            "name": "validate_prevention_candidate",
            "signature": "(candidate: PreventionCandidate) -> None",
            "docstring": "Validate that a prevention candidate satisfies the contract.\n\nRaises PreventionContractViolation if any rule is violated.\n\nRules (from PIN-136):\n1. Policy must be ACTIVE\n2. No incident created\n3. Pattern signature matches\n4. Same tenant\n5. Prevention records are append-only (handled at DB level)",
            "is_async": false,
            "line": 85
          },
          {
            "name": "assert_prevention_immutable",
            "signature": "(record_id: str, existing_record: dict[str, Any]) -> None",
            "docstring": "Assert that a prevention record has not been modified.\n\nPrevention records are append-only and immutable.\nThis should be called before any UPDATE attempt.",
            "is_async": false,
            "line": 142
          },
          {
            "name": "assert_no_deletion",
            "signature": "(record_id: str) -> None",
            "docstring": "Assert that a prevention record cannot be deleted.\n\nPrevention records are append-only and immutable.",
            "is_async": false,
            "line": 154
          },
          {
            "name": "validate_prevention_for_graduation",
            "signature": "(prevention_record: dict[str, Any], policy_activated_at: datetime) -> bool",
            "docstring": "Validate that a prevention record counts toward graduation.\n\nFor Gate 1 (Prevention) to pass:\n- Prevention must be real (is_simulated = False)\n- Prevention must be after policy activation\n- Policy must have been active at time of prevention",
            "is_async": false,
            "line": 170
          }
        ],
        "classes": [
          {
            "name": "PreventionContractViolation",
            "docstring": "Raised when a prevention record would violate the contract.",
            "methods": [
              "__init__"
            ],
            "line": 55
          },
          {
            "name": "PreventionCandidate",
            "docstring": "Candidate for prevention record creation.\n\nMust pass all contract checks before writing to prevention_records.",
            "methods": [],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "Any"
            ],
            "is_relative": false,
            "line": 46
          }
        ],
        "constants": [
          {
            "name": "PREVENTION_CONTRACT_VERSION",
            "line": 51
          },
          {
            "name": "PREVENTION_CONTRACT_FROZEN_AT",
            "line": 52
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "sql_gateway.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/sql_gateway.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 464,
        "module_docstring": "Module: sql_gateway\nPurpose: Template-based SQL queries (NO raw SQL from LLM).\n\nKey Difference from PostgresQuerySkill:\n    - PostgresQuerySkill: LLM provides SQL string (DANGEROUS)\n    - SqlGatewayService: LLM selects template ID, machine fills parameters\n\nSecurity Invariant: LLM NEVER sees or constructs SQL.\nThe SQL comes from pre-registered, audited templates.\n\nImports (Dependencies):\n    - None (credential service passed via constructor)\n\nExports (Provides):\n    - SqlGatewayService: Governed SQL access\n    - SqlGatewayConfig: Configuration dataclass\n    - QueryTemplate: SQL template definition\n\nWiring Points:\n    - Called from: RetrievalMediator\n    - Registered in: ConnectorRegistry\n\nAcceptance Criteria:\n    - [x] AC-060-01: No raw SQL from LLM\n    - [x] AC-060-02: Template ID required\n    - [x] AC-060-03: Parameters validated\n    - [x] AC-060-04: Read-only enforced\n    - [x] AC-060-05: SQL injection prevented\n    - [x] AC-060-06: Max rows enforced\n    - [x] AC-060-07: Tenant isolation (INV-003)\n    - [x] AC-060-08: Max result bytes enforced\n    - [x] AC-060-09: Query timeout enforced",
        "functions": [],
        "classes": [
          {
            "name": "ParameterType",
            "docstring": "Supported parameter types for validation.",
            "methods": [],
            "line": 74
          },
          {
            "name": "ParameterSpec",
            "docstring": "Specification for a query parameter.",
            "methods": [],
            "line": 88
          },
          {
            "name": "QueryTemplate",
            "docstring": "Definition of a SQL query template.",
            "methods": [],
            "line": 101
          },
          {
            "name": "SqlGatewayConfig",
            "docstring": "Configuration for SQL gateway.",
            "methods": [],
            "line": 114
          },
          {
            "name": "SqlGatewayError",
            "docstring": "Error from SQL gateway.",
            "methods": [],
            "line": 134
          },
          {
            "name": "SqlInjectionAttemptError",
            "docstring": "Potential SQL injection detected.",
            "methods": [],
            "line": 139
          },
          {
            "name": "SqlGatewayService",
            "docstring": "Governed SQL gateway.\n\nMachine controls:\n- SQL query templates (pre-registered)\n- Parameter validation\n- Connection credentials\n- Read-only enforcement\n- Row limits\n\nLLM controls:\n- Template selection (by ID from allowlist)\n- Parameter values (validated against spec)\n\nImplements Connector protocol for use with RetrievalMediator.",
            "methods": [
              "__init__",
              "id",
              "execute",
              "_resolve_template",
              "_validate_parameters",
              "_coerce_parameter",
              "_check_sql_injection",
              "_get_connection_string"
            ],
            "line": 144
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 55
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 56
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "app.hoc.cus.integrations.L5_engines.credentials",
            "names": [
              "Credential",
              "CredentialService"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "asyncio",
            "names": [
              "asyncio"
            ],
            "is_relative": false,
            "line": 464
          }
        ],
        "constants": [
          {
            "name": "DEFAULT_MAX_ROWS",
            "line": 69
          },
          {
            "name": "DEFAULT_MAX_RESULT_BYTES",
            "line": 70
          },
          {
            "name": "DEFAULT_TIMEOUT_SECONDS",
            "line": 71
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "types.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_engines/types.py",
        "layer": "L5_engines",
        "domain": "integrations",
        "lines": 56,
        "module_docstring": "Credential Type \u2014 Canonical Definition\n\nThis is the CANONICAL and ONLY authoritative definition of the\nCredential dataclass used by connector services.\n\nHistory:\n    Previously duplicated in:\n    - http_connector.py (lines 99-103)\n    - mcp_connector.py (lines 90-94)\n    - sql_gateway.py (lines 114-118)\n\n    Consolidated here per INT-DUP-001 quarantine resolution.",
        "functions": [],
        "classes": [
          {
            "name": "Credential",
            "docstring": "Credential from vault.\n\nA simple container for credential values retrieved from\nthe credential service. Used by connector services to\nauthenticate with external systems.\n\nAttributes:\n    value: The credential value (e.g., API key, token)\n    expires_at: Optional expiration timestamp",
            "methods": [],
            "line": 42
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [
      {
        "file_name": "audit_schemas.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/audit_schemas.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 59,
        "module_docstring": "M25 Audit Schemas\n\nDataclasses for audit records in the integration bridges.\n\nFROZEN: 2025-12-23\nDo NOT modify without explicit approval.",
        "functions": [],
        "classes": [
          {
            "name": "PolicyActivationAudit",
            "docstring": "Audit record for policy activation.\n\nRequired for:\n- Rollback\n- Blame tracking\n- Trust verification",
            "methods": [
              "to_dict"
            ],
            "line": 28
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 21
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 23
          },
          {
            "module": "datetime",
            "names": [
              "datetime"
            ],
            "is_relative": false,
            "line": 24
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "cus_schemas.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/cus_schemas.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 498,
        "module_docstring": "Customer Integrations API Schemas\n\nPURPOSE:\n    Pydantic request/response models for the Customer Integrations API surface.\n    These schemas define the contract between SDK/clients and the backend.\n\nSCHEMAS:\n    Request Schemas:\n    - CusIntegrationCreate: Create a new integration\n    - CusIntegrationUpdate: Update integration settings\n    - CusLLMUsageIngest: Telemetry ingestion from SDK\n\n    Response Schemas:\n    - CusIntegrationResponse: Full integration details\n    - CusIntegrationSummary: List view integration\n    - CusUsageSummary: Aggregated usage statistics\n    - CusLimitsStatus: Current usage vs limits\n\nVALIDATION:\n    - All credential_ref values are validated as non-raw (no bare API keys)\n    - Provider types are constrained to supported enum values\n    - Token/cost values must be non-negative",
        "functions": [],
        "classes": [
          {
            "name": "CusIntegrationCreate",
            "docstring": "Request schema for creating a new integration.\n\nPURPOSE:\n    Captures all required information to create a customer LLM integration.\n    Credential handling is secure - we never accept raw API keys directly.\n\nVALIDATION:\n    - name is required, 1-255 chars\n    - provider_type must be a supported provider\n    - credential_ref must not look like a raw API key",
            "methods": [
              "validate_not_raw_key"
            ],
            "line": 55
          },
          {
            "name": "CusIntegrationUpdate",
            "docstring": "Request schema for updating an integration.\n\nPURPOSE:\n    Partial update - only provided fields are changed.\n    Status changes should use dedicated enable/disable endpoints.",
            "methods": [
              "validate_not_raw_key"
            ],
            "line": 133
          },
          {
            "name": "CusLLMUsageIngest",
            "docstring": "Request schema for SDK telemetry ingestion.\n\nPURPOSE:\n    SDK sends telemetry for each LLM call. This schema validates\n    the payload before persisting to cus_llm_usage.\n\nSEMANTIC:\n    This is DATA PLANE ingestion - append-only facts about what happened.\n    call_id provides idempotency for at-least-once delivery.",
            "methods": [],
            "line": 192
          },
          {
            "name": "CusLLMUsageBatchIngest",
            "docstring": "Request schema for batch telemetry ingestion.\n\nPURPOSE:\n    SDK may buffer and send multiple telemetry records at once\n    for efficiency. Max batch size is 100.",
            "methods": [],
            "line": 273
          },
          {
            "name": "CusIntegrationResponse",
            "docstring": "Full integration details response.\n\nPURPOSE:\n    Complete integration information including health state\n    and current limits. Used for detail view.",
            "methods": [],
            "line": 294
          },
          {
            "name": "CusIntegrationSummary",
            "docstring": "Integration summary for list views.\n\nPURPOSE:\n    Lightweight representation for list endpoints.\n    Excludes detailed config and health messages.",
            "methods": [],
            "line": 330
          },
          {
            "name": "CusLimitsStatus",
            "docstring": "Current usage vs configured limits.\n\nPURPOSE:\n    Dashboard view showing how much of each limit has been used.\n    Enables proactive budget and capacity management.",
            "methods": [],
            "line": 350
          },
          {
            "name": "CusUsageSummary",
            "docstring": "Aggregated usage statistics.\n\nPURPOSE:\n    Summary view of usage across integrations.\n    Used for dashboard totals and reports.",
            "methods": [],
            "line": 396
          },
          {
            "name": "CusIntegrationUsage",
            "docstring": "Usage for a single integration within a period.\n\nPURPOSE:\n    Per-integration breakdown within CusUsageSummary.",
            "methods": [],
            "line": 428
          },
          {
            "name": "CusLLMUsageResponse",
            "docstring": "Individual usage record response.\n\nPURPOSE:\n    Detailed view of a single LLM call for audit/debugging.",
            "methods": [],
            "line": 445
          },
          {
            "name": "CusHealthCheckResponse",
            "docstring": "Response from integration health check.\n\nPURPOSE:\n    Result of testing integration connectivity and credentials.",
            "methods": [],
            "line": 480
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "date",
              "datetime"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.models.cus_models",
            "names": [
              "CusHealthState",
              "CusIntegrationStatus",
              "CusPolicyResult",
              "CusProviderType"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "datasource_model.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/datasource_model.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 582,
        "module_docstring": "CustomerDataSource - Customer data source models and registry.\n\nProvides data source abstraction for:\n- Database connections\n- File storage\n- API endpoints\n- Vector stores\n- Custom connectors",
        "functions": [
          {
            "name": "get_datasource_registry",
            "signature": "() -> DataSourceRegistry",
            "docstring": "Get the singleton registry instance.",
            "is_async": false,
            "line": 537
          },
          {
            "name": "_reset_registry",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 545
          },
          {
            "name": "create_datasource",
            "signature": "(tenant_id: str, name: str, source_type: DataSourceType, config: Optional[DataSourceConfig] = None) -> CustomerDataSource",
            "docstring": "Create a new data source using the singleton registry.",
            "is_async": false,
            "line": 554
          },
          {
            "name": "get_datasource",
            "signature": "(source_id: str) -> Optional[CustomerDataSource]",
            "docstring": "Get a data source by ID using the singleton registry.",
            "is_async": false,
            "line": 570
          },
          {
            "name": "list_datasources",
            "signature": "(tenant_id: Optional[str] = None, source_type: Optional[DataSourceType] = None) -> list[CustomerDataSource]",
            "docstring": "List data sources using the singleton registry.",
            "is_async": false,
            "line": 576
          }
        ],
        "classes": [
          {
            "name": "DataSourceType",
            "docstring": "Types of data sources.",
            "methods": [],
            "line": 22
          },
          {
            "name": "DataSourceStatus",
            "docstring": "Status of a data source.",
            "methods": [],
            "line": 34
          },
          {
            "name": "DataSourceConfig",
            "docstring": "Configuration for a data source.",
            "methods": [
              "to_dict",
              "get_connection_url"
            ],
            "line": 46
          },
          {
            "name": "CustomerDataSource",
            "docstring": "Representation of a customer data source.",
            "methods": [
              "record_connection",
              "record_error",
              "activate",
              "deactivate",
              "deprecate",
              "update_config",
              "add_tag",
              "remove_tag",
              "grant_access",
              "revoke_access",
              "has_access",
              "to_dict"
            ],
            "line": 126
          },
          {
            "name": "DataSourceError",
            "docstring": "Exception for data source errors.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 257
          },
          {
            "name": "DataSourceStats",
            "docstring": "Statistics for data sources.",
            "methods": [
              "to_dict"
            ],
            "line": 281
          },
          {
            "name": "DataSourceRegistry",
            "docstring": "Registry for managing customer data sources.\n\nFeatures:\n- CRUD operations for data sources\n- Status management\n- Tenant isolation\n- Access control",
            "methods": [
              "__init__",
              "register",
              "get",
              "get_by_name",
              "list",
              "update",
              "activate",
              "deactivate",
              "delete",
              "get_statistics",
              "clear_tenant",
              "reset"
            ],
            "line": 311
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 15
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 16
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 17
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 18
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 19
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "loop_events.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_schemas/loop_events.py",
        "layer": "L5_schemas",
        "domain": "integrations",
        "lines": 968,
        "module_docstring": "M25 Integration Loop Events\n\n# =============================================================================\n# M25_FROZEN - DO NOT MODIFY\n# =============================================================================\n# Any changes here require explicit M25 reopen approval.\n# Changes invalidate all prior graduation evidence.\n# See PIN-140 for freeze rationale.\n# =============================================================================\n\nEnhanced with:\n- Confidence bands (strong/weak/novel) instead of binary matching\n- Loop failure states for unhappy paths\n- Policy shadow mode support\n- Human checkpoint controls\n- Routing guardrails\n\nFROZEN: 2025-12-23\nGRADUATION_RULES_VERSION = \"1.0.0\"",
        "functions": [
          {
            "name": "ensure_json_serializable",
            "signature": "(obj: Any, path: str = 'root') -> Any",
            "docstring": "Guard function to ensure all objects stored in details are JSON-serializable.\n\nRaises TypeError with clear path if non-serializable object found.",
            "is_async": false,
            "line": 133
          }
        ],
        "classes": [
          {
            "name": "ConfidenceCalculator",
            "docstring": "Centralized confidence calculation.\n\nFROZEN: All confidence logic must go through this class.\nVersion is logged with every confidence value for audit.",
            "methods": [
              "calculate_recovery_confidence",
              "should_auto_apply",
              "get_confirmation_level"
            ],
            "line": 55
          },
          {
            "name": "ConfidenceBand",
            "docstring": "Confidence classification for pattern matching.\n\n- STRONG_MATCH: High confidence (>0.85) - Safe for auto-apply\n- WEAK_MATCH: Medium confidence (0.6-0.85) - Requires review\n- NOVEL: Low confidence (<0.6) - New pattern, needs investigation",
            "methods": [
              "from_confidence",
              "allows_auto_apply",
              "requires_human_review"
            ],
            "line": 166
          },
          {
            "name": "LoopStage",
            "docstring": "Stages in the integration feedback loop.",
            "methods": [],
            "line": 205
          },
          {
            "name": "LoopFailureState",
            "docstring": "Explicit failure states for when the loop doesn't complete.\n\nCritical for debugging and trust - the unhappy path matters more\nthan the happy path.",
            "methods": [],
            "line": 216
          },
          {
            "name": "PolicyMode",
            "docstring": "Policy activation modes for safety.\n\nShadow mode allows observation without enforcement.",
            "methods": [],
            "line": 238
          },
          {
            "name": "HumanCheckpointType",
            "docstring": "Types of human intervention points.",
            "methods": [],
            "line": 251
          },
          {
            "name": "LoopEvent",
            "docstring": "Base event for integration loop.\n\nAll events flow through the dispatcher and are persisted for durability.",
            "methods": [
              "create",
              "is_success",
              "is_blocked",
              "to_dict"
            ],
            "line": 267
          },
          {
            "name": "PatternMatchResult",
            "docstring": "Result of Bridge 1: Incident \u2192 Failure Catalog.\n\nEnhanced with confidence bands instead of binary matching.",
            "methods": [
              "from_match",
              "no_match",
              "should_auto_proceed",
              "to_dict"
            ],
            "line": 342
          },
          {
            "name": "RecoverySuggestion",
            "docstring": "Result of Bridge 2: Pattern \u2192 Recovery.\n\nEnhanced with template vs generated distinction and confidence scoring.",
            "methods": [
              "create",
              "none_available",
              "add_confirmation",
              "to_dict"
            ],
            "line": 415
          },
          {
            "name": "PolicyRule",
            "docstring": "Result of Bridge 3: Recovery \u2192 Policy.\n\nEnhanced with:\n- Shadow mode for safe observation\n- Confirmation requirements\n- Policy regret tracking",
            "methods": [
              "create",
              "record_shadow_evaluation",
              "add_confirmation",
              "record_regret",
              "shadow_block_rate",
              "to_dict"
            ],
            "line": 509
          },
          {
            "name": "RoutingAdjustment",
            "docstring": "Result of Bridge 4: Policy \u2192 CARE Routing.\n\nEnhanced with guardrails:\n- Max delta per adjustment\n- Decay window\n- Rollback on KPI regression",
            "methods": [
              "create",
              "check_kpi_regression",
              "rollback",
              "effective_magnitude",
              "to_dict"
            ],
            "line": 636
          },
          {
            "name": "HumanCheckpoint",
            "docstring": "Human intervention point in the loop.\n\nSupports: approve, simulate, revert actions.",
            "methods": [
              "create",
              "resolve",
              "is_pending"
            ],
            "line": 771
          },
          {
            "name": "LoopStatus",
            "docstring": "Complete status of an integration loop instance.\n\nUsed for console display and debugging.",
            "methods": [
              "completion_pct",
              "to_console_display",
              "_generate_narrative",
              "to_dict"
            ],
            "line": 835
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Literal",
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          }
        ],
        "constants": [
          {
            "name": "LOOP_MECHANICS_VERSION",
            "line": 46
          },
          {
            "name": "LOOP_MECHANICS_FROZEN_AT",
            "line": 47
          }
        ],
        "all_exports": null
      }
    ],
    "l5_other": [
      {
        "file_name": "channel_engine.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_notifications/engines/channel_engine.py",
        "layer": "L5_other",
        "domain": "integrations",
        "lines": 1102,
        "module_docstring": "Module: channel_engine\nPurpose: Configurable notification channels for alerts and events.\n\nGAP-017: Notify channels must be configurable per tenant/policy.\nThis service provides:\n    - Channel configuration (enable/disable per channel type)\n    - Channel validation (test connectivity)\n    - Delivery tracking (success/failure metrics)\n    - Retry logic for failed deliveries\n\nExports:\n    - NotifyChannel: Enum of available channels\n    - NotifyEventType: Enum of event types\n    - NotifyChannelConfig: Channel configuration\n    - NotifyChannelService: Main service class\n    - NotifyDeliveryResult: Delivery result tracking\n    - NotifyChannelError: Error for channel failures\n    - Helper functions for quick access",
        "functions": [
          {
            "name": "get_notify_service",
            "signature": "() -> NotifyChannelService",
            "docstring": "Get or create the notification service singleton.",
            "is_async": false,
            "line": 1032
          },
          {
            "name": "_reset_notify_service",
            "signature": "() -> None",
            "docstring": "Reset the notification service (for testing).",
            "is_async": false,
            "line": 1040
          },
          {
            "name": "get_channel_config",
            "signature": "(tenant_id: str, channel: NotifyChannel) -> Optional[NotifyChannelConfig]",
            "docstring": "Quick helper to get channel configuration.\n\nArgs:\n    tenant_id: Tenant identifier\n    channel: Channel type\n\nReturns:\n    NotifyChannelConfig or None",
            "is_async": false,
            "line": 1049
          },
          {
            "name": "send_notification",
            "signature": "(tenant_id: str, event_type: NotifyEventType, payload: Dict[str, Any], channels: Optional[List[NotifyChannel]] = None) -> List[NotifyDeliveryResult]",
            "docstring": "Quick helper to send notification.\n\nArgs:\n    tenant_id: Tenant identifier\n    event_type: Type of event\n    payload: Notification payload\n    channels: Optional specific channels\n\nReturns:\n    List of delivery results",
            "is_async": true,
            "line": 1067
          },
          {
            "name": "check_channel_health",
            "signature": "(tenant_id: str) -> Dict[NotifyChannel, Dict[str, Any]]",
            "docstring": "Quick helper to check channel health.\n\nArgs:\n    tenant_id: Tenant identifier\n\nReturns:\n    Dictionary of channel health status",
            "is_async": true,
            "line": 1089
          }
        ],
        "classes": [
          {
            "name": "NotifyChannel",
            "docstring": "Available notification channels.",
            "methods": [],
            "line": 49
          },
          {
            "name": "NotifyEventType",
            "docstring": "Types of events that can trigger notifications.",
            "methods": [],
            "line": 60
          },
          {
            "name": "NotifyChannelStatus",
            "docstring": "Status of a notification channel.",
            "methods": [],
            "line": 75
          },
          {
            "name": "NotifyChannelError",
            "docstring": "Raised when notification channel operation fails.\n\nThis error indicates that a notification could not be sent\nthrough the configured channel.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 84
          },
          {
            "name": "NotifyDeliveryResult",
            "docstring": "Result of a notification delivery attempt.",
            "methods": [
              "to_dict"
            ],
            "line": 116
          },
          {
            "name": "NotifyChannelConfig",
            "docstring": "Configuration for a notification channel.",
            "methods": [
              "is_event_enabled",
              "is_configured",
              "record_success",
              "record_failure",
              "to_dict"
            ],
            "line": 145
          },
          {
            "name": "NotifyChannelConfigResponse",
            "docstring": "Response from channel configuration operations.",
            "methods": [
              "to_dict"
            ],
            "line": 232
          },
          {
            "name": "NotificationSender",
            "docstring": "Protocol for notification sender implementations.",
            "methods": [
              "send"
            ],
            "line": 252
          },
          {
            "name": "NotifyChannelService",
            "docstring": "Service for managing notification channels.\n\nGAP-017: Provides configurable notification channels for\nalerts, incidents, and policy events.\n\nUsage:\n    service = NotifyChannelService()\n\n    # Configure a channel\n    config = service.configure_channel(\n        tenant_id=\"tenant-1\",\n        channel=NotifyChannel.WEBHOOK,\n        webhook_url=\"https://example.com/webhook\"\n    )\n\n    # Send notification\n    result = await service.send(\n        tenant_id=\"tenant-1\",\n        event_type=NotifyEventType.INCIDENT_CREATED,\n        payload={\"incident_id\": \"inc-123\", ...}\n    )\n\n    # Check channel health\n    health = await service.check_health(tenant_id=\"tenant-1\")",
            "methods": [
              "__init__",
              "configure_channel",
              "get_channel_config",
              "get_all_configs",
              "get_enabled_channels",
              "enable_channel",
              "disable_channel",
              "set_event_filter",
              "send",
              "_send_via_channel",
              "_send_ui_notification",
              "_send_webhook_notification",
              "_send_email_notification",
              "_send_slack_notification",
              "_send_pagerduty_notification",
              "_send_teams_notification",
              "check_health",
              "get_delivery_history"
            ],
            "line": 265
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional",
              "Protocol",
              "Set"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "vault.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_vault/drivers/vault.py",
        "layer": "L5_other",
        "domain": "integrations",
        "lines": 749,
        "module_docstring": "Credential Vault Abstraction (GAP-171)\n\nSupports multiple vault providers:\n- HashiCorp Vault (production)\n- AWS Secrets Manager (production)\n- Environment variables (development only)",
        "functions": [
          {
            "name": "create_credential_vault",
            "signature": "() -> CredentialVault",
            "docstring": "Factory function to create appropriate vault based on configuration.",
            "is_async": false,
            "line": 729
          }
        ],
        "classes": [
          {
            "name": "VaultProvider",
            "docstring": "Supported vault providers.",
            "methods": [],
            "line": 49
          },
          {
            "name": "CredentialType",
            "docstring": "Types of credentials.",
            "methods": [],
            "line": 57
          },
          {
            "name": "CredentialMetadata",
            "docstring": "Metadata about a stored credential (without secret values).",
            "methods": [],
            "line": 71
          },
          {
            "name": "CredentialData",
            "docstring": "Full credential including secret values.",
            "methods": [
              "credential_id",
              "tenant_id"
            ],
            "line": 91
          },
          {
            "name": "CredentialVault",
            "docstring": "Abstract credential vault interface.",
            "methods": [
              "store_credential",
              "get_credential",
              "get_metadata",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential"
            ],
            "line": 106
          },
          {
            "name": "HashiCorpVault",
            "docstring": "HashiCorp Vault implementation.",
            "methods": [
              "__init__",
              "store_credential",
              "get_credential",
              "get_metadata",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential"
            ],
            "line": 266
          },
          {
            "name": "EnvCredentialVault",
            "docstring": "Environment variable credential vault (development only).\n\nCredentials are stored in memory with secrets read from environment.",
            "methods": [
              "__init__",
              "store_credential",
              "get_credential",
              "get_metadata",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential"
            ],
            "line": 562
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "service.py",
        "file_path": "backend/app/hoc/cus/integrations/L5_vault/engines/service.py",
        "layer": "L5_other",
        "domain": "integrations",
        "lines": 551,
        "module_docstring": "Credential Service (GAP-171)\n\nHigh-level service for credential management with:\n- Input validation\n- Audit logging\n- Expiration checking\n- Rotation scheduling",
        "functions": [],
        "classes": [
          {
            "name": "CredentialAccessRecord",
            "docstring": "Record of credential access for auditing.",
            "methods": [],
            "line": 45
          },
          {
            "name": "CredentialService",
            "docstring": "High-level credential service.\n\nFeatures:\n- Credential CRUD with validation\n- Expiration checking\n- Access auditing\n- Rotation support",
            "methods": [
              "__init__",
              "store_credential",
              "get_credential",
              "get_secret_value",
              "list_credentials",
              "update_credential",
              "delete_credential",
              "rotate_credential",
              "get_expiring_credentials",
              "get_rotatable_credentials",
              "get_access_log",
              "_audit",
              "_validate_tenant_id",
              "_validate_name",
              "_validate_secret_data"
            ],
            "line": 58
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "vault",
            "names": [
              "CredentialData",
              "CredentialMetadata",
              "CredentialType",
              "CredentialVault"
            ],
            "is_relative": true,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l6_drivers": [
      {
        "file_name": "connector_registry.py",
        "file_path": "backend/app/hoc/cus/integrations/L6_drivers/connector_registry.py",
        "layer": "L6_drivers",
        "domain": "integrations",
        "lines": 838,
        "module_docstring": "ConnectorRegistry - Connector management and registration.\n\nProvides a unified registry for:\n- Connector type registration\n- Connector instance management\n- Capability discovery\n- Status monitoring",
        "functions": [
          {
            "name": "get_connector_registry",
            "signature": "() -> ConnectorRegistry",
            "docstring": "Get the singleton registry instance.",
            "is_async": false,
            "line": 803
          },
          {
            "name": "_reset_registry",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 811
          },
          {
            "name": "register_connector",
            "signature": "(connector: BaseConnector) -> BaseConnector",
            "docstring": "Register a connector using the singleton registry.",
            "is_async": false,
            "line": 820
          },
          {
            "name": "get_connector",
            "signature": "(connector_id: str) -> Optional[BaseConnector]",
            "docstring": "Get a connector by ID using the singleton registry.",
            "is_async": false,
            "line": 826
          },
          {
            "name": "list_connectors",
            "signature": "(tenant_id: Optional[str] = None, connector_type: Optional[ConnectorType] = None) -> list[BaseConnector]",
            "docstring": "List connectors using the singleton registry.",
            "is_async": false,
            "line": 832
          }
        ],
        "classes": [
          {
            "name": "ConnectorType",
            "docstring": "Types of connectors.",
            "methods": [],
            "line": 38
          },
          {
            "name": "ConnectorStatus",
            "docstring": "Status of a connector.",
            "methods": [],
            "line": 51
          },
          {
            "name": "ConnectorCapability",
            "docstring": "Capabilities a connector may have.",
            "methods": [],
            "line": 63
          },
          {
            "name": "ConnectorConfig",
            "docstring": "Base configuration for connectors.",
            "methods": [
              "to_dict"
            ],
            "line": 77
          },
          {
            "name": "ConnectorError",
            "docstring": "Exception for connector errors.",
            "methods": [
              "__init__",
              "to_dict"
            ],
            "line": 118
          },
          {
            "name": "BaseConnector",
            "docstring": "Abstract base class for all connectors.",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "health_check",
              "record_connection",
              "record_error",
              "to_dict"
            ],
            "line": 143
          },
          {
            "name": "VectorConnector",
            "docstring": "Connector for vector databases (GAP-061).\n\nSupports:\n- Vector storage and retrieval\n- Similarity search\n- Metadata filtering",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "health_check",
              "upsert_vectors",
              "search",
              "delete_vectors",
              "to_dict"
            ],
            "line": 226
          },
          {
            "name": "FileConnector",
            "docstring": "Connector for file storage (GAP-062).\n\nSupports:\n- File upload/download\n- Directory listing\n- Metadata operations",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "health_check",
              "list_files",
              "read_file",
              "write_file",
              "delete_file",
              "to_dict"
            ],
            "line": 345
          },
          {
            "name": "ServerlessConnector",
            "docstring": "Connector for serverless functions (GAP-064).\n\nSupports:\n- Function invocation\n- Async execution\n- Result retrieval",
            "methods": [
              "__init__",
              "connect",
              "disconnect",
              "health_check",
              "invoke",
              "list_functions",
              "get_result",
              "to_dict"
            ],
            "line": 470
          },
          {
            "name": "ConnectorStats",
            "docstring": "Statistics for connectors.",
            "methods": [
              "to_dict"
            ],
            "line": 587
          },
          {
            "name": "ConnectorRegistry",
            "docstring": "Registry for managing connectors (GAP-057).\n\nFeatures:\n- Connector registration and lookup\n- Type-based filtering\n- Status management\n- Tenant isolation",
            "methods": [
              "__init__",
              "register",
              "create_vector_connector",
              "create_file_connector",
              "create_serverless_connector",
              "get",
              "get_by_name",
              "list",
              "delete",
              "get_statistics",
              "clear_tenant",
              "reset"
            ],
            "line": 615
          }
        ],
        "imports": [
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 35
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "external_response_driver.py",
        "file_path": "backend/app/hoc/cus/integrations/L6_drivers/external_response_driver.py",
        "layer": "L6_drivers",
        "domain": "integrations",
        "lines": 289,
        "module_docstring": "External Response Driver (Phase E FIX-04)\n\nL6 service for persisting raw external responses and their interpretations.\n\nWrite Path (L3 \u2192 L6):\n- Adapters call record_raw_response() with raw data\n- Raw data is persisted with interpretation_owner declared\n- L3 returns only receipt confirmation (not interpretation)\n\nInterpretation Path (L4 \u2192 L6):\n- L4 engines call interpret() with domain-meaningful result\n- interpreted_value is persisted with interpreted_by\n\nRead Path (L5/L2 \u2190 L6):\n- Consumers call get_interpreted() to read L4's interpretation\n- Raw data is never exposed to consumers\n\nContract:\n- Every external response has an explicit interpretation owner\n- L3 adapters never interpret - only record raw data\n- L4 engines are the only authority for interpretation\n- L5/L2 never see raw_response - only interpreted_value",
        "functions": [
          {
            "name": "record_external_response",
            "signature": "(session: Session, source: str, raw_response: dict, interpretation_owner: str, interpretation_contract: Optional[str] = None, request_id: Optional[str] = None, run_id: Optional[str] = None) -> ExternalResponse",
            "docstring": "Record a raw external response (L3 \u2192 L6).",
            "is_async": false,
            "line": 247
          },
          {
            "name": "interpret_response",
            "signature": "(session: Session, response_id: UUID, interpreted_value: dict, interpreted_by: str) -> ExternalResponse",
            "docstring": "Record L4 engine interpretation (L4 \u2192 L6).",
            "is_async": false,
            "line": 268
          },
          {
            "name": "get_interpreted_response",
            "signature": "(session: Session, response_id: UUID) -> Optional[InterpretedResponse]",
            "docstring": "Get interpreted response for consumers (L5/L2 \u2190 L6).",
            "is_async": false,
            "line": 283
          }
        ],
        "classes": [
          {
            "name": "ExternalResponseService",
            "docstring": "Service for external response operations.\n\nPhase E FIX-04: Makes interpretation authority explicit and queryable.",
            "methods": [
              "__init__",
              "record_raw_response",
              "interpret",
              "get_raw_for_interpretation",
              "get_interpreted",
              "get_pending_interpretations"
            ],
            "line": 61
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "select",
              "update"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "sqlalchemy.orm",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 53
          },
          {
            "module": "app.models.external_response",
            "names": [
              "ExternalResponse",
              "InterpretedResponse"
            ],
            "is_relative": false,
            "line": 55
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "worker_registry_driver.py",
        "file_path": "backend/app/hoc/cus/integrations/L6_drivers/worker_registry_driver.py",
        "layer": "L6_drivers",
        "domain": "integrations",
        "lines": 424,
        "module_docstring": "Worker Registry Driver (L6)\n\nProvides:\n- Dynamic worker discovery from database\n- Worker status and capability queries\n- Per-tenant worker configuration\n- Worker availability checks",
        "functions": [
          {
            "name": "get_worker_registry_service",
            "signature": "(session: Session) -> WorkerRegistryService",
            "docstring": "Get a WorkerRegistryService instance.",
            "is_async": false,
            "line": 413
          }
        ],
        "classes": [
          {
            "name": "WorkerRegistryError",
            "docstring": "Base exception for worker registry errors.",
            "methods": [],
            "line": 47
          },
          {
            "name": "WorkerNotFoundError",
            "docstring": "Raised when a worker is not found.",
            "methods": [],
            "line": 53
          },
          {
            "name": "WorkerUnavailableError",
            "docstring": "Raised when a worker is not available.",
            "methods": [],
            "line": 59
          },
          {
            "name": "WorkerRegistryService",
            "docstring": "Service for worker registry operations.",
            "methods": [
              "__init__",
              "get_worker",
              "get_worker_or_raise",
              "list_workers",
              "list_available_workers",
              "is_worker_available",
              "get_worker_details",
              "get_worker_summary",
              "list_worker_summaries",
              "register_worker",
              "update_worker_status",
              "deprecate_worker",
              "get_tenant_worker_config",
              "set_tenant_worker_config",
              "list_tenant_worker_configs",
              "get_effective_worker_config",
              "is_worker_enabled_for_tenant",
              "get_workers_for_tenant"
            ],
            "line": 65
          }
        ],
        "imports": [
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "select"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.models.tenant",
            "names": [
              "WorkerConfig",
              "WorkerRegistry"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "WorkerRegistryService",
          "WorkerRegistryError",
          "WorkerNotFoundError",
          "WorkerUnavailableError",
          "get_worker_registry_service"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 50,
    "violation_count": 6,
    "gap_count": 3
  },
  "apis": {
    "l2_1_facade": null,
    "l2_apis": [],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [],
    "l5_schemas": [],
    "l5_other": [],
    "l6_drivers": [
      {
        "file_name": "keys_driver.py",
        "file_path": "backend/app/hoc/cus/apis/L6_drivers/keys_driver.py",
        "layer": "L6_drivers",
        "domain": "apis",
        "lines": 196,
        "module_docstring": "Keys Driver (L6)\n\nPure data access for API keys.\nNo business logic - only DB operations.\n\nAuthority: KEY_PERSISTENCE\nTables: api_keys, proxy_calls (read-only for usage)",
        "functions": [
          {
            "name": "get_keys_driver",
            "signature": "(session: Session) -> KeysDriver",
            "docstring": "Factory function for KeysDriver.",
            "is_async": false,
            "line": 188
          }
        ],
        "classes": [
          {
            "name": "KeysDriver",
            "docstring": "L6 driver for API key data access.\n\nINVARIANTS (L6):\n- No business branching\n- No validation\n- No cross-domain calls\n- Pure persistence operations only",
            "methods": [
              "__init__",
              "fetch_keys_paginated",
              "fetch_key_by_id",
              "fetch_key_usage_today",
              "update_key_frozen"
            ],
            "line": 55
          }
        ],
        "imports": [
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "typing",
            "names": [
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "sqlalchemy",
            "names": [
              "and_",
              "desc",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "app.models.killswitch",
            "names": [
              "ProxyCall"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.models.tenant",
            "names": [
              "APIKey"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": [
          "KeysDriver",
          "get_keys_driver"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 1,
    "violation_count": 0,
    "gap_count": 2
  },
  "account": {
    "l2_1_facade": null,
    "l2_apis": [
      {
        "file_name": "memory_pins.py",
        "file_path": "backend/app/hoc/api/cus/account/memory_pins.py",
        "layer": "L2_api",
        "domain": "account",
        "lines": 578,
        "module_docstring": "Memory Pins API - M7 Implementation\n\nProvides REST API for managing memory pins (structured key-value storage).\n\nFeatures:\n- Tenant-isolated storage\n- JSONB values for flexible schema\n- Optional TTL for expiring entries\n- RBAC enforcement (when enabled)\n- Prometheus metrics\n\nEndpoints:\n- POST /api/v1/memory/pins - Create or upsert a pin\n- GET /api/v1/memory/pins/{key} - Get a pin by key\n- GET /api/v1/memory/pins - List pins for tenant\n- DELETE /api/v1/memory/pins/{key} - Delete a pin",
        "functions": [
          {
            "name": "check_feature_enabled",
            "signature": "()",
            "docstring": "Check if memory pins feature is enabled.",
            "is_async": false,
            "line": 130
          },
          {
            "name": "extract_tenant_from_request",
            "signature": "(request: Request, tenant_id: Optional[str] = None) -> str",
            "docstring": "Extract tenant ID from request or parameter.",
            "is_async": false,
            "line": 136
          },
          {
            "name": "write_memory_audit",
            "signature": "(db, operation: str, tenant_id: str, key: str, success: bool, latency_ms: float, agent_id: Optional[str] = None, source: Optional[str] = None, cache_hit: bool = False, error_message: Optional[str] = None, old_value_hash: Optional[str] = None, new_value_hash: Optional[str] = None, extra: Optional[Dict[str, Any]] = None)",
            "docstring": "Write an audit entry to system.memory_audit.",
            "is_async": false,
            "line": 147
          },
          {
            "name": "create_or_upsert_pin",
            "signature": "(pin: MemoryPinCreate, request: Request, db = Depends(get_db_session))",
            "docstring": "Create or upsert a memory pin.\n\nIf a pin with the same (tenant_id, key) exists, it will be updated.\nOtherwise, a new pin is created.\n\nRequires RBAC permission: memory_pin:write",
            "is_async": true,
            "line": 204
          },
          {
            "name": "get_pin",
            "signature": "(key: str, request: Request, tenant_id: str = Query(default='global', description='Tenant ID'), db = Depends(get_db_session))",
            "docstring": "Get a memory pin by key.\n\nReturns 404 if not found or expired.\n\nRequires RBAC permission: memory_pin:read",
            "is_async": true,
            "line": 308
          },
          {
            "name": "list_pins",
            "signature": "(request: Request, tenant_id: str = Query(default='global', description='Tenant ID'), prefix: Optional[str] = Query(default=None, description='Key prefix filter'), limit: int = Query(default=100, ge=1, le=1000, description='Max results'), offset: int = Query(default=0, ge=0, description='Offset for pagination'), include_expired: bool = Query(default=False, description='Include expired pins'), db = Depends(get_db_session))",
            "docstring": "List memory pins for a tenant.\n\nSupports filtering by key prefix and pagination.\n\nRequires RBAC permission: memory_pin:read",
            "is_async": true,
            "line": 377
          },
          {
            "name": "delete_pin",
            "signature": "(key: str, request: Request, tenant_id: str = Query(default='global', description='Tenant ID'), db = Depends(get_db_session))",
            "docstring": "Delete a memory pin by key.\n\nReturns 404 if not found.\n\nRequires RBAC permission: memory_pin:delete",
            "is_async": true,
            "line": 460
          },
          {
            "name": "cleanup_expired_pins",
            "signature": "(request: Request, tenant_id: Optional[str] = Query(default=None, description='Limit to specific tenant'), db = Depends(get_db_session))",
            "docstring": "Clean up expired memory pins.\n\nTypically called by a cron job. Deletes all pins where expires_at < now().\n\nRequires RBAC permission: memory_pin:admin",
            "is_async": true,
            "line": 517
          }
        ],
        "classes": [
          {
            "name": "MemoryPinCreate",
            "docstring": "Schema for creating/upserting a memory pin.",
            "methods": [
              "validate_key"
            ],
            "line": 71
          },
          {
            "name": "MemoryPinResponse",
            "docstring": "Schema for memory pin response.",
            "methods": [],
            "line": 91
          },
          {
            "name": "MemoryPinListResponse",
            "docstring": "Schema for listing memory pins.",
            "methods": [],
            "line": 108
          },
          {
            "name": "MemoryPinDeleteResponse",
            "docstring": "Schema for delete response.",
            "methods": [],
            "line": 117
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 33
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 34
          },
          {
            "module": "fastapi",
            "names": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "Query",
              "Request"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "pydantic",
            "names": [
              "BaseModel",
              "Field",
              "field_validator"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "sqlalchemy",
            "names": [
              "text"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "sqlalchemy.exc",
            "names": [
              "IntegrityError"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "db",
            "names": [
              "get_session"
            ],
            "is_relative": true,
            "line": 41
          },
          {
            "module": "schemas.response",
            "names": [
              "wrap_dict"
            ],
            "is_relative": true,
            "line": 42
          },
          {
            "module": "utils.metrics_helpers",
            "names": [
              "get_or_create_counter",
              "get_or_create_histogram"
            ],
            "is_relative": true,
            "line": 43
          }
        ],
        "constants": [
          {
            "name": "MEMORY_PINS_ENABLED",
            "line": 48
          },
          {
            "name": "MEMORY_PINS_OPERATIONS",
            "line": 51
          },
          {
            "name": "MEMORY_PINS_LATENCY",
            "line": 56
          }
        ],
        "all_exports": null
      }
    ],
    "l3_adapters": [],
    "l4_runtime": [],
    "l5_engines": [
      {
        "file_name": "accounts_facade.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/accounts_facade.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 1140,
        "module_docstring": "Accounts Domain Facade (L5)\n\nUnified facade for all accounts domain operations:\n- Projects: list, detail\n- Users: list, detail, invite, remove, update role\n- Profile: get, update\n- Billing: summary, invoices\n- Support: contact, tickets\n\nGOVERNANCE NOTE:\nAccount is NOT a domain - it manages who, what, and billing (not what happened).\nAccount pages MUST NOT display executions, incidents, policies, or logs.",
        "functions": [
          {
            "name": "get_accounts_facade",
            "signature": "() -> AccountsFacade",
            "docstring": "Get the singleton AccountsFacade instance.",
            "is_async": false,
            "line": 1101
          }
        ],
        "classes": [
          {
            "name": "ProjectSummaryResult",
            "docstring": "Project summary for list view.",
            "methods": [],
            "line": 66
          },
          {
            "name": "ProjectsListResult",
            "docstring": "Projects list response.",
            "methods": [],
            "line": 79
          },
          {
            "name": "ProjectDetailResult",
            "docstring": "Project detail response.",
            "methods": [],
            "line": 89
          },
          {
            "name": "UserSummaryResult",
            "docstring": "User summary for list view.",
            "methods": [],
            "line": 122
          },
          {
            "name": "UsersListResult",
            "docstring": "Users list response.",
            "methods": [],
            "line": 135
          },
          {
            "name": "UserDetailResult",
            "docstring": "User detail response.",
            "methods": [],
            "line": 145
          },
          {
            "name": "TenantUserResult",
            "docstring": "User in tenant.",
            "methods": [],
            "line": 170
          },
          {
            "name": "TenantUsersListResult",
            "docstring": "List of tenant users.",
            "methods": [],
            "line": 181
          },
          {
            "name": "ProfileResult",
            "docstring": "User profile response.",
            "methods": [],
            "line": 194
          },
          {
            "name": "ProfileUpdateResult",
            "docstring": "Profile update response.",
            "methods": [],
            "line": 209
          },
          {
            "name": "BillingSummaryResult",
            "docstring": "Billing summary response.",
            "methods": [],
            "line": 226
          },
          {
            "name": "InvoiceSummaryResult",
            "docstring": "Invoice summary.",
            "methods": [],
            "line": 244
          },
          {
            "name": "InvoiceListResult",
            "docstring": "Invoice list response.",
            "methods": [],
            "line": 256
          },
          {
            "name": "SupportContactResult",
            "docstring": "Support contact info.",
            "methods": [],
            "line": 270
          },
          {
            "name": "SupportTicketResult",
            "docstring": "Support ticket response.",
            "methods": [],
            "line": 279
          },
          {
            "name": "SupportTicketListResult",
            "docstring": "Support ticket list response.",
            "methods": [],
            "line": 295
          },
          {
            "name": "InvitationResult",
            "docstring": "Invitation response.",
            "methods": [],
            "line": 308
          },
          {
            "name": "InvitationListResult",
            "docstring": "Invitation list response.",
            "methods": [],
            "line": 321
          },
          {
            "name": "AcceptInvitationResult",
            "docstring": "Invitation acceptance result.",
            "methods": [],
            "line": 329
          },
          {
            "name": "AccountsErrorResult",
            "docstring": "Error result for accounts operations.",
            "methods": [],
            "line": 344
          },
          {
            "name": "AccountsFacade",
            "docstring": "Unified facade for all Accounts domain operations.\n\nProvides:\n- Projects: list, detail\n- Users: list, detail, invite, remove, update role\n- Profile: get, update\n- Billing: summary, invoices\n- Support: contact, tickets\n\nGOVERNANCE NOTE:\nAccount is NOT a domain - it manages who, what, and billing (not what happened).\n\nLAYER COMPLIANCE (Phase 2.5B):\nThis L4 facade delegates all DB operations to AccountsFacadeDriver (L6).\nBusiness logic (validation, permissions) remains here.",
            "methods": [
              "__init__",
              "list_projects",
              "get_project_detail",
              "list_users",
              "get_user_detail",
              "list_tenant_users",
              "update_user_role",
              "remove_user",
              "get_profile",
              "update_profile",
              "get_billing_summary",
              "get_billing_invoices",
              "get_support_contact",
              "create_support_ticket",
              "list_support_tickets",
              "invite_user",
              "list_invitations",
              "accept_invitation"
            ],
            "line": 357
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "secrets",
            "names": [
              "secrets"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta",
              "timezone"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.account.L6_drivers.accounts_facade_driver",
            "names": [
              "AccountsFacadeDriver",
              "get_accounts_facade_driver"
            ],
            "is_relative": false,
            "line": 51
          }
        ],
        "constants": [],
        "all_exports": [
          "AccountsFacade",
          "get_accounts_facade",
          "ProjectSummaryResult",
          "ProjectsListResult",
          "ProjectDetailResult",
          "UserSummaryResult",
          "UsersListResult",
          "UserDetailResult",
          "TenantUserResult",
          "TenantUsersListResult",
          "ProfileResult",
          "ProfileUpdateResult",
          "BillingSummaryResult",
          "InvoiceSummaryResult",
          "InvoiceListResult",
          "SupportContactResult",
          "SupportTicketResult",
          "SupportTicketListResult",
          "InvitationResult",
          "InvitationListResult",
          "AcceptInvitationResult",
          "AccountsErrorResult"
        ]
      },
      {
        "file_name": "billing_provider.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/billing_provider.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 251,
        "module_docstring": "Phase-6 Billing Provider \u2014 Interface and Mock Implementation\n\nPIN-399 Phase-6: Mock provider must satisfy same interface as real provider.\n\nDESIGN INVARIANTS (LOCKED):\n- BILLING-005: Mock provider must satisfy same interface as real provider\n\nIMPLEMENTATION CONSTRAINTS:\n- Hardcoded plan assignment\n- Hardcoded limits\n- Deterministic behavior\n- No network calls\n- No external dependencies\n\nThis ensures zero refactor when Stripe/etc is added later.",
        "functions": [
          {
            "name": "get_billing_provider",
            "signature": "() -> BillingProvider",
            "docstring": "Get the billing provider instance.\n\nReturns MockBillingProvider by default.\nCan be replaced for testing or production.",
            "is_async": false,
            "line": 223
          },
          {
            "name": "set_billing_provider",
            "signature": "(provider: BillingProvider) -> None",
            "docstring": "Set the billing provider instance.\n\nUsed for testing or to swap in a real provider.",
            "is_async": false,
            "line": 236
          }
        ],
        "classes": [
          {
            "name": "BillingProvider",
            "docstring": "Phase-6 Billing Provider Protocol.\n\nAll billing providers (mock and real) must implement this interface.\n\nThis protocol is LOCKED per BILLING-005.",
            "methods": [
              "get_billing_state",
              "get_plan",
              "get_limits",
              "is_limit_exceeded"
            ],
            "line": 47
          },
          {
            "name": "MockBillingProvider",
            "docstring": "Phase-6 Mock Billing Provider.\n\nImplements BillingProvider protocol with hardcoded, deterministic behavior.\n\nIMPLEMENTATION CONSTRAINTS:\n- No network calls\n- No database access (uses in-memory state)\n- Deterministic results\n- Static configuration\n\nThis mock is behavior-compatible with future real providers.",
            "methods": [
              "__init__",
              "get_billing_state",
              "get_plan",
              "get_limits",
              "is_limit_exceeded",
              "set_billing_state",
              "set_plan",
              "reset"
            ],
            "line": 111
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Protocol",
              "Optional"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "app.billing.state",
            "names": [
              "BillingState"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "app.billing.plan",
            "names": [
              "Plan",
              "DEFAULT_PLAN",
              "PLAN_FREE",
              "PLAN_PRO",
              "PLAN_ENTERPRISE"
            ],
            "is_relative": false,
            "line": 41
          },
          {
            "module": "app.billing.limits",
            "names": [
              "Limits",
              "derive_limits"
            ],
            "is_relative": false,
            "line": 42
          }
        ],
        "constants": [],
        "all_exports": [
          "BillingProvider",
          "MockBillingProvider",
          "get_billing_provider",
          "set_billing_provider"
        ]
      },
      {
        "file_name": "email_verification.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/email_verification.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 302,
        "module_docstring": "Email Verification Service\n\nProvides OTP-based email verification for customer onboarding.\n\nConfiguration (environment variables):\n    RESEND_API_KEY: Resend.com API key for sending emails\n    EMAIL_FROM: Sender email address\n    EMAIL_VERIFICATION_TTL: OTP validity in seconds (default: 600 = 10 min)",
        "functions": [
          {
            "name": "get_email_verification_service",
            "signature": "() -> EmailVerificationService",
            "docstring": "Get email verification service singleton.",
            "is_async": false,
            "line": 297
          }
        ],
        "classes": [
          {
            "name": "VerificationResult",
            "docstring": "Result of OTP verification.",
            "methods": [],
            "line": 60
          },
          {
            "name": "EmailVerificationError",
            "docstring": "Email verification error.",
            "methods": [
              "__init__"
            ],
            "line": 69
          },
          {
            "name": "EmailVerificationService",
            "docstring": "Handles OTP generation, sending, and verification for email signup.\n\nUses Redis for OTP storage with TTL.",
            "methods": [
              "__init__",
              "_otp_key",
              "_attempts_key",
              "_cooldown_key",
              "_generate_otp",
              "send_otp",
              "_send_otp_email",
              "verify_otp"
            ],
            "line": 78
          }
        ],
        "imports": [
          {
            "module": "hashlib",
            "names": [
              "hashlib"
            ],
            "is_relative": false,
            "line": 35
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 36
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 37
          },
          {
            "module": "secrets",
            "names": [
              "secrets"
            ],
            "is_relative": false,
            "line": 38
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 39
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 40
          },
          {
            "module": "httpx",
            "names": [
              "httpx"
            ],
            "is_relative": false,
            "line": 42
          },
          {
            "module": "redis",
            "names": [
              "Redis"
            ],
            "is_relative": false,
            "line": 43
          }
        ],
        "constants": [
          {
            "name": "RESEND_API_KEY",
            "line": 48
          },
          {
            "name": "EMAIL_FROM",
            "line": 49
          },
          {
            "name": "EMAIL_VERIFICATION_TTL",
            "line": 50
          },
          {
            "name": "REDIS_URL",
            "line": 51
          },
          {
            "name": "OTP_LENGTH",
            "line": 54
          },
          {
            "name": "MAX_OTP_ATTEMPTS",
            "line": 55
          },
          {
            "name": "OTP_COOLDOWN_SECONDS",
            "line": 56
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "identity_resolver.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/identity_resolver.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 207,
        "module_docstring": "Identity Resolver (GAP-173)\n\nResolves identities from various sources:\n- JWT tokens (Clerk, Auth0)\n- API keys\n- System tokens",
        "functions": [
          {
            "name": "create_default_identity_chain",
            "signature": "() -> IdentityChain",
            "docstring": "Create the default identity resolver chain.",
            "is_async": false,
            "line": 199
          }
        ],
        "classes": [
          {
            "name": "IdentityResolver",
            "docstring": "Abstract identity resolver.",
            "methods": [
              "resolve",
              "provider"
            ],
            "line": 41
          },
          {
            "name": "ClerkIdentityResolver",
            "docstring": "Resolver for Clerk JWT tokens.",
            "methods": [
              "__init__",
              "provider",
              "resolve"
            ],
            "line": 60
          },
          {
            "name": "APIKeyIdentityResolver",
            "docstring": "Resolver for API keys.",
            "methods": [
              "provider",
              "resolve"
            ],
            "line": 101
          },
          {
            "name": "SystemIdentityResolver",
            "docstring": "Resolver for internal system identities.",
            "methods": [
              "provider",
              "resolve"
            ],
            "line": 129
          },
          {
            "name": "IdentityChain",
            "docstring": "Chain of identity resolvers.\n\nTries each resolver in order until one succeeds.",
            "methods": [
              "resolve"
            ],
            "line": 152
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 29
          },
          {
            "module": "abc",
            "names": [
              "ABC",
              "abstractmethod"
            ],
            "is_relative": false,
            "line": 30
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 31
          },
          {
            "module": "typing",
            "names": [
              "Optional"
            ],
            "is_relative": false,
            "line": 32
          },
          {
            "module": "app.hoc.int.platform.iam.engines.iam_service",
            "names": [
              "ActorType",
              "Identity",
              "IdentityProvider"
            ],
            "is_relative": false,
            "line": 34
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "notifications_facade.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/notifications_facade.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 480,
        "module_docstring": "Notifications Facade (L5 Domain Engine)\n\nThis facade provides the external interface for notification operations.\nAll notification APIs MUST use this facade instead of directly importing\ninternal notification modules.\n\nWhy This Facade Exists:\n- Prevents L2\u2192L4 layer violations\n- Centralizes notification delivery logic\n- Provides unified access to multiple notification channels\n- Single point for audit emission\n\nL2 API Routes (GAP-109):\n- POST /api/v1/notifications (send notification)\n- GET /api/v1/notifications (list notifications)\n- GET /api/v1/notifications/{id} (get notification)\n- POST /api/v1/notifications/{id}/read (mark as read)\n- GET /api/v1/notifications/channels (list channels)\n- PUT /api/v1/notifications/preferences (update preferences)\n\nUsage:\n    from app.hoc.cus.account.L5_engines import get_notifications_facade\n\n    facade = get_notifications_facade()\n\n    # Send notification\n    result = await facade.send_notification(\n        tenant_id=\"...\",\n        channel=\"email\",\n        recipient=\"...\",\n        message=\"...\",\n    )",
        "functions": [
          {
            "name": "get_notifications_facade",
            "signature": "() -> NotificationsFacade",
            "docstring": "Get the notifications facade instance.\n\nThis is the recommended way to access notification operations\nfrom L2 APIs and the SDK.\n\nReturns:\n    NotificationsFacade instance",
            "is_async": false,
            "line": 467
          }
        ],
        "classes": [
          {
            "name": "NotificationChannel",
            "docstring": "Notification channels.",
            "methods": [],
            "line": 67
          },
          {
            "name": "NotificationPriority",
            "docstring": "Notification priorities.",
            "methods": [],
            "line": 76
          },
          {
            "name": "NotificationStatus",
            "docstring": "Notification delivery status.",
            "methods": [],
            "line": 84
          },
          {
            "name": "NotificationInfo",
            "docstring": "Notification information.",
            "methods": [
              "to_dict"
            ],
            "line": 94
          },
          {
            "name": "ChannelInfo",
            "docstring": "Notification channel information.",
            "methods": [
              "to_dict"
            ],
            "line": 128
          },
          {
            "name": "NotificationPreferences",
            "docstring": "User notification preferences.",
            "methods": [
              "to_dict"
            ],
            "line": 148
          },
          {
            "name": "NotificationsFacade",
            "docstring": "Facade for notification operations.\n\nThis is the ONLY entry point for L2 APIs and SDK to interact with\nnotification services.\n\nLayer: L4 (Domain Logic)\nCallers: notifications.py (L2), aos_sdk, Worker",
            "methods": [
              "__init__",
              "send_notification",
              "list_notifications",
              "get_notification",
              "mark_as_read",
              "list_channels",
              "get_channel",
              "get_preferences",
              "update_preferences"
            ],
            "line": 165
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 57
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass",
              "field"
            ],
            "is_relative": false,
            "line": 58
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "uuid",
            "names": [
              "uuid"
            ],
            "is_relative": false,
            "line": 62
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "profile.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/profile.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 459,
        "module_docstring": "Governance Profile Configuration\n\nReduces cognitive load and configuration drift by providing three\nwell-defined governance profiles:\n\n- STRICT: Full enforcement, all features enabled, production-ready\n- STANDARD: Core features enabled, some optional features disabled\n- OBSERVE_ONLY: Audit and observe without enforcement (safe rollout)\n\nUsage:\n    from app.hoc.cus.account.L5_engines.profile import (\n        get_governance_profile,\n        validate_governance_config,\n        GovernanceProfile,\n    )\n\n    # At startup\n    profile = get_governance_profile()\n    validate_governance_config()  # Raises if invalid combination\n\n    # Check profile\n    if profile == GovernanceProfile.STRICT:\n        # Full enforcement mode\n        ...\n\nEnvironment Variables:\n    GOVERNANCE_PROFILE: STRICT | STANDARD | OBSERVE_ONLY (default: STANDARD)\n\n    Individual flags (override profile defaults):\n    - ROK_ENABLED\n    - RAC_ENABLED\n    - TRANSACTION_COORDINATOR_ENABLED\n    - EVENT_REACTOR_ENABLED\n    - MID_EXECUTION_POLICY_CHECK_ENABLED\n    - RAC_DURABILITY_ENFORCE (STRICT only)\n    - PHASE_STATUS_INVARIANT_ENFORCE (STRICT only)",
        "functions": [
          {
            "name": "_get_bool_env",
            "signature": "(name: str, default: bool) -> bool",
            "docstring": "Get boolean from environment variable.",
            "is_async": false,
            "line": 246
          },
          {
            "name": "get_governance_profile",
            "signature": "() -> GovernanceProfile",
            "docstring": "Get the current governance profile from environment.\n\nReturns:\n    GovernanceProfile enum value",
            "is_async": false,
            "line": 254
          },
          {
            "name": "load_governance_config",
            "signature": "() -> GovernanceConfig",
            "docstring": "Load complete governance configuration.\n\nLoads profile defaults, then applies any environment variable overrides.\n\nReturns:\n    GovernanceConfig with all settings",
            "is_async": false,
            "line": 276
          },
          {
            "name": "validate_governance_config",
            "signature": "(config: Optional[GovernanceConfig] = None) -> List[str]",
            "docstring": "Validate governance configuration for invalid combinations.\n\nArgs:\n    config: Configuration to validate (loads from env if not provided)\n\nReturns:\n    List of warning messages (empty if valid)\n\nRaises:\n    GovernanceConfigError: If configuration has blocking violations",
            "is_async": false,
            "line": 326
          },
          {
            "name": "get_governance_config",
            "signature": "() -> GovernanceConfig",
            "docstring": "Get the validated governance configuration singleton.\n\nLoads and validates on first call, caches thereafter.\n\nReturns:\n    Validated GovernanceConfig",
            "is_async": false,
            "line": 411
          },
          {
            "name": "reset_governance_config",
            "signature": "() -> None",
            "docstring": "Reset the singleton (for testing).",
            "is_async": false,
            "line": 427
          },
          {
            "name": "validate_governance_at_startup",
            "signature": "() -> None",
            "docstring": "Validate governance configuration at application startup.\n\nCall this from main.py during FastAPI lifespan startup.\n\nRaises:\n    GovernanceConfigError: If configuration is invalid",
            "is_async": false,
            "line": 438
          }
        ],
        "classes": [
          {
            "name": "GovernanceProfile",
            "docstring": "Pre-defined governance profiles.\n\nEach profile represents a coherent set of feature flag settings\ndesigned for specific deployment scenarios.",
            "methods": [],
            "line": 68
          },
          {
            "name": "GovernanceConfig",
            "docstring": "Complete governance configuration derived from profile + overrides.",
            "methods": [
              "to_dict"
            ],
            "line": 110
          },
          {
            "name": "GovernanceConfigError",
            "docstring": "Raised when governance configuration is invalid.",
            "methods": [
              "__init__"
            ],
            "line": 233
          }
        ],
        "imports": [
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 59
          },
          {
            "module": "os",
            "names": [
              "os"
            ],
            "is_relative": false,
            "line": 60
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 61
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 62
          },
          {
            "module": "typing",
            "names": [
              "Dict",
              "FrozenSet",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 63
          }
        ],
        "constants": [],
        "all_exports": null
      },
      {
        "file_name": "tenant_engine.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/tenant_engine.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 582,
        "module_docstring": "Tenant Engine (L5)\n\nBusiness logic for tenant operations.\n\nProvides:\n- Tenant creation with plan quotas\n- Plan upgrades/downgrades\n- Quota enforcement (runs per day, tokens per month, concurrent runs)\n- API key management with limits\n- Run lifecycle with quota checks\n- Usage tracking\n\nAll DB operations are delegated to TenantDriver (L6).",
        "functions": [
          {
            "name": "get_tenant_engine",
            "signature": "(session: Session) -> TenantEngine",
            "docstring": "Get a TenantEngine instance.",
            "is_async": false,
            "line": 572
          }
        ],
        "classes": [
          {
            "name": "TenantEngineError",
            "docstring": "Base exception for tenant engine errors.",
            "methods": [],
            "line": 65
          },
          {
            "name": "QuotaExceededError",
            "docstring": "Raised when a quota limit is exceeded.",
            "methods": [
              "__init__"
            ],
            "line": 70
          },
          {
            "name": "TenantEngine",
            "docstring": "L4 Engine for tenant business logic.\n\nHandles:\n- Quota decisions\n- Plan logic\n- Status validation\n- Temporal logic (daily counter reset)\n\nDelegates all DB operations to TenantDriver (L6).",
            "methods": [
              "__init__",
              "create_tenant",
              "get_tenant",
              "get_tenant_by_slug",
              "update_plan",
              "suspend",
              "create_membership_with_default",
              "create_api_key",
              "list_api_keys",
              "revoke_api_key",
              "check_run_quota",
              "check_token_quota",
              "increment_usage",
              "_maybe_reset_daily_counter",
              "record_usage",
              "get_usage_summary",
              "create_run",
              "complete_run",
              "list_runs"
            ],
            "line": 85
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "logging",
            "names": [
              "logging"
            ],
            "is_relative": false,
            "line": 46
          },
          {
            "module": "datetime",
            "names": [
              "timedelta"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "List",
              "Optional",
              "Tuple"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "app.hoc.cus.account.L6_drivers.tenant_driver",
            "names": [
              "TenantDriver",
              "get_tenant_driver"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "app.models.tenant",
            "names": [
              "PLAN_QUOTAS",
              "APIKey",
              "Tenant",
              "TenantMembership",
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 52
          }
        ],
        "constants": [],
        "all_exports": [
          "TenantEngine",
          "TenantEngineError",
          "QuotaExceededError",
          "get_tenant_engine"
        ]
      },
      {
        "file_name": "user_write_engine.py",
        "file_path": "backend/app/hoc/cus/account/L5_engines/user_write_engine.py",
        "layer": "L5_engines",
        "domain": "account",
        "lines": 91,
        "module_docstring": "User Write Engine (L5)\n\nDB write operations for User management.\nDelegates to UserWriteDriver (L6) for all database access.\n\nL2 (API) \u2192 L4 (this service) \u2192 L6 (UserWriteDriver)\n\nResponsibilities:\n- Delegate to L6 driver for data access\n- Maintain backward compatibility for callers\n\nReference: PIN-250, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [],
        "classes": [
          {
            "name": "UserWriteService",
            "docstring": "DB write operations for User management.\n\nDelegates all operations to UserWriteDriver (L6).\nNO DIRECT DB ACCESS - driver calls only.",
            "methods": [
              "__init__",
              "create_user",
              "update_user_login",
              "user_to_dict"
            ],
            "line": 57
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 44
          },
          {
            "module": "app.hoc.cus.account.L6_drivers.user_write_driver",
            "names": [
              "UserWriteDriver",
              "get_user_write_driver"
            ],
            "is_relative": false,
            "line": 47
          }
        ],
        "constants": [],
        "all_exports": null
      }
    ],
    "l5_schemas": [],
    "l5_other": [
      {
        "file_name": "crm_validator_engine.py",
        "file_path": "backend/app/hoc/cus/account/L5_support/CRM/engines/crm_validator_engine.py",
        "layer": "L5_other",
        "domain": "account",
        "lines": 739,
        "module_docstring": "Part-2 Validator Service (L4)\n\nAnalyzes incoming CRM issues and produces structured verdicts for the\neligibility engine. The Validator is advisory only - it recommends but\ndoes not decide.\n\nResponsibilities:\n1. Classify issue type (capability_request, bug_report, etc.)\n2. Determine severity (critical, high, medium, low)\n3. Extract affected capabilities\n4. Recommend action (create_contract, defer, reject, escalate)\n5. Calculate confidence score\n\nInvariants (from VALIDATOR_LOGIC.md):\n- VAL-001: Validator is stateless (no writes)\n- VAL-002: Verdicts include version (required field)\n- VAL-003: Confidence in [0,1] (clamping)\n- VAL-004: Unknown type defers (action logic)\n- VAL-005: Escalation always escalates (action logic)\n\nReference: PIN-287, VALIDATOR_LOGIC.md, part2-design-v1",
        "functions": [],
        "classes": [
          {
            "name": "IssueType",
            "docstring": "Issue type classification.\n\nReference: VALIDATOR_LOGIC.md Issue Type Classification",
            "methods": [],
            "line": 90
          },
          {
            "name": "Severity",
            "docstring": "Issue severity classification.\n\nReference: VALIDATOR_LOGIC.md Severity Classification",
            "methods": [],
            "line": 109
          },
          {
            "name": "RecommendedAction",
            "docstring": "Recommended action from validator.\n\nReference: VALIDATOR_LOGIC.md Recommended Action Logic",
            "methods": [],
            "line": 127
          },
          {
            "name": "IssueSource",
            "docstring": "Issue source for confidence weighting.",
            "methods": [],
            "line": 145
          },
          {
            "name": "ValidatorInput",
            "docstring": "Input to the validator.\n\nReference: VALIDATOR_LOGIC.md Validator Input",
            "methods": [],
            "line": 161
          },
          {
            "name": "ValidatorVerdict",
            "docstring": "Output from the validator.\n\nReference: VALIDATOR_LOGIC.md Validator Output (Verdict)\n\nInvariant VAL-002: Verdicts include version (required field)",
            "methods": [],
            "line": 183
          },
          {
            "name": "ValidatorErrorType",
            "docstring": "Error types for validator failures.",
            "methods": [],
            "line": 208
          },
          {
            "name": "ValidatorError",
            "docstring": "Error from validator with fallback verdict.\n\nReference: VALIDATOR_LOGIC.md Error Handling",
            "methods": [],
            "line": 218
          },
          {
            "name": "ValidatorService",
            "docstring": "Part-2 Validator Service (L4)\n\nAnalyzes CRM issues and produces advisory verdicts.\n\nProperties:\n- ADVISORY: Produces recommendations, not decisions\n- STATELESS: No side effects (VAL-001)\n- DETERMINISTIC: Same input produces same output\n- VERSIONED: Every verdict includes version (VAL-002)\n\nReference: VALIDATOR_LOGIC.md, part2-design-v1",
            "methods": [
              "__init__",
              "validate",
              "_do_validate",
              "_extract_text",
              "_classify_issue_type",
              "_classify_severity",
              "_find_severity_indicators",
              "_extract_capabilities",
              "_get_source_weight",
              "_get_capability_confidence",
              "_calculate_confidence",
              "_determine_action",
              "_build_reason",
              "_create_fallback_verdict"
            ],
            "line": 333
          }
        ],
        "imports": [
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 72
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 73
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 74
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 75
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 76
          }
        ],
        "constants": [
          {
            "name": "VALIDATOR_VERSION",
            "line": 82
          },
          {
            "name": "CAPABILITY_REQUEST_KEYWORDS",
            "line": 235
          },
          {
            "name": "BUG_REPORT_KEYWORDS",
            "line": 250
          },
          {
            "name": "CONFIGURATION_KEYWORDS",
            "line": 265
          },
          {
            "name": "ESCALATION_KEYWORDS",
            "line": 279
          },
          {
            "name": "CRITICAL_INDICATORS",
            "line": 294
          },
          {
            "name": "HIGH_INDICATORS",
            "line": 306
          },
          {
            "name": "LOW_INDICATORS",
            "line": 316
          }
        ],
        "all_exports": null
      },
      {
        "file_name": "validator_engine.py",
        "file_path": "backend/app/hoc/cus/account/L5_support/CRM/engines/validator_engine.py",
        "layer": "L5_other",
        "domain": "account",
        "lines": 735,
        "module_docstring": "Part-2 Validator Service (L4)\n\nAnalyzes incoming CRM issues and produces structured verdicts for the\neligibility engine. The Validator is advisory only - it recommends but\ndoes not decide.\n\nResponsibilities:\n1. Classify issue type (capability_request, bug_report, etc.)\n2. Determine severity (critical, high, medium, low)\n3. Extract affected capabilities\n4. Recommend action (create_contract, defer, reject, escalate)\n5. Calculate confidence score\n\nInvariants (from VALIDATOR_LOGIC.md):\n- VAL-001: Validator is stateless (no writes)\n- VAL-002: Verdicts include version (required field)\n- VAL-003: Confidence in [0,1] (clamping)\n- VAL-004: Unknown type defers (action logic)\n- VAL-005: Escalation always escalates (action logic)\n\nReference: PIN-287, VALIDATOR_LOGIC.md, part2-design-v1",
        "functions": [],
        "classes": [
          {
            "name": "IssueType",
            "docstring": "Issue type classification.\n\nReference: VALIDATOR_LOGIC.md Issue Type Classification",
            "methods": [],
            "line": 86
          },
          {
            "name": "Severity",
            "docstring": "Issue severity classification.\n\nReference: VALIDATOR_LOGIC.md Severity Classification",
            "methods": [],
            "line": 105
          },
          {
            "name": "RecommendedAction",
            "docstring": "Recommended action from validator.\n\nReference: VALIDATOR_LOGIC.md Recommended Action Logic",
            "methods": [],
            "line": 123
          },
          {
            "name": "IssueSource",
            "docstring": "Issue source for confidence weighting.",
            "methods": [],
            "line": 141
          },
          {
            "name": "ValidatorInput",
            "docstring": "Input to the validator.\n\nReference: VALIDATOR_LOGIC.md Validator Input",
            "methods": [],
            "line": 157
          },
          {
            "name": "ValidatorVerdict",
            "docstring": "Output from the validator.\n\nReference: VALIDATOR_LOGIC.md Validator Output (Verdict)\n\nInvariant VAL-002: Verdicts include version (required field)",
            "methods": [],
            "line": 179
          },
          {
            "name": "ValidatorErrorType",
            "docstring": "Error types for validator failures.",
            "methods": [],
            "line": 204
          },
          {
            "name": "ValidatorError",
            "docstring": "Error from validator with fallback verdict.\n\nReference: VALIDATOR_LOGIC.md Error Handling",
            "methods": [],
            "line": 214
          },
          {
            "name": "ValidatorService",
            "docstring": "Part-2 Validator Service (L4)\n\nAnalyzes CRM issues and produces advisory verdicts.\n\nProperties:\n- ADVISORY: Produces recommendations, not decisions\n- STATELESS: No side effects (VAL-001)\n- DETERMINISTIC: Same input produces same output\n- VERSIONED: Every verdict includes version (VAL-002)\n\nReference: VALIDATOR_LOGIC.md, part2-design-v1",
            "methods": [
              "__init__",
              "validate",
              "_do_validate",
              "_extract_text",
              "_classify_issue_type",
              "_classify_severity",
              "_find_severity_indicators",
              "_extract_capabilities",
              "_get_source_weight",
              "_get_capability_confidence",
              "_calculate_confidence",
              "_determine_action",
              "_build_reason",
              "_create_fallback_verdict"
            ],
            "line": 329
          }
        ],
        "imports": [
          {
            "module": "re",
            "names": [
              "re"
            ],
            "is_relative": false,
            "line": 66
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 67
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timezone"
            ],
            "is_relative": false,
            "line": 68
          },
          {
            "module": "decimal",
            "names": [
              "Decimal"
            ],
            "is_relative": false,
            "line": 69
          },
          {
            "module": "enum",
            "names": [
              "Enum"
            ],
            "is_relative": false,
            "line": 70
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 71
          },
          {
            "module": "uuid",
            "names": [
              "UUID"
            ],
            "is_relative": false,
            "line": 72
          }
        ],
        "constants": [
          {
            "name": "VALIDATOR_VERSION",
            "line": 78
          },
          {
            "name": "CAPABILITY_REQUEST_KEYWORDS",
            "line": 231
          },
          {
            "name": "BUG_REPORT_KEYWORDS",
            "line": 246
          },
          {
            "name": "CONFIGURATION_KEYWORDS",
            "line": 261
          },
          {
            "name": "ESCALATION_KEYWORDS",
            "line": 275
          },
          {
            "name": "CRITICAL_INDICATORS",
            "line": 290
          },
          {
            "name": "HIGH_INDICATORS",
            "line": 302
          },
          {
            "name": "LOW_INDICATORS",
            "line": 312
          }
        ],
        "all_exports": null
      }
    ],
    "l6_drivers": [
      {
        "file_name": "accounts_facade_driver.py",
        "file_path": "backend/app/hoc/cus/account/L6_drivers/accounts_facade_driver.py",
        "layer": "L6_drivers",
        "domain": "account",
        "lines": 954,
        "module_docstring": "Accounts Facade Driver (L6)\n\nPure data access layer for accounts domain operations.\n\nProvides:\n- Tenant/Project queries\n- User queries\n- Membership queries\n- Profile queries\n- Billing queries\n- Support ticket queries\n- Invitation queries\n\nAll methods return snapshot dataclasses, not ORM models.\nBusiness logic belongs in the facade (L4), not here.",
        "functions": [
          {
            "name": "get_accounts_facade_driver",
            "signature": "() -> AccountsFacadeDriver",
            "docstring": "Get the singleton AccountsFacadeDriver instance.",
            "is_async": false,
            "line": 932
          }
        ],
        "classes": [
          {
            "name": "TenantSnapshot",
            "docstring": "Tenant data from DB for list view.",
            "methods": [],
            "line": 72
          },
          {
            "name": "TenantDetailSnapshot",
            "docstring": "Detailed tenant data from DB.",
            "methods": [],
            "line": 84
          },
          {
            "name": "UserSnapshot",
            "docstring": "User data from DB for list view.",
            "methods": [],
            "line": 106
          },
          {
            "name": "UserDetailSnapshot",
            "docstring": "Detailed user data from DB.",
            "methods": [],
            "line": 118
          },
          {
            "name": "MembershipSnapshot",
            "docstring": "Tenant membership data from DB.",
            "methods": [],
            "line": 139
          },
          {
            "name": "ProfileSnapshot",
            "docstring": "User profile data from DB.",
            "methods": [],
            "line": 149
          },
          {
            "name": "SubscriptionSnapshot",
            "docstring": "Subscription data from DB.",
            "methods": [],
            "line": 163
          },
          {
            "name": "InvitationSnapshot",
            "docstring": "Invitation data from DB.",
            "methods": [],
            "line": 173
          },
          {
            "name": "TicketSnapshot",
            "docstring": "Support ticket data from DB.",
            "methods": [],
            "line": 187
          },
          {
            "name": "AccountsFacadeDriver",
            "docstring": "L6 Driver for accounts domain data access.\n\nAll methods are pure data access - no business logic.\nReturns snapshot dataclasses, not ORM models.",
            "methods": [
              "fetch_tenant",
              "fetch_tenants",
              "count_tenants",
              "fetch_tenant_detail",
              "fetch_users",
              "count_users",
              "fetch_user_detail",
              "fetch_tenant_memberships",
              "fetch_membership",
              "fetch_membership_with_user",
              "update_membership_role",
              "delete_membership",
              "fetch_profile",
              "fetch_user_by_id",
              "update_user_profile",
              "fetch_subscription",
              "insert_support_ticket",
              "fetch_support_tickets",
              "fetch_invitation_by_email",
              "insert_invitation",
              "fetch_invitations",
              "fetch_invitation_by_id_and_token",
              "fetch_user_by_email",
              "insert_user",
              "insert_membership",
              "update_invitation_accepted",
              "update_invitation_expired"
            ],
            "line": 206
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "typing",
            "names": [
              "TYPE_CHECKING",
              "Any",
              "Optional"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "sqlalchemy",
            "names": [
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 51
          },
          {
            "module": "sqlalchemy.ext.asyncio",
            "names": [
              "AsyncSession"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.models.tenant",
            "names": [
              "Invitation",
              "Subscription",
              "SupportTicket",
              "Tenant",
              "TenantMembership",
              "User",
              "generate_uuid",
              "utc_now"
            ],
            "is_relative": false,
            "line": 54
          }
        ],
        "constants": [],
        "all_exports": [
          "AccountsFacadeDriver",
          "get_accounts_facade_driver",
          "TenantSnapshot",
          "TenantDetailSnapshot",
          "UserSnapshot",
          "UserDetailSnapshot",
          "MembershipSnapshot",
          "ProfileSnapshot",
          "SubscriptionSnapshot",
          "InvitationSnapshot",
          "TicketSnapshot"
        ]
      },
      {
        "file_name": "tenant_driver.py",
        "file_path": "backend/app/hoc/cus/account/L6_drivers/tenant_driver.py",
        "layer": "L6_drivers",
        "domain": "account",
        "lines": 574,
        "module_docstring": "Tenant Driver (L6)\n\nPure data access layer for tenant operations.\n\nProvides:\n- Tenant CRUD\n- Membership CRUD\n- API key CRUD\n- Usage record CRUD\n- Run CRUD\n- Audit logging\n\nAll methods are pure data access - no business logic.\nReturns snapshot dataclasses or ORM models for mutations.\nBusiness logic belongs in the engine (L4).",
        "functions": [
          {
            "name": "get_tenant_driver",
            "signature": "(session: Session) -> TenantDriver",
            "docstring": "Get a TenantDriver instance.",
            "is_async": false,
            "line": 560
          }
        ],
        "classes": [
          {
            "name": "TenantCoreSnapshot",
            "docstring": "Core tenant data for engine operations.",
            "methods": [],
            "line": 72
          },
          {
            "name": "RunCountSnapshot",
            "docstring": "Running count for quota checks.",
            "methods": [],
            "line": 93
          },
          {
            "name": "APIKeySnapshot",
            "docstring": "API key data snapshot.",
            "methods": [],
            "line": 99
          },
          {
            "name": "UsageRecordSnapshot",
            "docstring": "Usage record data.",
            "methods": [],
            "line": 116
          },
          {
            "name": "RunSnapshot",
            "docstring": "Worker run snapshot.",
            "methods": [],
            "line": 128
          },
          {
            "name": "TenantDriver",
            "docstring": "L6 Driver for tenant data access.\n\nAll methods are pure data access - no business logic.\nReturns snapshots or ORM models for mutations.",
            "methods": [
              "__init__",
              "fetch_tenant_by_id",
              "fetch_tenant_by_slug",
              "fetch_tenant_snapshot",
              "insert_tenant",
              "update_tenant_plan",
              "update_tenant_status",
              "update_tenant_usage",
              "increment_tenant_usage",
              "insert_membership",
              "count_active_api_keys",
              "insert_api_key",
              "fetch_api_keys",
              "fetch_api_key_by_id",
              "update_api_key_revoked",
              "count_running_runs",
              "insert_run",
              "fetch_run_by_id",
              "update_run_completed",
              "fetch_runs",
              "insert_usage_record",
              "fetch_usage_records",
              "insert_audit_log"
            ],
            "line": 148
          }
        ],
        "imports": [
          {
            "module": "__future__",
            "names": [
              "annotations"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "json",
            "names": [
              "json"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "dataclasses",
            "names": [
              "dataclass"
            ],
            "is_relative": false,
            "line": 48
          },
          {
            "module": "datetime",
            "names": [
              "datetime",
              "timedelta"
            ],
            "is_relative": false,
            "line": 49
          },
          {
            "module": "typing",
            "names": [
              "Any",
              "List",
              "Optional",
              "cast"
            ],
            "is_relative": false,
            "line": 50
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session",
              "func",
              "select"
            ],
            "is_relative": false,
            "line": 52
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 54
          },
          {
            "module": "app.models.tenant",
            "names": [
              "APIKey",
              "AuditLog",
              "Tenant",
              "TenantMembership",
              "UsageRecord",
              "User",
              "WorkerRun"
            ],
            "is_relative": false,
            "line": 55
          }
        ],
        "constants": [],
        "all_exports": [
          "TenantDriver",
          "get_tenant_driver",
          "TenantCoreSnapshot",
          "RunCountSnapshot",
          "APIKeySnapshot",
          "UsageRecordSnapshot",
          "RunSnapshot"
        ]
      },
      {
        "file_name": "user_write_driver.py",
        "file_path": "backend/app/hoc/cus/account/L6_drivers/user_write_driver.py",
        "layer": "L6_drivers",
        "domain": "account",
        "lines": 137,
        "module_docstring": "User Write Driver (L6)\n\nPure database write operations for User management.\n\nL4 (UserWriteService) \u2192 L6 (this driver)\n\nResponsibilities:\n- Create user records\n- Update user login timestamps\n- Convert user to dict (DTO transformation)\n- NO business logic (L4 responsibility)\n\nReference: PIN-250, PHASE2_EXTRACTION_PROTOCOL.md",
        "functions": [
          {
            "name": "get_user_write_driver",
            "signature": "(session: Session) -> UserWriteDriver",
            "docstring": "Factory function to get UserWriteDriver instance.",
            "is_async": false,
            "line": 129
          }
        ],
        "classes": [
          {
            "name": "UserWriteDriver",
            "docstring": "L6 driver for user write operations.\n\nPure database access - no business logic.",
            "methods": [
              "__init__",
              "create_user",
              "update_user_login",
              "user_to_dict"
            ],
            "line": 51
          }
        ],
        "imports": [
          {
            "module": "typing",
            "names": [
              "Dict",
              "Optional"
            ],
            "is_relative": false,
            "line": 43
          },
          {
            "module": "sqlmodel",
            "names": [
              "Session"
            ],
            "is_relative": false,
            "line": 45
          },
          {
            "module": "app.hoc.cus.general.L5_utils.time",
            "names": [
              "utc_now"
            ],
            "is_relative": false,
            "line": 47
          },
          {
            "module": "app.models.tenant",
            "names": [
              "User"
            ],
            "is_relative": false,
            "line": 48
          }
        ],
        "constants": [],
        "all_exports": [
          "UserWriteDriver",
          "get_user_write_driver"
        ]
      }
    ],
    "l7_models": [],
    "total_files": 14,
    "violation_count": 1,
    "gap_count": 3
  }
}