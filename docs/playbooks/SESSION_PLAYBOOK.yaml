# =============================================================================
# SESSION PLAYBOOK BOOTSTRAP (SPB)
# =============================================================================
#
# Purpose: Single source of truth for what MUST be loaded every session.
# This is the equivalent of a DB migration head check, but for agent behavior.
#
# Rule: Memory decays. Contracts don't.
#       Sessions must boot like systems, not humans.
#
# Enforcement: BL-BOOT-001 behavior rule
# Validator: scripts/ops/session_bootstrap_validator.py
#
# Created: 2025-12-27
# Reference: Last Mile Guarantee / Session-Level Inevitability
# =============================================================================

session_playbook_version: "2.43"
created: "2025-12-27"
last_updated: "2026-01-11"

# Changelog:
#   2.43 - RBAC GUARDRAIL (Section 26, PIN-391).
#          Added rbac_guardrail section enforcing schema-first authorization.
#          Invariant: Authorization is declared, not inferred.
#          Canonical source: design/auth/RBAC_RULES.yaml (single source of truth).
#          Hard rules: RBAC-001 to RBAC-004 (no inference, schema first).
#          Decision ladder: Check RBAC_RULES.yaml before modifying auth.
#          Self-check: Prevent PUBLIC_PATHS drift from schema.
#          New artifacts: design/auth/RBAC_RULES.yaml, backend/app/auth/rbac_rules_loader.py.
#          Root cause: Dual authority (gateway + middleware) caused 403 drift.
#          Reference: PIN-391, design/auth/RBAC_RULES.yaml
#   2.42 - QUERY AUTHORITY CI GUARD (Section 41 enhancement, PIN-390).
#          Added ci_guard subsection to query_authority_model.
#          Script: scripts/ci/query_authority_guard.py (BLOCKING enforcement).
#          Validations: contract declaration, panel presence, schema compliance,
#          hard invariants (SYNTHETIC/INTERNAL), matrix compliance.
#          Exit codes: 0=pass, 1=violations, 2=file error.
#          Usage: --verbose, --strict, --path options.
#          Enforcement: Query authority violations now fail CI.
#          Reference: PIN-390, docs/schemas/query_authority_schema.json
#   2.41 - QUERY AUTHORITY MODEL (Section 41, BL-QUERY-AUTH-001, PIN-390).
#          Added query_authority_model section for four-console authority.
#          Prime directive: Query authority is declarative, not inferred.
#          Authority levels: USER, SYSTEM, SYNTHETIC, INTERNAL (locked semantics).
#          Four-console matrix: customer×preflight, customer×prod, founder×preflight, founder×prod.
#          Failure modes: HIDE, DISABLE, EXPLAIN.
#          Fail-closed default: SYSTEM level, all consoles denied.
#          UI contract: canQuery() before any API call.
#          Compiler contract: must emit query_authority for every panel.
#          Adds rules QUERY-AUTH-001 to QUERY-AUTH-005.
#          Key distinctions: Visibility ≠ Queryability ≠ Executability.
#          Root cause: Four consoles without explicit authority = 403 factory.
#          Reference: PIN-390, docs/governance/QUERY_AUTHORITY_MODEL.md
#   2.40 - EPISTEMIC SAFETY PROTOCOL (Section 40, BL-EPISTEMIC-001, PIN-389).
#          Added epistemic_safety_protocol section enforcing schema-first behavior.
#          Prime directive: Schema is law. No guessing, no extrapolation.
#          Mental model: Claude behaves like a compiler, not a co-designer.
#          Mandatory steps: Declare Scope → Load Schema → Validate → Write → Assert.
#          Forbidden behaviors: field invention, silent fixes, pattern-matching.
#          Layer boundary guardrails for SDSR → UI pipeline.
#          Adds rules EPISTEMIC-001 to EPISTEMIC-005.
#          Root cause: Claude enforced runtime invariants at design time.
#          Reference: PIN-389, docs/governance/CLAUDE_EPISTEMIC_SAFETY.md
#   2.39 - CANONICAL-FIRST FIX POLICY (Section 39, ARCH-CANON-001, PIN-370).
#          Added canonical_first_policy section enforcing extension over duplication.
#          Core principle: Claude is FORBIDDEN from creating new tables/APIs for existing domains.
#          Must fix by extension: lifecycle hooks, state transitions, mappings, queries, indexes.
#          Explicitly forbidden: parallel tables (sdsr_*, *_v2), shadow APIs, "temporary" structures.
#          Added canonical repair order (4-step mandatory process).
#          Added fragmentation escalation protocol (ARCH-FRAG-ESCALATE-001).
#          Fragmentation is not forbidden, but never Claude's decision - must escalate.
#          Root cause fix: sdsr_incidents incident required emergency consolidation.
#          Reference: PIN-370, CLAUDE_ENGINEERING_AUTHORITY.md Section 13-15
#   2.38 - SDSR CROSS-DOMAIN PROPAGATION CONTRACT (PIN-370).
#          Added SDSR-PROP-001 to SDSR-PROP-004 rules.
#          Core principle: Scenarios inject causes, not consequences.
#          Cross-domain effects must emerge from backend capabilities.
#          Added cross_domain_propagation section with backend responsibility matrix.
#          Domain execution order: Activity → Incidents → Policies → Logs.
#          If cross-domain effects don't fire, backend is broken, not scenario.
#   2.37 - SDSR UI ARCHITECTURE GATE (Section 38, BL-SDSR-UI-001, PIN-370).
#          Added sdsr_ui_architecture section enforcing projection-driven UI.
#          Core principle: UI renders projection. UI does not bypass projection.
#          SDSR data binding must happen at panel level via PanelContentRegistry.
#          Custom pages that bypass DomainPage structure are FORBIDDEN.
#          Conflict resolution: ASK_USER when architecture is ambiguous.
#          Adds rules SDSR-UI-001 to SDSR-UI-004.
#          Reference: PIN-370, docs/governance/SDSR.md
#   2.36 - DEPLOY AFTER REBUILD RULE (BL-DEPLOY-001, PIN-359).
#          Added mandatory deployment discipline: build without deploy is forbidden.
#          Frontend: npm run build MUST be followed by cp dist/* dist-preflight/ && reload apache2
#          Backend: docker compose up -d --build includes deploy by construction.
#          Incident: Code rebuilt but not deployed, user could not see/test changes.
#          Principle: Build without deploy = invisible work = wasted time.
#          Reference: PIN-359 Phase 2
#   2.35 - SCOPE ADMISSION PROTOCOL (Section 36, PIN-347).
#          Added scope_admission_protocol section for "No Code Before Scope" rule.
#          Claude must detect new paths and update INTENT_DECLARATION.yaml BEFORE
#          generating files. Prevents --no-verify bypass culture.
#          Root cause fix: declare governance intent before code exists.
#          Core rules: SCOPE-001 to SCOPE-004.
#          Reference: PIN-347 (L2.1 Epistemic Layer Table-First Design)
#   2.34 - INTENT LOCK SYSTEM (Section 35, PIN-319 Governance Fix).
#          Added intent_lock section for clean push by construction.
#          Requires INTENT_DECLARATION.yaml at session start.
#          Adds worktree_sanity_check.py continuous enforcement.
#          Adds --no-verify formalized policy.
#          Root cause fix: detect mixed intent at session start, not commit time.
#          Reference: PIN-319 (Frontend Realignment - Governance Hardening)
#   2.33 - Previous version (no changes from 2.32)
#   2.32 - DECISION GUARDRAILS (Section 25.1, PIN-276 REDO).
#          Adds decision_guardrails section preventing contract drift.
#          Layer 1: Fix classification required before any code change.
#          Layer 2: System-guided design detection (overload/parallel field patterns).
#          Layer 3: Hard stop conditions for structural violations.
#          Core principle: One contract, one signature, one truth.
#          Prevents function overloading and parallel state fields.
#          Reference: PIN-276 (Contract Authority Enforcement)
#   2.31 - INFRA REALITY INVARIANT (infra_truth_rule extension, PIN-276).
#          Added infra_reality_invariant subsection enforcing schema/code alignment.
#          Core principle: If code assumes it, schema must enforce it.
#          Added M10-specific enforcement rules and isolation fixtures.
#          Prevents future debt from placeholder skips.
#          Reference: PIN-276 (Test Isolation)
#   2.30 - INFRA TRUTH RULE (Section 33, PIN-266).
#          Added infra_truth_rule section enforcing registry-derived CI behavior.
#          Core principle: CI behavior must be derived from INFRA_REGISTRY.md.
#          Adds infra state taxonomy (A/B/C) with locked definitions.
#          Adds CI auto-alignment rules for @requires_infra decorator.
#          Adds ground truth authority chain (registry → enforcement → governance).
#          Adds Claude behavior rules for infra reasoning.
#          Prevents silent skips and infra assumption without registry entry.
#          Reference: PIN-266 (Infra Registry Canonicalization)
#   2.29 - CLAUDE_AUTHORITY.md SUPREMACY (PIN-269).
#          Added CLAUDE_AUTHORITY.md to mandatory_load as HIGHEST non-human authority.
#          Added governance_relationship section mapping playbook to authority sections.
#          Establishes: CLAUDE_AUTHORITY.md is principle; SESSION_PLAYBOOK is procedure.
#          If conflict exists, CLAUDE_AUTHORITY.md wins without exception.
#          Reference: PIN-269, CLAUDE_AUTHORITY.md
#   2.28 - FEATURE INTENT SYSTEM (Section 17 upgrade to full hierarchy).
#          Phase-2.3: Extends intent from function-level to feature-level.
#          Adds FeatureIntent enum: PURE_QUERY, STATE_MUTATION, EXTERNAL_SIDE_EFFECT, RECOVERABLE_OPERATION
#          Adds RetryPolicy enum: NEVER, SAFE, DANGEROUS
#          Adds @feature decorator for feature-level intent consistency
#          Adds INTENT_CONSISTENCY_MATRIX enforcing feature→function→primitive alignment
#          Adds scripts/ci/check_feature_intent.py for module-level enforcement
#          Adds app/infra/feature_intent_examples.py with all valid combinations
#          Reference: PIN-264 (Phase-2.3 Feature Intent System)
#   2.27 - TRANSACTION INTENT SYSTEM (Section 17 upgrade).
#          Phase-2.2: Upgrades from "blocked" to "guided by construction".
#          Adds TransactionIntent enum: READ_ONLY, ATOMIC_WRITE, LOCKED_MUTATION
#          Adds @transactional decorator for intent declaration (fail-fast validation)
#          Adds scripts/ci/check_intent_consistency.py for intent/primitive alignment
#          Adds app/infra/transaction_examples.py as golden reference
#          Section 17 is now "mirror, not authority" — code enforces, playbook explains
#          Reference: PIN-264 (Phase-2.2 Self-Defense with Intent)
#   2.26 - TRANSACTION SAFETY PRIMITIVES (Section 17).
#          Added self-defending transaction architecture.
#          Introduces single_connection_transaction() as the ONLY blessed path
#          for row locks (SELECT ... FOR UPDATE).
#          CI check: scripts/ci/check_forbidden_patterns.py
#          Makes cross-connection deadlocks STRUCTURALLY IMPOSSIBLE.
#          Reference: PIN-264 (Phase-2.1 Self-Defense)
#   2.25 - CLAUDE GOVERNANCE INSTRUCTION SET (Section 32).
#          Comprehensive phase-aware, SCD-compatible governance rules.
#          Adds: Operating mode, phase awareness, signal definition, SCD rules,
#                metadata semantics handling, automation limits, task discipline,
#                prohibited behaviors, output discipline, canonical self-test.
#          Adds: Signal Circuit Enumerator (SCE) automation specification.
#          Reference: PIN-262 (SCD Governance Clarification)
#   2.24 - SIGNAL OWNERSHIP REQUIREMENT (G-RULE-11).
#          Any discovered signal (CI, runtime, or boundary) without a named owner
#          is classified as a P0 governance defect and blocks phase progression.
#          Signal Circuit Discovery must record ownership status explicitly.
#          Reference: PIN-262 (Signal Circuit Discovery Governance Clarification)
#   2.23 - PRODUCT DEVELOPMENT CONTRACT V3 (mandatory_load + PIN-261).
#          Added PRODUCT_DEVELOPMENT_CONTRACT_V3.md to mandatory_load.
#          Establishes phase-ordered productization: CI → Console → Lifecycle.
#          Current phase: 1 (CI Signal Rediscovery & Stabilization).
#          Created CI_SIGNAL_REGISTRY.md template for Phase 1 output.
#          Supremacy order locked: Governance → CI → Product → UX.
#          Session start question: "Which phase, which work item?"
#          Reference: PIN-261
#   2.22 - PRODUCT ARCHITECTURE RULES (Section 31).
#          Documented: AI Console IS the product container.
#          Added frozen_domains (5): Overview, Activity, Incidents, Policies, Logs.
#          Added product_mapping: "products" → existing domain features.
#          Added expansion_rules: domains FROZEN, topics/orders expandable.
#          Added gap classification: productization vs architecture gaps.
#          Added session_guidance with 6 quick-reference rules.
#          Prevents proposing "new products" that are existing domains.
#          SDK confirmed PUBLISHED (PyPI + npm), not a gap.
#          Only true gap: Federated Agent Identity (intentionally deferred).
#          Reference: PIN-260 Product Architecture Clarity
#   2.21 - BLCA BOOTSTRAP ENFORCEMENT (BL-BOOT-002).
#          BLCA verification is now MANDATORY at session start.
#          Added blca_verification section with command and enforcement.
#          Added BLCA status to bootstrap_confirmation_format.
#          Added BL-BOOT-002 behavior rule (BLCA at bootstrap).
#          Bootstrap is INCOMPLETE without BLCA CLEAN status.
#          Reference: Phase G governance, G-RULE-1 compliance.
#   2.20 - PHASE G STEADY-STATE GOVERNANCE (Section 30).
#          Phase E (Semantic Closure) and Phase F (Structural Closure) COMPLETE.
#          Phase G is PERMANENT governance regime, not a construction phase.
#          Added G-RULE-1 through G-RULE-10 (hard rules, no drift allowed).
#          Added Phase G governance documents to mandatory_load.
#          Updated system_state: phase_family=G, current_stage=G_STEADY_STATE.
#          Added HOW_TO_ADD_A_FEATURE.md for compliant feature development.
#          Reference: PIN-258, PIN-259
#   2.19 - POST-PHASE D STEADY-STATE GOVERNANCE LOOP (Section 29).
#          Phase D complete. Architecture is now "Baseline: Truthful Architecture v1".
#          Added severity classification: BLOCKING/WARN/LOW with corrected tiers.
#          Corrected: Unregistered endpoints are BLOCKING (not WARN).
#          Added explicit ACK requirement: "BLCA reviewed for this session".
#          Added weekly acknowledgment cadence with explicit anti-decay purpose.
#          Added override authority with scope limit rule.
#          Defined safe work (no re-audit) vs audit-triggering work.
#          Clarified "mini phase" = same rules, smaller scope.
#          Added governance caveats: first test ≠ lifetime guarantee.
#          Added "auditability over findings" principle.
#          Reference: PIN-254, User governance review feedback
#   2.18 - PHASE D FINAL LOCKS (pre-Phase D governance hardening).
#          Added transaction clarifier: ephemeral UI state is NOT a transaction.
#          Lock 1 (D-4): Phase D failure semantics - failure is valid, silent correction forbidden.
#          Lock 2: F2 (Client-Side Authority) elevated to HIGH severity, always BLOCKING.
#          Lock 3: D-3 updated with full binary completion criteria including L1 and Unclassified=0.
#          Added restart_condition: If BLCA flips, Phase D RESTARTS (not continues).
#          Reference: PIN-254, User governance review feedback
#   2.17 - BLCA SCOPE EXPANSION: Backend-only BLCA is insufficient.
#          Added blast_radius (entire system where intent becomes effect).
#          Added transaction_definition (intent→effect, not just DB writes).
#          Added frontend_rules (F1: Entry Points, F2: Authority, F3: Side Effects).
#          Added intent_graph model (graph validation, not code scanning).
#          Added governance_escalation matrix (Claude surfaces, humans decide).
#          Added axis A6: Frontend Transaction Audit.
#          Reference: PIN-254, User governance review feedback
#   2.16 - BLCA hardening for Phase D governance.
#          Added governance_artifact_change trigger (BLCA guards process, not just code).
#          Added Phase D Governance Constraints (D-1, D-2, D-3):
#            D-1: BLCA supremacy during Phase D (BLCA can block Phase D mid-execution)
#            D-2: Validation-only mode (fixes only for BLCA restoration)
#            D-3: Binary success criteria (BLCA must remain CLEAN for full duration)
#          Added phase_d_as_blca_stress_test documentation.
#          Reference: PIN-254, User governance review feedback
#   2.15 - Added Section 28: BIDIRECTIONAL LAYER CONSISTENCY AUDITOR (BLCA).
#          Standing governance sentinel for continuous bidirectional verification.
#          Claude must run BLCA at session start and after code changes.
#          Non-clean results must escalate into governance artifacts (PIN/playbook).
#          Work is BLOCKED while audit status is BLOCKED.
#          Single source of truth: docs/governance/BIDIRECTIONAL_AUDIT_STATUS.md
#          Reference: PIN-254 (Phase C′ certified, Phase D unblocked)
#   2.14 - GOVERNANCE INCIDENT RATIFICATION (2025-12-31).
#          Phase C remediation was applied immediately following discovery.
#          This violated phase discipline: discovery ≠ remediation.
#          RATIFICATION: All fixes were strictly structural, non-semantic, and within
#          Phase C′ authorization scope. No behavior changes were introduced.
#          This action is ratified as Phase C′ remediation, not Phase C activity.
#          Phase C′ must still execute: L8 hygiene, authority integrity, closure report.
#          This incident is recorded as a governance example to prevent future drift.
#          Reference: PIN-254, Phase C Discipline Violation
#   2.13 - Added Section: GOVERNANCE_QUALIFIER (PIN-254 Phase C).
#          Explicit boundary: Session playbook governs reasoning order, not system meaning.
#          Authority Boundary: Playbook may NOT decide domain policy, thresholds, guarantees.
#          Fix Authorization: Only structural moves allowed, not semantic choices.
#          Escalation Clause: Claude must pause when domain intent is ambiguous.
#          Reference: PIN-254 (Layered Semantic Completion Phase C)
#   2.12 - PHASE 3 COMPLETE. Added ARCH-GOV-015, ARCH-GOV-016, ARCH-GOV-PRODUCT.
#          ARCH-GOV-015: Semantic Contract Authority — Frozen contracts are normative.
#          ARCH-GOV-016: Semantic Change Protocol — Meaning changes before behavior.
#          ARCH-GOV-PRODUCT: Product Unlock Condition — Foundational phases closed.
#          All 5 semantic pillars (Auth, Execution, Workers, Recovery, Transactions) FROZEN.
#          PRODUCT work is now UNLOCKED.
#          Reference: PIN-251, TRANSACTION_AUTHORITY_SEMANTIC_CONTRACT.md
#   2.11 - Added ARCH-GOV-014 (Mandatory Semantic Spot Audits).
#          Rule: No phase may be approved without random semantic spot audit verifying
#          code-level alignment with declared semantics.
#          Adversarial verification prevents "paper compliance" and semantic drift.
#          Reference: PIN-251, EXECUTION_SEMANTIC_CONTRACT.md
#   2.10 - Added ARCH-GOV-011 (CI Discovery Timing Gate).
#          Rule: CI discovery must occur only after structural alignment is complete
#          and before semantic alignment begins.
#          Reference: PIN-250, CI_CANDIDATE_MATRIX.md, PHASE2_RETROSPECTIVE.md
#   2.9 - Added ARCH-GOV-008, 009, 010 (Phase 2 Governance Elevations).
#         ARCH-GOV-008: Minimum Runnable Definition (>5 files requires explicit criteria)
#         ARCH-GOV-009: Batch Independence Validation (prove before batched extraction)
#         ARCH-GOV-010: Structural Diff Invariant (document every responsibility move)
#         Reference: PIN-250, PHASE2_ALIGNMENT_PLAN_v2.md
#   2.8 - Added Section 26: Layer Classification & Reassignment Gate (ENFORCED).
#         Added ARCH-GOV-007 (Layer Classification Reassignment Gate).
#         Mandatory 5-step procedure for layer audits and reclassification.
#         Hard stops prevent new abstractions, unrelated refactors, invented layers.
#         Outcomes: A (correct), B (misjudged), C (hybrid) - no shared/temporary allowed.
#         Principle: "Optimizing for correctness, not speed. Blocking = success."
#         Reference: PIN-249 (Protective Governance).
#   2.7 - Added Section 25: Protective Governance Mode (ENFORCED).
#         Added PG-001 (No Unregistered Debt), PG-002 (Monotonicity Guard),
#         PG-003 (Quarantine Ceiling), PG-004 (Baseline Ceremony).
#         Added debt_ceilings with quantified limits.
#         Added session_behavior with mode transition rules.
#         Reference: docs/contracts/PROTECTIVE_GOVERNANCE_CONTRACT.md
#   2.6 - Added Section 24: Artifact Class Contract (ENFORCED).
#         Added ARCH-GOV-006 (Artifact Class Declaration Gate).
#         Updated CODE-REG-002 to require artifact_class field.
#         Updated ARTIFACT_INTENT.yaml with artifact_class section.
#         Updated FILE_HEADER_TEMPLATE with non-executable guidance.
#         Artifact classes: CODE, TEST, DATA, STYLE, CONFIG, DOC.
#         UNKNOWN is now BLOCKING - never acceptable.
#         Principle: "Nothing escapes the system. Not everything executes."
#         Reference: PIN-248 (Codebase Inventory & Layer System).
#   2.5 - Added Section 23: Codebase Inventory & Artifact Hygiene (ENFORCED).
#         Added INV-001 (Inventory Update After Task) - update inventory after file operations.
#         Added HYG-001 (Artifact Hygiene Summary) - print hygiene summary after every task.
#         Added layer_model reference for L1-L8 classification.
#         Added on_task_completion checklist for artifact hygiene.
#         Reference: PIN-248 (Codebase Inventory & Layer System).
#   2.4 - Added pre_build_guards: PRE-BUILD-001 (Intent Declaration Gate),
#         PRE-BUILD-002 (Temporal Model Declaration Gate), PRE-BUILD-003 (Layer Confidence Gate).
#         Added runtime_sanity_guards: RUNTIME-001 (Sync-Async Boundary Guard),
#         RUNTIME-002 (Async Leak Detection Guard), RUNTIME-003 (Intent Completeness Guard).
#         Added prohibition_clause for invalid temporal justifications.
#         Intent and temporal enforcement now machine-enforced, not social rules.
#         Reference: PIN-245 (Integration Integrity System).
#   2.3 - Added Section 22: Architecture & Integration Governance (ENFORCED).
#         Added ARCH-GOV-001 (Artifact Intent Gate), ARCH-GOV-002 (Layer Declaration Gate),
#         ARCH-GOV-003 (Temporal Clarity Gate), ARCH-GOV-004 (File Header Requirement),
#         ARCH-GOV-005 (Integration Seam Awareness).
#         Added behavioral invariants BI-001 through BI-005.
#         Claude now operates as Architecture Governor with mandatory pre-build gates.
#         Reference: PIN-245 (Integration Integrity System).
#   2.2 - Added Section 21: Product Boundary Enforcement (ENFORCED).
#         Added BOUNDARY-001 through BOUNDARY-005 pre-build enforcement rules.
#         Added artifact intent schema requirements.
#         Product boundary contract now blocking.
#         Code existence requires provenance declaration.
#   2.1 - Added Section 20: Codebase Registry Authority (ENFORCED).
#         Added CODE-REG-001 through CODE-REG-004 blocking rules.
#         Added CODE-CHANGE-001 through CODE-CHANGE-003 change tracking rules.
#         Added codebase-registry to mandatory_load.
#         Code evolution now requires registered change records.
#   2.0 - Added Section 19: Frontend Architecture Invariants (FROZEN).
#         Added FRONTEND-ARCH-001: 3-layer entry point model enforcement.
#         Added FRONTEND-INTEGRATION-001: Pre-deploy completeness check.
#         Both rules are BLOCKING severity. Reference: PIN-235.
#   1.9 - CRITICAL: Renamed Administration → Account in console_governance.
#         Account is secondary navigation (top-right/footer), NOT primary sidebar.
#         Account is NOT a domain - manages who/what/billing, not what happened.
#   1.8 - Added Project Scope rules to console_governance (Section 18).
#         Projects are global scope selectors, not domains.
#         Cross-project aggregation forbidden in Customer Console.
#   1.7 - Added Customer Console v1 Constitution enforcement.
#         Added console_governance section (Section 18).
#         Constitution loaded at session bootstrap.
#         Claude role defined: auditor and mapper, not designer.
#   1.6 - C5 design surface COMPLETE (S1 certified, S2/S3 designed).
#         S2: Learning from Coordination Friction - DESIGN COMPLETE
#         S3: Learning from Optimization Effectiveness - DESIGN COMPLETE
#         Updated stages to reflect design surface completion.
#         C5 implementation remains LOCKED (S1 only certified).
#   1.5 - Updated system_state for C5-S1 certification complete.
#         C1→C2→C3→C4 all CERTIFIED. C5-S1 CERTIFIED.
#         Added C3_to_C4 and C4_to_C5_S1 phase transitions.
#         Current stage now C5_LEARNING (S1 certified, S2+ locked).
#   1.4 - Added auth_contract and refusal_policy to execution_discipline.
#         Added mandatory_confirmations to on_session_restart (auth_header_format_known,
#         api_call_template_loaded, preflight_required, public_paths_known).
#         Created docs/execution/API_CALL_TEMPLATE.md and scripts/preflight/check_auth_context.sh.
#         Permanently fixes env-vars-are-not-credentials failure class.
#   1.3 - Added execution_discipline (shell commands, credentials, infra assumptions, log interpretation).
#         Extended on_session_restart with execution rules. Prevents execution-layer drift.
#   1.2 - Added system_state (phase status), authoritative_environment, testing_principles (P1-P6),
#         infrastructure_authority map, phase_transitions, on_session_restart, verification_boundaries,
#         anti_drift_rules. Prevents architectural entropy across sessions.
#   1.1 - Added forbidden_assumptions, negative_design_rules, authority_declaration,
#         upgraded_self_audit, database_contract.yaml to mandatory_load
#   1.0 - Initial version with mandatory_load and phase enforcement

# =============================================================================
# MANDATORY LOAD
# =============================================================================
# These documents MUST be loaded and acknowledged at session start.
# No work is allowed until all documents are confirmed loaded.
# Order matters - load in this sequence.

mandatory_load:
  # Claude Authority Spine (HIGHEST NON-HUMAN AUTHORITY)
  # Reference: PIN-269
  - path: CLAUDE_AUTHORITY.md
    purpose: Absolute authority hierarchy, pre-flight requirements, behavioral principles
    required: true
    frozen: true
    ci_guard: claude-authority-guard
    supremacy_note: |
      This document takes precedence over SESSION_PLAYBOOK.yaml.
      If any conflict exists between CLAUDE_AUTHORITY.md and this playbook,
      CLAUDE_AUTHORITY.md wins. This playbook is procedural implementation;
      CLAUDE_AUTHORITY.md is governing principle.

  # Core Boot Contract (defines Claude's operating rules)
  - path: CLAUDE_BOOT_CONTRACT.md
    purpose: Boot sequence and forbidden actions
    required: true

  # Behavior Library (mechanical enforcement rules)
  - path: docs/behavior/behavior_library.yaml
    purpose: Behavior rules and triggers
    required: true

  # Visibility Contract (O1-O4 declarations)
  - path: docs/contracts/visibility_contract.yaml
    purpose: Visibility surface declarations
    required: true

  # Visibility Lifecycle (Phase C+ governance)
  - path: docs/contracts/visibility_lifecycle.yaml
    purpose: Visibility eligibility, contracting, promotion lifecycle
    required: true
    phase_activation: C  # Active enforcement starts in Phase C

  # Discovery Ledger Contract (Phase C+ observational signals)
  - path: docs/contracts/discovery_ledger.yaml
    purpose: Discovery signal recording and promotion rules
    required: true
    phase_activation: C  # Active enforcement starts in Phase C

  # Database Contract (prevents split-brain DB failures)
  - path: docs/contracts/database_contract.yaml
    purpose: Single authoritative DB per environment, no localhost fallback
    required: true

  # Lessons Enforced (invariants from past failures)
  - path: docs/LESSONS_ENFORCED.md
    purpose: 15 enforced invariants
    required: true

  # Phase B Frozen PINs (immutable truth guarantees)
  - path: docs/memory-pins/PIN-199-pb-s1-retry-immutability.md
    purpose: PB-S1 Retry creates NEW execution
    required: true
    phase: B

  - path: docs/memory-pins/PIN-202-pb-s2-crash-recovery.md
    purpose: PB-S2 Crashed runs never silently lost
    required: true
    phase: B

  - path: docs/memory-pins/PIN-203-pb-s3-controlled-feedback-loops.md
    purpose: PB-S3 Feedback observes but never mutates
    required: true
    phase: B

  - path: docs/memory-pins/PIN-204-pb-s4-policy-evolution-with-provenance.md
    purpose: PB-S4 Policies proposed, never auto-enforced
    required: true
    phase: B

  - path: docs/memory-pins/PIN-205-pb-s5-prediction-without-determinism-loss.md
    purpose: PB-S5 Predictions advise, never influence
    required: true
    phase: B

  # Customer Console Constitution (v1 frozen structure)
  - path: docs/contracts/CUSTOMER_CONSOLE_V1_CONSTITUTION.md
    purpose: Frozen domains, structure, and governance for Customer Console
    required: true
    scope: console.agenticverz.com
    frozen: true
    version: v1

  # Priority-5 Feature Intent (Phase-3 Batch-1 frozen)
  - path: docs/ci/PRIORITY5_INTENT_CANONICAL.md
    purpose: Priority-5 intents are frozen; changes require founder ratification
    required: true
    frozen: true
    ci_guard: priority5-intent-guard
    reference: PIN-265

  # Codebase Registry (artifact registration and purpose tracking)
  - path: docs/codebase-registry/schema-v1.yaml
    purpose: Artifact registration schema (frozen v1)
    required: true

  - path: docs/codebase-registry/change-schema-v1.yaml
    purpose: Code change registration schema (frozen v1)
    required: true

  - path: docs/codebase-registry/README.md
    purpose: Registry scope and governance rules
    required: true

  # Phase G Governance Documents (PERMANENT)
  - path: docs/governance/PHASE_F_CLOSURE_DECLARATION.md
    purpose: Formal closure of Phase F (structural completion certified)
    required: true
    phase: G

  - path: docs/governance/PHASE_G_STEADY_STATE_GOVERNANCE.md
    purpose: Hard rules for steady-state governance (G-RULE-1 to G-RULE-10)
    required: true
    phase: G

  - path: docs/governance/EXECUTIVE_ARCHITECTURE_MAP.md
    purpose: 1-page architecture truth map
    required: true
    phase: G

  - path: docs/governance/HOW_TO_ADD_A_FEATURE.md
    purpose: Compliant feature development guide
    required: true
    phase: G

  # Product Development Contract v3 (Stabilization → Productization)
  - path: docs/contracts/PRODUCT_DEVELOPMENT_CONTRACT_V3.md
    purpose: Phase-ordered productization governance (CI → Console → Lifecycle)
    required: true
    phase: G
    current_phase: 1
    current_phase_name: CI Signal Rediscovery & Stabilization

# =============================================================================
# BLCA VERIFICATION (MANDATORY - BL-BOOT-002)
# =============================================================================
# BLCA must run at session start per G-RULE-1 (BLCA Supremacy).
# Bootstrap is INCOMPLETE without BLCA verification.
#
# Sequence: Load documents → Run BLCA → Confirm bootstrap
# A bootstrap without BLCA is governance-invalid.

blca_verification:
  rule_id: BL-BOOT-002
  name: BLCA Bootstrap Verification
  status: MANDATORY
  severity: BLOCKING

  trigger: session_start

  command: python3 scripts/ops/layer_validator.py --backend --ci

  required_output:
    - "Files scanned:"
    - "Violations found: 0"
    - "Layer architecture is clean."

  on_clean:
    action: PROCEED
    message: "BLCA verification passed. Bootstrap may complete."

  on_violations:
    action: BLOCK
    message: |
      BLCA VERIFICATION FAILED

      Layer violations detected. Bootstrap cannot complete.

      Required action:
      1. Review violations from BLCA output
      2. Fix violations before proceeding
      3. Re-run BLCA until CLEAN

      No work is allowed while BLCA has violations.
      Reference: G-RULE-1 (BLCA Supremacy)

  on_skip:
    action: BLOCK
    message: |
      BLCA VERIFICATION SKIPPED

      Bootstrap is INCOMPLETE without BLCA verification.

      Run: python3 scripts/ops/layer_validator.py --backend --ci

      A bootstrap confirmation without BLCA is governance-invalid.

  bootstrap_sequence:
    step_1: Load all mandatory_load documents
    step_2: Run BLCA verification
    step_3: Run Capability Registry validation (validate-registry + heatmap)
    step_4: Only if BLCA is CLEAN AND registry is valid → provide SESSION_BOOTSTRAP_CONFIRMATION
    step_5: If BLCA has violations OR registry invalid → BLOCK and report (do NOT say "ready")

  # PIN-313: Capability Surveyor Gate (added 2026-01-05)
  capability_registry_gate:
    commands:
      - python3 scripts/ops/capability_registry_enforcer.py validate-registry
      - python3 scripts/ops/capability_registry_enforcer.py heatmap
    on_failure: BLOCK bootstrap
    on_gaps_exist: Claude must acknowledge gaps before proceeding to feature work

# =============================================================================
# GOVERNANCE RELATIONSHIP: CLAUDE_AUTHORITY.md → SESSION_PLAYBOOK
# =============================================================================
# CLAUDE_AUTHORITY.md is the governing PRINCIPLE document.
# SESSION_PLAYBOOK.yaml is the PROCEDURAL implementation.
#
# When conflicts exist: CLAUDE_AUTHORITY.md always wins.
# When procedures are unclear: Refer to CLAUDE_AUTHORITY.md principles.
#
# Reference: PIN-269 (Claude Authority Spine)

governance_relationship:
  authority_document: CLAUDE_AUTHORITY.md
  implementation_document: SESSION_PLAYBOOK.yaml
  supremacy: CLAUDE_AUTHORITY.md wins on conflict

  section_mapping:
    # §1 Order of Precedence → Implicit in mandatory_load order
    authority_section_1:
      name: Order of Precedence
      playbook_implementation: mandatory_load order + supremacy_note
      note: Human > CLAUDE_AUTHORITY > SESSION_PLAYBOOK > PINs > CI > Tests > Code

    # §2 Pre-Flight → pre_build_guards, ARTIFACT_INTENT.yaml
    authority_section_2:
      name: Mandatory Pre-Flight
      playbook_implementation: Section 22 (Architecture Governor)
      templates:
        - docs/templates/NEW_FEATURE_SKELETON.md
        - docs/templates/ARTIFACT_INTENT.yaml

    # §3 Classification → Bucket A/B/C system
    authority_section_3:
      name: Classification Before Fixing
      playbook_implementation: CI bucket markers (@pytest.mark.ci_bucket)
      reference: GU-002 in PIN-268

    # §4 Intent → Section 17 (Transaction Safety), FeatureIntent
    authority_section_4:
      name: Intent Is Not Optional
      playbook_implementation: Section 17 (Transaction Safety + Feature Intent)
      templates:
        - docs/templates/INTENT_BOILERPLATE.md

    # §5 Invariants → invariant tests, docs/invariants/
    authority_section_5:
      name: Invariants Are Sacred
      playbook_implementation: tests/invariants/, docs/invariants/
      enforcement: "@pytest.mark.invariant tests cannot be weakened"

    # §6 Guidance → GU-004 Danger Fences
    authority_section_6:
      name: Guidance Over Punishment
      playbook_implementation: app/infra/danger_fences.py
      reference: GU-004 in PIN-268

    # §7 Artifacts → on_task_completion, artifact hygiene
    authority_section_7:
      name: Artifact Accountability
      playbook_implementation: Section 23 (Artifact Hygiene)
      required_output: Artifacts Created/Modified/Deleted/Governance Updated

    # §8 Freezing → frozen documents, CI guards
    authority_section_8:
      name: Change Freezing & Ratification
      playbook_implementation: frozen fields in mandatory_load, CI guards
      examples:
        - "CLAUDE_AUTHORITY.md (frozen: true, ci_guard: claude-authority-guard)"
        - "PRIORITY5_INTENT_CANONICAL.md (frozen: true)"

    # §9 Evolution → PIN creation, CI guard creation
    authority_section_9:
      name: Evolution Rule
      playbook_implementation: memory_trail.py, CI guard addition
      rule: Every incident produces at least one artifact

    # §10 Final Principle → governance_qualifier section
    authority_section_10:
      name: Final Governing Principle
      playbook_implementation: Section 27 (Governance Qualifier)
      note: Clarity over cleverness, declared intent over inference

  deduplication_note: |
    SESSION_PLAYBOOK sections should not REPEAT CLAUDE_AUTHORITY.md principles.
    SESSION_PLAYBOOK sections should IMPLEMENT or REFERENCE those principles.
    If a playbook section says "X is required", but CLAUDE_AUTHORITY.md says
    "X is not required", CLAUDE_AUTHORITY.md wins.

# =============================================================================
# FORBIDDEN ACTIONS (Before Bootstrap)
# =============================================================================
# These actions are BLOCKED until SESSION_BOOTSTRAP_CONFIRMATION is complete.

forbidden_if_not_loaded:
  - action: phase_testing
    reason: Cannot test without knowing phase constraints

  - action: acceptance_declaration
    reason: Cannot declare acceptance without knowing criteria

  - action: code_changes
    reason: Cannot modify code without knowing invariants

  - action: migration_creation
    reason: Cannot create migrations without knowing schema rules

  - action: api_creation
    reason: Cannot create APIs without knowing visibility contract

  - action: visibility_validation
    reason: Cannot validate visibility without knowing discovery rules

  - action: ui_exposure
    reason: Cannot expose UI without knowing promotion rules

# =============================================================================
# BOOTSTRAP CONFIRMATION FORMAT
# =============================================================================
# Claude's first response MUST match this format exactly.
# Validator rejects any response that doesn't conform.

bootstrap_confirmation_format: |
  SESSION_BOOTSTRAP_CONFIRMATION
  - playbook_version: {version}
  - loaded_documents:
    - CLAUDE_BOOT_CONTRACT.md
    - behavior_library.yaml
    - visibility_contract.yaml
    - visibility_lifecycle.yaml
    - discovery_ledger.yaml
    - database_contract.yaml
    - LESSONS_ENFORCED.md
    - PIN-199-pb-s1-retry-immutability.md
    - PIN-202-pb-s2-crash-recovery.md
    - PIN-203-pb-s3-controlled-feedback-loops.md
    - PIN-204-pb-s4-policy-evolution-with-provenance.md
    - PIN-205-pb-s5-prediction-without-determinism-loss.md
    - CUSTOMER_CONSOLE_V1_CONSTITUTION.md
    - PHASE_G_STEADY_STATE_GOVERNANCE.md
    - GOVERNANCE_CHECKLIST.md
    - codebase-registry/schema-v1.yaml
    - codebase-registry/change-schema-v1.yaml
  - blca_verification:
      command_run: python3 scripts/ops/layer_validator.py --backend --ci
      files_scanned: {count}
      violations_found: 0
      status: CLEAN
  - capability_registry_verification:
      registry_valid: YES
      total_capabilities: {count}
      closed_capabilities: {count}
      gaps_acknowledged: YES
  - visibility_lifecycle_loaded: YES
  - discovery_ledger_loaded: YES
  - database_contract_loaded: YES
  - console_constitution_loaded: YES
  - phase_g_governance_loaded: YES
  - codebase_registry_loaded: YES
  - forbidden_assumptions_acknowledged: YES
  - restrictions_acknowledged: YES
  - phase_family: {family}
  - current_stage: {stage}
  - phase_enforcement:
      visibility_lifecycle: {lifecycle_mode}
      discovery_ledger: {discovery_mode}
      dpcc: {dpcc_mode}
      cseg: {cseg_mode}
      code_registration: ENFORCED
      blca: ENFORCED

# =============================================================================
# PHASE EXTENSIONS
# =============================================================================
# When new phases are added, their frozen PINs go here.
# The playbook is the ONLY file that needs updating.

phase_extensions:
  phase_c:
    # Phase C activates visibility lifecycle
    documents: []
    status: READY
    activates:
      - visibility_lifecycle: LOAD_DETECT_PROPOSE
      - dpcc: BLOCKER
      - cseg: BLOCKER

  phase_d:
    # Phase D enforces full visibility lifecycle
    documents: []
    status: PENDING
    activates:
      - visibility_lifecycle: LOAD_ENFORCE
      - dpcc: BLOCKER
      - cseg: BLOCKER
      - promotion_at_boundary: true

# =============================================================================
# PHASE ENFORCEMENT TABLE
# =============================================================================
# This is the switch that activates DPCC/CSEG properly.
# Validator uses current_stage to determine enforcement severity.

phase_enforcement_table:
  phase_b:
    visibility_lifecycle: LOAD_AND_DECLARE
    eligibility_detection: DISABLED
    dpcc: WARNING
    cseg: DECLARATIVE
    description: "Phase B: Data exists, truth frozen"

  phase_c:
    visibility_lifecycle: LOAD_DETECT_PROPOSE
    eligibility_detection: ENABLED
    dpcc: BLOCKER
    cseg: BLOCKER
    description: "Phase C: Eligibility + proposals active"

  phase_d:
    visibility_lifecycle: LOAD_ENFORCE
    eligibility_detection: ENABLED
    dpcc: BLOCKER
    cseg: BLOCKER
    promotion_at_boundary: true
    description: "Phase D+: Full enforcement"

# =============================================================================
# VALIDATION RULES
# =============================================================================

validation:
  # First response must be bootstrap confirmation
  first_response_must_be_bootstrap: true

  # All mandatory_load documents must be listed in confirmation
  all_documents_required: true

  # Partial loading is rejected
  partial_load_rejected: true

  # Version mismatch is rejected
  version_must_match: true

# =============================================================================
# ENFORCEMENT
# =============================================================================

enforcement:
  behavior_rule: BL-BOOT-001
  validator_script: scripts/ops/session_bootstrap_validator.py

  on_missing_bootstrap:
    action: BLOCK
    message: |
      SESSION BOOTSTRAP REQUIRED

      Your first response must be SESSION_BOOTSTRAP_CONFIRMATION.

      Required format:
      SESSION_BOOTSTRAP_CONFIRMATION
      - playbook_version: 1.0
      - loaded_documents: [list all mandatory documents]
      - restrictions_acknowledged: YES
      - phase_family: [A/B/C]
      - current_stage: [A5/B1/C1/C2/C3]

      No work is allowed until bootstrap is complete.

  on_partial_load:
    action: BLOCK
    message: |
      INCOMPLETE BOOTSTRAP

      Missing documents: {missing}

      All documents in SESSION_PLAYBOOK.yaml must be loaded.
      Partial loading is not allowed.

# =============================================================================
# FORBIDDEN ASSUMPTIONS (Critical - Prevents Architecture Invention)
# =============================================================================
# Claude must not invent architecture.
# If something is not explicitly declared, it must be treated as UNKNOWN and BLOCKED.
#
# These assumptions have caused real failures and are now mechanically forbidden.

forbidden_assumptions:

  - id: FA-001
    name: api_prefix_based_console_separation
    description: Assuming consoles are separated by API prefix (/api/ops)
    correct_model: Consoles are separated by SUBDOMAIN + AUTH AUDIENCE
    reference: PIN-190, visibility_contract.yaml

  - id: FA-002
    name: localhost_database_fallback
    description: Using localhost as default when DATABASE_URL not set
    correct_model: DATABASE_URL must be explicitly set, hard fail if missing
    reference: database_contract.yaml

  - id: FA-003
    name: app_db_import_outside_backend_runtime
    description: Importing from app.db in scripts/validators
    correct_model: Scripts use psycopg2 + explicit DATABASE_URL
    reference: database_contract.yaml

  - id: FA-004
    name: implicit_environment_detection
    description: Inferring database/config from environment markers
    correct_model: All config must be explicit via environment variables
    reference: database_contract.yaml

  - id: FA-005
    name: data_partitioned_by_console
    description: Assuming different consoles see different data subsets
    correct_model: Same data, different visibility rules per console
    reference: visibility_contract.yaml

  - id: FA-006
    name: visibility_without_discovery
    description: Exposing data to UI without discovery ledger entry
    correct_model: Discovery must precede visibility (DPC check)
    reference: discovery_ledger.yaml

forbidden_assumptions_enforcement: |
  If Claude introduces any forbidden assumption:
  - Response is INVALID
  - SELF-AUDIT must catch it before output
  - Validator blocks execution

# =============================================================================
# NEGATIVE DESIGN RULES (What Must NEVER Happen)
# =============================================================================
# These encode the implicit boundaries that Claude must respect.
# Violation of any rule invalidates the response.

negative_design_rules:

  - id: NDR-001
    rule: Database must never encode visibility or console logic
    reason: Visibility is declarative (contract), not data-driven
    enforcement: Code review, schema audit

  - id: NDR-002
    rule: Validators must never import backend runtime modules
    reason: Creates implicit coupling and split-brain potential
    enforcement: Import pattern check

  - id: NDR-003
    rule: Discovery systems must never mutate execution data
    reason: Discovery observes, execution decides
    enforcement: DB trigger, code review

  - id: NDR-004
    rule: Consoles must never be inferred from routes
    reason: Console topology is subdomain + auth, not URL path
    enforcement: visibility_validator.py

  - id: NDR-005
    rule: Scripts must never have default database URLs
    reason: Prevents split-brain where script uses wrong DB
    enforcement: database_contract.yaml

  - id: NDR-006
    rule: Historical data must never be mutated
    reason: Truth-grade system, immutability is constitutional
    enforcement: DB triggers, LESSONS_ENFORCED.md

# =============================================================================
# AUTHORITY DECLARATION (Required for System-Level Changes)
# =============================================================================
# Claude must declare where truth comes from before coding.
# This prevents choosing the wrong authority source.

authority_declaration:
  required_for:
    - system_level_changes
    - database_operations
    - visibility_changes
    - console_modifications

  format: |
    AUTHORITY_DECLARATION
    - Data truth source: [Neon DB / Local DB / explicit]
    - Access control source: [Auth audience / visibility_contract.yaml]
    - Visibility source: [visibility_contract.yaml]
    - Phase rules source: [SESSION_PLAYBOOK.yaml]
    - Database contract: [database_contract.yaml]

  enforcement: |
    If authority declaration is missing for system-level change → BLOCK
    If code contradicts declared authority → BLOCK

# =============================================================================
# UPGRADED SELF-AUDIT (Mandatory for All Code Changes)
# =============================================================================
# Forces Claude to self-reject before output.

upgraded_self_audit:
  required_for: all_code_changes

  format: |
    SELF-AUDIT
    - Did I verify current DB and migration state? YES / NO
    - Did I read memory pins and lessons learned? YES / NO
    - Did I introduce new persistence? YES / NO
    - Did I risk historical mutation? YES / NO
    - Did I assume any architecture not explicitly declared? YES / NO
    - Did I reuse backend internals outside runtime? YES / NO
    - Did I introduce an implicit default (DB, env, routing)? YES / NO
    - If YES to any risk → mitigation: <explain>
    - If YES to last three → response is INVALID, must redesign

  enforcement: |
    If any "YES" without mitigation → BLOCK
    If last three are "YES" → Response INVALID, redesign required

# =============================================================================
# TRUTH ANCHOR
# =============================================================================

truth_anchor: |
  Memory decays. Contracts don't.
  Sessions must boot like systems, not humans.

  LLMs fail where constraints are implicit.
  Make the implicit illegal, and the failures disappear.

# =============================================================================
# SECTION 9: PHASE FAMILY & EXECUTION STAGE
# =============================================================================
# Two distinct concepts:
#   - phase_family: What kind of system are we building? (A/B/C)
#   - current_stage: What is currently allowed to exist? (C1/C2/C3)
#
# Phase families are eras. Stages are sequential gates within an era.
# C1 certified = frozen invariant, not "current location".

system_state:
  # Phase Family: Which era are we in?
  # A = Truth & Determinism, B = Control & Resilience, C = Learning & Optimization
  # D = Visibility & Discovery, E = Semantic Closure, F = Structural Closure
  # G = Steady-State Governance (PERMANENT)
  phase_family: G

  # Current Stage: What behavior is currently allowed?
  current_stage: G_STEADY_STATE

  # Stage Status: Each stage is a gate, not a mode
  stages:
    A5_CLOSURE: FROZEN       # Truth-grade certification complete (binding forever)
    C1_TELEMETRY: CERTIFIED  # Telemetry plane certified 2025-12-27 (frozen invariant)
    C2_PREDICTION: CERTIFIED # Prediction plane certified 2025-12-28 (sealed, O4 governance frozen)
    C3_OPTIMIZATION: CERTIFIED # Optimization safety certified 2025-12-28 (S1/S2/S3 - 69 tests)
    C4_COORDINATION: CERTIFIED # Multi-envelope coordination certified 2025-12-28 (14 tests, 83 total)
    C5_LEARNING: CERTIFIED   # Learning & Evolution - certified 2025-12-28
    C5_S1_ROLLBACK: CERTIFIED # Learning from Rollback Frequency certified 2025-12-28 (27 tests)
    C5_S2_FRICTION: FROZEN       # Learning from Coordination Friction frozen 2025-12-28
    C5_S3_EFFECTIVENESS: FROZEN  # Learning from Optimization Effectiveness frozen 2025-12-28
    D_VISIBILITY: CERTIFIED  # Visibility & Discovery certified 2025-12-30
    E_SEMANTIC: CERTIFIED    # Semantic Closure certified 2025-12-31 (domain extractions complete)
    F_STRUCTURAL: CERTIFIED  # Structural Closure certified 2025-12-31 (BLCA = 0)
    G_STEADY_STATE: ACTIVE   # Steady-State Governance - PERMANENT REGIME

  rule:
    - No stage transition is implicit
    - Any stage unlock requires explicit human approval
    - Presence of code does not imply stage readiness
    - CERTIFIED stages remain binding invariants, not "previous locations"
    - FROZEN = design locked, implementation requires explicit unlock
    - Phase G is PERMANENT - no successor phase exists
    - G-RULE-1 through G-RULE-10 are HARD rules with no exceptions
    - BLCA supremacy is absolute - violations block all work

  # Subsystem Closures: Constitutional subsystems with phase-locked invariants
  # Any change touching these systems must reference their closure tag.
  subsystem_closures:
    platform_health_v1:
      pin: PIN-284
      tag: platform-health-v1
      closed: "2026-01-04"
      status: PHASE_1_CLOSED
      scope: "Founder-only Platform Health Monitoring"
      invariants:
        - HEALTH-IS-AUTHORITY
        - HEALTH-LIFECYCLE-COHERENCE
        - HEALTH-DETERMINISM
        - NO-PHANTOM-HEALTH
        - DOMINANCE-ORDER
      frozen_files:
        - backend/app/services/platform/platform_health_service.py
        - backend/app/adapters/platform_eligibility_adapter.py
        - backend/app/api/platform.py
        - scripts/ci/health_lifecycle_coherence_guard.py
        - scripts/ci/backend_structure_guard.py
        - backend/tests/invariants/test_platform_health_determinism.py
      reference:
        - docs/governance/PHASE_1_CLOSURE_NOTE.md
        - docs/governance/BACKEND_STRUCTURE_FREEZE.yaml
      rule: >
        Any change touching health, lifecycle, or governance signals
        must explicitly reference tag platform-health-v1 and declare
        whether it EXTENDS, AMENDS, or VIOLATES Phase-1 guarantees.

# =============================================================================
# SECTION 10: AUTHORITATIVE ENVIRONMENT (GLOBAL)
# =============================================================================
# This is the "where is truth" section. Phase-agnostic.

authoritative_environment:
  name: neon
  description: >
    Neon Postgres is the single authoritative environment
    for all certification-grade testing, verification,
    replay guarantees, and evidence.
  rules:
    - All real-scenario tests must run on Neon first
    - All certification evidence must reference Neon
    - Localhost is never authoritative

fallback_environment:
  name: localhost
  allowed_use:
    - destructive testing
    - chaos experiments
    - cost/performance fallback when Neon blocked
  restrictions:
    - Evidence is supplementary only
    - Cannot be used for certification claims
    - Must be explicitly declared when used

# =============================================================================
# SECTION 11: CANONICAL TESTING PRINCIPLES (P1-P6)
# =============================================================================
# These are LAWS, not guidelines. Violation invalidates results.

testing_principles:

  P1_real_scenarios:
    rule: >
      All new phases or features must first be tested
      using real scenarios against real infrastructure.
    enforcement:
      - Scenarios defined explicitly
      - No mocks for initial verification

  P2_real_execution_by_claude:
    rule: >
      Claude must execute tests using real LLMs,
      real databases, and real services.
    enforcement:
      - No simulated responses
      - No fabricated results

  P3_full_data_propagation:
    rule: >
      Data propagation must be verified across all
      relevant modules and planes.
    enforcement:
      - Execution → persistence → downstream consumers
      - Absence of data must be explicitly proven if expected

  P4_ui_propagation_O_levels:
    rule: >
      API-level propagation must be verified for
      all applicable UI layers (O1-O4).
    enforcement:
      - O-level applicability declared per phase
      - UI reachability not required for API verification

  P5_human_semantic_verification:
    rule: >
      Final semantic verification of user-facing consoles
      must be performed by a human.
    enforcement:
      - Claude cannot self-certify meaning
      - Code-based verification allowed only if UI access blocked

  P6_localhost_fallback_only:
    rule: >
      Localhost may be used only when Neon testing
      is blocked by cost, performance, or risk.
    enforcement:
      - Fallback must be explicitly declared
      - Localhost evidence is never authoritative

# =============================================================================
# SECTION 12: INFRASTRUCTURE AUTHORITY MAP
# =============================================================================
# What each infrastructure component is allowed to do.

infrastructure_authority:

  neon_postgres:
    role: authoritative_truth
    allowed_for:
      - Truth tables (runs, traces, executions)
      - Telemetry tables (C1)
      - Prediction events (advisory, persisted) (C2+)
      - Replay guarantees
      - Memory pins
    forbidden_for:
      - Ephemeral-only signals (use Redis)

  upstash_redis:
    role: advisory_cache
    allowed_for:
      - Rolling aggregates
      - Sliding windows
      - Prediction acceleration
      - UI performance caching
    forbidden_for:
      - Truth storage
      - Enforcement decisions
      - Control paths
      - Replay
      - Memory
    invariant:
      - Redis loss must not change system behavior
      - Redis is never authoritative

# =============================================================================
# SECTION 13: PHASE TRANSITION RULES
# =============================================================================
# What is required to move between phases.

phase_transitions:

  C1_to_C2:
    status: COMPLETE
    required_artifacts:
      - PIN-220 (C2 Entry Conditions)
    required_verification:
      - Real scenario tests on Neon
      - Propagation verification (modules + O-levels)
      - Human semantic verification
    explicit_unlock_phrase: "C2 entry conditions approved"
    completion_date: 2025-12-28

  C2_to_C3:
    status: COMPLETE
    completion_date: 2025-12-28
    required_artifacts:
      - PIN-225 (C3 Entry Conditions) ✅
      - C3_OPTIMIZATION_SAFETY_CONTRACT.md ✅
      - C3_ENVELOPE_ABSTRACTION.md ✅
      - C3_KILLSWITCH_ROLLBACK_MODEL.md ✅
    required_verification:
      - Kill switch design agreed ✅
      - Optimization envelope abstraction designed ✅
      - Rollback model documented ✅
    invariants:
      - I-C3-1: Predictions influence via declared envelopes only
      - I-C3-2: Every change is bounded (impact + time)
      - I-C3-3: All influence is reversible
      - I-C3-4: Human override always wins
      - I-C3-5: Replay without predictions = baseline behavior
      - I-C3-6: Optimization failure never creates incidents
    explicit_unlock_phrase: "C3 entry conditions approved"
    approved_by: human
    approved_at: 2025-12-28

  C3_to_C4:
    status: COMPLETE
    completion_date: 2025-12-28
    required_artifacts:
      - PIN-230 (C4 Entry Conditions) ✅
      - C4_COORDINATION_AUDIT_SCHEMA.md ✅
    required_verification:
      - Multi-envelope coordination tests (14 tests) ✅
      - Priority preemption verified ✅
      - Same-parameter rejection verified ✅
      - Kill-switch supremacy verified ✅
      - Audit persistence verified ✅
    invariants:
      - I-C4-1: Kill-switch always wins
      - I-C4-2: Coordination is required for overlapping changes
      - I-C4-3: Priority is immutable during decision
      - I-C4-4: Same-parameter changes are rejected
      - I-C4-5: All coordination decisions are audited
      - I-C4-6: Replay produces identical decisions
    explicit_unlock_phrase: "C4 entry conditions approved"
    approved_by: human
    approved_at: 2025-12-28

  C4_to_C5_S1:
    status: COMPLETE
    completion_date: 2025-12-28
    required_artifacts:
      - PIN-232 (C5 Entry Conditions) ✅
      - C5_S1_LEARNING_SCENARIO.md ✅
      - C5_S1_ACCEPTANCE_CRITERIA.md ✅
      - C5_S1_CI_ENFORCEMENT.md ✅
      - C5_CI_GUARDRAILS_DESIGN.md ✅
    required_verification:
      - Unit tests (27/27 PASS) ✅
      - CI guardrails (6/6 PASS) ✅
      - Acceptance criteria (46/46 PASS) ✅
      - C5 invariants verified (I-C5-1 to I-C5-8) ✅
    invariants:
      - I-C5-1: Learning suggests, humans decide
      - I-C5-2: No learned change applies without approval
      - I-C5-3: Learning operates on metadata, not runtime
      - I-C5-4: All learned suggestions are versioned
      - I-C5-5: Learning can be disabled without affecting coordination
      - I-C5-6: Kill-switch supremacy is unchanged
      - I-C5-7: Learned policies are replayable
      - I-C5-8: No autonomous policy mutation
    explicit_unlock_phrase: "C5-S1 certification approved"
    approved_by: human
    approved_at: 2025-12-28
    certification_statement: "Learning suggests. Humans decide. Systems apply."

  C5_DESIGN_SURFACE:
    status: COMPLETE
    completion_date: 2025-12-28
    description: >
      C5 design surface is complete. All three learning scenarios have
      been designed with frozen acceptance criteria and CI guardrails.
      Implementation remains LOCKED for S2/S3.
    scenarios:
      S1_ROLLBACK:
        question: "Are bounds too aggressive?"
        status: CERTIFIED
        tests: 27
        guardrails: 6/6
      S2_FRICTION:
        question: "Are envelopes structurally conflicting?"
        status: FROZEN
        frozen_date: 2025-12-28
        design_docs:
          - C5_S2_LEARNING_SCENARIO.md
          - C5_S2_ACCEPTANCE_CRITERIA.md
      S3_EFFECTIVENESS:
        question: "Did the envelope help?"
        status: FROZEN
        frozen_date: 2025-12-28
        design_docs:
          - C5_S3_LEARNING_SCENARIO.md
          - C5_S3_ACCEPTANCE_CRITERIA.md
        key_constraint: "No thresholds, no rankings, no recommendations"
    shared_invariants:
      - I-C5-1: Learning suggests, humans decide
      - I-C5-2: No learned change applies without approval
      - I-C5-3: Learning operates on metadata, not runtime
      - I-C5-4: All learned suggestions are versioned
      - I-C5-5: Learning can be disabled without affecting coordination
      - I-C5-6: Kill-switch supremacy is unchanged
      - I-C5-7: Learned policies are replayable
      - I-C5-8: No autonomous policy mutation
    core_principle: "Learning suggests. Humans decide. Systems apply."
    implementation_gate: "Explicit unlock required for S2/S3 implementation"

  general_rules:
    - Presence of code does not imply phase readiness
    - Experiments are subject to the same gates
    - Certification is a frozen boundary, not a milestone to build on casually

# =============================================================================
# SECTION 14: SESSION RESTART SAFETY
# =============================================================================
# What MUST happen when a session restarts.

on_session_restart:
  mandatory_steps:
    - Read system_state.phase_family
    - Read system_state.current_stage
    - Read authoritative_environment
    - Read testing_principles
    - Read execution_discipline (including auth_contract)
    - Read API_CALL_TEMPLATE.md for auth pattern
    - Confirm auth context before any API calls
    - Confirm allowed infra for current phase
    - List allowed_actions for current phase
    - List forbidden_actions for current phase

  mandatory_confirmations:
    - auth_header_format_known       # X-AOS-Key: <API_KEY>
    - api_call_template_loaded       # docs/execution/API_CALL_TEMPLATE.md
    - preflight_required             # scripts/preflight/check_auth_context.sh
    - public_paths_known             # Know which paths don't need auth

  refusal_policy:
    if_action_violates_phase_or_principles:
      action: refuse
      response: >
        This action violates the current phase or
        canonical testing principles. Cannot proceed.

    if_execution_rules_violated:
      action: refuse
      response: >
        Execution violates shell/credential discipline.
        Provide stepwise, verifiable commands instead.

# =============================================================================
# SECTION 14.5: SESSION CONTINUATION FROM SUMMARY
# =============================================================================
# What MUST happen when a session is continued from a summarized context.
#
# CRITICAL: This closes the governance gap where "continue without asking"
# was interpreted as permission to skip bootstrap and code governance.
#
# Root Cause (PIN-052 incident 2025-12-30):
#   - Session ran out of context and was summarized
#   - Continuation instruction said "continue without asking questions"
#   - This conflicted with bootstrap which requires confirmation
#   - Claude prioritized continuation over governance
#   - Result: 4 files modified, 2 files created WITHOUT registry entries
#
# Fix: Explicit rules for summarized continuation that do NOT conflict
#      with the "don't ask questions" instruction.

on_session_continuation_from_summary:

  trigger_phrases:
    - "This session is being continued from a previous conversation"
    - "conversation that ran out of context"
    - "The conversation is summarized below"

  interpretation_rule: >
    The instruction "continue without asking the user any further questions"
    applies to CLARIFYING questions about requirements, NOT to governance
    confirmations. Governance acknowledgment is MANDATORY, not optional.

  mandatory_acknowledgment:
    # Claude must include this block in the FIRST response after continuation
    format: |
      SESSION_CONTINUATION_ACKNOWLEDGMENT
      - governance_active: YES
      - code_reg_rules: ACKNOWLEDGED (CODE-REG-001 to CODE-REG-004)
      - code_change_rules: ACKNOWLEDGED (CODE-CHANGE-001 to CODE-CHANGE-003)
      - self_audit_required: YES (for all code changes)
      - phase_family: {current phase}

    required_fields:
      - governance_active: must be YES
      - code_reg_rules: must be ACKNOWLEDGED
      - code_change_rules: must be ACKNOWLEDGED
      - self_audit_required: must be YES

  pre_code_gates:
    # These gates apply EVEN in continuation mode
    - gate: CODE-REG-001
      rule: New files require artifact registration
      action: BLOCK if not registered

    - gate: CODE-CHANGE-001
      rule: Modified files require change records
      action: BLOCK if no change record

    - gate: SELF-AUDIT
      rule: All code changes require SELF-AUDIT section
      action: Response INVALID if missing

  what_can_be_skipped:
    # These are OK to skip in continuation (lighter than full bootstrap)
    - Full SESSION_BOOTSTRAP_CONFIRMATION (use lighter acknowledgment)
    - Re-reading all mandatory_load documents (context preserved in summary)
    - Phase transition checks (phase preserved in summary)

  what_cannot_be_skipped:
    # These are NEVER skippable, even in continuation
    - CODE-REG gates (artifact registration)
    - CODE-CHANGE gates (change records)
    - SELF-AUDIT on code changes
    - ARCH-GOV gates (layer, temporal, ownership)
    - Forbidden assumptions check

  refusal_policy:
    if_about_to_create_code_without_registration:
      action: STOP
      response: |
        CODE-REG-001 VIOLATION: Cannot create file without artifact registration.

        Before creating {filename}, I need to:
        1. Create artifact intent: docs/codebase-registry/artifacts/AOS-XX-XXX-XXX-NNN.yaml
        2. Get approval for registration
        3. Then create the file

        Proceeding with registration proposal...

    if_about_to_modify_code_without_change_record:
      action: STOP
      response: |
        CODE-CHANGE-001 VIOLATION: Cannot modify file without change record.

        Before modifying {filename}, I need to:
        1. Create change record: docs/codebase-registry/changes/CHANGE-YYYY-NNNN.yaml
        2. Reference artifact ID: {artifact_id}
        3. Then make the modification

        Proceeding with change record creation...

  # Reference documents for session summary generation
  summary_requirements:
    document: docs/system/SESSION_SUMMARY_REQUIREMENTS.md
    purpose: Ensure session summaries preserve governance context
    mandatory_elements:
      - GOVERNANCE_CONTEXT_PRESERVED block
      - PENDING_REGISTRATIONS if any
      - PENDING_CHANGES if any
      - INCOMPLETE_GATES if any
      - CONTINUATION_INSTRUCTION_INTERPRETATION

# =============================================================================
# SECTION 15: HUMAN VS AUTOMATION BOUNDARY
# =============================================================================
# What CI can and cannot verify.

verification_boundaries:

  ci_can_verify:
    - Schema constraints
    - Forbidden imports
    - Delete safety
    - Invariant preservation
    - Type checking
    - Test execution

  ci_cannot_verify:
    - UI semantics (meaning of labels)
    - Language implying authority vs advisory
    - User interpretation
    - Subjective design decisions

  rule:
    - Any user-facing semantic change requires human review
    - CI passing does not mean phase complete

# =============================================================================
# SECTION 16: ANTI-DRIFT SAFEGUARDS
# =============================================================================
# Explicit rules to prevent future regression.

anti_drift_rules:
  - No "temporary" bypass of principles
  - No experimental code outside phase gates
  - No refactor justified solely by certification completion
  - If a change feels "obviously fine", re-check principles
  - Redis convenience must never become Redis dependency

meta_rule: >
  "If a future change feels 'obviously fine', it probably bypasses a principle."

# =============================================================================
# SECTION 17: EXECUTION DISCIPLINE
# =============================================================================
# Governs HOW commands are constructed and executed.
# Prevents shell synthesis, credential assumptions, and log over-interpretation.

execution_discipline:

  shell_commands:
    rules:
      - No eval usage
      - No nested command substitution
      - No inline env extraction (e.g. $(grep ...))
      - Commands must be copy-paste safe
      - Multi-step operations must be explicit separate commands
    required_structure:
      - Explicit export commands first
      - Then execution commands second
      - Each step verifiable independently
    forbidden_patterns:
      - "$("           # nested substitution
      - "eval"         # dynamic evaluation
      - backslash-escaped URLs
      - multi-line one-liners with mixed quoting
    correct_pattern: |
      # Step 1: load env explicitly
      export AOS_API_KEY="xxxxxxxx"

      # Step 2: verify
      echo "$AOS_API_KEY" | wc -c

      # Step 3: execute
      curl -X POST \
        -H "X-AOS-Key: $AOS_API_KEY" \
        "http://localhost:8000/api/v1/endpoint"

  credentials:
    rules:
      - Never assume credentials exist
      - Always verify auth context before API calls
      - Auth failures must be handled explicitly
    required_steps:
      - Explicit env check (verify variable is set)
      - Explicit header construction (visible, not interpolated)
      - Explicit auth failure handling (check response code)
    forbidden_assumptions:
      - "env is loaded"
      - "headers are correct"
      - "auth context exists"

  infra_assumptions:
    rules:
      - Logs do not imply relevance
      - Infra services may be present but unused
      - Redis presence ≠ Redis usage allowed
      - Service availability ≠ service authorization
    invariant:
      - Presence of logs does not override guardrails

  log_interpretation:
    rules:
      - Logs indicate availability, not usage
      - Connection logs do not imply feature usage
      - Noise must be filtered, not inferred from
    invariant:
      - Presence of logs does not override guardrails
      - redis_connected log does NOT mean C2 uses Redis

  auth_contract:
    description: >
      Environment variables are NOT credentials until explicitly mapped to HTTP headers.
      The chain is: .env → Shell env → HTTP header → RBAC middleware.
      Claude must bridge ALL layers explicitly.
    invariant:
      - HTTP calls must explicitly construct auth headers
      - Environment variables are not credentials until mapped
      - source .env does NOT imply authentication
      - shell context does NOT imply RBAC context
    canonical_template: docs/execution/API_CALL_TEMPLATE.md
    preflight_script: scripts/preflight/check_auth_context.sh
    frozen_header_format: "X-AOS-Key: <API_KEY>"
    public_paths:
      - /health
      - /metrics
      - /api/v1/auth/
      - /api/v1/c2/predictions/
      - /docs
      - /openapi.json
      - /redoc

  refusal_policy:
    missing_auth_header:
      trigger: API call without explicit -H header visible in command
      action: refuse
      message: >
        Auth header not explicitly constructed.
        Use canonical API_CALL_TEMPLATE.md pattern.
        Run preflight: ./scripts/preflight/check_auth_context.sh
    assumed_auth_context:
      trigger: Assuming source .env implies auth is working
      action: refuse
      message: >
        Environment variables are not credentials until mapped to HTTP headers.
        Explicit header required: -H "X-AOS-Key: $AOS_API_KEY"

# =============================================================================
# SECTION 18: CONSOLE GOVERNANCE (Customer Console v1)
# =============================================================================
# Frozen structure for Customer Console. Claude is auditor and mapper, not designer.
# Reference: docs/contracts/CUSTOMER_CONSOLE_V1_CONSTITUTION.md

console_governance:

  scope: console.agenticverz.com
  status: FROZEN
  version: v1
  effective_date: 2025-12-29

  # Frozen Domains (MUST appear exactly as written)
  frozen_domains:
    - Overview
    - Activity
    - Incidents
    - Policies
    - Logs

  domain_questions:
    Overview: "Is the system okay right now?"
    Activity: "What ran / is running?"
    Incidents: "What went wrong?"
    Policies: "How is behavior defined?"
    Logs: "What is the raw truth?"

  sidebar_structure:
    core_lenses:
      position: top
      items:
        - Overview
        - Activity
        - Incidents
        - Policies
        - Logs
      rule: Primary mental model, stable over time

    connectivity:
      position: middle
      items:
        - Integrations
        - API Keys
      rule: Standard utilities only, not analytical views

    account:
      position: secondary  # Top-right dropdown or footer, NOT primary sidebar
      is_domain: false
      items:
        - Projects
        - Users
        - Profile
        - Billing
        - Support
      rules:
        - Account is NOT a domain
        - Account pages must NOT display executions, incidents, policies, or logs
        - Account manages who, what, and billing - not what happened
        - Matches: Cloudflare Account Home, GitHub Org Settings, AWS Account Settings

  structural_hierarchy:
    domain:
      definition: Answers a fundamental user question
      lifespan: years
      location: sidebar only
    subdomain:
      definition: Represents a real system boundary
      rule: Owns independent lifecycle, distinct permissions
      location: tabs or sections within domain
    topic:
      definition: View or capability (O1 entry point)
      rule: Safe to add without changing domain structure
      location: page content within subdomain
    orders:
      O1: Summary / Snapshot
      O2: List of instances
      O3: Detail / Explanation
      O4: Context / Impact
      O5: Raw records / Proof
      rule: Sidebar never changes with depth

  jurisdiction:
    customer_console:
      scope: tenant_only
      sees:
        - Own executions
        - Own incidents
        - Own policies
        - Own spend
        - Own logs
    exclusions:
      - Founder Pulse (cross-tenant → Ops Console)
      - Discovery Ledger (learning system → Ops Console)
      - Chaos Corpus (testing → Ops Console)
      - Cross-tenant intelligence (multi-tenant → Ops Console)
      - Learned authority (forbidden)
      - Auto-enforcement (forbidden)

  # Project Scope Rules (v1.1.0)
  project_scope:
    description: >
      All Customer Console domains, topics, and Orders (O1–O5) are evaluated
      within a selected Project context. Project is a global scope selector.
    rules:
      - All Customer Console analysis must assume a selected Project context
      - Domains, topics, and Orders are invariant across projects
      - Project selection affects data scope only, never navigation structure
      - Projects must not be introduced as domains or sidebar items
      - Cross-project aggregation is forbidden in Customer Console analysis
      - Shared resources (policies, agents) must be evaluated per-project view
    project_selector:
      location: global_header
      not_in: sidebar
    project_container:
      managed_under: ADMIN
      not_domain: true
    shared_resources:
      policies: "May be ORG-scoped (all projects) or PROJECT-scoped"
      agents: "May be bound to multiple projects"
      executions: "Always project-scoped"
      incidents: "Attach to executions → always project-scoped"

  claude_role:
    allowed:
      - Validate existence of objects and flows in codebase
      - Report fits, gaps, partial fits, and violations
      - Map existing code to approved domains and topics
      - Generate drafts for human review
      - Flag deviations explicitly
    not_allowed:
      - Introducing new domains
      - Renaming frozen domains
      - Mixing customer and founder jurisdictions
      - Suggesting automation or learned authority
      - Auto-applying structural changes
      - Improving without explicit approval

  governance_rules:
    - No global automation
    - No learned authority
    - No cross-tenant intelligence claims
    - No "system decided" language
    - All actions must be explicit, scoped, attributable, auditable
    - Logs and evidence are immutable

  deviation_protocol:
    on_deviation:
      - Explicitly flag what deviates
      - Clearly justify with evidence
      - Do not apply automatically
      - Require human approval
    amendment_process:
      - Proposal documented with rationale
      - Impact assessment on existing structure
      - Human review and approval
      - Version increment
      - Playbook updates
      - Behavior rule updates

  forbidden_actions:
    - Rename frozen domains
    - Add new domains without amendment
    - Merge domains
    - Mix jurisdictions
    - Auto-apply learned patterns

  failure_mode_to_avoid: |
    "Claude-suggested improvement" that silently mutates product identity.

  validation:
    on_console_work:
      required_check: constitution_loaded
      failure_response: |
        CONSOLE WORK BLOCKED

        Customer Console Constitution not loaded.
        Load docs/contracts/CUSTOMER_CONSOLE_V1_CONSTITUTION.md first.

        No console work allowed until constitution is acknowledged.

# =============================================================================
# SECTION 19: FRONTEND ARCHITECTURE INVARIANTS
# =============================================================================
# Frozen architectural decisions for frontend products.
# Reference: PIN-235 (Products-First Architecture Migration)

frontend_architecture:

  scope: website/aos-console/console
  status: FROZEN
  version: v1
  effective_date: 2025-12-29
  reference: docs/memory-pins/PIN-235-products-first-architecture-migration.md

  # -----------------------------------------------------------------------------
  # FRONTEND-ARCH-001: Frontend Architecture Invariants
  # -----------------------------------------------------------------------------
  # Violations are BLOCKING - no code changes allowed until compliant.

  FRONTEND-ARCH-001:
    name: Frontend Architecture Invariants
    severity: BLOCKING
    description: >
      Enforces the 3-layer entry point model and products-first folder structure.
      These decisions are frozen and must not be debated.

    # Freeze Point #1: Entry Point Pattern
    freeze_point_1:
      name: Product Entry Pattern
      rule: |
        main.tsx        = runtime entry (DOM, browser)
        AIConsoleApp.tsx = product root (providers, routing)
      invariants:
        - No business logic in main.tsx
        - No DOM mounting in product code
        - Product root handles providers, routing, layout
        - Entry point handles BrowserRouter only (for standalone)

    # Freeze Point #2: Product Folder Layout
    freeze_point_2:
      name: Product Folder Layout
      rule: |
        All Agenticverz products must follow this structure:
        products/{product-name}/
          main.tsx
          app/
          pages/
          account/
          integrations/
      allowed_products:
        - ai-console
        - agents (future)
        - product-builder (future)

    # Freeze Point #3: Domain → Folder Mapping
    freeze_point_3:
      name: Domain to Folder Mapping
      rule: |
        Overview   → pages/overview
        Activity   → pages/activity
        Incidents  → pages/incidents
        Policies   → pages/policies
        Logs       → pages/logs
      enforcement: No aliases. No exceptions.

    # Import Pattern
    import_pattern:
      correct: |
        import { guardApi } from '@/api/guard';
        import { OverviewPage } from '@ai-console/pages/overview/OverviewPage';
      wrong: |
        import { guardApi } from '../../api/guard';
        import { OverviewPage } from '../pages/overview';

    # Anti-Patterns (FORBIDDEN)
    anti_patterns:
      - description: "Reorganize Orders (O2-O5) into folders"
        reason: "Orders are epistemic depth, not folder structure"
      - description: "Merge account + pages"
        reason: "Account is secondary navigation, pages are core domains"
      - description: "Move providers into main.tsx"
        reason: "Providers belong in product root, not runtime entry"
      - description: "Add a global Admin folder"
        reason: "Admin is not a domain, it manages users/billing"
      - description: "Rename AIConsoleApp again"
        reason: "Name is frozen, reflects product identity"

    triggers:
      - Any change to src/products/*/main.tsx
      - Any change to src/products/*/app/*.tsx
      - Any new product folder creation
      - Any page relocation or rename
      - Any import path changes in products folder

    requires:
      step_1:
        action: "Verify entry point separation"
        check: "Is main.tsx runtime-only? Is product logic in app/?"
      step_2:
        action: "Verify folder structure"
        check: "Does structure match freeze_point_2?"
      step_3:
        action: "Verify domain mapping"
        check: "Do page folders match freeze_point_3?"
      step_4:
        action: "Verify import patterns"
        check: "Are imports using @ai-console/* or @/ aliases?"

    forbid:
      - Adding business logic to main.tsx
      - Creating non-standard product folder structures
      - Using relative imports in products folder
      - Renaming frozen domains
      - Creating new folder patterns without approval

    violation:
      type: BLOCKING
      message: "FRONTEND-ARCH-001 VIOLATION: Architecture invariant violated"
      action: "STOP. Verify compliance with PIN-235 freeze points."

  # -----------------------------------------------------------------------------
  # FRONTEND-INTEGRATION-001: Frontend Integration Completeness Check
  # -----------------------------------------------------------------------------
  # Pre-deploy smoke check to prevent dead clicks and 500 errors.

  FRONTEND-INTEGRATION-001:
    name: Frontend Integration Completeness Check
    severity: BLOCKING
    description: >
      Ensures all frontend changes are complete before deployment.
      Prevents dead clicks, 500 errors, and broken routes.

    triggers:
      - Any new page added
      - Any route change
      - Any navigation item added
      - Any API integration added
      - Before any frontend deployment

    pre_deploy_checklist:
      routes:
        - action: "Route exists in AIConsoleApp.tsx"
          check: "New page has <Route path=... element=... />"
        - action: "Route is accessible"
          check: "Navigating to route renders page, not 404"

      navigation:
        - action: "Nav item links to valid route"
          check: "Clicking nav item navigates, not dead click"
        - action: "Active state reflects current route"
          check: "Correct nav item highlighted when on page"

      api_integration:
        - action: "API endpoints exist"
          check: "All fetch/axios calls hit real endpoints"
        - action: "Error states handled"
          check: "API errors show user-friendly message, not crash"
        - action: "Loading states implemented"
          check: "User sees loading indicator during fetch"

      imports:
        - action: "All imports resolve"
          check: "npm run build succeeds with no import errors"
        - action: "Path aliases work"
          check: "@ai-console/* and @/* aliases resolve correctly"

    requires:
      step_1:
        action: "Run build verification"
        command: "cd website/aos-console/console && npm run build"
        condition: "Build succeeds without errors"
      step_2:
        action: "Check route completeness"
        check: "Every sidebar nav item has corresponding route"
      step_3:
        action: "Verify no dead clicks"
        check: "All clickable elements have onClick or valid href"
      step_4:
        action: "Verify error handling"
        check: "API failures render error UI, not white screen"

    forbid:
      - Deploying without successful build
      - Adding nav items without corresponding routes
      - Adding routes without corresponding pages
      - Leaving TODO comments in deployed code
      - Ignoring TypeScript errors

    violation:
      type: BLOCKING
      message: "FRONTEND-INTEGRATION-001 VIOLATION: Integration incomplete"
      action: "STOP. Complete pre-deploy checklist before proceeding."

# =============================================================================
# SECTION 20: CODEBASE REGISTRY AUTHORITY
# =============================================================================
# Governing Principle:
#   All executable or semantically meaningful code MUST be registered in the
#   Codebase Purpose & Authority Registry before it can be created, modified,
#   or reasoned about. Claude must not infer purpose, ownership, or relationships
#   where they are not explicitly registered.
#
# Reference: PIN-237 (Codebase Registry Survey)
# Reference: docs/codebase-registry/

codebase_registry_authority:

  scope: /root/agenticverz2.0
  status: ENFORCED
  version: v1
  effective_date: 2025-12-29

  governing_principle: |
    The Codebase Purpose & Authority Registry is the single source of truth
    for why code exists, what it may do, and what it may interact with.
    Code evolution is authority. Authority must be declared.

  # ---------------------------------------------------------------------------
  # CODE-REG-001: Registration Required for Code Existence
  # ---------------------------------------------------------------------------
  CODE-REG-001:
    name: Registration Required for Code Existence
    enforcement: BLOCKING
    applies_to:
      - new_code
      - code_modification
      - architectural_reasoning
      - refactoring
      - dependency_analysis

    rule:
      - Any executable or semantically significant code artifact MUST have
        a corresponding registry entry in docs/codebase-registry/artifacts/
      - If no registry entry exists, Claude must pause and request clarification

    disallowed:
      - Creating code without proposing a registry entry
      - Modifying code whose registry entry is missing or unclear
      - Reasoning about unregistered code behavior

    on_violation:
      action: BLOCK
      message: |
        CODE-REG-001 VIOLATION: No registry entry found for this artifact.

        Before proceeding, please:
        1. Search existing artifacts: python scripts/ops/artifact_lookup.py <name>
        2. If not found, propose a registry entry for approval
        3. Only proceed after registration is confirmed

  # ---------------------------------------------------------------------------
  # CODE-REG-002: Purpose and Semantic Clarity Required
  # ---------------------------------------------------------------------------
  CODE-REG-002:
    name: Purpose and Semantic Clarity Required
    enforcement: BLOCKING

    rule:
      - Each registry entry MUST clearly specify:
          - artifact_class (CODE, TEST, DATA, STYLE, CONFIG, DOC)
          - purpose (why this code exists)
          - responsibility (what it does)
          - authority_level (observe, advise, enforce, mutate)
          - execution_surface (server, client, cli) — for executable only
      - If any of these are unclear or missing, Claude must stop and ask
      - UNKNOWN is never an acceptable artifact_class

    forbidden:
      - Inferring purpose from filenames alone
      - Guessing authority based on behavior
      - Best-practice assumptions
      - Reasoning about code without reading its registry entry
      - Leaving artifact_class unspecified or as UNKNOWN

    on_violation:
      action: BLOCK
      message: |
        CODE-REG-002 VIOLATION: Registry entry incomplete or unclear.

        Required fields: artifact_class, purpose, responsibility, authority_level.
        Artifact class must be: CODE, TEST, DATA, STYLE, CONFIG, or DOC.
        UNKNOWN is never acceptable.
        Please clarify missing information before proceeding.

  # ---------------------------------------------------------------------------
  # CODE-REG-003: Product and Surface Traceability
  # ---------------------------------------------------------------------------
  CODE-REG-003:
    name: Product and Surface Traceability
    enforcement: BLOCKING

    rule:
      frontend_code:
        required:
          - product (ai-console, product-builder, etc.)
          - console (customer, founder, internal, external)
          - domain and subdomain
        scope: All code in products/ or pages/

      backend_code:
        required:
          - owning service or worker
          - mutation/enforcement authority (explicit)
        scope: All code in backend/app/

      scripts_and_tests:
        required:
          - mark console as internal or none
          - mark product as system-wide or specific
        scope: All code in scripts/ or tests/

    failure_mode:
      action: PAUSE_AND_ASK
      message: |
        CODE-REG-003: Cannot determine product/surface traceability.

        Please clarify:
        - Which product does this belong to?
        - Which console (customer/founder/internal)?
        - What domain/subdomain does it serve?

  # ---------------------------------------------------------------------------
  # CODE-REG-004: Pause on Unclear Relationships
  # ---------------------------------------------------------------------------
  CODE-REG-004:
    name: Pause on Unclear Relationships
    enforcement: MANDATORY

    behavior:
      trigger: |
        When Claude cannot establish:
        - purpose
        - ownership
        - product mapping
        - UI/backend placement
      action: STOP
      response: |
        Please clarify the intended purpose and placement of this code
        so it can be registered correctly.

        I cannot proceed without understanding:
        - What does this code do? (purpose)
        - Who owns it? (owner)
        - Which product? (traceability)
        - What authority level? (observe/advise/enforce/mutate)

    prohibited:
      - Proceeding with partial assumptions
      - Creating placeholder registry entries without approval
      - Inferring relationships from code structure alone

  # ---------------------------------------------------------------------------
  # CODE-CHANGE-001: Change Registration Required
  # ---------------------------------------------------------------------------
  CODE-CHANGE-001:
    name: Change Registration Required
    enforcement: BLOCKING
    applies_to:
      - code_modification
      - refactor
      - bugfix
      - optimization
      - interface_change
      - dependency_change

    rule:
      - Any modification to existing code MUST have a corresponding
        change record in docs/codebase-registry/changes/
      - The change record MUST reference the registry artifact IDs
        of all modified code
      - Change records follow change-schema-v1.yaml

    prohibited:
      - Modifying code without a registered change_id
      - Making multiple semantic changes under one unclear purpose
      - Bundling unrelated changes in a single record

    on_violation:
      action: BLOCK
      message: |
        CODE-CHANGE-001 VIOLATION: No change record for this modification.

        Before modifying code, please:
        1. Create a change record following change-schema-v1.yaml
        2. Specify purpose, scope, and impact
        3. List all affected artifact_ids
        4. Only proceed after change record is created

  # ---------------------------------------------------------------------------
  # CODE-CHANGE-002: Pause on Unregistered Code Change
  # ---------------------------------------------------------------------------
  CODE-CHANGE-002:
    name: Pause on Unregistered Code Change
    enforcement: MANDATORY

    behavior:
      trigger: Code changes detected without associated change record
      action: STOP
      response: |
        Before proceeding with code changes, please register the change:

        Required information:
        - purpose: Why is this change being made?
        - change_type: bugfix | refactor | behavior_change | etc.
        - artifacts_modified: Which artifact IDs are affected?
        - impact: Does this change behavior, interfaces, or data?

    forbidden:
      - Proceeding with "minor" changes without registration
      - Auto-generating change records without user approval
      - Assuming changes are too small to register

  # ---------------------------------------------------------------------------
  # CODE-CHANGE-003: Artifact-Change Traceability
  # ---------------------------------------------------------------------------
  CODE-CHANGE-003:
    name: Artifact-Change Traceability
    enforcement: BLOCKING

    rule:
      - Each change record MUST list all affected artifact_ids
      - Each artifact MAY reference multiple change_ids over time
      - Change records are immutable once created

    purpose: |
      Provides:
      - Per-artifact evolution history
      - Per-change blast-radius visibility
      - Complete audit trail

  # ---------------------------------------------------------------------------
  # Registry Lookup Commands
  # ---------------------------------------------------------------------------
  lookup_commands:
    search_by_name: "python scripts/ops/artifact_lookup.py <name>"
    search_by_id: "python scripts/ops/artifact_lookup.py --id <artifact_id>"
    filter_by_product: "python scripts/ops/artifact_lookup.py --product ai-console"
    filter_by_type: "python scripts/ops/artifact_lookup.py --type service"
    filter_by_authority: "python scripts/ops/artifact_lookup.py --authority mutate"
    list_all: "python scripts/ops/artifact_lookup.py --list"

  # ---------------------------------------------------------------------------
  # Registry Locations
  # ---------------------------------------------------------------------------
  registry_locations:
    artifacts: docs/codebase-registry/artifacts/
    changes: docs/codebase-registry/changes/
    schema: docs/codebase-registry/schema-v1.yaml
    change_schema: docs/codebase-registry/change-schema-v1.yaml
    survey_pin: docs/memory-pins/PIN-237-codebase-registry-survey.md

# =============================================================================
# SECTION 21: PRODUCT BOUNDARY ENFORCEMENT
# =============================================================================
# Pre-build enforcement framework that blocks code existence unless
# provenance is declared. This is design-time enforcement, not runtime checks.
#
# Reference: docs/contracts/PRODUCT_BOUNDARY_CONTRACT.md
# Reference: PIN-239 (Product Boundary Enforcement)

product_boundary_enforcement:

  scope: /root/agenticverz2.0
  status: ENFORCED
  version: v1
  effective_date: 2025-12-29

  prime_invariant: |
    No code artifact may be created, modified, or reasoned about unless
    ALL of the following are declared and accepted:
    1. Product ownership
    2. Invocation ownership
    3. Boundary classification
    4. Failure jurisdiction

    If ANY are unknown → STOP and ask for clarification.

  core_shift: |
    This enforcement moves from:
      "Verify correctness after code exists"
    to:
      "Block code existence unless provenance is declared."

    This is a DESIGN-TIME GATE, not a runtime check.

  # ---------------------------------------------------------------------------
  # BOUNDARY-001: Artifact Registration Required Before Code
  # ---------------------------------------------------------------------------
  BOUNDARY-001:
    name: Artifact Registration Required Before Code
    enforcement: BLOCKING
    applies_to:
      - new_code_creation
      - file_creation
      - module_creation

    rule:
      - No code may be written until artifact intent is declared
      - Intent declaration must include product, bucket, callers, failure scope
      - If intent cannot be declared, the artifact is not understood yet

    required_declaration:
      artifact_id: AOS-XXX-YYY-ZZZ
      type: service | api | page | worker | script | sdk
      product: ai-console | system-wide | product-builder
      bucket: surface | adapter | platform
      intent:
        purpose: <1-2 sentences, no implementation details>
        user_promise: <what the user gets, or NONE>
      invocation:
        expected_callers:
          - <module/file>
        forbidden_callers:
          - <module/pattern>
      failure_scope:
        breaks_if_removed:
          - <product list>
        must_not_break:
          - <product/component list>
      state:
        mutates_global_state: true | false
        mutates_tenant_state: true | false

    on_violation:
      action: BLOCK
      message: |
        BOUNDARY-001 VIOLATION: Cannot create code without artifact intent.

        Before writing any code, you must declare:
        1. Product ownership (ai-console / system-wide / product-builder)
        2. Boundary bucket (surface / adapter / platform)
        3. Expected callers (who will use this?)
        4. Forbidden callers (who must NOT use this?)
        5. Failure scope (what breaks if this is removed?)

        Only proceed after intent is approved.

  # ---------------------------------------------------------------------------
  # BOUNDARY-002: The Three Blocking Questions
  # ---------------------------------------------------------------------------
  BOUNDARY-002:
    name: Three Blocking Questions
    enforcement: BLOCKING
    applies_to:
      - new_code_creation
      - code_modification
      - architectural_reasoning

    questions:
      Q1:
        question: "Who calls this in production?"
        acceptable_answers:
          - Specific modules/files
          - Nothing (orphan - reject or archive)
          - Explicit list of callers
        unacceptable_answers:
          - "Not sure"
          - "Later"
          - "Probably"
          - "We'll figure it out"

      Q2:
        question: "What breaks if AI Console is deleted?"
        acceptable_answers:
          - Specific products/features
          - Nothing (platform-only)
          - Only this feature
        unacceptable_answers:
          - "I don't know"
          - "Everything"
          - "Hard to say"

      Q3:
        question: "Who must NOT depend on this?"
        acceptable_answers:
          - Specific modules/patterns
          - "Workers must not call this"
          - "SDK must not import this"
        unacceptable_answers:
          - "Anyone can use it"
          - "No restrictions"
          - "Not sure yet"

    on_violation:
      action: BLOCK
      message: |
        BOUNDARY-002 VIOLATION: Cannot answer blocking questions.

        All three questions MUST have acceptable answers:
        1. Who calls this in production?
        2. What breaks if AI Console is deleted?
        3. Who must NOT depend on this?

        Uncertain answers are BLOCKING. Clarify before proceeding.

  # ---------------------------------------------------------------------------
  # BOUNDARY-003: No Silent Assumptions
  # ---------------------------------------------------------------------------
  BOUNDARY-003:
    name: No Silent Assumptions
    enforcement: BLOCKING

    forbidden_inferences:
      - id: FI-001
        name: product_ownership_from_filename
        description: Inferring product ownership from filename or path
        reason: Filenames lie. Callers don't.

      - id: FI-002
        name: future_callers
        description: Assuming who will call this code in the future
        reason: Speculation creates architectural debt.

      - id: FI-003
        name: intended_reuse
        description: Assuming code will be reused elsewhere
        reason: Intent ≠ reality.

      - id: FI-004
        name: likely_platform_use
        description: Assuming code is "probably platform"
        reason: Assumptions create boundary leaks.

      - id: FI-005
        name: authority_from_behavior
        description: Inferring authority level from code behavior
        reason: Authority must be declared, not inferred.

    rule: |
      If not explicitly stated → it is UNKNOWN.
      Unknown is BLOCKING.

    on_violation:
      action: BLOCK
      message: |
        BOUNDARY-003 VIOLATION: Silent assumption detected.

        The system is forbidden from inferring:
        - Product ownership from filename
        - Future callers
        - Intended reuse
        - "Likely platform use"
        - Authority from behavior

        Please explicitly declare the missing information.

  # ---------------------------------------------------------------------------
  # BOUNDARY-004: Bucket Classification Required
  # ---------------------------------------------------------------------------
  BOUNDARY-004:
    name: Bucket Classification Required
    enforcement: BLOCKING

    buckets:
      surface:
        definition: User-facing presentation layer, product-specific
        criteria:
          - Only imported by product UI or product-specific routes
          - Removal breaks ONLY this product
          - No platform dependencies rely on it
        examples: Pages, console routes, product layouts

      adapter:
        definition: Thin translation layer between platform and product
        criteria:
          - Transforms platform data into product semantics
          - Must remain thin (< 200 LOC, no business logic)
          - May not mutate global state
          - Called only by product surface
        examples: Evidence export, policy proposals, predictions
        warning: |
          Adapter creep is the #1 boundary violation. If an adapter:
          - Grows > 200 LOC
          - Adds business logic
          - Introduces state mutation
          → It must be SPLIT or PROMOTED to platform.

      platform:
        definition: Shared infrastructure serving multiple surfaces
        criteria:
          - Called by workers, SDK, or multiple products
          - Removal affects system-wide functionality
          - Owns truth, not presentation
        examples: Workers, BudgetLLM, memory service, policy engine

      orphan:
        definition: Artifact with no production callers
        rule: ILLEGAL
        resolution: Integrate (add production caller) OR Delete
        note: No third state. No "keeping for later."

    on_violation:
      action: BLOCK
      message: |
        BOUNDARY-004 VIOLATION: Bucket classification unclear.

        Every artifact must be classified as:
        - SURFACE: Product UI/routes only
        - ADAPTER: Thin translation layer
        - PLATFORM: Shared infrastructure
        - ORPHAN: No callers (must be resolved)

        Please specify the bucket classification.

  # ---------------------------------------------------------------------------
  # BOUNDARY-005: Invocation Ownership Rule
  # ---------------------------------------------------------------------------
  BOUNDARY-005:
    name: Invocation Ownership Rule
    enforcement: BLOCKING

    principles:
      - name: Caller Graph Determines Truth
        rule: Labels lie. Callers don't.
        detail: |
          An artifact's TRUE product ownership is determined by:
          WHO CALLS IT IN PRODUCTION (not tests)?

          Not by:
          - What label it has
          - What directory it's in
          - What the developer intended

      - name: Non-Console Caller = Not Console-Owned
        rule: |
          If ANY of these call an artifact:
          - workers/*
          - sdk/*
          - ops/* (founder/ops console)
          - External API consumers

          Then the artifact is NOT ai-console owned.

      - name: Negative Dependency Test
        rule: |
          Before labeling `product: ai-console`, answer:
          "Does anything NON-console depend on this?"

          If yes → platform.

    on_violation:
      action: BLOCK
      message: |
        BOUNDARY-005 VIOLATION: Invocation ownership unclear.

        An artifact is NOT console-owned if:
        - Workers call it
        - SDK imports it
        - Other consoles depend on it
        - External APIs use it

        Please clarify the actual caller graph.

  # ---------------------------------------------------------------------------
  # Boundary Violation Types (For Incident Classification)
  # ---------------------------------------------------------------------------
  violation_types:
    - id: BV-001
      name: Mislabeled Product
      definition: Artifact labeled ai-console but has non-console callers
      detection: Caller graph analysis
      resolution: Reclassify to system-wide

    - id: BV-002
      name: Adapter Creep
      definition: Adapter exceeds thin boundary criteria
      detection: LOC > 200, state mutation, business logic
      resolution: Split or promote to platform

    - id: BV-003
      name: Orphan Existence
      definition: Artifact with no production callers
      detection: Caller graph shows tests-only or no callers
      resolution: Integrate or delete

    - id: BV-004
      name: Dual-Surface Hazard
      definition: Single artifact serving multiple products
      detection: Callers from multiple product surfaces
      resolution: Split into product-specific facades + shared core

    - id: BV-005
      name: Silent Platform Dependency
      definition: Console artifact secretly depends on platform state
      detection: Import analysis shows hidden platform coupling
      resolution: Make dependency explicit or restructure

  # ---------------------------------------------------------------------------
  # Known Violations (2025-12-29 Analysis)
  # ---------------------------------------------------------------------------
  known_violations:
    - artifact: recovery_matcher.py
      current_label: ai-console
      violation_type: BV-001
      required_action: Reclassify to system-wide

    - artifact: recovery_rule_engine.py
      current_label: ai-console
      violation_type: BV-001
      required_action: Reclassify to system-wide

    - artifact: event_emitter.py
      current_label: ai-console
      violation_type: BV-001
      required_action: Reclassify to system-wide (founder console)

    - artifact: cost_anomaly_detector.py
      current_label: ai-console
      violation_type: BV-001
      required_action: Reclassify to system-wide

    - artifact: pattern_detection.py
      current_label: ai-console
      violation_type: BV-003
      required_action: Delete or integrate

    - artifact: v1_killswitch.py
      current_label: ai-console
      violation_type: BV-004
      required_action: Split or document as dual-surface

  # ---------------------------------------------------------------------------
  # Enforcement Timeline
  # ---------------------------------------------------------------------------
  enforcement_timeline:
    - gate: design_time
      when: Before code written
      enforcer: Session playbook (this file)

    - gate: pre_commit
      when: Before merge
      enforcer: Human review

    - gate: ci
      when: After merge
      enforcer: Automated caller graph

    - gate: periodic
      when: Weekly
      enforcer: Registry audit

  # ---------------------------------------------------------------------------
  # Reference Files
  # ---------------------------------------------------------------------------
  reference_files:
    contract: docs/contracts/PRODUCT_BOUNDARY_CONTRACT.md
    schema: docs/codebase-registry/artifact-intent-schema.yaml
    lookup: scripts/ops/artifact_lookup.py
    survey_pin: docs/memory-pins/PIN-237-codebase-registry-survey.md
    enforcement_pin: docs/memory-pins/PIN-239-product-boundary-enforcement.md

# =============================================================================
# SECTION 22: ARCHITECTURE & INTEGRATION GOVERNANCE
# =============================================================================
# Claude operates as Architecture Governor with mandatory pre-build gates.
# No code may exist unless Layer, Temporal role, and Ownership are declared.
#
# Reference: PIN-245 (Integration Integrity System)
# Reference: docs/templates/ARTIFACT_INTENT.yaml
# Reference: docs/templates/FILE_HEADER_TEMPLATE.md
# Reference: docs/contracts/INTEGRATION_INTEGRITY_CONTRACT.md

architecture_governance:

  scope: /root/agenticverz2.0
  status: ENFORCED
  version: v1
  effective_date: 2025-12-30

  governing_principle: |
    No code may be created, modified, or reasoned about unless
    Layer, Temporal role, and Ownership are explicitly declared.

    Claude is an Architecture Governor, not a code generator.
    Integration correctness precedes business correctness.

  claude_role: |
    Claude operates as an Architecture Governor with three mandatory gates.
    Any response that creates or modifies code must pass all gates.
    Gate violations result in BLOCKED responses.

  # ---------------------------------------------------------------------------
  # ARCH-GOV-001: Artifact Intent Gate
  # ---------------------------------------------------------------------------
  ARCH-GOV-001:
    name: Artifact Intent Gate
    enforcement: BLOCKING
    applies_to:
      - new_code_creation
      - file_creation
      - module_creation

    rule:
      - Before creating ANY new file, the artifact intent must be declared
      - Use docs/templates/ARTIFACT_INTENT.yaml template
      - If intent cannot be declared, the artifact is not understood

    required_fields:
      - artifact_id
      - file_path
      - layer.declared
      - layer.confidence
      - layer.justification
      - temporal.trigger
      - temporal.execution
      - temporal.lifecycle
      - product.owner
      - product.slice
      - responsibility.role
      - dependencies.allowed_layers
      - dependencies.forbidden_layers

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-001 VIOLATION: Artifact intent not declared.

        Before creating code, fill out ARTIFACT_INTENT.yaml:
        - Layer: Which of L1-L8?
        - Temporal: sync/async? Triggered by what?
        - Product: Who owns this?
        - Dependencies: What can this import?

        Template: docs/templates/ARTIFACT_INTENT.yaml

  # ---------------------------------------------------------------------------
  # ARCH-GOV-002: Layer Declaration Gate
  # ---------------------------------------------------------------------------
  ARCH-GOV-002:
    name: Layer Declaration Gate
    enforcement: BLOCKING
    applies_to:
      - new_code_creation
      - code_modification
      - import_changes

    rule:
      - Every code artifact MUST have an explicit layer declaration
      - Layer must be L1-L8 with confidence HIGH or MEDIUM
      - LOW confidence = BLOCK (cannot proceed without clarification)
      - Layer determines allowed imports and dependencies

    layer_model:
      L1:
        name: Product Experience (UI)
        allowed_imports: [L2]
        forbidden_imports: [L3, L4, L5, L6, L7, L8]
        notes: UI components, pages, user interactions

      L2:
        name: Product APIs (Console/Public)
        allowed_imports: [L3, L4, L6]
        forbidden_imports: [L1, L5, L7, L8]
        notes: REST endpoints, API routes

      L3:
        name: Boundary Adapters (Translation)
        allowed_imports: [L4, L6]
        forbidden_imports: [L1, L2, L5, L7, L8]
        notes: Thin translation layers, < 200 LOC

      L4:
        name: Domain Engines (Truth & Rules)
        allowed_imports: [L5, L6]
        forbidden_imports: [L1, L2, L3, L7, L8]
        notes: Policy engine, business rules, system truth

      L5:
        name: Execution & Workers
        allowed_imports: [L6]
        forbidden_imports: [L1, L2, L3, L4, L7, L8]
        notes: Background workers, job execution

      L6:
        name: Platform Substrate
        allowed_imports: []
        forbidden_imports: [L1, L2, L3, L4, L5, L7, L8]
        notes: DB access, Redis, external services

      L7:
        name: Ops & Deployment
        allowed_imports: [L6]
        forbidden_imports: [L1, L2, L3, L4, L5, L8]
        notes: Systemd, Docker, deployment scripts

      L8:
        name: Catalyst / Meta
        allowed_imports: []
        forbidden_imports: []
        notes: CI, tests, validators, scaffolding

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-002 VIOLATION: Layer declaration missing or ambiguous.

        Every file must declare its layer in the header:
        # Layer: L{x} — {Layer Name}

        If layer is unclear, STOP and ask for clarification.
        Low confidence = BLOCKED.

        Template: docs/templates/FILE_HEADER_TEMPLATE.md

  # ---------------------------------------------------------------------------
  # ARCH-GOV-003: Temporal Clarity Gate
  # ---------------------------------------------------------------------------
  ARCH-GOV-003:
    name: Temporal Clarity Gate
    enforcement: BLOCKING
    applies_to:
      - new_code_creation
      - code_modification
      - function_changes

    rule:
      - Every code artifact MUST declare its temporal behavior
      - sync vs async must be explicit, never inferred
      - Async execution leaking into sync layers = BUILD VIOLATION

    temporal_properties:
      trigger:
        values: [user, api, worker, scheduler, external]
        rule: Who/what initiates this code?

      execution:
        values: [sync, async, deferred]
        rule: How does this code run?

      lifecycle:
        values: [request, job, long-running, batch]
        rule: How long does this code live?

    async_leak_detection:
      rule: |
        Async code in L1-L3 that is not properly awaited = violation.
        Worker patterns leaking into API handlers = violation.
        Deferred execution hidden behind sync API = violation.

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-003 VIOLATION: Temporal behavior unclear.

        Every file must declare temporal behavior:
        # Temporal:
        #   Trigger: {user|api|worker|scheduler|external}
        #   Execution: {sync|async|deferred}

        Sync vs async must be explicit. Never infer.
        Async leaking into sync = BLOCKED.

  # ---------------------------------------------------------------------------
  # ARCH-GOV-004: File Header Requirement
  # ---------------------------------------------------------------------------
  ARCH-GOV-004:
    name: File Header Requirement
    enforcement: BLOCKING
    applies_to:
      - new_file_creation
      - python_files
      - typescript_files
      - yaml_files
      - shell_scripts

    rule:
      - Every new file MUST begin with a structured header
      - Header declares layer, product, temporal, role, imports
      - Missing header = invalid file

    header_template_location: docs/templates/FILE_HEADER_TEMPLATE.md

    python_format: |
      # Layer: L{x} — {Layer Name}
      # Product: {product | system-wide}
      # Temporal:
      #   Trigger: {user|api|worker|scheduler|external}
      #   Execution: {sync|async|deferred}
      # Role: {single-line responsibility}
      # Callers: {who calls this?}
      # Allowed Imports: L{x}, L{y}
      # Forbidden Imports: L{z}
      # Reference: PIN-{xxx}

    typescript_format: |
      /**
       * Layer: L{x} — {Layer Name}
       * Product: {product | system-wide}
       * Temporal:
       *   Trigger: {user|api|worker|scheduler}
       *   Execution: {sync|async}
       * Role: {single-line responsibility}
       * Callers: {who renders/uses this?}
       * Allowed Imports: L{x}, L{y}
       * Forbidden Imports: L{z}
       * Reference: PIN-{xxx}
       */

    validation_rules:
      - Layer is missing or ambiguous → INVALID
      - Product is missing → INVALID
      - Temporal information missing for executable code → INVALID
      - Role is empty or "TODO" → INVALID

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-004 VIOLATION: File header missing or incomplete.

        Every file must have a structured header declaring:
        - Layer (L1-L8)
        - Product (ai-console | system-wide | product-builder)
        - Temporal behavior (trigger, execution)
        - Role (single-line responsibility)
        - Import boundaries

        Template: docs/templates/FILE_HEADER_TEMPLATE.md

  # ---------------------------------------------------------------------------
  # ARCH-GOV-005: Integration Seam Awareness
  # ---------------------------------------------------------------------------
  ARCH-GOV-005:
    name: Integration Seam Awareness
    enforcement: BLOCKING
    applies_to:
      - api_creation
      - adapter_creation
      - cross_layer_changes

    rule:
      - Code that crosses layer boundaries must identify the integration seam
      - Integration seams require LIT (Layer Integration Tests)
      - UI-facing code requires BIT (Browser Integration Tests)

    integration_seams:
      L1_L2: "Frontend to API"
      L2_L3: "API to Adapter"
      L3_L4: "Adapter to Domain"
      L4_L5: "Domain to Worker"
      L2_L6: "API to Platform"

    test_requirements:
      api_endpoint: "At least one LIT test"
      ui_page: "Entry in page-registry.yaml + BIT coverage"
      adapter: "LIT test for upstream seam"

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-005 VIOLATION: Integration seam not identified.

        Cross-layer code must declare its integration seam:
        - L2↔L3: API to Adapter
        - L3↔L4: Adapter to Domain

        And include appropriate tests:
        - LIT for layer seams
        - BIT for UI pages

        Reference: PIN-245 (Integration Integrity System)

  # ---------------------------------------------------------------------------
  # ARCH-GOV-006: Artifact Class Declaration
  # ---------------------------------------------------------------------------
  ARCH-GOV-006:
    name: Artifact Class Declaration
    enforcement: BLOCKING
    applies_to:
      - file_creation
      - file_modification
      - codebase_inventory

    rule:
      - Every file must have an artifact_class (CODE, TEST, DATA, STYLE, CONFIG, DOC)
      - Artifact class determines whether file is executable or non-executable
      - Artifact class informs layer inference for non-code files
      - UNKNOWN is never acceptable - every file must be classified

    artifact_classes:
      executable:
        CODE: "Executable code with imports (.py, .ts, .js, .sh, .sql)"
        TEST: "Test files - executable but categorized separately"
      non_executable:
        DATA: "Static data files (.json in /data/, fixtures, catalogs)"
        STYLE: "Stylesheets (.css, .scss)"
        CONFIG: "Configuration files (.yaml, .ini, .toml, .cfg)"
        DOC: "Documentation (.md, .txt, .rst)"

    layer_inference_rules:
      STYLE: "L1 (Product Experience) - frontend presentation"
      DATA: "L4 or L6 based on path (/app/data/ → L4, else L6)"
      CONFIG: "L7 (Ops & Deployment) - infrastructure config"
      DOC: "L7 (Ops & Deployment) - documentation"
      TEST: "L8 (Catalyst / Meta) - test infrastructure"
      CODE: "From path pattern or explicit header"

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-006 VIOLATION: Artifact class not declared.

        Every file must have an artifact class:
        - CODE: Executable code with imports
        - TEST: Test files
        - DATA: Static data files
        - STYLE: Stylesheets
        - CONFIG: Configuration files
        - DOC: Documentation

        UNKNOWN is never acceptable. Classify the file before proceeding.

        Reference: PIN-248 (Codebase Inventory & Layer System)

  # ---------------------------------------------------------------------------
  # Behavioral Invariants
  # ---------------------------------------------------------------------------
  behavioral_invariants:

    - id: BI-001
      name: No Code Without Layer
      rule: |
        Claude MUST NOT write code if layer is unclear.
        If unsure, STOP and ask: "Which layer is this?"

    - id: BI-002
      name: No Async Leak
      rule: |
        Claude MUST NOT introduce async behavior into sync layers.
        If async is needed, declare it explicitly.

    - id: BI-003
      name: No Silent Import
      rule: |
        Claude MUST NOT add imports that violate layer boundaries.
        Check allowed_imports and forbidden_imports before adding.

    - id: BI-004
      name: Intent Before Code
      rule: |
        Claude MUST declare artifact intent before writing code.
        Use ARTIFACT_INTENT.yaml template.

    - id: BI-005
      name: Header Before Body
      rule: |
        Claude MUST write file header before file body.
        No code without architectural declaration.

  # ---------------------------------------------------------------------------
  # Validation Checklist (Claude must verify before proceeding)
  # ---------------------------------------------------------------------------
  validation_checklist:
    - layer_explicit: "Layer declared with HIGH or MEDIUM confidence"
    - temporal_explicit: "Trigger and execution mode declared"
    - ownership_explicit: "Product owner declared"
    - integration_seam_identified: "If cross-layer, seam identified"
    - no_integration_leak: "Async does not leak into sync"
    - file_header_complete: "Header has all required fields"

  # ---------------------------------------------------------------------------
  # PRE-BUILD GUARDS (Machine-Enforced Gates)
  # ---------------------------------------------------------------------------
  # These convert policy into gates. Missing or ambiguous = BLOCKED.

  pre_build_guards:

    - name: Intent Declaration Gate
      id: PRE-BUILD-001
      rule: |
        Any new file detected must have a corresponding
        ARTIFACT_INTENT.yaml entry.
        Missing intent is a blocking violation.
      applies_to:
        - new_file_creation
        - significant_modifications
        - boundary_changing_refactors
      on_violation: BLOCK_AND_QUERY
      message: |
        PRE-BUILD-001: Intent Declaration Required

        Cannot create code without artifact intent.
        Fill out ARTIFACT_INTENT.yaml first.

        Required fields:
        - artifact_id
        - layer (L1-L8)
        - temporal (trigger, execution, lifecycle)
        - product owner
        - dependencies

    - name: Temporal Model Declaration Gate
      id: PRE-BUILD-002
      rule: |
        Every artifact must explicitly declare:
        - trigger (user, api, worker, scheduler, external)
        - execution mode (sync, async, deferred)
        - lifecycle (request, job, long-running, batch)
        Temporal ambiguity is not allowed.
      applies_to:
        - new_file_creation
        - code_modification
        - function_changes
      on_violation: BLOCK_AND_QUERY
      message: |
        PRE-BUILD-002: Temporal Declaration Required

        Cannot proceed with ambiguous temporal behavior.
        Inference is forbidden.

        Declare explicitly:
        - Trigger: who/what initiates this?
        - Execution: sync | async | deferred
        - Lifecycle: request | job | long-running | batch

    - name: Layer Confidence Gate
      id: PRE-BUILD-003
      rule: |
        Layer must be declared with HIGH or MEDIUM confidence.
        LOW confidence = BLOCKED.
        Ambiguous layer = BLOCKED.
      applies_to:
        - new_file_creation
        - import_changes
      on_violation: BLOCK_AND_QUERY
      message: |
        PRE-BUILD-003: Layer Confidence Insufficient

        Layer declaration requires HIGH or MEDIUM confidence.
        LOW confidence means the artifact is not understood.

        Clarify layer assignment before proceeding.

  # ---------------------------------------------------------------------------
  # RUNTIME SANITY GUARDS (Violation Detection)
  # ---------------------------------------------------------------------------
  # These detect architectural violations at design time.

  runtime_sanity_guards:

    - name: Sync-Async Boundary Guard
      id: RUNTIME-001
      rule: |
        Synchronous layers (L1–L3) must not directly
        invoke asynchronous execution layers (L5).
      severity: ERROR
      detection:
        - L1 importing from L5
        - L2 importing from L5
        - L3 importing from L5
        - Sync function awaiting worker execution
        - API handler blocking on long-running computation
      on_violation:
        action: BLOCK
        message: |
          RUNTIME-001: Sync-Async Boundary Violation

          Synchronous layer (L1-L3) is accessing async execution layer (L5).
          This is an architectural incident, not an implementation bug.

          Resolution options:
          1. Add an adapter layer (L3)
          2. Change the execution model
          3. Restructure the call hierarchy

    - name: Async Leak Detection Guard
      id: RUNTIME-002
      rule: |
        Async execution semantics must not leak upward.
        L5 execution must be initiated via domain (L4) or adapter (L3) boundaries.
      severity: ERROR
      detection:
        - Worker patterns in API handlers
        - Deferred execution hidden behind sync API
        - Background task creation in L1-L2
      on_violation:
        action: BLOCK
        message: |
          RUNTIME-002: Async Leak Detected

          Async execution semantics are leaking into sync layers.
          Execution must be initiated via domain or adapter boundaries.

          This is a temporal contract violation.

    - name: Intent Completeness Guard
      id: RUNTIME-003
      rule: |
        Artifact intent must be complete before code exists.
        Incomplete intent = artifact architecturally invalid.
      severity: ERROR
      required_fields:
        - layer.declared
        - layer.confidence (HIGH or MEDIUM)
        - temporal.trigger
        - temporal.execution
        - temporal.lifecycle
        - product.owner
        - responsibility.role
      on_violation:
        action: BLOCK
        message: |
          RUNTIME-003: Incomplete Artifact Intent

          Intent declaration is missing required fields.
          An artifact without complete intent is:
          - Architecturally invalid
          - Non-reviewable
          - Non-mergeable

  # ---------------------------------------------------------------------------
  # PROHIBITION CLAUSE
  # ---------------------------------------------------------------------------
  # Invalid justifications that must be rejected.

  prohibition_clause:
    invalid_justifications:
      - phrase: "Temporary sync"
        reason: Temporal violations are architectural, not temporary
      - phrase: "Fast async"
        reason: Speed doesn't change execution model
      - phrase: "We'll refactor later"
        reason: Debt accumulation is not allowed
      - phrase: "Probably fast enough"
        reason: Inference is forbidden
      - phrase: "Likely async"
        reason: Inference is forbidden
      - phrase: "Just for now"
        reason: Temporary violations become permanent
      - phrase: "Quick hack"
        reason: Architectural shortcuts create debt

    enforcement: |
      If Claude detects any invalid justification:
      1. Reject the justification explicitly
      2. Explain why it's invalid
      3. Block until proper declaration is made

  # ---------------------------------------------------------------------------
  # Reference Files
  # ---------------------------------------------------------------------------
  reference_files:
    # Manual (single source of truth)
    architecture_operating_manual: docs/ARCHITECTURE_OPERATING_MANUAL.md

    # Templates
    artifact_intent_template: docs/templates/ARTIFACT_INTENT.yaml
    file_header_template: docs/templates/FILE_HEADER_TEMPLATE.md

    # Contracts
    integration_integrity_contract: docs/contracts/INTEGRATION_INTEGRITY_CONTRACT.md
    temporal_integrity_contract: docs/contracts/TEMPORAL_INTEGRITY_CONTRACT.md
    integration_integrity_pin: docs/memory-pins/PIN-245-integration-integrity-system.md

    # Enforcement tools
    intent_validator: scripts/ops/intent_validator.py
    temporal_detector: scripts/ops/temporal_detector.py
    ci_workflow: .github/workflows/integration-integrity.yml

    # Test locations
    lit_tests: backend/tests/lit/
    bit_tests: website/aos-console/console/tests/bit/

# =============================================================================
# SECTION 23: CODEBASE INVENTORY & ARTIFACT HYGIENE (ENFORCED)
# =============================================================================
# Reference: PIN-248 (Codebase Inventory & Layer System)
# Added: 2025-12-30

codebase_inventory:
  status: ENFORCED
  purpose: |
    Maintain accurate layer-based inventory of all codebase artifacts.
    Every file must be classified as either:
    - A Layered Code Artifact (executable code with layer L1-L8)
    - A Non-Executable Artifact (DATA, STYLE, CONFIG, DOC, TEST)

    UNKNOWN files must be resolved into either a Layered Code Artifact
    or a Non-Executable Artifact Class. Nothing escapes the system.

    Inventory must be updated after every task that creates or modifies files.

  # ---------------------------------------------------------------------------
  # ARTIFACT CLASSES (CODE vs NON-EXECUTABLE)
  # ---------------------------------------------------------------------------
  artifact_classes:
    executable:
      CODE: "Executable code with imports (.py, .ts, .js, .sh)"
      TEST: "Test files (executable but categorized separately)"
    non_executable:
      DATA: "Static data files (.json in /data/, etc)"
      STYLE: "Stylesheets (.css, .scss)"
      CONFIG: "Configuration files (.yaml, .ini, .toml)"
      DOC: "Documentation (.md)"

    classification_rule: |
      Every artifact gets:
      - An artifact_class (CODE, TEST, DATA, STYLE, CONFIG, DOC)
      - A layer (L1-L8) based on class + path

      Layer inference for non-executable:
      - STYLE → L1 (Product Experience)
      - DATA → L4/L6 (Domain/Platform based on path)
      - DOC → L7 (Ops & Deployment)
      - CONFIG → L7 (Ops & Deployment)
      - TEST → L8 (Catalyst / Meta)

  # ---------------------------------------------------------------------------
  # INVENTORY UPDATE RULE (INV-001)
  # ---------------------------------------------------------------------------
  inventory_update_rule:
    id: INV-001
    name: Inventory Update After Task
    when: After every task that creates or modifies files
    action: |
      1. Run inventory check: python3 /tmp/full_inventory.py --json
      2. Verify UNKNOWN count is near zero
      3. If new files were created without headers, flag them
      4. Update docs/codebase-registry/CODEBASE_INVENTORY.md if counts changed
    severity: ADVISORY
    enforcement: |
      Claude should proactively update inventory after file operations.
      New files without layer headers should be flagged for classification.

  # ---------------------------------------------------------------------------
  # ARTIFACT HYGIENE PRINT RULE (HYG-001)
  # ---------------------------------------------------------------------------
  artifact_hygiene_rule:
    id: HYG-001
    name: Artifact Hygiene Summary After Task
    when: After every task completion
    action: |
      Print an artifact hygiene summary as part of task completion.
      Include:
      - Files created (with layer classification)
      - Files modified (with layer)
      - UNKNOWN count (should be near zero)
      - Any hygiene warnings
    severity: ADVISORY
    format: |
      ## Artifact Hygiene Summary

      | Metric | Value |
      |--------|-------|
      | Files Created | {count} |
      | Files Modified | {count} |
      | UNKNOWN Files | {count} |
      | Headers Added | {count} |

      ### Files Changed
      - `path/to/file.py` (L4 — Domain Engine)
      - `path/to/other.py` (L6 — Platform Substrate)

  # ---------------------------------------------------------------------------
  # CLASSIFICATION REQUIREMENTS
  # ---------------------------------------------------------------------------
  classification_requirements:
    executable_code:
      - Every new Python file must have a layer header (# Layer: Lx — Name)
      - Every new TypeScript/TSX file must have a layer header (// Layer: Lx — Name)
      - Files without headers are classified via path inference (MEDIUM confidence)
      - Explicit headers earn HIGH confidence
    non_executable:
      - Non-executable artifacts (DATA, STYLE, CONFIG, DOC) get layer via class rule
      - No headers required for non-executable artifacts
      - Classification is automatic based on file extension and path
    invariants:
      - UNKNOWN count must equal 0 at all times
      - Every artifact has both a class AND a layer (never unclassified)
      - "Not everything executes, but nothing escapes the system"

  # ---------------------------------------------------------------------------
  # INVENTORY TOOLS
  # ---------------------------------------------------------------------------
  tools:
    full_inventory: scripts/inventory/full_inventory.py
    unknown_finder: scripts/inventory/find_unknown_files_v2.py
    inventory_report: docs/codebase-registry/CODEBASE_INVENTORY.md
    triage_log: docs/codebase-registry/UNKNOWN_TRIAGE.md

  # ---------------------------------------------------------------------------
  # LAYER MODEL REFERENCE
  # ---------------------------------------------------------------------------
  layer_model:
    L1:
      name: Product Experience
      description: UI pages, components, hooks, types
      allowed_imports: [L2]
    L2:
      name: Product APIs
      description: REST endpoints, surface contracts
      allowed_imports: [L3, L4, L6]
    L3:
      name: Boundary Adapters
      description: LLM adapters, external integrations
      allowed_imports: [L4, L6]
    L4:
      name: Domain Engines
      description: Policy, workflow, skills, agents
      allowed_imports: [L5, L6]
    L5:
      name: Execution & Workers
      description: Jobs, tasks, runtime
      allowed_imports: [L6]
    L6:
      name: Platform Substrate
      description: DB, auth, models, utils, SDK
      allowed_imports: []
    L7:
      name: Ops & Deployment
      description: Docs, scripts, config, monitoring
      allowed_imports: [L6]
    L8:
      name: Catalyst / Meta
      description: Tests, validators, CI
      allowed_imports: [any]

  # ---------------------------------------------------------------------------
  # TASK COMPLETION CHECKLIST
  # ---------------------------------------------------------------------------
  on_task_completion:
    - step: Check if files were created or modified
      action: List all file changes
    - step: Verify layer classification
      action: Ensure all new files have layer headers or path inference
    - step: Print hygiene summary
      action: Output artifact hygiene table
    - step: Flag any UNKNOWN files
      action: Warn if UNKNOWN count increased

# =============================================================================
# SECTION 24: ARTIFACT CLASS CONTRACT (ENFORCED)
# =============================================================================
# Reference: PIN-248 (Codebase Inventory & Layer System)
# Added: 2025-12-30

artifact_class_contract:
  status: ENFORCED
  principle: |
    Nothing escapes the system. Not everything executes.

    Every file in the codebase must have:
    1. An artifact_class (CODE, TEST, DATA, STYLE, CONFIG, DOC)
    2. A layer (L1-L8)

    UNKNOWN is NEVER acceptable as a final state.

  # ---------------------------------------------------------------------------
  # ARTIFACT CLASSES
  # ---------------------------------------------------------------------------
  classes:
    executable:
      CODE:
        description: "Executable code with imports"
        extensions: [".py", ".ts", ".tsx", ".js", ".jsx", ".sh", ".sql"]
        header_required: true
        layer_source: "header or path inference"
      TEST:
        description: "Test files - executable but categorized separately"
        extensions: [".py", ".ts", ".js"]
        patterns: ["tests/", "test_", "_test.", ".test."]
        header_required: true
        layer_source: "always L8"

    non_executable:
      DATA:
        description: "Static data files"
        extensions: [".json"]
        patterns: ["/data/", "fixtures", "catalog"]
        header_required: false
        layer_source: "L4 for domain data, L6 for platform data"
      STYLE:
        description: "Stylesheets"
        extensions: [".css", ".scss", ".sass", ".less"]
        header_required: false
        layer_source: "always L1"
      CONFIG:
        description: "Configuration files"
        extensions: [".yaml", ".yml", ".ini", ".toml", ".cfg", ".conf"]
        patterns: ["Dockerfile", "Makefile", "Procfile"]
        header_required: false  # optional brief header acceptable
        layer_source: "always L7"
      DOC:
        description: "Documentation"
        extensions: [".md", ".txt", ".rst"]
        header_required: false
        layer_source: "always L7"

  # ---------------------------------------------------------------------------
  # BLOCKING RULES
  # ---------------------------------------------------------------------------
  blocking_rules:
    - id: AC-001
      name: "Artifact Class Required"
      rule: "Every file must have an artifact_class"
      enforcement: BLOCKING

    - id: AC-002
      name: "No UNKNOWN"
      rule: "UNKNOWN is never acceptable as artifact_class"
      enforcement: BLOCKING

    - id: AC-003
      name: "Layer Required"
      rule: "Every artifact must have a layer (derived from class or declared)"
      enforcement: BLOCKING

    - id: AC-004
      name: "Executable Header"
      rule: "Executable artifacts (CODE, TEST) require layer headers"
      enforcement: BLOCKING

  # ---------------------------------------------------------------------------
  # ON VIOLATION
  # ---------------------------------------------------------------------------
  on_violation:
    action: BLOCK
    message: |
      ARTIFACT CLASS CONTRACT VIOLATION

      Every file must be classified:
      - Executable: CODE, TEST (header required)
      - Non-Executable: DATA, STYLE, CONFIG, DOC (header optional)

      UNKNOWN is never acceptable. Classify before proceeding.

      Reference: PIN-248

# =============================================================================
# SECTION 25: PROTECTIVE GOVERNANCE MODE (ENFORCED)
# =============================================================================
# Reference: docs/contracts/PROTECTIVE_GOVERNANCE_CONTRACT.md
# Added: 2025-12-30
# Purpose: Long-term protection against regression, noise, and silent debt growth

protective_governance:
  status: ENFORCED

  principles:
    - No repeated errors
    - No silent debt growth
    - No tool noise escalation
    - Debt must be explicit and bounded

  rules:
    - id: PG-001
      name: "No Unregistered Debt"
      rule: "No new ignores or suppressions without QUARANTINE_LEDGER entry"
      enforcement: BLOCKING

    - id: PG-002
      name: "Monotonicity Guard"
      rule: "No increase in lint or typing warnings from baseline"
      enforcement: BLOCKING

    - id: PG-003
      name: "Quarantine Ceiling"
      rule: "No increase in quarantined artifacts without approval"
      enforcement: BLOCKING

    - id: PG-004
      name: "Baseline Ceremony"
      rule: "Baselines move only with explicit commit + justification"
      enforcement: BLOCKING

  session_behavior:
    mode_transition_rule: |
      If task scope changes (hygiene → feature, infra → product),
      session must be re-bootstrapped.

    require_rebootstrap_on:
      - hygiene_to_feature
      - infra_to_product
      - cleanup_to_refactor
      - tooling_to_business_logic

  debt_ceilings:
    quarantined_mypy_modules:
      ceiling: "≤ 15% of runtime code (L1–L6)"
      current: 10
      status: under_ceiling

    type_ignore_lines:
      ceiling: "≤ 2 per file"
      current: "varies"
      status: under_ceiling

    legacy_untyped_modules:
      ceiling: "fixed allowlist only"
      current: "see QUARANTINE_LEDGER.md"
      status: frozen

    config_suppressions:
      ceiling: "no growth after housekeeping baseline"
      current: 4
      status: frozen

  enforcement:
    authority: CI
    script: scripts/ci/lint_regression_guard.sh
    baseline: docs/HOUSEKEEPING_BASELINE.md
    ledger: docs/technical-debt/QUARANTINE_LEDGER.md

  on_violation:
    action: BLOCK
    message: |
      PROTECTIVE GOVERNANCE VIOLATION

      This change violates monotonicity or debt ceiling rules.

      Options:
      1. Fix the regression (recommended)
      2. Pay existing debt to make room
      3. Request explicit exception with justification

      Reference: docs/contracts/PROTECTIVE_GOVERNANCE_CONTRACT.md

# =============================================================================
# SECTION 26: LAYER CLASSIFICATION & REASSIGNMENT GATE (ENFORCED)
# =============================================================================
# Reference: PIN-249 (Protective Governance)
# Added: 2025-12-30
# Purpose: Force correct layer reasoning, prevent hand-waving, block ambiguity

layer_classification_gate:
  status: ENFORCED

  context:
    description: |
      The codebase is classified into 8 strict layers.
      L1–L3 = Product-owned
      L4–L7 = System / Foundation
      L8 = Catalyst layer (CI, tests, validators, governance tooling)
      Architecture is FROZEN. No new code may be written until classification is resolved.

  authoritative_layer_model:
    L1:
      name: Product Experience
      scope: AI Console, UI, UX
      boundary: product

    L2:
      name: Product APIs
      scope: request/response, controllers
      boundary: product

    L3:
      name: Boundary Adapters
      scope: protocols, SDK glue, IO normalization
      boundary: product

    L4:
      name: Domain Engines
      scope: business logic, rules, state machines
      boundary: system

    L5:
      name: Execution & Workers
      scope: jobs, schedulers, async execution
      boundary: system

    L6:
      name: Platform Substrate
      scope: DB, cache, messaging, auth infra
      boundary: system

    L7:
      name: Ops & Deployment
      scope: runtime ops, configs, scripts, runbooks
      boundary: system

    L8:
      name: Catalyst / Meta
      scope: CI, tests, validators, governance
      boundary: meta

  # ---------------------------------------------------------------------------
  # ARCH-GOV-007: Layer Classification Reassignment Gate
  # ---------------------------------------------------------------------------
  ARCH-GOV-007:
    name: Layer Classification Reassignment Gate
    enforcement: BLOCKING
    applies_to:
      - layer_audits
      - file_reclassification
      - architecture_reviews
      - cross_layer_refactors

    rule:
      - For each file under review, determine placement correctness
      - No assumptions, no shortcuts
      - If classification cannot be resolved, STOP and ask

    mandatory_procedure:
      step_1_artifact_intake:
        description: Gather facts about the artifact
        required_information:
          - file_path
          - declared_purpose
          - consumers (who calls it)
          - dependents (who depends on it)
          - execution_time: [request_time, async_background, build_ci_time, deploy_ops_time]
        on_unclear: STOP and ask for clarification

      step_2_layer_claim:
        description: State one primary layer the artifact claims to belong to
        rule: Justify using FUNCTION, not location
        bad_justification: "It lives under /api so it's L2"
        valid_justification: "It defines request/response schemas and performs no business logic, therefore L2"

      step_3_violation_check:
        description: Explicitly answer YES/NO for each
        questions:
          - Does it contain business logic?
          - Does it touch infra primitives directly?
          - Does it orchestrate async work?
          - Does it enforce policy or governance?
          - Does it leak product concerns downward?
        on_yes_outside_layer: Violation exists

      step_4_classification_outcome:
        case_A_correct:
          description: Confirm layer, no action required
          artifact_registry: unchanged

        case_B_misjudged:
          description: Wrong original classification
          required_actions:
            - Identify why original classification was wrong
            - Propose correct layer
            - Specify required code changes for layer purity
            - Specify new file location
            - Update artifact registry entry
          partial_fixes: NOT_ALLOWED

        case_C_hybrid:
          description: Straddles two layers
          required_actions:
            - Identify which two layers it straddles
            - Decide closest correct layer (forced choice)
            - State nuance being accepted
            - Require explicit registry annotation
          shared_layer_answer: NOT_ALLOWED
          temporary_answer: NOT_ALLOWED

      step_5_registry_update:
        description: Required for Case B or C
        format: |
          Artifact: <name>
          Old Layer: Lx
          New Layer: Ly
          Reason: <one-paragraph factual justification>
          Nuance (if any): <explicitly documented>
          Approval Required: YES / NO

    hard_stops:
      - Do NOT propose new abstractions
      - Do NOT refactor unrelated code
      - Do NOT invent new layers
      - Do NOT proceed to feature work
      - Do NOT allow "it's fine as-is" without proof

    output_format:
      required_sections:
        - summary (3-5 lines)
        - layer_decision
        - violation_analysis
        - outcome (A / B / C)
        - required_actions (if any)
        - registry_update_block (if required)

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-007 VIOLATION: Layer classification not resolved.

        Before proceeding with code changes, you must:
        1. Complete artifact intake (Step 1)
        2. Make explicit layer claim with justification (Step 2)
        3. Check for cross-layer violations (Step 3)
        4. Declare outcome: A (correct), B (misjudged), or C (hybrid)
        5. Provide registry update if B or C

        If classification cannot be resolved, STOP and ask.

        Reference: SESSION_PLAYBOOK Section 26

  governance_principle: |
    You are not optimizing for speed.
    You are optimizing for architectural correctness and long-term clarity.
    If this exercise blocks progress, that is SUCCESS, not failure.

  # ---------------------------------------------------------------------------
  # ARCH-GOV-008: Minimum Runnable Definition (Phase 2 Elevation)
  # ---------------------------------------------------------------------------
  ARCH-GOV-008:
    name: Minimum Runnable Definition
    enforcement: BLOCKING
    added: 2025-12-30
    reference: PIN-250, PHASE2_ALIGNMENT_PLAN_v2.md
    applies_to:
      - structural_alignment
      - refactors_touching_5_plus_files
      - responsibility_migrations

    rule: |
      Any structural alignment touching >5 files must define a "minimum runnable"
      condition BEFORE execution begins.

    rationale: |
      Prevents silent breakage under "no behavior change" claims.
      Makes rollback criteria explicit and verifiable.

    minimum_runnable_template:
      import_succeeds: "python -c 'from app.main import app' — no exceptions"
      server_boots: "uvicorn starts without crash"
      core_router_loads: "/health returns 200"
      auth_initializes: "auth endpoints return 401/200, not 500"
      representative_endpoint: "one endpoint per affected group responds"

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-008 VIOLATION: No minimum runnable definition provided.

        Before proceeding with structural changes touching >5 files:
        1. Define explicit runnable criteria
        2. List verification commands
        3. Document rollback trigger

        Reference: PHASE2_ALIGNMENT_PLAN_v2.md (Minimum Runnable Definition)

  # ---------------------------------------------------------------------------
  # ARCH-GOV-009: Batch Independence Validation
  # ---------------------------------------------------------------------------
  ARCH-GOV-009:
    name: Batch Independence Validation
    enforcement: BLOCKING
    added: 2025-12-30
    reference: PIN-250, PHASE2_ALIGNMENT_PLAN_v2.md
    applies_to:
      - batched_migrations
      - multi_step_extractions
      - phased_refactors

    rule: |
      Structural extraction batches must prove or disprove batch independence
      BEFORE execution begins.

    rationale: |
      Prevents false isolation assumptions.
      Ensures batch ordering reflects actual dependency graph.
      Avoids hidden coupling that breaks later batches.

    validation_requirements:
      - cross_batch_import_check: "grep for imports between batch files"
      - dependency_graph_confirmation: "document which batches depend on which"
      - reorder_decision: "if coupling found, adjust batch boundaries"
      - independence_report: "produce written report before first batch"

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-009 VIOLATION: Batch independence not validated.

        Before proceeding with batched extraction:
        1. Check for cross-batch imports
        2. Document batch dependencies
        3. Produce Batch Independence Report
        4. Reorder if coupling found

        Reference: PHASE2_ALIGNMENT_PLAN_v2.md (Batch Independence Validation)

  # ---------------------------------------------------------------------------
  # ARCH-GOV-010: Structural Diff Invariant
  # ---------------------------------------------------------------------------
  ARCH-GOV-010:
    name: Structural Diff Invariant
    enforcement: BLOCKING
    added: 2025-12-30
    reference: PIN-250, PHASE2_ALIGNMENT_PLAN_v2.md
    applies_to:
      - responsibility_migrations
      - db_write_extractions
      - layer_boundary_changes

    rule: |
      Structural Diff Invariant tables are mandatory for any responsibility migration.
      For every file touched, document: what moved, where it moved, who owns it now.

    rationale: |
      Makes "no behavior change" auditable, not aspirational.
      Creates reviewable evidence trail.
      Enables precise rollback if issues discovered.

    required_table_format: |
      | File | Existing Behavior | New Owner | Layer | Before | After |
      |------|-------------------|-----------|-------|--------|-------|
      | path | what it did       | new func  | L4/L6 | direct | via X |

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-010 VIOLATION: No Structural Diff Invariant table provided.

        Before migrating responsibility:
        1. Produce table showing every move
        2. Document existing behavior
        3. Document new owner function and layer
        4. Show before/after call paths

        No undocumented moves. Period.

        Reference: PHASE2_ALIGNMENT_PLAN_v2.md (Structural Diff Invariant)

  # ARCH-GOV-011: CI Discovery Timing Gate
  # Purpose: CI must measure truth, not encode assumptions.
  ARCH-GOV-011:
    name: CI Discovery Timing
    purpose: Ensure CI discovery occurs only after structural alignment and before semantic alignment
    status: BLOCKING
    effective_date: 2025-12-30
    applies_to: CI implementation decisions

    rule: |
      CI discovery must occur only after structural alignment is complete
      and before semantic alignment begins.

    rationale: |
      - Premature CI encodes lies at scale
      - CI checks on unstable structure create false signals
      - Structure must be understood before it can be measured
      - CI discovery is observation, not enforcement

    preconditions:
      - Phase 2 structural alignment complete (PHASE2_COMPLETION_GATE.md exists)
      - Structural Truth Map updated (post-alignment)
      - No structural work remains in current phase

    ci_discovery_ladder:
      rung_1:
        name: Discovery
        behavior: Observe, record, propose
        enforcement: None
      rung_2:
        name: Dry-Run CI
        behavior: Warn only, never fail
        phase: Phase 3
      rung_3:
        name: Soft Gates
        behavior: Fail new violations, grandfather existing
        phase: Mid Phase 3
      rung_4:
        name: Hard Gates
        behavior: Full enforcement
        phase: Phase 4

    forbidden_during_discovery:
      - Adding CI checks
      - Writing test code for CI
      - Fixing lint/typing issues flagged by discovery
      - Refactoring because CI flagged it
      - Mixing CI discovery with Phase 3 execution

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-011 VIOLATION: CI discovery timing incorrect.

        CI discovery requires:
        1. Structural alignment complete (PHASE2_COMPLETION_GATE.md)
        2. Structural Truth Map current
        3. No structural work remains

        CI discovery produces:
        - CI Candidate Matrix (observation only)

        CI discovery does NOT:
        - Add CI checks
        - Fail builds
        - Fix code

        Reference: CI_CANDIDATE_MATRIX.md, PHASE2_RETROSPECTIVE.md

  # ---------------------------------------------------------------------------
  # ARCH-GOV-014: Mandatory Semantic Spot Audits
  # ---------------------------------------------------------------------------
  # Purpose: Artifacts do NOT guarantee semantics. Only code inspection does.
  # Paper is necessary but never sufficient.
  ARCH-GOV-014:
    name: Mandatory Semantic Spot Audits
    purpose: Ensure declared semantics are reflected in actual code behavior
    status: BLOCKING
    added: 2025-12-30
    reference: PIN-251

    principle: |
      Never audit everything.
      Always audit randomly.
      Drift hides in the "unlikely" files.

    audit_trigger_points:
      - End of each Phase sub-step (e.g., Phase 3.1, Phase 3.2)
      - Before approval of the next phase
      - Before any governance or CI promotion
      - Before unlocking product work

    file_selection_rules:
      minimum_files: 5
      alternative: "5% of touched files (whichever is higher)"
      span_requirement: "Files must span multiple layers"
      mandatory_inclusion:
        - At least one "semantically neutral" file
        - At least one "authority" file (decision/enforcement)
        - At least one "boundary" file (cross-layer)

    verification_checks:
      - name: Layer fidelity
        question: "Is this file actually behaving like its declared layer?"
      - name: X-axis role
        question: "Is its role (verification/decision/execution/utility) true in code?"
      - name: Y-axis boundary
        question: "Is it leaking authority across layers?"
      - name: Z-axis timing
        question: "Does execution timing match the contract?"
      - name: State authority
        question: "Is it mutating state it claims not to?"
      - name: Naming honesty
        question: "Does the name reflect what it does?"

    classification_outcomes:
      MATCH:
        meaning: "Code aligns with declared semantics"
        action: "Proceed to approval"
      DRIFT:
        meaning: "Behavior violates declared semantics"
        action: "BLOCK phase until resolved"
        resolution_options:
          - Fix code
          - Update semantic contract
          - Reclassify file
      MISREPRESENTATION:
        meaning: "Semantics are wrong or misleading"
        action: "BLOCK phase, escalate to governance review"

    role_separation:
      claude:
        - Produces artifacts
        - Implements code
        - Declares semantics
        - Surfaces code on request for inspection
      human_or_adversarial_inspector:
        - Randomly selects files
        - Challenges claims
        - Blocks approval if semantics do not hold

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-014 VIOLATION: No Semantic Spot Audit performed.

        Phase approval requires:
        1. Random file selection (≥5 files or ≥5% of touched files)
        2. Code-level verification against declared semantics
        3. Pass verdict from adversarial inspector

        Artifacts do NOT guarantee semantics.
        Only code inspection does.

        Reference: PIN-251, Semantic Spot Audit mechanism

  # ---------------------------------------------------------------------------
  # ARCH-GOV-015: Semantic Contract Authority
  # ---------------------------------------------------------------------------
  # Purpose: Frozen semantic contracts are the source of truth, not just guidance.
  # Code, refactors, and product work must conform to them.
  ARCH-GOV-015:
    name: Semantic Contract Authority
    purpose: Frozen semantic contracts are normative, not advisory
    status: BLOCKING
    added: 2025-12-30
    reference: PIN-251, Phase 3 Completion

    principle: |
      Frozen semantic contracts are the source of truth.
      Code must conform to declared semantics.
      "But it works" is not a valid override.

    frozen_contracts:
      - name: AUTH_SEMANTIC_CONTRACT.md
        phase: "3.1"
        frozen: 2025-12-30
        scope: Authentication and authorization semantics

      - name: EXECUTION_SEMANTIC_CONTRACT.md
        phase: "3.2"
        frozen: 2025-12-30
        scope: Execution model, async/sync, guarantees

      - name: WORKER_LIFECYCLE_SEMANTIC_CONTRACT.md
        phase: "3.3"
        frozen: 2025-12-30
        scope: Worker states, transitions, authority

      - name: RECOVERY_SEMANTIC_CONTRACT.md
        phase: "3.4"
        frozen: 2025-12-30
        scope: Recovery candidates, actions, provenance

      - name: TRANSACTION_AUTHORITY_SEMANTIC_CONTRACT.md
        phase: "3.5"
        frozen: 2025-12-30
        scope: WHO may mutate WHAT, authority classes

    rules:
      - id: SCA-001
        rule: No code change may contradict a frozen semantic contract
        enforcement: BLOCKING
        resolution: Semantic amendment required, not workaround

      - id: SCA-002
        rule: Violations require explicit semantic amendment, not bypass
        enforcement: BLOCKING
        resolution: Amendment process in ARCH-GOV-016

      - id: SCA-003
        rule: Semantic contracts outrank patterns, conventions, and CI heuristics
        enforcement: BLOCKING
        resolution: When in conflict, contract wins

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-015 VIOLATION: Code contradicts frozen semantic contract.

        Frozen semantic contracts are normative.
        Code must conform to declared semantics.

        Resolution options:
        1. Modify code to conform to the contract
        2. Initiate semantic amendment process (ARCH-GOV-016)

        "But it works" is not a valid override.

        Reference: PIN-251, Phase 3 Semantic Contracts

  # ---------------------------------------------------------------------------
  # ARCH-GOV-016: Semantic Change Protocol
  # ---------------------------------------------------------------------------
  # Purpose: Semantics must evolve intentionally, not accidentally.
  # Meaning changes before behavior changes.
  ARCH-GOV-016:
    name: Semantic Change Protocol
    purpose: Define how frozen semantics may be amended
    status: BLOCKING
    added: 2025-12-30
    reference: PIN-251, Phase 3 Completion

    principle: |
      Meaning changes before behavior changes.
      Code must not diverge from frozen semantics without formal process.
      Accidental semantic drift is a governance failure.

    amendment_process:
      - step: 1
        action: Identify affected contract(s)
        description: Which frozen semantic contract(s) need to change?

      - step: 2
        action: Declare reason
        description: |
          Why does the semantic need to change?
          Valid reasons: new capability, constraint relaxation, error correction
          Invalid reasons: convenience, "easier this way", optimization

      - step: 3
        action: Draft versioned amendment
        description: |
          Create amendment document with:
          - Original semantic definition
          - Proposed new semantic definition
          - Justification for change
          - Impact analysis (what code changes)

      - step: 4
        action: Human approval
        description: Semantic amendments require explicit human approval

      - step: 5
        action: Update contract version
        description: Contract version incremented, amendment recorded

    rules:
      - id: SCP-001
        rule: Code must not diverge from frozen semantics without this process
        enforcement: BLOCKING

      - id: SCP-002
        rule: Semantic amendments must precede code changes
        enforcement: BLOCKING

      - id: SCP-003
        rule: Amendments require human approval
        enforcement: BLOCKING

    on_violation:
      action: BLOCK
      message: |
        ARCH-GOV-016 VIOLATION: Code diverges from frozen semantics without amendment.

        Semantic change requires:
        1. Identified affected contract(s)
        2. Declared reason (new capability, constraint, or correction)
        3. Versioned amendment or replacement
        4. Human approval

        Code must not diverge from frozen semantics without this process.

        Reference: PIN-251, Semantic Change Protocol

  # ---------------------------------------------------------------------------
  # ARCH-GOV-PRODUCT: Product Unlock Condition
  # ---------------------------------------------------------------------------
  # Purpose: Record that Phase 3 is complete and PRODUCT work is unlocked.
  # Foundational phases may not be reopened without formal amendment.
  ARCH-GOV-PRODUCT:
    name: Product Unlock Condition
    purpose: Record Phase 3 completion and protect momentum
    status: INFORMATIONAL
    added: 2025-12-30
    reference: PIN-251, Phase 3 Completion

    phase_3_status: COMPLETE

    semantic_pillars:
      - phase: "3.1"
        name: Auth Semantics
        contract: AUTH_SEMANTIC_CONTRACT.md
        status: FROZEN

      - phase: "3.2"
        name: Execution Semantics
        contract: EXECUTION_SEMANTIC_CONTRACT.md
        status: FROZEN

      - phase: "3.3"
        name: Worker Lifecycle
        contract: WORKER_LIFECYCLE_SEMANTIC_CONTRACT.md
        status: FROZEN

      - phase: "3.4"
        name: Recovery Semantics
        contract: RECOVERY_SEMANTIC_CONTRACT.md
        status: FROZEN

      - phase: "3.5"
        name: Transaction Authority
        contract: TRANSACTION_AUTHORITY_SEMANTIC_CONTRACT.md
        status: FROZEN

    unlocked:
      - PRODUCT work
      - Feature development
      - UI/UX changes
      - Business experiments

    protected:
      note: |
        Once Phase 3 (Semantics) is closed:
        - Product work is allowed
        - Foundational phases (1–3) may not be reopened
          unless a semantic contract is formally amended (ARCH-GOV-016)

    principle: |
      Phase 3 is COMPLETE.
      All semantic pillars are defined.
      The system has explicit meaning.

      Product work proceeds under semantic governance.
      Foundational phases are closed.

# =============================================================================
# SECTION 27: GOVERNANCE QUALIFIER — SESSION PLAYBOOK AUTHORITY
# =============================================================================
# Purpose: This session playbook is a governance instrument, not an execution mandate.
# It governs HOW analysis proceeds and WHEN fixes are allowed.
# It does NOT grant authority to invent product behavior or redefine domain policy.
# Reference: PIN-254 Phase C
# =============================================================================

governance_qualifier:
  purpose: |
    This session playbook is a GOVERNANCE INSTRUMENT, not an execution mandate.

    It governs:
    - How analysis proceeds
    - When fixes are allowed
    - Who has authority to decide intent

    It does NOT grant authority to:
    - Invent product behavior
    - Redefine domain policy
    - Introduce new capabilities
    - Optimize or redesign architecture

  classification:
    document_type: Governance & Verification Playbook
    authority_level: Process-Governing, NOT System-Governing
    scope: Analysis order, fix timing, credibility gates
    binding_nature: Binding on SESSION BEHAVIOR, not code semantics

  authority_boundary:
    description: |
      The Session Playbook governs the order and rules of reasoning —
      NOT the meaning of the system.

    playbook_may_decide:
      - When a phase starts or blocks
      - Whether a violation must be fixed now or later
      - Whether the system is "clean enough" to proceed

    playbook_may_NOT_decide:
      - What the correct domain policy is
      - What thresholds should be
      - How business logic should behave
      - What product promises are made

    such_decisions_belong_to:
      - L4 domain contracts
      - Explicit design authority
      - Human owner approval

    on_ambiguity: |
      If such decisions are required → the playbook must pause and escalate.

  claude_enforcement_clause:
    rule: |
      If a task requires choosing WHAT the system should do (policy, thresholds, guarantees),
      and not merely WHERE that logic should live,
      Claude must stop and request explicit design authority input.

    claude_must_NOT_infer_intent_from:
      - Naming
      - Usage frequency
      - Convenience
      - Common patterns

  fix_authorization_constraint:
    description: |
      Fixes are allowed ONLY when ALL of the following are true:

    conditions:
      - id: FAC-001
        condition: A violation has been identified by a completed phase
        required: true

      - id: FAC-002
        condition: The fix is STRUCTURAL, not semantic
        required: true

      - id: FAC-003
        condition: The fix MOVES existing logic to the correct layer
        required: true

      - id: FAC-004
        condition: The fix does NOT change behavior
        required: true

      - id: FAC-005
        condition: The fix resolves a defined governance violation
        required: true

    unauthorized_fixes:
      description: |
        If a fix would do any of the following, it is NOT authorized:

      disallowed:
        - Introduce new rules
        - Change thresholds
        - Redefine eligibility
        - Alter product guarantees

      requires_instead:
        - Explicit domain design approval
        - Separate design contract or PIN

  session_validity_rule:
    rule: |
      Any work performed outside the rules of this playbook is
      NON-AUTHORITATIVE and must be re-validated.

    prevents:
      - Silent drift
      - '"We already fixed this" arguments'
      - Retroactive justification

  escalation_clause:
    claude_must_escalate_if:
      - Domain intent is ambiguous
      - Two layers claim authority over the same rule
      - A fix would require semantic choice
      - A violation cannot be resolved structurally

    escalation_response: |
      "Governance boundary reached. This decision requires explicit domain authority. Session paused."

  rationale: |
    This qualifier ensures:
    - The playbook KEEPS THE SYSTEM HONEST
    - The AI DOES NOT BECOME THE ARCHITECT
    - Fixes do not smuggle in design decisions
    - Top-down validation reflects REAL AUTHORITY, not inferred intent

    Without this qualifier:
    - The process becomes powerful but unsafe
    - Claude could unintentionally redesign the system

    With it:
    - The system stays credible
    - Authority remains human-owned
    - Governance is explicit, not implicit

# =============================================================================
# SECTION 28: BIDIRECTIONAL LAYER CONSISTENCY AUDITOR (BLCA)
# =============================================================================
# Purpose: Standing governance sentinel for continuous bidirectional verification.
# Claude must run BLCA at session start and after any L2-L7 code changes.
# Non-clean results must escalate into governance artifacts (PIN or playbook update).
# Work is BLOCKED while audit status is BLOCKED.
# Single source of truth: docs/governance/BIDIRECTIONAL_AUDIT_STATUS.md
# Reference: PIN-254 (Layered Semantic Completion), Phase C′ certified
# =============================================================================

bidirectional_layer_consistency_auditor:
  version: "1.0"
  status: ACTIVE
  reference: PIN-254

  purpose: |
    The Bidirectional Layer Consistency Auditor (BLCA) is a standing governance
    sentinel that ensures the architecture tells the truth in both directions:

    - Bottom-Up: Every execution path maps to an L4 semantic owner
    - Top-Down: Every L2 API has a real execution path

    BLCA runs at defined triggers and produces persistent audit artifacts.
    Inline or conversational reporting is NOT acceptable.

  enforcement_contract:
    rule: |
      Claude must run the Bidirectional Layer Consistency Auditor at the start
      of every session. Any non-clean result must be escalated into governance
      artifacts (PIN or playbook update). Claude may not proceed while audit
      status is BLOCKED. Audit results must never be reported only inline or
      conversationally.

    claude_must:
      - Run BLCA at session start
      - Run BLCA after any L2-L7 code modification
      - Update docs/governance/BIDIRECTIONAL_AUDIT_STATUS.md with results
      - Escalate non-clean results to PIN-254 or create new PIN
      - Block work if audit status is BLOCKED

    claude_must_NOT:
      - Report audit results only in conversation
      - Skip BLCA after code changes
      - Proceed with work while audit is BLOCKED
      - Mark issues as CLEAN without verification

  audit_triggers:
    - trigger: session_start
      description: Every new session
      action: Run full audit

    - trigger: code_change
      description: After any L2-L7 modification
      action: Run incremental audit on affected layers

    - trigger: phase_completion
      description: After any phase completion (A, B, C, D)
      action: Run full audit with certification

    - trigger: pre_product_work
      description: Before any L1 changes
      action: Run full audit to verify L1 can safely proceed

    - trigger: governance_artifact_change
      description: After any modification to SESSION_PLAYBOOK.yaml or PINs
      action: Run full audit (governance drift can occur without code changes)
      rationale: |
        Governance drift can happen without code changes.
        The Phase C incident demonstrated this risk.
        BLCA must guard PROCESS, not just code.

  # ---------------------------------------------------------------------------
  # BLCA BLAST RADIUS (v2.17)
  # ---------------------------------------------------------------------------
  # BLCA confined to backend is INSUFFICIENT and creates false safety.
  # BLCA's blast radius is the entire system surface where intent becomes effect.
  # ---------------------------------------------------------------------------

  blast_radius:
    principle: |
      BLCA's blast radius is the entire system surface where intent becomes effect.
      If it can change state, schedule execution, or commit intent, it is in scope.
      Anything else is observability.

    in_scope:
      - surface: Backend (L2-L7)
        reason: Obvious - execution and state mutation
        included: true

      - surface: Frontend (L1)
        reason: User-triggered transactions originate here
        included: true

      - surface: API contracts
        reason: Promise ↔ execution boundary
        included: true

      - surface: Workers / jobs
        reason: Deferred transactions
        included: true

      - surface: Integrations / webhooks
        reason: External-triggered authority
        included: true

      - surface: Feature flags / config
        reason: Conditional authority
        included: true

      - surface: CI / automation
        reason: Must never transact (hygiene only)
        included: false
        note: Except L8 hygiene checks

  # ---------------------------------------------------------------------------
  # TRANSACTION DEFINITION (v2.17)
  # ---------------------------------------------------------------------------
  # Narrow definition (DB writes only) misses 60-70% of real risk.
  # ---------------------------------------------------------------------------

  transaction_definition:
    principle: |
      A transaction is any action that moves the system from one authoritative
      state to another, whether synchronously or asynchronously.

    clarifier: |
      A transaction requires irreversible or authoritative effect.
      Ephemeral UI state, client-side previews, and optimistic rendering
      are NOT transactions unless they commit intent downstream.

    NOT_transactions:
      description: |
        The following are explicitly NOT transactions and must NOT be flagged by A6:
      excludes:
        - Ephemeral UI state (component state, form drafts)
        - Client-side previews (hover states, tooltips)
        - Optimistic rendering (until committed)
        - Feature toggles (unless they gate authority)
        - Navigation shortcuts
        - Local storage caching
        - UI animations and transitions

    backend_transactions:
      - DB writes
      - Redis mutations
      - Job enqueueing
      - State machine transitions
      - API calls that create/update/delete
      - Workflow triggers
      - Approval/rejection/escalation actions

    frontend_transactions:
      description: |
        If a UI action CAN cause a backend mutation, it is a transaction initiator.
      includes:
        - API calls that create/update/delete
        - API calls that trigger workflows
        - API calls that approve/reject/escalate
        - Client-side gating that suppresses actions
        - Client-side gating that auto-submits decisions
        - Confirm/Apply/Execute button handlers

  # ---------------------------------------------------------------------------
  # FRONTEND RULES (F1, F2, F3) — v2.17
  # ---------------------------------------------------------------------------
  # BLCA does not audit code style — it audits intent-to-effect paths.
  # ---------------------------------------------------------------------------

  frontend_rules:
    principle: |
      BLCA does not audit code style — it audits intent-to-effect paths.
      BLCA cares about three things in frontend code: F1, F2, F3.

    rules:
      - id: F1
        name: Transactional Entry Points
        description: |
          Any UI action that:
            - calls a mutating API
            - triggers execution
            - commits a decision
        examples:
          - onSubmit()
          - onApprove()
          - onExecute()
          - dispatch(action) that calls L2
        requirements:
          - Each entry point maps to a known L2 API
          - The API is registered in BLCA
          - The API has a full L2→L7 path
        violation_response: |
          BLCA BLOCK: UI calls unknown API. Register in BLCA before proceeding.

      - id: F2
        name: Client-Side Authority
        severity: HIGH
        blocking: true
        description: |
          BLCA must flag if frontend code:
            - decides eligibility
            - applies thresholds
            - auto-approves without backend confirmation
        violation_examples:
          - "if (confidence > 0.8) autoExecute()"
          - Client-enforced role checks
          - Feature gating without backend confirmation
        classification: Authority leak, not UX choice
        escalation_rule: |
          Any frontend authority violation (F2) is automatically HIGH severity and BLOCKING.
          Client-side authority leaks are the most dangerous class of drift.
          F2 violations may NEVER be classified as MEDIUM or LOW.
        violation_response: |
          BLCA BLOCK: Frontend authority detected. Authority belongs in L4.
          Severity: HIGH. This is a blocking issue.

      - id: F3
        name: Silent Side Effects
        description: |
          BLCA must flag if frontend code:
            - auto-fires transactions on load
            - retries without user intent
            - batches or cascades actions
        frontend_allowed:
          - Display data
          - Collect input
          - Request action (with user intent)
        frontend_forbidden:
          - Decide eligibility
          - Auto-execute
          - Cascade without explicit user action
        violation_response: |
          BLCA BLOCK: Silent side effect detected. Transactions require explicit intent.

  # ---------------------------------------------------------------------------
  # INTENT GRAPH MODEL (v2.17)
  # ---------------------------------------------------------------------------
  # BLCA operates as graph validation, not code scanning.
  # ---------------------------------------------------------------------------

  intent_graph:
    description: |
      BLCA maintains a living Intent Graph that traces from actor to state.
      BLCA checks two things continuously: bottom-up and top-down.

    graph_structure:
      - level: Human / External Actor
        description: Origin of intent
      - level: L1 Entry Point
        description: UI transaction initiator
      - level: L2 API
        description: Contract boundary
      - level: L3 Adapter
        description: Translation layer
      - level: L4 Policy
        description: Domain authority
      - level: L5 Execution
        description: Action performer
      - level: L6 State
        description: Authoritative storage
      - level: L7 Ops
        description: Infrastructure

    checks:
      bottom_up: |
        Does this execution path have a declared origin and exposure?
      top_down: |
        Does this exposed action actually execute something real?

    break_condition: |
      If either side breaks → governance alert.

  # ---------------------------------------------------------------------------
  # GOVERNANCE ESCALATION RULES (v2.17)
  # ---------------------------------------------------------------------------
  # Claude must surface — humans must decide.
  # BLCA never decides intent, it decides consistency.
  # ---------------------------------------------------------------------------

  governance_escalation:
    principle: |
      Claude must surface — humans must decide.
      BLCA never decides intent, it decides consistency.

    escalation_matrix:
      - finding: Unknown transaction
        action: New governance issue
        severity: HIGH

      - finding: Ambiguous authority
        action: Escalate to human
        severity: MEDIUM

      - finding: Frontend authority leak
        action: BLOCK
        severity: HIGH

      - finding: Backend orphan execution
        action: BLOCK
        severity: HIGH

      - finding: Partial mapping
        action: WARN + decision required
        severity: MEDIUM

    output: |
      BLCA produces facts.
      Humans ratify intent.

  consistency_axes:
    - axis: A1
      name: Bottom-Up Execution Path Verification
      question: Does every L5/L6/L7 action map to an L4 semantic owner?
      clean_condition: All execution paths have L4 authority
      failure_action: Document orphan path, assign to domain engine or quarantine

    - axis: A2
      name: Top-Down API Truthfulness Verification
      question: Does every L2 API have a real execution path?
      clean_condition: All APIs map to real execution
      failure_action: Remove decorative API or implement real path

    - axis: A3
      name: Layer Authority Purity Check
      question: Does each layer contain only its authorized content?
      clean_condition: |
        - L2: No policy, no execution
        - L3: No policy, no classification
        - L4: No execution, no orchestration
        - L5: No domain decisions
        - L6: No business meaning
        - L7: No domain semantics
        - L8: No runtime, no domain, no execution
      failure_action: Relocate misplaced logic to correct layer

    - axis: A4
      name: L8 Containment Sentinel
      question: Is L8 free of runtime/domain/execution leaks?
      clean_condition: |
        - No runtime writes in L8
        - No domain decisions in tests
        - No execution orchestration in CI
        - No prod-impacting test logic
        - Validators are observational only
      failure_action: Relocate to appropriate layer

    - axis: A5
      name: Governance Escalation Audit
      question: Have all findings been escalated to governance artifacts?
      clean_condition: No orphan findings (all in PINs or playbook)
      failure_action: Create PIN or update playbook

    - axis: A6
      name: Frontend Transaction Audit
      question: Do all L1 transaction initiators map to registered L2 APIs with full paths?
      clean_condition: |
        - All transactional entry points (F1) map to known L2 APIs
        - No client-side authority leaks (F2)
        - No silent side effects (F3)
        - All L1→L2 calls have documented L2→L7 paths
      failure_action: |
        F1 violation: Register API in BLCA, document full path
        F2 violation: BLOCK - relocate authority to L4
        F3 violation: BLOCK - require explicit user intent
      scope: Frontend (L1) transaction initiators
      note: |
        A6 extends BLCA beyond backend to close the frontend loophole.
        Frontend is allowed to: display, collect input, request action.
        Frontend is NOT allowed to: decide, auto-execute, cascade.

  audit_output:
    single_source_of_truth: docs/governance/BIDIRECTIONAL_AUDIT_STATUS.md

    required_fields:
      - field: run_metadata
        contains:
          - session_id
          - timestamp
          - scope (L2-L8)
          - trigger
          - previous_status

      - field: axis_results
        contains:
          - axis_id
          - status (CLEAN, WARNING, BLOCKED)
          - findings (if non-clean)
          - remediation_required

      - field: overall_verdict
        values:
          - CLEAN: All axes pass
          - WARNING: Non-critical issues found
          - BLOCKED: Critical issues require remediation

      - field: next_action
        description: What must happen before proceeding

  status_transitions:
    - from: CLEAN
      to: WARNING
      condition: Non-critical finding discovered
      action: Document finding, continue with caution

    - from: CLEAN
      to: BLOCKED
      condition: Critical finding discovered (C1 or authority violation)
      action: STOP work, remediate immediately

    - from: WARNING
      to: CLEAN
      condition: All warnings resolved
      action: Document resolution in audit history

    - from: WARNING
      to: BLOCKED
      condition: Warning escalates or new critical finding
      action: STOP work, remediate immediately

    - from: BLOCKED
      to: CLEAN
      condition: All blockers resolved and verified
      action: Document resolution, full re-audit required

  blocking_rules:
    - rule_id: BLCA-001
      name: Session Audit Required
      enforcement: |
        Claude must run BLCA at session start. Work is invalid without
        SESSION_BOOTSTRAP_CONFIRMATION including BLCA status.

    - rule_id: BLCA-002
      name: Code Change Re-audit
      enforcement: |
        After any L2-L7 code modification, BLCA must run before proceeding.
        Changes without re-audit are governance violations.

    - rule_id: BLCA-003
      name: BLOCKED Status Halts Work
      enforcement: |
        While audit status is BLOCKED, Claude may only work on remediation.
        No new features, no refactors, no unrelated changes.

    - rule_id: BLCA-004
      name: Persistent Artifact Required
      enforcement: |
        Audit results must be written to BIDIRECTIONAL_AUDIT_STATUS.md.
        Inline conversation is NOT acceptable for audit results.

    - rule_id: BLCA-005
      name: Escalation Required for Non-Clean
      enforcement: |
        Any non-CLEAN result must be escalated to:
        - PIN-254 (if related to layered semantic completion)
        - New PIN (if new architectural issue)
        - SESSION_PLAYBOOK.yaml (if governance gap)

  integration_with_phases:
    phase_a:
      description: L5 → L4 Domain Semantics
      blca_axes: A1 (Bottom-Up), A3 (Authority)
      audit_timing: After each violation fix

    phase_b:
      description: L4 → L3 Translation Integrity
      blca_axes: A1, A3
      audit_timing: After each adapter fix

    phase_c:
      description: L3 → L2 API Truthfulness
      blca_axes: A2 (Top-Down), A3
      audit_timing: After Phase C discovery, after C′ remediation

    phase_c_prime:
      description: Architectural Closure & L8 Hygiene
      blca_axes: A3, A4 (L8 Containment), A5 (Governance)
      audit_timing: Full audit required for certification

    phase_d:
      description: Bidirectional Reconciliation (Top-Down)
      blca_axes: All (A1-A5)
      audit_timing: Continuous during top-down validation

  rationale: |
    BLCA institutionalizes the bidirectional verification discipline established
    by PIN-254. Without BLCA:

    - Architectural drift can occur silently between sessions
    - Code changes may violate layer boundaries without detection
    - Governance findings may exist only in conversation (ephemeral)
    - Phase D (top-down) may run on a system that has drifted

    With BLCA:
    - Every session starts with verified architectural state
    - Code changes trigger immediate re-verification
    - Findings are persistent in governance artifacts
    - The system remains truthful in both directions

  # ---------------------------------------------------------------------------
  # PHASE D GOVERNANCE CONSTRAINTS
  # ---------------------------------------------------------------------------
  # These constraints ensure Phase D operates under BLCA supremacy and
  # produces binary (pass/fail) results, not subjective assessments.
  # ---------------------------------------------------------------------------

  phase_d_governance:
    status: MANDATORY
    effective: 2025-12-31
    reference: PIN-254

    constraints:
      - id: D-1
        name: BLCA Supremacy During Phase D
        rule: |
          During Phase D, BLCA findings override Phase D progress.
          If BLCA status becomes BLOCKED at any point, Phase D must pause immediately.
        enforcement: |
          Phase D cannot continue, complete, or claim success while BLCA status is non-CLEAN.
          This prevents "we're almost done, let's ignore this" reasoning.
        violation_response: |
          PHASE D PAUSED: BLCA status is [status]. Remediation required before continuation.

      - id: D-2
        name: Validation-Only Mode
        rule: |
          Phase D may not introduce fixes unless they are required to restore BLCA to CLEAN status.
        enforcement: |
          Phase D is for VERIFICATION, not REPAIR.
          Any fix applied during Phase D must:
            1. Be directly required to restore BLCA CLEAN
            2. Be documented as "D-remediation" not "D-improvement"
            3. Trigger BLCA re-run immediately after
        violation_response: |
          PHASE D FIX REJECTED: This fix is not required for BLCA restoration.
          Phase D is validation-only. Defer to future phase or separate PIN.

      - id: D-3
        name: Binary Success Criteria
        rule: |
          Phase D is COMPLETE when ALL of the following are true:
            1. All L2→L7 paths are traceable
            2. All L1 transactional entry points are classified
            3. Unclassified Transactions = 0
            4. No undocumented asymmetry remains
            5. BLCA status remained CLEAN for the full duration of Phase D
        enforcement: |
          Phase D success is BINARY, not subjective.
          "Looks good" is not an acceptable completion criterion.
          If BLCA flipped even once during Phase D → Phase D is INCOMPLETE.
          If Unclassified Transactions > 0 → Phase D is INCOMPLETE.
        completion_gate: |
          Phase D may only be marked COMPLETE when:
            - BLCA has run at least once per session during Phase D
            - BLCA has never reported non-CLEAN during Phase D
            - All L2 APIs have documented L7 provenance
            - All L7 execution paths have documented L2 exposure
            - All L1 transactional entry points are in Frontend Transaction Registry
            - Unclassified Transactions section is EMPTY

      - id: D-4
        name: Phase D Failure Semantics
        rule: |
          Phase D may fail. Failure is a valid and expected outcome.
          Any failure must result in governance artifacts, not silent correction.
        enforcement: |
          If Phase D discovers issues:
            1. Issues must be logged in governance artifacts (BLCA status, PIN, or playbook)
            2. Silent correction is FORBIDDEN
            3. "Let's just fix it and move on" is FORBIDDEN
            4. Each failure must be traceable and ratifiable
        failure_outcomes:
          - outcome: BLCA becomes non-CLEAN during Phase D
            action: Log to BIDIRECTIONAL_AUDIT_STATUS.md, pause Phase D
          - outcome: Unclassified transaction discovered
            action: Add to Unclassified Transactions section, require human decision
          - outcome: Frontend authority leak (F2) found
            action: BLOCK immediately (HIGH severity), document in PIN
          - outcome: Undocumented L2→L7 path found
            action: Document gap, classify as WARNING or BLOCK based on severity
        restart_condition: |
          If BLCA flips to non-CLEAN during Phase D, Phase D does not "continue after fix".
          Phase D RESTARTS from the beginning after remediation is complete.

    phase_d_as_blca_stress_test:
      description: |
        Phase D is the FIRST ADVERSARIAL TEST of BLCA.

        BLCA was installed immediately after Phase C′ certification.
        At that moment, the system had just been certified clean.
        "CLEAN" status is plausible but BLCA has not yet proven itself adversarial.

        Phase D must therefore be treated as:
          - A validation exercise for the architecture
          - AND a stress test for BLCA itself

        If Phase D completes without BLCA detecting any issues, this proves:
          1. The architecture is bidirectionally consistent
          2. BLCA is capable of maintaining that consistency

        If Phase D reveals issues BLCA should have caught, this requires:
          1. BLCA enhancement (new axis or refined check)
          2. Documented as BLCA gap, not just architecture gap

      primary_objective: |
        Phase D's primary objective is to test BLCA's ability to detect drift,
        NOT to prove the system is perfect.

        Phase D success is NOT "no findings".
        Phase D success IS "findings are surfaced, escalated, and handled correctly".

        This protects against false failure if BLCA catches something.
        A finding is evidence BLCA works, not evidence Phase D failed.

# =============================================================================
# Section 29: STEADY-STATE BLCA GOVERNANCE LOOP (Post-Phase D)
# =============================================================================
#
# Status: ACTIVE (effective after Phase D completion)
# Created: 2025-12-31
# Reference: PIN-254, BIDIRECTIONAL_AUDIT_STATUS.md
# Baseline: "Truthful Architecture v1" (2025-12-31)
#
# Purpose: Define operational cadence for BLCA to prevent decay.
#          Without this, BLCA fatigue, soft overrides, and semantic rot are guaranteed.
#
# =============================================================================

steady_state_governance:

  # ---------------------------------------------------------------------------
  # Core Principle: Auditability Over Findings
  # ---------------------------------------------------------------------------
  core_principle: |
    Phase D success does not require findings; it requires auditability and enforceability.

    The real success condition is:
      "If a violation HAD existed, BLCA would have forced it into governance."

    Anti-pattern to prevent: Future teams "optimising for green" by suppressing signals.

    Enforcement: BLCA value is measured by escalation fidelity, not finding count.

  # ---------------------------------------------------------------------------
  # Governance Caveats (Binding)
  # ---------------------------------------------------------------------------
  caveats:

    - id: CAVEAT-1
      name: First Test ≠ Lifetime Guarantee
      description: |
        BLCA passed its first adversarial test, not its lifetime guarantee.

        PROVEN:
          - BLCA can model the current system
          - BLCA can detect drift if it happens

        NOT YET PROVEN:
          - How BLCA behaves under rapid change
          - How noisy BLCA gets under iteration
          - Whether humans respect BLOCKED state under pressure

        Do not treat Phase D completion as permission to relax BLCA discipline.

    - id: CAVEAT-2
      name: Narrow Claim
      description: |
        Phase D proves exactly this, nothing more:

        "There is no hidden authority, no unaccounted transaction, and no semantic lie
         between intent and effect across L1-L8."

        This does NOT mean:
          - The system is "perfect"
          - No future bugs will occur
          - No design decisions remain

  # ---------------------------------------------------------------------------
  # 1. Severity Classification
  # ---------------------------------------------------------------------------
  severity_classification:

    blocking:
      description: Work halts immediately. Cannot proceed until resolved.
      findings:
        - Frontend authority violations (F2)
        - Unclassified transactions
        - Authority leakage across layers
        - Implemented endpoints not registered in BLCA
      note: |
        CORRECTED: "Implemented endpoints not registered" is BLOCKING, not WARN.
        Unregistered endpoints are how shadow APIs are born.
        "Later registration" thinking is how drift starts.

        PROPOSING an endpoint without registry = allowed (must register first)
        IMPLEMENTING an endpoint without registry = BLOCKING

    warn:
      description: Track, resolve within 48 hours. Work may continue on unrelated items.
      findings:
        - L3 translation creep
        - New signals without full consumer mapping
        - Partial documentation gaps affecting traceability

    low:
      description: Informational. Log but do not block.
      findings:
        - Naming inconsistencies
        - Non-semantic documentation drift

  # ---------------------------------------------------------------------------
  # 2. Review & Acknowledgment
  # ---------------------------------------------------------------------------
  review_and_acknowledgment:

    session_review:
      rule: |
        BLCA runs at session start and after qualifying changes.
        Session initiator must explicitly acknowledge:
          "BLCA reviewed for this session"
      enforcement: |
        This is a MECHANICAL acknowledgement, not trust.
        "Review happened" is not the same as "review was implicit".
        Missing acknowledgement = governance violation.

    blocking_acknowledgment:
      rule: |
        BLOCKING findings must be acknowledged in the same session.
        Cannot defer BLOCKING to next session.

  # ---------------------------------------------------------------------------
  # 3. Acknowledgment Cadence
  # ---------------------------------------------------------------------------
  acknowledgment_cadence:

    weekly_acknowledgment:
      rule: Weekly human acknowledgment required even if BLCA is CLEAN.
      purpose: |
        The purpose of periodic acknowledgment is not to find issues,
        but to prevent false confidence from silent green status.

        This prevents future "why are we doing this?" erosion.
      enforcement: |
        Missed acknowledgment = governance violation (non-blocking but logged).
        Pattern of missed acknowledgments = escalation to playbook review.

  # ---------------------------------------------------------------------------
  # 4. Override Authority
  # ---------------------------------------------------------------------------
  override_authority:

    no_unilateral_override:
      rule: BLOCKING findings cannot be overridden unilaterally.

    emergency_override:
      requirements:
        - Written justification
        - PIN created documenting the override
        - 24-hour remediation SLA
        - Scope limited to minimum necessary
      scope_limit: |
        CRITICAL: Emergency override applies only to the minimal scope required.
        All unrelated work remains blocked.

        Without this, overrides become a backdoor.

        Example:
          - BLOCKING finding in module A
          - Override granted for module A work only
          - Work on modules B, C, D remains blocked until CLEAN

  # ---------------------------------------------------------------------------
  # 5. Safe Work (No Re-Audit Required)
  # ---------------------------------------------------------------------------
  safe_work:

    definition: |
      The following work may proceed without triggering a full phase re-audit:

    allowed:
      - L1 features using registered L2 APIs
      - L2 endpoints registered BEFORE implementation
      - Refactors with zero new transactions

    key_phrase: |
      "Refactors that do not introduce new transactions"
      This line alone prevents 80% of accidental drift.

  # ---------------------------------------------------------------------------
  # 6. Audit-Triggering Work
  # ---------------------------------------------------------------------------
  audit_triggering_work:

    definition: |
      The following work requires a scoped phase audit before proceeding:

    triggers:
      - trigger: New transaction types
        audit: Scoped Phase C
      - trigger: New domain engines
        audit: Scoped Phase A + B
      - trigger: Frontend authority patterns
        audit: Scoped Phase D

    mini_phase_definition: |
      "Mini phase" means:
        - Same rules
        - Same BLCA enforcement
        - Smaller scope only

      "Mini phase" does NOT mean:
        - Lighter rules
        - Relaxed enforcement
        - "Good enough" verification

      If someone treats "mini" as "easier", they have misunderstood.

  # ---------------------------------------------------------------------------
  # Baseline Reference
  # ---------------------------------------------------------------------------
  baseline:
    tag: "Baseline: Truthful Architecture v1"
    date: "2025-12-31"
    scope: L1-L8 Full Stack
    purpose: |
      This is a REFERENCE POINT, not an aspiration.
      All future BLCA audits compare against this baseline.
      Drift is measured from here.

# =============================================================================
# SECTION 30: PHASE G STEADY-STATE GOVERNANCE (PERMANENT)
# =============================================================================
#
# Date: 2025-12-31
# Status: ACTIVE (Permanent)
# Reference: PIN-258 (Phase F Closure), PIN-259 (Phase G Governance)
#
# Phase G is not a construction phase. It is a GOVERNANCE REGIME.
# The architecture is complete. Phase G ensures it stays complete.
#
# =============================================================================

phase_g_governance:

  # ---------------------------------------------------------------------------
  # Prime Directive
  # ---------------------------------------------------------------------------
  prime_directive: |
    No code may be added, modified, or removed that causes BLCA to report violations.
    This is not a guideline. This is a hard gate.

  # ---------------------------------------------------------------------------
  # G-RULE Summary (Hard Rules)
  # ---------------------------------------------------------------------------
  rules:
    - rule_id: G-RULE-1
      name: BLCA Supremacy
      severity: ABSOLUTE
      summary: BLCA is sole authority. Violations block merge.

    - rule_id: G-RULE-2
      name: Layer Contract Immutability
      severity: HARD
      summary: Seven-layer model is frozen. No additions, removals, or renames.

    - rule_id: G-RULE-3
      name: Import Direction Enforcement
      severity: HARD
      summary: Import directions are mechanically enforced. L2→L5 forbidden.

    - rule_id: G-RULE-4
      name: Adapter Discipline
      severity: HARD
      summary: L3 adapters are translation only. Zero logic, <200 LOC.

    - rule_id: G-RULE-5
      name: Command Discipline
      severity: HARD
      summary: L4 commands authorize and delegate. No execution logic.

    - rule_id: G-RULE-6
      name: Worker Isolation
      severity: HARD
      summary: L5 workers are blind executors. No decisions.

    - rule_id: G-RULE-7
      name: No Reclassification Escapes
      severity: ABSOLUTE
      summary: Reclassification is not a fix. Extraction is the fix.

    - rule_id: G-RULE-8
      name: Extraction-First Resolution
      severity: HARD
      summary: Layer violations fixed by extraction, not suppression.

    - rule_id: G-RULE-9
      name: Sequential Modification
      severity: HARD
      summary: One change at a time, BLCA between each.

    - rule_id: G-RULE-10
      name: Amendment Protocol
      severity: CONSTITUTIONAL
      summary: Rule changes require PIN + human ratification.

    - rule_id: G-RULE-11
      name: Signal Ownership Requirement
      severity: BLOCKING
      summary: |
        Any discovered signal (CI, runtime, or boundary) without a named owner
        is classified as a P0 governance defect and blocks phase progression.
      reference: PIN-262
      enforcement: |
        Signal Circuit Discovery must record ownership status explicitly for every signal.
        Signals without owners:
        - Are classified as P0 governance defects
        - Block phase advancement
        - Require human action to assign an owner
        - Cannot be deferred, annotated, or accepted

  # ---------------------------------------------------------------------------
  # Feature Development Guide
  # ---------------------------------------------------------------------------
  feature_development:
    guide: docs/governance/HOW_TO_ADD_A_FEATURE.md
    checklist: docs/governance/GOVERNANCE_CHECKLIST.md
    golden_rule: "Build the authority path before you build the feature."
    principle: |
      Features do not start in code.
      Features start as intent and must earn execution.
    steps:
      - Classify (transactional or not)
      - Declare intent
      - Create L4 command (decision authority)
      - Create L3 adapter (translation only)
      - Create L2 route (HTTP concerns only)
      - Run BLCA (must be CLEAN)
      - Governance recording
      - Final attestation

  # ---------------------------------------------------------------------------
  # Governance Checklist Enforcement Rules
  # ---------------------------------------------------------------------------
  governance_checklist_rules:
    - rule_id: GC-001
      name: Checklist Required For All Features
      enforcement: BLOCKING
      description: |
        Every session that introduces or modifies behavior MUST complete
        the Governance Checklist. Missing sections block the session.

    - rule_id: GC-002
      name: Missing Sections Block Session
      enforcement: BLOCKING
      description: |
        All 7 sections of the checklist must be completed.
        Partial completion is not allowed.

    - rule_id: GC-003
      name: BLCA Not Clean Blocks Progress
      enforcement: BLOCKING
      description: |
        BLCA status must be CLEAN before claiming completion.
        Non-CLEAN status halts all work.

    - rule_id: GC-004
      name: Deferred Violations Forbidden
      enforcement: BLOCKING
      description: |
        Discovery without resolution = BLOCKED SESSION.
        Violations may not be documented away.

    - rule_id: GC-005
      name: Claude Must Surface Uncertainty
      enforcement: BLOCKING
      description: |
        If Claude is unsure about layer placement, authority,
        or classification, it must STOP and surface the uncertainty.
        Silence, assumption, or implicit compliance is a violation.

    - rule_id: GC-006
      name: Change Classification Required First
      enforcement: BLOCKING
      description: |
        change_classification section must be completed BEFORE any code.
        If any field is true, full governance pipeline is required.

    - rule_id: GC-007
      name: Final Attestation Required
      enforcement: BLOCKING
      description: |
        Session is NOT COMPLETE until attestation section shows
        all values as true. Any false value blocks completion.

  # ---------------------------------------------------------------------------
  # Layer Compliance Enforcement
  # ---------------------------------------------------------------------------
  layer_compliance_enforcement:

    L2_rules:
      performs_decision_logic: false    # MUST be false
      imports_L4_or_L5: false           # MUST be false
      delegates_to_L3: true             # MUST be true
      violation_response: BLOCKED

    L3_rules:
      contains_policy_or_thresholds: false   # MUST be false
      performs_side_effects: false           # MUST be false
      calls_single_L4_command: true          # MUST be true
      violation_response: BLOCKED

    L4_rules:
      contains_all_decisions: true           # MUST be true
      imports_only_L5_L6: true               # MUST be true
      returns_domain_result: true            # MUST be true
      violation_response: BLOCKED

    L5_rules:
      executes_only_L4_decisions: true       # MUST be true
      recomputes_authority: false            # MUST be false
      violation_response: BLOCKED

  # ---------------------------------------------------------------------------
  # Reference Documents
  # ---------------------------------------------------------------------------
  reference:
    - docs/governance/PHASE_F_CLOSURE_DECLARATION.md
    - docs/governance/PHASE_G_STEADY_STATE_GOVERNANCE.md
    - docs/governance/EXECUTIVE_ARCHITECTURE_MAP.md
    - docs/governance/HOW_TO_ADD_A_FEATURE.md
    - docs/governance/GOVERNANCE_CHECKLIST.md
    - docs/memory-pins/PIN-258-phase-f-application-boundary-completion.md
    - docs/memory-pins/PIN-259-phase-f-closure-and-phase-g-steady-state-governance.md

# =============================================================================
# SECTION 31: PRODUCT ARCHITECTURE RULES
# =============================================================================
# Reference: PIN-260 Product Architecture Clarity — One Console, All Products
# =============================================================================

product_architecture:
  # ---------------------------------------------------------------------------
  # Prime Invariant
  # ---------------------------------------------------------------------------
  prime_invariant: |
    The AI Console is not one product among many — it IS the product container.
    All product capabilities fit within the frozen console framework.
    No new architecture is required.

  # ---------------------------------------------------------------------------
  # Frozen Console Structure
  # ---------------------------------------------------------------------------
  frozen_domains:
    - name: Overview
      question: "Is the system okay right now?"
      expandable: false
    - name: Activity
      question: "What ran / is running?"
      expandable: false
    - name: Incidents
      question: "What went wrong?"
      expandable: false
    - name: Policies
      question: "How is behavior defined?"
      expandable: false
    - name: Logs
      question: "What is the raw truth?"
      expandable: false

  # ---------------------------------------------------------------------------
  # Expansion Rules
  # ---------------------------------------------------------------------------
  expansion_rules:
    domain:
      definition: "Fundamental user question"
      expandable: false
      note: "FROZEN - Cannot add new domains"
    subdomain:
      definition: "Real system boundary"
      expandable: "cautiously"
      note: "Requires strong justification"
    topic:
      definition: "View or capability"
      expandable: true
      note: "Safe to add features"
    orders:
      definition: "Depth levels O1-O5"
      expandable: true
      note: "Safe to add depth"

  # ---------------------------------------------------------------------------
  # Product-to-Domain Mapping (AUTHORITATIVE)
  # ---------------------------------------------------------------------------
  product_mapping:
    - suggested_name: "AI Cost Guard"
      actually_is: "Cost visibility feature"
      console_domain: "Overview + Activity"
    - suggested_name: "AI Incident Console"
      actually_is: "The Incidents domain"
      console_domain: "Incidents"
    - suggested_name: "Agent Governance Platform"
      actually_is: "The Policies domain"
      console_domain: "Policies"
    - suggested_name: "Compliance Evidence Generator"
      actually_is: "The Logs domain"
      console_domain: "Logs"
    - suggested_name: "Execution Monitor"
      actually_is: "The Activity domain"
      console_domain: "Activity"
    - suggested_name: "System Health Dashboard"
      actually_is: "The Overview domain"
      console_domain: "Overview"

  # ---------------------------------------------------------------------------
  # External Products (Not Console)
  # ---------------------------------------------------------------------------
  external_products:
    - name: "Python SDK"
      location: "PyPI: aos-sdk"
      status: "PUBLISHED"
    - name: "JavaScript SDK"
      location: "npm: @agenticverz/aos-sdk"
      status: "PUBLISHED"
    - name: "Ops Console"
      location: "pages/ops/"
      status: "Separate jurisdiction"
    - name: "Founder Console"
      location: "pages/founder/"
      status: "Separate jurisdiction"

  # ---------------------------------------------------------------------------
  # Governance Rules
  # ---------------------------------------------------------------------------
  prevents:
    - "Suggesting new sidebar domains"
    - "Proposing 'new products' that are existing domains"
    - "Conflating feature gaps with architecture gaps"
    - "Claiming SDK 'needs packaging' (already published)"

  allows:
    - "Adding Topics within existing domains"
    - "Adding Order depth (O1-O5) within topics"
    - "Feature polish within frozen structure"
    - "UX improvements that surface existing functionality"

  # ---------------------------------------------------------------------------
  # Gap Classification
  # ---------------------------------------------------------------------------
  productization_gaps:
    description: "NOT architecture gaps — product definition work"
    types:
      - "SKU Definition: Naming what already exists implicitly"
      - "Feature Polish: Completing Topics within domains"
      - "UX Scaffolding: Guided setup for non-expert users"
      - "Customer Defaults: Pre-approved policy bundles"
      - "Documentation: User-facing feature documentation"

  true_architecture_gaps:
    - name: "Federated Agent Identity"
      status: "Intentionally Deferred"
      rationale: "Requires new identity layer, expands threat model"

  # ---------------------------------------------------------------------------
  # Session Guidance
  # ---------------------------------------------------------------------------
  session_guidance:
    rule_1: "AI Console IS the product container"
    rule_2: "5 Core Domains are FROZEN: Overview, Activity, Incidents, Policies, Logs"
    rule_3: "'Products' map to domains, not new architecture"
    rule_4: "Features fit as Topics within domains"
    rule_5: "SDK is PUBLISHED (PyPI + npm)"
    rule_6: "Only true gap: Federated Agent Identity (deferred)"

  quick_check:
    if_suggesting_new_product: "Check if it's actually a domain feature"
    if_suggesting_missing_architecture: "Check if it's productization work"

  # ---------------------------------------------------------------------------
  # One-Line Truth
  # ---------------------------------------------------------------------------
  one_line_truth: |
    The hard infrastructure is already built.
    What remains is productization discipline: feature polish within frozen domains.

  # ---------------------------------------------------------------------------
  # Reference Documents
  # ---------------------------------------------------------------------------
  reference:
    - docs/contracts/CUSTOMER_CONSOLE_V1_CONSTITUTION.md
    - docs/memory-pins/PIN-260-product-architecture-clarity.md
    - docs/memory-pins/PIN-035-sdk-package-registry.md
    - docs/memory-pins/PIN-259-phase-f-closure-and-phase-g-steady-state-governance.md

# =============================================================================
# SECTION 32: CLAUDE GOVERNANCE INSTRUCTION SET
# =============================================================================
# Reference: PIN-262 Signal Circuit Discovery Governance Clarification
# Status: AUTHORITATIVE · PHASE-AWARE · NON-NEGOTIABLE
# =============================================================================

claude_governance:
  # ---------------------------------------------------------------------------
  # 0. Operating Mode (Always On)
  # ---------------------------------------------------------------------------
  operating_mode:
    name: Governed System Mode
    status: ALWAYS_ON
    forbidden:
      - default_assumptions
      - inference_without_evidence
      - optimization_before_topology
    required:
      - explicit_contracts
      - declared_intent
      - mechanical_evidence
      - phase_discipline

  # ---------------------------------------------------------------------------
  # 1. Phase Awareness (Hard Gate)
  # ---------------------------------------------------------------------------
  phase_awareness:
    gate_type: HARD
    session_start_question: "Which phase are we in, and what work is permitted in this phase?"
    canonical_phases:
      - phase: 0
        name: Architecture & Governance
        status: FROZEN
      - phase: 1
        name: CI Signal Rediscovery & Stabilization
        status: ACTIVE
      - phase: 1.5
        name: Signal Closure / Promotion
        status: BLOCKED_UNTIL_PHASE_1_EXIT
      - phase: 2
        name: Console Completion
        status: BLOCKED
      - phase: 3
        name: Customer Lifecycle & RBAC
        status: BLOCKED
      - phase: 4
        name: Commercialization
        status: BLOCKED
      - phase: 5
        name: Support & GTM
        status: BLOCKED
    on_phase_violation:
      - action: REFUSE
      - action: STATE_VIOLATION
      - action: REDIRECT_TO_ALLOWED_WORK

  # ---------------------------------------------------------------------------
  # 2. Layer Model (Authoritative)
  # ---------------------------------------------------------------------------
  layer_model:
    status: VERBATIM_REQUIRED
    layers:
      - layer: L1
        name: Product Experience
        responsibility: UI, components
      - layer: L2
        name: Product APIs
        responsibility: REST surfaces
      - layer: L3
        name: Boundary Adapters
        responsibility: External/LLM
      - layer: L4
        name: Domain Engines
        responsibility: Policy, workflows, agents
      - layer: L5
        name: Execution & Workers
        responsibility: Jobs, runtime
      - layer: L6
        name: Platform Substrate
        responsibility: DB, auth, SDK
      - layer: L7
        name: Ops & Deployment
        responsibility: Infra, scripts
      - layer: L8
        name: Catalyst / Meta
        responsibility: CI, validators
    requirements:
      - respect_allowed_import_directions
      - flag_violations_immediately
      - never_normalize_boundary_breaches

  # ---------------------------------------------------------------------------
  # 3. Definition of a Signal (Non-Negotiable)
  # ---------------------------------------------------------------------------
  signal_definition:
    status: NON_NEGOTIABLE
    signal_is_not:
      - function_call
      - return_value
      - log_line
      - human_check
    signal_must_have:
      - Intent
      - Emission
      - Transport
      - Consumption
      - Consequence
    rule: "If any segment is missing, signal does not exist."
    direction_default: bidirectional_unless_proven_otherwise

  # ---------------------------------------------------------------------------
  # 4. Signal Circuit Discovery (SCD) Rules
  # ---------------------------------------------------------------------------
  scd_rules:
    what_scd_is:
      - forensic_topology_mapping
      - structural_truth_discovery
      - phase_1_only_activity
    what_scd_is_not:
      - refactoring
      - correctness_validation
      - runtime_testing
      - optimization
    application: mechanical_using_scd_checklist

  # ---------------------------------------------------------------------------
  # 5. Structural Correctness Standard (Phase 1)
  # ---------------------------------------------------------------------------
  structural_correctness:
    phase: 1
    circuit_acceptable_only_if:
      - expected_signals_are_named
      - emissions_are_explicit
      - consumptions_are_explicit
      - ownership_is_defined
      - consequences_are_observable
    explicitly_out_of_scope: runtime_correctness

  # ---------------------------------------------------------------------------
  # 6. Metadata Semantics Handling
  # ---------------------------------------------------------------------------
  metadata_semantics:
    rule: "Metadata is a CLAIM, not truth."
    requirements:
      - claims_must_be_corroborated_by_mechanical_evidence
      - discrepancies_must_be_surfaced_as_drift
    classification_types:
      - DECLARED_NOT_OBSERVED
      - OBSERVED_NOT_DECLARED
      - DECLARED_DIRECTION_MISMATCH
    invariant: "Metadata alone never proves correctness."

  # ---------------------------------------------------------------------------
  # 7. Automation & Workers (Strict Limits)
  # ---------------------------------------------------------------------------
  automation_limits:
    allowed_operations:
      - static_enumeration
      - boundary_detection
      - claim_vs_mechanics_comparison
    forbidden_operations:
      - declare_correctness
      - block_CI
      - enforce_governance
      - override_human_judgment
    output_classification: evidence_only

  # ---------------------------------------------------------------------------
  # 8. Governance Qualifier Handling (Mandatory)
  # ---------------------------------------------------------------------------
  governance_qualifier_handling:
    triggers:
      - missing_ownership
      - implicit_signals
      - boundary_violations
      - phase_violations
      - unenforced_governance_rules
    required_actions:
      - action: DECLARE_EXPLICITLY_AS_GOVERNANCE_QUALIFIER
      - action: ADD_AS_TASK_TO_DO
      - action: PROPOSE_SESSION_PLAYBOOK_UPDATE_RECORD_ONLY
    confirmation_rule: "Wait for user confirmation before any playbook changes are considered applied."

  # ---------------------------------------------------------------------------
  # 9. Task Discipline
  # ---------------------------------------------------------------------------
  task_discipline:
    requirements:
      - uniquely_identifiable
      - phrased_as_actions
      - explicitly_scoped
      - phase_compatible
    forbidden:
      - vague_tasks
      - future_phase_execution

  # ---------------------------------------------------------------------------
  # 10. CI & Signal Ownership Rule (Hard)
  # ---------------------------------------------------------------------------
  signal_ownership_rule:
    severity: HARD
    rule: "Any signal without a named owner is a P0 governance defect and a phase blocker."
    prohibited: "normalizing or downplaying unowned signals"

  # ---------------------------------------------------------------------------
  # 11. Prohibited Behaviors (Absolute)
  # ---------------------------------------------------------------------------
  prohibited_behaviors:
    - invent_signals
    - assume_intent
    - temporarily_ignore_violations
    - optimize_before_topology_is_closed
    - collapse_layers_for_convenience
    - treat_green_CI_as_safety_proof

  # ---------------------------------------------------------------------------
  # 12. Output Discipline
  # ---------------------------------------------------------------------------
  output_discipline:
    requirements:
      - distinguish_fact_vs_interpretation
      - label_phase_restricted_content
      - avoid_speculative_language
      - avoid_reassurance
      - avoid_motivational_framing
    principle: "Clarity over comfort."

  # ---------------------------------------------------------------------------
  # 13. Canonical Test (Self-Check)
  # ---------------------------------------------------------------------------
  canonical_self_test:
    question: "Could another engineer, using only this output, independently reach the same conclusion?"
    on_failure: response_is_invalid

  # ---------------------------------------------------------------------------
  # 14. One Line That Governs Everything
  # ---------------------------------------------------------------------------
  governing_principle: |
    If the architecture cannot explicitly observe itself, governance does not exist.

  # ---------------------------------------------------------------------------
  # 15. Signal Circuit Enumerator (SCE) Automation
  # ---------------------------------------------------------------------------
  sce_automation:
    name: Signal Circuit Enumerator
    class: Forensic / Evidence Generator
    phase_eligibility: PHASE_1_ONLY
    authority: READ_ONLY
    ci_blocking: FORBIDDEN

    allowed_access:
      - source_code: read
      - metadata_annotations: read
      - ast: parse
      - import_graph: build
      - call_graph_shallow: build
      - ci_configs: read
      - docs_contracts_playbooks: read

    forbidden_actions:
      - modify_code
      - modify_CI
      - enforce_rules
      - block_builds
      - rewrite_metadata
      - assign_ownership
      - infer_intent_beyond_metadata

    blast_radius: |
      Zero behavioral impact. Zero enforcement impact. Zero runtime impact.
      If this worker breaks, nothing else must break.

    output_classification: evidence_only

    outputs:
      - type: raw_evidence
        path: docs/ci/scd/evidence/SCE_RUN_<timestamp>.json
        mode: append_only
      - type: boundary_summary
        path: docs/ci/scd/SCE-L{X}-L{Y}-EVIDENCE.md
        mode: generated
      - type: registry_hints
        path: docs/ci/scd/SCE_REGISTRY_HINTS.md
        mode: non_authoritative

    human_treatment:
      - declared_not_observed: review_in_scd
      - observed_not_declared: decide_relevance
      - boundary_violation: record_gap
      - implicit_signal: classify_risk
      - missing_emission: mark_MISSING_EMITTER

    sanity_test:
      question: "If the worker produces zero output, does governance still function?"
      expected_answer: "yes"
      on_failure: "Worker is too powerful - kill it."

    explicit_non_goals:
      - prove_signals_fire
      - prove_signals_are_complete
      - prove_correctness
      - replace_SCD
      - replace_CI

  # ---------------------------------------------------------------------------
  # 16. Phase-S Infrastructure Rule (Mandatory)
  # ---------------------------------------------------------------------------
  phase_s_infrastructure:
    name: Phase-S Infra Semantics
    reference: PIN-264
    effective: 2026-01-01

    prime_directive: |
      Phase-S systems are infrastructure diagnostics ONLY.
      They live in L6/L7/L8, use `infra.*` semantics, and must NOT be exposed
      to product APIs, UI, or customer contracts.
      Any user-visible error system is a separate concern and must be modeled separately.

    namespace_separation:
      infra_namespace: "app.infra.*"
      product_namespace: "app.{api,services,workers}.*"
      rule: "infra.* never leaks into product.* responses"

    error_envelope_constraints:
      artifact: "app.infra.error_envelope.ErrorEnvelope"
      layer: L6
      exposure: FORBIDDEN_TO_CLIENTS
      forbidden_uses:
        - return_from_L2_APIs
        - render_in_UI
        - use_as_product_contract
        - expose_to_customers

    emission_rules_by_layer:
      L2_API:
        allowed: ["infra.*", "system.*"]
        forbidden: ["domain.*"]
      L3_Adapter:
        allowed: ["infra.*", "system.*"]
        forbidden: ["domain.*"]
      L4_Domain:
        allowed: ["domain.*", "system.*"]
        forbidden: ["infra.*"]
      L5_Worker:
        allowed: ["infra.*", "system.*"]
        forbidden: ["domain.*"]
      L6_Platform:
        allowed: ["infra.*", "system.*"]
        forbidden: ["domain.*"]

    rationale: |
      Workers (L5) execute but do not interpret domain meaning.
      Domain engines (L4) own business semantics, not infrastructure failures.
      Mixing these collapses diagnostic value and creates semantic drift.

    validation:
      - check: "L2 never returns ErrorEnvelope"
        type: AST_SCAN
        severity: BLOCKING
      - check: "L5 never emits domain.*"
        type: RUNTIME_ASSERTION
        severity: BLOCKING
      - check: "L4 never emits infra.*"
        type: RUNTIME_ASSERTION
        severity: BLOCKING

    l4_aggregation_rules:
      name: L4 Ops Aggregation Service Constraints
      reference: PIN-264 (Track 1.3 + L4 Aggregation)
      effective: 2026-01-01

      prime_directive: |
        L4 Aggregation Services translate infra truth into operator understanding.
        They query L6 infra persistence and return L4 domain models ONLY.
        No UI shaping, no pagination, no adapters, no APIs.

      service_design:
        input: "Time window, severity threshold, optional component scope"
        output: "List[OpsIncident] or similar L4 domain model"
        forbidden:
          - return_infra_artifacts_like_ErrorEnvelope
          - know_about_consoles_like_fops_or_preflight
          - paginate_results_for_display
          - sort_for_ui_presentation
          - filter_by_user_role

      publication_pipeline:
        L6_Infra_Truth: "ErrorEnvelope, DecisionSnapshot — NEVER exposed"
        L4_Domain_Interpretation: "OpsIncident, OpsHealthSignal — meaning + grouping"
        L3_View_Adapters: "FounderOpsAdapter, PreflightOpsAdapter — shape + permission"
        L2_Ops_APIs: "read-only, aggregated, role-filtered"
        L1_Consoles: "fops, preflight-fops — curated views only"

      hard_rules:
        HR_001: "Never return infra artifacts (ErrorEnvelope, raw DB rows)"
        HR_002: "Never know about consoles (fops, preflight)"
        HR_003: "Never paginate (that's L3's job)"
        HR_004: "Must be unit-testable with fake infra data"
        HR_005: "Use Protocol for dependency injection"

      testability:
        pattern: "Protocol-based dependency injection"
        example: |
          class ErrorStoreProtocol(Protocol):
              def get_errors_by_component(...) -> List[Dict[str, Any]]: ...

          class OpsIncidentService:
              def __init__(self, error_store: ErrorStoreProtocol): ...

      current_services:
        - name: OpsIncidentService
          location: app.services.ops_incident_service
          status: IMPLEMENTED
          answers: "What incidents are happening?"

    related_docs:
      - docs/governance/SEMANTIC_ARTIFACTS.md
      - docs/memory-pins/PIN-264-phase-s-system-readiness-for-first-contact.md

  # ---------------------------------------------------------------------------
  # 17. Transaction Safety Primitives (Self-Defending Architecture)
  # ---------------------------------------------------------------------------
  # MIRROR, NOT AUTHORITY:
  # This section EXPLAINS why the system works. The code ENFORCES it.
  # If this section and the code disagree, the code is right.
  # Modify the code to change behavior, not this document.
  # ---------------------------------------------------------------------------
  transaction_safety_primitives:
    name: Self-Defending Transaction Architecture
    reference: PIN-264 (Phase-2.2 Self-Defense with Intent)
    effective: 2026-01-01
    incident_origin: "2026-01-01 circuit breaker deadlock"

    mirror_not_authority: |
      This section is a MIRROR explaining "why" — not an AUTHORITY enforcing "how".
      The enforcement happens in:
        - app/infra/transaction.py (primitives, @transactional decorator)
        - scripts/ci/check_forbidden_patterns.py (syntax ban)
        - scripts/ci/check_intent_consistency.py (intent validation)

      If you want to change how transactions work, modify the code above.
      This playbook will automatically become correct by describing what is.

    prime_directive: |
      Row locks (SELECT ... FOR UPDATE) are STRUCTURALLY DANGEROUS with ORMs.
      session.commit() may release the connection to the pool, and subsequent
      operations may get a DIFFERENT connection. The new connection blocks on
      the lock held by the old connection, causing DEADLOCK.

      The system prevents this BY CONSTRUCTION, not by documentation.

    root_cause_class: |
      The real root cause is NOT "FOR UPDATE". It is:
        "Transactional intent is not explicit in feature design."

      Phase-2.2 addresses this by requiring engineers to DECLARE intent
      before they can write implementation. See: TransactionIntent enum.

    blessed_path:
      primitive: "single_connection_transaction()"
      location: "app/infra/transaction.py"
      usage: |
        from app.infra import single_connection_transaction

        with single_connection_transaction() as txn:
            row = txn.lock_row(MyTable, MyTable.id == row_id)
            row.field = new_value
            txn.commit()

      guarantees:
        - Single connection for entire scope
        - Auto-rollback on error
        - Auto-close on exit
        - Lock timeout enforcement
        - Type-safe contract (SingleConnectionTxn)

    intent_declaration:
      purpose: |
        Phase-2.2 introduces TransactionIntent: a required declaration before
        any function can use transaction primitives. This GUIDES engineers into
        correct design by making intent explicit and machine-checkable.

      enum: TransactionIntent
      location: "app/infra/transaction.py"

      intents:
        READ_ONLY:
          description: "Plain session, no locks"
          allowed_primitives: ["session.exec()", "select()"]
          required_param: "Session"

        ATOMIC_WRITE:
          description: "Transaction context, no FOR UPDATE"
          allowed_primitives: ["session.add()", "session.commit()"]
          required_param: "Session"

        LOCKED_MUTATION:
          description: "single_connection_transaction() REQUIRED"
          allowed_primitives: ["txn.lock_row()", "txn.commit()"]
          required_param: "SingleConnectionTxn"

      decorator: "@transactional(intent=TransactionIntent.X)"
      usage: |
        from app.infra import transactional, TransactionIntent, SingleConnectionTxn

        @transactional(intent=TransactionIntent.LOCKED_MUTATION)
        def trip_circuit(txn: SingleConnectionTxn, state_id: str):
            state = txn.lock_row(CostSimCBState, CostSimCBState.id == state_id)
            state.disabled = True
            txn.commit()

      ci_enforcement:
        script: "scripts/ci/check_intent_consistency.py"
        validates:
          - "LOCKED_MUTATION intent has SingleConnectionTxn as first parameter"
          - "Async functions cannot have LOCKED_MUTATION intent"
          - "Intent is registered for every decorated function"

    golden_examples:
      transaction_examples: "app/infra/transaction_examples.py"
      feature_examples: "app/infra/feature_intent_examples.py"
      purpose: |
        Reference implementations demonstrating correct intent patterns.
        Use these as templates when implementing new features.

    # -------------------------------------------------------------------------
    # FEATURE INTENT HIERARCHY (Phase-2.3)
    # -------------------------------------------------------------------------
    feature_intent_system:
      purpose: |
        Phase-2.3 extends intent from function-level to feature-level.

        TransactionIntent answers: "How does this function interact with the DB?"
        FeatureIntent answers: "What does this feature DO to system state?"

        A fully self-defending system requires BOTH.

      hierarchy: |
        FeatureIntent (module-level)
             ↓ constrains
        TransactionIntent (function-level)
             ↓ constrains
        Primitive (implementation-level)

      feature_intents:
        PURE_QUERY:
          description: "Read-only, no state changes"
          allowed_transaction_intents: ["READ_ONLY"]
          retry_policy: "any (reads are always safe)"

        STATE_MUTATION:
          description: "Changes system state (DB writes)"
          allowed_transaction_intents: ["ATOMIC_WRITE", "LOCKED_MUTATION"]
          retry_policy: "any (depends on idempotency)"

        EXTERNAL_SIDE_EFFECT:
          description: "Calls external services (APIs, webhooks)"
          allowed_transaction_intents: ["ATOMIC_WRITE"]
          retry_policy: "NEVER required (side effects can't be safely retried)"

        RECOVERABLE_OPERATION:
          description: "Must be idempotent and resumable"
          allowed_transaction_intents: ["LOCKED_MUTATION"]
          retry_policy: "SAFE required (must support restart)"

      retry_policies:
        NEVER: "Retries are forbidden (side-effects, non-idempotent)"
        SAFE: "Retries are safe (idempotent operations)"
        DANGEROUS: "Retries possible but require manual review"

      module_declaration: |
        Every state-touching module must declare at module level:

            from app.infra import FeatureIntent, RetryPolicy

            FEATURE_INTENT = FeatureIntent.STATE_MUTATION
            RETRY_POLICY = RetryPolicy.SAFE

      ci_enforcement:
        script: "scripts/ci/check_feature_intent.py"
        checks:
          - "Module uses persistence but has no FEATURE_INTENT → FAIL"
          - "TransactionIntent not in allowed set for FeatureIntent → FAIL"
          - "EXTERNAL_SIDE_EFFECT without RETRY_POLICY.NEVER → FAIL"
          - "RECOVERABLE_OPERATION without RETRY_POLICY.SAFE → FAIL"

    forbidden_patterns:
      - pattern: ".with_for_update()"
        allowed_in: ["app/infra/transaction.py"]
        ci_check: "scripts/ci/check_forbidden_patterns.py"
        severity: BLOCKING

      - pattern: "FOR UPDATE in raw SQL"
        allowed_in: ["app/infra/transaction.py"]
        ci_check: "scripts/ci/check_forbidden_patterns.py"
        severity: BLOCKING

    type_safety_rule: |
      If a function requires lock continuity, it MUST accept SingleConnectionTxn.
      This makes the requirement VISIBLE in the function signature and ENFORCEABLE.

      Example:
        def trip_circuit(txn: SingleConnectionTxn, state_id: str):
            state = txn.lock_row(CostSimCBState, CostSimCBState.id == state_id)
            state.disabled = True
            txn.commit()

    ci_enforcement:
      scripts:
        - name: "Forbidden Patterns Check"
          script: "scripts/ci/check_forbidden_patterns.py"
          purpose: "Blocks raw FOR UPDATE usage outside blessed primitives"

        - name: "Intent Consistency Check"
          script: "scripts/ci/check_intent_consistency.py"
          purpose: "Validates @transactional decorator usage and intent/primitive alignment"

      exit_codes:
        0: "No violations"
        1: "Violations found (BLOCKING)"
        2: "Script error"

      integration: |
        Add to CI pipeline:
          - name: Check Forbidden Patterns
            run: python scripts/ci/check_forbidden_patterns.py app

          - name: Check Intent Consistency
            run: python scripts/ci/check_intent_consistency.py app

          - name: Check Feature Intent
            run: python scripts/ci/check_feature_intent.py app

    self_defense_checklist:
      - question: "Does this require transactional continuity?"
        enforced_by: "Function signature (SingleConnectionTxn type)"
      - question: "Does this require locking?"
        enforced_by: "Must use txn.lock_row(), no raw FOR UPDATE"
      - question: "Does this span multiple steps?"
        enforced_by: "Transaction context scope"
      - question: "Can this block?"
        enforced_by: "Lock timeout (default 30s)"

    incident_to_invariant_loop:
      incident: "Cross-connection row locks causing deadlock"
      invariant: "Lock scope == Connection scope (ALWAYS)"
      primitive: "single_connection_transaction()"
      result: "Mistake is now structurally impossible"

    architecture_not_documentation: |
      This is the key difference between "memory-assisted" and "self-defending":
      - Documentation tells engineers what to remember
      - Architecture makes wrong behavior impossible

      Phase-2.2 adds a new distinction between "blocked" and "guided":
      - Blocked: System prevents mistakes AFTER they happen (CI failures)
      - Guided: System guides engineers BEFORE code is written (intent declaration)

      The @transactional(intent=...) decorator is the key innovation:
      - Engineers MUST declare intent before writing implementation
      - Intent is machine-checkable at decoration time (fail fast)
      - CI validates intent/primitive alignment
      - Wrong designs fail at compile time, not runtime

      If you need to use FOR UPDATE and the primitives don't support your use case,
      EXTEND THE PRIMITIVES — don't bypass them.

    evolution_rule: |
      Every incident class must result in either:
      - A new primitive
      - A stricter intent
      - A new CI invariant

      If not, the system has NOT learned.

  # ---------------------------------------------------------------------------
  # Reference Documents
  # ---------------------------------------------------------------------------
  reference:
    - docs/memory-pins/PIN-262-signal-circuit-discovery-governance-clarification.md
    - docs/ci/scd/INDEX.md
    - docs/ci/CI_SIGNAL_REGISTRY.md
    - docs/contracts/PRODUCT_DEVELOPMENT_CONTRACT_V3.md

# =============================================================================
# Section 33: INFRA TRUTH RULE (PIN-266)
# =============================================================================
#
# Purpose: CI behavior must be derived from INFRA_REGISTRY.md.
#          No test may assume infra presence implicitly.
#
# Created: 2026-01-01
# Reference: PIN-266 (Infra Registry Canonicalization)
# =============================================================================

infra_truth_rule:
  status: ENFORCED
  effective: "2026-01-01"
  reference: "PIN-266"

  # ---------------------------------------------------------------------------
  # The Rule
  # ---------------------------------------------------------------------------
  core_principle: |
    CI behavior must be derived from INFRA_REGISTRY.md.
    No test may assume infra presence implicitly.

  invariant: |
    If an infrastructure item is not listed in INFRA_REGISTRY.md,
    it MUST NOT be assumed to exist.

  # ---------------------------------------------------------------------------
  # Infra State Taxonomy (Locked)
  # ---------------------------------------------------------------------------
  infra_states:
    A:
      name: "Absent (Conceptual)"
      meaning: "Selected for production, not wired locally"
      ci_behavior: "SKIP with explicit reason"
      stub_required: false
    B:
      name: "Stubbed (Local Substitute)"
      meaning: "Deterministic fake available for CI"
      ci_behavior: "RUN with stub"
      stub_required: true
    C:
      name: "Real (Fully Wired)"
      meaning: "Production-grade, required for correctness"
      ci_behavior: "FAIL if missing"
      stub_required: false

  # ---------------------------------------------------------------------------
  # CI Auto-Alignment Rules
  # ---------------------------------------------------------------------------
  ci_alignment:
    decorator: "@requires_infra(name, state=None)"
    location: "tests/helpers/infra.py"

    behavior_matrix:
      - state: A
        infra_missing: SKIP
        reason_required: true
        bucket_required: true  # B1 or B2
      - state: B
        infra_missing: SKIP
        stub_available: RUN
        reason_required: true
      - state: C
        infra_missing: FAIL
        reason_required: false  # Blocking failure

    no_silent_skips: |
      Every skipped test must have:
        1. @requires_infra marker OR explicit pytest.mark.skip
        2. Documented reason referencing infra name
        3. Bucket classification (B1 = must fix, B2 = intentional)

  # ---------------------------------------------------------------------------
  # Ground Truth Authority
  # ---------------------------------------------------------------------------
  authority:
    canonical_source: "docs/infra/INFRA_REGISTRY.md"
    enforcement: "tests/helpers/infra.py"

    derivation_order:
      1: "INFRA_REGISTRY.md (ground truth)"
      2: "CI_NORTH_STAR.md (invariants)"
      3: "tests/helpers/infra.py (mechanical enforcement)"
      4: "SESSION_PLAYBOOK.yaml (Claude governance)"
      5: "CI_REDISCOVERY_MASTER_ROADMAP.md (progress tracking)"

    anti_drift_rule: |
      No artifact may define infra state independently of INFRA_REGISTRY.md.
      If a test skips for infra → it must use @requires_infra.
      If Claude reasons about infra → it must check INFRA_REGISTRY.md first.

  # ---------------------------------------------------------------------------
  # Claude Behavior
  # ---------------------------------------------------------------------------
  claude_behavior:
    before_reasoning_about_infra:
      - "Check INFRA_REGISTRY.md for infra state"
      - "Do NOT assume infra exists without registry entry"
      - "Do NOT propose infra changes without human approval"

    when_test_fails_for_infra:
      - "Classify: Bucket A (test wrong), B (infra missing), C (real bug)"
      - "If Bucket B: Check INFRA_REGISTRY.md for state"
      - "If State A: Recommend @requires_infra marker"
      - "If State B: Check if stub is available"
      - "If State C: This is a blocking CI failure"

  # ---------------------------------------------------------------------------
  # Validation
  # ---------------------------------------------------------------------------
  self_check:
    - question: "Is the infra listed in INFRA_REGISTRY.md?"
      if_no: "STOP - cannot assume infra exists"
    - question: "What is the infra state (A/B/C)?"
      if_unknown: "CHECK INFRA_REGISTRY.md"
    - question: "Is a stub available for State B infra?"
      if_no: "Test must skip with @requires_infra"
    - question: "Is this a State C infra that's missing?"
      if_yes: "CI FAILURE - not a skip"

  # ---------------------------------------------------------------------------
  # INFRA_REALITY_INVARIANT (PIN-276)
  # ---------------------------------------------------------------------------
  # Added: 2026-01-02
  # Rule: If code assumes it, schema must enforce it.
  # This prevents future debt from "placeholder" skips.
  #
  infra_reality_invariant:
    status: LOCKED
    effective: "2026-01-02"
    reference: "PIN-276"

    principle: |
      If code assumes a schema, table, or constraint exists,
      that structure MUST be enforced by a canonical migration.
      No test hacks. No stubs. No future debt.

    enforcement:
      - rule: "SCHEMA_EXISTS"
        description: "Schema must exist before code imports it"
        migration_required: true
        skip_forbidden: true

      - rule: "CONSTRAINT_MATCHES_ASSUMPTION"
        description: "Unique/FK constraints in code must exist in DB"
        migration_required: true
        mismatch_is_bug: true

      - rule: "FUNCTION_SIGNATURE_STABLE"
        description: "PL/pgSQL function signatures must match call sites"
        migration_required: true
        signature_mismatch_is_blocker: true

    m10_specific:
      schema: "m10_recovery"
      migration: "002_m10_recovery_outbox.py"
      status: "State B - Local Compatible"
      invariant_tests:
        - "tests/invariants/test_m10_invariants.py"
      isolation_fixtures:
        - "clean_m10_tables"
        - "clean_recovery_candidates"

    violation_response: |
      If code assumes schema that doesn't exist:
      1. DO NOT add skip markers
      2. DO NOT stub the schema
      3. DO create a canonical migration
      4. DO run tests to verify

# =============================================================================
# SECTION 25: ENGINEERING AUTHORITY (PIN-270)
# =============================================================================
# Claude operates as Architecture Governor with explicit authority hierarchy.
# The system must never lie. Green CI that diverges from production is a defect.
#
# Reference: PIN-270 (Engineering Authority Codification)
# Reference: docs/governance/CLAUDE_ENGINEERING_AUTHORITY.md

engineering_authority:

  status: ENFORCED
  version: v1
  effective_date: 2026-01-02

  # ---------------------------------------------------------------------------
  # Prime Directive
  # ---------------------------------------------------------------------------
  prime_directive: |
    The system must never lie.
    Green CI that diverges from production behavior is a defect, not progress.
    Claude's job is not to make things pass.
    Claude's job is to make the architecture correct.

  # ---------------------------------------------------------------------------
  # Authority Hierarchy (Immutable)
  # ---------------------------------------------------------------------------
  authority_hierarchy:
    - priority: 1
      authority: "Layer Model (L1-L8)"
      status: immutable

    - priority: 2
      authority: "Domain boundaries - L4 owns meaning"
      status: immutable

    - priority: 3
      authority: "Infrastructure conformance truth"
      status: enforced

    - priority: 4
      authority: "Session Playbook"
      status: enforced

    - priority: 5
      authority: "Memory PINs"
      status: enforced

    - priority: 6
      authority: "Tests"
      status: derived

    - priority: 7
      authority: "CI tooling"
      status: derived

  # ---------------------------------------------------------------------------
  # Self-Check (Run Before Every Response)
  # ---------------------------------------------------------------------------
  self_check:
    - check: "Am I fixing the architecture or just making tests pass?"
      if_fail: "STOP, identify real issue"

    - check: "Does this contradict Layer Model (L1-L8)?"
      if_fail: "STOP, fix the proposal"

    - check: "Am I assuming infra exists without checking INFRA_REGISTRY?"
      if_fail: "CHECK registry first"

    - check: "Am I weakening an assertion to avoid a failure?"
      if_fail: "STOP, classify the failure (A/B/C/D)"

    - check: "Is this a shortcut that future-me will regret?"
      if_fail: "STOP, design the invariant"

    - check: "Would a new engineer understand this without asking?"
      if_fail: "ADD guidance (template, decorator, contract)"

    - check: "Am I guessing instead of asking one precise question?"
      if_fail: "ASK instead"

  # ---------------------------------------------------------------------------
  # Reference Files
  # ---------------------------------------------------------------------------
  reference_files:
    pin: docs/memory-pins/PIN-270-engineering-authority-codification.md
    full_document: docs/governance/CLAUDE_ENGINEERING_AUTHORITY.md
    claude_md: CLAUDE.md

# =============================================================================
# SECTION 25.1: DECISION GUARDRAILS (PIN-276 REDO)
# =============================================================================
# Prevention system for contract drift, function overloading, and parallel truth.
#
# Core Principle: One contract, one signature, one truth.
#
# This section exists because Claude introduced:
# - Function overloads to satisfy both tests AND production
# - Parallel retry fields (process_after AND next_retry_at)
# - Tests dictating production semantics (inverted authority)
#
# These are STRUCTURAL FAILURES that bypass test suites.
#
# Reference: PIN-276 (Contract Authority Enforcement)

decision_guardrails:

  status: ENFORCED
  version: v1
  effective_date: 2026-01-02
  reference: PIN-276

  # ---------------------------------------------------------------------------
  # Layer 1: Fix Classification (REQUIRED before any code change)
  # ---------------------------------------------------------------------------
  fix_classification_required:
    principle: |
      Before writing ANY code change, classify the fix type.
      Different fix types have different correct resolutions.

    fix_classes:
      - class: A
        name: "Schema/Migration Gap"
        symptom: "Test assumes structure that doesn't exist"
        correct_resolution: "Add migration, NOT test workaround"

      - class: B
        name: "Contract Mismatch"
        symptom: "Caller uses wrong signature"
        correct_resolution: "Fix ALL callers to match contract, NOT add overload"

      - class: C
        name: "Semantic Drift"
        symptom: "Same operation has multiple meanings"
        correct_resolution: "Pick ONE meaning, update all usages"

      - class: D
        name: "Test Bug"
        symptom: "Test expectation is wrong"
        correct_resolution: "Fix test, NOT production code"

  # ---------------------------------------------------------------------------
  # Fix Class Priority (IMMUTABLE)
  # ---------------------------------------------------------------------------
  fix_class_priority:
    rule: |
      When multiple fix classes seem applicable,
      apply the LOWEST letter (highest authority).

    order:
      - A: "Schema fixes outrank everything"
      - B: "Contract fixes outrank semantic/test fixes"
      - C: "Semantic fixes outrank test fixes"
      - D: "Test fixes are last resort"

    never_acceptable:
      - "Adding function overloads to satisfy multiple callers"
      - "Creating parallel fields for same semantic concept"
      - "Changing production to match test expectations"
      - "Using 'both' when 'one' is required"

  # ---------------------------------------------------------------------------
  # Layer 2: Suspicious Patterns (SYSTEM MUST FLAG)
  # ---------------------------------------------------------------------------
  suspicious_patterns:

    - pattern: "CREATE.*OVERLOAD|CREATE.*FUNCTION.*same_name"
      signal: "Function overloading detected"
      required_action: "STOP - ask which signature is canonical"

    - pattern: "UPDATE.*SET.*field_a.*field_b.*WHERE"
      signal: "Multiple fields updated for same semantic"
      required_action: "STOP - ask which field is the authority"

    - pattern: "test.*expects|test.*calls.*different"
      signal: "Test signature differs from production"
      required_action: "STOP - production wins, fix test"

    - pattern: "for.*tests|overload.*for.*tests"
      signal: "Creating code specifically for tests"
      required_action: "STOP - tests conform to production, not reverse"

  # ---------------------------------------------------------------------------
  # Layer 3: Hard Stop Conditions (BLOCKING)
  # ---------------------------------------------------------------------------
  hard_stop_conditions:

    - condition: "About to create second signature for existing function"
      action: "HARD STOP"
      resolution: "Pick ONE signature. Fix ALL callers."

    - condition: "About to add field that duplicates existing field's semantic"
      action: "HARD STOP"
      resolution: "Use existing field. Remove duplicate."

    - condition: "About to change production code to match test expectation"
      action: "HARD STOP"
      resolution: "Verify contract first. Test may be wrong."

    - condition: "About to use 'and' where 'or' is architecturally correct"
      action: "HARD STOP"
      resolution: "Pick one. Document why."

  # ---------------------------------------------------------------------------
  # Self-Audit Extension (Add to existing SELF-AUDIT)
  # ---------------------------------------------------------------------------
  self_audit_extension:
    - question: "Did I create ANY function overload?"
      if_yes: "STOP - pick one canonical signature"

    - question: "Did I update MULTIPLE fields for the same semantic?"
      if_yes: "STOP - pick one authority field"

    - question: "Did I change production code to satisfy a test?"
      if_yes: "STOP - verify which is wrong"

    - question: "Did I use 'both' when the architecture requires 'one'?"
      if_yes: "STOP - pick one, remove other"

  # ---------------------------------------------------------------------------
  # Reference
  # ---------------------------------------------------------------------------
  reference_files:
    pin: docs/memory-pins/PIN-276-bucket-ab-permanent-fix.md
    incident: "M10 function overload incident (2026-01-02)"

# =============================================================================
# SECTION 26: RBAC GUARDRAIL (PIN-391)
# =============================================================================
# Authorization is declared, not inferred.
# Claude must not guess access control rules.
#
# Reference: PIN-391 (RBAC Unification), design/auth/RBAC_RULES.yaml

rbac_guardrail:

  status: ENFORCED
  version: v1
  effective_date: 2026-01-11
  reference: PIN-391

  # ---------------------------------------------------------------------------
  # Core Invariant (LOCKED)
  # ---------------------------------------------------------------------------
  invariant: |
    Authorization is declared, not inferred.
    Code may mirror rules temporarily, but must not invent them.

  # ---------------------------------------------------------------------------
  # Canonical Source of Truth
  # ---------------------------------------------------------------------------
  canonical_source:
    file: design/auth/RBAC_RULES.yaml
    description: |
      All RBAC rules MUST be declared in RBAC_RULES.yaml.
      This file is the single source of truth for authorization.

  # ---------------------------------------------------------------------------
  # Hard Rules (No Exceptions)
  # ---------------------------------------------------------------------------
  hard_rules:

    - rule_id: RBAC-001
      name: "No Inference"
      description: |
        Claude MUST NOT classify endpoints as public/private by inference.
        If no rule exists, report "RBAC rule missing" — not guess.

    - rule_id: RBAC-002
      name: "No PUBLIC_PATHS Modification"
      description: |
        Claude MUST NOT modify PUBLIC_PATHS in rbac_middleware.py
        unless explicitly instructed AND the change is first declared
        in RBAC_RULES.yaml.

    - rule_id: RBAC-003
      name: "Schema First"
      description: |
        All access decisions MUST reference RBAC_RULES.yaml.
        Code may mirror the schema temporarily, but schema is authority.

    - rule_id: RBAC-004
      name: "Report Missing Rules"
      description: |
        If an endpoint has no RBAC rule, Claude MUST report:
        "RBAC RULE MISSING: {method} {path}"
        Do not proceed with implementation.

  # ---------------------------------------------------------------------------
  # Decision Ladder (When Touching Auth)
  # ---------------------------------------------------------------------------
  decision_ladder:
    - step: 1
      question: "Is this endpoint already in RBAC_RULES.yaml?"
      if_yes: "Modify rule in RBAC_RULES.yaml"
      if_no: "STOP and propose a new rule for approval"

    - step: 2
      question: "Is this preflight-only?"
      if_yes: "Use SYSTEM tier with preflight-only environment"
      default: "Never PUBLIC by default"

    - step: 3
      question: "Is PUBLIC_PATHS involved?"
      if_yes: "Only as a temporary mirror of RBAC_RULES.yaml"
      requirement: "Must reference a PIN"

  # ---------------------------------------------------------------------------
  # Self-Check (Run Before Auth-Related Code)
  # ---------------------------------------------------------------------------
  self_check:
    - question: "Did I check RBAC_RULES.yaml before modifying auth?"
      if_no: "STOP - check schema first"

    - question: "Did I add to PUBLIC_PATHS without updating RBAC_RULES.yaml?"
      if_yes: "STOP - update schema first"

    - question: "Did I infer access level from endpoint name or behavior?"
      if_yes: "STOP - inference is forbidden"

    - question: "Did I create a new endpoint without an RBAC rule?"
      if_yes: "STOP - propose rule for approval"

  # ---------------------------------------------------------------------------
  # Hard Failure Response
  # ---------------------------------------------------------------------------
  hard_failure_response: |
    RBAC GUARDRAIL VIOLATION

    Claude attempted to: {action}
    Rule violated: {rule_id}

    STATUS: BLOCKED

    Required action:
    1. Check design/auth/RBAC_RULES.yaml for existing rules
    2. If no rule exists, propose a new rule for approval
    3. Only after rule is approved, update rbac_middleware.py

    Reference: PIN-391, design/auth/RBAC_RULES.yaml

  # ---------------------------------------------------------------------------
  # Claude Constraints (Machine-Enforced)
  # ---------------------------------------------------------------------------
  # These constraints are checked by CI and must be enforced in Claude output.
  #
  claude_constraints:

    schema_read_first:
      enforcement: BLOCKING
      description: |
        Before ANY RBAC modification, Claude MUST read:
        1. design/auth/RBAC_READ_BEFORE_EDITING.md (stop file)
        2. design/auth/RBAC_RULES.yaml (_meta section)

    stop_file_required:
      file: design/auth/RBAC_READ_BEFORE_EDITING.md
      enforcement: BLOCKING
      description: |
        This file MUST be read before any RBAC change.
        Claude must confirm reading it in the response.

    exception_on_missing:
      module: backend/app/auth/rbac_rules_loader.py
      class: RBACSchemaViolation
      enforcement: BLOCKING
      description: |
        When strict=True, resolve_rbac_rule raises RBACSchemaViolation
        for missing rules. Callers MUST NOT catch and ignore.

    ci_guard_required:
      script: scripts/ci/check_rbac_alignment.py
      enforcement: BLOCKING
      on_failure: |
        RBAC alignment violation detected.
        Run: python3 scripts/ci/check_rbac_alignment.py --verbose

    legacy_block_warning:
      file: backend/app/auth/rbac_middleware.py
      pattern: "LEGACY CODE BLOCK"
      enforcement: WARNING
      description: |
        PUBLIC_PATHS is a legacy list scheduled for deprecation.
        All modifications must update RBAC_RULES.yaml first.

  # ---------------------------------------------------------------------------
  # Acknowledgment Template (For Claude Responses)
  # ---------------------------------------------------------------------------
  acknowledgment_template: |
    RBAC GUARDRAIL ACKNOWLEDGMENT
    - stop_file_read: YES
    - schema_checked: YES
    - rule_exists: YES / NO (if NO, proposing new rule)
    - ci_guard_will_run: YES

# =============================================================================
# SECTION 27: PRE-COMMIT LOCALITY RULES (PIN-269)
# =============================================================================
# Pre-commit hooks must only evaluate what the commit is responsible for.
# Surfacing unrelated violations trains developers to skip hooks.
#
# Reference: PIN-269 (Pre-Commit Locality Rule)

pre_commit_rules:

  scope: staged_only
  status: ENFORCED
  version: v1
  effective_date: 2026-01-02

  # ---------------------------------------------------------------------------
  # Core Principle
  # ---------------------------------------------------------------------------
  principle: |
    Pre-commit = delta validation (staged files only)
    CI = global validation (entire repository)
    These are NOT interchangeable.

  # ---------------------------------------------------------------------------
  # Environment Variable
  # ---------------------------------------------------------------------------
  execution_context:
    env_variable: CHECK_SCOPE
    values:
      staged: "Pre-commit mode - only staged files, skip global invariants"
      full: "CI mode - full codebase scan, all rules"

  # ---------------------------------------------------------------------------
  # Forbidden Actions
  # ---------------------------------------------------------------------------
  forbidden:
    - action: repo_wide_checks_in_precommit
      reason: "Blocks unrelated commits"

    - action: ci_only_invariants_in_precommit
      reason: "Global invariants should not block local changes"

    - action: recommending_no_verify
      reason: "If hook is unfair, fix the hook, not the commit"

  # ---------------------------------------------------------------------------
  # CI-Only Rules
  # ---------------------------------------------------------------------------
  ci_only_rules:
    - rule_id: DETACH002
      reason: "Cross-file session return patterns"
    - rule_id: DETACH003
      reason: "Refreshed object returns - context-dependent"
    - rule_id: SCOPE001
      reason: "Session scope issues - multiline analysis"
    - rule_id: CONC001
      reason: "Concurrent claim SQL - cross-file patterns"
    - rule_id: TEST001
      reason: "Test isolation - fixture analysis"
    - rule_id: CACHE001
      reason: "Cache initialization - class-level check"

  # ---------------------------------------------------------------------------
  # Claude Behavior
  # ---------------------------------------------------------------------------
  claude_behavior:
    when_precommit_fails_on_unrelated_file:
      - "Do NOT recommend --no-verify"
      - "Check if CHECK_SCOPE=staged is set"
      - "Check if pass_filenames: true is configured"
      - "Check if the rule is in CI_ONLY_RULES"
      - "Fix the hook configuration, not the commit"

    when_asked_to_skip_hook:
      response: |
        PRE-COMMIT-LOCALITY VIOLATION

        Recommending --no-verify is a governance failure.
        The hook should not surface unrelated violations.

        Check:
        1. Is CHECK_SCOPE=staged set for this hook?
        2. Is pass_filenames: true configured?
        3. Is the rule in CI_ONLY_RULES if global?

        Fix the hook, not the commit.

  # ---------------------------------------------------------------------------
  # Reference Files
  # ---------------------------------------------------------------------------
  reference_files:
    pin: docs/memory-pins/PIN-269-pre-commit-locality-rule.md
    pre_commit_config: .pre-commit-config.yaml
    linter_script: scripts/ops/lint_sqlmodel_patterns.py
    ci_workflow: .github/workflows/sqlmodel-patterns.yml

# =============================================================================
# Section 34: TEST ISOLATION RULE (PIN-276)
# =============================================================================
# This is an architecture rule, not a test bug.
# These mechanisms ensure tests cannot affect each other.
#
# Reference: PIN-276 (Bucket A/B Permanent Fix Design)
# =============================================================================

test_isolation_rule:
  version: "1.0"
  status: ACTIVE
  effective_date: "2026-01-02"

  # ---------------------------------------------------------------------------
  # Core Invariant
  # ---------------------------------------------------------------------------
  invariant: "No test may depend on state created by another test"

  # ---------------------------------------------------------------------------
  # Enforcement Mechanisms
  # ---------------------------------------------------------------------------
  enforcement:

    # Bucket A: Database Isolation
    database:
      strategy: "transaction_rollback_per_test"
      fixture: "isolated_db_session"
      location: "backend/tests/conftest.py"
      rule: |
        - Every test runs inside a DB transaction
        - Transaction is rolled back after the test
        - No test commits durable state
        - Use flush() not commit() in tests

    # Bucket B: Prometheus Isolation
    prometheus:
      strategy: "per_test_registry"
      fixture: "prometheus_registry"
      state: "B"
      location: "backend/tests/conftest.py"
      rule: |
        - Real Prometheus client (not mocks)
        - In-process CollectorRegistry per test
        - No external server required
        - Metrics available synchronously

    # Verification
    verification:
      command: "pytest --random-order"
      ci_check: true
      rule: |
        - Running pytest --random-order never changes results
        - Running pytest -n auto never changes results
        - Any test can be run in isolation OR suite with same result

  # ---------------------------------------------------------------------------
  # Fixtures Reference
  # ---------------------------------------------------------------------------
  fixtures:
    isolated_db_session:
      scope: function
      purpose: "Database session with automatic rollback"
      invariant: "Any DB changes are automatically rolled back"
      usage: |
        def test_something(isolated_db_session):
            isolated_db_session.add(MyModel(name="test"))
            isolated_db_session.flush()  # NOT commit()
            # After test: automatic rollback

    isolated_async_session:
      scope: function
      purpose: "Async database session with automatic rollback"
      invariant: "Any DB changes are automatically rolled back"
      usage: |
        async def test_something(isolated_async_session):
            async with isolated_async_session() as session:
                session.add(MyModel(name="test"))
                await session.flush()
            # After test: automatic rollback

    prometheus_registry:
      scope: function
      purpose: "Per-test isolated Prometheus registry"
      invariant: "Metrics from other tests never appear"
      usage: |
        def test_metrics(prometheus_registry):
            counter = Counter('test_counter', 'Test', registry=prometheus_registry)
            counter.inc()
            assert prometheus_registry.get_sample_value('test_counter_total') == 1.0

    metrics_factory:
      scope: function
      purpose: "Factory for creating isolated metrics"
      invariant: "All metrics created are test-isolated"
      usage: |
        def test_something(metrics_factory):
            counter = metrics_factory.counter('requests_total', 'Request count')
            counter.inc()
            value = metrics_factory.get_value('requests_total')

  # ---------------------------------------------------------------------------
  # Violation Classification
  # ---------------------------------------------------------------------------
  violations:
    test_order_dependence:
      classification: "Architecture bug"
      not_classification: "Flaky test"
      resolution: "Fix state leak, not test"

    metrics_collision:
      classification: "Missing isolation"
      not_classification: "Duplicated timeseries error"
      resolution: "Use prometheus_registry fixture"

    database_state_bleed:
      classification: "Missing rollback"
      not_classification: "Dirty database"
      resolution: "Use isolated_db_session fixture"

  # ---------------------------------------------------------------------------
  # Hard Stop Rules
  # ---------------------------------------------------------------------------
  hard_stop_rules:
    - condition: "Test fails due to isolation"
      classification: "BUG"
      action: "Fix state leak"

    - condition: "Test fails due to missing infra"
      classification: "Infra not done"
      action: "Promote infra to State B"

    - condition: "Test is skipped"
      classification: "Governance violation"
      action: "Justify or remove skip"

  # ---------------------------------------------------------------------------
  # Reference
  # ---------------------------------------------------------------------------
  reference:
    pin: PIN-276
    design_doc: docs/memory-pins/PIN-276-bucket-ab-permanent-fix-design.md
    verification_tests: backend/tests/unit/test_isolation_mechanism.py
    conftest: backend/tests/conftest.py

# =============================================================================
# GOVERNANCE QUALIFIERS (MANDATORY)
# =============================================================================
#
# Status: ENFORCED
# Effective: 2026-01-03
# Reference: docs/governance/GOVERNANCE_QUALIFIERS.yaml
#           docs/governance/QUALIFIER_EVALUATION.yaml
#           PIN-281 (L7→L2 Structural Closure)
#
# A Governance Qualifier is a MACHINE-EVALUABLE VERDICT that answers:
#   "Is this capability allowed to be treated as a product-level truth surface?"
#
# It is NOT a status label, registry note, or human approval.
# It is a DERIVED QUALIFICATION, computed from structural evidence.
#
# =============================================================================

governance_qualifiers:

  # ---------------------------------------------------------------------------
  # Primary Qualifier: GQ-L2-CONTRACT-READY
  # ---------------------------------------------------------------------------
  primary_qualifier: GQ-L2-CONTRACT-READY

  qualifier_states:
    QUALIFIED:
      description: "All requirements met. L2 testing and claims permitted."
      permits:
        - l2_testing
        - frontend_wiring
        - product_claims
        - status_complete

    CONDITIONALLY_QUALIFIED:
      description: "Core structure exists but not all validators pass."
      permits:
        - structural_work
        - integration_testing
      forbids:
        - l2_testing
        - product_claims
        - status_complete

    DISQUALIFIED:
      description: "Fundamental structural requirements not met."
      permits:
        - structural_repair
        - investigation
        - planning
      forbids:
        - l2_testing
        - frontend_wiring
        - product_claims
        - status_complete
        - integration_testing

  # ---------------------------------------------------------------------------
  # Claude Behavioral Constraints
  # ---------------------------------------------------------------------------
  claude_constraints:

    pre_claim_check:
      rule: |
        Claude MUST evaluate GQ-L2-CONTRACT-READY before making any claim
        about readiness, testing, or exposure.
      enforcement: BLOCKING

    if_not_qualified:
      actions:
        - refuse_testing
        - refuse_promotion_language
        - recommend_structural_repair_only

    forbidden_language_if_not_qualified:
      - "ready"
      - "complete"
      - "promoted"
      - "can be tested"
      - "production ready"
      - "all done"
      - "finished"
      - "go ahead and test"

    forbidden_actions_if_not_qualified:
      - l2_testing
      - frontend_claims
      - product_signoff
      - status_promotion

  # ---------------------------------------------------------------------------
  # Evaluation Command
  # ---------------------------------------------------------------------------
  evaluation:
    command: "python scripts/ops/evaluate_qualifiers.py"
    options:
      - "--generate: Generate QUALIFIER_EVALUATION.yaml"
      - "--check <CAP>: Check specific capability"
      - "--qualified-only: List only QUALIFIED capabilities"
      - "--ci: CI mode (exit 1 if any not QUALIFIED)"

  # ---------------------------------------------------------------------------
  # Bootstrap Integration
  # ---------------------------------------------------------------------------
  bootstrap_integration:
    when: SESSION_START
    action: |
      Before any L2-related work, run:
        python scripts/ops/evaluate_qualifiers.py --check <capability>

      If state != QUALIFIED:
        - DO NOT proceed with L2 testing
        - DO NOT use promotion language
        - ONLY recommend structural repair steps

  # ---------------------------------------------------------------------------
  # Claude Self-Check (Required)
  # ---------------------------------------------------------------------------
  claude_qualifier_self_check:
    trigger: "Before any claim about capability readiness"
    questions:
      - "Have I evaluated GQ-L2-CONTRACT-READY for this capability?"
      - "Is the qualifier state QUALIFIED?"
      - "If not QUALIFIED, am I avoiding forbidden language/actions?"
    on_failure: "Response is INVALID. Evaluate qualifier first."

  # ---------------------------------------------------------------------------
  # Preflight Integration
  # ---------------------------------------------------------------------------
  preflight_integration:
    file: scripts/ops/preflight.py
    check: "from scripts.ops.evaluate_qualifiers import check_all_qualified"
    fail_condition: "any capability referenced in L2 tests is not QUALIFIED"

  # ---------------------------------------------------------------------------
  # CI Integration
  # ---------------------------------------------------------------------------
  ci_integration:
    workflow: ".github/workflows/governance-qualifier.yml"
    job: "qualifier-check"
    blocking: true
    fail_conditions:
      - "capability referenced in L2 tests is not QUALIFIED"
      - "registry claims PROMOTED but qualifier != QUALIFIED"

  # ---------------------------------------------------------------------------
  # No Override Rule
  # ---------------------------------------------------------------------------
  no_override:
    rule: |
      No human or AI override is permitted for governance qualifiers.
      The evaluation is mechanical and non-negotiable.
      There is no "almost qualified" state.
      There is no "close enough" exception.
      There is no "temporary bypass".
    enforcement: ABSOLUTE

# =============================================================================
# SECTION 35: CAPABILITY REGISTRY GOVERNANCE (PIN-313)
# =============================================================================
# Added: 2026-01-05
# Reference: PIN-313 (Governance Hardening & Gap Closure)
# Purpose: Prevent regression, enforce capability truth at runtime

capability_registry_governance:

  # ---------------------------------------------------------------------------
  # Unregistered Code Response Matrix
  # ---------------------------------------------------------------------------
  unregistered_code_response:
    description: |
      When Claude detects unregistered code via scan-unregistered,
      it MUST follow this matrix exactly. No bypass allowed.

    response_matrix:
      owns_domain_logic:
        action: REGISTER as new capability
        example: "New engine directory with business rules"
        required: capability_id, planes, lifecycle, evidence

      routing_or_glue:
        action: Mark NON_OWNING or QUARANTINED
        example: "Adapter file, dispatcher, thin wrapper"
        required: Add to platform_infrastructure or legacy_routes section

      deprecated_code:
        action: Mark LEGACY + schedule deletion
        example: "Old API version, superseded endpoint"
        required: Add DEPRECATED comment, create removal ticket

      intent_unclear:
        action: STOP and ask founder
        example: "Code with no clear ownership or purpose"
        required: Do NOT proceed without human clarification

    enforcement: BLOCKING
    no_bypass: true

  # ---------------------------------------------------------------------------
  # Promotion Gate Rules
  # ---------------------------------------------------------------------------
  promotion_gate:
    description: |
      Before ANY lifecycle promotion (to CLOSED or FROZEN),
      these conditions MUST be met. Failure = STOP.

    required_conditions:
      - capability_surveyor_passes: true
      - no_plane_asymmetry: true
      - no_missing_authority: true
      - no_stubbed_infra: true
      - all_evidence_paths_exist: true
      - all_closure_requirements_met: true

    on_any_fail: STOP promotion immediately
    enforcement: BLOCKING

    commands:
      validate: python3 scripts/ops/capability_registry_enforcer.py validate-registry
      check_gaps: python3 scripts/ops/capability_registry_enforcer.py heatmap
      scan: python3 scripts/ops/capability_registry_enforcer.py scan-unregistered

  # ---------------------------------------------------------------------------
  # Session Start Registry Gate
  # ---------------------------------------------------------------------------
  session_registry_gate:
    description: |
      At session start, Claude MUST execute registry validation.
      If gaps exist, Claude must acknowledge them before feature work.

    commands:
      - python3 scripts/ops/capability_registry_enforcer.py validate-registry
      - python3 scripts/ops/capability_registry_enforcer.py heatmap

    on_gaps_exist:
      action: ACKNOWLEDGE gaps in bootstrap confirmation
      blocked_activities:
        - Feature work on capabilities with gaps
        - UI expansion for blocked capabilities
        - Lifecycle promotion

    on_validation_fail:
      action: BLOCK session start
      response: |
        CAPABILITY REGISTRY VALIDATION FAILED
        Cannot proceed until registry is valid.
        Run: python3 scripts/ops/capability_registry_enforcer.py validate-registry

  # ---------------------------------------------------------------------------
  # Advisory vs Control vs Audit Separation
  # ---------------------------------------------------------------------------
  semantic_separation:
    description: |
      Claude MUST separate advisory, control, and audit semantics.
      No mixing allowed.

    advisory_plane:
      allowed: READ, QUERY, REPORT
      forbidden: MUTATE, ENFORCE, WRITE
      examples: predictions, cost_simulation results, policy proposals

    control_plane:
      allowed: ENFORCE, GATE, BLOCK
      forbidden: None (full authority)
      examples: RBAC, rate limits, policy enforcement

    audit_plane:
      allowed: RECORD, PERSIST, REPLAY
      forbidden: MUTATE historical records
      examples: traces, audit logs, simulation runs

    invariant: |
      An advisory capability MUST NOT gain mutation paths.
      If mutation is required, it becomes a control capability.

  # ---------------------------------------------------------------------------
  # Gap Type Semantics
  # ---------------------------------------------------------------------------
  gap_type_semantics:
    PLANE_ASYMMETRY:
      meaning: "Some planes present, others missing"
      resolution: "Add missing planes OR document as intentional"

    MISSING_AUTHORITY:
      meaning: "Exposed to users without governance gate"
      resolution: "Add RBAC/visibility rules"

    MISSING_AUDIT:
      meaning: "Mutations occur without audit trail"
      resolution: "Add audit capture before state changes"

    LIFECYCLE_INCOMPLETE:
      meaning: "Closure requirements not met"
      resolution: "Complete requirements OR stay in PARTIAL/READ_ONLY"

    STUBBED_INFRA:
      meaning: "Infrastructure code present but not wired"
      resolution: "Wire to runtime OR remove"

    INTENTIONALLY_ABSENT:
      meaning: "Explicitly not implemented (PLANNED state)"
      resolution: "No action required until implementation begins"

# =============================================================================
# SECTION 35: INTENT LOCK SYSTEM (PIN-319 Governance Fix)
# =============================================================================
#
# Purpose: Ensure clean push by construction through intent-scoped worktrees.
# Root cause fix: Detect mixed intent at session start, not at commit time.
#
# Problem solved:
#   Before: Mixed work accumulates silently, enforcement fires late (at push),
#           causing noisy failures and forcing --no-verify workarounds.
#   After: Intent declared at session start, worktree sanity checked continuously,
#          pushes are clean by construction.

intent_lock:
  # ---------------------------------------------------------------------------
  # Intent Declaration Requirement
  # ---------------------------------------------------------------------------
  intent_declaration:
    required: true
    schema_file: docs/governance/INTENT_DECLARATION_SCHEMA.yaml
    instance_file: INTENT_DECLARATION.yaml

    validation_rules:
      # V1: PIN must exist
      - id: V1
        rule: "Referenced PIN must exist in docs/memory-pins/"
        enforcement: BLOCKING

      # V2: Scope must be defined
      - id: V2
        rule: "allowed_paths must have at least one entry"
        enforcement: BLOCKING

      # V3: No wildcard-only scopes (except exploratory mode)
      - id: V3
        rule: "Cannot use '**' alone in exclusive mode"
        enforcement: BLOCKING

    on_missing_intent:
      action: WARN
      message: |
        No INTENT_DECLARATION.yaml found.
        Create one to enable worktree sanity enforcement.
        Template: docs/governance/INTENT_DECLARATION_SCHEMA.yaml

  # ---------------------------------------------------------------------------
  # Worktree Sanity Enforcement
  # ---------------------------------------------------------------------------
  worktree_sanity:
    enabled: true
    script: scripts/ops/worktree_sanity_check.py

    triggers:
      - session_bootstrap         # At session start
      - pre_commit                # Before git commit
      - pre_push                  # Before git push
      - periodic: 50              # Every N tool invocations

    behavior:
      exclusive_mode:
        on_violation: BLOCK
        message: |
          Files modified outside declared intent scope.
          Remediation:
          1. git stash the out-of-scope changes
          2. Update INTENT_DECLARATION.yaml to include these paths
          3. Create separate branch for this work

      exploratory_mode:
        on_violation: WARN
        message: |
          Exploratory mode: violation logged but not blocking.

      hotfix_mode:
        on_violation: LOG
        message: |
          Hotfix mode: violation logged only.

  # ---------------------------------------------------------------------------
  # Intent-Aware Commit Hook
  # ---------------------------------------------------------------------------
  commit_hook:
    enabled: true
    behavior:
      # Extract PIN from commit message
      extract_pin: true
      pin_pattern: "PIN-[0-9]+"

      # Validate staged files against intent
      validate_scope: true

      on_scope_violation:
        action: BLOCK
        message: |
          Staged files outside declared intent scope.
          PIN in message: {pin}
          Violations: {violations}
          Fix: Update INTENT_DECLARATION.yaml or use separate commit.

  # ---------------------------------------------------------------------------
  # --no-verify Policy (FORMALIZED)
  # ---------------------------------------------------------------------------
  no_verify_policy:
    description: |
      --no-verify is allowed but regulated.
      It is NOT banned, but usage must be justified.

    allowed_when:
      - hook_failure_reason == "scope_pollution"
      - intent_documented == true
      - pin_updated == true
      - formatting_only_violation == true  # ruff false positives

    forbidden_when:
      - test_failures_present == true
      - semantic_violation == true
      - security_guard_failure == true
      - missing_intent_declaration == true

    required_justification:
      format: |
        # --no-verify justification:
        # Reason: {reason}
        # Intent: PIN-{number}
        # Files bypassed: {files}

    audit:
      log_usage: true
      include_in_commit_message: false  # Not required but recommended

  # ---------------------------------------------------------------------------
  # Session Workflow Integration
  # ---------------------------------------------------------------------------
  session_workflow:
    on_session_start:
      - Load INTENT_DECLARATION.yaml
      - Validate against schema
      - Run worktree_sanity_check.py
      - Report scope violations before work begins

    on_tool_invocation:
      - Check if file operation is within scope
      - Warn if outside allowed_paths
      - Block if in forbidden_paths (exclusive mode)

    on_commit:
      - Run worktree_sanity_check.py --staged
      - Validate commit message PIN matches intent
      - Report violations with remediation

    on_push:
      - Run full worktree_sanity_check.py
      - Verify no scope pollution accumulated
      - Clean push guaranteed

  # ---------------------------------------------------------------------------
  # Intent Lock Rules (Summary)
  # ---------------------------------------------------------------------------
  rules:
    - id: INTENT-001
      name: Intent Declaration Required
      description: INTENT_DECLARATION.yaml should exist for worktree sanity
      enforcement: WARNING  # Not blocking, but encouraged
      script: worktree_sanity_check.py

    - id: INTENT-002
      name: Working Tree Must Match Scope
      description: All modified files must be within allowed_paths
      enforcement: BLOCKING (exclusive) / WARNING (exploratory)
      script: worktree_sanity_check.py

    - id: INTENT-003
      name: Forbidden Paths Absolute
      description: Files in forbidden_paths cannot be modified regardless of mode
      enforcement: BLOCKING
      script: worktree_sanity_check.py

    - id: INTENT-004
      name: --no-verify Requires Justification
      description: Cannot use --no-verify for test/semantic/security failures
      enforcement: BLOCKING (manual review)
      audit: Logged if used

# =============================================================================
# Section 36: SCOPE ADMISSION PROTOCOL (PIN-347)
# =============================================================================
#
# Purpose: Prevent scope violations by declaring intent BEFORE writing code.
# Root cause: Claude writes code to new paths, pre-commit blocks, --no-verify bypass.
# Fix: Claude must detect and declare new scope BEFORE generating any files.
#
# Core principle: Governance intent must be declared before code exists.

scope_admission_protocol:
  # ---------------------------------------------------------------------------
  # Rule: No Code Before Scope
  # ---------------------------------------------------------------------------
  rule: |
    Claude must never create files in a filesystem path that is not already
    declared in INTENT_DECLARATION.yaml.

  enforced_by:
    - Claude (pre-generation, behavioral)
    - pre-commit hooks (post-generation, mechanical)
    - CI (final gate)

  # ---------------------------------------------------------------------------
  # Claude Obligations
  # ---------------------------------------------------------------------------
  claude_obligations:
    - Detect new directory or top-level path introduction
    - Halt code generation immediately
    - Propose an INTENT_DECLARATION.yaml update
    - Await explicit confirmation before proceeding

  # ---------------------------------------------------------------------------
  # Prohibited Actions
  # ---------------------------------------------------------------------------
  prohibited_actions:
    - "Writing code before scope declaration"
    - "Using --no-verify to bypass scope checks"
    - "Retroactively justifying scope expansion"
    - "Creating scaffolding in undeclared paths"
    - "'We'll fix it later' scope deferrals"

  # ---------------------------------------------------------------------------
  # Allowed Flow (MANDATORY)
  # ---------------------------------------------------------------------------
  allowed_flow:
    step_1:
      name: Identify new scope
      action: Claude detects a path not in INTENT_DECLARATION.yaml
      output: "This introduces a new governed scope: <path>"

    step_2:
      name: Declare intent
      action: Claude proposes INTENT_DECLARATION.yaml update
      output: Diff showing new allowed_paths entry

    step_3:
      name: Commit intent alone
      action: Governance change committed separately
      output: Clean commit with only intent update

    step_4:
      name: Resume implementation
      action: Claude proceeds with file creation
      output: Pre-commit passes naturally

  # ---------------------------------------------------------------------------
  # Violation Response
  # ---------------------------------------------------------------------------
  violation_response:
    on_new_scope_detected:
      action: HALT
      message: |
        ❌ SCOPE ADMISSION REQUIRED

        The path '{path}' is not in INTENT_DECLARATION.yaml.
        I must update governance intent before creating files.

        Proposed change:
        ```yaml
        allowed_paths:
          - "{path}/**"
        ```

        Awaiting confirmation to proceed.

    on_hook_failure:
      interpretation: |
        A pre-commit hook failure due to scope is NOT a nuisance.
        It is evidence of missing governance work.
      action: DO NOT USE --no-verify
      correct_response: Update INTENT_DECLARATION.yaml first

  # ---------------------------------------------------------------------------
  # Claude Decision Tree (Internal)
  # ---------------------------------------------------------------------------
  claude_decision_tree:
    before_creating_any_directory:
      question_1: "Does this path exist in INTENT_DECLARATION.yaml?"
      if_no:
        question_2: "What type of artifact is this?"
        if_semantic_layer: ESCALATE (requires human approval)
        if_documentation: DECLARE (propose intent update)
        if_design: DECLARE (propose intent update)
        if_execution: BLOCK (may require architecture review)
      if_yes: PROCEED

  # ---------------------------------------------------------------------------
  # Session Resume Check
  # ---------------------------------------------------------------------------
  session_resume_checks:
    - name: scope_integrity
      description: |
        Before continuing work, verify that all existing uncommitted
        files are within declared intent scope.
      claude_action_on_violation:
        - Stop further changes
        - Identify offending paths
        - Propose intent normalization commit

  # ---------------------------------------------------------------------------
  # Rules Summary
  # ---------------------------------------------------------------------------
  rules:
    - id: SCOPE-001
      name: No Code Before Scope
      description: Files cannot be created in undeclared paths
      enforcement: BLOCKING (Claude behavioral)

    - id: SCOPE-002
      name: Intent Before Implementation
      description: INTENT_DECLARATION.yaml must be updated before new paths
      enforcement: BLOCKING

    - id: SCOPE-003
      name: Hook Failures Are Signals
      description: Scope-based hook failures indicate missing governance work
      enforcement: BLOCKING (no bypass)

    - id: SCOPE-004
      name: Separate Governance Commits
      description: Intent updates must be committed alone before implementation
      enforcement: MANDATORY

# =============================================================================
# Section 37: DEPLOY AFTER REBUILD DISCIPLINE (BL-DEPLOY-001)
# =============================================================================
# Incident: Code rebuilt but not deployed, user could not see/test changes.
# Root Cause: Build step completed, but deploy step was forgotten.
# Principle: Build without deploy = invisible work = wasted time.
# Reference: PIN-359 Phase 2
# =============================================================================

deployment_discipline:
  rule_id: BL-DEPLOY-001
  severity: BLOCKING
  effective: "2026-01-08"

  principle: |
    Build without deploy is forbidden.
    User cannot see or test changes until they are deployed.
    Build + Deploy must be treated as a single atomic operation.

  # ---------------------------------------------------------------------------
  # Frontend Deployment (app-shell)
  # ---------------------------------------------------------------------------
  frontend:
    working_directory: /root/agenticverz2.0/website/app-shell
    build_command: npm run build
    deploy_commands:
      - cp -r dist/* dist-preflight/
      - sudo systemctl reload apache2
    verification: "Refresh browser - changes visible"

    canonical_sequence: |
      cd /root/agenticverz2.0/website/app-shell && npm run build && \
      cp -r dist/* dist-preflight/ && sudo systemctl reload apache2

  # ---------------------------------------------------------------------------
  # Backend Deployment (docker compose)
  # ---------------------------------------------------------------------------
  backend:
    working_directory: /root/agenticverz2.0
    build_and_deploy_command: docker compose up -d --build backend
    verification: docker compose ps
    health_check: "Status: healthy"

    canonical_sequence: |
      cd /root/agenticverz2.0 && docker compose up -d --build backend && \
      docker compose ps

  # ---------------------------------------------------------------------------
  # Claude Behavioral Rule
  # ---------------------------------------------------------------------------
  claude_behavior:
    after_any_build:
      - MUST run deploy commands immediately
      - MUST NOT stop at "build complete"
      - MUST NOT assume user can see changes
      - MUST confirm deployment in response

    response_format: |
      Build complete. Deploying...
      [deploy commands output]
      Deployed. Refresh browser to see changes.

  # ---------------------------------------------------------------------------
  # Violation Response
  # ---------------------------------------------------------------------------
  violation_response:
    on_build_without_deploy: |
      BL-DEPLOY-001 VIOLATION: Build completed but not deployed.

      After ANY rebuild, you MUST deploy:

      Frontend:
        cp -r dist/* dist-preflight/ && sudo systemctl reload apache2

      Backend:
        docker compose up -d --build backend

      User cannot see/test changes until deployed.

  # ---------------------------------------------------------------------------
  # Rules Summary
  # ---------------------------------------------------------------------------
  rules:
    - id: DEPLOY-001
      name: Deploy After Frontend Build
      description: npm run build MUST be followed by deploy to dist-preflight/
      enforcement: BLOCKING

    - id: DEPLOY-002
      name: Reload Apache After Deploy
      description: Frontend deploy MUST include systemctl reload apache2
      enforcement: BLOCKING

    - id: DEPLOY-003
      name: Backend Build Includes Deploy
      description: docker compose up -d --build IS build + deploy
      enforcement: BY_CONSTRUCTION

    - id: DEPLOY-004
      name: Verify Deployment
      description: Always confirm deployment was successful
      enforcement: MANDATORY

# =============================================================================
# Section 38: SDSR UI ARCHITECTURE GATE (BL-SDSR-UI-001)
# =============================================================================
# Incident: Custom ActivityPage bypassed projection-driven DomainPage.
# Root Cause: SDSR data binding happened at page level, not panel level.
# Principle: UI renders projection. UI does not bypass projection.
# Reference: PIN-370, docs/governance/SDSR.md
# =============================================================================

sdsr_ui_architecture:
  rule_id: BL-SDSR-UI-001
  severity: BLOCKING
  effective: "2026-01-09"

  # ---------------------------------------------------------------------------
  # Core Principle
  # ---------------------------------------------------------------------------
  principle: |
    UI renders projection. UI does not bypass projection.

    The L2.1 projection pipeline defines the canonical UI structure:
      Domain → Subdomain → Topic Tabs → Panels

    SDSR data binding happens at the PANEL level via PanelContentRegistry.
    Custom pages that bypass the projection structure are FORBIDDEN.

  # ---------------------------------------------------------------------------
  # Architecture Rules
  # ---------------------------------------------------------------------------
  rules:
    - id: SDSR-UI-001
      name: Routes Use DomainPage
      description: |
        All domain routes in routes/index.tsx must import from DomainPage.tsx.
        Direct custom page imports for domains are forbidden.
      enforcement: BLOCKING
      reference: website/app-shell/src/routes/index.tsx

    - id: SDSR-UI-002
      name: Data Binding via PanelContentRegistry
      description: |
        SDSR data must be bound at the panel level via PanelContentRegistry.
        Do NOT render data directly in custom components outside the panel structure.
      enforcement: BLOCKING
      reference: website/app-shell/src/components/panels/PanelContentRegistry.tsx

    - id: SDSR-UI-003
      name: Panel ID Registration Required
      description: |
        Before a panel can show real data, its panel_id must be registered
        in the PANEL_CONTENT_REGISTRY map with a content renderer function.
      enforcement: BLOCKING

    - id: SDSR-UI-004
      name: Projection Structure Preserved
      description: |
        The DomainPage structure (Domain → Subdomain → Topic → Panel) must be
        preserved. Flattening or bypassing this hierarchy is forbidden.
      enforcement: BLOCKING

    # Cross-Domain Propagation Rules
    - id: SDSR-PROP-001
      name: Scenarios Inject Causes Not Consequences
      description: |
        Scenarios must NEVER simulate cross-domain behavior.
        Cross-domain reflection must emerge ONLY from backend capabilities.
        A scenario's job is to introduce a cause, not to fake consequences.
      enforcement: BLOCKING

    - id: SDSR-PROP-002
      name: One Scenario One Domain
      description: |
        Each scenario is authored from exactly one domain's point of view.
        Examples: ACTIVITY-FAILED-RUN-001, INCIDENTS-THRESHOLD-BREACH-001
      enforcement: BLOCKING

    - id: SDSR-PROP-003
      name: Expectations Not Cross-Domain Writes
      description: |
        Scenarios declare `writes` ONLY for their domain.
        Cross-domain effects use `expects` (assertions), not `writes`.
        If any `expects` fail → backend bug, not scenario bug.
      enforcement: BLOCKING

    - id: SDSR-PROP-004
      name: Backend Owns Propagation
      description: |
        Cross-domain effects must fire from backend capabilities:
        - Run → Incident: Incident Engine
        - Incident → Policy: Policy Engine
        - Run → Logs: Logging/Evidence
        If these don't fire, backend is broken, not scenario.
      enforcement: BLOCKING

  # ---------------------------------------------------------------------------
  # Cross-Domain Propagation Contract
  # ---------------------------------------------------------------------------
  cross_domain_propagation:
    principle: |
      If a failed Activity run does NOT create an Incident, influence Policies,
      or appear in Logs, then the backend is broken, not the scenario.

    backend_responsibility_matrix:
      - effect: Run → Incident
        owner: Incident Engine
        scenario_role: EXPECT only
      - effect: Incident → Policy
        owner: Policy Engine
        scenario_role: EXPECT only
      - effect: Run → Logs
        owner: Logging / Evidence
        scenario_role: EXPECT only
      - effect: Incident → Logs
        owner: Logging / Evidence
        scenario_role: EXPECT only
      - effect: Policy → Memory
        owner: Memory / Learning
        scenario_role: EXPECT only

    domain_execution_order:
      - Activity (cause)
      - Incidents (reactive)
      - Policies (reactive)
      - Logs (evidence)

    rule: No parallelism. No shortcuts.

  # ---------------------------------------------------------------------------
  # Conflict Resolution (MANDATORY)
  # ---------------------------------------------------------------------------
  conflict_resolution:
    on_ambiguity: ASK_USER
    rule: |
      When Claude is uncertain whether a UI change respects projection architecture,
      Claude MUST stop and ask the user. Guessing is forbidden.

    claude_question_format: |
      UI ARCHITECTURE CONFLICT DETECTED

      I'm uncertain whether this change respects the projection-driven architecture.

      Options:
      1. Bind data at panel level via PanelContentRegistry (recommended)
      2. Create a custom page (requires explicit approval)
      3. Clarify the UI structure requirement

      Which approach should I take?

    default_choice: Option 1 (PanelContentRegistry)

  # ---------------------------------------------------------------------------
  # Validation Checklist
  # ---------------------------------------------------------------------------
  validation_checklist:
    name: SDSR UI Architecture Check
    run_before: Any UI work involving SDSR data binding
    items:
      - question: Does this use DomainPage for structure?
        required: YES
      - question: Does data binding happen via PanelContentRegistry?
        required: YES
      - question: Is the panel_id registered in the registry?
        required: YES
      - question: Does the API endpoint exist?
        required: YES
      - question: Is synthetic data properly marked (is_synthetic)?
        required: YES

    on_failure: STOP and resolve before proceeding

  # ---------------------------------------------------------------------------
  # Claude Behavioral Rules
  # ---------------------------------------------------------------------------
  claude_behavior:
    forbidden_actions:
      - Bypass DomainPage for domain routes
      - Create flat custom pages that ignore projection hierarchy
      - Render data outside PanelContentRegistry pattern
      - Assume UI structure without checking projection lock
      - Proceed with ambiguous UI architecture decisions

    required_actions:
      - Ask when UI architecture is unclear
      - Use PanelContentRegistry for all SDSR data binding
      - Verify panel_id exists in projection_lock.json
      - Confirm projection structure is preserved

  # ---------------------------------------------------------------------------
  # Violation Response
  # ---------------------------------------------------------------------------
  violation_response:
    on_bypass_attempt: |
      BL-SDSR-UI-001 VIOLATION: Projection bypass detected.

      Routes must use DomainPage for domain rendering.
      Data binding must happen via PanelContentRegistry.

      Correct pattern:
      1. DomainPage provides: Domain → Subdomain → Topic → Panel structure
      2. PanelContentRegistry binds data to specific panel_ids
      3. FullPanelSurface checks registry and renders content

      Do NOT create custom pages that bypass this structure.

  # ---------------------------------------------------------------------------
  # Reference Files
  # ---------------------------------------------------------------------------
  reference_files:
    governance: docs/governance/SDSR.md
    pin: docs/memory-pins/PIN-370-sdsr-scenario-driven-system-realization.md
    domain_page: website/app-shell/src/pages/domains/DomainPage.tsx
    panel_registry: website/app-shell/src/components/panels/PanelContentRegistry.tsx
    projection_lock: website/app-shell/public/projection/ui_projection_lock.json
    routes: website/app-shell/src/routes/index.tsx

# =============================================================================
# SECTION 39: CANONICAL-FIRST FIX POLICY (ARCH-CANON-001)
# =============================================================================
# Reference: PIN-370 (SDSR Consolidation Incident), CLAUDE_ENGINEERING_AUTHORITY.md
# Root Cause: sdsr_incidents table was created instead of extending canonical incidents table
# Incident: Analytics fragmentation, policy engine breakage, export compliance issues
# =============================================================================

canonical_first_policy:
  status: MANDATORY
  effective: 2026-01-09
  reference: PIN-370

  # ---------------------------------------------------------------------------
  # Core Rule (HARD BLOCK)
  # ---------------------------------------------------------------------------
  core_rule:
    id: ARCH-CANON-001
    name: Canonical-First Fix Policy
    statement: |
      Claude is FORBIDDEN from creating new database tables, schemas, or public APIs
      when addressing functional gaps, bugs, or missing behavior in an existing domain.
    enforcement: BLOCKING

  # ---------------------------------------------------------------------------
  # Mandatory Behavior
  # ---------------------------------------------------------------------------
  mandatory_behavior:
    principle: |
      Claude MUST assume a single canonical structure already exists for each
      domain concept (e.g., incidents, runs, policies).

    fix_types:
      - type: Lifecycle hooks
        description: Add/fix event handlers, triggers
      - type: State transitions
        description: Fix status changes, workflow steps
      - type: Mappings
        description: Fix field mappings, transformations
      - type: Queries
        description: Fix SELECT/JOIN logic
      - type: Indexing
        description: Add/fix database indexes
      - type: Ownership boundaries
        description: Fix domain engine responsibility

  # ---------------------------------------------------------------------------
  # Explicitly Forbidden Actions
  # ---------------------------------------------------------------------------
  forbidden_actions:
    - action: Creating parallel tables
      pattern: "sdsr_*, *_v2, *_new"
      reason: Fragments analytics, policy, exports
    - action: Creating shadow APIs
      pattern: Duplicate endpoints for same intent
      reason: Confuses callers, duplicates maintenance
    - action: Introducing "temporary" structures
      pattern: Any structure labeled temporary
      reason: Temporary becomes permanent
    - action: Renaming domain concepts
      pattern: Avoiding collisions by renaming
      reason: Obscures truth

  # ---------------------------------------------------------------------------
  # Canonical Repair Order (MANDATORY)
  # ---------------------------------------------------------------------------
  repair_order:
    description: |
      When a conflict or limitation appears, Claude must follow this exact repair order.
      At no point may Claude bypass a canonical structure.

    steps:
      - step: 1
        name: Find the Canonical Structure
        action: Identify existing table, model, API, domain engine

      - step: 2
        name: Explain Why Behavior Is Missing
        diagnose:
          - Lifecycle hook absent
          - Event not emitted
          - Mapping incomplete
          - Query wrong
          - Transaction boundary wrong

      - step: 3
        name: Fix by Extension Not Duplication
        do_this:
          - Add fields to existing table
          - Add hooks to existing flow
          - Add handlers to existing engine
          - Add indexes to existing table
          - Add constraints to existing schema
        not_this:
          - Create new table
          - Create parallel flow
          - Create new service
          - Create materialized view
          - Create shadow validation

      - step: 4
        name: Re-run Scenario
        action: |
          If scenario passes → proceed
          If scenario fails → repeat from Step 2

  # ---------------------------------------------------------------------------
  # Fragmentation Escalation Protocol (ARCH-FRAG-ESCALATE-001)
  # ---------------------------------------------------------------------------
  fragmentation_escalation:
    id: ARCH-FRAG-ESCALATE-001
    name: Fragmentation Escalation Protocol
    principle: |
      Fragmentation is not forbidden, but it is never Claude's decision.

    escalation_triggers:
      - Break backward compatibility
      - Violate regulatory constraints
      - Corrupt production data
      - Invalidate existing customers

    required_report_format: |
      FRAGMENTATION ESCALATION REPORT

      Title: Canonical Architecture Conflict Detected — Decision Required

      1. CANONICAL STRUCTURE IDENTIFIED
         - Name: [table/model/API name]
         - Location: [file path]
         - Owner domain: [domain name]

      2. WHY DIRECT FIX IS UNSAFE
         - Concrete reason (not speculative)
         - What would break

      3. OPTIONS (No More Than 3)
         | Option | Description | Trade-offs | Long-Term Cost |
         |--------|-------------|------------|----------------|
         | A      | Fix canonical structure | ... | ... |
         | B      | Introduce parallel structure | ... | ... |
         | C      | Transitional shim | ... | ... |

      4. RECOMMENDATION (Optional)
         - Claude may recommend ONE option
         - Must justify clearly

      5. EXPLICIT ASK
         "Please choose A, B, or C. I will not proceed without direction."

    hard_stop_rule: |
      Claude MUST NOT write code after producing this report.
      Claude MUST wait for user instruction.

  # ---------------------------------------------------------------------------
  # Blocking Rules
  # ---------------------------------------------------------------------------
  blocking_rules:
    - rule_id: ARCH-CANON-001
      name: Canonical-First Fix Policy
      enforcement: |
        If Claude proposes any new table or public API without approval,
        response is INVALID. Claude must STOP and report the conflict.

    - rule_id: ARCH-FRAG-ESCALATE-001
      name: Fragmentation Escalation Required
      enforcement: |
        If canonical fix is unsafe, Claude must produce Fragmentation
        Escalation Report and wait for direction. Code is forbidden.

  # ---------------------------------------------------------------------------
  # Hard Failure Response
  # ---------------------------------------------------------------------------
  violation_response:
    on_parallel_structure_attempt: |
      ARCH-CANON-001 VIOLATION: Cannot create new table/API for existing domain.

      Canonical structure: [name] at [location]
      Must fix by extension, not duplication.

      If canonical fix is unsafe, produce Fragmentation Escalation Report.

      Reference: docs/governance/CLAUDE_ENGINEERING_AUTHORITY.md Section 13

  # ---------------------------------------------------------------------------
  # Rationale (Claude Must Internalize)
  # ---------------------------------------------------------------------------
  rationale: |
    Fragmentation solves the immediate error but permanently damages:
    - Analytics (queries must join multiple sources)
    - Policy reasoning (engines see incomplete data)
    - Exports & compliance (reports miss data)
    - Trust (system truth is fragmented)

    Fixing canonical structures preserves long-term system integrity.
    This rule was created after the sdsr_incidents incident (PIN-370)
    where a parallel table was created instead of extending the canonical
    incidents table, requiring emergency consolidation.

# =============================================================================
# Section 40: EPISTEMIC SAFETY PROTOCOL (PIN-389)
# =============================================================================
#
# Reference: docs/governance/CLAUDE_EPISTEMIC_SAFETY.md
# Enforcement: claude_epistemic_contract.yaml
# Root Cause: Claude invented field names by pattern-matching, causing validation failures
#
# Prime Directive:
#   Schema is law.
#   If a schema exists, Claude MUST load it, reason from it, and constrain outputs to it.
#   If a schema is missing, ambiguous, or not provided, Claude MUST stop and ask for it.
#   Guessing, extrapolation, or pattern-based invention is forbidden.
#
# Mental Model: Claude behaves like a compiler, not a co-designer.
#

epistemic_safety_protocol:
  id: BL-EPISTEMIC-001
  name: Schema-First Protocol
  effective: "2026-01-11"
  reference: PIN-389
  status: BLOCKING

  # ---------------------------------------------------------------------------
  # Core Principle
  # ---------------------------------------------------------------------------
  prime_directive: |
    Schema is law.
    If a schema exists, I MUST load it, reason from it, and constrain outputs to it.
    If a schema is missing, ambiguous, or not provided, I MUST stop and ask for it.
    Guessing, extrapolation, or pattern-based invention is forbidden.

  mental_model: |
    "I behave like a compiler, not a co-designer."

    This reframes all interactions:
    - Compilers don't guess missing tokens
    - Compilers don't rename fields "for clarity"
    - Compilers halt on invalid input
    - Compilers produce deterministic output

  # ---------------------------------------------------------------------------
  # Mandatory Operating Protocol (Every Schema-Governed Operation)
  # ---------------------------------------------------------------------------
  mandatory_steps:
    - step: 0
      name: Declare Scope
      action: |
        Claude must explicitly state:
        - Which file(s) it is operating on
        - Which schema(s) govern those files
        If it cannot name the schema → STOP
      output_format: |
        SCOPE DECLARATION
        - Operating on: <file_path>
        - Governing schema: <schema_name>
        - Schema location: <schema_path>

    - step: 1
      name: Load Schema
      action: |
        Claude must do one of the following:
        - Quote the schema fields it is using
        - Or explicitly say: "Schema not provided — cannot proceed"
      forbidden: |
        "Typically an observation would include…"
        "Based on similar files…"

    - step: 2
      name: Validate Before Writing
      checks:
        - Required fields: Are all required fields present?
        - Field names: Are field names exact (no synonyms)?
        - Enum values: Are enum values valid per schema?
        - Responsibilities: Is this layer allowed to write this?
      rule: If any check fails → refuse output

    - step: 3
      name: Write Output (Zero Creativity)
      constraints:
        - Only schema-defined fields allowed
        - No inferred fields
        - No renamed fields
        - No "extra helpful metadata"

    - step: 4
      name: Post-Write Assertion
      output_format: |
        SCHEMA COMPLIANCE CHECK
        - Schema: <name>
        - Required fields: OK / MISSING: <list>
        - Forbidden fields: none / FOUND: <list>
        - Responsibility boundary respected: YES / NO
      rule: If it cannot say "OK" and "YES" → output is INVALID

  # ---------------------------------------------------------------------------
  # Forbidden Behaviors (Absolute)
  # ---------------------------------------------------------------------------
  forbidden_behaviors:
    - action: Invent field names
      example: "observed_on vs observed_at is a schema violation"
    - action: Rename fields "for clarity"
      reason: "Field names are contract, not style"
    - action: Add fields not in schema
      reason: "Extra fields pollute validation"
    - action: Infer backend behavior from intent
      reason: "Intent ≠ Implementation"
    - action: Infer UI behavior from projection
      reason: "UI reads projection, doesn't derive it"
    - action: Write relative + absolute routes in same layer
      reason: "Layer separation is absolute"
    - action: Fix errors silently
      reason: "Must report and stop"
    - action: Guess missing values
      reason: "Missing = STOP, not invent"
    - action: Pattern-match from similar files
      reason: "Each file has its own schema"
    - action: Assume schema from filename
      reason: "Schema must be explicitly loaded"

  # ---------------------------------------------------------------------------
  # Layer Boundary Guardrails
  # ---------------------------------------------------------------------------
  layer_boundaries:
    description: Claude must name the layer before acting.
    layers:
      - layer: SDSR Scenario
        may_read: YAML scenario
        may_write: DB (synthetic only)
        forbidden: AURORA_L2
      - layer: Scenario_SDSR_output
        may_read: Runner state
        may_write: In-memory struct
        forbidden: Files, DB
      - layer: SDSR_output_emit
        may_read: Scenario output
        may_write: Observation JSON
        forbidden: Inference
      - layer: AURORA_L2_apply
        may_read: Observation JSON
        may_write: Capability + Intent YAML
        forbidden: Guessing
      - layer: Compiler
        may_read: Intent + Capability
        may_write: Projection
        forbidden: Runtime logic
      - layer: UI
        may_read: Projection
        may_write: Rendering only
        forbidden: Decisions
      - layer: Projection Assertions
        may_read: Projection JSON
        may_write: Validation errors
        forbidden: Route resolution
      - layer: Route Resolution
        may_read: Relative routes
        may_write: Absolute routes
        forbidden: Projection mutation

    cross_layer_rule: Cross-layer writes are forbidden without explicit approval.

  # ---------------------------------------------------------------------------
  # Refusal Template
  # ---------------------------------------------------------------------------
  refusal_template: |
    EPISTEMIC SAFETY HALT

    I cannot proceed.

    Reason: <specific reason>
    Missing: <what is needed>
    Schema required: <schema_name>

    This prevents me from guessing field names or semantics.
    Please provide the schema or clarify the requirement.

  # ---------------------------------------------------------------------------
  # Blocking Rules
  # ---------------------------------------------------------------------------
  blocking_rules:
    - rule_id: EPISTEMIC-001
      name: Schema Declaration Required
      trigger: Any schema-governed file operation
      enforcement: Output without schema declaration is INVALID

    - rule_id: EPISTEMIC-002
      name: No Field Invention
      trigger: Writing JSON, YAML, or structured data
      enforcement: Invented field names invalidate response

    - rule_id: EPISTEMIC-003
      name: Cross-Layer Write Block
      trigger: Attempting to write outside layer boundary
      enforcement: Response is BLOCKED

    - rule_id: EPISTEMIC-004
      name: Silent Fix Prohibition
      trigger: Any error correction
      enforcement: Must HALT and report, never silently fix

    - rule_id: EPISTEMIC-005
      name: Pattern Inference Block
      trigger: Reasoning from similar files
      enforcement: Response INVALID if based on pattern-matching

  # ---------------------------------------------------------------------------
  # Rationale
  # ---------------------------------------------------------------------------
  rationale: |
    Claude failed earlier not because it lacked intelligence, but because:
    - It treated schema as documentation, not authority
    - It inferred intent from filenames and patterns
    - It "helpfully" filled gaps instead of refusing to proceed

    The fix is NOT "be more careful" —
    the fix is procedural refusal unless schema is loaded and validated.

    This rule was created after PIN-389 (Projection Route Separation) where
    Claude was enforcing runtime invariants (console prefixes) at design time
    (projection routes), causing validation failures for correct relative routes.

    A halted response is correct.
    A guessed response is a bug.

# =============================================================================
# Section 41: QUERY AUTHORITY MODEL (PIN-390)
# =============================================================================
#
# Reference: docs/governance/QUERY_AUTHORITY_MODEL.md
# Schema: docs/schemas/query_authority_schema.json
# Root Cause: Four consoles without explicit query authority = 403 factory
#
# Prime Directive:
#   Query authority is declarative.
#   UI MUST NOT infer query permissions.
#   Backend MUST NOT be relaxed for preflight.
#   Projection MUST declare query_authority.
#   Any panel without query_authority is INVALID.
#

query_authority_model:
  id: BL-QUERY-AUTH-001
  name: Four-Console Query Authority
  effective: "2026-01-11"
  reference: PIN-390
  status: BLOCKING

  # ---------------------------------------------------------------------------
  # Prime Directive
  # ---------------------------------------------------------------------------
  prime_directive: |
    Query authority is declarative.
    UI MUST NOT infer query permissions.
    Backend MUST NOT be relaxed for preflight.
    Projection MUST declare query_authority.
    Claude MUST NOT guess authority based on endpoint names.
    Any panel without query_authority is INVALID.

  # ---------------------------------------------------------------------------
  # Authority Levels (Locked Semantics)
  # ---------------------------------------------------------------------------
  authority_levels:
    USER:
      meaning: Tenant-scoped, customer-safe data
      examples: ["Activity runs", "Policies", "Logs"]
    SYSTEM:
      meaning: Engine / control-plane derived data
      examples: ["Incidents", "System health", "Metrics"]
    SYNTHETIC:
      meaning: Test, injected, SDSR-derived data
      examples: ["Scenarios", "Synthetic runs", "Test fixtures"]
    INTERNAL:
      meaning: Staff-only / governance / debugging
      examples: ["Admin tools", "Governance data"]

  forbidden_shortcuts:
    - "SYSTEM ≠ USER in preflight"
    - "SYNTHETIC ≠ SYSTEM"
    - "INTERNAL ≠ founder by default"
    - "No collapsing allowed"

  # ---------------------------------------------------------------------------
  # Four-Console Authority Matrix (Core Truth)
  # ---------------------------------------------------------------------------
  authority_matrix:
    description: |
      This table must be hardcoded in UI runtime, not inferred.
      SYNTHETIC is NEVER allowed in production.
      INTERNAL is never projection-exposed.
      Founder ≠ god mode.

    consoles:
      - console: customer
        environment: preflight
        USER: true
        SYSTEM: false
        SYNTHETIC: false
        INTERNAL: false

      - console: customer
        environment: production
        USER: true
        SYSTEM: false
        SYNTHETIC: false
        INTERNAL: false

      - console: founder
        environment: preflight
        USER: true
        SYSTEM: true
        SYNTHETIC: true
        INTERNAL: false

      - console: founder
        environment: production
        USER: true
        SYSTEM: true
        SYNTHETIC: false
        INTERNAL: false

  # ---------------------------------------------------------------------------
  # Failure Modes
  # ---------------------------------------------------------------------------
  failure_modes:
    HIDE:
      behavior: Panel is not rendered at all
      use_when: User should not know panel exists
    DISABLE:
      behavior: Panel visible but non-interactive (grayed)
      use_when: User should see but not interact
    EXPLAIN:
      behavior: Panel shows explanation of access denial
      use_when: User should understand why denied

  # ---------------------------------------------------------------------------
  # Fail-Closed Default
  # ---------------------------------------------------------------------------
  fail_closed_default:
    description: When authority is unknown, use this default
    value:
      level: SYSTEM
      allow_in:
        customer:
          preflight: false
          production: false
        founder:
          preflight: false
          production: false
      failure_mode: HIDE
      notes: "Fail-closed default - requires explicit promotion"

  # ---------------------------------------------------------------------------
  # UI Contract
  # ---------------------------------------------------------------------------
  ui_contract:
    before_any_api_call: |
      if (!canQuery(panel.query_authority, consoleContext, authContext)) {
        return renderBoundary(panel.query_authority.failure_mode);
      }

    ui_must_never:
      - action: Retry on 403
        reason: 403 is truth, not transient error
      - action: Infer permission from response
        reason: Check before call
      - action: Log denied queries as errors
        reason: Denied is expected behavior
      - action: Mask as backend error
        reason: Show appropriate boundary

  # ---------------------------------------------------------------------------
  # Compiler Contract (AURORA_L2)
  # ---------------------------------------------------------------------------
  compiler_contract:
    must_do:
      - Emit query_authority for every panel
      - Use fail-closed default if unsure
      - Fail compilation if missing

    must_not_do:
      - Infer from endpoint name
      - Infer from domain placement
      - Infer from console kind
      - Use implicit fallbacks

  # ---------------------------------------------------------------------------
  # CI Guard (Enforcement)
  # ---------------------------------------------------------------------------
  ci_guard:
    script: scripts/ci/query_authority_guard.py
    trigger: Any CI run, projection changes, or manual validation
    enforcement: BLOCKING

    validations:
      - name: Contract Declaration
        check: _contract declares query_authority_required
      - name: Panel Presence
        check: Every panel has query_authority field
      - name: Schema Compliance
        check: All fields match query_authority_schema.json
      - name: Hard Invariants
        check: No SYNTHETIC in production, no INTERNAL exposed
      - name: Matrix Compliance
        check: allow_in values match four-console matrix

    usage:
      verbose: python3 scripts/ci/query_authority_guard.py --verbose
      strict: python3 scripts/ci/query_authority_guard.py --strict
      custom_path: python3 scripts/ci/query_authority_guard.py --path /custom/path.json

    exit_codes:
      0: All validations passed
      1: Query authority violations detected
      2: File not found or invalid JSON

  # ---------------------------------------------------------------------------
  # Key Distinctions
  # ---------------------------------------------------------------------------
  key_distinctions:
    - distinction: "Visibility ≠ Queryability"
      meaning: A panel can be visible in projection but not queryable by user

    - distinction: "Queryability ≠ Executability"
      meaning: A user can see data but not take action on it

  # ---------------------------------------------------------------------------
  # Blocking Rules
  # ---------------------------------------------------------------------------
  blocking_rules:
    - rule_id: QUERY-AUTH-001
      name: Query Authority Required
      trigger: Any panel in projection
      enforcement: Panel without query_authority is INVALID

    - rule_id: QUERY-AUTH-002
      name: No Authority Inference
      trigger: Writing query_authority
      enforcement: Must declare explicitly, no guessing from context

    - rule_id: QUERY-AUTH-003
      name: Synthetic Production Block
      trigger: allow_in with SYNTHETIC
      enforcement: SYNTHETIC + production must always be false

    - rule_id: QUERY-AUTH-004
      name: Internal Projection Block
      trigger: INTERNAL level in projection
      enforcement: INTERNAL data never in projection output

    - rule_id: QUERY-AUTH-005
      name: UI Authority Check
      trigger: Before API call
      enforcement: canQuery() must pass before fetch

  # ---------------------------------------------------------------------------
  # Rationale
  # ---------------------------------------------------------------------------
  rationale: |
    With four consoles, implicit permission logic becomes lethal:
    - Panel exists → UI queries → backend denies → UI retries → 403 noise

    With explicit query_authority:
    - Panel exists → authority check → boundary shown → NO API CALL

    This eliminates false 403s and makes authority declarative.

    Created after PIN-389 (Epistemic Safety) to extend schema-first
    principles to query authority. Claude cannot guess anymore.

# =============================================================================
# END OF SESSION PLAYBOOK
# =============================================================================
