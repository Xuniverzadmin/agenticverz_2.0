{
  "L2": [
    {
      "file": "api/agents.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "CreateJobRequest",
          "purpose": "Request to create a parallel job.",
          "methods": []
        },
        {
          "type": "class",
          "name": "JobResponse",
          "purpose": "Job status response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ClaimItemResponse",
          "purpose": "Response when claiming an item.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CompleteItemRequest",
          "purpose": "Request to complete an item.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FailItemRequest",
          "purpose": "Request to fail an item.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BlackboardWriteRequest",
          "purpose": "Request to write to blackboard.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BlackboardIncrementRequest",
          "purpose": "Request to increment counter.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LockRequest",
          "purpose": "Request for lock operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RegisterAgentRequest",
          "purpose": "Request to register an agent.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SendMessageRequest",
          "purpose": "Request to send a message.",
          "methods": []
        },
        {
          "type": "class",
          "name": "InvokeResponseRequest",
          "purpose": "Request to respond to an invocation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SimulateJobRequest",
          "purpose": "Request to simulate job execution before committing.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SimulateJobResponse",
          "purpose": "Response from job simulation.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "simulate_job",
          "purpose": "Simulate job execution before committing resources."
        },
        {
          "type": "async_function",
          "name": "create_job",
          "purpose": "Create a new parallel job."
        },
        {
          "type": "async_function",
          "name": "get_job",
          "purpose": "Get job status by ID."
        },
        {
          "type": "async_function",
          "name": "cancel_job",
          "purpose": "Cancel a running job."
        },
        {
          "type": "async_function",
          "name": "claim_item",
          "purpose": "Worker claims next available item."
        },
        {
          "type": "async_function",
          "name": "complete_item",
          "purpose": "Mark item as completed with output."
        },
        {
          "type": "async_function",
          "name": "fail_item",
          "purpose": "Mark item as failed."
        },
        {
          "type": "async_function",
          "name": "get_blackboard",
          "purpose": "Read value from blackboard."
        },
        {
          "type": "async_function",
          "name": "put_blackboard",
          "purpose": "Write value to blackboard."
        },
        {
          "type": "async_function",
          "name": "increment_blackboard",
          "purpose": "Atomically increment a counter."
        },
        {
          "type": "async_function",
          "name": "lock_blackboard",
          "purpose": "Lock operation on blackboard."
        },
        {
          "type": "async_function",
          "name": "register_agent",
          "purpose": "Register an agent instance."
        },
        {
          "type": "async_function",
          "name": "agent_heartbeat",
          "purpose": "Update agent heartbeat."
        },
        {
          "type": "async_function",
          "name": "deregister_agent",
          "purpose": "Deregister an agent instance."
        },
        {
          "type": "async_function",
          "name": "get_agent",
          "purpose": "Get agent instance details."
        },
        {
          "type": "async_function",
          "name": "list_agents",
          "purpose": "List agent instances."
        },
        {
          "type": "async_function",
          "name": "send_message",
          "purpose": "Send a message to an agent."
        },
        {
          "type": "async_function",
          "name": "get_messages",
          "purpose": "Get messages for an agent."
        },
        {
          "type": "async_function",
          "name": "mark_message_read",
          "purpose": "Mark message as read."
        },
        {
          "type": "async_function",
          "name": "respond_to_invocation",
          "purpose": "Respond to an agent invocation."
        },
        {
          "type": "class",
          "name": "SBAValidateRequest",
          "purpose": "Request to validate SBA schema.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SBARegisterRequest",
          "purpose": "Request to register agent with SBA.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SBAGenerateRequest",
          "purpose": "Request to auto-generate SBA for an agent.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "validate_sba_endpoint",
          "purpose": "Validate an SBA schema."
        },
        {
          "type": "async_function",
          "name": "register_agent_with_sba",
          "purpose": "Register an agent with its SBA schema."
        },
        {
          "type": "async_function",
          "name": "generate_sba_for_agent",
          "purpose": "Auto-generate SBA for an agent."
        },
        {
          "type": "async_function",
          "name": "get_sba_version_info",
          "purpose": "M15.1.1: Get SBA version negotiation info."
        },
        {
          "type": "async_function",
          "name": "negotiate_sba_version",
          "purpose": "M15.1.1: Negotiate SBA version."
        },
        {
          "type": "async_function",
          "name": "get_sba_health",
          "purpose": "M16: Get aggregated strategy health for Guard Console."
        },
        {
          "type": "async_function",
          "name": "get_agent_sba",
          "purpose": "Get SBA schema for an agent."
        },
        {
          "type": "async_function",
          "name": "list_agents_sba",
          "purpose": "List agents with their SBA status."
        },
        {
          "type": "async_function",
          "name": "check_spawn_allowed",
          "purpose": "Check if agent is allowed to spawn."
        },
        {
          "type": "async_function",
          "name": "get_fulfillment_aggregated",
          "purpose": "M15.1.1: Get aggregated fulfillment metrics for heatmap visualization."
        },
        {
          "type": "class",
          "name": "WorkerCostMetrics",
          "purpose": "Worker cost and risk metrics.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ActivityCostsResponse",
          "purpose": "Response for activity costs endpoint.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SpendingDataResponse",
          "purpose": "Response for spending tracker endpoint.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RetryEntryResponse",
          "purpose": "Single retry entry.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ActivityRetriesResponse",
          "purpose": "Response for retries endpoint.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BlockerEntry",
          "purpose": "Single blocker entry.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ActivityBlockersResponse",
          "purpose": "Response for blockers endpoint.",
          "methods": []
        },
        {
          "type": "class",
          "name": "HealthCheckItem",
          "purpose": "Single health check result.",
          "methods": []
        },
        {
          "type": "class",
          "name": "HealthCheckResponse",
          "purpose": "Response for health check endpoint.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "get_agent_activity_costs",
          "purpose": "M16: Get worker cost and risk metrics for an agent."
        },
        {
          "type": "async_function",
          "name": "get_agent_activity_spending",
          "purpose": "M16: Get spending data for budget burn chart."
        },
        {
          "type": "async_function",
          "name": "get_agent_activity_retries",
          "purpose": "M16: Get retry log for an agent."
        },
        {
          "type": "async_function",
          "name": "get_agent_activity_blockers",
          "purpose": "M16: Get current blockers for an agent."
        },
        {
          "type": "async_function",
          "name": "check_agent_health",
          "purpose": "M16: Run comprehensive health check for an agent."
        },
        {
          "type": "class",
          "name": "CascadeEvaluateRequest",
          "purpose": "Request for cascade evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RoutingDispatchRequest",
          "purpose": "Request for routing dispatch.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RoutingConfigUpdate",
          "purpose": "Request to update agent routing config.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "cascade_evaluate",
          "purpose": "M17: Evaluate agents through CARE pipeline without routing."
        },
        {
          "type": "async_function",
          "name": "routing_dispatch",
          "purpose": "M17: Execute full CARE routing pipeline and select best agent."
        },
        {
          "type": "async_function",
          "name": "get_agent_strategy",
          "purpose": "M17: Get agent's Strategy Cascade."
        },
        {
          "type": "async_function",
          "name": "update_agent_strategy",
          "purpose": "M17: Hot-swap agent's routing configuration."
        },
        {
          "type": "async_function",
          "name": "get_routing_stats",
          "purpose": "M17: Get routing statistics."
        },
        {
          "type": "class",
          "name": "ExplainRoutingResponse",
          "purpose": "Response explaining a routing decision.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EvolutionReportResponse",
          "purpose": "Response with agent evolution history.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SystemStabilityResponse",
          "purpose": "Response with system-wide stability metrics.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "explain_routing_decision",
          "purpose": "M18: Explain why a routing decision was made."
        },
        {
          "type": "async_function",
          "name": "get_agent_evolution",
          "purpose": "M18: Get agent evolution history and current state."
        },
        {
          "type": "async_function",
          "name": "get_system_stability",
          "purpose": "M18: Get system-wide stability metrics."
        },
        {
          "type": "async_function",
          "name": "freeze_system",
          "purpose": "M18: Manually freeze the learning system."
        },
        {
          "type": "async_function",
          "name": "unfreeze_system",
          "purpose": "M18: Manually unfreeze the learning system."
        },
        {
          "type": "async_function",
          "name": "trigger_batch_learning",
          "purpose": "M18: Trigger batch learning process."
        },
        {
          "type": "async_function",
          "name": "get_agent_reputation",
          "purpose": "M18: Get agent reputation details."
        },
        {
          "type": "async_function",
          "name": "get_agent_sla",
          "purpose": "M18: Get agent SLA score details."
        },
        {
          "type": "async_function",
          "name": "get_agent_successors",
          "purpose": "M18: Get successor mapping for agent failover."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/jobs/simulate"
        },
        {
          "method": "POST",
          "path": "/jobs"
        },
        {
          "method": "GET",
          "path": "/jobs/{job_id}"
        },
        {
          "method": "POST",
          "path": "/jobs/{job_id}/cancel"
        },
        {
          "method": "POST",
          "path": "/jobs/{job_id}/claim"
        },
        {
          "method": "POST",
          "path": "/jobs/{job_id}/items/{item_id}/complete"
        },
        {
          "method": "POST",
          "path": "/jobs/{job_id}/items/{item_id}/fail"
        },
        {
          "method": "GET",
          "path": "/blackboard/{key}"
        },
        {
          "method": "PUT",
          "path": "/blackboard/{key}"
        },
        {
          "method": "POST",
          "path": "/blackboard/{key}/increment"
        },
        {
          "method": "POST",
          "path": "/blackboard/{key}/lock"
        },
        {
          "method": "POST",
          "path": "/agents/register"
        },
        {
          "method": "POST",
          "path": "/agents/{instance_id}/heartbeat"
        },
        {
          "method": "DELETE",
          "path": "/agents/{instance_id}"
        },
        {
          "method": "GET",
          "path": "/agents/{instance_id}"
        },
        {
          "method": "GET",
          "path": "/agents"
        },
        {
          "method": "POST",
          "path": "/agents/{instance_id}/messages"
        },
        {
          "method": "GET",
          "path": "/agents/{instance_id}/messages"
        },
        {
          "method": "POST",
          "path": "/agents/{instance_id}/messages/{message_id}/read"
        },
        {
          "method": "POST",
          "path": "/invocations/respond"
        },
        {
          "method": "POST",
          "path": "/sba/validate"
        },
        {
          "method": "POST",
          "path": "/sba/register"
        },
        {
          "method": "POST",
          "path": "/sba/generate"
        },
        {
          "method": "GET",
          "path": "/sba/version"
        },
        {
          "method": "POST",
          "path": "/sba/version/negotiate"
        },
        {
          "method": "GET",
          "path": "/sba/health"
        },
        {
          "method": "GET",
          "path": "/sba/{agent_id}"
        },
        {
          "method": "GET",
          "path": "/sba"
        },
        {
          "method": "POST",
          "path": "/sba/check-spawn"
        },
        {
          "method": "GET",
          "path": "/sba/fulfillment/aggregated"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/activity/costs"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/activity/spending"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/activity/retries"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/activity/blockers"
        },
        {
          "method": "POST",
          "path": "/agents/{agent_id}/health/check"
        },
        {
          "method": "POST",
          "path": "/routing/cascade-evaluate"
        },
        {
          "method": "POST",
          "path": "/routing/dispatch"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/strategy"
        },
        {
          "method": "POST",
          "path": "/agents/{agent_id}/strategy/update"
        },
        {
          "method": "GET",
          "path": "/routing/stats"
        },
        {
          "method": "POST",
          "path": "/routing/explain/{request_id}"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/evolution"
        },
        {
          "method": "GET",
          "path": "/routing/stability"
        },
        {
          "method": "POST",
          "path": "/routing/stability/freeze"
        },
        {
          "method": "POST",
          "path": "/routing/stability/unfreeze"
        },
        {
          "method": "POST",
          "path": "/routing/batch-learning"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/reputation"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/sla"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/successors"
        }
      ]
    },
    {
      "file": "api/auth_helpers.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "async_function",
          "name": "verify_console_api_key",
          "purpose": "Verify API key for console endpoints."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/status"
        }
      ]
    },
    {
      "file": "api/cost_guard.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "async_function",
          "name": "get_cost_summary",
          "purpose": "GET /guard/costs/summary"
        },
        {
          "type": "async_function",
          "name": "get_cost_explained",
          "purpose": "GET /guard/costs/explained"
        },
        {
          "type": "async_function",
          "name": "get_cost_incidents",
          "purpose": "GET /guard/costs/incidents"
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/summary"
        },
        {
          "method": "GET",
          "path": "/explained"
        },
        {
          "method": "GET",
          "path": "/incidents"
        }
      ],
      "calls": {
        "L3": [
          "app.auth.console_auth"
        ],
        "L4": [
          "app.contracts.guard"
        ],
        "L6": [
          "app.db"
        ]
      }
    },
    {
      "file": "api/cost_intelligence.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "get_tenant_id",
          "purpose": "Extract tenant_id from query parameter."
        },
        {
          "type": "class",
          "name": "FeatureTagCreate",
          "purpose": "Create a new feature tag.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FeatureTagResponse",
          "purpose": "Feature tag response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FeatureTagUpdate",
          "purpose": "Update a feature tag.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostRecordCreate",
          "purpose": "Record a cost entry.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostSummary",
          "purpose": "Cost summary for a period.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostByFeature",
          "purpose": "Cost breakdown by feature.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostByUser",
          "purpose": "Cost breakdown by user.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostByModel",
          "purpose": "Cost breakdown by model.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostProjection",
          "purpose": "Cost projection for upcoming period.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostAnomalyResponse",
          "purpose": "Cost anomaly response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostDashboard",
          "purpose": "Complete cost dashboard data.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BudgetCreate",
          "purpose": "Create or update a budget.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BudgetResponse",
          "purpose": "Budget response.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "create_feature_tag",
          "purpose": "Register a new feature tag."
        },
        {
          "type": "async_function",
          "name": "list_feature_tags",
          "purpose": "List all feature tags for the tenant."
        },
        {
          "type": "async_function",
          "name": "update_feature_tag",
          "purpose": "Update a feature tag."
        },
        {
          "type": "async_function",
          "name": "record_cost",
          "purpose": "Record a cost entry."
        },
        {
          "type": "async_function",
          "name": "get_cost_dashboard",
          "purpose": "Get complete cost dashboard."
        },
        {
          "type": "async_function",
          "name": "get_cost_summary",
          "purpose": "Get cost summary for the period."
        },
        {
          "type": "async_function",
          "name": "get_costs_by_feature",
          "purpose": "Get cost breakdown by feature tag."
        },
        {
          "type": "async_function",
          "name": "get_costs_by_user",
          "purpose": "Get cost breakdown by user with anomaly detection."
        },
        {
          "type": "async_function",
          "name": "get_costs_by_model",
          "purpose": "Get cost breakdown by model."
        },
        {
          "type": "async_function",
          "name": "get_anomalies",
          "purpose": "Get detected cost anomalies."
        },
        {
          "type": "async_function",
          "name": "get_projection",
          "purpose": "Get cost projection based on historical data."
        },
        {
          "type": "async_function",
          "name": "create_or_update_budget",
          "purpose": "Create or update a budget."
        },
        {
          "type": "async_function",
          "name": "list_budgets",
          "purpose": "List all budgets for the tenant."
        },
        {
          "type": "class",
          "name": "AnomalyDetectionRequest",
          "purpose": "Request to trigger anomaly detection.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AnomalyDetectionResponse",
          "purpose": "Response from anomaly detection.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "trigger_anomaly_detection",
          "purpose": "Trigger anomaly detection for this tenant."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/features"
        },
        {
          "method": "GET",
          "path": "/features"
        },
        {
          "method": "PUT",
          "path": "/features/{tag}"
        },
        {
          "method": "POST",
          "path": "/record"
        },
        {
          "method": "GET",
          "path": "/dashboard"
        },
        {
          "method": "GET",
          "path": "/summary"
        },
        {
          "method": "GET",
          "path": "/by-feature"
        },
        {
          "method": "GET",
          "path": "/by-user"
        },
        {
          "method": "GET",
          "path": "/by-model"
        },
        {
          "method": "GET",
          "path": "/anomalies"
        },
        {
          "method": "GET",
          "path": "/projection"
        },
        {
          "method": "POST",
          "path": "/budgets"
        },
        {
          "method": "GET",
          "path": "/budgets"
        },
        {
          "method": "POST",
          "path": "/anomalies/detect"
        }
      ],
      "calls": {
        "L4": [
          "app.services.cost_write_service",
          "app.services.cost_anomaly_detector"
        ],
        "L6": [
          "app.db"
        ],
        "external": [
          "app.integrations.dispatcher"
        ]
      }
    },
    {
      "file": "api/cost_ops.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "async_function",
          "name": "get_cost_overview",
          "purpose": "GET /ops/cost/overview"
        },
        {
          "type": "async_function",
          "name": "get_cost_anomalies",
          "purpose": "GET /ops/cost/anomalies"
        },
        {
          "type": "async_function",
          "name": "get_cost_tenants",
          "purpose": "GET /ops/cost/tenants"
        },
        {
          "type": "async_function",
          "name": "get_customer_cost_drilldown",
          "purpose": "GET /ops/cost/customers/{tenant_id}"
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/overview"
        },
        {
          "method": "GET",
          "path": "/anomalies"
        },
        {
          "method": "GET",
          "path": "/tenants"
        },
        {
          "method": "GET",
          "path": "/customers/{tenant_id}"
        }
      ],
      "calls": {
        "L3": [
          "app.auth.console_auth"
        ],
        "L4": [
          "app.contracts.ops"
        ],
        "L6": [
          "app.db"
        ]
      }
    },
    {
      "file": "api/costsim.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "SimulationStep",
          "purpose": "A single step in a simulation plan.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SimulateRequest",
          "purpose": "Request for V2 simulation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SimulationStepResult",
          "purpose": "Result for a single step.",
          "methods": []
        },
        {
          "type": "class",
          "name": "V2SimulationResponse",
          "purpose": "Response from V2 simulation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ComparisonResponse",
          "purpose": "Comparison between V1 and V2.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SideEffectDisclosure",
          "purpose": "PIN-254 Phase C Fix (C5 Implicit Side-Effect): Explicit disclosure of side effects.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SandboxSimulateResponse",
          "purpose": "Response from sandbox simulation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SandboxStatusResponse",
          "purpose": "Status of V2 sandbox.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DivergenceReportResponse",
          "purpose": "Divergence report response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CanaryRunResponse",
          "purpose": "Canary run response.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "get_memory_context",
          "purpose": "Retrieve memory context for simulation."
        },
        {
          "type": "async_function",
          "name": "apply_post_execution_updates",
          "purpose": "Apply deterministic post-execution memory updates."
        },
        {
          "type": "async_function",
          "name": "detect_simulation_drift",
          "purpose": "Detect drift between baseline and memory-enabled simulation."
        },
        {
          "type": "async_function",
          "name": "get_sandbox_status",
          "purpose": "Get current V2 sandbox status."
        },
        {
          "type": "async_function",
          "name": "simulate_v2",
          "purpose": "Run simulation through V2 sandbox."
        },
        {
          "type": "async_function",
          "name": "reset_circuit_breaker",
          "purpose": "Reset the V2 circuit breaker."
        },
        {
          "type": "async_function",
          "name": "get_incidents",
          "purpose": "Get circuit breaker incidents."
        },
        {
          "type": "async_function",
          "name": "get_divergence_report",
          "purpose": "Get cost divergence report between V1 and V2."
        },
        {
          "type": "async_function",
          "name": "trigger_canary_run",
          "purpose": "Trigger a canary run on-demand."
        },
        {
          "type": "async_function",
          "name": "get_canary_reports",
          "purpose": "Get recent canary run reports."
        },
        {
          "type": "class",
          "name": "DatasetInfo",
          "purpose": "Dataset information.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ValidationResultResponse",
          "purpose": "Validation result response.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "list_datasets",
          "purpose": "List all available reference datasets."
        },
        {
          "type": "async_function",
          "name": "get_dataset_info",
          "purpose": "Get information about a specific dataset."
        },
        {
          "type": "async_function",
          "name": "validate_against_dataset",
          "purpose": "Validate V2 against a specific reference dataset."
        },
        {
          "type": "async_function",
          "name": "validate_all",
          "purpose": "Validate V2 against ALL reference datasets."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/v2/status"
        },
        {
          "method": "POST",
          "path": "/v2/simulate"
        },
        {
          "method": "POST",
          "path": "/v2/reset"
        },
        {
          "method": "GET",
          "path": "/v2/incidents"
        },
        {
          "method": "GET",
          "path": "/divergence"
        },
        {
          "method": "POST",
          "path": "/canary/run"
        },
        {
          "method": "GET",
          "path": "/canary/reports"
        },
        {
          "method": "GET",
          "path": "/datasets"
        },
        {
          "method": "GET",
          "path": "/datasets/{dataset_id}"
        },
        {
          "method": "POST",
          "path": "/datasets/{dataset_id}/validate"
        },
        {
          "method": "POST",
          "path": "/datasets/validate-all"
        }
      ],
      "calls": {
        "L4": [
          "app.costsim",
          "app.costsim.config",
          "app.costsim.divergence",
          "app.costsim.datasets",
          "app.costsim.datasets",
          "app.memory.drift_detector",
          "app.memory.memory_service",
          "app.memory.update_rules",
          "app.tasks.memory_update",
          "app.memory.memory_service",
          "app.memory.memory_service"
        ]
      }
    },
    {
      "file": "api/customer_visibility.py",
      "layer": "L2",
      "layer_source": "declared",
      "components": [
        {
          "type": "class",
          "name": "StageDeclaration",
          "purpose": "Single stage in the execution plan.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostDeclaration",
          "purpose": "Cost expectations before execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BudgetDeclaration",
          "purpose": "Budget enforcement mode.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyDeclaration",
          "purpose": "Policy posture declaration.",
          "methods": []
        },
        {
          "type": "class",
          "name": "MemoryDeclaration",
          "purpose": "Memory mode declaration.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EstimationMethodology",
          "purpose": "PIN-254 Phase C Fix (C3 Partial Truth): Explicit disclosure of estimation basis.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PreRunDeclaration",
          "purpose": "Complete PRE-RUN declaration for customer visibility.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AcknowledgementRequest",
          "purpose": "Customer acknowledgement of PRE-RUN declaration.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AcknowledgementResponse",
          "purpose": "Response after acknowledgement.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OutcomeItem",
          "purpose": "Single outcome item.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OutcomeReconciliation",
          "purpose": "Complete outcome reconciliation for customer visibility.",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_db_url",
          "purpose": "Get database URL from environment."
        },
        {
          "type": "function",
          "name": "get_budget_mode",
          "purpose": "Determine budget enforcement mode from configuration."
        },
        {
          "type": "function",
          "name": "get_policy_posture",
          "purpose": "Determine policy posture from configuration."
        },
        {
          "type": "function",
          "name": "get_memory_mode",
          "purpose": "Determine memory mode from configuration."
        },
        {
          "type": "function",
          "name": "estimate_stages",
          "purpose": "Estimate execution stages based on agent capabilities."
        },
        {
          "type": "function",
          "name": "estimate_cost",
          "purpose": "Estimate cost based on stages and historical data."
        },
        {
          "type": "function",
          "name": "fetch_run_outcome",
          "purpose": "Fetch run data for outcome reconciliation."
        },
        {
          "type": "function",
          "name": "fetch_decision_summary",
          "purpose": "Fetch decision summary for outcome reconciliation."
        },
        {
          "type": "async_function",
          "name": "get_pre_run_declaration",
          "purpose": "Get PRE-RUN declaration before execution."
        },
        {
          "type": "async_function",
          "name": "acknowledge_declaration",
          "purpose": "Acknowledge PRE-RUN declaration."
        },
        {
          "type": "async_function",
          "name": "get_outcome_reconciliation",
          "purpose": "Get outcome reconciliation after execution."
        },
        {
          "type": "async_function",
          "name": "get_declaration",
          "purpose": "Retrieve a previously created PRE-RUN declaration."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/pre-run"
        },
        {
          "method": "POST",
          "path": "/acknowledge"
        },
        {
          "method": "GET",
          "path": "/outcome/{run_id}"
        },
        {
          "method": "GET",
          "path": "/declaration/{declaration_id}"
        }
      ],
      "calls": {
        "L3": [
          "app.auth",
          "app.middleware.tenancy"
        ]
      }
    },
    {
      "file": "api/discovery.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "async_function",
          "name": "list_signals",
          "purpose": "List discovery signals from the ledger."
        },
        {
          "type": "async_function",
          "name": "signal_stats",
          "purpose": "Get summary statistics of discovery signals."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/"
        },
        {
          "method": "GET",
          "path": "/stats"
        }
      ],
      "calls": {
        "L6": [
          "app.db"
        ],
        "external": [
          "app.discovery.ledger"
        ]
      }
    },
    {
      "file": "api/embedding.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "EmbeddingQuotaResponse",
          "purpose": "Response schema for embedding quota status.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EmbeddingConfigResponse",
          "purpose": "Response schema for embedding configuration.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "get_embedding_quota",
          "purpose": "Get current embedding quota status."
        },
        {
          "type": "async_function",
          "name": "get_embedding_config",
          "purpose": "Get embedding configuration."
        },
        {
          "type": "async_function",
          "name": "embedding_health",
          "purpose": "Quick health check for embedding subsystem."
        },
        {
          "type": "async_function",
          "name": "embedding_cache_stats",
          "purpose": "Get embedding cache statistics."
        },
        {
          "type": "async_function",
          "name": "clear_embedding_cache",
          "purpose": "Clear all embedding cache entries."
        },
        {
          "type": "class",
          "name": "IAECComposeRequest",
          "purpose": "Request schema for IAEC composition (v3.0).",
          "methods": []
        },
        {
          "type": "class",
          "name": "TemporalSignatureResponse",
          "purpose": "Temporal signature for drift control.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyEncodingResponse",
          "purpose": "Policy slot encoding.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IAECComposeResponse",
          "purpose": "Response schema for IAEC composition (v3.2).",
          "methods": []
        },
        {
          "type": "class",
          "name": "IAECDecomposeRequest",
          "purpose": "Request schema for IAEC decomposition.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IAECDecomposeResponse",
          "purpose": "Response schema for IAEC decomposition (v3.0).",
          "methods": []
        },
        {
          "type": "class",
          "name": "IAECVerifyRequest",
          "purpose": "Request for integrity verification.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IAECVerifyResponse",
          "purpose": "Response for integrity verification.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "compose_embedding",
          "purpose": "Compose an instruction-aware embedding using IAEC v3.0."
        },
        {
          "type": "async_function",
          "name": "decompose_embedding",
          "purpose": "Decompose an IAEC embedding back into its constituent slots (v3.0)."
        },
        {
          "type": "async_function",
          "name": "get_iaec_instructions",
          "purpose": "Get available IAEC instruction types and their weights."
        },
        {
          "type": "async_function",
          "name": "get_iaec_segment_info",
          "purpose": "Get IAEC v3.0 segmentation configuration."
        },
        {
          "type": "async_function",
          "name": "check_mismatch",
          "purpose": "Check instruction-query semantic compatibility (v3.1)."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/quota"
        },
        {
          "method": "GET",
          "path": "/config"
        },
        {
          "method": "GET",
          "path": "/health"
        },
        {
          "method": "GET",
          "path": "/cache/stats"
        },
        {
          "method": "DELETE",
          "path": "/cache"
        },
        {
          "method": "POST",
          "path": "/compose"
        },
        {
          "method": "POST",
          "path": "/decompose"
        },
        {
          "method": "GET",
          "path": "/iaec/instructions"
        },
        {
          "method": "GET",
          "path": "/iaec/segment-info"
        },
        {
          "method": "POST",
          "path": "/iaec/check-mismatch"
        }
      ]
    },
    {
      "file": "api/feedback.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "FeedbackSummaryResponse",
          "purpose": "Summary of a feedback record.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FeedbackListResponse",
          "purpose": "Paginated list of feedback records.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FeedbackDetailResponse",
          "purpose": "Detailed feedback record.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "list_feedback",
          "purpose": "List pattern feedback records (PB-S3)."
        },
        {
          "type": "async_function",
          "name": "get_feedback",
          "purpose": "Get detailed feedback record by ID (PB-S3)."
        },
        {
          "type": "async_function",
          "name": "get_feedback_stats",
          "purpose": "Get feedback statistics summary (PB-S3)."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/{feedback_id}"
        },
        {
          "method": "GET",
          "path": "/stats/summary"
        }
      ]
    },
    {
      "file": "api/founder_actions.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "check_rate_limit",
          "purpose": "Check if founder has exceeded rate limit. Returns True if allowed."
        },
        {
          "type": "function",
          "name": "check_duplicate_action",
          "purpose": "Check if same action is already active on target."
        },
        {
          "type": "function",
          "name": "check_mutual_exclusion",
          "purpose": "Check for mutually exclusive active actions."
        },
        {
          "type": "function",
          "name": "get_target_name",
          "purpose": "Get display name for target."
        },
        {
          "type": "function",
          "name": "validate_target_exists",
          "purpose": "Validate that target exists."
        },
        {
          "type": "function",
          "name": "apply_action_effect",
          "purpose": "Apply the actual effect of an action."
        },
        {
          "type": "async_function",
          "name": "execute_action",
          "purpose": "Core action execution logic shared by all action endpoints."
        },
        {
          "type": "async_function",
          "name": "freeze_tenant",
          "purpose": "Freeze tenant - immediately block all API calls."
        },
        {
          "type": "async_function",
          "name": "throttle_tenant",
          "purpose": "Throttle tenant - reduce rate limit to 10%."
        },
        {
          "type": "async_function",
          "name": "freeze_api_key",
          "purpose": "Freeze API key - immediately revoke."
        },
        {
          "type": "async_function",
          "name": "override_incident",
          "purpose": "Override incident - mark as false positive. NOT REVERSIBLE."
        },
        {
          "type": "async_function",
          "name": "execute_reversal",
          "purpose": "Core reversal execution logic."
        },
        {
          "type": "async_function",
          "name": "unfreeze_tenant",
          "purpose": "Unfreeze tenant - restore access."
        },
        {
          "type": "async_function",
          "name": "unthrottle_tenant",
          "purpose": "Unthrottle tenant - restore rate limit."
        },
        {
          "type": "async_function",
          "name": "unfreeze_api_key",
          "purpose": "Unfreeze API key - restore access."
        },
        {
          "type": "async_function",
          "name": "get_audit_trail",
          "purpose": "Get founder action audit trail."
        },
        {
          "type": "async_function",
          "name": "get_audit_record",
          "purpose": "Get single audit record."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/freeze-tenant"
        },
        {
          "method": "POST",
          "path": "/throttle-tenant"
        },
        {
          "method": "POST",
          "path": "/freeze-api-key"
        },
        {
          "method": "POST",
          "path": "/override-incident"
        },
        {
          "method": "POST",
          "path": "/unfreeze-tenant"
        },
        {
          "method": "POST",
          "path": "/unthrottle-tenant"
        },
        {
          "method": "POST",
          "path": "/unfreeze-api-key"
        },
        {
          "method": "GET",
          "path": "/audit"
        },
        {
          "method": "GET",
          "path": "/audit/{action_id}"
        }
      ],
      "calls": {
        "L3": [
          "app.auth.console_auth"
        ],
        "L4": [
          "app.contracts.ops",
          "app.services.founder_action_write_service"
        ],
        "L6": [
          "app.db"
        ]
      }
    },
    {
      "file": "api/founder_timeline.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "DecisionRecordView",
          "purpose": "Raw decision record - all fields exposed to founder.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TimelineEntry",
          "purpose": "Single entry in the timeline - could be decision, pre-run, or outcome.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RunTimeline",
          "purpose": "Complete timeline for a run - raw, chronological.",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_db_url",
          "purpose": "Get database URL from environment."
        },
        {
          "type": "function",
          "name": "fetch_run_data",
          "purpose": "Fetch run data for PRE-RUN and OUTCOME records."
        },
        {
          "type": "function",
          "name": "fetch_decision_records",
          "purpose": "Fetch all decision records for a run."
        },
        {
          "type": "function",
          "name": "fetch_all_decision_records",
          "purpose": "Fetch decision records with optional filtering."
        },
        {
          "type": "async_function",
          "name": "get_run_timeline",
          "purpose": "Get complete timeline for a run."
        },
        {
          "type": "async_function",
          "name": "list_decision_records",
          "purpose": "List all decision records."
        },
        {
          "type": "async_function",
          "name": "get_decision_record",
          "purpose": "Get a single decision record by ID."
        },
        {
          "type": "async_function",
          "name": "count_decision_records",
          "purpose": "Count decision records."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/run/{run_id}"
        },
        {
          "method": "GET",
          "path": "/decisions"
        },
        {
          "method": "GET",
          "path": "/decisions/{decision_id}"
        },
        {
          "method": "GET",
          "path": "/count"
        }
      ]
    },
    {
      "file": "api/guard.py",
      "layer": "L2",
      "layer_source": "declared",
      "components": [
        {
          "type": "class",
          "name": "GuardStatus",
          "purpose": "Protection status response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TodaySnapshot",
          "purpose": "Today's metrics snapshot.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentSummary",
          "purpose": "Incident list item.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentEventResponse",
          "purpose": "Timeline event.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentDetailResponse",
          "purpose": "Full incident detail with timeline.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ApiKeyResponse",
          "purpose": "API key for customer console.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PaginatedResponse",
          "purpose": "Generic paginated response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GuardrailConfig",
          "purpose": "Guardrail configuration for settings page.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TenantSettings",
          "purpose": "Read-only tenant settings.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyDecision",
          "purpose": "Policy decision for replay.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayCallSnapshot",
          "purpose": "Call snapshot for replay comparison.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayCertificate",
          "purpose": "M23: Cryptographic certificate proving deterministic replay.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayResult",
          "purpose": "Replay result response.",
          "methods": []
        },
        {
          "type": "function",
          "name": "utc_now",
          "purpose": null
        },
        {
          "type": "function",
          "name": "get_tenant_from_auth",
          "purpose": "Get tenant or raise 404."
        },
        {
          "type": "async_function",
          "name": "get_guard_status",
          "purpose": "Get protection status - \"Am I safe right now?\""
        },
        {
          "type": "async_function",
          "name": "get_today_snapshot",
          "purpose": "Get today's metrics - \"What did it cost/save me?\""
        },
        {
          "type": "async_function",
          "name": "activate_killswitch",
          "purpose": "Stop all traffic - Emergency kill switch."
        },
        {
          "type": "async_function",
          "name": "deactivate_killswitch",
          "purpose": "Resume traffic - Deactivate kill switch."
        },
        {
          "type": "async_function",
          "name": "list_incidents",
          "purpose": "List incidents - \"What did you stop for me?\""
        },
        {
          "type": "async_function",
          "name": "get_incident_detail",
          "purpose": "Get incident detail with timeline."
        },
        {
          "type": "async_function",
          "name": "acknowledge_incident",
          "purpose": "Acknowledge an incident."
        },
        {
          "type": "async_function",
          "name": "resolve_incident",
          "purpose": "Resolve an incident."
        },
        {
          "type": "async_function",
          "name": "get_customer_incident_narrative",
          "purpose": "GET /guard/incidents/{id}/narrative"
        },
        {
          "type": "async_function",
          "name": "replay_call",
          "purpose": "Replay a call - Trust builder."
        },
        {
          "type": "async_function",
          "name": "list_api_keys",
          "purpose": "List API keys with status."
        },
        {
          "type": "async_function",
          "name": "freeze_api_key",
          "purpose": "Freeze an API key."
        },
        {
          "type": "async_function",
          "name": "unfreeze_api_key",
          "purpose": "Unfreeze an API key."
        },
        {
          "type": "async_function",
          "name": "get_settings",
          "purpose": "Get read-only settings."
        },
        {
          "type": "class",
          "name": "IncidentSearchRequest",
          "purpose": "Search incidents with filters.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentSearchResult",
          "purpose": "Search result item matching component map spec.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentSearchResponse",
          "purpose": "Search response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TimelineEvent",
          "purpose": "Decision timeline event - step by step policy evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyEvaluation",
          "purpose": "Individual policy evaluation result.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CARERoutingInfo",
          "purpose": "M17 CARE routing information for decision timeline.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FailureCatalogMatch",
          "purpose": "M9 Failure Catalog match information.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DecisionTimelineResponse",
          "purpose": "Full decision timeline for an incident/call.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "search_incidents",
          "purpose": "Search incidents with filters - M23 component map spec."
        },
        {
          "type": "async_function",
          "name": "get_decision_timeline",
          "purpose": "Get decision timeline - M23 component map spec."
        },
        {
          "type": "class",
          "name": "EvidenceExportRequest",
          "purpose": "Request for evidence report export.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "export_incident_evidence",
          "purpose": "Export incident as a legal-grade PDF evidence report."
        },
        {
          "type": "class",
          "name": "OnboardingVerifyRequest",
          "purpose": "Request for onboarding safety verification.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OnboardingVerifyResponse",
          "purpose": "Response from onboarding verification.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "onboarding_verify",
          "purpose": "REAL safety verification for onboarding."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/status"
        },
        {
          "method": "GET",
          "path": "/snapshot/today"
        },
        {
          "method": "POST",
          "path": "/killswitch/activate"
        },
        {
          "method": "POST",
          "path": "/killswitch/deactivate"
        },
        {
          "method": "GET",
          "path": "/incidents"
        },
        {
          "method": "GET",
          "path": "/incidents/{incident_id}"
        },
        {
          "method": "POST",
          "path": "/incidents/{incident_id}/acknowledge"
        },
        {
          "method": "POST",
          "path": "/incidents/{incident_id}/resolve"
        },
        {
          "method": "GET",
          "path": "/incidents/{incident_id}/narrative"
        },
        {
          "method": "POST",
          "path": "/replay/{call_id}"
        },
        {
          "method": "GET",
          "path": "/keys"
        },
        {
          "method": "POST",
          "path": "/keys/{key_id}/freeze"
        },
        {
          "method": "POST",
          "path": "/keys/{key_id}/unfreeze"
        },
        {
          "method": "GET",
          "path": "/settings"
        },
        {
          "method": "POST",
          "path": "/incidents/search"
        },
        {
          "method": "GET",
          "path": "/incidents/{incident_id}/timeline"
        },
        {
          "method": "POST",
          "path": "/incidents/{incident_id}/export"
        },
        {
          "method": "POST",
          "path": "/onboarding/verify"
        }
      ],
      "calls": {
        "L3": [
          "app.auth.console_auth"
        ],
        "L4": [
          "app.contracts.guard",
          "app.services.certificate",
          "app.services.guard_write_service",
          "app.services.replay_determinism",
          "app.services.replay_determinism",
          "app.services.evidence_report",
          "app.policy.validators"
        ],
        "L5": [
          "app.runtime.failure_catalog"
        ],
        "L6": [
          "app.db",
          "app.models.killswitch",
          "app.models.tenant",
          "app.utils.guard_cache",
          "app.models.killswitch"
        ]
      }
    },
    {
      "file": "api/health.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "update_replay_hash",
          "purpose": "Update the determinism state after a replay test."
        },
        {
          "type": "function",
          "name": "report_drift",
          "purpose": "Report a determinism drift."
        },
        {
          "type": "async_function",
          "name": "health_check",
          "purpose": "Basic health check endpoint."
        },
        {
          "type": "async_function",
          "name": "readiness_check",
          "purpose": "Kubernetes readiness probe."
        },
        {
          "type": "async_function",
          "name": "determinism_status",
          "purpose": "Determinism status endpoint."
        },
        {
          "type": "async_function",
          "name": "adapter_status",
          "purpose": "LLM adapter availability status."
        },
        {
          "type": "async_function",
          "name": "skills_status",
          "purpose": "Skill registry status."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/health"
        },
        {
          "method": "GET",
          "path": "/health/ready"
        },
        {
          "method": "GET",
          "path": "/health/determinism"
        },
        {
          "method": "GET",
          "path": "/health/adapters"
        },
        {
          "method": "GET",
          "path": "/health/skills"
        }
      ],
      "calls": {
        "L4": [
          "app.skills",
          "app.skills.llm_invoke_v2",
          "app.skills"
        ]
      }
    },
    {
      "file": "api/integration.py",
      "layer": "L2",
      "layer_source": "declared",
      "purpose": "Loop status, checkpoints, graduation, and prevention timeline",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "get_tenant_id",
          "purpose": "Get tenant ID from query parameter."
        },
        {
          "type": "function",
          "name": "get_current_user",
          "purpose": "Get current user from query parameter (optional)."
        },
        {
          "type": "class",
          "name": "LoopStatusResponse",
          "purpose": "Response for loop status endpoint.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StageDetail",
          "purpose": "Detail for a single stage.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CheckpointResponse",
          "purpose": "Response for human checkpoint.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ResolveCheckpointRequest",
          "purpose": "Request to resolve a checkpoint.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IntegrationStatsResponse",
          "purpose": "Statistics for integration loop.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RetryStageRequest",
          "purpose": "Request to retry a failed stage.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RevertLoopRequest",
          "purpose": "Request to revert a loop.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "get_loop_status",
          "purpose": "Get current loop status for an incident."
        },
        {
          "type": "async_function",
          "name": "get_loop_stages",
          "purpose": "Get detailed stage information for a loop."
        },
        {
          "type": "async_function",
          "name": "stream_loop_status",
          "purpose": "SSE endpoint for live loop status updates."
        },
        {
          "type": "async_function",
          "name": "retry_loop_stage",
          "purpose": "Retry a failed loop stage."
        },
        {
          "type": "async_function",
          "name": "revert_loop",
          "purpose": "Revert all changes made by a loop."
        },
        {
          "type": "async_function",
          "name": "list_pending_checkpoints",
          "purpose": "List all pending human checkpoints for the tenant."
        },
        {
          "type": "async_function",
          "name": "get_checkpoint",
          "purpose": "Get details of a specific checkpoint."
        },
        {
          "type": "async_function",
          "name": "resolve_checkpoint",
          "purpose": "Resolve a pending checkpoint."
        },
        {
          "type": "async_function",
          "name": "get_integration_stats",
          "purpose": "Get integration loop statistics for the specified period."
        },
        {
          "type": "async_function",
          "name": "get_loop_narrative",
          "purpose": "Get narrative artifacts for an incident loop."
        },
        {
          "type": "class",
          "name": "GateEvidenceResponse",
          "purpose": "Evidence for a graduation gate.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CapabilityStatus",
          "purpose": "Status of a capability gate.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SimulationStatus",
          "purpose": "Simulation mode status - separate from real graduation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "HardenedGraduationResponse",
          "purpose": "Hardened graduation status response.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "get_graduation_status",
          "purpose": "Get M25 graduation status (HARDENED)."
        },
        {
          "type": "class",
          "name": "SimulatePreventionRequest",
          "purpose": "Request to simulate a prevention event for demo/testing.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "simulate_prevention",
          "purpose": "Simulate a prevention event for demo/testing purposes."
        },
        {
          "type": "class",
          "name": "SimulateRegretRequest",
          "purpose": "Request to simulate a regret event for demo/testing.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "simulate_regret",
          "purpose": "Simulate a regret event for demo/testing purposes."
        },
        {
          "type": "async_function",
          "name": "simulate_timeline_view",
          "purpose": "Simulate viewing a prevention timeline for Gate 3."
        },
        {
          "type": "async_function",
          "name": "record_timeline_view",
          "purpose": "Record a REAL timeline view for Gate 3 graduation."
        },
        {
          "type": "async_function",
          "name": "trigger_graduation_re_evaluation",
          "purpose": "Trigger a re-evaluation of graduation status."
        },
        {
          "type": "class",
          "name": "TimelineEventResponse",
          "purpose": "A single event in the prevention timeline.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PreventionTimelineResponse",
          "purpose": "Response for prevention timeline endpoint.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "get_prevention_timeline",
          "purpose": "Get the prevention timeline for an incident."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/loop/{incident_id}"
        },
        {
          "method": "GET",
          "path": "/loop/{incident_id}/stages"
        },
        {
          "method": "GET",
          "path": "/loop/{incident_id}/stream"
        },
        {
          "method": "POST",
          "path": "/loop/{incident_id}/retry"
        },
        {
          "method": "POST",
          "path": "/loop/{incident_id}/revert"
        },
        {
          "method": "GET",
          "path": "/checkpoints"
        },
        {
          "method": "GET",
          "path": "/checkpoints/{checkpoint_id}"
        },
        {
          "method": "POST",
          "path": "/checkpoints/{checkpoint_id}/resolve"
        },
        {
          "method": "GET",
          "path": "/stats"
        },
        {
          "method": "GET",
          "path": "/loop/{incident_id}/narrative"
        },
        {
          "method": "GET",
          "path": "/graduation"
        },
        {
          "method": "POST",
          "path": "/graduation/simulate/prevention"
        },
        {
          "method": "POST",
          "path": "/graduation/simulate/regret"
        },
        {
          "method": "POST",
          "path": "/graduation/simulate/timeline-view"
        },
        {
          "method": "POST",
          "path": "/graduation/record-view"
        },
        {
          "method": "POST",
          "path": "/graduation/re-evaluate"
        },
        {
          "method": "GET",
          "path": "/timeline/{incident_id}"
        }
      ],
      "calls": {
        "L6": [
          "app.db",
          "app.db",
          "app.db",
          "app.db",
          "app.db",
          "app.db",
          "app.db",
          "app.db",
          "app.db",
          "app.db"
        ],
        "external": [
          "app.integrations.events",
          "app.integrations",
          "app.integrations",
          "app.integrations",
          "app.integrations",
          "app.integrations",
          "app.integrations",
          "app.integrations.graduation_engine",
          "app.integrations.graduation_engine",
          "app.integrations",
          "app.integrations"
        ]
      }
    },
    {
      "file": "api/legacy_routes.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "gone_response",
          "purpose": "Return a 410 Gone response with migration guidance."
        },
        {
          "type": "async_function",
          "name": "legacy_dashboard",
          "purpose": "410 Gone - Dashboard is not available for MVP customers."
        },
        {
          "type": "async_function",
          "name": "legacy_operator",
          "purpose": "410 Gone - Operator console merged into /ops/*."
        },
        {
          "type": "async_function",
          "name": "legacy_demo",
          "purpose": "410 Gone - Demo/simulation endpoints removed."
        },
        {
          "type": "async_function",
          "name": "legacy_simulation",
          "purpose": "410 Gone - Simulation endpoints removed."
        },
        {
          "type": "async_function",
          "name": "legacy_api_operator",
          "purpose": "410 Gone - /api/v1/operator/* merged into /ops/*."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/dashboard"
        },
        {
          "method": "POST",
          "path": "/dashboard"
        },
        {
          "method": "PUT",
          "path": "/dashboard"
        },
        {
          "method": "DELETE",
          "path": "/dashboard"
        },
        {
          "method": "GET",
          "path": "/operator"
        },
        {
          "method": "POST",
          "path": "/operator"
        },
        {
          "method": "PUT",
          "path": "/operator"
        },
        {
          "method": "DELETE",
          "path": "/operator"
        },
        {
          "method": "GET",
          "path": "/operator/{path:path}"
        },
        {
          "method": "POST",
          "path": "/operator/{path:path}"
        },
        {
          "method": "PUT",
          "path": "/operator/{path:path}"
        },
        {
          "method": "DELETE",
          "path": "/operator/{path:path}"
        },
        {
          "method": "GET",
          "path": "/demo"
        },
        {
          "method": "POST",
          "path": "/demo"
        },
        {
          "method": "GET",
          "path": "/demo/{path:path}"
        },
        {
          "method": "POST",
          "path": "/demo/{path:path}"
        },
        {
          "method": "GET",
          "path": "/simulation"
        },
        {
          "method": "POST",
          "path": "/simulation"
        },
        {
          "method": "GET",
          "path": "/simulation/{path:path}"
        },
        {
          "method": "POST",
          "path": "/simulation/{path:path}"
        },
        {
          "method": "GET",
          "path": "/api/v1/operator"
        },
        {
          "method": "GET",
          "path": "/api/v1/operator/{path:path}"
        },
        {
          "method": "POST",
          "path": "/api/v1/operator/{path:path}"
        }
      ]
    },
    {
      "file": "api/memory_pins.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "MemoryPinCreate",
          "purpose": "Schema for creating/upserting a memory pin.",
          "methods": [
            "validate_key"
          ]
        },
        {
          "type": "class",
          "name": "MemoryPinResponse",
          "purpose": "Schema for memory pin response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "MemoryPinListResponse",
          "purpose": "Schema for listing memory pins.",
          "methods": []
        },
        {
          "type": "class",
          "name": "MemoryPinDeleteResponse",
          "purpose": "Schema for delete response.",
          "methods": []
        },
        {
          "type": "function",
          "name": "check_feature_enabled",
          "purpose": "Check if memory pins feature is enabled."
        },
        {
          "type": "function",
          "name": "extract_tenant_from_request",
          "purpose": "Extract tenant ID from request or parameter."
        },
        {
          "type": "function",
          "name": "write_memory_audit",
          "purpose": "Write an audit entry to system.memory_audit."
        },
        {
          "type": "async_function",
          "name": "create_or_upsert_pin",
          "purpose": "Create or upsert a memory pin."
        },
        {
          "type": "async_function",
          "name": "get_pin",
          "purpose": "Get a memory pin by key."
        },
        {
          "type": "async_function",
          "name": "list_pins",
          "purpose": "List memory pins for a tenant."
        },
        {
          "type": "async_function",
          "name": "delete_pin",
          "purpose": "Delete a memory pin by key."
        },
        {
          "type": "async_function",
          "name": "cleanup_expired_pins",
          "purpose": "Clean up expired memory pins."
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/pins"
        },
        {
          "method": "GET",
          "path": "/pins/{key}"
        },
        {
          "method": "GET",
          "path": "/pins"
        },
        {
          "method": "DELETE",
          "path": "/pins/{key}"
        },
        {
          "method": "POST",
          "path": "/pins/cleanup"
        }
      ]
    },
    {
      "file": "api/onboarding.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "get_redis",
          "purpose": "Get Redis client singleton."
        },
        {
          "type": "function",
          "name": "utc_now",
          "purpose": null
        },
        {
          "type": "class",
          "name": "OAuthLoginRequest",
          "purpose": "OAuth login request (optional redirect_url).",
          "methods": []
        },
        {
          "type": "class",
          "name": "OAuthLoginResponse",
          "purpose": "OAuth login response with authorization URL.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EmailSignupRequest",
          "purpose": "Email signup request.",
          "methods": [
            "validate_email"
          ]
        },
        {
          "type": "class",
          "name": "EmailSignupResponse",
          "purpose": "Email signup response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EmailVerifyRequest",
          "purpose": "Email verification request.",
          "methods": [
            "validate_email"
          ]
        },
        {
          "type": "class",
          "name": "AuthResponse",
          "purpose": "Authentication response with tokens.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RefreshRequest",
          "purpose": "Token refresh request.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LogoutRequest",
          "purpose": "Logout request.",
          "methods": []
        },
        {
          "type": "function",
          "name": "create_tokens",
          "purpose": "Create access and refresh tokens."
        },
        {
          "type": "function",
          "name": "verify_token",
          "purpose": "Verify and decode a JWT token."
        },
        {
          "type": "function",
          "name": "revoke_refresh_token",
          "purpose": "Revoke a refresh token."
        },
        {
          "type": "function",
          "name": "get_or_create_user_from_oauth",
          "purpose": "Get or create user from OAuth provider info."
        },
        {
          "type": "function",
          "name": "get_or_create_user_from_email",
          "purpose": "Get or create user from email verification."
        },
        {
          "type": "function",
          "name": "create_default_tenant_for_user",
          "purpose": "Create a default personal tenant for a new user."
        },
        {
          "type": "function",
          "name": "user_to_dict",
          "purpose": "Convert user to dict for response."
        },
        {
          "type": "async_function",
          "name": "login_google",
          "purpose": "Initiate Google OAuth login flow."
        },
        {
          "type": "async_function",
          "name": "callback_google",
          "purpose": "Google OAuth callback handler."
        },
        {
          "type": "async_function",
          "name": "login_azure",
          "purpose": "Initiate Azure AD OAuth login flow."
        },
        {
          "type": "async_function",
          "name": "callback_azure",
          "purpose": "Azure AD OAuth callback handler."
        },
        {
          "type": "async_function",
          "name": "signup_email",
          "purpose": "Initiate email-based signup."
        },
        {
          "type": "async_function",
          "name": "verify_email",
          "purpose": "Verify email OTP and complete signup."
        },
        {
          "type": "async_function",
          "name": "refresh_token",
          "purpose": "Refresh access token using refresh token."
        },
        {
          "type": "async_function",
          "name": "logout",
          "purpose": "Logout and invalidate refresh token."
        },
        {
          "type": "async_function",
          "name": "get_current_user",
          "purpose": "Get current authenticated user from Authorization header."
        },
        {
          "type": "async_function",
          "name": "get_auth_providers",
          "purpose": "Get available authentication providers."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/login/google"
        },
        {
          "method": "GET",
          "path": "/callback/google"
        },
        {
          "method": "POST",
          "path": "/login/azure"
        },
        {
          "method": "GET",
          "path": "/callback/azure"
        },
        {
          "method": "POST",
          "path": "/signup/email"
        },
        {
          "method": "POST",
          "path": "/verify/email"
        },
        {
          "method": "POST",
          "path": "/refresh"
        },
        {
          "method": "POST",
          "path": "/logout"
        },
        {
          "method": "GET",
          "path": "/me"
        },
        {
          "method": "GET",
          "path": "/providers"
        }
      ]
    },
    {
      "file": "api/ops.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "cache_get",
          "purpose": "Get cached value if Redis is available."
        },
        {
          "type": "function",
          "name": "cache_set",
          "purpose": "Set cached value if Redis is available."
        },
        {
          "type": "class",
          "name": "SystemPulse",
          "purpose": "System health at a glance.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerSegment",
          "purpose": "Customer intelligence profile.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StickinessByFeature",
          "purpose": "Which feature creates stickiness.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentPattern",
          "purpose": "Failure pattern analysis.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EstimationBasis",
          "purpose": "PIN-254 Phase C Fix (C3 Partial Truth): Explicit disclosure of estimation assumptions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RevenueRisk",
          "purpose": "Revenue and risk metrics.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderIntervention",
          "purpose": "Phase-2: Suggested founder action for at-risk customer.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerAtRisk",
          "purpose": "Phase-2.1: At-risk customer with intervention suggestions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "InfraLimits",
          "purpose": "Infrastructure limits and capacity.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsEvent",
          "purpose": "Single ops event from event stream.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsEventListResponse",
          "purpose": "Response for /ops/events endpoint.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsJobResult",
          "purpose": "Response for /ops/jobs/* background job endpoints.",
          "methods": []
        },
        {
          "type": "function",
          "name": "utc_now",
          "purpose": null
        },
        {
          "type": "function",
          "name": "get_window",
          "purpose": null
        },
        {
          "type": "function",
          "name": "exec_sql",
          "purpose": "Execute raw SQL with parameters using SQLAlchemy's execute method."
        },
        {
          "type": "async_function",
          "name": "get_system_pulse",
          "purpose": "System Pulse - \"Is my business healthy right now?\""
        },
        {
          "type": "async_function",
          "name": "get_customer_segments",
          "purpose": "Customer Intelligence - All tenant profiles with stickiness and risk."
        },
        {
          "type": "function",
          "name": "generate_interventions",
          "purpose": "Generate founder intervention suggestions based on risk signals."
        },
        {
          "type": "async_function",
          "name": "get_customers_at_risk",
          "purpose": "Customers At Risk - Phase-2 Founder Intelligence."
        },
        {
          "type": "async_function",
          "name": "get_customer_detail",
          "purpose": "Get detailed customer profile for a specific tenant."
        },
        {
          "type": "class",
          "name": "PlaybookAction",
          "purpose": "A single step in a founder playbook.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PlaybookDetail",
          "purpose": "A founder playbook with signal \u2192 action mapping.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "get_founder_playbooks",
          "purpose": "Founder Playbooks - Signal \u2192 Action Matrix."
        },
        {
          "type": "async_function",
          "name": "get_playbook_detail",
          "purpose": "Get a specific founder playbook by ID."
        },
        {
          "type": "async_function",
          "name": "get_incident_patterns",
          "purpose": "Incident Intelligence - What's breaking and is it systemic?"
        },
        {
          "type": "async_function",
          "name": "get_infra_incident_summary",
          "purpose": "GET /ops/incidents/infra-summary"
        },
        {
          "type": "async_function",
          "name": "get_founder_incident_detail",
          "purpose": "GET /ops/incidents/{incident_id}"
        },
        {
          "type": "async_function",
          "name": "get_founder_incidents",
          "purpose": "GET /ops/incidents"
        },
        {
          "type": "async_function",
          "name": "get_stickiness_by_feature",
          "purpose": "Product Stickiness - Which feature actually keeps users?"
        },
        {
          "type": "async_function",
          "name": "get_revenue_risk",
          "purpose": "Revenue & Risk - Am I making money safely?"
        },
        {
          "type": "async_function",
          "name": "get_infra_limits",
          "purpose": "Infra & Limits - What breaks first if I grow?"
        },
        {
          "type": "async_function",
          "name": "get_event_stream",
          "purpose": "Event Stream - Raw events for debugging and analysis."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/pulse"
        },
        {
          "method": "GET",
          "path": "/customers"
        },
        {
          "method": "GET",
          "path": "/customers/at-risk"
        },
        {
          "method": "GET",
          "path": "/customers/{tenant_id}"
        },
        {
          "method": "GET",
          "path": "/playbooks"
        },
        {
          "method": "GET",
          "path": "/playbooks/{playbook_id}"
        },
        {
          "method": "GET",
          "path": "/incidents/patterns"
        },
        {
          "method": "GET",
          "path": "/incidents/infra-summary"
        },
        {
          "method": "GET",
          "path": "/incidents/{incident_id}"
        },
        {
          "method": "GET",
          "path": "/incidents"
        },
        {
          "method": "GET",
          "path": "/stickiness"
        },
        {
          "method": "GET",
          "path": "/revenue"
        },
        {
          "method": "GET",
          "path": "/infra"
        },
        {
          "method": "GET",
          "path": "/events"
        }
      ],
      "calls": {
        "L3": [
          "app.auth.console_auth",
          "app.adapters.founder_ops_adapter"
        ],
        "L4": [
          "app.contracts.ops",
          "app.services.ops_incident_service"
        ],
        "L6": [
          "app.db",
          "app.models.killswitch"
        ]
      }
    },
    {
      "file": "api/policy.py",
      "layer": "L2",
      "layer_source": "declared",
      "purpose": "Policy sandbox evaluation and approval workflow management",
      "temporal": {
        "trigger": "api",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "PolicyType",
          "purpose": "Types of policies that can be evaluated.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ApprovalStatus",
          "purpose": "Status of an approval request.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyEvalRequest",
          "purpose": "Request for policy sandbox evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyEvalResponse",
          "purpose": "Response from policy sandbox evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ApprovalRequestCreate",
          "purpose": "Request to create an approval request.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ApprovalRequestResponse",
          "purpose": "Response when creating an approval request.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ApprovalAction",
          "purpose": "Action to approve or reject a request.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ApprovalStatusResponse",
          "purpose": "Full status of an approval request.",
          "methods": []
        },
        {
          "type": "function",
          "name": "verify_webhook_signature",
          "purpose": "Verify webhook signature with version support for rotation."
        },
        {
          "type": "async_function",
          "name": "evaluate_policy",
          "purpose": "Sandbox evaluation of policy for a skill execution."
        },
        {
          "type": "async_function",
          "name": "create_approval_request",
          "purpose": "Create a new approval request (persisted to DB)."
        },
        {
          "type": "async_function",
          "name": "get_approval_request",
          "purpose": "Get the current status of an approval request."
        },
        {
          "type": "async_function",
          "name": "approve_request",
          "purpose": "Approve an approval request."
        },
        {
          "type": "async_function",
          "name": "reject_request",
          "purpose": "Reject an approval request."
        },
        {
          "type": "async_function",
          "name": "list_approval_requests",
          "purpose": "List approval requests with optional filtering."
        },
        {
          "type": "async_function",
          "name": "run_escalation_check",
          "purpose": "Check for pending requests that need escalation."
        },
        {
          "type": "function",
          "name": "run_escalation_task",
          "purpose": "Entry point for scheduled escalation check."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/eval"
        },
        {
          "method": "POST",
          "path": "/requests"
        },
        {
          "method": "GET",
          "path": "/requests/{request_id}"
        },
        {
          "method": "POST",
          "path": "/requests/{request_id}/approve"
        },
        {
          "method": "POST",
          "path": "/requests/{request_id}/reject"
        },
        {
          "method": "GET",
          "path": "/requests"
        }
      ],
      "calls": {
        "L3": [
          "app.auth.tenant_auth",
          "app.auth.tier_gating",
          "app.adapters.policy_adapter",
          "app.auth.rbac"
        ],
        "L6": [
          "app.db_async",
          "app.db",
          "app.db",
          "app.db",
          "app.db",
          "app.db",
          "app.db",
          "app.db_async",
          "app.utils.rate_limiter",
          "app.db"
        ]
      }
    },
    {
      "file": "api/policy_layer.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "EvaluateRequest",
          "purpose": "Request to evaluate an action against policies.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SimulateRequest",
          "purpose": "Request to simulate policy evaluation (dry run).",
          "methods": []
        },
        {
          "type": "class",
          "name": "ViolationQuery",
          "purpose": "Query parameters for violations.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RiskCeilingUpdate",
          "purpose": "Update for a risk ceiling.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SafetyRuleUpdate",
          "purpose": "Update for a safety rule.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CooldownInfo",
          "purpose": "Information about an active cooldown.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyMetrics",
          "purpose": "Metrics from the policy engine.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "evaluate_action",
          "purpose": "Evaluate a proposed action against all applicable policies."
        },
        {
          "type": "async_function",
          "name": "simulate_evaluation",
          "purpose": "Simulate policy evaluation without side effects."
        },
        {
          "type": "async_function",
          "name": "get_policy_state",
          "purpose": "Get the current state of the policy layer."
        },
        {
          "type": "async_function",
          "name": "reload_policies",
          "purpose": "Hot-reload policies from database."
        },
        {
          "type": "async_function",
          "name": "list_violations",
          "purpose": "List policy violations with filtering."
        },
        {
          "type": "async_function",
          "name": "get_violation",
          "purpose": "Get a specific violation by ID."
        },
        {
          "type": "async_function",
          "name": "acknowledge_violation",
          "purpose": "Acknowledge a violation (mark as reviewed)."
        },
        {
          "type": "async_function",
          "name": "list_risk_ceilings",
          "purpose": "List all risk ceilings with current values."
        },
        {
          "type": "async_function",
          "name": "get_risk_ceiling",
          "purpose": "Get a specific risk ceiling with current utilization."
        },
        {
          "type": "async_function",
          "name": "update_risk_ceiling",
          "purpose": "Update a risk ceiling configuration."
        },
        {
          "type": "async_function",
          "name": "reset_risk_ceiling",
          "purpose": "Reset a risk ceiling's current value to 0."
        },
        {
          "type": "async_function",
          "name": "list_safety_rules",
          "purpose": "List all safety rules."
        },
        {
          "type": "async_function",
          "name": "update_safety_rule",
          "purpose": "Update a safety rule configuration."
        },
        {
          "type": "async_function",
          "name": "list_ethical_constraints",
          "purpose": "List all ethical constraints."
        },
        {
          "type": "async_function",
          "name": "list_active_cooldowns",
          "purpose": "List all active cooldowns."
        },
        {
          "type": "async_function",
          "name": "clear_cooldowns",
          "purpose": "Clear cooldowns for an agent."
        },
        {
          "type": "async_function",
          "name": "get_policy_metrics",
          "purpose": "Get policy engine metrics for the specified time window."
        },
        {
          "type": "async_function",
          "name": "evaluate_batch",
          "purpose": "Evaluate multiple actions in a single call."
        },
        {
          "type": "class",
          "name": "CreateVersionRequest",
          "purpose": "Request to create a new policy version.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RollbackRequest",
          "purpose": "Request to rollback to a previous version.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "list_policy_versions",
          "purpose": "List all policy versions."
        },
        {
          "type": "async_function",
          "name": "get_current_version",
          "purpose": "Get the currently active policy version."
        },
        {
          "type": "async_function",
          "name": "create_policy_version",
          "purpose": "Create a new policy version snapshot."
        },
        {
          "type": "async_function",
          "name": "rollback_to_version",
          "purpose": "Rollback to a previous policy version."
        },
        {
          "type": "async_function",
          "name": "get_version_provenance",
          "purpose": "Get the provenance (change history) for a policy version."
        },
        {
          "type": "async_function",
          "name": "get_dependency_graph",
          "purpose": "Get the policy dependency graph."
        },
        {
          "type": "async_function",
          "name": "list_conflicts",
          "purpose": "List policy conflicts."
        },
        {
          "type": "class",
          "name": "ResolveConflictRequest",
          "purpose": "Request to resolve a policy conflict.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "resolve_conflict",
          "purpose": "Resolve a policy conflict."
        },
        {
          "type": "class",
          "name": "TemporalPolicyCreate",
          "purpose": "Request to create a temporal policy.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "list_temporal_policies",
          "purpose": "List temporal (sliding window) policies."
        },
        {
          "type": "async_function",
          "name": "create_temporal_policy",
          "purpose": "Create a new temporal policy."
        },
        {
          "type": "async_function",
          "name": "get_temporal_utilization",
          "purpose": "Get current utilization for a temporal policy."
        },
        {
          "type": "class",
          "name": "ContextAwareEvaluateRequest",
          "purpose": "Request for context-aware policy evaluation (GAP 4).",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "evaluate_with_context",
          "purpose": "Context-aware policy evaluation (GAP 4)."
        },
        {
          "type": "async_function",
          "name": "validate_dependency_dag",
          "purpose": "Validate that policy dependencies form a valid DAG."
        },
        {
          "type": "class",
          "name": "AddDependencyRequest",
          "purpose": "Request to add a policy dependency with DAG validation.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "add_dependency_with_dag_check",
          "purpose": "Add a policy dependency with DAG validation."
        },
        {
          "type": "async_function",
          "name": "get_evaluation_order",
          "purpose": "Get the topological evaluation order for policies."
        },
        {
          "type": "class",
          "name": "PruneTemporalMetricsRequest",
          "purpose": "Request to prune temporal metrics.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "prune_temporal_metrics",
          "purpose": "Prune and compact temporal metric events."
        },
        {
          "type": "async_function",
          "name": "get_temporal_storage_stats",
          "purpose": "Get storage statistics for temporal metrics."
        },
        {
          "type": "class",
          "name": "ActivateVersionRequest",
          "purpose": "Request to activate a policy version.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "activate_policy_version",
          "purpose": "Activate a policy version with pre-activation integrity checks."
        },
        {
          "type": "async_function",
          "name": "check_version_integrity",
          "purpose": "Run integrity checks on a version without activating."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/evaluate"
        },
        {
          "method": "POST",
          "path": "/simulate"
        },
        {
          "method": "GET",
          "path": "/state"
        },
        {
          "method": "POST",
          "path": "/reload"
        },
        {
          "method": "GET",
          "path": "/violations"
        },
        {
          "method": "GET",
          "path": "/violations/{violation_id}"
        },
        {
          "method": "POST",
          "path": "/violations/{violation_id}/acknowledge"
        },
        {
          "method": "GET",
          "path": "/risk-ceilings"
        },
        {
          "method": "GET",
          "path": "/risk-ceilings/{ceiling_id}"
        },
        {
          "method": "PATCH",
          "path": "/risk-ceilings/{ceiling_id}"
        },
        {
          "method": "POST",
          "path": "/risk-ceilings/{ceiling_id}/reset"
        },
        {
          "method": "GET",
          "path": "/safety-rules"
        },
        {
          "method": "PATCH",
          "path": "/safety-rules/{rule_id}"
        },
        {
          "method": "GET",
          "path": "/ethical-constraints"
        },
        {
          "method": "GET",
          "path": "/cooldowns"
        },
        {
          "method": "DELETE",
          "path": "/cooldowns/{agent_id}"
        },
        {
          "method": "GET",
          "path": "/metrics"
        },
        {
          "method": "POST",
          "path": "/evaluate/batch"
        },
        {
          "method": "GET",
          "path": "/versions"
        },
        {
          "method": "GET",
          "path": "/versions/current"
        },
        {
          "method": "POST",
          "path": "/versions"
        },
        {
          "method": "POST",
          "path": "/versions/rollback"
        },
        {
          "method": "GET",
          "path": "/versions/{version_id}/provenance"
        },
        {
          "method": "GET",
          "path": "/dependencies"
        },
        {
          "method": "GET",
          "path": "/conflicts"
        },
        {
          "method": "POST",
          "path": "/conflicts/{conflict_id}/resolve"
        },
        {
          "method": "GET",
          "path": "/temporal-policies"
        },
        {
          "method": "POST",
          "path": "/temporal-policies"
        },
        {
          "method": "GET",
          "path": "/temporal-policies/{policy_id}/utilization"
        },
        {
          "method": "POST",
          "path": "/evaluate/context-aware"
        },
        {
          "method": "GET",
          "path": "/dependencies/dag/validate"
        },
        {
          "method": "POST",
          "path": "/dependencies/add"
        },
        {
          "method": "GET",
          "path": "/dependencies/evaluation-order"
        },
        {
          "method": "POST",
          "path": "/temporal-metrics/prune"
        },
        {
          "method": "GET",
          "path": "/temporal-metrics/storage-stats"
        },
        {
          "method": "POST",
          "path": "/versions/activate"
        },
        {
          "method": "POST",
          "path": "/versions/{version_id}/check"
        }
      ],
      "calls": {
        "L4": [
          "app.policy",
          "app.policy"
        ],
        "L6": [
          "app.db_async"
        ]
      }
    },
    {
      "file": "api/policy_proposals.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "ProposalSummaryResponse",
          "purpose": "Summary of a policy proposal.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ProposalListResponse",
          "purpose": "Paginated list of policy proposals.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ProposalDetailResponse",
          "purpose": "Detailed policy proposal record.",
          "methods": []
        },
        {
          "type": "class",
          "name": "VersionResponse",
          "purpose": "Policy version record.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "list_proposals",
          "purpose": "List policy proposals (PB-S4)."
        },
        {
          "type": "async_function",
          "name": "get_proposal_stats",
          "purpose": "Get policy proposal statistics (PB-S4)."
        },
        {
          "type": "async_function",
          "name": "get_proposal",
          "purpose": "Get detailed policy proposal by ID (PB-S4)."
        },
        {
          "type": "async_function",
          "name": "list_proposal_versions",
          "purpose": "List all versions of a policy proposal (PB-S4)."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/stats/summary"
        },
        {
          "method": "GET",
          "path": "/{proposal_id}"
        },
        {
          "method": "GET",
          "path": "/{proposal_id}/versions"
        }
      ]
    },
    {
      "file": "api/predictions.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "PredictionSummaryResponse",
          "purpose": "Summary of a prediction event.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PredictionListResponse",
          "purpose": "Paginated list of predictions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PredictionDetailResponse",
          "purpose": "Detailed prediction event record.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "list_predictions",
          "purpose": "List prediction events (PB-S5)."
        },
        {
          "type": "async_function",
          "name": "get_prediction",
          "purpose": "Get detailed prediction by ID (PB-S5)."
        },
        {
          "type": "async_function",
          "name": "get_predictions_for_subject",
          "purpose": "Get all predictions for a specific subject (PB-S5)."
        },
        {
          "type": "async_function",
          "name": "get_prediction_stats",
          "purpose": "Get prediction statistics (PB-S5)."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/{prediction_id}"
        },
        {
          "method": "GET",
          "path": "/subject/{subject_type}/{subject_id}"
        },
        {
          "method": "GET",
          "path": "/stats/summary"
        }
      ]
    },
    {
      "file": "api/rbac_api.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "PolicyInfoResponse",
          "purpose": "Current policy information.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReloadResponse",
          "purpose": "Policy reload response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AuditEntry",
          "purpose": "Single audit log entry.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AuditResponse",
          "purpose": "Audit log query response.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "get_policy_info",
          "purpose": "Get current RBAC policy information."
        },
        {
          "type": "async_function",
          "name": "reload_policies",
          "purpose": "Hot-reload RBAC policies from file."
        },
        {
          "type": "async_function",
          "name": "get_permission_matrix",
          "purpose": "Get current permission matrix."
        },
        {
          "type": "async_function",
          "name": "query_audit_logs",
          "purpose": "Query RBAC audit logs."
        },
        {
          "type": "async_function",
          "name": "cleanup_audit_logs",
          "purpose": "Clean up old audit logs."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/info"
        },
        {
          "method": "POST",
          "path": "/reload"
        },
        {
          "method": "GET",
          "path": "/matrix"
        },
        {
          "method": "GET",
          "path": "/audit"
        },
        {
          "method": "POST",
          "path": "/audit/cleanup"
        }
      ]
    },
    {
      "file": "api/recovery.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "SuggestRequest",
          "purpose": "Request to generate recovery suggestion.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SuggestResponse",
          "purpose": "Response with recovery suggestion.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ApproveRequest",
          "purpose": "Request to approve/reject a recovery candidate.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CandidateResponse",
          "purpose": "Recovery candidate details.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CandidateListResponse",
          "purpose": "Response for candidates list endpoint.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CandidateUpdateRequest",
          "purpose": "Request to update a candidate.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EvaluateRequest",
          "purpose": "Request to evaluate rules without persisting.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EvaluateResponse",
          "purpose": "Response from rule evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ActionResponse",
          "purpose": "Recovery action from catalog.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ActionListResponse",
          "purpose": "Response for actions list endpoint.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CandidateDetailResponse",
          "purpose": "Detailed candidate response with provenance and inputs.",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_matcher",
          "purpose": "Get matcher instance."
        },
        {
          "type": "async_function",
          "name": "suggest_recovery",
          "purpose": "Generate recovery suggestion for a failure."
        },
        {
          "type": "async_function",
          "name": "list_candidates",
          "purpose": "List recovery candidates with optional status filter."
        },
        {
          "type": "async_function",
          "name": "approve_candidate",
          "purpose": "Approve or reject a recovery candidate."
        },
        {
          "type": "async_function",
          "name": "delete_candidate",
          "purpose": "Delete/revoke a recovery candidate (admin only)."
        },
        {
          "type": "async_function",
          "name": "get_recovery_stats",
          "purpose": "Get recovery suggestion statistics."
        },
        {
          "type": "async_function",
          "name": "get_candidate_detail",
          "purpose": "Get detailed information about a specific candidate."
        },
        {
          "type": "async_function",
          "name": "update_candidate",
          "purpose": "Update a candidate's execution status or selected action."
        },
        {
          "type": "async_function",
          "name": "list_actions",
          "purpose": "List available recovery actions from the catalog."
        },
        {
          "type": "async_function",
          "name": "evaluate_rules",
          "purpose": "Evaluate rules against error context without persisting."
        },
        {
          "type": "class",
          "name": "ScopeTestRequest",
          "purpose": "Request to test a recovery action in scoped execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ScopeTestResponse",
          "purpose": "Response from scoped execution test.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "test_recovery_scope",
          "purpose": "M6: Test a recovery action in scoped execution before global rollout."
        },
        {
          "type": "class",
          "name": "CreateScopeRequest",
          "purpose": "Request to create a bound execution scope.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CreateScopeResponse",
          "purpose": "Response with created execution scope.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExecuteRequest",
          "purpose": "Request to execute a recovery action.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExecuteResponse",
          "purpose": "Response from recovery execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ScopeListResponse",
          "purpose": "Response listing scopes for an incident.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "create_scope",
          "purpose": "P2FC-4: Create a bound execution scope for recovery action."
        },
        {
          "type": "async_function",
          "name": "execute_recovery",
          "purpose": "P2FC-4: Execute a recovery action (REQUIRES valid scope)."
        },
        {
          "type": "async_function",
          "name": "list_scopes",
          "purpose": "List all execution scopes for an incident."
        },
        {
          "type": "async_function",
          "name": "revoke_scope",
          "purpose": "Revoke an execution scope (admin action)."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/suggest"
        },
        {
          "method": "GET",
          "path": "/candidates"
        },
        {
          "method": "POST",
          "path": "/approve"
        },
        {
          "method": "DELETE",
          "path": "/candidates/{candidate_id}"
        },
        {
          "method": "GET",
          "path": "/stats"
        },
        {
          "method": "GET",
          "path": "/candidates/{candidate_id}"
        },
        {
          "method": "PATCH",
          "path": "/candidates/{candidate_id}"
        },
        {
          "method": "GET",
          "path": "/actions"
        },
        {
          "method": "POST",
          "path": "/evaluate"
        },
        {
          "method": "POST",
          "path": "/candidates/{candidate_id}/scope-test"
        },
        {
          "method": "POST",
          "path": "/scope"
        },
        {
          "method": "POST",
          "path": "/execute"
        },
        {
          "method": "GET",
          "path": "/scopes/{incident_id}"
        },
        {
          "method": "DELETE",
          "path": "/scopes/{scope_id}"
        }
      ],
      "calls": {
        "L3": [
          "app.middleware.rate_limit"
        ],
        "L4": [
          "app.services.recovery_matcher",
          "app.services.recovery_write_service",
          "app.services.scoped_execution",
          "app.services.scoped_execution",
          "app.services.scoped_execution",
          "app.services.scoped_execution",
          "app.services.scoped_execution",
          "app.services.recovery_rule_engine"
        ],
        "external": [
          "app.metrics",
          "app.metrics"
        ]
      }
    },
    {
      "file": "api/recovery_ingest.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "IngestRequest",
          "purpose": "Request to ingest a failure for recovery evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IngestResponse",
          "purpose": "Response from ingest endpoint.",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_db_session",
          "purpose": "Create database session for request."
        },
        {
          "type": "async_function",
          "name": "ingest_failure",
          "purpose": "Ingest a failure for recovery suggestion evaluation."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/ingest"
        }
      ],
      "calls": {
        "L3": [
          "app.middleware.rate_limit"
        ],
        "L4": [
          "app.services.recovery_write_service",
          "app.tasks.recovery_queue_stream"
        ],
        "external": [
          "app.metrics"
        ]
      }
    },
    {
      "file": "api/runtime.py",
      "layer": "L2",
      "layer_source": "declared",
      "purpose": "Runtime API endpoints for machine-native primitives",
      "temporal": {
        "trigger": "api",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "PlanStep",
          "purpose": "A single step in a plan to simulate.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SimulateRequest",
          "purpose": "Request to simulate a plan before execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SimulateResponse",
          "purpose": "Response from plan simulation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "QueryRequest",
          "purpose": "Request to query runtime state.",
          "methods": []
        },
        {
          "type": "class",
          "name": "QueryResponse",
          "purpose": "Response from runtime query.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SkillDescriptorResponse",
          "purpose": "Response describing a skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SkillListResponse",
          "purpose": "Response listing available skills.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CapabilitiesResponse",
          "purpose": "Response with agent capabilities.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "simulate_plan",
          "purpose": "Simulate a plan before execution."
        },
        {
          "type": "async_function",
          "name": "query_runtime",
          "purpose": "Query runtime state."
        },
        {
          "type": "async_function",
          "name": "list_available_skills",
          "purpose": "List all available skills."
        },
        {
          "type": "async_function",
          "name": "describe_skill",
          "purpose": "Get detailed descriptor for a skill."
        },
        {
          "type": "async_function",
          "name": "get_capabilities",
          "purpose": "Get available capabilities for an agent/tenant."
        },
        {
          "type": "async_function",
          "name": "get_resource_contract",
          "purpose": "Get resource contract for a specific resource."
        },
        {
          "type": "class",
          "name": "ReplayRequest",
          "purpose": "Request to replay a stored run.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayResponse",
          "purpose": "Response from replay operation.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "replay_run",
          "purpose": "Replay a stored plan and optionally verify determinism parity."
        },
        {
          "type": "async_function",
          "name": "list_traces",
          "purpose": "List stored traces for a tenant."
        },
        {
          "type": "async_function",
          "name": "get_trace",
          "purpose": "Get a specific trace by run ID."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/simulate"
        },
        {
          "method": "POST",
          "path": "/query"
        },
        {
          "method": "GET",
          "path": "/skills"
        },
        {
          "method": "GET",
          "path": "/skills/{skill_id}"
        },
        {
          "method": "GET",
          "path": "/capabilities"
        },
        {
          "method": "GET",
          "path": "/resource-contract/{resource_id}"
        },
        {
          "method": "POST",
          "path": "/replay/{run_id}"
        },
        {
          "method": "GET",
          "path": "/traces"
        },
        {
          "method": "GET",
          "path": "/traces/{run_id}"
        }
      ],
      "calls": {
        "L3": [
          "app.auth.tenant_auth",
          "app.auth.tier_gating",
          "app.middleware.rate_limit",
          "app.adapters.runtime_adapter"
        ],
        "L4": [
          "app.skills"
        ],
        "L5": [
          "app.worker.simulate",
          "app.runtime.replay",
          "app.runtime.replay",
          "app.runtime.replay"
        ],
        "external": [
          "app.commands.runtime_command"
        ]
      }
    },
    {
      "file": "api/status_history.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "StatusHistoryQuery",
          "purpose": "Query parameters for status history.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StatusHistoryResponse",
          "purpose": "Single status history record.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StatusHistoryListResponse",
          "purpose": "Paginated list of status history records.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExportRequest",
          "purpose": "Request for status history export.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExportResponse",
          "purpose": "Response with signed URL for export download.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StatsResponse",
          "purpose": "Statistics for audit reporting.",
          "methods": []
        },
        {
          "type": "function",
          "name": "generate_signed_url",
          "purpose": "Generate a signed URL for export download."
        },
        {
          "type": "function",
          "name": "verify_signed_url",
          "purpose": "Verify a signed URL signature."
        },
        {
          "type": "async_function",
          "name": "query_status_history",
          "purpose": "Query status history with filters."
        },
        {
          "type": "async_function",
          "name": "get_entity_history",
          "purpose": "Get complete status history for a specific entity."
        },
        {
          "type": "async_function",
          "name": "create_export",
          "purpose": "Create an export of status history records."
        },
        {
          "type": "async_function",
          "name": "download_export",
          "purpose": "Download an exported file using signed URL."
        },
        {
          "type": "async_function",
          "name": "get_stats",
          "purpose": "Get statistics about status history records."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/entity/{entity_type}/{entity_id}"
        },
        {
          "method": "POST",
          "path": "/export"
        },
        {
          "method": "GET",
          "path": "/download/{export_id}"
        },
        {
          "method": "GET",
          "path": "/stats"
        }
      ],
      "calls": {
        "L6": [
          "app.db"
        ]
      }
    },
    {
      "file": "api/tenants.py",
      "layer": "L2",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "get_db",
          "purpose": "Get database session."
        },
        {
          "type": "function",
          "name": "get_services",
          "purpose": "Get tenant and worker registry services."
        },
        {
          "type": "class",
          "name": "TenantResponse",
          "purpose": "Tenant information response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "APIKeyCreateRequest",
          "purpose": "Request to create an API key.",
          "methods": []
        },
        {
          "type": "class",
          "name": "APIKeyResponse",
          "purpose": "API key information (without the actual key).",
          "methods": []
        },
        {
          "type": "class",
          "name": "APIKeyCreatedResponse",
          "purpose": "Response when creating an API key (includes the key once).",
          "methods": []
        },
        {
          "type": "class",
          "name": "UsageSummaryResponse",
          "purpose": "Usage summary for a tenant.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerSummaryResponse",
          "purpose": "Worker summary information.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerDetailResponse",
          "purpose": "Detailed worker information.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerConfigRequest",
          "purpose": "Request to configure a worker for a tenant.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerConfigResponse",
          "purpose": "Worker configuration response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RunHistoryItem",
          "purpose": "Run history item.",
          "methods": []
        },
        {
          "type": "class",
          "name": "QuotaCheckResponse",
          "purpose": "Quota check response.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "get_current_tenant",
          "purpose": "Get information about the current tenant (from API key)."
        },
        {
          "type": "async_function",
          "name": "get_tenant_usage",
          "purpose": "Get usage summary for the current tenant."
        },
        {
          "type": "async_function",
          "name": "check_run_quota",
          "purpose": "Check if the tenant can create a new run."
        },
        {
          "type": "async_function",
          "name": "check_token_quota",
          "purpose": "Check if the tenant has token budget for an operation."
        },
        {
          "type": "async_function",
          "name": "list_api_keys",
          "purpose": "List all API keys for the current tenant."
        },
        {
          "type": "async_function",
          "name": "create_api_key",
          "purpose": "Create a new API key for the current tenant."
        },
        {
          "type": "async_function",
          "name": "revoke_api_key",
          "purpose": "Revoke an API key."
        },
        {
          "type": "async_function",
          "name": "list_workers",
          "purpose": "List all available workers."
        },
        {
          "type": "async_function",
          "name": "list_available_workers_for_tenant",
          "purpose": "List workers available to the current tenant with their configurations."
        },
        {
          "type": "async_function",
          "name": "get_worker_details",
          "purpose": "Get detailed information about a specific worker."
        },
        {
          "type": "async_function",
          "name": "get_worker_config",
          "purpose": "Get the effective configuration for a worker (tenant overrides merged with defaults)."
        },
        {
          "type": "async_function",
          "name": "set_worker_config",
          "purpose": "Set tenant-specific configuration for a worker."
        },
        {
          "type": "async_function",
          "name": "list_runs",
          "purpose": "List runs for the current tenant."
        },
        {
          "type": "async_function",
          "name": "tenant_health",
          "purpose": "Health check for tenant system."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/tenant"
        },
        {
          "method": "GET",
          "path": "/tenant/usage"
        },
        {
          "method": "GET",
          "path": "/tenant/quota/runs"
        },
        {
          "method": "GET",
          "path": "/tenant/quota/tokens"
        },
        {
          "method": "GET",
          "path": "/api-keys"
        },
        {
          "method": "POST",
          "path": "/api-keys"
        },
        {
          "method": "DELETE",
          "path": "/api-keys/{key_id}"
        },
        {
          "method": "GET",
          "path": "/workers"
        },
        {
          "method": "GET",
          "path": "/workers/available"
        },
        {
          "method": "GET",
          "path": "/workers/{worker_id}"
        },
        {
          "method": "GET",
          "path": "/workers/{worker_id}/config"
        },
        {
          "method": "PUT",
          "path": "/workers/{worker_id}/config"
        },
        {
          "method": "GET",
          "path": "/runs"
        },
        {
          "method": "GET",
          "path": "/tenant/health"
        }
      ]
    },
    {
      "file": "api/traces.py",
      "layer": "L2",
      "layer_source": "declared",
      "purpose": "Trace storage, indexing, query, and determinism validation",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "User",
          "purpose": "User model for RBAC - wraps JWT TokenPayload for backwards compatibility.",
          "methods": [
            "has_role",
            "from_token"
          ]
        },
        {
          "type": "async_function",
          "name": "get_current_user",
          "purpose": "Get current authenticated user from JWT token."
        },
        {
          "type": "function",
          "name": "require_role",
          "purpose": "Check if user has required role."
        },
        {
          "type": "function",
          "name": "get_trace_store",
          "purpose": "Get the trace store instance."
        },
        {
          "type": "class",
          "name": "TraceSummaryResponse",
          "purpose": "Trace summary for list views.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TraceStepResponse",
          "purpose": "Individual trace step.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TraceDetailResponse",
          "purpose": "Full trace with all steps.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TraceListResponse",
          "purpose": "Paginated trace list.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TraceCompareResponse",
          "purpose": "Result of comparing two traces.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StoreTraceRequest",
          "purpose": "Request to store a client-provided trace.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "list_traces",
          "purpose": "List and search traces with optional filters."
        },
        {
          "type": "async_function",
          "name": "store_trace",
          "purpose": "Store a client-provided trace."
        },
        {
          "type": "async_function",
          "name": "get_trace",
          "purpose": "Get a complete trace by run ID."
        },
        {
          "type": "async_function",
          "name": "get_trace_by_hash",
          "purpose": "Get a trace by its deterministic root hash."
        },
        {
          "type": "async_function",
          "name": "compare_traces",
          "purpose": "Compare two traces for deterministic equality."
        },
        {
          "type": "async_function",
          "name": "delete_trace",
          "purpose": "Delete a trace by run ID."
        },
        {
          "type": "async_function",
          "name": "cleanup_old_traces",
          "purpose": "Delete traces older than specified number of days."
        },
        {
          "type": "async_function",
          "name": "check_idempotency",
          "purpose": "Check if an idempotency key has been executed."
        },
        {
          "type": "class",
          "name": "MismatchReport",
          "purpose": "Report a replay mismatch for operator review.",
          "methods": []
        },
        {
          "type": "class",
          "name": "MismatchResponse",
          "purpose": "Response after reporting a mismatch.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "bulk_report_mismatches",
          "purpose": "Create a single GitHub issue for multiple mismatches."
        },
        {
          "type": "async_function",
          "name": "report_mismatch",
          "purpose": "Report a replay mismatch for operator review."
        },
        {
          "type": "async_function",
          "name": "list_trace_mismatches",
          "purpose": "List all mismatches reported for a trace."
        },
        {
          "type": "async_function",
          "name": "resolve_mismatch",
          "purpose": "Mark a mismatch as resolved."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/{run_id}"
        },
        {
          "method": "GET",
          "path": "/by-hash/{root_hash}"
        },
        {
          "method": "GET",
          "path": "/compare/{run_id1}/{run_id2}"
        },
        {
          "method": "DELETE",
          "path": "/{run_id}"
        },
        {
          "method": "POST",
          "path": "/cleanup"
        },
        {
          "method": "GET",
          "path": "/idempotency/{idempotency_key}"
        },
        {
          "method": "POST",
          "path": "/mismatches/bulk-report"
        },
        {
          "method": "POST",
          "path": "/{trace_id}/mismatch"
        },
        {
          "method": "GET",
          "path": "/{trace_id}/mismatches"
        },
        {
          "method": "POST",
          "path": "/{trace_id}/mismatches/{mismatch_id}/resolve"
        }
      ]
    },
    {
      "file": "api/v1_killswitch.py",
      "layer": "L2",
      "layer_source": "declared",
      "components": [
        {
          "type": "function",
          "name": "utc_now",
          "purpose": null
        },
        {
          "type": "async_function",
          "name": "freeze_tenant",
          "purpose": "Hard stop everything for a tenant."
        },
        {
          "type": "async_function",
          "name": "freeze_key",
          "purpose": "Kill a single API key."
        },
        {
          "type": "async_function",
          "name": "get_killswitch_status",
          "purpose": "Get complete kill switch status for a tenant."
        },
        {
          "type": "async_function",
          "name": "unfreeze_tenant",
          "purpose": "Unfreeze a tenant."
        },
        {
          "type": "async_function",
          "name": "unfreeze_key",
          "purpose": "Unfreeze an API key."
        },
        {
          "type": "async_function",
          "name": "get_active_policies",
          "purpose": "Get active guardrails - \"What's protecting me right now?\""
        },
        {
          "type": "async_function",
          "name": "list_incidents",
          "purpose": "List incidents (auto-grouped failures)."
        },
        {
          "type": "async_function",
          "name": "get_incident",
          "purpose": "Get incident detail with timeline."
        },
        {
          "type": "async_function",
          "name": "replay_call",
          "purpose": "REPLAY PROVES ENFORCEMENT"
        },
        {
          "type": "async_function",
          "name": "get_call",
          "purpose": "Get single call truth."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/killswitch/tenant"
        },
        {
          "method": "POST",
          "path": "/killswitch/key"
        },
        {
          "method": "GET",
          "path": "/killswitch/status"
        },
        {
          "method": "DELETE",
          "path": "/killswitch/tenant"
        },
        {
          "method": "DELETE",
          "path": "/killswitch/key"
        },
        {
          "method": "GET",
          "path": "/policies/active"
        },
        {
          "method": "GET",
          "path": "/incidents"
        },
        {
          "method": "GET",
          "path": "/incidents/{incident_id}"
        },
        {
          "method": "POST",
          "path": "/replay/{call_id}"
        },
        {
          "method": "GET",
          "path": "/calls/{call_id}"
        }
      ],
      "calls": {
        "L3": [
          "app.auth.tenant_auth",
          "app.auth.tier_gating"
        ],
        "L4": [
          "app.services.guard_write_service"
        ],
        "L6": [
          "app.db",
          "app.models.killswitch",
          "app.models.tenant"
        ]
      }
    },
    {
      "file": "api/v1_proxy.py",
      "layer": "L2",
      "layer_source": "declared",
      "purpose": "OpenAI-compatible proxy with KillSwitch and budget enforcement",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ChatMessage",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "ChatCompletionRequest",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "ChatCompletionChoice",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Usage",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "ChatCompletionResponse",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "EmbeddingRequest",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "EmbeddingData",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "EmbeddingResponse",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "ErrorResponse",
          "purpose": null,
          "methods": []
        },
        {
          "type": "async_function",
          "name": "get_auth_context",
          "purpose": "Authenticate request and return tenant/key context."
        },
        {
          "type": "function",
          "name": "record_usage_after_killswitch",
          "purpose": "Record API key usage ONLY after kill switch passes."
        },
        {
          "type": "async_function",
          "name": "check_killswitch",
          "purpose": "Check if tenant or API key is frozen."
        },
        {
          "type": "async_function",
          "name": "evaluate_guardrails",
          "purpose": "Evaluate default guardrails against request."
        },
        {
          "type": "function",
          "name": "calculate_cost",
          "purpose": "Calculate cost in cents."
        },
        {
          "type": "function",
          "name": "estimate_tokens",
          "purpose": "Estimate token count."
        },
        {
          "type": "function",
          "name": "get_openai_client",
          "purpose": "Get OpenAI client (lazy loaded)."
        },
        {
          "type": "async_function",
          "name": "log_proxy_call",
          "purpose": "Log a proxy call for replay and analysis."
        },
        {
          "type": "async_function",
          "name": "chat_completions",
          "purpose": "OpenAI-compatible chat completions endpoint."
        },
        {
          "type": "async_function",
          "name": "stream_chat_completion",
          "purpose": "Handle streaming chat completion."
        },
        {
          "type": "async_function",
          "name": "embeddings",
          "purpose": "OpenAI-compatible embeddings endpoint."
        },
        {
          "type": "async_function",
          "name": "proxy_status",
          "purpose": "Protection status endpoint - the pulse of your safety net."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/chat/completions"
        },
        {
          "method": "POST",
          "path": "/embeddings"
        },
        {
          "method": "GET",
          "path": "/status"
        }
      ],
      "calls": {
        "L6": [
          "app.db",
          "app.models.killswitch",
          "app.models.tenant",
          "app.db"
        ]
      }
    },
    {
      "file": "api/workers.py",
      "layer": "L2",
      "layer_source": "declared",
      "purpose": "Business Builder Worker API endpoints",
      "temporal": {
        "trigger": "api",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "ToneRuleRequest",
          "purpose": "Tone rule for brand.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ForbiddenClaimRequest",
          "purpose": "Forbidden claim definition.",
          "methods": []
        },
        {
          "type": "class",
          "name": "VisualIdentityRequest",
          "purpose": "Visual identity for brand.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BrandRequest",
          "purpose": "Brand schema for worker execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerRunRequest",
          "purpose": "Request to run the Business Builder Worker.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyStatusModel",
          "purpose": "Phase 5B: Policy pre-check status for PRE-RUN declaration.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerRunResponse",
          "purpose": "Response from worker execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayRequest",
          "purpose": "Request to replay a previous execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BrandValidationResponse",
          "purpose": "Response from brand validation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RunListItem",
          "purpose": "Summary item for run listing.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RunListResponse",
          "purpose": "Response for listing runs.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerEventBus",
          "purpose": "Event bus for real-time worker execution streaming.",
          "methods": [
            "subscribe",
            "unsubscribe",
            "emit",
            "get_history",
            "cleanup"
          ]
        },
        {
          "type": "function",
          "name": "get_event_bus",
          "purpose": "Get the global event bus instance."
        },
        {
          "type": "class",
          "name": "EventType",
          "purpose": "Constants for SSE event types.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "run_worker",
          "purpose": "Execute the Business Builder Worker."
        },
        {
          "type": "async_function",
          "name": "replay_execution_endpoint",
          "purpose": "Replay a previous execution using Golden Replay (M4)."
        },
        {
          "type": "async_function",
          "name": "get_run",
          "purpose": "Get details of a worker run."
        },
        {
          "type": "async_function",
          "name": "list_runs",
          "purpose": "List recent worker runs."
        },
        {
          "type": "async_function",
          "name": "validate_brand",
          "purpose": "Validate a brand schema without executing the worker."
        },
        {
          "type": "async_function",
          "name": "worker_health",
          "purpose": "Health check for Business Builder Worker."
        },
        {
          "type": "async_function",
          "name": "delete_run",
          "purpose": "Delete a run from storage."
        },
        {
          "type": "async_function",
          "name": "get_brand_schema",
          "purpose": "Get the JSON schema for BrandRequest."
        },
        {
          "type": "async_function",
          "name": "get_run_schema",
          "purpose": "Get the JSON schema for WorkerRunRequest."
        },
        {
          "type": "async_function",
          "name": "stream_run_events",
          "purpose": "Stream real-time events for a worker run via Server-Sent Events (SSE)."
        },
        {
          "type": "async_function",
          "name": "get_run_events",
          "purpose": "Get all events for a run (non-streaming)."
        },
        {
          "type": "async_function",
          "name": "run_worker_streaming",
          "purpose": "Execute the Business Builder Worker with real-time event streaming."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/run"
        },
        {
          "method": "POST",
          "path": "/replay"
        },
        {
          "method": "GET",
          "path": "/runs/{run_id}"
        },
        {
          "method": "GET",
          "path": "/runs"
        },
        {
          "method": "POST",
          "path": "/validate-brand"
        },
        {
          "method": "GET",
          "path": "/health"
        },
        {
          "method": "DELETE",
          "path": "/runs/{run_id}"
        },
        {
          "method": "GET",
          "path": "/schema/brand"
        },
        {
          "method": "GET",
          "path": "/schema/run"
        },
        {
          "method": "GET",
          "path": "/stream/{run_id}"
        },
        {
          "method": "GET",
          "path": "/events/{run_id}"
        },
        {
          "method": "POST",
          "path": "/run-streaming"
        }
      ],
      "calls": {
        "L3": [
          "app.auth",
          "app.adapters.workers_adapter"
        ],
        "L4": [
          "app.contracts.decisions",
          "app.policy.engine",
          "app.services.worker_write_service_async",
          "app.routing.care",
          "app.policy.runtime.dag_executor",
          "app.services.recovery_matcher",
          "app.services.recovery_matcher"
        ],
        "L6": [
          "app.db",
          "app.models.tenant"
        ]
      }
    },
    {
      "file": "main.py",
      "layer": "L2",
      "layer_source": "declared",
      "purpose": "FastAPI application entry point, route registration, middleware setup",
      "temporal": {
        "trigger": "external (HTTP)",
        "execution": "sync (request-response)"
      },
      "components": [
        {
          "type": "class",
          "name": "CreateAgentRequest",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "CreateAgentResponse",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "GoalRequest",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "GoalResponse",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "RunResponse",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "MemoryResponse",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "ProvenanceResponse",
          "purpose": null,
          "methods": []
        },
        {
          "type": "async_function",
          "name": "update_queue_depth",
          "purpose": "Periodically update the queue depth metric."
        },
        {
          "type": "function",
          "name": "validate_route_order",
          "purpose": "Runtime validation of route ordering."
        },
        {
          "type": "async_function",
          "name": "lifespan",
          "purpose": "Manage application lifespan - start background tasks and initialize services."
        },
        {
          "type": "async_function",
          "name": "add_request_id",
          "purpose": "Add unique request ID for tracing."
        },
        {
          "type": "async_function",
          "name": "execute_run",
          "purpose": "Execute a queued run in the background."
        },
        {
          "type": "async_function",
          "name": "health_check",
          "purpose": "Health check with DB validation."
        },
        {
          "type": "async_function",
          "name": "version",
          "purpose": "Version info."
        },
        {
          "type": "async_function",
          "name": "healthz",
          "purpose": "Kubernetes-style health check."
        },
        {
          "type": "async_function",
          "name": "download_openapi",
          "purpose": "Download OpenAPI spec as JSON file."
        },
        {
          "type": "async_function",
          "name": "worker_pool_health",
          "purpose": "Worker pool health probe endpoint."
        },
        {
          "type": "async_function",
          "name": "metrics",
          "purpose": "Prometheus metrics endpoint (multiprocess-aware)."
        },
        {
          "type": "async_function",
          "name": "get_skills",
          "purpose": "List all registered skills."
        },
        {
          "type": "async_function",
          "name": "create_agent",
          "purpose": "Create a new agent."
        },
        {
          "type": "async_function",
          "name": "get_agent",
          "purpose": "Get agent by ID."
        },
        {
          "type": "async_function",
          "name": "post_goal",
          "purpose": "Submit a goal to an agent."
        },
        {
          "type": "async_function",
          "name": "get_run",
          "purpose": "Get run status and results."
        },
        {
          "type": "async_function",
          "name": "list_runs",
          "purpose": "List runs for an agent."
        },
        {
          "type": "async_function",
          "name": "recall_memory",
          "purpose": "Recall memories for an agent."
        },
        {
          "type": "async_function",
          "name": "get_provenance",
          "purpose": "Get provenance records for an agent."
        },
        {
          "type": "async_function",
          "name": "get_provenance_by_id",
          "purpose": "Get a specific provenance record."
        },
        {
          "type": "class",
          "name": "RetryRequest",
          "purpose": "Request to retry a failed worker run (PB-S1 compliant).",
          "methods": []
        },
        {
          "type": "class",
          "name": "RetryResponse",
          "purpose": "Response from retry operation (PB-S1 compliant).",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "retry_failed_run",
          "purpose": "Retry a failed worker run by creating a NEW execution (PB-S1 compliant)."
        },
        {
          "type": "class",
          "name": "RerunRequest",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "RerunResponse",
          "purpose": null,
          "methods": []
        },
        {
          "type": "async_function",
          "name": "rerun_failed_run",
          "purpose": "REMOVED: This endpoint has been disabled to enforce PB-S1 truth guarantees."
        },
        {
          "type": "async_function",
          "name": "list_failed_runs",
          "purpose": "List recent failed runs for review."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/health"
        },
        {
          "method": "GET",
          "path": "/version"
        },
        {
          "method": "GET",
          "path": "/healthz"
        },
        {
          "method": "GET",
          "path": "/openapi-download"
        },
        {
          "method": "GET",
          "path": "/healthz/worker_pool"
        },
        {
          "method": "GET",
          "path": "/metrics"
        },
        {
          "method": "GET",
          "path": "/skills"
        },
        {
          "method": "POST",
          "path": "/agents"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}"
        },
        {
          "method": "POST",
          "path": "/agents/{agent_id}/goals"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/runs/{run_id}"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/runs"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/recall"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/provenance"
        },
        {
          "method": "GET",
          "path": "/agents/{agent_id}/provenance/{prov_id}"
        },
        {
          "method": "POST",
          "path": "/admin/retry"
        },
        {
          "method": "POST",
          "path": "/admin/rerun"
        },
        {
          "method": "GET",
          "path": "/admin/failed-runs"
        }
      ],
      "calls": {
        "L4": [
          "app.services.plan_generation_engine"
        ]
      }
    }
  ],
  "L3": [
    {
      "file": "adapters/founder_ops_adapter.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Translate OpsIncident domain models to Founder-facing views",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "FounderIncidentSummaryView",
          "purpose": "Founder-facing incident summary.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderIncidentsSummaryResponse",
          "purpose": "Response for GET /ops/incidents/summary.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderOpsAdapter",
          "purpose": "Boundary adapter for Founder Ops incident views.",
          "methods": [
            "to_summary_view",
            "to_summary_response"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.services.ops_domain_models"
        ]
      }
    },
    {
      "file": "adapters/policy_adapter.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Policy evaluation boundary adapter (L2 \u2192 L3 \u2192 L4)",
      "temporal": {
        "trigger": "api",
        "execution": "async (delegates to L4)"
      },
      "components": [
        {
          "type": "class",
          "name": "PolicyAdapter",
          "purpose": "Boundary adapter for policy operations.",
          "methods": [
            "simulate_cost",
            "check_policy_violations",
            "evaluate_policy",
            "record_approval_created",
            "record_approval_outcome",
            "record_escalation",
            "record_webhook_used"
          ]
        },
        {
          "type": "function",
          "name": "get_policy_adapter",
          "purpose": "Get the singleton PolicyAdapter instance."
        }
      ],
      "calls": {
        "external": [
          "app.commands.policy_command"
        ]
      }
    },
    {
      "file": "adapters/runtime_adapter.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Translate API requests into runtime domain commands",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "RuntimeAdapter",
          "purpose": "L3 Boundary Adapter for runtime operations.",
          "methods": [
            "query",
            "get_supported_queries",
            "describe_skill",
            "list_skills",
            "get_skill_descriptors",
            "get_resource_contract",
            "get_capabilities"
          ]
        },
        {
          "type": "function",
          "name": "get_runtime_adapter",
          "purpose": "Factory function to get RuntimeAdapter instance."
        }
      ],
      "calls": {
        "external": [
          "app.commands.runtime_command"
        ]
      }
    },
    {
      "file": "adapters/workers_adapter.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Worker execution boundary adapter (L2 \u2192 L3 \u2192 L4)",
      "temporal": {
        "trigger": "api",
        "execution": "async (delegates to L4)"
      },
      "components": [
        {
          "type": "class",
          "name": "WorkersAdapter",
          "purpose": "Boundary adapter for worker operations.",
          "methods": [
            "execute_worker",
            "replay_execution",
            "calculate_cost_cents",
            "convert_brand_request"
          ]
        },
        {
          "type": "function",
          "name": "get_workers_adapter",
          "purpose": "Get the singleton WorkersAdapter instance."
        }
      ],
      "calls": {
        "external": [
          "app.commands.worker_execution_command"
        ]
      }
    },
    {
      "file": "auth/__init__.py",
      "layer": "L3",
      "layer_source": "inferred",
      "components": [
        {
          "type": "async_function",
          "name": "verify_api_key",
          "purpose": "Verify the API key from X-AOS-Key header."
        }
      ]
    },
    {
      "file": "auth/clerk_provider.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Clerk authentication provider adapter",
      "temporal": {
        "trigger": "external",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "ClerkUser",
          "purpose": "Represents a Clerk user with role information.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ClerkAuthError",
          "purpose": "Raised when Clerk authentication fails.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ClerkAuthProvider",
          "purpose": "Clerk authentication provider for AOS.",
          "methods": [
            "is_configured",
            "close",
            "verify_token",
            "get_user",
            "get_user_roles",
            "get_user_by_token"
          ]
        },
        {
          "type": "function",
          "name": "get_clerk_provider",
          "purpose": "Get or create the Clerk auth provider singleton."
        },
        {
          "type": "async_function",
          "name": "get_user_roles_from_clerk",
          "purpose": "Convenience function to get user roles from Clerk."
        }
      ],
      "calls": {
        "L3": [
          "app.auth.rbac_engine"
        ]
      }
    },
    {
      "file": "auth/identity_adapter.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Extract identity from requests, produce ActorContext",
      "temporal": {
        "trigger": "api",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "AuthenticationError",
          "purpose": "Raised when authentication fails (invalid/expired token).",
          "methods": []
        },
        {
          "type": "class",
          "name": "IdentityAdapter",
          "purpose": "Abstract base for identity adapters.",
          "methods": [
            "extract_actor",
            "get_source",
            "name"
          ]
        },
        {
          "type": "class",
          "name": "ClerkAdapter",
          "purpose": "Clerk identity adapter.",
          "methods": [
            "get_source",
            "extract_actor"
          ]
        },
        {
          "type": "class",
          "name": "SystemIdentityAdapter",
          "purpose": "System identity adapter for CI, workers, internal services.",
          "methods": [
            "get_source",
            "extract_actor"
          ]
        },
        {
          "type": "class",
          "name": "DevIdentityAdapter",
          "purpose": "Development identity adapter.",
          "methods": [
            "get_source",
            "extract_actor"
          ]
        },
        {
          "type": "class",
          "name": "StubIdentityAdapter",
          "purpose": "Stub identity adapter for CI testing.",
          "methods": [
            "get_source",
            "extract_actor"
          ]
        }
      ],
      "calls": {
        "L3": [
          "app.auth.actor",
          "app.auth.clerk_provider"
        ]
      }
    },
    {
      "file": "auth/oauth_providers.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "OAuth provider adapters (Google, GitHub, etc)",
      "temporal": {
        "trigger": "external",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "OAuthUserInfo",
          "purpose": "Standardized user info from OAuth providers.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OAuthError",
          "purpose": "OAuth-related error.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GoogleOAuthProvider",
          "purpose": "Google OAuth2 provider.",
          "methods": [
            "is_configured",
            "get_authorization_url",
            "exchange_code",
            "get_user_info"
          ]
        },
        {
          "type": "class",
          "name": "AzureOAuthProvider",
          "purpose": "Azure AD OAuth2 provider.",
          "methods": [
            "is_configured",
            "get_authorization_url",
            "exchange_code",
            "get_user_info"
          ]
        },
        {
          "type": "function",
          "name": "get_google_provider",
          "purpose": "Get Google OAuth provider singleton."
        },
        {
          "type": "function",
          "name": "get_azure_provider",
          "purpose": "Get Azure OAuth provider singleton."
        }
      ]
    },
    {
      "file": "auth/oidc_provider.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "OIDC authentication provider adapter",
      "temporal": {
        "trigger": "external",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "OIDCError",
          "purpose": "Base exception for OIDC-related errors.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TokenValidationError",
          "purpose": "Raised when token validation fails.",
          "methods": []
        },
        {
          "type": "function",
          "name": "validate_token",
          "purpose": "Validate a JWT token using JWKS from the OIDC provider."
        },
        {
          "type": "function",
          "name": "get_roles_from_token",
          "purpose": "Extract roles from Keycloak token claims."
        },
        {
          "type": "function",
          "name": "get_user_info_from_token",
          "purpose": "Extract user information from token claims."
        },
        {
          "type": "function",
          "name": "validate_and_extract",
          "purpose": "Validate token and extract roles in one call."
        },
        {
          "type": "function",
          "name": "map_keycloak_roles_to_aos",
          "purpose": "Map Keycloak roles to AOS RBAC roles."
        }
      ],
      "calls": {
        "L3": [
          "app.auth.rbac_engine"
        ]
      }
    },
    {
      "file": "costsim/v2_adapter.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Cost simulation adapter (translation only)",
      "temporal": {
        "trigger": "api|worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "V2StepEstimate",
          "purpose": "Enhanced step estimate with confidence.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostSimV2Adapter",
          "purpose": "CostSim V2 Adapter with enhanced modeling.",
          "methods": [
            "simulate",
            "simulate_with_comparison"
          ]
        },
        {
          "type": "async_function",
          "name": "simulate_v2",
          "purpose": "Convenience function for V2 simulation."
        },
        {
          "type": "async_function",
          "name": "simulate_v2_with_comparison",
          "purpose": "Convenience function for V2 simulation with V1 comparison."
        }
      ],
      "calls": {
        "L4": [
          "app.costsim.config",
          "app.costsim.models",
          "app.costsim.provenance",
          "app.services.cost_model_engine",
          "app.services.cost_model_engine",
          "app.services.cost_model_engine"
        ],
        "L5": [
          "app.worker.simulate"
        ]
      }
    },
    {
      "file": "events/nats_adapter.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "NATS event streaming adapter",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "NatsAdapter",
          "purpose": "NATS event publisher adapter.",
          "methods": [
            "publish"
          ]
        }
      ]
    },
    {
      "file": "events/publisher.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Event publishing abstraction",
      "temporal": {
        "trigger": "api|worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "BasePublisher",
          "purpose": "Base class for event publishers.",
          "methods": [
            "publish",
            "close"
          ]
        },
        {
          "type": "class",
          "name": "LoggingPublisher",
          "purpose": "Fallback publisher that logs events.",
          "methods": [
            "publish"
          ]
        },
        {
          "type": "function",
          "name": "get_publisher",
          "purpose": "Get configured event publisher."
        },
        {
          "type": "function",
          "name": "reset_publisher",
          "purpose": "Reset publisher instance (for testing)."
        }
      ]
    },
    {
      "file": "events/redis_publisher.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Redis pub/sub event adapter",
      "temporal": {
        "trigger": "api|worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "RedisPublisher",
          "purpose": "Redis Pub/Sub event publisher.",
          "methods": [
            "publish",
            "close"
          ]
        }
      ]
    },
    {
      "file": "planner/__init__.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Planner package marker",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "get_stub_planner",
          "purpose": "Get StubPlanner class (lazy import)."
        },
        {
          "type": "function",
          "name": "get_legacy_stub_planner",
          "purpose": "Get LegacyStubPlanner class (lazy import)."
        }
      ]
    },
    {
      "file": "planner/interface.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Planner interface definition (contract)",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "DeterminismMode",
          "purpose": "Determinism mode for planner outputs.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PlanStep",
          "purpose": "A single step in an execution plan.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "PlanMetadata",
          "purpose": "Metadata about plan generation.",
          "methods": [
            "generated_at",
            "to_dict",
            "to_deterministic_dict"
          ]
        },
        {
          "type": "class",
          "name": "PlannerOutput",
          "purpose": "Structured planner output.",
          "methods": [
            "to_dict",
            "to_deterministic_dict",
            "to_canonical_json",
            "content_hash",
            "plan"
          ]
        },
        {
          "type": "class",
          "name": "PlannerError",
          "purpose": "Structured planner error.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "PlannerErrorCode",
          "purpose": "Standard planner error codes.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PlannerInterface",
          "purpose": "Abstract base class for planner implementations.",
          "methods": [
            "planner_id",
            "version",
            "get_determinism_mode",
            "plan",
            "validate_plan",
            "estimate_cost"
          ]
        },
        {
          "type": "class",
          "name": "PlannerRegistry",
          "purpose": "Registry for planner implementations.",
          "methods": [
            "register",
            "get",
            "list",
            "clear"
          ]
        },
        {
          "type": "function",
          "name": "normalize_goal",
          "purpose": "Normalize goal text for consistent processing."
        },
        {
          "type": "function",
          "name": "normalize_context",
          "purpose": "Normalize context text."
        },
        {
          "type": "function",
          "name": "compute_plan_input_hash",
          "purpose": "Compute deterministic hash of planner inputs."
        }
      ]
    },
    {
      "file": "planner/stub_planner.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Stub planner for testing",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PlanRule",
          "purpose": "A rule for generating plans based on goal keywords.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StubPlanner",
          "purpose": "Rule-based stub planner for testing.",
          "methods": [
            "planner_id",
            "version",
            "get_determinism_mode",
            "plan",
            "add_rule",
            "clear_rules",
            "get_call_history",
            "reset"
          ]
        },
        {
          "type": "class",
          "name": "LegacyStubPlanner",
          "purpose": "Legacy stub planner interface for backwards compatibility.",
          "methods": [
            "plan"
          ]
        },
        {
          "type": "async_function",
          "name": "example_stub_planner_usage",
          "purpose": "Example demonstrating stub planner usage."
        }
      ]
    },
    {
      "file": "planners/anthropic_adapter.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Anthropic Claude LLM adapter",
      "temporal": {
        "trigger": "api|worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "AnthropicPlanner",
          "purpose": "Anthropic Claude-based planner for intelligent plan generation.",
          "methods": [
            "plan"
          ]
        }
      ]
    },
    {
      "file": "planners/stub_adapter.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Stub LLM adapter for testing",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "StubPlanner",
          "purpose": "Stub planner for testing and fallback scenarios.",
          "methods": [
            "plan"
          ]
        }
      ]
    },
    {
      "file": "services/certificate.py",
      "layer": "L3",
      "layer_source": "declared",
      "components": [
        {
          "type": "class",
          "name": "CertificateType",
          "purpose": "Types of certificates that can be issued.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CertificatePayload",
          "purpose": "The signed payload of a certificate.",
          "methods": [
            "to_dict",
            "canonical_json"
          ]
        },
        {
          "type": "class",
          "name": "Certificate",
          "purpose": "A signed certificate proving deterministic replay or policy evaluation.",
          "methods": [
            "to_dict",
            "to_json",
            "from_dict"
          ]
        },
        {
          "type": "class",
          "name": "CertificateService",
          "purpose": "Service for creating and verifying cryptographic certificates.",
          "methods": [
            "create_replay_certificate",
            "create_policy_audit_certificate",
            "verify_certificate",
            "export_certificate"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.services.replay_determinism"
        ]
      }
    },
    {
      "file": "services/email_verification.py",
      "layer": "L3",
      "layer_source": "declared",
      "components": [
        {
          "type": "class",
          "name": "VerificationResult",
          "purpose": "Result of OTP verification.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EmailVerificationError",
          "purpose": "Email verification error.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EmailVerificationService",
          "purpose": "Handles OTP generation, sending, and verification for email signup.",
          "methods": [
            "send_otp",
            "verify_otp"
          ]
        },
        {
          "type": "function",
          "name": "get_email_verification_service",
          "purpose": "Get email verification service singleton."
        }
      ]
    },
    {
      "file": "services/evidence_report.py",
      "layer": "L3",
      "layer_source": "declared",
      "components": [
        {
          "type": "class",
          "name": "CertificateEvidence",
          "purpose": "M23: Certificate data for cryptographic proof.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentEvidence",
          "purpose": "Evidence data for an incident.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EvidenceReportGenerator",
          "purpose": "Generates legal-grade PDF evidence reports.",
          "methods": [
            "generate"
          ]
        },
        {
          "type": "function",
          "name": "generate_evidence_report",
          "purpose": "Convenience function to generate an evidence report."
        }
      ]
    },
    {
      "file": "services/policy_proposal.py",
      "layer": "L3",
      "layer_source": "declared",
      "components": [
        {
          "type": "async_function",
          "name": "check_proposal_eligibility",
          "purpose": "Check if feedback patterns are eligible for policy proposals."
        },
        {
          "type": "async_function",
          "name": "create_policy_proposal",
          "purpose": "Create a policy proposal."
        },
        {
          "type": "async_function",
          "name": "review_policy_proposal",
          "purpose": "Review (approve/reject) a policy proposal."
        },
        {
          "type": "async_function",
          "name": "generate_proposals_from_feedback",
          "purpose": "Generate policy proposals from eligible feedback patterns."
        },
        {
          "type": "function",
          "name": "generate_default_rule",
          "purpose": "Generate a default rule template based on policy type."
        },
        {
          "type": "async_function",
          "name": "get_proposal_summary",
          "purpose": "Get policy proposal summary for ops visibility."
        }
      ],
      "calls": {
        "L6": [
          "app.db",
          "app.models.feedback",
          "app.models.policy"
        ]
      }
    },
    {
      "file": "services/prediction.py",
      "layer": "L3",
      "layer_source": "declared",
      "components": [
        {
          "type": "async_function",
          "name": "predict_failure_likelihood",
          "purpose": "Predict likelihood of failure for upcoming runs."
        },
        {
          "type": "async_function",
          "name": "predict_cost_overrun",
          "purpose": "Predict likelihood of cost overrun for upcoming runs."
        },
        {
          "type": "async_function",
          "name": "emit_prediction",
          "purpose": "Emit a prediction event."
        },
        {
          "type": "async_function",
          "name": "run_prediction_cycle",
          "purpose": "Run full prediction cycle."
        },
        {
          "type": "async_function",
          "name": "get_prediction_summary",
          "purpose": "Get prediction summary for ops visibility."
        }
      ],
      "calls": {
        "L6": [
          "app.db",
          "app.models.feedback",
          "app.models.prediction",
          "app.models.tenant"
        ]
      }
    },
    {
      "file": "skill_http.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "HTTP skill execution adapter",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "async_function",
          "name": "run_http_skill",
          "purpose": "Resilient HTTP skill with timeout, retries, and exponential backoff."
        }
      ]
    },
    {
      "file": "skills/adapters/openai_adapter.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "OpenAI API translation adapter",
      "temporal": {
        "trigger": "api|worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "OpenAIAdapter",
          "purpose": "OpenAI adapter implementing LLMAdapter interface.",
          "methods": [
            "adapter_id",
            "default_model",
            "supports_seeding",
            "estimate_tokens",
            "estimate_cost",
            "invoke"
          ]
        },
        {
          "type": "class",
          "name": "OpenAIAdapterStub",
          "purpose": "Stub version of OpenAIAdapter for testing without API access.",
          "methods": [
            "set_mock_response",
            "clear_mocks",
            "invoke"
          ]
        },
        {
          "type": "function",
          "name": "register_openai_adapter",
          "purpose": "Register OpenAI adapter with the adapter registry."
        }
      ],
      "calls": {
        "L4": [
          "app.skills.llm_invoke_v2",
          "app.services.llm_policy_engine",
          "app.services.llm_policy_engine",
          "app.services.llm_policy_engine",
          "app.skills.llm_invoke_v2"
        ]
      }
    },
    {
      "file": "skills/adapters/tenant_config.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "Tenant LLM configuration adapter",
      "temporal": {
        "trigger": "api|worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "TenantLLMConfig",
          "purpose": "LLM configuration for a specific tenant.",
          "methods": [
            "get_effective_model",
            "is_model_allowed"
          ]
        },
        {
          "type": "function",
          "name": "get_default_config",
          "purpose": "Get default tenant config."
        },
        {
          "type": "async_function",
          "name": "get_tenant_config",
          "purpose": "Get LLM configuration for a tenant."
        },
        {
          "type": "function",
          "name": "reset_config_cache",
          "purpose": "Reset config cache. For testing."
        },
        {
          "type": "async_function",
          "name": "get_model_for_tenant",
          "purpose": "Get the appropriate model for a tenant and task."
        }
      ],
      "calls": {
        "L4": [
          "app.services.llm_policy_engine",
          "app.services.llm_policy_engine"
        ]
      }
    },
    {
      "file": "workers/business_builder/llm_service.py",
      "layer": "L3",
      "layer_source": "declared",
      "purpose": "LLM service adapter for business builder",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "LLMResult",
          "purpose": "Result from LLM call.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerLLMService",
          "purpose": "LLM Service for Business Builder Worker.",
          "methods": [
            "total_tokens",
            "research",
            "generate_strategy",
            "generate_copy",
            "generate_ux_html",
            "generate_ux_css"
          ]
        },
        {
          "type": "function",
          "name": "get_llm_service",
          "purpose": "Get singleton LLM service instance."
        }
      ],
      "calls": {
        "L4": [
          "app.skills.llm_invoke_v2",
          "app.skills.llm_invoke_v2",
          "app.skills.adapters.claude_adapter"
        ]
      }
    }
  ],
  "L4": [
    {
      "file": "agents/sba/evolution.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "SBA agent evolution logic",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "DriftType",
          "purpose": "Types of drift that can be detected.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ViolationType",
          "purpose": "Types of boundary violations.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AdjustmentType",
          "purpose": "Types of strategy adjustments.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BoundaryViolation",
          "purpose": "Record of a boundary violation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "DriftSignal",
          "purpose": "Signal indicating detected drift.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "StrategyAdjustment",
          "purpose": "Record of a strategy adjustment.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "SBAEvolutionEngine",
          "purpose": "SBA Evolution Engine for self-improving agents.",
          "methods": [
            "record_violation",
            "get_violations",
            "detect_drift",
            "get_drift_signals",
            "acknowledge_drift",
            "suggest_adjustment",
            "apply_adjustment",
            "get_adjustments"
          ]
        },
        {
          "type": "function",
          "name": "get_evolution_engine",
          "purpose": "Get singleton evolution engine."
        }
      ]
    },
    {
      "file": "agents/sba/generator.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "SBA agent generation",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "GenerationQuality",
          "purpose": "Quality level of generated SBA content.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GenerationReport",
          "purpose": "M15.1.1: Report on SBA generation quality.",
          "methods": [
            "is_strict_compliant",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "SBAGenerator",
          "purpose": "Generator for Strategy-Bound Agent schemas.",
          "methods": [
            "generate",
            "generate_with_report"
          ]
        },
        {
          "type": "function",
          "name": "generate_sba_from_agent",
          "purpose": "Generate SBA schema from agent metadata."
        },
        {
          "type": "function",
          "name": "generate_sba_from_spawn_input",
          "purpose": "Generate SBA schema from AgentSpawnInput data."
        },
        {
          "type": "function",
          "name": "retrofit_existing_agents",
          "purpose": "Retrofit SBA schemas for a list of existing agents."
        }
      ]
    },
    {
      "file": "agents/sba/schema.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "SBA schema definitions",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "GovernanceProvider",
          "purpose": "Supported governance providers.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DependencyType",
          "purpose": "Types of dependencies an agent can have.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Dependency",
          "purpose": "Structured dependency declaration.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnvironmentRequirements",
          "purpose": "Environment requirements for agent execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "HowToWin",
          "purpose": "How the agent will achieve its aspiration.",
          "methods": [
            "validate_tasks_not_empty"
          ]
        },
        {
          "type": "class",
          "name": "CapabilitiesCapacity",
          "purpose": "What the agent needs to operate.",
          "methods": [
            "get_all_dependency_names",
            "get_tool_dependencies",
            "get_agent_dependencies",
            "get_required_dependencies"
          ]
        },
        {
          "type": "class",
          "name": "EnablingManagementSystems",
          "purpose": "Management systems that govern this agent.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WinningAspiration",
          "purpose": "Why the agent exists.",
          "methods": [
            "validate_not_task_list"
          ]
        },
        {
          "type": "class",
          "name": "WhereToPlay",
          "purpose": "Boundaries and scope of the agent's operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SBASchema",
          "purpose": "Strategy-Bound Agent (SBA) Schema.",
          "methods": [
            "to_dict",
            "from_dict",
            "validate_version_supported",
            "is_version_deprecated",
            "get_cascade_summary"
          ]
        },
        {
          "type": "function",
          "name": "create_minimal_sba",
          "purpose": "Create a minimal valid SBA schema."
        },
        {
          "type": "class",
          "name": "SBAVersionError",
          "purpose": "Raised when SBA version is not supported.",
          "methods": []
        },
        {
          "type": "function",
          "name": "check_version_supported",
          "purpose": "Check if an SBA version is supported."
        },
        {
          "type": "function",
          "name": "check_version_deprecated",
          "purpose": "Check if an SBA version is deprecated."
        },
        {
          "type": "function",
          "name": "negotiate_version",
          "purpose": "Negotiate SBA version."
        },
        {
          "type": "function",
          "name": "get_version_info",
          "purpose": "Get version negotiation info for API responses."
        },
        {
          "type": "function",
          "name": "create_tool_dependency",
          "purpose": "Create a tool dependency."
        },
        {
          "type": "function",
          "name": "create_agent_dependency",
          "purpose": "Create an agent dependency."
        },
        {
          "type": "function",
          "name": "create_api_dependency",
          "purpose": "Create an API dependency."
        }
      ]
    },
    {
      "file": "agents/sba/service.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "SBA service orchestration",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "AgentDefinition",
          "purpose": "Agent definition from registry.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SBAService",
          "purpose": "Service for SBA registry operations.",
          "methods": [
            "register_agent",
            "get_agent",
            "list_agents",
            "validate_for_spawn",
            "check_spawn_allowed",
            "update_sba",
            "update_fulfillment_metric",
            "compute_fulfillment_from_job",
            "get_fulfillment_history",
            "retrofit_missing_sba"
          ]
        },
        {
          "type": "function",
          "name": "get_sba_service",
          "purpose": "Get singleton SBA service instance."
        }
      ]
    },
    {
      "file": "agents/sba/validator.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "SBA agent validation",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SBAValidationErrorCode",
          "purpose": "Error codes for SBA validation failures.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SBAValidationError",
          "purpose": "A single validation error.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SBAValidationResult",
          "purpose": "Result of SBA validation.",
          "methods": [
            "to_dict",
            "get_error_summary"
          ]
        },
        {
          "type": "class",
          "name": "SBAValidator",
          "purpose": "Validator for Strategy-Bound Agent schemas.",
          "methods": [
            "validate"
          ]
        },
        {
          "type": "function",
          "name": "validate_sba",
          "purpose": "Convenience function to validate SBA data."
        },
        {
          "type": "function",
          "name": "validate_at_spawn",
          "purpose": "Validate SBA at spawn time."
        }
      ]
    },
    {
      "file": "agents/services/blackboard_service.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "BlackboardEntry",
          "purpose": "Entry in the blackboard.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LockResult",
          "purpose": "Result of a lock operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BlackboardService",
          "purpose": "Shared blackboard for M12 multi-agent coordination.",
          "methods": [
            "get",
            "set",
            "delete",
            "increment",
            "increment_float",
            "scan_pattern",
            "acquire_lock",
            "release_lock",
            "extend_lock",
            "store_result"
          ]
        },
        {
          "type": "function",
          "name": "get_blackboard_service",
          "purpose": "Get singleton blackboard service instance."
        }
      ]
    },
    {
      "file": "agents/services/credit_service.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "CreditBalance",
          "purpose": "Current credit balance for a tenant.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CreditOperation",
          "purpose": "Result of a credit operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CreditService",
          "purpose": "Credit management for M12 multi-agent system.",
          "methods": [
            "get_skill_cost",
            "check_credits",
            "get_balance",
            "check_reservation",
            "log_reservation",
            "reserve_for_job",
            "spend_for_item",
            "refund_for_item",
            "charge_skill"
          ]
        },
        {
          "type": "function",
          "name": "get_credit_service",
          "purpose": "Get singleton credit service instance."
        }
      ]
    },
    {
      "file": "agents/services/governance_service.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "BudgetStatus",
          "purpose": "Budget status for a job or worker.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RiskMetrics",
          "purpose": "Risk metrics for a job or worker.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GovernanceStatus",
          "purpose": "Combined governance status.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerBudgetCheck",
          "purpose": "Result of worker budget check.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GovernanceService",
          "purpose": "LLM Governance orchestration service.",
          "methods": [
            "get_job_budget_status",
            "get_job_risk_metrics",
            "get_job_governance_status",
            "update_job_budget",
            "check_worker_budget",
            "allocate_worker_budget",
            "get_worker_budget_status",
            "record_item_llm_usage",
            "get_governance_summary",
            "get_high_risk_items"
          ]
        },
        {
          "type": "function",
          "name": "get_governance_service",
          "purpose": "Get singleton governance service instance."
        }
      ]
    },
    {
      "file": "agents/services/invoke_audit_service.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "InvokeAuditEntry",
          "purpose": "Audit entry for an agent_invoke call.",
          "methods": []
        },
        {
          "type": "class",
          "name": "InvokeAuditService",
          "purpose": "Audit trail service for agent_invoke calls.",
          "methods": [
            "start_invoke",
            "complete_invoke",
            "fail_invoke",
            "get_by_invoke_id",
            "list_by_job",
            "list_by_caller",
            "get_stats"
          ]
        },
        {
          "type": "function",
          "name": "get_invoke_audit_service",
          "purpose": "Get singleton invoke audit service instance."
        }
      ]
    },
    {
      "file": "agents/services/job_service.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "JobConfig",
          "purpose": "Configuration for a parallel job.",
          "methods": []
        },
        {
          "type": "class",
          "name": "JobProgress",
          "purpose": "Job progress status.",
          "methods": []
        },
        {
          "type": "class",
          "name": "JobCredits",
          "purpose": "Job credit tracking.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Job",
          "purpose": "Job entity.",
          "methods": []
        },
        {
          "type": "class",
          "name": "JobItem",
          "purpose": "Individual work item in a job.",
          "methods": []
        },
        {
          "type": "class",
          "name": "JobService",
          "purpose": "Job management service for M12 multi-agent system.",
          "methods": [
            "create_job",
            "get_job",
            "list_jobs",
            "check_job_completion",
            "cancel_job",
            "get_job_items"
          ]
        },
        {
          "type": "function",
          "name": "get_job_service",
          "purpose": "Get singleton job service instance."
        }
      ]
    },
    {
      "file": "agents/services/message_service.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "Message",
          "purpose": "Agent message entity.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SendResult",
          "purpose": "Result of sending a message.",
          "methods": []
        },
        {
          "type": "class",
          "name": "MessageService",
          "purpose": "P2P messaging service for M12 multi-agent system.",
          "methods": [
            "send",
            "get_inbox",
            "get_message",
            "mark_delivered",
            "mark_read",
            "get_replies",
            "wait_for_message",
            "wait_for_reply",
            "cleanup_old_messages"
          ]
        },
        {
          "type": "function",
          "name": "get_message_service",
          "purpose": "Get singleton message service instance."
        }
      ]
    },
    {
      "file": "agents/services/registry_service.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "AgentInstance",
          "purpose": "Registered agent instance.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RegistrationResult",
          "purpose": "Result of agent registration.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RegistryService",
          "purpose": "Agent registry service for M12 multi-agent system.",
          "methods": [
            "register",
            "heartbeat",
            "deregister",
            "get_instance",
            "list_instances",
            "mark_instance_stale",
            "mark_stale",
            "reclaim_stale_items",
            "get_active_worker_count"
          ]
        },
        {
          "type": "function",
          "name": "get_registry_service",
          "purpose": "Get singleton registry service instance."
        }
      ]
    },
    {
      "file": "agents/services/retry_policy.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "RetryStopReason",
          "purpose": "Reasons for stopping retry.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RetryConfig",
          "purpose": "Configuration for retry policy.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RetryState",
          "purpose": "Current state of retry attempts.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RetryResult",
          "purpose": "Result of retry execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RetryPolicy",
          "purpose": "Retry policy for LLM calls with parameter adjustment.",
          "methods": [
            "should_retry",
            "get_adjusted_parameters",
            "get_backoff_ms",
            "execute_with_retry"
          ]
        },
        {
          "type": "function",
          "name": "get_default_retry_config",
          "purpose": "Get default retry configuration."
        },
        {
          "type": "function",
          "name": "create_retry_policy",
          "purpose": "Create a retry policy with custom settings."
        }
      ]
    },
    {
      "file": "agents/services/worker_service.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "ClaimedItem",
          "purpose": "A claimed job item ready for processing.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerStats",
          "purpose": "Statistics for a worker.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerService",
          "purpose": "Worker service for M12 multi-agent system.",
          "methods": [
            "claim_item",
            "start_item",
            "complete_item",
            "fail_item",
            "release_claimed",
            "get_worker_stats"
          ]
        },
        {
          "type": "function",
          "name": "get_worker_service",
          "purpose": "Get singleton worker service instance."
        }
      ]
    },
    {
      "file": "agents/skills/agent_invoke.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Agent-to-agent invocation skill",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "AgentInvokeInput",
          "purpose": "Input schema for agent_invoke skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AgentInvokeOutput",
          "purpose": "Output schema for agent_invoke skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AgentInvokeSkill",
          "purpose": "Skill to invoke another agent and wait for response.",
          "methods": [
            "execute",
            "respond_to_invoke",
            "get_schema"
          ]
        }
      ]
    },
    {
      "file": "agents/skills/agent_spawn.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Parallel worker agent spawn skill",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "AgentSpawnInput",
          "purpose": "Input schema for agent_spawn skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AgentSpawnOutput",
          "purpose": "Output schema for agent_spawn skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AgentSpawnSkill",
          "purpose": "Skill to spawn parallel worker agents.",
          "methods": [
            "execute",
            "get_schema"
          ]
        }
      ]
    },
    {
      "file": "agents/skills/blackboard_ops.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Blackboard read/write operations skill",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "BlackboardReadInput",
          "purpose": "Input schema for blackboard_read skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BlackboardReadOutput",
          "purpose": "Output schema for blackboard_read skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BlackboardReadSkill",
          "purpose": "Read values from shared blackboard.",
          "methods": [
            "execute",
            "get_schema"
          ]
        },
        {
          "type": "class",
          "name": "BlackboardWriteInput",
          "purpose": "Input schema for blackboard_write skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BlackboardWriteOutput",
          "purpose": "Output schema for blackboard_write skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BlackboardWriteSkill",
          "purpose": "Write values to shared blackboard.",
          "methods": [
            "execute",
            "get_schema"
          ]
        },
        {
          "type": "class",
          "name": "BlackboardLockInput",
          "purpose": "Input schema for blackboard_lock skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BlackboardLockOutput",
          "purpose": "Output schema for blackboard_lock skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BlackboardLockSkill",
          "purpose": "Distributed lock operations on blackboard.",
          "methods": [
            "execute",
            "get_schema"
          ]
        }
      ]
    },
    {
      "file": "agents/skills/llm_invoke_governed.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Governed LLM invocation skill with budget enforcement",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "LLMMessage",
          "purpose": "Chat message.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LLMInvokeGovernedInput",
          "purpose": "Input schema for governed LLM invoke skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LLMInvokeGovernedOutput",
          "purpose": "Output schema for governed LLM invoke skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GovernanceConfig",
          "purpose": "Configuration for LLM governance.",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_default_governance_config",
          "purpose": "Get governance config from environment."
        },
        {
          "type": "class",
          "name": "GovernedLLMClient",
          "purpose": "LLM client with BudgetLLM governance integration.",
          "methods": [
            "invoke",
            "get_budget_status"
          ]
        },
        {
          "type": "class",
          "name": "LLMInvokeGovernedSkill",
          "purpose": "LLM invoke skill with BudgetLLM governance.",
          "methods": [
            "execute",
            "get_schema"
          ]
        },
        {
          "type": "function",
          "name": "get_governed_llm_skill",
          "purpose": "Get or create the default governed LLM skill."
        },
        {
          "type": "async_function",
          "name": "governed_llm_invoke",
          "purpose": "Convenience function for governed LLM invoke."
        }
      ],
      "calls": {
        "L6": [
          "app.db"
        ]
      }
    },
    {
      "file": "auth/authorization.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Single source of truth for all authorization decisions",
      "temporal": {
        "trigger": "api | worker | internal",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "Decision",
          "purpose": "Authorization decision types.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AuthorizationResult",
          "purpose": "Result of an authorization check.",
          "methods": [
            "raise_if_denied"
          ]
        },
        {
          "type": "class",
          "name": "AuthorizationEngine",
          "purpose": "Core authorization engine.",
          "methods": [
            "compute_permissions",
            "authorize",
            "can_access_resource"
          ]
        },
        {
          "type": "function",
          "name": "get_authorization_engine",
          "purpose": "Get the singleton authorization engine."
        },
        {
          "type": "function",
          "name": "authorize",
          "purpose": "Convenience function for authorization checks."
        }
      ],
      "calls": {
        "L3": [
          "app.auth.actor"
        ]
      }
    },
    {
      "file": "auth/rbac.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "RBAC core logic and permission checks",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ApprovalLevel",
          "purpose": "Approval levels mapped to organizational roles.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RBACResult",
          "purpose": "Result of RBAC permission check.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RBACError",
          "purpose": "Raised when authorization check fails.",
          "methods": []
        },
        {
          "type": "function",
          "name": "check_approver_permission",
          "purpose": "Check if approver has permission to approve at the required level."
        },
        {
          "type": "function",
          "name": "require_approval_level",
          "purpose": "Decorator factory for requiring minimum approval level."
        }
      ],
      "calls": {
        "L3": [
          "app.auth.clerk_provider"
        ]
      }
    },
    {
      "file": "auth/rbac_engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "RBAC authorization engine with policy evaluation",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "get_role_approval_level",
          "purpose": "Get approval level for a role (L4 domain decision)."
        },
        {
          "type": "function",
          "name": "get_max_approval_level",
          "purpose": "Get maximum approval level from a list of roles (L4 domain decision)."
        },
        {
          "type": "function",
          "name": "map_external_role_to_aos",
          "purpose": "Map external provider role to AOS internal role (L4 domain decision)."
        },
        {
          "type": "function",
          "name": "map_external_roles_to_aos",
          "purpose": "Map list of external roles to AOS internal roles (L4 domain decision)."
        },
        {
          "type": "class",
          "name": "PolicyObject",
          "purpose": "Represents an authorization request.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Decision",
          "purpose": "Result of an authorization decision.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyConfig",
          "purpose": "Loaded policy configuration.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RBACEngine",
          "purpose": "Core RBAC authorization engine.",
          "methods": [
            "reload_policy",
            "get_policy_info",
            "check"
          ]
        },
        {
          "type": "function",
          "name": "get_policy_for_path",
          "purpose": "Map request path and method to a PolicyObject."
        },
        {
          "type": "function",
          "name": "get_rbac_engine",
          "purpose": "Get or create global RBAC engine instance."
        },
        {
          "type": "function",
          "name": "init_rbac_engine",
          "purpose": "Initialize RBAC engine with database session factory."
        },
        {
          "type": "function",
          "name": "check_permission",
          "purpose": "Programmatic permission check."
        },
        {
          "type": "function",
          "name": "require_permission",
          "purpose": "Decorator for requiring specific permissions."
        }
      ]
    },
    {
      "file": "auth/role_mapping.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Role-to-permission mapping engine",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "CustomerRole",
          "purpose": "Customer Console roles (M28).",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderRole",
          "purpose": "Founder Ops Console roles (M28).",
          "methods": []
        },
        {
          "type": "class",
          "name": "RBACRole",
          "purpose": "Canonical RBAC roles (M7).",
          "methods": []
        },
        {
          "type": "class",
          "name": "PrincipalType",
          "purpose": "Type of principal making the request.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Principal",
          "purpose": "Unified identity model extracted from request.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AuthContext",
          "purpose": "Complete auth context for every request.",
          "methods": [
            "is_founder",
            "is_tenant_scoped",
            "has_role"
          ]
        },
        {
          "type": "function",
          "name": "map_customer_role_to_rbac",
          "purpose": "Map a Customer Console role to a SINGLE canonical RBAC role."
        },
        {
          "type": "function",
          "name": "map_founder_role_to_rbac",
          "purpose": "Map a Founder Console role to a SINGLE canonical RBAC role."
        },
        {
          "type": "function",
          "name": "map_console_role_string",
          "purpose": "Map a role string to RBAC role."
        },
        {
          "type": "class",
          "name": "FounderIsolationError",
          "purpose": "Raised when founder context leaks into tenant scope.",
          "methods": []
        },
        {
          "type": "function",
          "name": "guard_founder_isolation",
          "purpose": "Founder paths must NEVER touch tenant data accidentally."
        },
        {
          "type": "function",
          "name": "get_role_hierarchy",
          "purpose": "Get role hierarchy levels (higher = more privileged)."
        },
        {
          "type": "function",
          "name": "role_subsumes",
          "purpose": "Check if a higher role subsumes a lower role."
        },
        {
          "type": "function",
          "name": "build_auth_context",
          "purpose": "Build an AuthContext from request data."
        }
      ]
    },
    {
      "file": "auth/shadow_audit.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Shadow audit logging for auth decisions",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ShadowAuditEvent",
          "purpose": "Shadow audit event for RBAC decisions.",
          "methods": [
            "to_dict",
            "to_json"
          ]
        },
        {
          "type": "class",
          "name": "ShadowAuditLogger",
          "purpose": "Shadow audit logger for RBAC decisions.",
          "methods": [
            "log_decision",
            "log_role_mapping",
            "log_founder_isolation_check"
          ]
        },
        {
          "type": "class",
          "name": "ShadowAuditAggregator",
          "purpose": "In-memory aggregation for shadow audit events.",
          "methods": [
            "record_decision",
            "record_founder_violation",
            "get_stats",
            "check_rollout_gates",
            "get_who_would_be_blocked",
            "get_recent_blocks",
            "get_founder_violations"
          ]
        },
        {
          "type": "function",
          "name": "record_shadow_audit_metric",
          "purpose": "Record shadow audit decision in Prometheus."
        }
      ]
    },
    {
      "file": "auth/stub.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "RBAC stub for CI/development - deterministic auth without external dependencies",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "StubClaims",
          "purpose": "Claims structure matching Clerk's shape.",
          "methods": []
        },
        {
          "type": "function",
          "name": "parse_stub_token",
          "purpose": "Parse a stub token into claims."
        },
        {
          "type": "function",
          "name": "is_stub_token",
          "purpose": "Check if a token is a stub token without fully parsing it."
        },
        {
          "type": "function",
          "name": "get_stub_token_for_role",
          "purpose": "Generate a stub token for a given role."
        },
        {
          "type": "function",
          "name": "stub_claims_to_dict",
          "purpose": "Convert StubClaims to a dictionary matching Clerk JWT claims format."
        },
        {
          "type": "function",
          "name": "stub_has_permission",
          "purpose": "Check if stub claims grant a required permission."
        },
        {
          "type": "function",
          "name": "stub_has_role",
          "purpose": "Check if stub claims include a required role."
        },
        {
          "type": "function",
          "name": "validate_stub_or_skip",
          "purpose": "Validate a stub token, returning claims or None."
        }
      ]
    },
    {
      "file": "auth/tier_gating.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Tier-based feature gating engine",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "TenantTier",
          "purpose": "Tenant subscription tiers.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PricingPhase",
          "purpose": "Pricing phase determines enforcement mode.",
          "methods": []
        },
        {
          "type": "function",
          "name": "resolve_tier",
          "purpose": "Resolve a plan string to a TenantTier."
        },
        {
          "type": "class",
          "name": "TierAccessResult",
          "purpose": "Result of a tier access check.",
          "methods": [
            "upgrade_required"
          ]
        },
        {
          "type": "function",
          "name": "check_tier_access",
          "purpose": "Check if a tenant tier has access to a feature."
        },
        {
          "type": "function",
          "name": "requires_tier",
          "purpose": "FastAPI dependency factory for tier-based access control."
        },
        {
          "type": "function",
          "name": "requires_feature",
          "purpose": "FastAPI dependency factory that checks tier based on feature name."
        },
        {
          "type": "function",
          "name": "tier_gated",
          "purpose": "Decorator for tier-gated endpoints (alternative to Depends)."
        },
        {
          "type": "function",
          "name": "get_tier_features",
          "purpose": "Get all features available at a given tier (including lower tiers)."
        },
        {
          "type": "function",
          "name": "get_tier_info",
          "purpose": "Get complete information about a tier."
        },
        {
          "type": "function",
          "name": "get_upgrade_path",
          "purpose": "Get upgrade information for accessing a feature."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/evidence/export/pdf"
        },
        {
          "method": "GET",
          "path": "/evidence/export/pdf"
        },
        {
          "method": "GET",
          "path": "/sba/recommendations"
        },
        {
          "method": "GET",
          "path": "/evidence/export/pdf"
        }
      ]
    },
    {
      "file": "commands/policy_command.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy evaluation and decision authority",
      "temporal": {
        "trigger": "api",
        "execution": "async (delegates to L5)"
      },
      "components": [
        {
          "type": "class",
          "name": "PolicyViolation",
          "purpose": "A policy violation detected during evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyEvaluationResult",
          "purpose": "Result from policy evaluation command.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ApprovalConfig",
          "purpose": "Approval level configuration.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "simulate_cost",
          "purpose": "Simulate cost for a skill execution."
        },
        {
          "type": "async_function",
          "name": "check_policy_violations",
          "purpose": "Check for policy violations."
        },
        {
          "type": "async_function",
          "name": "evaluate_policy",
          "purpose": "Evaluate policy for a skill execution."
        },
        {
          "type": "function",
          "name": "record_approval_created",
          "purpose": "Record that an approval request was created."
        },
        {
          "type": "function",
          "name": "record_approval_outcome",
          "purpose": "Record approval outcome (approved/rejected/expired)."
        },
        {
          "type": "function",
          "name": "record_escalation",
          "purpose": "Record that an escalation occurred."
        },
        {
          "type": "function",
          "name": "record_webhook_used",
          "purpose": "Record that webhook fallback was used."
        },
        {
          "type": "class",
          "name": "MinimalStep",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "MinimalContext",
          "purpose": null,
          "methods": []
        }
      ],
      "calls": {
        "L4": [
          "app.workflow.cost_sim",
          "app.workflow.policies",
          "app.workflow.metrics",
          "app.workflow.metrics",
          "app.workflow.metrics",
          "app.workflow.metrics",
          "app.workflow.metrics",
          "app.workflow.metrics",
          "app.workflow.metrics"
        ]
      }
    },
    {
      "file": "commands/runtime_command.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Runtime domain commands and query logic",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "QueryResult",
          "purpose": "Result from a runtime query command.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SkillInfo",
          "purpose": "Domain information about a skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ResourceContractInfo",
          "purpose": "Domain information about a resource contract.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CapabilitiesInfo",
          "purpose": "Domain information about available capabilities.",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_supported_query_types",
          "purpose": "Get list of supported query types."
        },
        {
          "type": "function",
          "name": "query_remaining_budget",
          "purpose": "Query remaining budget."
        },
        {
          "type": "function",
          "name": "query_execution_history",
          "purpose": "Query execution history."
        },
        {
          "type": "function",
          "name": "query_allowed_skills",
          "purpose": "Query list of allowed skills."
        },
        {
          "type": "function",
          "name": "query_last_step_outcome",
          "purpose": "Query last step outcome."
        },
        {
          "type": "function",
          "name": "query_skills_for_goal",
          "purpose": "Query skills available for a goal."
        },
        {
          "type": "function",
          "name": "execute_query",
          "purpose": "Execute a runtime query."
        },
        {
          "type": "function",
          "name": "get_skill_info",
          "purpose": "Get domain information about a skill."
        },
        {
          "type": "function",
          "name": "list_skills",
          "purpose": "List all available skill IDs."
        },
        {
          "type": "function",
          "name": "get_all_skill_descriptors",
          "purpose": "Get descriptors for all skills."
        },
        {
          "type": "function",
          "name": "get_resource_contract",
          "purpose": "Get resource contract information."
        },
        {
          "type": "function",
          "name": "get_capabilities",
          "purpose": "Get capabilities for an agent/tenant."
        }
      ]
    },
    {
      "file": "commands/worker_execution_command.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Worker execution authorization and delegation",
      "temporal": {
        "trigger": "api",
        "execution": "async (delegates to L5)"
      },
      "components": [
        {
          "type": "class",
          "name": "WorkerExecutionResult",
          "purpose": "Result from worker execution command.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayResult",
          "purpose": "Result from replay command.",
          "methods": []
        },
        {
          "type": "function",
          "name": "calculate_cost_cents",
          "purpose": "Calculate LLM cost in cents."
        },
        {
          "type": "function",
          "name": "get_brand_schema_types",
          "purpose": "Get brand schema types from L5."
        },
        {
          "type": "function",
          "name": "convert_brand_request",
          "purpose": "Convert API brand request to BrandSchema."
        },
        {
          "type": "async_function",
          "name": "execute_worker",
          "purpose": "Execute Business Builder Worker."
        },
        {
          "type": "async_function",
          "name": "replay_execution",
          "purpose": "Replay a previous execution."
        }
      ],
      "calls": {
        "L5": [
          "app.worker.runner",
          "app.workers.business_builder.schemas.brand",
          "app.workers.business_builder.worker",
          "app.workers.business_builder.worker"
        ]
      }
    },
    {
      "file": "contracts/common.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Common contract definitions",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "HealthDTO",
          "purpose": "GET /health response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "HealthDetailDTO",
          "purpose": "GET /health/detail response (if authenticated).",
          "methods": []
        },
        {
          "type": "class",
          "name": "ErrorDTO",
          "purpose": "Standard error response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ValidationErrorDTO",
          "purpose": "422 Validation error response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PaginationMetaDTO",
          "purpose": "Pagination metadata.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CursorPaginationMetaDTO",
          "purpose": "Cursor-based pagination metadata.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ActionResultDTO",
          "purpose": "Generic action result (activate, deactivate, etc.).",
          "methods": []
        },
        {
          "type": "class",
          "name": "ContractVersionDTO",
          "purpose": "GET /api/v1/contracts/version response.",
          "methods": []
        }
      ]
    },
    {
      "file": "contracts/decisions.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Decision contract enforcement",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "DecisionType",
          "purpose": "Types of decisions that must be recorded.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DecisionSource",
          "purpose": "Who originated the decision authority.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DecisionTrigger",
          "purpose": "Why the decision occurred.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DecisionOutcome",
          "purpose": "Result of the decision.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CausalRole",
          "purpose": "When in the lifecycle this decision occurred.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DecisionRecord",
          "purpose": "Contract-aligned decision record.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "DecisionRecordService",
          "purpose": "Append-only sink for decision records.",
          "methods": [
            "emit",
            "emit_sync"
          ]
        },
        {
          "type": "function",
          "name": "get_decision_service",
          "purpose": "Get singleton decision record service."
        },
        {
          "type": "function",
          "name": "emit_routing_decision",
          "purpose": "Emit a routing decision record."
        },
        {
          "type": "function",
          "name": "emit_recovery_decision",
          "purpose": "Emit a recovery decision record."
        },
        {
          "type": "function",
          "name": "emit_memory_decision",
          "purpose": "Emit a memory injection decision record."
        },
        {
          "type": "function",
          "name": "emit_policy_decision",
          "purpose": "Emit a policy enforcement decision record."
        },
        {
          "type": "function",
          "name": "emit_budget_decision",
          "purpose": "Emit a budget handling decision record."
        },
        {
          "type": "function",
          "name": "emit_budget_enforcement_decision",
          "purpose": "Emit a budget enforcement decision record when hard limit halts execution."
        },
        {
          "type": "function",
          "name": "emit_policy_precheck_decision",
          "purpose": "Emit a policy pre-check decision record."
        },
        {
          "type": "function",
          "name": "emit_recovery_evaluation_decision",
          "purpose": "Emit a recovery evaluation decision record."
        },
        {
          "type": "function",
          "name": "backfill_run_id_for_request",
          "purpose": "Backfill run_id for all decisions with matching request_id."
        },
        {
          "type": "class",
          "name": "CARESignalAccessError",
          "purpose": "Raised when attempting to access a forbidden CARE signal.",
          "methods": []
        },
        {
          "type": "function",
          "name": "check_signal_access",
          "purpose": "Check if a signal is allowed for CARE optimization."
        },
        {
          "type": "function",
          "name": "activate_care_kill_switch",
          "purpose": "Activate the CARE optimization kill-switch."
        },
        {
          "type": "function",
          "name": "deactivate_care_kill_switch",
          "purpose": "Deactivate the CARE optimization kill-switch."
        },
        {
          "type": "function",
          "name": "is_care_kill_switch_active",
          "purpose": "Check if CARE kill-switch is currently active."
        },
        {
          "type": "function",
          "name": "emit_care_optimization_decision",
          "purpose": "Emit a CARE routing optimization decision record."
        }
      ]
    },
    {
      "file": "contracts/guard.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Guard contract for access control",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "GuardStatusDTO",
          "purpose": "GET /guard/status response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TodaySnapshotDTO",
          "purpose": "GET /guard/snapshot/today response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentSummaryDTO",
          "purpose": "Incident list item.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentEventDTO",
          "purpose": "Timeline event within an incident.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentDetailDTO",
          "purpose": "GET /guard/incidents/{id} response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentListDTO",
          "purpose": "GET /guard/incidents response (paginated).",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerIncidentImpactDTO",
          "purpose": "Impact assessment for customers - calm, explicit.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerIncidentResolutionDTO",
          "purpose": "Resolution status for customers - reassuring.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerIncidentActionDTO",
          "purpose": "Customer action item - only if necessary.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerIncidentNarrativeDTO",
          "purpose": "GET /guard/incidents/{id} enhanced response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ApiKeyDTO",
          "purpose": "API key response (masked).",
          "methods": []
        },
        {
          "type": "class",
          "name": "ApiKeyListDTO",
          "purpose": "GET /guard/keys response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GuardrailConfigDTO",
          "purpose": "Individual guardrail configuration.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TenantSettingsDTO",
          "purpose": "GET /guard/settings response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayCallSnapshotDTO",
          "purpose": "Original call context for replay.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayCertificateDTO",
          "purpose": "Cryptographic proof of replay (M23).",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayResultDTO",
          "purpose": "POST /guard/replay/{call_id} response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "KillSwitchActionDTO",
          "purpose": "POST /guard/killswitch/activate and /deactivate response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OnboardingVerifyResponseDTO",
          "purpose": "POST /guard/onboarding/verify response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerCostSummaryDTO",
          "purpose": "GET /guard/costs/summary response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostBreakdownItemDTO",
          "purpose": "Individual cost breakdown item.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerCostExplainedDTO",
          "purpose": "GET /guard/costs/explained response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerCostIncidentDTO",
          "purpose": "Cost-related incident visible to customer.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerCostIncidentListDTO",
          "purpose": "GET /guard/costs/incidents response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        }
      ]
    },
    {
      "file": "contracts/ops.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Ops contract definitions",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SystemPulseDTO",
          "purpose": "GET /ops/pulse response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerSegmentDTO",
          "purpose": "Customer profile with engagement metrics.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerAtRiskDTO",
          "purpose": "Customer at risk of churning.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerListDTO",
          "purpose": "GET /ops/customers response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentPatternDTO",
          "purpose": "Aggregated incident pattern across all tenants.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderIncidentHeaderDTO",
          "purpose": "Incident header - dense, no prose, just facts.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderDecisionTimelineEventDTO",
          "purpose": "Single event in the decision timeline - raw truth, append-only.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderRootCauseDTO",
          "purpose": "Root cause analysis - explicit, no hedging.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderBlastRadiusDTO",
          "purpose": "Impact assessment - helps founders judge seriousness.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderRecurrenceRiskDTO",
          "purpose": "Recurrence risk analysis - strategic, not operational.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderIncidentDetailDTO",
          "purpose": "GET /ops/incidents/{id} response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderIncidentListItemDTO",
          "purpose": "Incident list item for founder console.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderIncidentListDTO",
          "purpose": "GET /ops/incidents response (paginated).",
          "methods": []
        },
        {
          "type": "class",
          "name": "StickinessByFeatureDTO",
          "purpose": "Feature engagement metrics.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RevenueRiskDTO",
          "purpose": "GET /ops/revenue response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "InfraLimitsDTO",
          "purpose": "GET /ops/infra response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PlaybookActionDTO",
          "purpose": "Individual action in a playbook.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PlaybookDTO",
          "purpose": "GET /ops/playbooks and GET /ops/playbooks/{id} response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsEventDTO",
          "purpose": "Raw ops event.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsEventListDTO",
          "purpose": "GET /ops/events response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsJobResultDTO",
          "purpose": "POST /ops/jobs/* response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderCostOverviewDTO",
          "purpose": "GET /ops/cost/overview response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderCostAnomalyDTO",
          "purpose": "Cost anomaly aggregation for founders.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderCostAnomalyListDTO",
          "purpose": "GET /ops/cost/anomalies response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderCostTenantDTO",
          "purpose": "Per-tenant cost drilldown for founders.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderCostTenantListDTO",
          "purpose": "GET /ops/cost/tenants response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostDailyBreakdownDTO",
          "purpose": "Daily cost data point.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostByFeatureDTO",
          "purpose": "Cost attribution by feature.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostByUserDTO",
          "purpose": "Cost attribution by user (top N).",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostByModelDTO",
          "purpose": "Cost attribution by LLM model.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerAnomalyHistoryDTO",
          "purpose": "Recent anomaly for this customer.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderCustomerCostDrilldownDTO",
          "purpose": "GET /ops/cost/customers/{id} response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderActionTargetDTO",
          "purpose": "Target of a founder action.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderActionReasonDTO",
          "purpose": "Reason for a founder action - required for audit trail.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderActionRequestDTO",
          "purpose": "Unified command model for all founder actions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderActionResponseDTO",
          "purpose": "Unified response for all founder actions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderAuditRecordDTO",
          "purpose": "Immutable audit record for founder actions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderReversalRequestDTO",
          "purpose": "Request to reverse a previous action.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderActionSummaryDTO",
          "purpose": "Summary of a founder action for list views.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderActionListDTO",
          "purpose": "List of recent founder actions for audit trail.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        }
      ]
    },
    {
      "file": "costsim/alert_worker.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "AlertWorker",
          "purpose": "Background worker for processing alert queue.",
          "methods": [
            "close",
            "process_batch",
            "run_continuous",
            "get_queue_stats"
          ]
        },
        {
          "type": "async_function",
          "name": "enqueue_alert",
          "purpose": "Enqueue an alert for delivery."
        },
        {
          "type": "async_function",
          "name": "retry_failed_alerts",
          "purpose": "Retry failed alerts (reset to pending)."
        },
        {
          "type": "async_function",
          "name": "purge_old_alerts",
          "purpose": "Purge old alerts from queue."
        },
        {
          "type": "async_function",
          "name": "run_alert_worker",
          "purpose": "Run alert worker continuously."
        }
      ],
      "calls": {
        "L4": [
          "app.costsim.config",
          "app.costsim.leader",
          "app.costsim.metrics"
        ],
        "L6": [
          "app.infra",
          "app.db_async",
          "app.models.costsim_cb"
        ]
      }
    },
    {
      "file": "costsim/canary.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "CanarySample",
          "purpose": "A single canary test sample.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CanaryRunConfig",
          "purpose": "Configuration for a canary run.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CanaryRunner",
          "purpose": "Daily canary runner for V2 validation.",
          "methods": [
            "run"
          ]
        },
        {
          "type": "async_function",
          "name": "run_canary",
          "purpose": "Convenience function to run canary."
        }
      ],
      "calls": {
        "L4": [
          "app.costsim.circuit_breaker",
          "app.costsim.circuit_breaker_async",
          "app.costsim.config",
          "app.costsim.leader",
          "app.costsim.models",
          "app.costsim.provenance",
          "app.costsim.v2_adapter"
        ],
        "L5": [
          "app.worker.simulate"
        ]
      }
    },
    {
      "file": "costsim/cb_sync_wrapper.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "is_v2_disabled_sync",
          "purpose": "Sync wrapper for is_v2_disabled()."
        },
        {
          "type": "function",
          "name": "get_state_sync",
          "purpose": "Sync wrapper for get_state()."
        },
        {
          "type": "function",
          "name": "shutdown_executor",
          "purpose": "Shutdown the thread pool executor gracefully."
        }
      ],
      "calls": {
        "L4": [
          "app.costsim.circuit_breaker_async",
          "app.costsim.circuit_breaker_async"
        ]
      }
    },
    {
      "file": "costsim/circuit_breaker.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "CircuitBreakerState",
          "purpose": "Current state of the circuit breaker (in-memory representation).",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "Incident",
          "purpose": "Incident record for circuit breaker trip.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CircuitBreaker",
          "purpose": "DB-backed circuit breaker for CostSim V2 auto-disable.",
          "methods": [
            "is_disabled",
            "is_open",
            "is_closed",
            "get_state",
            "report_drift",
            "report_schema_error",
            "disable_v2",
            "enable_v2",
            "reset",
            "get_incidents"
          ]
        },
        {
          "type": "function",
          "name": "get_circuit_breaker",
          "purpose": "Get the global circuit breaker instance."
        },
        {
          "type": "async_function",
          "name": "is_v2_disabled",
          "purpose": "Check if CostSim V2 is disabled."
        },
        {
          "type": "async_function",
          "name": "disable_v2",
          "purpose": "Disable CostSim V2."
        },
        {
          "type": "async_function",
          "name": "enable_v2",
          "purpose": "Enable CostSim V2."
        }
      ],
      "calls": {
        "L4": [
          "app.costsim.config"
        ],
        "L6": [
          "app.infra",
          "app.db"
        ]
      }
    },
    {
      "file": "costsim/circuit_breaker_async.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "CircuitBreakerState",
          "purpose": "Current state of the circuit breaker.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "Incident",
          "purpose": "Incident record for circuit breaker trip.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "async_function",
          "name": "is_v2_disabled",
          "purpose": "Check if V2 is disabled."
        },
        {
          "type": "async_function",
          "name": "get_state",
          "purpose": "Get current circuit breaker state."
        },
        {
          "type": "async_function",
          "name": "report_drift",
          "purpose": "Report drift observation."
        },
        {
          "type": "async_function",
          "name": "report_schema_error",
          "purpose": "Report schema validation errors."
        },
        {
          "type": "async_function",
          "name": "disable_v2",
          "purpose": "Manually disable CostSim V2."
        },
        {
          "type": "async_function",
          "name": "enable_v2",
          "purpose": "Manually enable CostSim V2."
        },
        {
          "type": "async_function",
          "name": "get_incidents",
          "purpose": "Get recent incidents."
        },
        {
          "type": "class",
          "name": "AsyncCircuitBreaker",
          "purpose": "Async circuit breaker class for compatibility with existing code.",
          "methods": [
            "is_disabled",
            "is_open",
            "is_closed",
            "get_state",
            "report_drift",
            "report_schema_error",
            "disable_v2",
            "enable_v2",
            "reset",
            "reset_v2"
          ]
        },
        {
          "type": "function",
          "name": "get_async_circuit_breaker",
          "purpose": "Get the global async circuit breaker instance."
        }
      ],
      "calls": {
        "L4": [
          "app.costsim.config",
          "app.costsim.metrics",
          "app.costsim.cb_sync_wrapper"
        ],
        "L6": [
          "app.infra",
          "app.db_async",
          "app.models.costsim_cb"
        ]
      }
    },
    {
      "file": "costsim/config.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "CostSimConfig",
          "purpose": "Configuration for CostSim V2.",
          "methods": [
            "from_env"
          ]
        },
        {
          "type": "function",
          "name": "get_config",
          "purpose": "Get the global CostSim configuration."
        },
        {
          "type": "function",
          "name": "is_v2_sandbox_enabled",
          "purpose": "Check if V2 sandbox is enabled."
        },
        {
          "type": "function",
          "name": "is_v2_disabled_by_drift",
          "purpose": "Check if V2 was auto-disabled due to drift."
        },
        {
          "type": "function",
          "name": "get_commit_sha",
          "purpose": "Get current git commit SHA."
        }
      ]
    },
    {
      "file": "costsim/datasets.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "DatasetSample",
          "purpose": "A single sample in a reference dataset.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReferenceDataset",
          "purpose": "A reference dataset for validation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "DatasetValidator",
          "purpose": "Validator for V2 against reference datasets.",
          "methods": [
            "list_datasets",
            "get_dataset",
            "validate_dataset",
            "validate_all"
          ]
        },
        {
          "type": "function",
          "name": "get_dataset_validator",
          "purpose": "Get the global dataset validator."
        },
        {
          "type": "async_function",
          "name": "validate_dataset",
          "purpose": "Convenience function to validate a dataset."
        },
        {
          "type": "async_function",
          "name": "validate_all_datasets",
          "purpose": "Convenience function to validate all datasets."
        }
      ],
      "calls": {
        "L4": [
          "app.costsim.models",
          "app.costsim.v2_adapter"
        ]
      }
    },
    {
      "file": "costsim/divergence.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "DivergenceSample",
          "purpose": "A single sample for divergence analysis.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DivergenceAnalyzer",
          "purpose": "Analyzer for V1 vs V2 cost divergence.",
          "methods": [
            "generate_report"
          ]
        },
        {
          "type": "async_function",
          "name": "generate_divergence_report",
          "purpose": "Convenience function to generate a divergence report."
        }
      ],
      "calls": {
        "L4": [
          "app.costsim.config",
          "app.costsim.models",
          "app.costsim.provenance"
        ]
      }
    },
    {
      "file": "costsim/leader.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "async_function",
          "name": "try_acquire_leader_lock",
          "purpose": "Try to acquire an advisory lock (non-blocking)."
        },
        {
          "type": "async_function",
          "name": "release_leader_lock",
          "purpose": "Explicitly release an advisory lock."
        },
        {
          "type": "async_function",
          "name": "is_lock_held",
          "purpose": "Check if a lock is currently held by any session."
        },
        {
          "type": "class",
          "name": "LeaderContext",
          "purpose": "Async context manager for leader election.",
          "methods": [
            "is_leader"
          ]
        },
        {
          "type": "async_function",
          "name": "leader_election",
          "purpose": "Context manager for leader election."
        },
        {
          "type": "async_function",
          "name": "with_leader_lock",
          "purpose": "Execute callback only if we can acquire leadership."
        },
        {
          "type": "async_function",
          "name": "with_canary_lock",
          "purpose": "Execute callback with canary runner lock."
        },
        {
          "type": "async_function",
          "name": "with_alert_worker_lock",
          "purpose": "Execute callback with alert worker lock."
        },
        {
          "type": "async_function",
          "name": "with_archiver_lock",
          "purpose": "Execute callback with provenance archiver lock."
        }
      ],
      "calls": {
        "L6": [
          "app.db_async"
        ]
      }
    },
    {
      "file": "costsim/metrics.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "CostSimMetrics",
          "purpose": "Prometheus metrics for CostSim V2.",
          "methods": [
            "record_drift",
            "record_cost_delta",
            "record_schema_error",
            "record_simulation_duration",
            "record_simulation",
            "set_circuit_breaker_state",
            "record_provenance_log",
            "record_canary_run",
            "set_kl_divergence",
            "record_cb_disabled"
          ]
        },
        {
          "type": "function",
          "name": "get_metrics",
          "purpose": "Get the global CostSim metrics instance."
        },
        {
          "type": "function",
          "name": "get_alert_rules",
          "purpose": "Get Prometheus alert rules YAML."
        }
      ],
      "calls": {
        "L4": [
          "app.costsim.config"
        ]
      }
    },
    {
      "file": "costsim/models.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "V2SimulationStatus",
          "purpose": "V2 simulation result status.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ComparisonVerdict",
          "purpose": "Verdict from V1 vs V2 comparison.",
          "methods": []
        },
        {
          "type": "class",
          "name": "V2SimulationResult",
          "purpose": "Result from CostSim V2 simulation.",
          "methods": [
            "to_dict",
            "compute_output_hash"
          ]
        },
        {
          "type": "class",
          "name": "ComparisonResult",
          "purpose": "Result of comparing V2 vs V1 simulation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "DiffResult",
          "purpose": "Detailed diff between two simulation results.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CanaryReport",
          "purpose": "Report from daily canary run.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "DivergenceReport",
          "purpose": "Cost divergence report between V1 and V2.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "ValidationResult",
          "purpose": "Result of validating V2 against a reference dataset.",
          "methods": [
            "to_dict"
          ]
        }
      ]
    },
    {
      "file": "costsim/provenance.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "ProvenanceLog",
          "purpose": "Single provenance log entry.",
          "methods": [
            "to_dict",
            "from_dict",
            "get_decompressed_input",
            "get_decompressed_output"
          ]
        },
        {
          "type": "function",
          "name": "compute_hash",
          "purpose": "Compute SHA256 hash of data."
        },
        {
          "type": "function",
          "name": "compress_json",
          "purpose": "Compress JSON data to base64-encoded gzip."
        },
        {
          "type": "class",
          "name": "ProvenanceLogger",
          "purpose": "Logger for CostSim V2 provenance.",
          "methods": [
            "log",
            "close",
            "query"
          ]
        },
        {
          "type": "function",
          "name": "get_provenance_logger",
          "purpose": "Get the global provenance logger."
        }
      ],
      "calls": {
        "L4": [
          "app.costsim.config"
        ]
      }
    },
    {
      "file": "costsim/provenance_async.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "async_function",
          "name": "write_provenance",
          "purpose": "Write a single provenance record."
        },
        {
          "type": "async_function",
          "name": "write_provenance_batch",
          "purpose": "Write multiple provenance records in a single transaction."
        },
        {
          "type": "async_function",
          "name": "query_provenance",
          "purpose": "Query provenance records."
        },
        {
          "type": "async_function",
          "name": "count_provenance",
          "purpose": "Count provenance records matching filters."
        },
        {
          "type": "async_function",
          "name": "get_drift_stats",
          "purpose": "Get drift statistics between V1 and V2 costs."
        },
        {
          "type": "async_function",
          "name": "check_duplicate",
          "purpose": "Check if a record with this input hash already exists."
        },
        {
          "type": "function",
          "name": "compute_input_hash",
          "purpose": "Compute deterministic hash of input payload."
        },
        {
          "type": "async_function",
          "name": "backfill_v1_baseline",
          "purpose": "Backfill V1 baseline records from historical data."
        }
      ],
      "calls": {
        "L6": [
          "app.db_async",
          "app.models.costsim_cb"
        ]
      }
    },
    {
      "file": "costsim/sandbox.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "SandboxResult",
          "purpose": "Result from sandbox routing.",
          "methods": [
            "production_result"
          ]
        },
        {
          "type": "class",
          "name": "CostSimSandbox",
          "purpose": "Sandbox router for CostSim V1 vs V2.",
          "methods": [
            "simulate"
          ]
        },
        {
          "type": "async_function",
          "name": "simulate_with_sandbox",
          "purpose": "Convenience function for sandbox simulation."
        },
        {
          "type": "function",
          "name": "get_sandbox",
          "purpose": "Get a sandbox instance."
        }
      ],
      "calls": {
        "L4": [
          "app.costsim.circuit_breaker_async",
          "app.costsim.config",
          "app.costsim.models",
          "app.costsim.v2_adapter"
        ],
        "L5": [
          "app.worker.simulate"
        ]
      }
    },
    {
      "file": "discovery/ledger.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Discovery ledger for artifact tracking",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "DiscoverySignal",
          "purpose": "Discovery signal data model.",
          "methods": []
        },
        {
          "type": "function",
          "name": "emit_signal",
          "purpose": "Record a discovery signal to the ledger."
        },
        {
          "type": "function",
          "name": "get_signals",
          "purpose": "Query discovery signals from the ledger."
        }
      ],
      "calls": {
        "L6": [
          "app.db",
          "app.db"
        ]
      }
    },
    {
      "file": "domain/failure_intelligence.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Canonical export surface for failure intelligence domain concepts",
      "temporal": {
        "trigger": "internal",
        "execution": "sync"
      },
      "calls": {
        "L4": [
          "app.jobs.failure_classification_engine",
          "app.services.recovery_rule_engine",
          "app.services.recovery_rule_engine"
        ]
      }
    },
    {
      "file": "integrations/__init__.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "M25 Pillar Integration \u2014 internal domain coordination",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "get_dispatcher",
          "purpose": "Get the singleton M25 integration dispatcher."
        },
        {
          "type": "async_function",
          "name": "trigger_integration_loop",
          "purpose": "Trigger the M25 integration loop for a newly created incident."
        }
      ],
      "calls": {
        "L6": [
          "app.db"
        ]
      }
    },
    {
      "file": "integrations/bridges.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Integration bridge abstractions",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PolicyActivationAudit",
          "purpose": "Audit record for policy activation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "async_function",
          "name": "record_policy_activation",
          "purpose": "Record policy activation for audit trail."
        },
        {
          "type": "class",
          "name": "BaseBridge",
          "purpose": "Base class for all integration bridges.",
          "methods": [
            "stage",
            "process",
            "register"
          ]
        },
        {
          "type": "class",
          "name": "IncidentToCatalogBridge",
          "purpose": "Bridge 1: Route incidents to failure catalog.",
          "methods": [
            "stage",
            "process"
          ]
        },
        {
          "type": "class",
          "name": "PatternToRecoveryBridge",
          "purpose": "Bridge 2: Generate recovery suggestions from patterns.",
          "methods": [
            "stage",
            "process"
          ]
        },
        {
          "type": "class",
          "name": "RecoveryToPolicyBridge",
          "purpose": "Bridge 3: Convert applied recovery into prevention policy.",
          "methods": [
            "stage",
            "process"
          ]
        },
        {
          "type": "class",
          "name": "PolicyToRoutingBridge",
          "purpose": "Bridge 4: Update CARE routing based on new policy.",
          "methods": [
            "stage",
            "process"
          ]
        },
        {
          "type": "class",
          "name": "LoopStatusBridge",
          "purpose": "Bridge 5: Aggregate loop status for console display.",
          "methods": [
            "stage",
            "process"
          ]
        },
        {
          "type": "function",
          "name": "create_bridges",
          "purpose": "Create all bridges with shared configuration."
        },
        {
          "type": "function",
          "name": "register_all_bridges",
          "purpose": "Register all bridges with the dispatcher."
        }
      ]
    },
    {
      "file": "integrations/cost_bridges.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Cost-related integration bridges",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "AnomalyType",
          "purpose": "Types of cost anomalies.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AnomalySeverity",
          "purpose": "Severity levels for cost anomalies.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostAnomaly",
          "purpose": "Detected cost anomaly from M26 Cost Intelligence.",
          "methods": [
            "create",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CostLoopBridge",
          "purpose": "Bridge C1: Cost Anomaly \u2192 M25 Integration Loop.",
          "methods": [
            "on_anomaly_detected"
          ]
        },
        {
          "type": "class",
          "name": "CostPatternMatcher",
          "purpose": "Bridge C2: Match cost anomalies to failure patterns.",
          "methods": [
            "match_cost_pattern"
          ]
        },
        {
          "type": "class",
          "name": "CostRecoveryGenerator",
          "purpose": "Bridge C3: Generate recovery suggestions for cost anomalies.",
          "methods": [
            "generate_recovery"
          ]
        },
        {
          "type": "class",
          "name": "CostPolicyGenerator",
          "purpose": "Bridge C4: Generate policies from cost recoveries.",
          "methods": [
            "generate_policy"
          ]
        },
        {
          "type": "class",
          "name": "CostRoutingAdjuster",
          "purpose": "Bridge C5: Adjust CARE routing based on cost policies.",
          "methods": [
            "on_cost_policy_created"
          ]
        },
        {
          "type": "class",
          "name": "CostEstimationProbe",
          "purpose": "CARE probe that estimates request cost before execution.",
          "methods": [
            "probe"
          ]
        },
        {
          "type": "class",
          "name": "CostLoopOrchestrator",
          "purpose": "Orchestrates the full M27 cost loop:",
          "methods": [
            "process_anomaly"
          ]
        }
      ],
      "calls": {
        "external": [
          "app.integrations.events"
        ]
      }
    },
    {
      "file": "integrations/cost_safety_rails.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Cost safety rail enforcement",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SafetyConfig",
          "purpose": "M27 Safety Configuration.",
          "methods": [
            "production",
            "testing"
          ]
        },
        {
          "type": "class",
          "name": "CostSafetyRails",
          "purpose": "Enforces M27 safety limits.",
          "methods": [
            "can_auto_apply_policy",
            "can_auto_apply_recovery",
            "can_auto_apply_routing",
            "record_action",
            "get_status"
          ]
        },
        {
          "type": "class",
          "name": "SafeCostLoopOrchestrator",
          "purpose": "Wraps CostLoopOrchestrator with safety rails.",
          "methods": [
            "process_anomaly_safe"
          ]
        },
        {
          "type": "function",
          "name": "get_safety_rails",
          "purpose": "Get or create default safety rails instance."
        }
      ],
      "calls": {
        "external": [
          "app.integrations.cost_bridges"
        ]
      }
    },
    {
      "file": "integrations/cost_snapshots.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Cost snapshot management",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SnapshotType",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "SnapshotStatus",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "EntityType",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "CostSnapshot",
          "purpose": "Point-in-time cost snapshot definition.",
          "methods": [
            "create",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "SnapshotAggregate",
          "purpose": "Aggregated cost data for an entity within a snapshot.",
          "methods": [
            "create"
          ]
        },
        {
          "type": "class",
          "name": "SnapshotBaseline",
          "purpose": "Rolling baseline for an entity (used for anomaly threshold).",
          "methods": [
            "create"
          ]
        },
        {
          "type": "class",
          "name": "AnomalyEvaluation",
          "purpose": "Audit record for an anomaly evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SnapshotComputer",
          "purpose": "Computes cost snapshots from raw cost_records.",
          "methods": [
            "compute_hourly_snapshot",
            "compute_daily_snapshot"
          ]
        },
        {
          "type": "class",
          "name": "BaselineComputer",
          "purpose": "Computes rolling baselines from historical snapshots.",
          "methods": [
            "compute_baselines"
          ]
        },
        {
          "type": "class",
          "name": "SnapshotAnomalyDetector",
          "purpose": "Detects anomalies from complete snapshots only.",
          "methods": [
            "evaluate_snapshot"
          ]
        },
        {
          "type": "async_function",
          "name": "run_hourly_snapshot_job",
          "purpose": "Run hourly snapshot job for multiple tenants."
        },
        {
          "type": "async_function",
          "name": "run_daily_snapshot_and_baseline_job",
          "purpose": "Run daily snapshot and baseline computation for multiple tenants."
        }
      ]
    },
    {
      "file": "integrations/events.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Integration event definitions",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ConfidenceCalculator",
          "purpose": "Centralized confidence calculation.",
          "methods": [
            "calculate_recovery_confidence",
            "should_auto_apply",
            "get_confirmation_level"
          ]
        },
        {
          "type": "function",
          "name": "ensure_json_serializable",
          "purpose": "Guard function to ensure all objects stored in details are JSON-serializable."
        },
        {
          "type": "class",
          "name": "ConfidenceBand",
          "purpose": "Confidence classification for pattern matching.",
          "methods": [
            "from_confidence",
            "allows_auto_apply",
            "requires_human_review"
          ]
        },
        {
          "type": "class",
          "name": "LoopStage",
          "purpose": "Stages in the integration feedback loop.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LoopFailureState",
          "purpose": "Explicit failure states for when the loop doesn't complete.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyMode",
          "purpose": "Policy activation modes for safety.",
          "methods": []
        },
        {
          "type": "class",
          "name": "HumanCheckpointType",
          "purpose": "Types of human intervention points.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LoopEvent",
          "purpose": "Base event for integration loop.",
          "methods": [
            "create",
            "is_success",
            "is_blocked",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "PatternMatchResult",
          "purpose": "Result of Bridge 1: Incident \u2192 Failure Catalog.",
          "methods": [
            "from_match",
            "no_match",
            "should_auto_proceed",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "RecoverySuggestion",
          "purpose": "Result of Bridge 2: Pattern \u2192 Recovery.",
          "methods": [
            "create",
            "none_available",
            "add_confirmation",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "PolicyRule",
          "purpose": "Result of Bridge 3: Recovery \u2192 Policy.",
          "methods": [
            "create",
            "record_shadow_evaluation",
            "add_confirmation",
            "record_regret",
            "shadow_block_rate",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "RoutingAdjustment",
          "purpose": "Result of Bridge 4: Policy \u2192 CARE Routing.",
          "methods": [
            "create",
            "check_kpi_regression",
            "rollback",
            "effective_magnitude",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "HumanCheckpoint",
          "purpose": "Human intervention point in the loop.",
          "methods": [
            "create",
            "resolve",
            "is_pending"
          ]
        },
        {
          "type": "class",
          "name": "LoopStatus",
          "purpose": "Complete status of an integration loop instance.",
          "methods": [
            "completion_pct",
            "to_console_display",
            "to_dict"
          ]
        }
      ]
    },
    {
      "file": "integrations/graduation_engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Agent graduation evaluation domain logic (pure computation)",
      "temporal": {
        "trigger": "api|worker (called by L5)",
        "execution": "sync (REQUIRED - async forbidden)"
      },
      "components": [
        {
          "type": "class",
          "name": "GraduationThresholds",
          "purpose": "Configurable thresholds for graduation gates.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GateEvidence",
          "purpose": "Evidence for a single gate - computed from database.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GraduationEvidence",
          "purpose": "All evidence needed to compute graduation status.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GraduationLevel",
          "purpose": "Graduation levels - derived from evidence.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ComputedGraduationStatus",
          "purpose": "Graduation status computed from evidence.",
          "methods": [
            "is_graduated",
            "is_degraded",
            "status_label",
            "to_api_response"
          ]
        },
        {
          "type": "class",
          "name": "GraduationEngine",
          "purpose": "Computes graduation status from evidence.",
          "methods": [
            "compute"
          ]
        },
        {
          "type": "class",
          "name": "CapabilityGates",
          "purpose": "Capabilities that are LOCKED until graduation passes specific gates.",
          "methods": [
            "can_auto_apply_recovery",
            "can_auto_activate_policy",
            "can_full_auto_routing",
            "get_blocked_capabilities",
            "get_unlocked_capabilities"
          ]
        },
        {
          "type": "class",
          "name": "SimulationState",
          "purpose": "Simulation state - SEPARATE from real graduation.",
          "methods": [
            "is_demo_mode",
            "to_display"
          ]
        }
      ]
    },
    {
      "file": "integrations/learning_proof.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Learning proof generation",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PreventionOutcome",
          "purpose": "Outcome of a prevention attempt.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PreventionRecord",
          "purpose": "Evidence that a policy prevented a recurrence.",
          "methods": [
            "create_prevention",
            "to_console_timeline"
          ]
        },
        {
          "type": "class",
          "name": "PreventionTracker",
          "purpose": "Tracks prevention effectiveness across policies.",
          "methods": [
            "record_prevention",
            "record_failure",
            "prevention_rate",
            "has_proven_prevention",
            "get_top_preventing_patterns"
          ]
        },
        {
          "type": "class",
          "name": "RegretType",
          "purpose": "Types of policy regret.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RegretEvent",
          "purpose": "A single regret event - when a policy caused harm.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyRegretTracker",
          "purpose": "Tracks regret for individual policies.",
          "methods": [
            "add_regret",
            "decay_regret",
            "is_demoted",
            "to_rollback_timeline"
          ]
        },
        {
          "type": "class",
          "name": "GlobalRegretTracker",
          "purpose": "System-wide regret tracking.",
          "methods": [
            "get_or_create_tracker",
            "record_regret",
            "has_proven_rollback",
            "system_regret_rate"
          ]
        },
        {
          "type": "class",
          "name": "PatternCalibration",
          "purpose": "Per-pattern confidence calibration based on actual outcomes.",
          "methods": [
            "record_outcome",
            "accuracy",
            "is_calibrated",
            "get_calibrated_band"
          ]
        },
        {
          "type": "class",
          "name": "AdaptiveConfidenceSystem",
          "purpose": "System-wide adaptive confidence management.",
          "methods": [
            "get_or_create_calibration",
            "record_outcome",
            "get_threshold_for_pattern",
            "get_confidence_report"
          ]
        },
        {
          "type": "class",
          "name": "CheckpointPriority",
          "purpose": "Priority levels for human checkpoints.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CheckpointConfig",
          "purpose": "Per-tenant checkpoint configuration.",
          "methods": [
            "is_blocking",
            "get_priority",
            "should_auto_dismiss"
          ]
        },
        {
          "type": "class",
          "name": "PrioritizedCheckpoint",
          "purpose": "Enhanced checkpoint with priority and configurability.",
          "methods": [
            "create",
            "check_auto_dismiss"
          ]
        },
        {
          "type": "class",
          "name": "M25GraduationStatus",
          "purpose": "The three gates that graduate M25 from \"loop-enabled\" to \"loop-proven\".",
          "methods": [
            "gate1_passed",
            "gate2_passed",
            "gate3_passed",
            "is_graduated",
            "status_label",
            "to_dashboard"
          ]
        },
        {
          "type": "class",
          "name": "PreventionTimeline",
          "purpose": "Console-ready timeline showing the learning loop in action.",
          "methods": [
            "add_incident_created",
            "add_policy_born",
            "add_prevention",
            "add_regret",
            "add_rollback",
            "to_console"
          ]
        }
      ]
    },
    {
      "file": "integrations/prevention_contract.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Prevention contract enforcement",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PreventionContractViolation",
          "purpose": "Raised when a prevention record would violate the contract.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PreventionCandidate",
          "purpose": "Candidate for prevention record creation.",
          "methods": []
        },
        {
          "type": "function",
          "name": "validate_prevention_candidate",
          "purpose": "Validate that a prevention candidate satisfies the contract."
        },
        {
          "type": "function",
          "name": "assert_prevention_immutable",
          "purpose": "Assert that a prevention record has not been modified."
        },
        {
          "type": "function",
          "name": "assert_no_deletion",
          "purpose": "Assert that a prevention record cannot be deleted."
        },
        {
          "type": "function",
          "name": "validate_prevention_for_graduation",
          "purpose": "Validate that a prevention record counts toward graduation."
        }
      ]
    },
    {
      "file": "jobs/failure_classification_engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Failure pattern classification and aggregation logic",
      "temporal": {
        "trigger": "api|worker (called by L5)",
        "execution": "sync (REQUIRED - async forbidden)"
      },
      "components": [
        {
          "type": "class",
          "name": "FailurePattern",
          "purpose": "Input: Raw failure pattern from database query.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AggregatedPattern",
          "purpose": "Output: Aggregated failure pattern with classification.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SummaryStats",
          "purpose": "Output: Summary statistics for patterns.",
          "methods": []
        },
        {
          "type": "function",
          "name": "compute_signature",
          "purpose": "Compute deterministic signature for error grouping."
        },
        {
          "type": "function",
          "name": "aggregate_patterns",
          "purpose": "Aggregate patterns by signature for deduplication."
        },
        {
          "type": "function",
          "name": "get_summary_stats",
          "purpose": "Generate summary statistics for logging/alerting."
        }
      ],
      "calls": {
        "L4": [
          "app.services.recovery_rule_engine"
        ],
        "L6": [
          "app.infra"
        ]
      }
    },
    {
      "file": "learning/config.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Learning system configuration",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "learning_enabled",
          "purpose": "Check if learning is enabled."
        },
        {
          "type": "function",
          "name": "set_learning_enabled",
          "purpose": "Set learning enabled state."
        },
        {
          "type": "function",
          "name": "require_learning_enabled",
          "purpose": "Decorator that skips function execution when learning is disabled."
        }
      ]
    },
    {
      "file": "learning/s1_rollback.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "S1 rollback learning and suggestions",
      "temporal": {
        "trigger": "worker|scheduler",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "RollbackStats",
          "purpose": "Aggregated rollback statistics for a parameter.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RollbackObserver",
          "purpose": "C5-S1 Rollback Observer.",
          "methods": [
            "get_suggestions",
            "observe"
          ]
        },
        {
          "type": "function",
          "name": "get_rollback_observer",
          "purpose": "Get the module-level rollback observer instance."
        },
        {
          "type": "function",
          "name": "observe_rollback_frequency",
          "purpose": "Convenience function to observe rollback frequency."
        }
      ],
      "calls": {
        "L4": [
          "app.learning.config",
          "app.learning.suggestions",
          "app.optimization.envelope"
        ]
      }
    },
    {
      "file": "learning/suggestions.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Learning-based suggestion generation",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SuggestionConfidence",
          "purpose": "Confidence level for suggestions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SuggestionStatus",
          "purpose": "Lifecycle status for suggestions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ObservationWindow",
          "purpose": "Time window for observation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RollbackObservation",
          "purpose": "Observation data for C5-S1 (rollback frequency).",
          "methods": []
        },
        {
          "type": "class",
          "name": "LearningSuggestion",
          "purpose": "C5 Learning Suggestion - Advisory Only.",
          "methods": [
            "acknowledge",
            "dismiss",
            "mark_applied_externally",
            "to_dict",
            "from_dict"
          ]
        },
        {
          "type": "function",
          "name": "validate_suggestion_text",
          "purpose": "Validate that suggestion text uses observational language only."
        }
      ]
    },
    {
      "file": "memory/drift_detector.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "TraceStep",
          "purpose": "Single step in an execution trace.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExecutionTrace",
          "purpose": "Complete execution trace.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DriftPoint",
          "purpose": "Point where drift was detected.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DriftResult",
          "purpose": "Result of drift comparison.",
          "methods": [
            "severity"
          ]
        },
        {
          "type": "class",
          "name": "DriftDetector",
          "purpose": "Detects determinism drift between execution traces.",
          "methods": [
            "compare"
          ]
        },
        {
          "type": "function",
          "name": "get_drift_detector",
          "purpose": "Get or create global drift detector."
        },
        {
          "type": "function",
          "name": "init_drift_detector",
          "purpose": "Initialize global drift detector."
        }
      ]
    },
    {
      "file": "memory/embedding_cache.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "compute_cache_key",
          "purpose": "Compute cache key for embedding lookup."
        },
        {
          "type": "class",
          "name": "EmbeddingCache",
          "purpose": "Redis-based embedding cache.",
          "methods": [
            "get",
            "set",
            "invalidate",
            "clear_all",
            "stats"
          ]
        },
        {
          "type": "function",
          "name": "get_embedding_cache",
          "purpose": "Get singleton embedding cache instance."
        }
      ],
      "calls": {
        "L6": [
          "app.utils.metrics_helpers"
        ]
      }
    },
    {
      "file": "memory/embedding_metrics.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "update_index_stats",
          "purpose": "Update index statistics gauges."
        },
        {
          "type": "function",
          "name": "update_backfill_progress",
          "purpose": "Update backfill progress gauges."
        },
        {
          "type": "function",
          "name": "check_embedding_quota",
          "purpose": "Check if embedding quota allows new requests."
        },
        {
          "type": "function",
          "name": "increment_embedding_count",
          "purpose": "Increment daily embedding call count."
        },
        {
          "type": "function",
          "name": "get_embedding_quota_status",
          "purpose": "Get current quota status."
        }
      ],
      "calls": {
        "L6": [
          "app.utils.metrics_helpers"
        ]
      }
    },
    {
      "file": "memory/iaec.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "InstructionType",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "TemporalSignature",
          "purpose": "Temporal signature for drift control (32 dimensions).",
          "methods": [
            "encode",
            "to_dict",
            "current",
            "is_compatible",
            "version_key"
          ]
        },
        {
          "type": "class",
          "name": "TemporalMediator",
          "purpose": "Transform DAG Manager for cross-version embedding transformation.",
          "methods": [
            "set_current_signature",
            "register_transform",
            "compute_transform",
            "can_mediate",
            "mediate",
            "collapse_transitive",
            "prune_old_versions",
            "get_dag_stats",
            "serialize",
            "deserialize"
          ]
        },
        {
          "type": "class",
          "name": "PolicyEncoding",
          "purpose": "Policy slot encoding (32 dimensions) with 5-level hierarchy support.",
          "methods": [
            "encode",
            "stack",
            "fold",
            "get_folded_vector",
            "to_dict",
            "from_id",
            "from_stack"
          ]
        },
        {
          "type": "class",
          "name": "SlotBasis",
          "purpose": "Stores original slot vectors for reversible decomposition.",
          "methods": [
            "to_bytes",
            "from_bytes"
          ]
        },
        {
          "type": "class",
          "name": "CompositeEmbedding",
          "purpose": "Result of IAEC composition with full provenance and reversibility.",
          "methods": [
            "to_list",
            "dimensions",
            "to_provenance_dict",
            "can_decompose"
          ]
        },
        {
          "type": "class",
          "name": "DecomposedEmbedding",
          "purpose": "Result of IAEC decomposition with all 4 slots.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "MismatchWarning",
          "purpose": "Warning for instruction-query semantic mismatch with corrective action.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CorrectiveAction",
          "purpose": "Prescriptive corrective action for mismatch resolution.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CorrectionCooldown",
          "purpose": "v3.2: Prevents oscillation loops in corrective actions.",
          "methods": [
            "can_correct",
            "record_correction",
            "get_cooldown_state"
          ]
        },
        {
          "type": "function",
          "name": "get_correction_cooldown",
          "purpose": "Get global correction cooldown instance."
        },
        {
          "type": "class",
          "name": "IntegrityCheckResult",
          "purpose": "Result of slot integrity verification.",
          "methods": []
        },
        {
          "type": "class",
          "name": "InstructionAwareEmbeddingComposer",
          "purpose": "Instruction-Aware Embedding Composer (IAEC) v3.0",
          "methods": [
            "initialize",
            "get_whitening_info",
            "compose",
            "decompose",
            "verify_integrity",
            "verify_provenance",
            "similarity",
            "get_instruction_types",
            "get_weights",
            "get_segment_info"
          ]
        },
        {
          "type": "async_function",
          "name": "get_iaec",
          "purpose": "Get singleton IAEC instance."
        },
        {
          "type": "async_function",
          "name": "compose_embedding",
          "purpose": "Convenience function to compose an embedding."
        },
        {
          "type": "async_function",
          "name": "compose_for_routing",
          "purpose": "Compose embedding optimized for routing decisions."
        },
        {
          "type": "async_function",
          "name": "compose_for_search",
          "purpose": "Compose embedding optimized for semantic search."
        },
        {
          "type": "async_function",
          "name": "decompose_embedding",
          "purpose": "Decompose an embedding back to slots."
        },
        {
          "type": "async_function",
          "name": "check_instruction_query_match",
          "purpose": "Check if instruction and query are semantically compatible."
        },
        {
          "type": "async_function",
          "name": "verify_embedding_integrity",
          "purpose": "Verify slot integrity of an embedding."
        }
      ],
      "calls": {
        "L4": [
          "app.memory.vector_store"
        ]
      }
    },
    {
      "file": "memory/memory_service.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "MemoryEntry",
          "purpose": "Memory entry with metadata.",
          "methods": []
        },
        {
          "type": "class",
          "name": "MemoryResult",
          "purpose": "Result of memory operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "MemoryService",
          "purpose": "Memory service with caching and fail-open behavior.",
          "methods": [
            "get",
            "set",
            "delete",
            "list"
          ]
        },
        {
          "type": "function",
          "name": "get_memory_service",
          "purpose": "Get global memory service instance."
        },
        {
          "type": "function",
          "name": "init_memory_service",
          "purpose": "Initialize global memory service."
        }
      ],
      "calls": {
        "L4": [
          "app.contracts.decisions"
        ]
      }
    },
    {
      "file": "memory/retriever.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "MemoryRetriever",
          "purpose": "Retrieves memories and builds context for planners.",
          "methods": [
            "get_context_for_planning"
          ]
        },
        {
          "type": "function",
          "name": "get_retriever",
          "purpose": "Get the singleton memory retriever instance."
        }
      ]
    },
    {
      "file": "memory/store.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "MemoryStore",
          "purpose": "Protocol for memory storage backends.",
          "methods": [
            "store",
            "get",
            "list_by_agent",
            "search",
            "delete"
          ]
        },
        {
          "type": "class",
          "name": "PostgresMemoryStore",
          "purpose": "PostgreSQL-backed memory store using SQLModel.",
          "methods": [
            "store",
            "get",
            "list_by_agent",
            "search",
            "delete",
            "get_recent_for_context"
          ]
        },
        {
          "type": "function",
          "name": "get_memory_store",
          "purpose": "Get the singleton memory store instance."
        }
      ]
    },
    {
      "file": "memory/update_rules.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "UpdateRule",
          "purpose": "Single update rule definition.",
          "methods": [
            "matches"
          ]
        },
        {
          "type": "class",
          "name": "RuleResult",
          "purpose": "Result of rule application.",
          "methods": []
        },
        {
          "type": "function",
          "name": "sanitize_strings",
          "purpose": "Strip whitespace from string values."
        },
        {
          "type": "function",
          "name": "sanitize_nulls",
          "purpose": "Remove null/None values from dicts."
        },
        {
          "type": "function",
          "name": "sanitize_timestamps",
          "purpose": "Convert timestamp strings to ISO format."
        },
        {
          "type": "function",
          "name": "deep_merge",
          "purpose": "Deep merge two dictionaries."
        },
        {
          "type": "function",
          "name": "append_lists",
          "purpose": "Append list values from update to base."
        },
        {
          "type": "function",
          "name": "increment_numbers",
          "purpose": "Increment numeric values."
        },
        {
          "type": "class",
          "name": "UpdateRulesEngine",
          "purpose": "Engine for applying update rules to memory values.",
          "methods": [
            "add_rule",
            "remove_rule",
            "get_rules",
            "apply",
            "validate"
          ]
        },
        {
          "type": "function",
          "name": "create_default_engine",
          "purpose": "Create engine with default rules."
        },
        {
          "type": "function",
          "name": "get_update_rules_engine",
          "purpose": "Get or create global rules engine."
        },
        {
          "type": "function",
          "name": "init_update_rules_engine",
          "purpose": "Initialize global rules engine."
        }
      ]
    },
    {
      "file": "memory/vector_store.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "EmbeddingError",
          "purpose": "Raised when embedding generation fails.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "get_embedding_openai",
          "purpose": "Get embedding from OpenAI API."
        },
        {
          "type": "async_function",
          "name": "get_embedding_voyage",
          "purpose": "Get embedding from Voyage AI API."
        },
        {
          "type": "async_function",
          "name": "get_embedding",
          "purpose": "Get embedding using configured provider with automatic fallback and caching."
        },
        {
          "type": "function",
          "name": "compute_text_hash",
          "purpose": "Compute hash of text for deduplication."
        },
        {
          "type": "class",
          "name": "VectorMemoryStore",
          "purpose": "pgvector-backed memory store with semantic search.",
          "methods": [
            "store",
            "search",
            "get",
            "list_by_agent",
            "delete",
            "backfill_embeddings"
          ]
        },
        {
          "type": "function",
          "name": "get_vector_memory_store",
          "purpose": "Get the singleton vector memory store instance."
        }
      ],
      "calls": {
        "L4": [
          "app.memory.embedding_metrics",
          "app.memory.embedding_cache"
        ],
        "L6": [
          "app.db_async"
        ],
        "external": [
          "app.security.sanitize"
        ]
      }
    },
    {
      "file": "optimization/envelope.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Base optimization envelope definition",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "DeltaType",
          "purpose": "How bounds are expressed.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnvelopeClass",
          "purpose": "C4 Envelope Class (FROZEN priority order).",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_envelope_priority",
          "purpose": "Get the priority of an envelope class (lower number = higher priority)."
        },
        {
          "type": "function",
          "name": "has_higher_priority",
          "purpose": "Check if class_a has higher priority than class_b."
        },
        {
          "type": "class",
          "name": "BaselineSource",
          "purpose": "Where baseline value comes from.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnvelopeLifecycle",
          "purpose": "Fixed envelope lifecycle states.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RevertReason",
          "purpose": "Why an envelope was reverted.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnvelopeTrigger",
          "purpose": "What prediction triggers this envelope.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnvelopeScope",
          "purpose": "What this envelope affects.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnvelopeBounds",
          "purpose": "Numerical bounds for the envelope.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnvelopeTimebox",
          "purpose": "Time constraints for the envelope.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnvelopeBaseline",
          "purpose": "Baseline value reference.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnvelopeAuditRecord",
          "purpose": "Immutable audit record for envelope lifecycle.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CoordinationDecisionType",
          "purpose": "C4 coordination decision types.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CoordinationAuditRecord",
          "purpose": "C4 Coordination audit record.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CoordinationDecision",
          "purpose": "Result of a coordination check.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Envelope",
          "purpose": "Declarative optimization envelope.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnvelopeValidationError",
          "purpose": "Raised when envelope fails validation.",
          "methods": []
        },
        {
          "type": "function",
          "name": "validate_envelope",
          "purpose": "Validate envelope against hard gate rules (V1-V5 + CI-C4-1)."
        },
        {
          "type": "function",
          "name": "calculate_bounded_value",
          "purpose": "Calculate the bounded value based on prediction confidence."
        },
        {
          "type": "function",
          "name": "create_audit_record",
          "purpose": "Create an audit record for envelope application."
        }
      ]
    },
    {
      "file": "optimization/envelopes/s1_retry_backoff.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "S1 Retry backoff envelope implementation",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "create_s1_envelope",
          "purpose": "Create a fresh S1 envelope instance with specified baseline."
        }
      ],
      "calls": {
        "L4": [
          "app.optimization.envelope"
        ]
      }
    },
    {
      "file": "optimization/envelopes/s2_cost_smoothing.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "S2 Cost smoothing envelope implementation",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "create_s2_envelope",
          "purpose": "Create a fresh S2 envelope instance with specified baseline."
        },
        {
          "type": "function",
          "name": "validate_s2_envelope",
          "purpose": "Validate S2-specific rules (additive to V1-V5)."
        },
        {
          "type": "function",
          "name": "calculate_s2_bounded_value",
          "purpose": "Calculate the bounded value for S2 (decrease only)."
        }
      ],
      "calls": {
        "L4": [
          "app.optimization.envelope"
        ]
      }
    },
    {
      "file": "optimization/killswitch.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Optimization killswitch for emergency stops",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "KillSwitchState",
          "purpose": "Global kill-switch state. Exactly two values. No partial states.",
          "methods": []
        },
        {
          "type": "class",
          "name": "KillSwitchTrigger",
          "purpose": "What triggered the kill-switch.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RollbackStatus",
          "purpose": "Status of rollback operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "KillSwitchEvent",
          "purpose": "Immutable audit record for kill-switch events.",
          "methods": []
        },
        {
          "type": "class",
          "name": "KillSwitch",
          "purpose": "Global, authoritative kill-switch for C3 optimization.",
          "methods": [
            "state",
            "is_enabled",
            "is_disabled",
            "activate",
            "mark_rollback_complete",
            "rearm",
            "on_activate",
            "get_events",
            "get_last_event"
          ]
        },
        {
          "type": "function",
          "name": "get_killswitch",
          "purpose": "Get the global kill-switch instance."
        },
        {
          "type": "function",
          "name": "reset_killswitch_for_testing",
          "purpose": "Reset kill-switch state. FOR TESTING ONLY."
        }
      ]
    },
    {
      "file": "planners/__init__.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "PlannerProtocol",
          "purpose": "Protocol for planner adapters.",
          "methods": [
            "plan"
          ]
        },
        {
          "type": "function",
          "name": "get_planner",
          "purpose": "Factory function to get the configured planner backend."
        }
      ]
    },
    {
      "file": "planners/test_planners.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "TestStubPlanner",
          "purpose": "Tests for the StubPlanner adapter.",
          "methods": [
            "test_stub_planner_initialization",
            "test_stub_planner_generates_plan",
            "test_stub_planner_step_structure",
            "test_stub_planner_with_tool_manifest",
            "test_stub_planner_metadata"
          ]
        },
        {
          "type": "class",
          "name": "TestAnthropicPlanner",
          "purpose": "Tests for the AnthropicPlanner adapter.",
          "methods": [
            "test_anthropic_planner_initialization_without_key",
            "test_anthropic_planner_initialization_with_key",
            "test_anthropic_planner_generates_stub_without_key",
            "test_anthropic_planner_custom_model",
            "test_anthropic_planner_builds_prompts",
            "test_anthropic_planner_with_tool_manifest"
          ]
        },
        {
          "type": "class",
          "name": "TestPlannerFactory",
          "purpose": "Tests for the planner factory function.",
          "methods": [
            "test_get_planner_default_stub",
            "test_get_planner_anthropic",
            "test_get_planner_fallback_to_stub"
          ]
        }
      ]
    },
    {
      "file": "policy/ast/nodes.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy AST node definitions",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "GovernanceMetadata",
          "purpose": "M19 Governance metadata attached to AST nodes.",
          "methods": [
            "merge_with"
          ]
        },
        {
          "type": "class",
          "name": "ASTNode",
          "purpose": "Base class for all AST nodes.",
          "methods": [
            "accept",
            "location"
          ]
        },
        {
          "type": "class",
          "name": "ExprNode",
          "purpose": "Base class for expression nodes.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ProgramNode",
          "purpose": "Root node representing a complete PLang program.",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "PolicyDeclNode",
          "purpose": "Policy declaration node.",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "RuleDeclNode",
          "purpose": "Rule declaration node.",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "ImportNode",
          "purpose": "Import statement node.",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "RuleRefNode",
          "purpose": "Reference to a named rule.",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "PriorityNode",
          "purpose": "Priority declaration node.",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "ConditionBlockNode",
          "purpose": "When/then condition block.",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "ActionBlockNode",
          "purpose": "Action block (deny, allow, escalate, route).",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "RouteTargetNode",
          "purpose": "Route target specification.",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "BinaryOpNode",
          "purpose": "Binary operation (and, or, ==, !=, etc.).",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "UnaryOpNode",
          "purpose": "Unary operation (not).",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "ValueNode",
          "purpose": "Base class for value nodes.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IdentNode",
          "purpose": "Identifier node.",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "LiteralNode",
          "purpose": "Literal value node (number, string, boolean).",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "FuncCallNode",
          "purpose": "Function call node.",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "AttrAccessNode",
          "purpose": "Attribute access node (obj.attr).",
          "methods": [
            "accept"
          ]
        },
        {
          "type": "class",
          "name": "ASTVisitor",
          "purpose": "Abstract base class for AST visitors.",
          "methods": [
            "visit_program",
            "visit_policy_decl",
            "visit_rule_decl",
            "visit_import",
            "visit_rule_ref",
            "visit_priority",
            "visit_condition_block",
            "visit_action_block",
            "visit_route_target",
            "visit_binary_op"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.policy.compiler.grammar",
          "app.policy.compiler.grammar",
          "app.policy.compiler.grammar"
        ]
      }
    },
    {
      "file": "policy/ast/visitors.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy AST visitor pattern implementations",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "BaseVisitor",
          "purpose": "Base visitor with default implementations.",
          "methods": [
            "visit_program",
            "visit_policy_decl",
            "visit_rule_decl",
            "visit_import",
            "visit_rule_ref",
            "visit_priority",
            "visit_condition_block",
            "visit_action_block",
            "visit_route_target",
            "visit_binary_op"
          ]
        },
        {
          "type": "class",
          "name": "PrintVisitor",
          "purpose": "Visitor that prints AST in readable format.",
          "methods": [
            "get_output",
            "visit_program",
            "visit_policy_decl",
            "visit_rule_decl",
            "visit_import",
            "visit_rule_ref",
            "visit_priority",
            "visit_condition_block",
            "visit_action_block",
            "visit_route_target"
          ]
        },
        {
          "type": "class",
          "name": "CategoryCollector",
          "purpose": "Visitor that collects all categories used in the AST.",
          "methods": [
            "get_categories",
            "visit_policy_decl",
            "visit_rule_decl"
          ]
        },
        {
          "type": "class",
          "name": "RuleExtractor",
          "purpose": "Visitor that extracts all rules with their governance metadata.",
          "methods": [
            "get_rules",
            "visit_policy_decl",
            "visit_rule_decl",
            "visit_condition_block"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.policy.ast.nodes",
          "app.policy.compiler.grammar"
        ]
      }
    },
    {
      "file": "policy/compiler/grammar.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy language grammar definitions",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "GrammarNodeType",
          "purpose": "Grammar node types for PLang v2.0.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyCategory",
          "purpose": "M19 Policy Categories.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ActionType",
          "purpose": "Policy action types.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GrammarProduction",
          "purpose": "A production rule in the grammar.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PLangGrammar",
          "purpose": "PLang v2.0 Grammar Definition.",
          "methods": [
            "get_category_priority",
            "get_action_precedence",
            "is_keyword",
            "is_operator",
            "is_category",
            "is_action"
          ]
        }
      ]
    },
    {
      "file": "policy/compiler/parser.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy language parser",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ParseError",
          "purpose": "Error during parsing.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Parser",
          "purpose": "Parser for PLang v2.0.",
          "methods": [
            "from_source",
            "current",
            "peek",
            "advance",
            "expect",
            "match",
            "parse",
            "parse_policy_decl",
            "parse_category",
            "parse_policy_body"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.policy.ast.nodes",
          "app.policy.compiler.grammar",
          "app.policy.compiler.tokenizer"
        ]
      }
    },
    {
      "file": "policy/compiler/tokenizer.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy language tokenizer",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "TokenType",
          "purpose": "Token types for PLang v2.0.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Token",
          "purpose": "A token in PLang source code.",
          "methods": [
            "is_category",
            "is_action"
          ]
        },
        {
          "type": "class",
          "name": "TokenizerError",
          "purpose": "Error during tokenization.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Tokenizer",
          "purpose": "Tokenizer for PLang v2.0.",
          "methods": [
            "current_char",
            "peek",
            "advance",
            "skip_whitespace",
            "skip_comment",
            "read_string",
            "read_number",
            "read_identifier",
            "read_operator",
            "tokenize"
          ]
        }
      ]
    },
    {
      "file": "policy/engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy rule evaluation engine",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PolicyEngine",
          "purpose": "M19 Policy Engine - Constitutional Governance Layer.",
          "methods": [
            "evaluate",
            "pre_check",
            "get_state",
            "reload_policies",
            "set_governor",
            "get_violations",
            "get_violation",
            "acknowledge_violation",
            "get_risk_ceilings",
            "get_risk_ceiling"
          ]
        },
        {
          "type": "function",
          "name": "get_policy_engine",
          "purpose": "Get singleton policy engine with M18 Governor integration."
        }
      ],
      "calls": {
        "L4": [
          "app.policy.models",
          "app.contracts.decisions",
          "app.policy.models",
          "app.policy.models",
          "app.policy.models",
          "app.policy.models",
          "app.policy.models",
          "app.policy.models",
          "app.policy.models",
          "app.policy.models",
          "app.policy.models",
          "app.policy.models",
          "app.routing"
        ]
      }
    },
    {
      "file": "policy/ir/ir_builder.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy intermediate representation builder",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "IRBuilder",
          "purpose": "Builds IR from PLang AST.",
          "methods": [
            "build",
            "visit_program",
            "visit_policy_decl",
            "visit_rule_decl",
            "visit_import",
            "visit_rule_ref",
            "visit_priority",
            "visit_condition_block",
            "visit_action_block",
            "visit_route_target"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.policy.ast.nodes",
          "app.policy.ast.visitors",
          "app.policy.compiler.grammar",
          "app.policy.ir.ir_nodes",
          "app.policy.ir.symbol_table"
        ]
      }
    },
    {
      "file": "policy/ir/ir_nodes.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy IR node definitions",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "IRType",
          "purpose": "IR value types.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRGovernance",
          "purpose": "Governance metadata for IR nodes.",
          "methods": [
            "from_ast",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "IRNode",
          "purpose": "Base class for all IR nodes.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRInstruction",
          "purpose": "Base class for IR instructions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRLoadConst",
          "purpose": "Load constant value.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRLoadVar",
          "purpose": "Load variable value.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRStoreVar",
          "purpose": "Store value to variable.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRBinaryOp",
          "purpose": "Binary operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRUnaryOp",
          "purpose": "Unary operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRCompare",
          "purpose": "Comparison operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRJump",
          "purpose": "Unconditional jump.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRJumpIf",
          "purpose": "Conditional jump.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRCall",
          "purpose": "Function call.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRReturn",
          "purpose": "Return from function.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRAction",
          "purpose": "Policy action instruction.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRCheckPolicy",
          "purpose": "Check against M19 policy engine.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IREmitIntent",
          "purpose": "Emit intent to M18 execution layer.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IRBlock",
          "purpose": "Basic block in IR.",
          "methods": [
            "add_instruction",
            "is_terminated"
          ]
        },
        {
          "type": "class",
          "name": "IRFunction",
          "purpose": "Function in IR.",
          "methods": [
            "add_block",
            "get_block"
          ]
        },
        {
          "type": "class",
          "name": "IRModule",
          "purpose": "Module in IR.",
          "methods": [
            "add_function",
            "get_function",
            "get_functions_by_category"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.policy.compiler.grammar"
        ]
      }
    },
    {
      "file": "policy/ir/symbol_table.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy symbol table management",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SymbolType",
          "purpose": "Types of symbols in PLang.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Symbol",
          "purpose": "A symbol in the symbol table.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Scope",
          "purpose": "A scope in the symbol table.",
          "methods": [
            "define",
            "lookup",
            "lookup_by_category",
            "get_all_symbols"
          ]
        },
        {
          "type": "class",
          "name": "SymbolTable",
          "purpose": "Symbol table for PLang compilation.",
          "methods": [
            "enter_scope",
            "exit_scope",
            "define",
            "lookup",
            "lookup_policy",
            "lookup_rule",
            "get_symbols_by_category",
            "get_policies",
            "get_rules",
            "add_reference"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.policy.compiler.grammar"
        ]
      }
    },
    {
      "file": "policy/models.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy domain models and types",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PolicyCategory",
          "purpose": "Categories of policies in the M19 Policy Layer.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyDecision",
          "purpose": "Possible decisions from policy evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ActionType",
          "purpose": "Types of actions that require policy evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ViolationType",
          "purpose": "Types of policy violations.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ViolationSeverity",
          "purpose": "Enhanced violation severity classifications (GAP 5).",
          "methods": []
        },
        {
          "type": "class",
          "name": "RecoverabilityType",
          "purpose": "Whether a violation is recoverable.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SafetyRuleType",
          "purpose": "Types of safety rules.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EthicalConstraintType",
          "purpose": "Types of ethical constraints.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BusinessRuleType",
          "purpose": "Types of business rules.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyEvaluationRequest",
          "purpose": "Request for policy evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyModification",
          "purpose": "Modification applied to an action by policy engine.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyEvaluationResult",
          "purpose": "Result of policy evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyViolation",
          "purpose": "A policy violation record.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyRule",
          "purpose": "A single rule within a policy.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Policy",
          "purpose": "A policy definition.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RiskCeiling",
          "purpose": "A risk ceiling definition.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SafetyRule",
          "purpose": "A safety rule definition.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EthicalConstraint",
          "purpose": "An ethical constraint definition.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BusinessRule",
          "purpose": "A business rule definition.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyState",
          "purpose": "Current state of the policy layer.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyLoadResult",
          "purpose": "Result of loading policies from database.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyVersion",
          "purpose": "A versioned snapshot of a policy set (GAP 1).",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyProvenance",
          "purpose": "Audit trail for policy changes (GAP 1).",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyDependency",
          "purpose": "Dependency relationship between policies (GAP 2).",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyConflict",
          "purpose": "A detected conflict between policies (GAP 2).",
          "methods": []
        },
        {
          "type": "class",
          "name": "DependencyGraph",
          "purpose": "The complete policy dependency graph (GAP 2).",
          "methods": []
        },
        {
          "type": "class",
          "name": "TemporalPolicyType",
          "purpose": "Types of temporal policies.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TemporalPolicy",
          "purpose": "A temporal/sliding window policy (GAP 3).",
          "methods": []
        },
        {
          "type": "class",
          "name": "TemporalMetricWindow",
          "purpose": "A sliding window of metric values (GAP 3).",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyContext",
          "purpose": "Complete policy context passed through the decision cycle (GAP 4).",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnhancedPolicyEvaluationRequest",
          "purpose": "Enhanced evaluation request with full context (GAP 4).",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnhancedPolicyViolation",
          "purpose": "Enhanced violation with severity classification (GAP 5).",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnhancedPolicyEvaluationResult",
          "purpose": "Enhanced evaluation result with full context (GAPs 1-5).",
          "methods": []
        }
      ]
    },
    {
      "file": "policy/optimizer/conflict_resolver.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy conflict resolution",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ConflictType",
          "purpose": "Types of policy conflicts.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyConflict",
          "purpose": "A detected conflict between policies.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ConflictResolver",
          "purpose": "Resolves conflicts between policies.",
          "methods": [
            "resolve"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.policy.compiler.grammar",
          "app.policy.ir.ir_nodes"
        ]
      }
    },
    {
      "file": "policy/optimizer/dag_sorter.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy DAG topological sorting",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ExecutionPhase",
          "purpose": "Execution phases in deterministic order.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExecutionNode",
          "purpose": "A node in the execution DAG.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExecutionDAG",
          "purpose": "Directed Acyclic Graph of policy execution.",
          "methods": [
            "add_node",
            "add_edge",
            "get_roots",
            "get_leaves"
          ]
        },
        {
          "type": "class",
          "name": "ExecutionPlan",
          "purpose": "A deterministic execution plan.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "DAGSorter",
          "purpose": "Sorts policies into deterministic execution order.",
          "methods": [
            "build_dag",
            "sort",
            "get_execution_order",
            "visualize"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.policy.compiler.grammar",
          "app.policy.ir.ir_nodes",
          "app.policy.compiler.grammar",
          "app.policy.ir.ir_nodes"
        ]
      }
    },
    {
      "file": "policy/optimizer/folds.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy constant folding optimizations",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "FoldResult",
          "purpose": "Result of a folding operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ConstantFolder",
          "purpose": "Constant folding optimization.",
          "methods": [
            "fold_module",
            "fold_function",
            "fold_block",
            "try_fold"
          ]
        },
        {
          "type": "class",
          "name": "DeadCodeEliminator",
          "purpose": "Dead code elimination.",
          "methods": [
            "eliminate"
          ]
        },
        {
          "type": "class",
          "name": "PolicySimplifier",
          "purpose": "Policy-specific simplifications.",
          "methods": [
            "simplify"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.policy.ir.ir_nodes"
        ]
      }
    },
    {
      "file": "policy/runtime/deterministic_engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Deterministic policy execution engine",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ExecutionStatus",
          "purpose": "Status of policy execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExecutionContext",
          "purpose": "Execution context for policy evaluation.",
          "methods": [
            "get_variable",
            "set_variable",
            "push_call",
            "pop_call",
            "add_trace"
          ]
        },
        {
          "type": "class",
          "name": "ExecutionResult",
          "purpose": "Result of policy execution.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "DeterministicEngine",
          "purpose": "Deterministic policy execution engine.",
          "methods": [
            "execute"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.policy.compiler.grammar",
          "app.policy.ir.ir_nodes",
          "app.policy.runtime.intent"
        ]
      }
    },
    {
      "file": "policy/runtime/intent.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy intent model and declaration",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "IntentType",
          "purpose": "Types of intents emitted by policy runtime.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IntentPayload",
          "purpose": "Payload data for an intent.",
          "methods": [
            "to_dict",
            "from_dict"
          ]
        },
        {
          "type": "class",
          "name": "Intent",
          "purpose": "An intent emitted by the policy runtime.",
          "methods": [
            "to_dict",
            "from_dict"
          ]
        },
        {
          "type": "class",
          "name": "IntentEmitter",
          "purpose": "Emits intents from policy runtime to M18.",
          "methods": [
            "create_intent",
            "validate_intent",
            "emit",
            "emit_all",
            "register_handler",
            "get_pending",
            "get_emitted",
            "clear"
          ]
        }
      ]
    },
    {
      "file": "policy/validators/content_accuracy.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Policy content accuracy validation",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "AssertionType",
          "purpose": "Types of assertions detected in output.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ValidationResult",
          "purpose": "Result of content accuracy validation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AssertionCheck",
          "purpose": "A single assertion check result.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ContentAccuracyResult",
          "purpose": "Complete result of content accuracy validation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "ContentAccuracyValidator",
          "purpose": "Validates that LLM output does not make assertions about missing data.",
          "methods": [
            "validate"
          ]
        },
        {
          "type": "function",
          "name": "validate_content_accuracy",
          "purpose": "Convenience function to validate content accuracy."
        }
      ]
    },
    {
      "file": "policy/validators/prevention_engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Prevention-based policy validation",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PolicyType",
          "purpose": "Types of policies that can be evaluated.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Severity",
          "purpose": "Severity levels for policy violations.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PreventionAction",
          "purpose": "Action to take when prevention triggers.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyViolation",
          "purpose": "A single policy violation detected.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "PreventionContext",
          "purpose": "Context for prevention evaluation.",
          "methods": [
            "hash_output"
          ]
        },
        {
          "type": "class",
          "name": "PreventionResult",
          "purpose": "Result of prevention engine evaluation.",
          "methods": [
            "highest_severity",
            "primary_violation",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "BaseValidator",
          "purpose": "Base class for policy validators.",
          "methods": [
            "validate"
          ]
        },
        {
          "type": "class",
          "name": "ContentAccuracyValidatorV2",
          "purpose": "Enhanced content accuracy validator.",
          "methods": [
            "validate"
          ]
        },
        {
          "type": "class",
          "name": "PIIValidator",
          "purpose": "Detects PII in LLM output that shouldn't be exposed.",
          "methods": [
            "validate"
          ]
        },
        {
          "type": "class",
          "name": "SafetyValidator",
          "purpose": "Detects harmful, dangerous, or inappropriate content.",
          "methods": [
            "validate"
          ]
        },
        {
          "type": "class",
          "name": "HallucinationValidator",
          "purpose": "Detects potential hallucinations by checking for unsupported claims.",
          "methods": [
            "validate"
          ]
        },
        {
          "type": "class",
          "name": "BudgetValidator",
          "purpose": "Validates that response doesn't exceed budget limits.",
          "methods": [
            "validate"
          ]
        },
        {
          "type": "class",
          "name": "PreventionEngine",
          "purpose": "Multi-policy prevention engine with severity levels and async incident creation.",
          "methods": [
            "evaluate"
          ]
        },
        {
          "type": "function",
          "name": "get_prevention_engine",
          "purpose": "Get global prevention engine instance."
        },
        {
          "type": "function",
          "name": "evaluate_prevention",
          "purpose": "Convenience function to evaluate prevention."
        },
        {
          "type": "async_function",
          "name": "create_incident_from_violation",
          "purpose": "Create an incident from prevention violation."
        }
      ],
      "calls": {
        "L4": [
          "app.services.policy_violation_service",
          "app.services.policy_violation_service"
        ],
        "L6": [
          "app.db_async"
        ]
      }
    },
    {
      "file": "policy/validators/prevention_hook.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Prevention hook for policy enforcement",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PreventionAction",
          "purpose": "Action to take when prevention hook triggers.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PreventionContext",
          "purpose": "Context for prevention hook evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PreventionResult",
          "purpose": "Result of prevention hook evaluation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "PreventionHook",
          "purpose": "Prevention hook for pre-response validation.",
          "methods": [
            "evaluate",
            "get_safe_response"
          ]
        },
        {
          "type": "function",
          "name": "create_prevention_hook",
          "purpose": "Factory function to create a prevention hook."
        },
        {
          "type": "function",
          "name": "get_prevention_hook",
          "purpose": "Get the global prevention hook instance."
        },
        {
          "type": "function",
          "name": "evaluate_response",
          "purpose": "Convenience function to evaluate an LLM response."
        }
      ],
      "calls": {
        "L4": [
          "app.policy.validators.content_accuracy"
        ]
      }
    },
    {
      "file": "predictions/api.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Prediction service API logic",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "get_db",
          "purpose": "Get database session."
        },
        {
          "type": "function",
          "name": "create_incident_risk_prediction",
          "purpose": "Create ONE advisory prediction for incident risk."
        },
        {
          "type": "function",
          "name": "list_predictions",
          "purpose": "List non-expired predictions for a subject."
        },
        {
          "type": "function",
          "name": "create_spend_spike_prediction",
          "purpose": "Create ONE advisory prediction for spend spike."
        },
        {
          "type": "function",
          "name": "create_policy_drift_prediction",
          "purpose": "Create ONE advisory prediction for policy drift observation."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/incident-risk"
        },
        {
          "method": "POST",
          "path": "/spend-spike"
        },
        {
          "method": "POST",
          "path": "/policy-drift"
        }
      ],
      "calls": {
        "L6": [
          "app.db",
          "app.models.prediction"
        ]
      }
    },
    {
      "file": "routing/care.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "CARE-L routing algorithm core",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "RateLimiter",
          "purpose": "Redis-based rate limiter with per-policy limits.",
          "methods": [
            "check_rate_limit",
            "get_remaining"
          ]
        },
        {
          "type": "function",
          "name": "get_rate_limiter",
          "purpose": "Get singleton rate limiter instance."
        },
        {
          "type": "class",
          "name": "FairnessTracker",
          "purpose": "Redis-based tracker for agent assignment fairness.",
          "methods": [
            "record_assignment",
            "get_recent_assignments",
            "get_fairness_scores"
          ]
        },
        {
          "type": "class",
          "name": "PerformanceStore",
          "purpose": "Store for agent performance vectors.",
          "methods": [
            "get_vector",
            "update_vector",
            "get_vectors_for_agents"
          ]
        },
        {
          "type": "function",
          "name": "get_fairness_tracker",
          "purpose": "Get singleton fairness tracker instance."
        },
        {
          "type": "function",
          "name": "get_performance_store",
          "purpose": "Get singleton performance store instance."
        },
        {
          "type": "class",
          "name": "CAREEngine",
          "purpose": "Cascade-Aware Routing Engine.",
          "methods": [
            "evaluate_agent",
            "record_outcome",
            "get_agent_performance",
            "route",
            "evaluate_agents"
          ]
        },
        {
          "type": "function",
          "name": "get_care_engine",
          "purpose": "Get singleton CARE engine instance."
        }
      ],
      "calls": {
        "L4": [
          "app.contracts.decisions"
        ]
      }
    },
    {
      "file": "routing/feedback.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "CARE-L feedback loop processing",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "TaskPriority",
          "purpose": "Task priority levels for SLA weighting.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TaskComplexity",
          "purpose": "Task complexity for scoring adjustment.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FeedbackDirection",
          "purpose": "Direction of feedback in the loop.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RoutingOutcomeSignal",
          "purpose": "Signal from CARE-L to SBA Evolution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StrategyAdjustmentSignal",
          "purpose": "Signal from SBA Evolution to CARE-L.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SLAScore",
          "purpose": "SLA-aware score for an agent.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BatchLearningResult",
          "purpose": "Result of batch learning process.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FeedbackLoop",
          "purpose": "Bidirectional feedback loop between CARE-L and SBA Evolution.",
          "methods": [
            "record_routing_outcome",
            "get_signals_for_sba",
            "record_strategy_adjustment",
            "get_reputation_updates_for_care",
            "get_sla_score",
            "compute_sla_adjusted_reputation",
            "run_batch_learning",
            "recommend_capability_redistribution",
            "get_successor_mapping"
          ]
        },
        {
          "type": "function",
          "name": "get_feedback_loop",
          "purpose": "Get singleton feedback loop."
        }
      ]
    },
    {
      "file": "routing/governor.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "CARE-L routing governor/throttling",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "GovernorState",
          "purpose": "System stability states.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RollbackReason",
          "purpose": "Reasons for rolling back an adjustment.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AdjustmentRecord",
          "purpose": "Record of a parameter adjustment for governor tracking.",
          "methods": [
            "compute_magnitude"
          ]
        },
        {
          "type": "class",
          "name": "StabilityMetrics",
          "purpose": "System-wide stability metrics.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RollbackResult",
          "purpose": "Result of a rollback operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Governor",
          "purpose": "Stabilization layer that prevents learning system oscillation.",
          "methods": [
            "request_adjustment",
            "record_adjustment",
            "evaluate_adjustment",
            "rollback_adjustment",
            "get_stability_metrics",
            "force_freeze",
            "unfreeze"
          ]
        },
        {
          "type": "function",
          "name": "get_governor",
          "purpose": "Get singleton governor."
        }
      ]
    },
    {
      "file": "routing/learning.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "CARE-L learning from routing decisions",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "QuarantineState",
          "purpose": "Agent quarantine states.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AgentReputation",
          "purpose": "Agent reputation for routing decisions.",
          "methods": [
            "compute_reputation",
            "record_success",
            "record_failure",
            "record_violation",
            "is_routable",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "LearningParameters",
          "purpose": "Self-tuning routing parameters.",
          "methods": [
            "tune_from_outcomes"
          ]
        },
        {
          "type": "class",
          "name": "HysteresisManager",
          "purpose": "Prevents oscillation between agents during performance swings.",
          "methods": [
            "should_switch",
            "record_selection"
          ]
        },
        {
          "type": "class",
          "name": "ReputationStore",
          "purpose": "Store for agent reputations.",
          "methods": [
            "get_reputation",
            "save_reputation",
            "get_all_reputations"
          ]
        },
        {
          "type": "function",
          "name": "get_reputation_store",
          "purpose": "Get singleton reputation store."
        },
        {
          "type": "function",
          "name": "get_hysteresis_manager",
          "purpose": "Get singleton hysteresis manager."
        },
        {
          "type": "function",
          "name": "get_learning_parameters",
          "purpose": "Get singleton learning parameters."
        }
      ]
    },
    {
      "file": "routing/models.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "CARE-L routing models and types",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SuccessMetric",
          "purpose": "Success metrics derived from winning aspiration.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OrchestratorMode",
          "purpose": "Orchestrator execution modes.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RoutingStage",
          "purpose": "CARE pipeline stages.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RiskPolicy",
          "purpose": "Risk policies for execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DifficultyLevel",
          "purpose": "Task difficulty levels.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ProbeType",
          "purpose": "Types of capability probes.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CapabilityHardness",
          "purpose": "Dependency hardness classification.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CapabilityProbeResult",
          "purpose": "Result of a single capability probe.",
          "methods": [
            "to_dict",
            "is_blocking"
          ]
        },
        {
          "type": "class",
          "name": "CapabilityCheckResult",
          "purpose": "Aggregated capability check results.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "StageResult",
          "purpose": "Result of a single CARE pipeline stage.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RouteEvaluationResult",
          "purpose": "Evaluation of a single agent for routing.",
          "methods": [
            "get_stage_result"
          ]
        },
        {
          "type": "class",
          "name": "RoutingRequest",
          "purpose": "Request for CARE routing.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RoutingDecision",
          "purpose": "Final routing decision from CARE.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "AgentPerformanceVector",
          "purpose": "Performance metrics for an agent, updated after each routing outcome.",
          "methods": [
            "calculate_fairness_score",
            "update_success_rate",
            "update_fallback_rate",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "RoutingOutcome",
          "purpose": "Outcome of a routing decision, used to update agent performance vectors.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RoutingConfig",
          "purpose": "M17 Routing configuration extension for SBA.",
          "methods": []
        },
        {
          "type": "function",
          "name": "infer_success_metric",
          "purpose": "Infer success metric from winning aspiration text."
        },
        {
          "type": "function",
          "name": "infer_orchestrator_mode",
          "purpose": "Infer orchestrator mode from orchestrator name and agent type."
        }
      ]
    },
    {
      "file": "routing/probes.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "CARE-L health probes for routing",
      "temporal": {
        "trigger": "scheduler",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "CapabilityProber",
          "purpose": "Real-time capability probing with Redis caching.",
          "methods": [
            "probe_smtp",
            "probe_dns",
            "probe_api_key",
            "probe_http",
            "probe_redis",
            "probe_database",
            "probe_agent",
            "probe_service",
            "check_capabilities"
          ]
        },
        {
          "type": "function",
          "name": "get_capability_prober",
          "purpose": "Get singleton capability prober instance."
        }
      ]
    },
    {
      "file": "services/budget_enforcement_engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Budget enforcement decision-making (domain logic)",
      "temporal": {
        "trigger": "scheduler (background task)",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "BudgetEnforcementEngine",
          "purpose": "L4 Domain Engine for budget enforcement decisions.",
          "methods": [
            "emit_decision_for_halt",
            "process_pending_halts"
          ]
        },
        {
          "type": "function",
          "name": "emit_budget_halt_decision",
          "purpose": "Convenience function to emit a budget enforcement decision."
        },
        {
          "type": "async_function",
          "name": "process_pending_budget_decisions",
          "purpose": "Process all pending budget halt decisions."
        }
      ],
      "calls": {
        "L4": [
          "app.contracts.decisions"
        ]
      }
    },
    {
      "file": "services/claim_decision_engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "components": [
        {
          "type": "function",
          "name": "is_candidate_claimable",
          "purpose": "Determine if a candidate is eligible for claiming based on confidence."
        },
        {
          "type": "function",
          "name": "determine_claim_status",
          "purpose": "Determine the execution status from an evaluation result."
        },
        {
          "type": "function",
          "name": "get_result_confidence",
          "purpose": "Extract confidence from evaluation result with default fallback."
        }
      ]
    },
    {
      "file": "services/cost_anomaly_detector.py",
      "layer": "L4",
      "layer_source": "declared",
      "components": [
        {
          "type": "class",
          "name": "AnomalyType",
          "purpose": "Cost anomaly types - minimal set.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AnomalySeverity",
          "purpose": "Aligned severity bands per plan.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DerivedCause",
          "purpose": "Deterministic cause derivation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DetectedAnomaly",
          "purpose": "A detected cost anomaly.",
          "methods": []
        },
        {
          "type": "function",
          "name": "classify_severity",
          "purpose": "Classify severity based on percentage deviation."
        },
        {
          "type": "class",
          "name": "CostAnomalyDetector",
          "purpose": "Detects cost anomalies with aligned rules.",
          "methods": [
            "detect_all",
            "detect_absolute_spikes",
            "detect_sustained_drift",
            "detect_budget_issues",
            "persist_anomalies"
          ]
        },
        {
          "type": "async_function",
          "name": "run_anomaly_detection",
          "purpose": "Run anomaly detection and persist results."
        },
        {
          "type": "async_function",
          "name": "run_anomaly_detection_with_m25",
          "purpose": "Run anomaly detection AND escalate HIGH anomalies to M25 loop."
        }
      ],
      "calls": {
        "L6": [
          "app.db"
        ],
        "external": [
          "app.integrations.cost_bridges",
          "app.integrations.cost_bridges",
          "app.integrations.cost_bridges",
          "app.integrations.cost_bridges"
        ]
      }
    },
    {
      "file": "services/cost_model_engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Cost modeling and risk estimation domain authority",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "DriftVerdict",
          "purpose": "Classification of drift between V1 and V2 simulation results.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StepCostEstimate",
          "purpose": "Enhanced step estimate with confidence (L4 domain output).",
          "methods": []
        },
        {
          "type": "class",
          "name": "FeasibilityResult",
          "purpose": "Result of feasibility check (L4 domain output).",
          "methods": []
        },
        {
          "type": "class",
          "name": "DriftAnalysis",
          "purpose": "Result of drift analysis between V1 and V2 (L4 domain output).",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_skill_coefficients",
          "purpose": "Get cost model coefficients for a skill (L4 domain function)."
        },
        {
          "type": "function",
          "name": "estimate_step_cost",
          "purpose": "Estimate cost and latency for a single step (L4 domain function)."
        },
        {
          "type": "function",
          "name": "calculate_cumulative_risk",
          "purpose": "Calculate cumulative risk from individual risk factors (L4 domain function)."
        },
        {
          "type": "function",
          "name": "check_feasibility",
          "purpose": "Check if a plan is feasible (L4 domain function)."
        },
        {
          "type": "function",
          "name": "classify_drift",
          "purpose": "Classify drift between V1 and V2 simulation results (L4 domain function)."
        },
        {
          "type": "function",
          "name": "is_significant_risk",
          "purpose": "Check if a risk factor is significant enough to report (L4 domain function)."
        }
      ]
    },
    {
      "file": "services/cost_write_service.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "DB write delegation for Cost Intelligence API (Phase 2B extraction)",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "utc_now",
          "purpose": "Get current UTC time."
        },
        {
          "type": "class",
          "name": "CostWriteService",
          "purpose": "DB write operations for Cost Intelligence.",
          "methods": [
            "create_feature_tag",
            "update_feature_tag",
            "create_cost_record",
            "create_or_update_budget"
          ]
        }
      ],
      "calls": {
        "L6": [
          "app.db"
        ]
      }
    },
    {
      "file": "services/founder_action_write_service.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "DB write delegation for Founder Actions API (Phase 2B extraction)",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "FounderActionWriteService",
          "purpose": "DB write operations for Founder Actions.",
          "methods": [
            "create_founder_action",
            "mark_action_reversed",
            "commit",
            "rollback"
          ]
        }
      ],
      "calls": {
        "L6": [
          "app.models.tenant"
        ]
      }
    },
    {
      "file": "services/guard_write_service.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "DB write delegation for Guard API (Phase 2B extraction)",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "utc_now",
          "purpose": "Get current UTC time."
        },
        {
          "type": "class",
          "name": "GuardWriteService",
          "purpose": "DB write operations for Guard Console.",
          "methods": [
            "get_or_create_killswitch_state",
            "freeze_killswitch",
            "unfreeze_killswitch",
            "acknowledge_incident",
            "resolve_incident",
            "create_demo_incident"
          ]
        }
      ],
      "calls": {
        "L6": [
          "app.models.killswitch"
        ]
      }
    },
    {
      "file": "services/incident_aggregator.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Incident grouping rules, escalation logic",
      "components": [
        {
          "type": "class",
          "name": "IncidentAggregatorConfig",
          "purpose": "Configuration for incident aggregation behavior.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentKey",
          "purpose": "Grouping key for incident aggregation.",
          "methods": [
            "from_event"
          ]
        },
        {
          "type": "class",
          "name": "IncidentAggregator",
          "purpose": "Service for intelligent incident aggregation.",
          "methods": [
            "get_or_create_incident",
            "resolve_stale_incidents",
            "get_incident_stats"
          ]
        },
        {
          "type": "function",
          "name": "create_incident_aggregator",
          "purpose": "Create an IncidentAggregator with canonical dependencies."
        }
      ],
      "calls": {
        "L6": [
          "app.models.killswitch",
          "app.utils.runtime"
        ]
      }
    },
    {
      "file": "services/llm_failure_service.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "S4 failure truth model, fact persistence",
      "components": [
        {
          "type": "class",
          "name": "LLMFailureFact",
          "purpose": "Authoritative LLM failure fact.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LLMFailureResult",
          "purpose": "Result of failure persistence operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LLMFailureService",
          "purpose": "Service for handling LLM failures with S4 truth guarantees.",
          "methods": [
            "persist_failure_and_mark_run",
            "get_failure_by_run_id"
          ]
        }
      ],
      "calls": {
        "L6": [
          "app.utils.runtime"
        ]
      }
    },
    {
      "file": "services/llm_policy_engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "LLM policy and safety limits enforcement",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SafetyCheckResult",
          "purpose": "Result of a safety limit check.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LLMRateLimiter",
          "purpose": "Sliding window rate limiter for LLM requests (L4 policy enforcement).",
          "methods": [
            "get_instance",
            "check_and_record",
            "requests_remaining"
          ]
        },
        {
          "type": "function",
          "name": "estimate_tokens",
          "purpose": "Estimate token count for text (L4 domain function)."
        },
        {
          "type": "function",
          "name": "estimate_cost_cents",
          "purpose": "Estimate cost in cents (L4 domain function)."
        },
        {
          "type": "function",
          "name": "check_safety_limits",
          "purpose": "Check safety limits before making LLM API call (L4 domain function)."
        },
        {
          "type": "function",
          "name": "is_model_allowed",
          "purpose": "Check if a model is allowed (L4 domain function)."
        },
        {
          "type": "function",
          "name": "is_expensive_model",
          "purpose": "Check if a model is classified as expensive (L4 domain function)."
        },
        {
          "type": "function",
          "name": "get_model_for_task",
          "purpose": "Get appropriate model for a task type (L4 policy decision)."
        },
        {
          "type": "function",
          "name": "get_effective_model",
          "purpose": "Get effective model based on request and tenant config (L4 policy decision)."
        }
      ]
    },
    {
      "file": "services/ops_domain_models.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Ops domain models for operator intelligence views",
      "temporal": {
        "trigger": "api|scheduler",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "OpsSeverity",
          "purpose": "Operator-facing severity levels.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsIncidentCategory",
          "purpose": "Operator-facing incident categories.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsHealthStatus",
          "purpose": "System health states for operators.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsRiskLevel",
          "purpose": "Risk levels for preflight findings.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsIncident",
          "purpose": "Aggregated incident for operator visibility.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsHealthSignal",
          "purpose": "Current health state of a component or subsystem.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsRiskFinding",
          "purpose": "Preflight risk finding for launch readiness.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsTrendMetric",
          "purpose": "Time-series trend for operator dashboards.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsDecisionOutcome",
          "purpose": "Summary of domain engine decisions for operator review.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsCorrelatedEvent",
          "purpose": "Cross-component event correlation for incident investigation.",
          "methods": []
        }
      ]
    },
    {
      "file": "services/ops_incident_service.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Translate infra errors into operator-facing incidents",
      "temporal": {
        "trigger": "api|scheduler",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ErrorStoreProtocol",
          "purpose": "Protocol for error store dependency.",
          "methods": [
            "get_errors_by_component",
            "get_error_counts_by_class",
            "get_error_counts_by_component"
          ]
        },
        {
          "type": "class",
          "name": "IncidentAggregationConfig",
          "purpose": "Configuration for incident aggregation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsIncidentService",
          "purpose": "L4 Aggregation Service for incidents.",
          "methods": [
            "get_active_incidents",
            "get_incident_by_component",
            "get_incident_summary"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.services.ops_domain_models"
        ],
        "L6": [
          "app.db"
        ]
      }
    },
    {
      "file": "services/ops_write_service.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "DB write delegation for Ops API (Phase 2B extraction)",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "OpsWriteService",
          "purpose": "DB write operations for Ops background jobs.",
          "methods": [
            "update_silent_churn",
            "compute_stickiness_scores"
          ]
        }
      ]
    },
    {
      "file": "services/orphan_recovery.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Orphan detection logic, PB-S2 truth guarantee",
      "components": [
        {
          "type": "async_function",
          "name": "detect_orphaned_runs",
          "purpose": "Detect runs that appear to be orphaned."
        },
        {
          "type": "async_function",
          "name": "mark_run_as_crashed",
          "purpose": "Mark a run as crashed."
        },
        {
          "type": "async_function",
          "name": "recover_orphaned_runs",
          "purpose": "Main recovery function - called on startup."
        },
        {
          "type": "async_function",
          "name": "get_crash_recovery_summary",
          "purpose": "Get a summary of crashed runs for operator visibility."
        }
      ],
      "calls": {
        "L6": [
          "app.infra",
          "app.db",
          "app.models.tenant"
        ]
      }
    },
    {
      "file": "services/pattern_detection.py",
      "layer": "L4",
      "layer_source": "declared",
      "components": [
        {
          "type": "function",
          "name": "compute_error_signature",
          "purpose": "Compute a stable signature for an error message."
        },
        {
          "type": "async_function",
          "name": "detect_failure_patterns",
          "purpose": "Detect repeated failure patterns."
        },
        {
          "type": "async_function",
          "name": "detect_cost_spikes",
          "purpose": "Detect abnormal cost increases."
        },
        {
          "type": "async_function",
          "name": "emit_feedback",
          "purpose": "Emit a feedback record."
        },
        {
          "type": "async_function",
          "name": "run_pattern_detection",
          "purpose": "Run full pattern detection cycle."
        },
        {
          "type": "async_function",
          "name": "get_feedback_summary",
          "purpose": "Get feedback summary for ops visibility."
        }
      ],
      "calls": {
        "L6": [
          "app.db",
          "app.models.feedback",
          "app.models.tenant"
        ]
      }
    },
    {
      "file": "services/plan_generation_engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Plan generation (domain logic)",
      "temporal": {
        "trigger": "api (run creation)",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PlanGenerationContext",
          "purpose": "Context for plan generation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PlanGenerationResult",
          "purpose": "Result of plan generation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PlanGenerationEngine",
          "purpose": "L4 Domain Engine for plan generation.",
          "methods": [
            "generate"
          ]
        },
        {
          "type": "function",
          "name": "generate_plan_for_run",
          "purpose": "Convenience function to generate a plan for a run."
        }
      ],
      "calls": {
        "L4": [
          "app.memory",
          "app.planners",
          "app.skills"
        ],
        "L6": [
          "app.utils.budget_tracker",
          "app.utils.plan_inspector"
        ]
      }
    },
    {
      "file": "services/policy_violation_service.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "S3 violation truth model, fact persistence, evidence linking",
      "components": [
        {
          "type": "class",
          "name": "ViolationFact",
          "purpose": "Authoritative violation fact - must be persisted before incident creation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ViolationIncident",
          "purpose": "Result of creating an incident from a violation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyViolationService",
          "purpose": "Service for handling policy violations with S3 truth guarantees.",
          "methods": [
            "persist_violation_fact",
            "check_violation_persisted",
            "check_policy_enabled",
            "persist_evidence",
            "check_incident_exists",
            "create_incident_from_violation",
            "persist_violation_and_create_incident",
            "verify_violation_truth"
          ]
        },
        {
          "type": "async_function",
          "name": "handle_policy_violation",
          "purpose": "Handle a policy violation with S3 truth guarantees."
        }
      ],
      "calls": {
        "L4": [
          "app.services.incident_aggregator"
        ],
        "L6": [
          "app.utils.runtime",
          "app.db"
        ]
      }
    },
    {
      "file": "services/recovery_evaluation_engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Recovery evaluation decision-making (domain logic)",
      "temporal": {
        "trigger": "worker (via failure events)",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "FailureContext",
          "purpose": "Context for recovery evaluation (mirrors L5 FailureEvent for L4 use).",
          "methods": []
        },
        {
          "type": "class",
          "name": "RecoveryDecision",
          "purpose": "Domain decision DTO returned by L4 engine to L5 executor.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "RecoveryEvaluationEngine",
          "purpose": "L4 Domain Engine for recovery evaluation decisions.",
          "methods": [
            "evaluate",
            "emit_decision_record"
          ]
        },
        {
          "type": "function",
          "name": "evaluate_recovery",
          "purpose": "Convenience function to evaluate a failure and get a decision."
        },
        {
          "type": "async_function",
          "name": "evaluate_and_execute",
          "purpose": "Full entry point: evaluate failure and execute decision."
        }
      ],
      "calls": {
        "L4": [
          "app.contracts.decisions",
          "app.services.recovery_matcher",
          "app.services.recovery_rule_engine"
        ],
        "L5": [
          "app.worker.recovery_evaluator"
        ]
      }
    },
    {
      "file": "services/recovery_matcher.py",
      "layer": "L4",
      "layer_source": "declared",
      "components": [
        {
          "type": "class",
          "name": "MatchResult",
          "purpose": "Result from matching a failure to a recovery suggestion.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RecoveryMatcher",
          "purpose": "Matches failures to recovery suggestions using pattern matching",
          "methods": [
            "suggest_hybrid",
            "suggest",
            "get_candidates",
            "approve_candidate"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.memory.vector_store"
        ],
        "L6": [
          "app.infra"
        ],
        "external": [
          "app.security.sanitize"
        ]
      }
    },
    {
      "file": "services/recovery_rule_engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "components": [
        {
          "type": "class",
          "name": "RuleContext",
          "purpose": "Context provided to rules for evaluation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "RuleResult",
          "purpose": "Result from evaluating a single rule.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "EvaluationResult",
          "purpose": "Complete result from rule evaluation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "Rule",
          "purpose": "Base class for recovery rules.",
          "methods": [
            "evaluate"
          ]
        },
        {
          "type": "class",
          "name": "ErrorCodeRule",
          "purpose": "Match based on error code patterns.",
          "methods": [
            "evaluate"
          ]
        },
        {
          "type": "class",
          "name": "HistoricalPatternRule",
          "purpose": "Match based on historical success patterns.",
          "methods": [
            "evaluate"
          ]
        },
        {
          "type": "class",
          "name": "SkillSpecificRule",
          "purpose": "Rules specific to certain skills.",
          "methods": [
            "evaluate"
          ]
        },
        {
          "type": "class",
          "name": "OccurrenceThresholdRule",
          "purpose": "Escalate based on occurrence count.",
          "methods": [
            "evaluate"
          ]
        },
        {
          "type": "class",
          "name": "CompositeRule",
          "purpose": "Combine multiple rules with AND/OR logic.",
          "methods": [
            "evaluate"
          ]
        },
        {
          "type": "class",
          "name": "RecoveryRuleEngine",
          "purpose": "Evaluates rules against failure context to recommend recovery actions.",
          "methods": [
            "add_rule",
            "remove_rule",
            "evaluate"
          ]
        },
        {
          "type": "function",
          "name": "combine_confidences",
          "purpose": "Combine rule and matcher confidence scores."
        },
        {
          "type": "function",
          "name": "should_select_action",
          "purpose": "Determine if an action should be selected based on combined confidence."
        },
        {
          "type": "function",
          "name": "should_auto_execute",
          "purpose": "Determine if a recovery action should be auto-executed based on confidence."
        },
        {
          "type": "function",
          "name": "classify_error_category",
          "purpose": "Classify error codes into a category."
        },
        {
          "type": "function",
          "name": "suggest_recovery_mode",
          "purpose": "Suggest a recovery mode based on error codes."
        },
        {
          "type": "function",
          "name": "evaluate_rules",
          "purpose": "Convenience function to evaluate rules against a failure."
        }
      ]
    },
    {
      "file": "services/recovery_write_service.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "DB write delegation for Recovery APIs (Phase 2B extraction)",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "RecoveryWriteService",
          "purpose": "Sync DB write operations for Recovery APIs.",
          "methods": [
            "upsert_recovery_candidate",
            "get_candidate_by_idempotency_key",
            "enqueue_evaluation_db_fallback",
            "update_recovery_candidate",
            "insert_suggestion_provenance",
            "commit",
            "rollback"
          ]
        }
      ],
      "calls": {
        "L6": [
          "app.infra"
        ]
      }
    },
    {
      "file": "services/replay_determinism.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "DeterminismLevel",
          "purpose": "Levels of determinism for replay validation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ModelVersion",
          "purpose": "Track the model version used for a call.",
          "methods": [
            "to_dict",
            "from_dict"
          ]
        },
        {
          "type": "class",
          "name": "PolicyDecision",
          "purpose": "Record of a policy enforcement decision.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "ReplayMatch",
          "purpose": "Result of replay comparison.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayResult",
          "purpose": "Result of replay validation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CallRecord",
          "purpose": "Record of a call for replay validation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "ReplayValidator",
          "purpose": "Validates replay determinism at configurable levels.",
          "methods": [
            "validate_replay",
            "hash_content"
          ]
        },
        {
          "type": "class",
          "name": "ReplayContextBuilder",
          "purpose": "Builds replay context from API calls.",
          "methods": [
            "build_call_record"
          ]
        }
      ]
    },
    {
      "file": "services/scoped_execution.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Pre-execution gate, scope enforcement",
      "components": [
        {
          "type": "class",
          "name": "RiskClass",
          "purpose": "Risk classification for recovery actions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExecutionScope",
          "purpose": "Type of scoped execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ScopedExecutionResult",
          "purpose": "Result of a scoped execution test.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RecoveryAction",
          "purpose": "A recovery action to be tested in scoped execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ScopedExecutionContext",
          "purpose": "M6 Scoped Execution primitive.",
          "methods": [
            "execute"
          ]
        },
        {
          "type": "class",
          "name": "ScopedExecutionRequired",
          "purpose": "Raised when a MEDIUM+ risk action is attempted without scoped pre-execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ScopeNotFound",
          "purpose": "Raised when a scope ID does not exist.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ScopeExhausted",
          "purpose": "Raised when a scope has been fully consumed.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ScopeExpired",
          "purpose": "Raised when a scope has expired.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ScopeActionMismatch",
          "purpose": "Raised when action does not match scope's allowed actions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ScopeIncidentMismatch",
          "purpose": "Raised when execution targets a different incident than scope.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BoundExecutionScope",
          "purpose": "A bound execution scope that gates recovery actions.",
          "methods": [
            "is_valid",
            "can_execute",
            "consume",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "ScopeStore",
          "purpose": "Thread-safe in-memory store for execution scopes.",
          "methods": [
            "create_scope",
            "get_scope",
            "get_scopes_for_incident",
            "revoke_scope",
            "cleanup_expired"
          ]
        },
        {
          "type": "function",
          "name": "get_scope_store",
          "purpose": "Get the global scope store."
        },
        {
          "type": "async_function",
          "name": "create_recovery_scope",
          "purpose": "Create a bound execution scope for recovery action."
        },
        {
          "type": "async_function",
          "name": "execute_with_scope",
          "purpose": "Execute a recovery action within a valid scope."
        },
        {
          "type": "async_function",
          "name": "validate_scope_required",
          "purpose": "Validate that execution without scope should fail."
        },
        {
          "type": "function",
          "name": "requires_scoped_execution",
          "purpose": "Decorator to enforce scoped pre-execution for risky recovery actions."
        },
        {
          "type": "async_function",
          "name": "test_recovery_scope",
          "purpose": "Test a recovery action in scoped execution."
        }
      ]
    },
    {
      "file": "services/user_write_service.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "DB write delegation for User management (Phase 2B extraction)",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "utc_now",
          "purpose": "Get current UTC time."
        },
        {
          "type": "class",
          "name": "UserWriteService",
          "purpose": "DB write operations for User management.",
          "methods": [
            "create_user",
            "update_user_login",
            "user_to_dict"
          ]
        }
      ],
      "calls": {
        "L6": [
          "app.models.tenant"
        ]
      }
    },
    {
      "file": "services/worker_write_service_async.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "DB write delegation for Worker API (Phase 2B extraction)",
      "temporal": {
        "trigger": "api",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "WorkerWriteServiceAsync",
          "purpose": "Async DB write operations for Worker API.",
          "methods": [
            "upsert_worker_run",
            "insert_cost_record",
            "insert_cost_advisory",
            "delete_worker_run",
            "commit",
            "get_worker_run"
          ]
        }
      ],
      "calls": {
        "L6": [
          "app.db",
          "app.models.tenant"
        ]
      }
    },
    {
      "file": "skills/__init__.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "load_skill",
          "purpose": "Lazy-load a skill class by name."
        },
        {
          "type": "function",
          "name": "load_all_skills",
          "purpose": "Load all registered skills. Call this when you need all skills registered."
        }
      ]
    },
    {
      "file": "skills/adapters/__init__.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "AdapterConfigurationError",
          "purpose": "Raised when adapter configuration is invalid in strict mode (ENV=prod).",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_llm_adapter",
          "purpose": "Get or create LLM adapter based on environment configuration."
        },
        {
          "type": "function",
          "name": "reset_adapter",
          "purpose": "Reset cached adapter instance. For testing only."
        },
        {
          "type": "function",
          "name": "get_claude_adapter",
          "purpose": "Get or create ClaudeAdapter instance."
        },
        {
          "type": "function",
          "name": "get_claude_stub",
          "purpose": "Get or create ClaudeAdapterStub instance."
        },
        {
          "type": "function",
          "name": "get_openai_adapter",
          "purpose": "Get or create OpenAIAdapter instance."
        },
        {
          "type": "function",
          "name": "register_all_adapters",
          "purpose": "Register all adapters with the llm_invoke adapter registry."
        }
      ],
      "calls": {
        "L4": [
          "app.skills.llm_invoke_v2",
          "app.skills.llm_invoke_v2",
          "app.skills.adapters.openai_adapter",
          "app.skills.adapters.claude_adapter"
        ]
      }
    },
    {
      "file": "skills/adapters/claude_adapter.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "ClaudeAdapter",
          "purpose": "Anthropic Claude adapter implementing LLMAdapter interface.",
          "methods": [
            "adapter_id",
            "default_model",
            "supports_seeding",
            "estimate_tokens",
            "invoke"
          ]
        },
        {
          "type": "function",
          "name": "register_claude_adapter",
          "purpose": "Register Claude adapter with the adapter registry."
        },
        {
          "type": "class",
          "name": "ClaudeAdapterStub",
          "purpose": "Stub version of ClaudeAdapter for testing without API access.",
          "methods": [
            "supports_seeding",
            "set_mock_response",
            "clear_mocks",
            "invoke"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.skills.llm_invoke_v2",
          "app.skills.llm_invoke_v2"
        ]
      }
    },
    {
      "file": "skills/adapters/metrics.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "estimate_cost_cents",
          "purpose": "Estimate cost in cents for token usage."
        },
        {
          "type": "function",
          "name": "track_llm_response",
          "purpose": "Track LLM response metrics with tenant/agent labels for billing & throttling."
        },
        {
          "type": "function",
          "name": "track_llm_usage",
          "purpose": "Decorator to automatically track LLM usage metrics."
        },
        {
          "type": "function",
          "name": "track_llm_usage_sync",
          "purpose": "Synchronous version of track_llm_usage decorator."
        },
        {
          "type": "function",
          "name": "estimate_monthly_cost",
          "purpose": "Estimate monthly LLM costs."
        }
      ],
      "calls": {
        "L4": [
          "app.skills.llm_invoke_v2"
        ],
        "external": [
          "app.metrics"
        ]
      }
    },
    {
      "file": "skills/base.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "SkillCircuitBreaker",
          "purpose": "Lightweight circuit breaker for M11 external skills.",
          "methods": [
            "is_open",
            "record_success",
            "record_failure",
            "get_cooldown_remaining"
          ]
        },
        {
          "type": "function",
          "name": "get_circuit_breaker",
          "purpose": "Get or create circuit breaker for a target."
        },
        {
          "type": "class",
          "name": "IdempotentSkill",
          "purpose": "Base class for skills with idempotency support.",
          "methods": [
            "skill_name",
            "execute",
            "get_input_schema",
            "get_output_schema"
          ]
        },
        {
          "type": "class",
          "name": "ExternalSkill",
          "purpose": "Base class for skills that call external APIs.",
          "methods": [
            "execute"
          ]
        }
      ]
    },
    {
      "file": "skills/calendar_write.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "CalendarWriteSkill",
          "purpose": "Calendar write skill for creating calendar events.",
          "methods": [
            "execute"
          ]
        }
      ]
    },
    {
      "file": "skills/email_send.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "EmailSendConfig",
          "purpose": "Configuration schema for email_send skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EmailSendSkill",
          "purpose": "Email sending skill using Resend API.",
          "methods": [
            "execute",
            "get_input_schema",
            "get_output_schema"
          ]
        }
      ]
    },
    {
      "file": "skills/executor.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "SkillExecutionError",
          "purpose": "Error during skill execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SkillValidationError",
          "purpose": "Input/output validation failed.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BudgetExceededError",
          "purpose": "Budget limit exceeded - skill execution blocked.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SkillExecutor",
          "purpose": "Executes skills with input/output validation.",
          "methods": [
            "execute_step",
            "execute"
          ]
        },
        {
          "type": "async_function",
          "name": "execute_skill",
          "purpose": "Convenience function to execute a skill with default executor."
        }
      ]
    },
    {
      "file": "skills/http_call.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "HttpCallConfig",
          "purpose": "Configuration schema for http_call skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "HttpCallSkill",
          "purpose": "HTTP call skill with configurable behavior.",
          "methods": [
            "execute",
            "get_input_schema",
            "get_output_schema"
          ]
        }
      ]
    },
    {
      "file": "skills/http_call_v2.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "ErrorCategory",
          "purpose": "Error categories from error_contract.md",
          "methods": []
        },
        {
          "type": "class",
          "name": "ErrorMapping",
          "purpose": "Mapping from HTTP status to error info.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RetryConfig",
          "purpose": "Retry configuration.",
          "methods": []
        },
        {
          "type": "function",
          "name": "compute_retry_delay",
          "purpose": "Compute deterministic retry delay."
        },
        {
          "type": "function",
          "name": "validate_idempotency",
          "purpose": "Validate idempotency key requirement."
        },
        {
          "type": "function",
          "name": "validate_url",
          "purpose": "Validate URL against blocked hosts."
        },
        {
          "type": "function",
          "name": "map_http_error",
          "purpose": "Map HTTP status code to error info."
        },
        {
          "type": "function",
          "name": "map_network_error",
          "purpose": "Map network exception to error info."
        },
        {
          "type": "class",
          "name": "MockResponse",
          "purpose": "Mock HTTP response for testing.",
          "methods": [
            "json"
          ]
        },
        {
          "type": "function",
          "name": "set_mock_response",
          "purpose": "Set a mock response for testing."
        },
        {
          "type": "function",
          "name": "clear_mock_responses",
          "purpose": "Clear all mock responses."
        },
        {
          "type": "async_function",
          "name": "http_call_execute",
          "purpose": "Execute HTTP call with error contract enforcement."
        },
        {
          "type": "async_function",
          "name": "http_call_handler",
          "purpose": "Handler function for skill registry."
        },
        {
          "type": "function",
          "name": "register_http_call",
          "purpose": "Register http_call skill with registry."
        }
      ],
      "calls": {
        "L5": [
          "app.worker.runtime.core"
        ]
      }
    },
    {
      "file": "skills/json_transform.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "TransformMapping",
          "purpose": "A single transformation mapping.",
          "methods": []
        },
        {
          "type": "class",
          "name": "JsonTransformInput",
          "purpose": "Input schema for json_transform skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "JsonTransformOutput",
          "purpose": "Output schema for json_transform skill.",
          "methods": []
        },
        {
          "type": "function",
          "name": "transform_json",
          "purpose": "Transform JSON payload using mapping."
        },
        {
          "type": "class",
          "name": "JsonTransformSkill",
          "purpose": "Transform JSON payloads using dot-path mapping.",
          "methods": [
            "execute"
          ]
        }
      ]
    },
    {
      "file": "skills/json_transform_v2.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "async_function",
          "name": "json_transform_execute",
          "purpose": "Execute JSON transformation."
        },
        {
          "type": "async_function",
          "name": "json_transform_handler",
          "purpose": "Handler function for skill registry."
        },
        {
          "type": "function",
          "name": "register_json_transform",
          "purpose": "Register json_transform skill with registry."
        }
      ],
      "calls": {
        "L5": [
          "app.worker.runtime.core"
        ]
      }
    },
    {
      "file": "skills/kv_store.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "KVStoreConfig",
          "purpose": "Configuration schema for kv_store skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "KVStoreSkill",
          "purpose": "Redis KV Store skill with idempotency support.",
          "methods": [
            "execute",
            "get_input_schema",
            "get_output_schema"
          ]
        }
      ]
    },
    {
      "file": "skills/llm_invoke.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "CacheEntry",
          "purpose": "A cached LLM response with metadata.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PromptCache",
          "purpose": "Thread-safe LLM prompt cache with TTL and size limits.",
          "methods": [
            "get",
            "set",
            "clear",
            "stats"
          ]
        },
        {
          "type": "function",
          "name": "get_prompt_cache",
          "purpose": "Get or create the global prompt cache."
        },
        {
          "type": "function",
          "name": "configure_prompt_cache",
          "purpose": "Configure the global prompt cache."
        },
        {
          "type": "class",
          "name": "LLMInvokeConfig",
          "purpose": "Configuration for llm_invoke skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LLMInvokeSkill",
          "purpose": "LLM inference skill for AI-powered processing steps.",
          "methods": [
            "execute"
          ]
        }
      ]
    },
    {
      "file": "skills/llm_invoke_v2.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "ErrorCategory",
          "purpose": "Error categories from error_contract.md",
          "methods": []
        },
        {
          "type": "class",
          "name": "ErrorMapping",
          "purpose": "Mapping from error type to error info.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Message",
          "purpose": "Chat message.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LLMConfig",
          "purpose": "LLM invocation configuration.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LLMResponse",
          "purpose": "LLM response.",
          "methods": []
        },
        {
          "type": "function",
          "name": "estimate_cost",
          "purpose": "Estimate cost in cents."
        },
        {
          "type": "class",
          "name": "LLMAdapter",
          "purpose": "Abstract base class for LLM adapters.",
          "methods": [
            "adapter_id",
            "default_model",
            "supports_seeding",
            "invoke",
            "estimate_tokens"
          ]
        },
        {
          "type": "class",
          "name": "StubAdapter",
          "purpose": "Stub adapter for deterministic testing.",
          "methods": [
            "adapter_id",
            "default_model",
            "supports_seeding",
            "set_response",
            "set_error",
            "clear_responses",
            "invoke"
          ]
        },
        {
          "type": "function",
          "name": "register_adapter",
          "purpose": "Register an LLM adapter."
        },
        {
          "type": "function",
          "name": "get_adapter",
          "purpose": "Get adapter by ID."
        },
        {
          "type": "function",
          "name": "list_adapters",
          "purpose": "List registered adapter IDs."
        },
        {
          "type": "async_function",
          "name": "llm_invoke_execute",
          "purpose": "Execute LLM invocation with error contract enforcement."
        },
        {
          "type": "async_function",
          "name": "llm_invoke_handler",
          "purpose": "Handler function for skill registry."
        },
        {
          "type": "function",
          "name": "register_llm_invoke",
          "purpose": "Register llm_invoke skill with registry."
        }
      ],
      "calls": {
        "L5": [
          "app.worker.runtime.core"
        ]
      }
    },
    {
      "file": "skills/postgres_query.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "PostgresQueryInput",
          "purpose": "Input schema for postgres_query skill.",
          "methods": [
            "validate_query_safety"
          ]
        },
        {
          "type": "class",
          "name": "PostgresQueryOutput",
          "purpose": "Output schema for postgres_query skill.",
          "methods": []
        },
        {
          "type": "function",
          "name": "is_read_only_query",
          "purpose": "Check if query is read-only (SELECT, WITH...SELECT, EXPLAIN)."
        },
        {
          "type": "class",
          "name": "PostgresQuerySkill",
          "purpose": "Execute safe, parameterized PostgreSQL queries.",
          "methods": [
            "execute"
          ]
        }
      ]
    },
    {
      "file": "skills/registry.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "SkillInterface",
          "purpose": "Protocol defining the skill interface.",
          "methods": [
            "execute",
            "get_input_schema",
            "get_output_schema"
          ]
        },
        {
          "type": "class",
          "name": "SkillEntry",
          "purpose": "Registry entry for a registered skill.",
          "methods": [
            "create_instance",
            "to_manifest",
            "to_dict"
          ]
        },
        {
          "type": "function",
          "name": "skill",
          "purpose": "Decorator to register a skill class."
        },
        {
          "type": "function",
          "name": "register_skill",
          "purpose": "Register a skill class in the registry (legacy function)."
        },
        {
          "type": "function",
          "name": "get_skill",
          "purpose": "Get a skill entry from the registry (legacy format)."
        },
        {
          "type": "function",
          "name": "get_skill_entry",
          "purpose": "Get the full SkillEntry from the registry."
        },
        {
          "type": "function",
          "name": "create_skill_instance",
          "purpose": "Create an instance of a skill from the registry."
        },
        {
          "type": "function",
          "name": "list_skills",
          "purpose": "List all registered skills."
        },
        {
          "type": "function",
          "name": "get_skill_manifest",
          "purpose": "Get skill manifest for planner context."
        },
        {
          "type": "function",
          "name": "get_skills_by_tag",
          "purpose": "Get all skills with a specific tag."
        },
        {
          "type": "function",
          "name": "skill_exists",
          "purpose": "Check if a skill is registered."
        },
        {
          "type": "function",
          "name": "set_skill_config",
          "purpose": "Set configuration for a skill."
        },
        {
          "type": "function",
          "name": "get_skill_config",
          "purpose": "Get configuration for a skill."
        },
        {
          "type": "function",
          "name": "create_skill_with_config",
          "purpose": "Create a skill instance using global configuration."
        }
      ]
    },
    {
      "file": "skills/registry_v2.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "SkillVersion",
          "purpose": "Semantic version for skills.",
          "methods": [
            "parse"
          ]
        },
        {
          "type": "class",
          "name": "SkillRegistration",
          "purpose": "Complete skill registration including descriptor, handler, and metadata.",
          "methods": [
            "skill_id",
            "version",
            "versioned_key",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "SkillRegistry",
          "purpose": "M2 Skill Registry with versioning and persistence support.",
          "methods": [
            "register",
            "deregister",
            "resolve",
            "get_handler",
            "get_descriptor",
            "list",
            "list_all_versions",
            "list_by_tag",
            "exists",
            "get_all_skill_ids"
          ]
        },
        {
          "type": "function",
          "name": "get_global_registry",
          "purpose": "Get the global registry instance (creates if needed)."
        },
        {
          "type": "function",
          "name": "set_global_registry",
          "purpose": "Set the global registry instance."
        },
        {
          "type": "function",
          "name": "register_skill",
          "purpose": "Register a skill in the global registry."
        },
        {
          "type": "function",
          "name": "get_skill_handler",
          "purpose": "Get a skill handler from the global registry."
        },
        {
          "type": "function",
          "name": "get_skill_descriptor",
          "purpose": "Get a skill descriptor from the global registry."
        },
        {
          "type": "class",
          "name": "ContractDiff",
          "purpose": "Represents differences between two skill contracts.",
          "methods": [
            "has_breaking_changes",
            "is_compatible",
            "to_dict"
          ]
        },
        {
          "type": "function",
          "name": "compare_versions",
          "purpose": "Compare two semantic versions."
        },
        {
          "type": "function",
          "name": "diff_contracts",
          "purpose": "Compare two skill descriptors and identify changes."
        },
        {
          "type": "function",
          "name": "is_version_compatible",
          "purpose": "Check if actual version satisfies the required version."
        },
        {
          "type": "function",
          "name": "resolve_skill_with_version",
          "purpose": "Resolve a skill with version compatibility checking."
        }
      ]
    },
    {
      "file": "skills/slack_send.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "SlackSendConfig",
          "purpose": "Configuration schema for slack_send skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SlackSendSkill",
          "purpose": "Slack message sending skill via webhook.",
          "methods": [
            "execute",
            "get_input_schema",
            "get_output_schema"
          ]
        }
      ]
    },
    {
      "file": "skills/stubs/http_call_stub.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "MockResponse",
          "purpose": "Configurable mock response for http_call stub.",
          "methods": []
        },
        {
          "type": "class",
          "name": "HttpCallStub",
          "purpose": "HTTP Call stub with configurable responses.",
          "methods": [
            "add_response",
            "add_error",
            "execute",
            "reset"
          ]
        },
        {
          "type": "async_function",
          "name": "http_call_stub_handler",
          "purpose": "Handler function for http_call stub."
        },
        {
          "type": "function",
          "name": "get_http_call_stub",
          "purpose": "Get the global http_call stub instance for configuration."
        },
        {
          "type": "function",
          "name": "configure_http_call_stub",
          "purpose": "Replace the global http_call stub instance."
        }
      ]
    },
    {
      "file": "skills/stubs/json_transform_stub.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "JsonTransformStub",
          "purpose": "JSON Transform stub with deterministic operations.",
          "methods": [
            "execute",
            "reset"
          ]
        },
        {
          "type": "async_function",
          "name": "json_transform_stub_handler",
          "purpose": "Handler function for json_transform stub."
        },
        {
          "type": "function",
          "name": "get_json_transform_stub",
          "purpose": "Get the global json_transform stub instance for configuration."
        },
        {
          "type": "function",
          "name": "configure_json_transform_stub",
          "purpose": "Replace the global json_transform stub instance."
        }
      ]
    },
    {
      "file": "skills/stubs/llm_invoke_stub.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "MockLlmResponse",
          "purpose": "Configurable mock LLM response.",
          "methods": []
        },
        {
          "type": "class",
          "name": "LlmInvokeStub",
          "purpose": "LLM Invoke stub with deterministic responses.",
          "methods": [
            "add_response",
            "add_error",
            "execute",
            "reset"
          ]
        },
        {
          "type": "async_function",
          "name": "llm_invoke_stub_handler",
          "purpose": "Handler function for llm_invoke stub."
        },
        {
          "type": "function",
          "name": "get_llm_invoke_stub",
          "purpose": "Get the global llm_invoke stub instance for configuration."
        },
        {
          "type": "function",
          "name": "configure_llm_invoke_stub",
          "purpose": "Replace the global llm_invoke stub instance."
        }
      ]
    },
    {
      "file": "skills/voyage_embed.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "VoyageEmbedConfig",
          "purpose": "Configuration schema for voyage_embed skill.",
          "methods": []
        },
        {
          "type": "class",
          "name": "VoyageEmbedSkill",
          "purpose": "Voyage AI embedding skill.",
          "methods": [
            "execute",
            "get_input_schema",
            "get_output_schema"
          ]
        }
      ]
    },
    {
      "file": "skills/webhook_send.py",
      "layer": "L4",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "WebhookSendConfig",
          "purpose": "Configuration schema for webhook_send skill.",
          "methods": []
        },
        {
          "type": "function",
          "name": "sign_payload",
          "purpose": "Generate HMAC-SHA256 signature for payload."
        },
        {
          "type": "function",
          "name": "verify_signature",
          "purpose": "Verify HMAC-SHA256 signature."
        },
        {
          "type": "class",
          "name": "WebhookSendSkill",
          "purpose": "Generic webhook skill with HMAC signing.",
          "methods": [
            "execute",
            "get_input_schema",
            "get_output_schema"
          ]
        }
      ]
    },
    {
      "file": "worker/simulate.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Pre-execution cost simulation (M5)",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "FeasibilityStatus",
          "purpose": "Simulation feasibility results.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StepRisk",
          "purpose": "Risk assessment for a single step.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SimulationResult",
          "purpose": "Result of plan simulation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CostSimulator",
          "purpose": "Pre-execution cost and feasibility simulator.",
          "methods": [
            "simulate"
          ]
        },
        {
          "type": "function",
          "name": "simulate_plan",
          "purpose": "Convenience function to simulate a plan."
        }
      ]
    },
    {
      "file": "workers/business_builder/agents/definitions.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Business builder agent definitions",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "create_researcher_agent",
          "purpose": "Research Analyst Agent."
        },
        {
          "type": "function",
          "name": "create_strategist_agent",
          "purpose": "Brand Strategist Agent."
        },
        {
          "type": "function",
          "name": "create_copywriter_agent",
          "purpose": "Copywriter Agent."
        },
        {
          "type": "function",
          "name": "create_ux_agent",
          "purpose": "UX Layout Designer Agent."
        },
        {
          "type": "function",
          "name": "create_recovery_agent",
          "purpose": "Recovery Engineer Agent."
        },
        {
          "type": "function",
          "name": "create_governor_agent",
          "purpose": "Cost Governor Agent."
        },
        {
          "type": "function",
          "name": "create_validator_agent",
          "purpose": "Pre-flight Validator Agent."
        },
        {
          "type": "function",
          "name": "register_all_agents",
          "purpose": "Register all worker agents with M12 agent registry."
        }
      ],
      "calls": {
        "L4": [
          "app.agents.sba.schema",
          "app.agents.sba.service"
        ]
      }
    },
    {
      "file": "workers/business_builder/execution_plan.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Business builder execution planning",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "StageStatus",
          "purpose": "Status of an execution stage.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StageCategory",
          "purpose": "Stage categories matching M19 policy categories.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StageResult",
          "purpose": "Result of a single stage execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExecutionStage",
          "purpose": "A single stage in the execution plan.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExecutionPlan",
          "purpose": "Complete execution plan for Business Builder Worker.",
          "methods": [
            "get_stages_by_category",
            "get_execution_order",
            "add_stage",
            "get_stage",
            "get_stage_result",
            "get_output",
            "to_replay_token",
            "to_yaml",
            "from_yaml"
          ]
        },
        {
          "type": "function",
          "name": "create_business_builder_plan",
          "purpose": "Create the default Business Builder execution plan."
        }
      ]
    },
    {
      "file": "workers/business_builder/stages/copy.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Copy generation stage",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "CopyOutput",
          "purpose": "Structured output from copy stage.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CopyStage",
          "purpose": "Copy Generation Stage.",
          "methods": [
            "execute"
          ]
        }
      ]
    },
    {
      "file": "workers/business_builder/stages/research.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Research stage",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "ResearchOutput",
          "purpose": "Structured output from research stage.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ResearchStage",
          "purpose": "Market Research Stage.",
          "methods": [
            "execute"
          ]
        }
      ]
    },
    {
      "file": "workers/business_builder/stages/strategy.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Strategy generation stage",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "StrategyOutput",
          "purpose": "Structured output from strategy stage.",
          "methods": []
        },
        {
          "type": "class",
          "name": "StrategyStage",
          "purpose": "Brand Strategy Development Stage.",
          "methods": [
            "execute"
          ]
        }
      ]
    },
    {
      "file": "workers/business_builder/stages/ux.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "UX generation stage",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "UXOutput",
          "purpose": "Structured output from UX stage.",
          "methods": []
        },
        {
          "type": "class",
          "name": "UXStage",
          "purpose": "UX Layout Generation Stage.",
          "methods": [
            "execute"
          ]
        }
      ]
    },
    {
      "file": "workflow/canonicalize.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Workflow input/output canonicalization",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "canonicalize_for_golden",
          "purpose": "Canonicalize an object for golden file comparison."
        },
        {
          "type": "function",
          "name": "canonical_json",
          "purpose": "Produce canonical JSON string for deterministic comparison."
        },
        {
          "type": "function",
          "name": "canonical_hash",
          "purpose": "Compute deterministic hash of an object."
        },
        {
          "type": "function",
          "name": "redact_sensitive_fields",
          "purpose": "Redact sensitive fields from an object (in-place safe copy)."
        },
        {
          "type": "function",
          "name": "compare_canonical",
          "purpose": "Compare two objects after canonicalization."
        },
        {
          "type": "function",
          "name": "strip_volatile_from_events",
          "purpose": "Strip volatile fields from a list of golden events."
        }
      ]
    },
    {
      "file": "workflow/checkpoint.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Workflow checkpoint persistence and recovery",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "CheckpointVersionConflictError",
          "purpose": "Raised when concurrent update detected via version mismatch.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkflowCheckpoint",
          "purpose": "DB model for workflow checkpoints.",
          "methods": [
            "step_outputs",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CheckpointData",
          "purpose": "Immutable checkpoint data returned by load().",
          "methods": []
        },
        {
          "type": "class",
          "name": "CheckpointStore",
          "purpose": "Async checkpoint store for workflow persistence with optimistic locking.",
          "methods": [
            "init_tables",
            "ping",
            "save",
            "save_with_retry",
            "load",
            "delete",
            "list_running"
          ]
        },
        {
          "type": "class",
          "name": "InMemoryCheckpointStore",
          "purpose": "In-memory checkpoint store for unit tests.",
          "methods": [
            "init_tables",
            "ping",
            "save",
            "save_with_retry",
            "load",
            "delete",
            "list_running"
          ]
        }
      ]
    },
    {
      "file": "workflow/engine.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Deterministic workflow execution engine",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "StepDescriptor",
          "purpose": "Describes a single workflow step.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "WorkflowSpec",
          "purpose": "Complete workflow specification.",
          "methods": [
            "to_dict",
            "from_dict"
          ]
        },
        {
          "type": "class",
          "name": "StepContext",
          "purpose": "Context passed to each step execution.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "StepResult",
          "purpose": "Result of a single step execution.",
          "methods": [
            "to_dict",
            "to_canonical_json",
            "content_hash",
            "from_error"
          ]
        },
        {
          "type": "class",
          "name": "WorkflowResult",
          "purpose": "Final result of workflow execution.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "SkillRegistry",
          "purpose": "Protocol for skill registry access.",
          "methods": [
            "get"
          ]
        },
        {
          "type": "class",
          "name": "WorkflowEngine",
          "purpose": "Deterministic Workflow Engine.",
          "methods": [
            "run"
          ]
        }
      ]
    },
    {
      "file": "workflow/errors.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Workflow error types and classification",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ErrorCategory",
          "purpose": "Error categories for classification and retry logic.",
          "methods": [
            "is_retryable"
          ]
        },
        {
          "type": "class",
          "name": "WorkflowErrorCode",
          "purpose": "Canonical error codes for workflow execution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkflowError",
          "purpose": "Structured workflow error with full metadata.",
          "methods": [
            "category",
            "http_status",
            "is_retryable",
            "max_retries",
            "backoff_base_ms",
            "recovery",
            "to_dict",
            "to_api_error"
          ]
        },
        {
          "type": "function",
          "name": "classify_exception",
          "purpose": "Classify an exception into a structured WorkflowError."
        },
        {
          "type": "function",
          "name": "get_error_metadata",
          "purpose": "Get full metadata for an error code."
        }
      ]
    },
    {
      "file": "workflow/external_guard.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "External call guards for workflow safety",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ExternalCallBlockedError",
          "purpose": "Raised when an external call is blocked by the guard.",
          "methods": []
        },
        {
          "type": "function",
          "name": "is_external_calls_disabled",
          "purpose": "Check if external calls are disabled."
        },
        {
          "type": "function",
          "name": "get_blocked_calls",
          "purpose": "Get list of blocked calls (call_type, target)."
        },
        {
          "type": "function",
          "name": "clear_blocked_calls",
          "purpose": "Clear blocked calls history."
        },
        {
          "type": "function",
          "name": "check_external_call_allowed",
          "purpose": "Check if an external call is allowed."
        },
        {
          "type": "class",
          "name": "_BlockedSocket",
          "purpose": "Socket wrapper that blocks external connections.",
          "methods": [
            "connect"
          ]
        },
        {
          "type": "class",
          "name": "ExternalCallsGuard",
          "purpose": "Context manager that blocks external network calls.",
          "methods": []
        },
        {
          "type": "function",
          "name": "block_external_calls",
          "purpose": "Context manager shorthand for ExternalCallsGuard."
        },
        {
          "type": "function",
          "name": "require_no_external_calls",
          "purpose": "Decorator that blocks external calls during function execution."
        },
        {
          "type": "function",
          "name": "assert_no_external_calls_made",
          "purpose": "Assert that no external calls were blocked."
        }
      ]
    },
    {
      "file": "workflow/golden.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Golden file validation for replay fidelity",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "GoldenEvent",
          "purpose": "A single event in the golden file.",
          "methods": [
            "to_dict",
            "to_deterministic_dict"
          ]
        },
        {
          "type": "class",
          "name": "GoldenRecorder",
          "purpose": "Golden-file recorder for workflow replay testing.",
          "methods": [
            "record_run_start",
            "record_step",
            "record_run_end",
            "sign_golden",
            "verify_golden",
            "load_golden",
            "compare_golden"
          ]
        },
        {
          "type": "class",
          "name": "InMemoryGoldenRecorder",
          "purpose": "In-memory golden recorder for testing.",
          "methods": [
            "record_run_start",
            "record_step",
            "record_run_end",
            "get_events",
            "clear"
          ]
        }
      ]
    },
    {
      "file": "workflow/planner_sandbox.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Sandboxed planner execution for safety",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SandboxReport",
          "purpose": "Result of sandbox validation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "PlannerSandbox",
          "purpose": "Sandbox for validating planner outputs.",
          "methods": [
            "validate_plan",
            "add_forbidden_skill",
            "remove_forbidden_skill"
          ]
        },
        {
          "type": "function",
          "name": "validate_step_structure",
          "purpose": "Validate step has required fields."
        },
        {
          "type": "function",
          "name": "validate_workflow_structure",
          "purpose": "Validate workflow spec has required fields."
        }
      ]
    },
    {
      "file": "workflow/policies.py",
      "layer": "L4",
      "layer_source": "declared",
      "purpose": "Workflow policy enforcement",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "BudgetStore",
          "purpose": "Protocol for shared budget storage across workers.",
          "methods": [
            "get_workflow_cost",
            "add_workflow_cost",
            "reset_workflow_cost"
          ]
        },
        {
          "type": "class",
          "name": "InMemoryBudgetStore",
          "purpose": "In-memory budget store for single-worker or testing.",
          "methods": [
            "get_workflow_cost",
            "add_workflow_cost",
            "reset_workflow_cost"
          ]
        },
        {
          "type": "class",
          "name": "RedisBudgetStore",
          "purpose": "Redis-based budget store for multi-worker deployments.",
          "methods": [
            "get_workflow_cost",
            "add_workflow_cost",
            "add_workflow_cost_if_below",
            "reset_workflow_cost",
            "close"
          ]
        },
        {
          "type": "class",
          "name": "BudgetExceededError",
          "purpose": "Raised when budget limits are exceeded.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyViolationError",
          "purpose": "Raised when a policy is violated.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyCheckResult",
          "purpose": "Result of a policy check.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyEnforcer",
          "purpose": "Policy enforcer for workflow step execution.",
          "methods": [
            "check_can_execute",
            "can_retry",
            "record_step_cost_async",
            "record_step_cost",
            "reset_workflow_costs_async",
            "reset_workflow_costs",
            "get_workflow_cost_async",
            "get_workflow_cost"
          ]
        }
      ]
    }
  ],
  "L5": [
    {
      "file": "integrations/dispatcher.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Integration event dispatcher",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "DispatcherConfig",
          "purpose": "Configuration for the integration dispatcher.",
          "methods": [
            "from_env"
          ]
        },
        {
          "type": "class",
          "name": "IntegrationDispatcher",
          "purpose": "Central dispatcher for the M25 integration loop.",
          "methods": [
            "register_handler",
            "is_bridge_enabled",
            "dispatch",
            "resolve_checkpoint",
            "get_loop_status",
            "get_pending_checkpoints",
            "retry_failed_stage",
            "revert_loop"
          ]
        }
      ]
    },
    {
      "file": "jobs/failure_aggregation.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Failure aggregation background job (orchestration only)",
      "temporal": {
        "trigger": "scheduler",
        "execution": "async"
      },
      "components": [
        {
          "type": "function",
          "name": "fetch_unmatched_failures",
          "purpose": "Fetch unmatched failures from database."
        },
        {
          "type": "function",
          "name": "write_output",
          "purpose": "Write aggregated patterns to JSON file."
        },
        {
          "type": "function",
          "name": "run_aggregation",
          "purpose": "Run the full aggregation pipeline."
        },
        {
          "type": "function",
          "name": "main",
          "purpose": "CLI entrypoint."
        }
      ],
      "calls": {
        "L4": [
          "app.jobs.failure_classification_engine",
          "app.jobs.storage"
        ],
        "L6": [
          "app.infra",
          "app.db"
        ]
      }
    },
    {
      "file": "jobs/graduation_evaluator.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Agent graduation evaluation job (orchestration only)",
      "temporal": {
        "trigger": "scheduler",
        "execution": "async"
      },
      "components": [
        {
          "type": "async_function",
          "name": "fetch_graduation_evidence",
          "purpose": "Fetch graduation evidence from database."
        },
        {
          "type": "async_function",
          "name": "evaluate_graduation_status",
          "purpose": "Evaluate graduation status from evidence."
        },
        {
          "type": "async_function",
          "name": "run_periodic_evaluation",
          "purpose": "Run periodic graduation evaluation."
        },
        {
          "type": "function",
          "name": "main",
          "purpose": "CLI entry point for manual runs."
        }
      ],
      "calls": {
        "L6": [
          "app.infra",
          "app.db"
        ],
        "external": [
          "app.integrations.graduation_engine",
          "app.integrations.graduation_engine"
        ]
      }
    },
    {
      "file": "jobs/storage.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Storage maintenance jobs",
      "temporal": {
        "trigger": "scheduler",
        "execution": "async"
      },
      "components": [
        {
          "type": "function",
          "name": "make_s3_client",
          "purpose": "Create S3-compatible client for Cloudflare R2."
        },
        {
          "type": "function",
          "name": "is_r2_configured",
          "purpose": "Check if R2 storage is properly configured."
        },
        {
          "type": "function",
          "name": "sha256_bytes",
          "purpose": "Compute SHA256 hash of bytes."
        },
        {
          "type": "function",
          "name": "generate_object_key",
          "purpose": "Generate object key with date-partitioned path."
        },
        {
          "type": "function",
          "name": "upload_to_r2_bytes",
          "purpose": "Upload bytes to R2 with retry logic."
        },
        {
          "type": "function",
          "name": "write_local_fallback",
          "purpose": "Write payload to local fallback storage."
        },
        {
          "type": "function",
          "name": "write_candidate_json_and_upload",
          "purpose": "Write candidate failure patterns JSON to R2 with local fallback."
        },
        {
          "type": "function",
          "name": "retry_local_fallback",
          "purpose": "Retry uploading a local fallback file to R2."
        },
        {
          "type": "function",
          "name": "verify_r2_object",
          "purpose": "Verify an object exists in R2 and return metadata."
        },
        {
          "type": "function",
          "name": "list_r2_objects",
          "purpose": "List objects in R2 bucket."
        }
      ],
      "calls": {
        "L6": [
          "app.infra",
          "app.utils.metrics_helpers",
          "app.db",
          "app.db"
        ],
        "external": [
          "app.secrets.vault_client"
        ]
      }
    },
    {
      "file": "optimization/coordinator.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Optimization envelope coordination",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "CoordinationError",
          "purpose": "Raised when coordination fails in an unrecoverable way.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CoordinationManager",
          "purpose": "C4 Multi-Envelope Coordination Manager.",
          "methods": [
            "active_envelope_count",
            "is_kill_switch_active",
            "get_active_envelopes",
            "get_audit_trail",
            "check_allowed",
            "apply",
            "revert",
            "kill_switch",
            "reset_kill_switch",
            "expire_envelope"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.optimization.audit_persistence",
          "app.optimization.envelope"
        ],
        "L6": [
          "app.infra"
        ]
      }
    },
    {
      "file": "optimization/manager.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Optimization envelope lifecycle management",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "EnvelopeApplication",
          "purpose": "Record of an active envelope application.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EnvelopeManager",
          "purpose": "Manages the lifecycle of optimization envelopes.",
          "methods": [
            "active_envelope_count",
            "can_apply",
            "apply",
            "revert",
            "revert_all",
            "get_active_envelopes",
            "get_audit_records",
            "is_envelope_active"
          ]
        },
        {
          "type": "function",
          "name": "get_envelope_manager",
          "purpose": "Get the global envelope manager instance."
        },
        {
          "type": "function",
          "name": "reset_manager_for_testing",
          "purpose": "Reset envelope manager. FOR TESTING ONLY."
        }
      ],
      "calls": {
        "L4": [
          "app.optimization.envelope",
          "app.optimization.killswitch"
        ]
      }
    },
    {
      "file": "policy/runtime/dag_executor.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "DAG-based parallel policy executor",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "StageResult",
          "purpose": "Result of executing a single stage.",
          "methods": [
            "success",
            "was_blocked"
          ]
        },
        {
          "type": "class",
          "name": "ExecutionTrace",
          "purpose": "Full execution trace across all stages.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "DAGExecutor",
          "purpose": "Executes policies in DAG order.",
          "methods": [
            "execute",
            "get_execution_plan",
            "visualize_plan"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.policy.compiler.grammar",
          "app.policy.ir.ir_nodes",
          "app.policy.optimizer.dag_sorter",
          "app.policy.runtime.deterministic_engine",
          "app.policy.runtime.intent"
        ]
      }
    },
    {
      "file": "runtime/failure_catalog.py",
      "layer": "L5",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "MatchType",
          "purpose": "Types of matching for error lookup.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RecoveryStrategy",
          "purpose": "Recovery strategies from the catalog.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CatalogEntry",
          "purpose": "A single entry from the failure catalog.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "MatchResult",
          "purpose": "Result of a catalog match operation.",
          "methods": [
            "recovery_mode",
            "is_retryable",
            "suggestions"
          ]
        },
        {
          "type": "class",
          "name": "FailureCatalog",
          "purpose": "Failure catalog for structured error handling.",
          "methods": [
            "version",
            "error_count",
            "match_code",
            "match_message",
            "match",
            "get_entry",
            "get_recovery_config",
            "get_category",
            "list_codes",
            "list_by_category"
          ]
        },
        {
          "type": "function",
          "name": "get_catalog",
          "purpose": "Get or create singleton catalog instance."
        },
        {
          "type": "function",
          "name": "match_failure",
          "purpose": "Convenience function to match failure."
        },
        {
          "type": "function",
          "name": "persist_failure_match",
          "purpose": "Persist a failure match to the database (M9)."
        },
        {
          "type": "async_function",
          "name": "persist_failure_match_async",
          "purpose": "Async version of persist_failure_match for async code paths."
        },
        {
          "type": "function",
          "name": "persist_failure_match_nonblocking",
          "purpose": "Non-blocking persistence with circuit breaker (M9 P0)."
        },
        {
          "type": "function",
          "name": "update_recovery_status",
          "purpose": "Update recovery status after a recovery attempt (M9)."
        },
        {
          "type": "function",
          "name": "match_and_persist",
          "purpose": "Match and persist in one call (M9 convenience function)."
        }
      ],
      "calls": {
        "L6": [
          "app.db",
          "app.db"
        ]
      }
    },
    {
      "file": "runtime/replay.py",
      "layer": "L5",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "get_trace_store",
          "purpose": "Get the appropriate trace store based on configuration."
        },
        {
          "type": "class",
          "name": "ReplayResult",
          "purpose": "Result of a replay operation.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "ReplayEngine",
          "purpose": "Engine for replaying stored plans.",
          "methods": [
            "replay_run"
          ]
        },
        {
          "type": "async_function",
          "name": "replay_run",
          "purpose": "Replay a previously executed run."
        },
        {
          "type": "async_function",
          "name": "validate_determinism",
          "purpose": "Validate determinism across multiple runs."
        }
      ],
      "calls": {
        "L4": [
          "app.traces.models",
          "app.traces.store",
          "app.traces.pg_store"
        ]
      }
    },
    {
      "file": "tasks/m10_metrics_collector.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "M10 metrics collection task",
      "temporal": {
        "trigger": "scheduler",
        "execution": "async"
      },
      "components": [
        {
          "type": "async_function",
          "name": "collect_redis_stream_metrics",
          "purpose": "Collect Redis stream metrics including dead-letter."
        },
        {
          "type": "async_function",
          "name": "collect_db_queue_metrics",
          "purpose": "Collect DB fallback queue metrics."
        },
        {
          "type": "async_function",
          "name": "collect_matview_freshness",
          "purpose": "Collect materialized view freshness metrics."
        },
        {
          "type": "async_function",
          "name": "collect_candidate_stats",
          "purpose": "Collect recovery candidate statistics."
        },
        {
          "type": "async_function",
          "name": "collect_m10_metrics",
          "purpose": "Collect all M10 recovery system metrics."
        },
        {
          "type": "async_function",
          "name": "run_metrics_collector",
          "purpose": "Run metrics collector as a background loop."
        },
        {
          "type": "async_function",
          "name": "main",
          "purpose": "CLI entry point for one-time collection."
        },
        {
          "type": "async_function",
          "name": "daemon_main",
          "purpose": "Daemon entry point with signal handling and systemd watchdog."
        }
      ],
      "calls": {
        "L4": [
          "app.tasks.recovery_queue_stream"
        ],
        "L6": [
          "app.infra",
          "app.db_async",
          "app.db_async",
          "app.db_async"
        ],
        "external": [
          "app.metrics"
        ]
      }
    },
    {
      "file": "tasks/memory_update.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Memory update background task",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "async_function",
          "name": "upsert_memory_pin",
          "purpose": "Upsert a memory pin via the memory service."
        },
        {
          "type": "async_function",
          "name": "apply_update_rules",
          "purpose": "Evaluate deterministic rules and apply memory writes."
        },
        {
          "type": "function",
          "name": "apply_update_rules_sync",
          "purpose": "Synchronous wrapper to apply update rules and wait for completion."
        }
      ],
      "calls": {
        "L4": [
          "app.memory.memory_service",
          "app.memory.memory_service"
        ]
      }
    },
    {
      "file": "tasks/recovery_queue.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Recovery queue processing",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "async_function",
          "name": "get_redis",
          "purpose": "Get or create async Redis client."
        },
        {
          "type": "async_function",
          "name": "enqueue_evaluation",
          "purpose": "Enqueue a recovery candidate for evaluation."
        },
        {
          "type": "async_function",
          "name": "dequeue_evaluation",
          "purpose": "Dequeue a recovery candidate for evaluation."
        },
        {
          "type": "async_function",
          "name": "complete_evaluation",
          "purpose": "Mark an evaluation task as complete."
        },
        {
          "type": "async_function",
          "name": "requeue_failed",
          "purpose": "Requeue failed tasks that haven't exceeded max retries."
        },
        {
          "type": "async_function",
          "name": "get_queue_stats",
          "purpose": "Get queue statistics."
        },
        {
          "type": "async_function",
          "name": "close",
          "purpose": "Close Redis connection."
        }
      ]
    },
    {
      "file": "tasks/recovery_queue_stream.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Recovery queue stream processing",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "async_function",
          "name": "get_redis",
          "purpose": "Get or create async Redis client."
        },
        {
          "type": "async_function",
          "name": "ensure_consumer_group",
          "purpose": "Ensure consumer group exists for the stream."
        },
        {
          "type": "async_function",
          "name": "enqueue_stream",
          "purpose": "Add item to Redis Stream (durable queue)."
        },
        {
          "type": "async_function",
          "name": "consume_batch",
          "purpose": "Read a batch of messages from the stream using XREADGROUP."
        },
        {
          "type": "async_function",
          "name": "consume_stream",
          "purpose": "Async generator for consuming messages from stream."
        },
        {
          "type": "async_function",
          "name": "ack_message",
          "purpose": "Acknowledge a message as processed."
        },
        {
          "type": "async_function",
          "name": "ack_and_delete",
          "purpose": "Acknowledge and delete a message from stream."
        },
        {
          "type": "async_function",
          "name": "claim_stalled_messages",
          "purpose": "Claim messages that have been pending longer than idle_ms."
        },
        {
          "type": "async_function",
          "name": "get_stream_info",
          "purpose": "Get stream and consumer group statistics."
        },
        {
          "type": "async_function",
          "name": "close",
          "purpose": "Close Redis connection."
        },
        {
          "type": "async_function",
          "name": "move_to_dead_letter",
          "purpose": "Move a message to the dead-letter stream atomically."
        },
        {
          "type": "async_function",
          "name": "process_stalled_with_dead_letter",
          "purpose": "Process stalled messages with dead-letter support, rate-limiting, and exponential backoff."
        },
        {
          "type": "async_function",
          "name": "get_dead_letter_count",
          "purpose": "Get the number of messages in the dead-letter stream."
        },
        {
          "type": "async_function",
          "name": "archive_dead_letter_to_db",
          "purpose": "Archive a dead-letter message to PostgreSQL before trimming from Redis."
        },
        {
          "type": "async_function",
          "name": "archive_and_trim_dead_letter",
          "purpose": "Archive old dead-letter messages to DB, then trim the Redis stream."
        },
        {
          "type": "async_function",
          "name": "get_reclaim_attempts",
          "purpose": "Get the number of reclaim attempts for a message."
        },
        {
          "type": "async_function",
          "name": "increment_reclaim_attempts",
          "purpose": "Increment reclaim attempts for a message."
        },
        {
          "type": "async_function",
          "name": "clear_reclaim_attempts",
          "purpose": "Clear reclaim attempts for a message (after processing or dead-lettering)."
        },
        {
          "type": "async_function",
          "name": "gc_reclaim_attempts",
          "purpose": "Garbage collect stale entries from the reclaim attempts HASH."
        },
        {
          "type": "function",
          "name": "calculate_backoff_ms",
          "purpose": "Calculate exponential backoff based on reclaim attempts."
        },
        {
          "type": "async_function",
          "name": "replay_dead_letter",
          "purpose": "Replay a message from dead-letter back to main stream with idempotency."
        },
        {
          "type": "async_function",
          "name": "replay_all_dead_letters",
          "purpose": "Replay all messages from dead-letter stream with idempotency."
        }
      ],
      "calls": {
        "L6": [
          "app.infra"
        ],
        "external": [
          "app.metrics"
        ]
      }
    },
    {
      "file": "worker/__init__.py",
      "layer": "L5",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "get_worker_pool",
          "purpose": "Lazy getter for WorkerPool class to avoid early sqlmodel import."
        },
        {
          "type": "function",
          "name": "get_run_runner",
          "purpose": "Lazy getter for RunRunner class to avoid early sqlmodel import."
        },
        {
          "type": "class",
          "name": "_LazyModule",
          "purpose": "Lazy module wrapper for backwards compatibility.",
          "methods": [
            "WorkerPool",
            "RunRunner"
          ]
        }
      ]
    },
    {
      "file": "worker/outbox_processor.py",
      "layer": "L5",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "OutboxProcessor",
          "purpose": "Processes outbox events with exactly-once semantics.",
          "methods": [
            "start",
            "stop",
            "acquire_lock",
            "release_lock",
            "extend_lock",
            "claim_events",
            "process_event",
            "complete_event",
            "process_batch",
            "run"
          ]
        },
        {
          "type": "function",
          "name": "main",
          "purpose": "CLI entry point."
        }
      ],
      "calls": {
        "L6": [
          "app.infra"
        ],
        "external": [
          "app.metrics"
        ]
      }
    },
    {
      "file": "worker/pool.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Worker pool dispatch (polls DB, dispatches to RunRunner)",
      "temporal": {
        "trigger": "scheduler (standalone process)",
        "execution": "sync (dispatch loop) + ThreadPoolExecutor (worker threads)"
      },
      "components": [
        {
          "type": "class",
          "name": "WorkerPool",
          "purpose": "Worker pool that polls for queued runs and dispatches to runner threads.",
          "methods": [
            "poll_and_dispatch",
            "stop"
          ]
        },
        {
          "type": "function",
          "name": "main",
          "purpose": "Entry point for running worker pool as standalone process."
        }
      ],
      "calls": {
        "L6": [
          "app.infra"
        ]
      }
    },
    {
      "file": "worker/recovery_claim_worker.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Recovery claim processing orchestration (L5 execution wrapper)",
      "temporal": {
        "trigger": "scheduler (standalone process)",
        "execution": "async"
      },
      "components": [
        {
          "type": "function",
          "name": "signal_handler",
          "purpose": "Handle shutdown signals gracefully."
        },
        {
          "type": "class",
          "name": "RecoveryClaimWorker",
          "purpose": "Worker that claims and processes recovery candidates using FOR UPDATE SKIP LOCKED.",
          "methods": [
            "claim_batch",
            "evaluate_candidate",
            "update_candidate",
            "release_pending",
            "process_batch",
            "run"
          ]
        },
        {
          "type": "async_function",
          "name": "main_async",
          "purpose": "Async main entry point."
        },
        {
          "type": "function",
          "name": "main",
          "purpose": "CLI entry point."
        }
      ],
      "calls": {
        "L5": [
          "app.worker.recovery_evaluator"
        ],
        "L6": [
          "app.infra"
        ]
      }
    },
    {
      "file": "worker/recovery_evaluator.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Recovery execution (L5 pure execution)",
      "temporal": {
        "trigger": "worker (failure events)",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "FailureEvent",
          "purpose": "Event representing a failure that needs recovery evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EvaluationOutcome",
          "purpose": "Outcome of recovery evaluation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RecoveryHooks",
          "purpose": "Registry for recovery evaluation hooks.",
          "methods": [
            "register",
            "unregister",
            "trigger"
          ]
        },
        {
          "type": "class",
          "name": "RecoveryExecutor",
          "purpose": "L5 Executor for recovery actions.",
          "methods": [
            "execute_decision"
          ]
        },
        {
          "type": "function",
          "name": "register_hook",
          "purpose": "Register a hook callback."
        },
        {
          "type": "function",
          "name": "unregister_hook",
          "purpose": "Unregister a hook callback."
        }
      ],
      "calls": {
        "L6": [
          "app.infra"
        ],
        "external": [
          "app.metrics"
        ]
      }
    },
    {
      "file": "worker/runner.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Run execution (sync entrypoint wrapping async internal execution)",
      "temporal": {
        "trigger": "worker-pool",
        "execution": "sync-over-async"
      },
      "components": [
        {
          "type": "class",
          "name": "BudgetContext",
          "purpose": "Immutable budget context loaded from PRE-RUN (Agent configuration).",
          "methods": [
            "remaining_cents",
            "would_exceed"
          ]
        },
        {
          "type": "function",
          "name": "calculate_llm_cost_cents",
          "purpose": "Calculate LLM cost in cents based on token usage."
        },
        {
          "type": "class",
          "name": "RunRunner",
          "purpose": "Executes a single run's plan steps.",
          "methods": [
            "run"
          ]
        }
      ],
      "calls": {
        "L6": [
          "app.infra"
        ]
      }
    },
    {
      "file": "worker/runtime/__init__.py",
      "layer": "L5",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "get_integrated_runtime_class",
          "purpose": "Lazy import for IntegratedRuntime (requires pydantic)."
        },
        {
          "type": "function",
          "name": "create_integrated_runtime",
          "purpose": "Lazy factory for IntegratedRuntime (requires pydantic)."
        }
      ]
    },
    {
      "file": "worker/runtime/contracts.py",
      "layer": "L5",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "ContractMetadata",
          "purpose": "Metadata about a contract's version and lifecycle.",
          "methods": [
            "now"
          ]
        },
        {
          "type": "class",
          "name": "SkillContract",
          "purpose": "Full contract for a skill including schemas and stability rules.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "FailureMode",
          "purpose": "A known failure mode for a skill.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CostModel",
          "purpose": "Cost estimation model for a skill.",
          "methods": [
            "estimate",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "BudgetTracker",
          "purpose": "Mutable budget tracker for a run.",
          "methods": [
            "remaining_cents",
            "can_spend",
            "spend",
            "to_dict"
          ]
        }
      ]
    },
    {
      "file": "worker/runtime/core.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Core runtime execution (StructuredOutcome, never throws)",
      "temporal": {
        "trigger": "api|worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "ErrorCategory",
          "purpose": "Error categories from M0 error taxonomy.",
          "methods": [
            "is_retryable"
          ]
        },
        {
          "type": "class",
          "name": "StructuredOutcome",
          "purpose": "Structured outcome that M0 golden files & replay tests expect.",
          "methods": [
            "to_dict",
            "to_canonical_json",
            "content_hash",
            "success",
            "failure"
          ]
        },
        {
          "type": "class",
          "name": "SkillDescriptor",
          "purpose": "Skill metadata returned by describe_skill().",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "ResourceContract",
          "purpose": "Resource contract for budget, rate limits, and concurrency.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "Runtime",
          "purpose": "Machine-Native Runtime (M1)",
          "methods": [
            "register_skill",
            "register_resource_contract",
            "execute",
            "describe_skill",
            "query",
            "get_resource_contract",
            "set_budget",
            "get_all_skills",
            "clear_history"
          ]
        }
      ],
      "calls": {
        "L4": [
          "app.workflow.metrics"
        ]
      }
    },
    {
      "file": "worker/runtime/integrated_runtime.py",
      "layer": "L5",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "IntegratedRuntime",
          "purpose": "Runtime integrated with SkillRegistry v2.",
          "methods": [
            "registry",
            "register_skill",
            "execute",
            "describe_skill",
            "query",
            "get_all_skills"
          ]
        },
        {
          "type": "function",
          "name": "create_integrated_runtime",
          "purpose": "Factory function to create an integrated runtime with optional stubs."
        }
      ]
    },
    {
      "file": "workers/business_builder/worker.py",
      "layer": "L5",
      "layer_source": "declared",
      "purpose": "Business builder main worker",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "EventEmitter",
          "purpose": "Protocol for event emission - allows worker to emit events.",
          "methods": [
            "emit"
          ]
        },
        {
          "type": "class",
          "name": "WorkerResult",
          "purpose": "Complete result from Business Builder Worker.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BusinessBuilderWorker",
          "purpose": "Business Builder Worker v0.3 - Real MOAT Integration.",
          "methods": [
            "run"
          ]
        },
        {
          "type": "async_function",
          "name": "replay",
          "purpose": "Replay a previous execution using Golden Replay (M4)."
        }
      ],
      "calls": {
        "L4": [
          "app.routing.care",
          "app.policy.runtime.dag_executor",
          "app.policy.runtime.deterministic_engine",
          "app.services.recovery_matcher",
          "app.services.recovery_matcher",
          "app.routing.learning",
          "app.routing.models"
        ]
      }
    }
  ],
  "L6": [
    {
      "file": "auth.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "API key verification dependency for FastAPI routes",
      "temporal": {
        "trigger": "api (every authenticated request)",
        "execution": "sync"
      },
      "components": [
        {
          "type": "async_function",
          "name": "verify_api_key",
          "purpose": "Verify the API key from X-AOS-Key header."
        }
      ]
    },
    {
      "file": "auth/actor.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Canonical actor model for all authorization decisions",
      "temporal": {
        "trigger": "api | worker | internal",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ActorType",
          "purpose": "Classification of actors for policy enforcement.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IdentitySource",
          "purpose": "How the identity was established.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ActorContext",
          "purpose": "Immutable, canonical representation of an authenticated actor.",
          "methods": [
            "has_role",
            "has_permission",
            "is_operator",
            "is_system",
            "is_tenant_scoped",
            "is_account_scoped",
            "is_team_scoped",
            "same_tenant",
            "same_account",
            "same_team"
          ]
        },
        {
          "type": "function",
          "name": "get_system_actor",
          "purpose": "Get a predefined system actor by name."
        },
        {
          "type": "function",
          "name": "create_operator_actor",
          "purpose": "Create an operator (founder/admin) actor."
        },
        {
          "type": "function",
          "name": "create_external_actor",
          "purpose": "Create an external (customer) actor."
        }
      ]
    },
    {
      "file": "auth/console_auth.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Console-specific authentication handling",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "TokenAudience",
          "purpose": "Explicit token audiences - NO SHARED TOKENS.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerRole",
          "purpose": "Customer Console roles.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderRole",
          "purpose": "Founder Ops Console roles.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CustomerToken",
          "purpose": "Customer Console Token Claims.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "FounderToken",
          "purpose": "Founder Ops Console Token Claims.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "AuthRejectReason",
          "purpose": "Explicit rejection reasons for audit logging.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AuthAuditEvent",
          "purpose": "Audit log schema (from spec 2.4.1).",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "function",
          "name": "log_auth_rejection",
          "purpose": "Log auth rejection event. MANDATORY for every rejection."
        },
        {
          "type": "function",
          "name": "create_console_token",
          "purpose": "Create a Customer Console token."
        },
        {
          "type": "function",
          "name": "create_fops_token",
          "purpose": "Create a Founder Ops Console token."
        },
        {
          "type": "function",
          "name": "decode_token",
          "purpose": "Decode and verify a token."
        },
        {
          "type": "function",
          "name": "get_cookie_settings",
          "purpose": "Get cookie settings for a domain."
        },
        {
          "type": "class",
          "name": "AuthDomainError",
          "purpose": "Auth domain mismatch error with proper body.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "verify_console_token",
          "purpose": "Customer Console middleware."
        },
        {
          "type": "async_function",
          "name": "verify_fops_token",
          "purpose": "Founder Ops Console middleware."
        }
      ]
    },
    {
      "file": "auth/identity_chain.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Unified identity extraction via adapter chain",
      "temporal": {
        "trigger": "api",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "IdentityChain",
          "purpose": "Chain of identity adapters tried in order.",
          "methods": [
            "extract_actor",
            "extract_actor_or_raise",
            "get_adapter_names"
          ]
        },
        {
          "type": "function",
          "name": "create_identity_chain",
          "purpose": "Create identity chain based on environment."
        },
        {
          "type": "function",
          "name": "get_identity_chain",
          "purpose": "Get the singleton identity chain."
        },
        {
          "type": "function",
          "name": "reset_identity_chain",
          "purpose": "Reset the singleton (for testing)."
        },
        {
          "type": "async_function",
          "name": "get_current_actor",
          "purpose": "FastAPI dependency for getting the current actor."
        },
        {
          "type": "async_function",
          "name": "get_current_actor_optional",
          "purpose": "FastAPI dependency for optional authentication."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/resource"
        },
        {
          "method": "GET",
          "path": "/public"
        }
      ],
      "calls": {
        "L3": [
          "app.auth.actor",
          "app.auth.authorization",
          "app.auth.identity_adapter"
        ]
      }
    },
    {
      "file": "auth/jwt_auth.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "JWT token validation and parsing",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "JWTConfig",
          "purpose": "Configuration for JWT authentication.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TokenPayload",
          "purpose": "Parsed and validated JWT payload.",
          "methods": [
            "is_admin",
            "can_write_traces",
            "can_read_traces"
          ]
        },
        {
          "type": "class",
          "name": "JWKSCache",
          "purpose": "Cached JWKS client with automatic refresh.",
          "methods": [
            "get_client",
            "get_signing_key"
          ]
        },
        {
          "type": "class",
          "name": "JWTAuthDependency",
          "purpose": "FastAPI dependency for JWT authentication.",
          "methods": [
            "jwks_cache"
          ]
        },
        {
          "type": "function",
          "name": "get_jwt_auth",
          "purpose": "Get or create global JWT auth dependency."
        },
        {
          "type": "async_function",
          "name": "verify_token",
          "purpose": "Standalone token verification function."
        },
        {
          "type": "function",
          "name": "create_dev_token",
          "purpose": "Create a development token for testing."
        },
        {
          "type": "class",
          "name": "MockRequest",
          "purpose": null,
          "methods": []
        }
      ]
    },
    {
      "file": "auth/rbac_integration.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Bridge RBACv1 \u2192 RBACv2 for shadow comparison",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "DecisionComparison",
          "purpose": "Comparison between RBACv1 and RBACv2 authorization decisions.",
          "methods": [
            "to_dict",
            "old_allowed",
            "new_allowed",
            "old_reason",
            "new_reason"
          ]
        },
        {
          "type": "async_function",
          "name": "extract_actor_from_request",
          "purpose": "Extract ActorContext from request using new IdentityChain."
        },
        {
          "type": "function",
          "name": "build_fallback_actor_from_v1_roles",
          "purpose": "Build ActorContext from RBACv1 roles (fallback for comparison)."
        },
        {
          "type": "function",
          "name": "authorize_with_v2_engine",
          "purpose": "Authorize using RBACv2 AuthorizationEngine (Reference Mode)."
        },
        {
          "type": "function",
          "name": "compare_decisions",
          "purpose": "Compare RBACv1 and RBACv2 authorization decisions."
        },
        {
          "type": "function",
          "name": "map_policy_to_permission",
          "purpose": "Map PolicyObject to permission string."
        },
        {
          "type": "function",
          "name": "map_old_roles_to_new_roles",
          "purpose": "Map old RBAC matrix roles to new role names."
        },
        {
          "type": "async_function",
          "name": "parallel_authorize",
          "purpose": "Run RBACv1 and RBACv2 authorization in parallel (Reference Mode)."
        },
        {
          "type": "function",
          "name": "log_decision_comparison",
          "purpose": "Log RBACv1 \u2194 RBACv2 decision comparison for shadow audit."
        }
      ],
      "calls": {
        "L3": [
          "app.auth.actor",
          "app.auth.authorization",
          "app.auth.authorization",
          "app.auth.identity_chain",
          "app.auth.rbac_middleware",
          "app.auth.rbac_middleware",
          "app.auth.rbac_middleware"
        ]
      }
    },
    {
      "file": "auth/rbac_middleware.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "FastAPI RBAC middleware for request auth",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PolicyObject",
          "purpose": "Represents an authorization policy for a resource action.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Decision",
          "purpose": "Result of an authorization decision.",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_policy_for_path",
          "purpose": "Map request path and method to a PolicyObject."
        },
        {
          "type": "function",
          "name": "extract_roles_from_request",
          "purpose": "Extract roles from request headers."
        },
        {
          "type": "function",
          "name": "enforce",
          "purpose": "Evaluate a policy against the request."
        },
        {
          "type": "class",
          "name": "RBACMiddleware",
          "purpose": "Starlette middleware for RBAC enforcement.",
          "methods": [
            "dispatch"
          ]
        },
        {
          "type": "function",
          "name": "check_permission",
          "purpose": "Programmatic permission check (for use in route handlers)."
        },
        {
          "type": "function",
          "name": "require_permission",
          "purpose": "Decorator for requiring specific permissions."
        }
      ]
    },
    {
      "file": "auth/tenant_auth.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Tenant authentication and isolation",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "TenantContext",
          "purpose": "Context object passed through request lifecycle.",
          "methods": [
            "has_permission",
            "can_use_worker",
            "tier",
            "has_feature",
            "to_dict"
          ]
        },
        {
          "type": "function",
          "name": "get_db_session",
          "purpose": "Get database session - to be configured in main.py."
        },
        {
          "type": "function",
          "name": "hash_api_key",
          "purpose": "Hash an API key for database lookup."
        },
        {
          "type": "async_function",
          "name": "validate_api_key_db",
          "purpose": "Validate API key against database."
        },
        {
          "type": "async_function",
          "name": "get_tenant_context",
          "purpose": "FastAPI dependency that validates API key and returns tenant context."
        },
        {
          "type": "async_function",
          "name": "require_permission",
          "purpose": "Factory for permission-checking dependency."
        },
        {
          "type": "async_function",
          "name": "require_worker_access",
          "purpose": "Factory for worker access checking dependency."
        },
        {
          "type": "async_function",
          "name": "verify_api_key_with_fallback",
          "purpose": "API key verification with fallback to legacy env-based auth."
        },
        {
          "type": "function",
          "name": "is_operator_user",
          "purpose": "Check if user email belongs to an operator (internal staff)."
        },
        {
          "type": "class",
          "name": "ConsoleRole",
          "purpose": "Role identifier for console access control.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "require_customer_role",
          "purpose": "Dependency that enforces customer-only access (Guard Console)."
        },
        {
          "type": "async_function",
          "name": "require_operator_role",
          "purpose": "Dependency that enforces operator-only access (Operator Console)."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/runs"
        },
        {
          "method": "POST",
          "path": "/workers/{worker_id}/run"
        }
      ]
    },
    {
      "file": "config/__init__.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Configuration package marker",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "get_environment",
          "purpose": "Get current environment from ENV var or default to development."
        },
        {
          "type": "function",
          "name": "get_feature_flag",
          "purpose": "Get full feature flag configuration."
        },
        {
          "type": "function",
          "name": "is_flag_enabled",
          "purpose": "Check if a feature flag is enabled."
        },
        {
          "type": "function",
          "name": "requires_m4_signoff",
          "purpose": "Check if a flag requires M4 signoff before enabling."
        },
        {
          "type": "function",
          "name": "reload_flags",
          "purpose": "Force reload of feature flags from disk."
        }
      ]
    },
    {
      "file": "config/flag_sync.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Feature flag synchronization",
      "temporal": {
        "trigger": "scheduler",
        "execution": "async"
      },
      "components": [
        {
          "type": "function",
          "name": "get_db_session",
          "purpose": "Get database session."
        },
        {
          "type": "function",
          "name": "read_file_flags",
          "purpose": "Read flags from JSON file."
        },
        {
          "type": "function",
          "name": "write_file_flags",
          "purpose": "Write flags to JSON file atomically."
        },
        {
          "type": "function",
          "name": "acquire_advisory_lock",
          "purpose": "Acquire PostgreSQL advisory lock."
        },
        {
          "type": "function",
          "name": "release_advisory_lock",
          "purpose": "Release PostgreSQL advisory lock."
        },
        {
          "type": "function",
          "name": "sync_file_to_db",
          "purpose": "Sync flags from file to database."
        },
        {
          "type": "function",
          "name": "sync_db_to_file",
          "purpose": "Sync flags from database to file."
        },
        {
          "type": "function",
          "name": "check_consistency",
          "purpose": "Check consistency between file and DB flags."
        },
        {
          "type": "function",
          "name": "main",
          "purpose": "CLI entry point."
        }
      ],
      "calls": {
        "L6": [
          "app.db",
          "app.db",
          "app.db",
          "app.db"
        ]
      }
    },
    {
      "file": "config/secrets.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Secret loading and configuration",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SecretMissingError",
          "purpose": "Raised when a required secret is not configured.",
          "methods": []
        },
        {
          "type": "class",
          "name": "SecretValidationError",
          "purpose": "Raised when secrets validation fails at startup.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Secrets",
          "purpose": "Centralized secret accessor.",
          "methods": [
            "database_url",
            "redis_url",
            "aos_api_key",
            "openai_api_key",
            "has_openai",
            "anthropic_api_key",
            "has_anthropic",
            "voyage_api_key",
            "has_voyage",
            "vault_token"
          ]
        },
        {
          "type": "function",
          "name": "validate_required_secrets",
          "purpose": "Validate that all required secrets are present."
        },
        {
          "type": "function",
          "name": "get_secret_status",
          "purpose": "Get status of all known secrets for diagnostics."
        }
      ]
    },
    {
      "file": "db.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Database connection, SQLModel definitions, session management",
      "temporal": {
        "trigger": "any (import-time lazy, runtime on-demand)",
        "execution": "sync (connection pooled)"
      },
      "components": [
        {
          "type": "function",
          "name": "utc_now",
          "purpose": "Return timezone-aware UTC datetime. Use instead of utc_now()."
        },
        {
          "type": "function",
          "name": "get_database_url",
          "purpose": "Get DATABASE_URL, raising RuntimeError only when actually needed."
        },
        {
          "type": "function",
          "name": "get_engine",
          "purpose": "Get or create the sync SQLAlchemy engine (lazy initialization)."
        },
        {
          "type": "function",
          "name": "get_async_database_url",
          "purpose": "Get async database URL for asyncpg."
        },
        {
          "type": "function",
          "name": "get_async_engine",
          "purpose": "Get or create the async SQLAlchemy engine (lazy initialization)."
        },
        {
          "type": "function",
          "name": "get_async_session_factory",
          "purpose": "Get or create the async session factory (lazy initialization)."
        },
        {
          "type": "class",
          "name": "_LazyEngine",
          "purpose": "Lazy proxy for SQLAlchemy engine to avoid import-time initialization.",
          "methods": []
        },
        {
          "type": "async_function",
          "name": "get_async_session",
          "purpose": "Async session context manager for async endpoints."
        },
        {
          "type": "class",
          "name": "Agent",
          "purpose": null,
          "methods": [
            "remaining_budget_cents",
            "budget_usage_percent",
            "is_budget_exceeded",
            "should_alert_budget"
          ]
        },
        {
          "type": "class",
          "name": "Memory",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Run",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "Provenance",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "FeatureFlag",
          "purpose": "DB-backed feature flags for multi-node deployments.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "PolicyApprovalLevel",
          "purpose": "Defines approval hierarchy for policy decisions.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "ApprovalRequest",
          "purpose": "Persistent storage for policy approval requests.",
          "methods": [
            "get_payload",
            "set_payload",
            "get_approvals",
            "add_approval",
            "get_status_history",
            "transition_status",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CostSimCBState",
          "purpose": "DB-backed circuit breaker state for CostSim V2.",
          "methods": [
            "is_expired",
            "should_auto_recover",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CostSimCBIncident",
          "purpose": "Incident records for circuit breaker trips.",
          "methods": [
            "get_details",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "StatusHistory",
          "purpose": "Immutable append-only status history for audit trail.",
          "methods": [
            "get_metadata",
            "to_dict",
            "to_csv_row",
            "csv_headers"
          ]
        },
        {
          "type": "class",
          "name": "FailureMatch",
          "purpose": "Persistent storage for failure catalog matches.",
          "methods": [
            "get_context",
            "set_context",
            "mark_recovery_attempted",
            "mark_recovery_succeeded",
            "mark_recovery_failed",
            "to_dict"
          ]
        },
        {
          "type": "function",
          "name": "init_db",
          "purpose": null
        },
        {
          "type": "function",
          "name": "get_session",
          "purpose": null
        },
        {
          "type": "function",
          "name": "log_status_change",
          "purpose": "Log a status change to the immutable history."
        },
        {
          "type": "class",
          "name": "FeatureTag",
          "purpose": "Registered feature namespaces for cost attribution.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostRecord",
          "purpose": "High-volume raw cost metering (append-only).",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostAnomaly",
          "purpose": "Detected cost anomalies.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostBreachHistory",
          "purpose": "M29: Track breach history for consecutive interval logic.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostDriftTracking",
          "purpose": "M29: Track sustained drift for early-warning detection.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostBudget",
          "purpose": "Per-tenant and per-feature budget limits.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostDailyAggregate",
          "purpose": "Pre-aggregated daily costs for fast dashboard reads.",
          "methods": []
        }
      ]
    },
    {
      "file": "db_async.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Async SQLAlchemy session factory for non-blocking DB operations",
      "temporal": {
        "trigger": "any (async contexts)",
        "execution": "async"
      },
      "components": [
        {
          "type": "function",
          "name": "get_async_database_url",
          "purpose": "Get async database URL from environment."
        },
        {
          "type": "async_function",
          "name": "get_async_session",
          "purpose": "Dependency injection helper for FastAPI."
        },
        {
          "type": "async_function",
          "name": "async_session_context",
          "purpose": "Context manager for async session."
        },
        {
          "type": "async_function",
          "name": "init_async_db",
          "purpose": "Initialize async database connection."
        },
        {
          "type": "async_function",
          "name": "close_async_db",
          "purpose": "Close async database connections."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/items"
        }
      ]
    },
    {
      "file": "db_helpers.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "SQLModel query helpers to prevent Row tuple extraction bugs",
      "temporal": {
        "trigger": "any",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "query_one",
          "purpose": "Execute query and return single model instance or None."
        },
        {
          "type": "function",
          "name": "query_all",
          "purpose": "Execute query and return list of model instances."
        },
        {
          "type": "function",
          "name": "query_scalar",
          "purpose": "Execute query and return scalar value (for COUNT, SUM, etc)."
        },
        {
          "type": "function",
          "name": "query_exists",
          "purpose": "Check if any rows match the query."
        }
      ]
    },
    {
      "file": "infra/correlation.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Correlation ID generation and context propagation",
      "temporal": {
        "trigger": "any (api|worker|scheduler|external)",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "generate_correlation_id",
          "purpose": "Generate a unique correlation ID."
        },
        {
          "type": "function",
          "name": "get_current_correlation_id",
          "purpose": "Get the current correlation ID from context."
        },
        {
          "type": "function",
          "name": "get_current_span_id",
          "purpose": "Get the current span ID from context."
        },
        {
          "type": "class",
          "name": "CorrelationContext",
          "purpose": "Immutable correlation context for request tracing.",
          "methods": [
            "child",
            "create"
          ]
        },
        {
          "type": "function",
          "name": "correlation_scope",
          "purpose": "Context manager for establishing a correlation scope."
        },
        {
          "type": "function",
          "name": "child_span",
          "purpose": "Create a child span within the current correlation scope."
        },
        {
          "type": "function",
          "name": "with_correlation",
          "purpose": "Get or create a correlation context."
        },
        {
          "type": "function",
          "name": "inject_correlation",
          "purpose": "Inject a correlation ID into the current context."
        },
        {
          "type": "function",
          "name": "clear_correlation",
          "purpose": "Clear the current correlation context."
        }
      ]
    },
    {
      "file": "infra/danger_fences.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Danger Fences - Encapsulated patterns for known-dangerous operations",
      "temporal": {
        "trigger": "any",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "RecoveryEnqueueError",
          "purpose": "Exception raised when recovery candidate enqueue fails due to race condition.",
          "methods": []
        },
        {
          "type": "function",
          "name": "enqueue_recovery_candidate_safely",
          "purpose": "DANGER FENCE: Safely enqueue a recovery candidate with dual-constraint handling."
        },
        {
          "type": "function",
          "name": "get_danger_fence_documentation",
          "purpose": "Get documentation for all registered danger fences."
        }
      ]
    },
    {
      "file": "infra/error_envelope.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Unified error envelope for forensic diagnostics",
      "temporal": {
        "trigger": "any (api|worker|scheduler|external)",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ErrorSeverity",
          "purpose": "Error severity levels.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ErrorClass",
          "purpose": "Error classification taxonomy.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ErrorEnvelope",
          "purpose": "Unified Error Envelope for Phase-S forensic diagnostics.",
          "methods": [
            "create",
            "to_dict",
            "from_dict",
            "with_context",
            "is_critical",
            "is_infrastructure_error",
            "is_domain_error",
            "is_system_error"
          ]
        }
      ]
    },
    {
      "file": "infra/error_store.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Append-only error persistence for forensic diagnostics",
      "temporal": {
        "trigger": "any (api|worker|scheduler)",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "persist_error",
          "purpose": "Persist an error envelope to the store."
        },
        {
          "type": "function",
          "name": "persist_errors_batch",
          "purpose": "Persist multiple error envelopes in a batch."
        },
        {
          "type": "function",
          "name": "get_errors_by_correlation",
          "purpose": "Get all errors for a correlation ID (request/workflow trace)."
        },
        {
          "type": "function",
          "name": "get_errors_by_component",
          "purpose": "Get recent errors for a component."
        },
        {
          "type": "function",
          "name": "get_errors_by_class",
          "purpose": "Get recent errors by classification."
        },
        {
          "type": "function",
          "name": "get_error_counts_by_class",
          "purpose": "Get error counts grouped by class."
        },
        {
          "type": "function",
          "name": "get_error_counts_by_component",
          "purpose": "Get error counts grouped by component."
        },
        {
          "type": "function",
          "name": "get_error_timeline",
          "purpose": "Get error counts over time in buckets."
        },
        {
          "type": "function",
          "name": "cleanup_old_errors",
          "purpose": "Delete errors older than retention period."
        }
      ],
      "calls": {
        "L6": [
          "app.infra.error_envelope"
        ]
      }
    },
    {
      "file": "infra/feature_intent.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Feature-level intent declarations for self-defending architecture",
      "temporal": {
        "trigger": "any",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "FeatureIntent",
          "purpose": "Declared intent for a feature module.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RetryPolicy",
          "purpose": "Declared retry safety for a feature module.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IntentConsistencyError",
          "purpose": "Raised when feature intent doesn't match function intent.",
          "methods": []
        },
        {
          "type": "class",
          "name": "RetryPolicyError",
          "purpose": "Raised when retry policy is inconsistent with feature intent.",
          "methods": []
        },
        {
          "type": "function",
          "name": "validate_intent_consistency",
          "purpose": "Validate that transaction intent is allowed for the feature intent."
        },
        {
          "type": "function",
          "name": "validate_retry_policy",
          "purpose": "Validate that retry policy is consistent with feature intent."
        },
        {
          "type": "class",
          "name": "FeatureDeclaration",
          "purpose": "Registration of a feature module's intent declarations.",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_feature_registry",
          "purpose": "Return the feature registry for CI validation."
        },
        {
          "type": "function",
          "name": "register_feature",
          "purpose": "Register a feature module's intent declarations."
        },
        {
          "type": "function",
          "name": "feature",
          "purpose": "Decorator for feature functions that validates intent consistency."
        },
        {
          "type": "function",
          "name": "validate_module_intent",
          "purpose": "Validate that a module has required intent declarations."
        }
      ]
    },
    {
      "file": "infra/feature_intent_examples.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Golden examples for feature intent patterns",
      "temporal": {
        "trigger": "any",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PureQueryExample",
          "purpose": "Example of a PURE_QUERY feature.",
          "methods": [
            "get_entity"
          ]
        },
        {
          "type": "class",
          "name": "AtomicWriteExample",
          "purpose": "Example of a STATE_MUTATION feature using ATOMIC_WRITE.",
          "methods": [
            "create_record"
          ]
        },
        {
          "type": "class",
          "name": "LockedMutationExample",
          "purpose": "Example of a STATE_MUTATION feature using LOCKED_MUTATION.",
          "methods": [
            "update_counter"
          ]
        },
        {
          "type": "class",
          "name": "ExternalSideEffectExample",
          "purpose": "Example of an EXTERNAL_SIDE_EFFECT feature.",
          "methods": [
            "send_webhook"
          ]
        },
        {
          "type": "class",
          "name": "RecoverableOperationExample",
          "purpose": "Example of a RECOVERABLE_OPERATION feature.",
          "methods": [
            "process_job"
          ]
        }
      ],
      "calls": {
        "L6": [
          "app.infra.feature_intent",
          "app.infra.transaction"
        ]
      }
    },
    {
      "file": "infra/transaction.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Single-connection transaction primitives for lock-safe operations",
      "temporal": {
        "trigger": "api | worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "TransactionIntent",
          "purpose": "Declared intent for database operations.",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_intent_registry",
          "purpose": "Return the intent registry for CI validation."
        },
        {
          "type": "function",
          "name": "transactional",
          "purpose": "Decorator declaring transactional intent for a function."
        },
        {
          "type": "class",
          "name": "IntentViolationError",
          "purpose": "Raised when transactional intent doesn't match implementation.",
          "methods": []
        },
        {
          "type": "function",
          "name": "require_intent",
          "purpose": "Validate that calling context has the required intent."
        },
        {
          "type": "class",
          "name": "SingleConnectionTxn",
          "purpose": "Transaction context guaranteeing single-connection semantics.",
          "methods": [
            "lock_row",
            "lock_rows",
            "add",
            "refresh",
            "commit",
            "rollback"
          ]
        },
        {
          "type": "function",
          "name": "single_connection_transaction",
          "purpose": "Context manager for single-connection transactions."
        },
        {
          "type": "function",
          "name": "single_connection_transaction_with_engine",
          "purpose": "Context manager using an existing engine."
        },
        {
          "type": "function",
          "name": "get_or_create_locked",
          "purpose": "Get existing row with lock, or create new one."
        }
      ],
      "calls": {
        "L6": [
          "app.db"
        ]
      }
    },
    {
      "file": "infra/transaction_examples.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Golden examples for self-defending transaction patterns",
      "temporal": {
        "trigger": "any",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "get_entity_by_id",
          "purpose": "Read-only query with no locking."
        },
        {
          "type": "function",
          "name": "create_entity",
          "purpose": "Atomic write without row locking."
        },
        {
          "type": "function",
          "name": "trip_circuit_breaker",
          "purpose": "Trip a circuit breaker with row locking."
        },
        {
          "type": "function",
          "name": "reset_circuit_breaker",
          "purpose": "Reset a circuit breaker to enabled state."
        },
        {
          "type": "function",
          "name": "example_caller_pattern",
          "purpose": "This shows how to CALL functions with LOCKED_MUTATION intent."
        }
      ],
      "calls": {
        "L6": [
          "app.infra.transaction",
          "app.db",
          "app.db"
        ]
      }
    },
    {
      "file": "learning/tables.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Learning system database tables",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "validate_table_access",
          "purpose": "Validate that learning can access a table."
        },
        {
          "type": "class",
          "name": "LearningBoundaryViolation",
          "purpose": "Raised when learning attempts to access forbidden resources.",
          "methods": []
        }
      ]
    },
    {
      "file": "logging_config.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Structured JSON logging configuration",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "JSONFormatter",
          "purpose": "Custom JSON formatter for structured logging.",
          "methods": [
            "format"
          ]
        },
        {
          "type": "function",
          "name": "setup_logging",
          "purpose": "Configure structured JSON logging."
        },
        {
          "type": "function",
          "name": "log_request",
          "purpose": "Log a request with structured data."
        },
        {
          "type": "function",
          "name": "log_provenance",
          "purpose": "Log provenance record."
        }
      ]
    },
    {
      "file": "metrics.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Prometheus metrics definitions and multiprocess support",
      "temporal": {
        "trigger": "import-time, runtime increment",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "get_registry",
          "purpose": "Get the appropriate registry for the current mode."
        },
        {
          "type": "function",
          "name": "generate_metrics",
          "purpose": "Generate metrics output for /metrics endpoint."
        },
        {
          "type": "function",
          "name": "get_content_type",
          "purpose": "Get the content type for metrics response."
        }
      ]
    },
    {
      "file": "middleware/rate_limit.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Rate limiting middleware",
      "temporal": {
        "trigger": "api (every request)",
        "execution": "sync"
      },
      "components": [
        {
          "type": "async_function",
          "name": "get_redis",
          "purpose": "Get Redis connection pool (lazy initialization)."
        },
        {
          "type": "function",
          "name": "get_tier_limits",
          "purpose": "Get rate limit configuration for a tier."
        },
        {
          "type": "function",
          "name": "extract_tier_from_user",
          "purpose": "Extract rate limit tier from user object."
        },
        {
          "type": "async_function",
          "name": "check_rate_limit",
          "purpose": "Check and increment rate limit counter."
        },
        {
          "type": "async_function",
          "name": "rate_limit_dependency",
          "purpose": "FastAPI dependency for rate limiting."
        },
        {
          "type": "class",
          "name": "RateLimitMiddleware",
          "purpose": "ASGI middleware alternative for rate limiting.",
          "methods": []
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/simulate"
        }
      ],
      "calls": {
        "L6": [
          "app.utils.metrics_helpers"
        ]
      }
    },
    {
      "file": "middleware/tenancy.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Tenant context injection middleware",
      "temporal": {
        "trigger": "api (every request)",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "TenancyMiddleware",
          "purpose": "Middleware to enforce multi-tenancy on all requests.",
          "methods": [
            "dispatch"
          ]
        },
        {
          "type": "function",
          "name": "get_tenant_id",
          "purpose": "Get tenant_id from request state."
        }
      ]
    },
    {
      "file": "middleware/tenant.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Tenant isolation enforcement middleware",
      "temporal": {
        "trigger": "api (every request)",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "TenantContext",
          "purpose": "Tenant context for the current request.",
          "methods": [
            "has_permission",
            "to_dict"
          ]
        },
        {
          "type": "function",
          "name": "get_tenant_context",
          "purpose": "Get the current tenant context."
        },
        {
          "type": "function",
          "name": "set_tenant_context",
          "purpose": "Set the current tenant context."
        },
        {
          "type": "function",
          "name": "clear_tenant_context",
          "purpose": "Clear the current tenant context."
        },
        {
          "type": "function",
          "name": "require_tenant_context",
          "purpose": "Get the current tenant context, raising if not set."
        },
        {
          "type": "function",
          "name": "get_tenant_id",
          "purpose": "Get the current tenant ID, or None if not in tenant context."
        },
        {
          "type": "class",
          "name": "TenantMiddleware",
          "purpose": "Middleware for tenant context propagation.",
          "methods": [
            "dispatch"
          ]
        },
        {
          "type": "function",
          "name": "tenant_scoped_query",
          "purpose": "Add tenant scope to a SQLModel query."
        },
        {
          "type": "function",
          "name": "ensure_tenant_access",
          "purpose": "Ensure the current tenant can access an entity."
        },
        {
          "type": "function",
          "name": "require_tenant",
          "purpose": "Decorator to require tenant context for an endpoint."
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/runs"
        }
      ]
    },
    {
      "file": "models/costsim_cb.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "CostSim circuit breaker models",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "CostSimCBStateModel",
          "purpose": "Circuit breaker state for CostSim V2.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CostSimCBIncidentModel",
          "purpose": "Incident records for circuit breaker trips.",
          "methods": [
            "get_details",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CostSimProvenanceModel",
          "purpose": "Provenance records for CostSim simulations.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CostSimCanaryReportModel",
          "purpose": "Canary run reports for CostSim V2 validation.",
          "methods": [
            "get_failure_reasons",
            "get_artifact_paths",
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "CostSimAlertQueueModel",
          "purpose": "Alert queue for reliable alert delivery.",
          "methods": [
            "to_dict"
          ]
        }
      ]
    },
    {
      "file": "models/external_response.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "External response data models (DB tables)",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ExternalResponse",
          "purpose": "External response record - raw data with interpretation ownership.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExternalResponseCreate",
          "purpose": "Input model for recording external responses (L3 \u2192 L6 write).",
          "methods": []
        },
        {
          "type": "class",
          "name": "InterpretationUpdate",
          "purpose": "Input model for L4 engine interpretation (L4 \u2192 L6 write).",
          "methods": []
        },
        {
          "type": "class",
          "name": "ExternalResponseRead",
          "purpose": "Output model for external responses.",
          "methods": []
        },
        {
          "type": "class",
          "name": "InterpretedResponse",
          "purpose": "Output model for consumers (L5/L2) - only the interpreted value.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        }
      ],
      "calls": {
        "L6": [
          "app.models.costsim_cb"
        ]
      }
    },
    {
      "file": "models/feedback.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Feedback data models",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PatternFeedback",
          "purpose": "Pattern feedback record - observation without action.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PatternFeedbackCreate",
          "purpose": "Input model for creating pattern feedback.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PatternFeedbackResponse",
          "purpose": "Output model for pattern feedback.",
          "methods": []
        }
      ]
    },
    {
      "file": "models/governance.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Governance signal data models (DB tables)",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "GovernanceSignal",
          "purpose": "Governance signal record - explicit persistence of L7 decisions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GovernanceSignalCreate",
          "purpose": "Input model for creating governance signals.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GovernanceSignalResponse",
          "purpose": "Output model for governance signals.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GovernanceSignalQuery",
          "purpose": "Query model for checking governance status.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GovernanceCheckResult",
          "purpose": "Result of checking governance status for a scope.",
          "methods": []
        },
        {
          "type": "class",
          "name": "Config",
          "purpose": null,
          "methods": []
        }
      ],
      "calls": {
        "L6": [
          "app.models.costsim_cb"
        ]
      }
    },
    {
      "file": "models/killswitch.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Killswitch data models",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "utc_now",
          "purpose": null
        },
        {
          "type": "function",
          "name": "generate_uuid",
          "purpose": null
        },
        {
          "type": "class",
          "name": "EntityType",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "TriggerType",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentSeverity",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentStatus",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "GuardrailAction",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "GuardrailCategory",
          "purpose": null,
          "methods": []
        },
        {
          "type": "class",
          "name": "KillSwitchState",
          "purpose": "Track freeze state for tenants and API keys.",
          "methods": [
            "freeze",
            "unfreeze"
          ]
        },
        {
          "type": "class",
          "name": "ProxyCall",
          "purpose": "Log of OpenAI proxy calls for replay and analysis.",
          "methods": [
            "hash_request",
            "hash_response",
            "set_policy_decisions",
            "get_policy_decisions"
          ]
        },
        {
          "type": "class",
          "name": "Incident",
          "purpose": "Auto-grouped failure incidents.",
          "methods": [
            "add_related_call",
            "get_related_call_ids",
            "resolve"
          ]
        },
        {
          "type": "class",
          "name": "IncidentEvent",
          "purpose": "Timeline events within an incident.",
          "methods": [
            "set_data",
            "get_data"
          ]
        },
        {
          "type": "class",
          "name": "DefaultGuardrail",
          "purpose": "Read-only default policy pack.",
          "methods": [
            "get_rule_config",
            "evaluate"
          ]
        },
        {
          "type": "class",
          "name": "KillSwitchStatus",
          "purpose": "Response schema for kill switch status.",
          "methods": []
        },
        {
          "type": "class",
          "name": "KillSwitchAction",
          "purpose": "Request schema for kill switch actions.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentSummary",
          "purpose": "Summary view of an incident.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IncidentDetail",
          "purpose": "Detailed view of an incident with timeline.",
          "methods": []
        },
        {
          "type": "class",
          "name": "GuardrailSummary",
          "purpose": "Summary of active guardrails.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ProxyCallSummary",
          "purpose": "Summary of a proxy call.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ProxyCallDetail",
          "purpose": "Detailed view of a proxy call for replay.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayRequest",
          "purpose": "Request to replay a call.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayResult",
          "purpose": "Result of a replay operation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DemoSimulationRequest",
          "purpose": "Request to simulate an incident.",
          "methods": []
        },
        {
          "type": "class",
          "name": "DemoSimulationResult",
          "purpose": "Result of a demo simulation.",
          "methods": []
        }
      ]
    },
    {
      "file": "models/m10_recovery.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "M10 recovery data models",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SuggestionInput",
          "purpose": "Structured inputs that contributed to a recovery suggestion.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "SuggestionAction",
          "purpose": "Catalog of available recovery actions with templates.",
          "methods": [
            "to_dict",
            "matches_error",
            "matches_skill"
          ]
        },
        {
          "type": "class",
          "name": "SuggestionProvenance",
          "purpose": "Complete lineage of how a recovery suggestion was generated and processed.",
          "methods": [
            "to_dict"
          ]
        }
      ]
    },
    {
      "file": "models/policy.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Policy data models (DB tables)",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PolicyProposal",
          "purpose": "Policy proposal record - recommendation without enforcement.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyVersion",
          "purpose": "Policy version record - append-only history.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyProposalCreate",
          "purpose": "Input model for creating policy proposals.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyProposalResponse",
          "purpose": "Output model for policy proposals.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyApprovalRequest",
          "purpose": "Input model for approving/rejecting a policy proposal.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PolicyVersionResponse",
          "purpose": "Output model for policy versions.",
          "methods": []
        }
      ]
    },
    {
      "file": "models/prediction.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Prediction data models",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PredictionEvent",
          "purpose": "Prediction event record - advisory only, zero side-effects.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PredictionEventCreate",
          "purpose": "Input model for creating prediction events.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PredictionEventResponse",
          "purpose": "Output model for prediction events.",
          "methods": []
        }
      ]
    },
    {
      "file": "models/tenant.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Tenant data models",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "utc_now",
          "purpose": "Return current UTC time as a naive datetime (no timezone info)."
        },
        {
          "type": "function",
          "name": "generate_uuid",
          "purpose": null
        },
        {
          "type": "class",
          "name": "Tenant",
          "purpose": "Organization/Tenant model for multi-tenancy.",
          "methods": [
            "can_create_run",
            "can_use_tokens",
            "increment_usage",
            "tier",
            "tier_marketing_name",
            "retention_days",
            "has_feature",
            "get_available_features"
          ]
        },
        {
          "type": "class",
          "name": "User",
          "purpose": "User account - supports OAuth (Google/Azure) and email signup.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TenantMembership",
          "purpose": "User membership in a tenant with role.",
          "methods": [
            "can_manage_keys",
            "can_run_workers",
            "can_view_runs"
          ]
        },
        {
          "type": "class",
          "name": "APIKey",
          "purpose": "API key for programmatic access.",
          "methods": [
            "generate_key",
            "hash_key",
            "is_valid",
            "record_usage"
          ]
        },
        {
          "type": "class",
          "name": "Subscription",
          "purpose": "Billing subscription for a tenant.",
          "methods": []
        },
        {
          "type": "class",
          "name": "UsageRecord",
          "purpose": "Usage metering for billing.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerRegistry",
          "purpose": "Registry of available workers.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerConfig",
          "purpose": "Per-tenant worker configuration.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerRun",
          "purpose": "Worker execution run with tenant isolation.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AuditLog",
          "purpose": "Comprehensive audit log for compliance.",
          "methods": []
        },
        {
          "type": "class",
          "name": "FounderAction",
          "purpose": "Immutable record of founder actions on tenants/keys/incidents.",
          "methods": [
            "is_reversal"
          ]
        }
      ]
    },
    {
      "file": "observability/cost_tracker.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Cost tracking and metrics",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "CostEnforcementResult",
          "purpose": "Result of cost enforcement check.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostQuota",
          "purpose": "Cost quota configuration.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostRecord",
          "purpose": "Individual cost record.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostAlert",
          "purpose": "Cost alert notification.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CostTracker",
          "purpose": "Tracks LLM costs and enforces quotas.",
          "methods": [
            "record_cost",
            "get_spend",
            "get_remaining_budget",
            "is_budget_exceeded",
            "get_alerts",
            "get_cost_summary",
            "cleanup_old_records",
            "check_can_spend",
            "get_workflow_spend",
            "set_workflow_budget"
          ]
        },
        {
          "type": "function",
          "name": "get_cost_tracker",
          "purpose": "Get global cost tracker instance."
        },
        {
          "type": "function",
          "name": "configure_cost_quota",
          "purpose": "Configure global cost quota."
        }
      ]
    },
    {
      "file": "optimization/audit_persistence.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Optimization audit trail persistence",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "CoordinationAuditRecordDB",
          "purpose": "SQLModel for coordination_audit_records table.",
          "methods": []
        },
        {
          "type": "function",
          "name": "persist_audit_record",
          "purpose": "Persist a coordination audit record to the database."
        }
      ],
      "calls": {
        "L6": [
          "app.infra"
        ]
      }
    },
    {
      "file": "secrets/vault_client.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "HashiCorp Vault client for secret retrieval",
      "temporal": {
        "trigger": "any",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "VaultClient",
          "purpose": "Client for HashiCorp Vault KV v2 secrets engine.",
          "methods": [
            "is_available",
            "get_secret",
            "close"
          ]
        },
        {
          "type": "function",
          "name": "load_secrets_to_env",
          "purpose": "Load secrets from Vault and set them as environment variables."
        },
        {
          "type": "function",
          "name": "get_vault_client",
          "purpose": "Get the global Vault client instance."
        }
      ]
    },
    {
      "file": "security/sanitize.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Sanitize text before embedding to prevent secret leakage",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "sanitize_for_embedding",
          "purpose": "Sanitize text before embedding to prevent secret leakage."
        },
        {
          "type": "function",
          "name": "sanitize_error_message",
          "purpose": "Sanitize an error message specifically."
        },
        {
          "type": "function",
          "name": "is_safe_for_embedding",
          "purpose": "Check if text is safe to embed without sanitization."
        }
      ]
    },
    {
      "file": "services/event_emitter.py",
      "layer": "L6",
      "layer_source": "declared",
      "components": [
        {
          "type": "function",
          "name": "utc_now",
          "purpose": null
        },
        {
          "type": "class",
          "name": "EventType",
          "purpose": "Canonical event types (PIN-105 + Phase-2 Friction Events).",
          "methods": []
        },
        {
          "type": "class",
          "name": "EntityType",
          "purpose": "Entity types for classification.",
          "methods": []
        },
        {
          "type": "class",
          "name": "OpsEvent",
          "purpose": "Represents an ops event to be persisted.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EventEmitterError",
          "purpose": "Base exception for event emitter errors.",
          "methods": []
        },
        {
          "type": "class",
          "name": "EventEmitter",
          "purpose": "Service for emitting ops events.",
          "methods": [
            "emit",
            "emit_batch",
            "start_batch",
            "flush_batch",
            "emit_api_call",
            "emit_incident_created",
            "emit_incident_viewed",
            "emit_replay_executed",
            "emit_export_generated",
            "emit_cert_verified"
          ]
        },
        {
          "type": "function",
          "name": "get_event_emitter",
          "purpose": "Get EventEmitter instance for dependency injection."
        }
      ]
    },
    {
      "file": "services/external_response_service.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "External response persistence and interpretation service",
      "temporal": {
        "trigger": "api|worker|scheduler",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ExternalResponseService",
          "purpose": "Service for external response operations.",
          "methods": [
            "record_raw_response",
            "interpret",
            "get_raw_for_interpretation",
            "get_interpreted",
            "get_pending_interpretations"
          ]
        },
        {
          "type": "function",
          "name": "record_external_response",
          "purpose": "Record a raw external response (L3 \u2192 L6)."
        },
        {
          "type": "function",
          "name": "interpret_response",
          "purpose": "Record L4 engine interpretation (L4 \u2192 L6)."
        },
        {
          "type": "function",
          "name": "get_interpreted_response",
          "purpose": "Get interpreted response for consumers (L5/L2 \u2190 L6)."
        }
      ],
      "calls": {
        "L6": [
          "app.models.external_response"
        ]
      }
    },
    {
      "file": "services/governance_signal_service.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Governance signal persistence service",
      "temporal": {
        "trigger": "api|worker|scheduler",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "GovernanceSignalService",
          "purpose": "Service for governance signal operations.",
          "methods": [
            "record_signal",
            "check_governance",
            "is_blocked",
            "get_active_signals",
            "clear_signal"
          ]
        },
        {
          "type": "function",
          "name": "check_governance_status",
          "purpose": "Check governance status for a scope."
        },
        {
          "type": "function",
          "name": "is_governance_blocked",
          "purpose": "Quick check if scope is blocked."
        },
        {
          "type": "function",
          "name": "record_governance_signal",
          "purpose": "Record a governance signal."
        }
      ],
      "calls": {
        "L6": [
          "app.models.governance"
        ]
      }
    },
    {
      "file": "services/tenant_service.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Tenant CRUD, API key management, quota enforcement",
      "components": [
        {
          "type": "function",
          "name": "utc_now",
          "purpose": null
        },
        {
          "type": "class",
          "name": "TenantServiceError",
          "purpose": "Base exception for tenant service errors.",
          "methods": []
        },
        {
          "type": "class",
          "name": "QuotaExceededError",
          "purpose": "Raised when a quota limit is exceeded.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TenantService",
          "purpose": "Service for tenant management.",
          "methods": [
            "create_tenant",
            "get_tenant",
            "get_tenant_by_slug",
            "update_tenant_plan",
            "suspend_tenant",
            "create_membership_with_default",
            "create_api_key",
            "list_api_keys",
            "revoke_api_key",
            "check_run_quota"
          ]
        },
        {
          "type": "function",
          "name": "get_tenant_service",
          "purpose": "Get a TenantService instance."
        }
      ]
    },
    {
      "file": "services/worker_registry_service.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Worker discovery, status queries, capability registry",
      "components": [
        {
          "type": "class",
          "name": "WorkerRegistryError",
          "purpose": "Base exception for worker registry errors.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerNotFoundError",
          "purpose": "Raised when a worker is not found.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerUnavailableError",
          "purpose": "Raised when a worker is not available.",
          "methods": []
        },
        {
          "type": "class",
          "name": "WorkerRegistryService",
          "purpose": "Service for worker registry operations.",
          "methods": [
            "get_worker",
            "get_worker_or_raise",
            "list_workers",
            "list_available_workers",
            "is_worker_available",
            "get_worker_details",
            "get_worker_summary",
            "list_worker_summaries",
            "register_worker",
            "update_worker_status"
          ]
        },
        {
          "type": "function",
          "name": "get_worker_registry_service",
          "purpose": "Get a WorkerRegistryService instance."
        }
      ]
    },
    {
      "file": "storage/artifact.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Artifact storage (R2/S3)",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "StoredArtifact",
          "purpose": "Metadata for a stored artifact.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ArtifactStore",
          "purpose": "Abstract base class for artifact storage backends.",
          "methods": [
            "store",
            "retrieve",
            "get_metadata",
            "list_by_run",
            "delete"
          ]
        },
        {
          "type": "class",
          "name": "LocalArtifactStore",
          "purpose": "Local filesystem artifact storage.",
          "methods": [
            "store",
            "retrieve",
            "get_metadata",
            "list_by_run",
            "delete"
          ]
        },
        {
          "type": "class",
          "name": "S3ArtifactStore",
          "purpose": "S3-compatible artifact storage.",
          "methods": [
            "store",
            "retrieve",
            "get_metadata",
            "list_by_run",
            "delete"
          ]
        },
        {
          "type": "function",
          "name": "get_artifact_store",
          "purpose": "Get the configured artifact store instance."
        }
      ]
    },
    {
      "file": "stores/__init__.py",
      "layer": "L6",
      "layer_source": "inferred",
      "components": [
        {
          "type": "class",
          "name": "StoreConfigurationError",
          "purpose": "Raised when store configuration is invalid in strict mode (ENV=prod).",
          "methods": []
        },
        {
          "type": "class",
          "name": "BudgetStoreProtocol",
          "purpose": "Protocol for budget storage backends.",
          "methods": [
            "get_workflow_cost",
            "add_workflow_cost",
            "reset_workflow_cost"
          ]
        },
        {
          "type": "class",
          "name": "CheckpointStoreProtocol",
          "purpose": "Protocol for checkpoint storage backends.",
          "methods": [
            "init_tables",
            "ping",
            "save",
            "load",
            "delete"
          ]
        },
        {
          "type": "function",
          "name": "get_budget_store",
          "purpose": "Get or create budget store based on environment configuration."
        },
        {
          "type": "async_function",
          "name": "get_budget_store_async",
          "purpose": "Async version of get_budget_store (for consistency with async contexts)."
        },
        {
          "type": "function",
          "name": "get_checkpoint_store",
          "purpose": "Get or create checkpoint store based on environment configuration."
        },
        {
          "type": "async_function",
          "name": "get_checkpoint_store_async",
          "purpose": "Async version of get_checkpoint_store (for consistency with async contexts)."
        },
        {
          "type": "async_function",
          "name": "get_idempotency_store",
          "purpose": "Get or create idempotency store based on environment configuration."
        },
        {
          "type": "function",
          "name": "get_r2_client",
          "purpose": "Get or create Cloudflare R2 client for checkpoint offload."
        },
        {
          "type": "function",
          "name": "get_r2_bucket",
          "purpose": "Get R2 bucket name from environment."
        },
        {
          "type": "function",
          "name": "reset_all_stores",
          "purpose": "Reset all cached store instances. For testing only."
        }
      ],
      "calls": {
        "L4": [
          "app.workflow.policies",
          "app.workflow.checkpoint",
          "app.traces.idempotency",
          "app.workflow.policies",
          "app.workflow.checkpoint"
        ]
      }
    },
    {
      "file": "stores/checkpoint_offload.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Checkpoint offload to object storage",
      "temporal": {
        "trigger": "worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "async_function",
          "name": "offload_old_checkpoints",
          "purpose": "Offload old checkpoints from PostgreSQL to Cloudflare R2."
        },
        {
          "type": "async_function",
          "name": "restore_checkpoint_from_r2",
          "purpose": "Restore a checkpoint from R2 archive."
        },
        {
          "type": "async_function",
          "name": "get_offload_stats",
          "purpose": "Get statistics about checkpoint storage."
        }
      ],
      "calls": {
        "L6": [
          "app.stores",
          "app.stores"
        ]
      }
    },
    {
      "file": "stores/health.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Store health checks",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "HealthStatus",
          "purpose": "Health status for a component.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ComponentHealth",
          "purpose": "Health status for a single component.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "OverallHealth",
          "purpose": "Overall system health.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "async_function",
          "name": "check_database_health",
          "purpose": "Check PostgreSQL database connectivity."
        },
        {
          "type": "async_function",
          "name": "check_redis_health",
          "purpose": "Check Redis connectivity."
        },
        {
          "type": "async_function",
          "name": "check_r2_health",
          "purpose": "Check Cloudflare R2 connectivity."
        },
        {
          "type": "async_function",
          "name": "check_health",
          "purpose": "Check overall system health."
        },
        {
          "type": "async_function",
          "name": "readiness_probe",
          "purpose": "Kubernetes readiness probe."
        },
        {
          "type": "async_function",
          "name": "liveness_probe",
          "purpose": "Kubernetes liveness probe."
        }
      ],
      "calls": {
        "L6": [
          "app.stores"
        ]
      }
    },
    {
      "file": "traces/idempotency.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Trace idempotency enforcement (Redis + Lua scripts)",
      "temporal": {
        "trigger": "api|worker",
        "execution": "async"
      },
      "components": [
        {
          "type": "class",
          "name": "IdempotencyResult",
          "purpose": "Result of idempotency check.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IdempotencyResponse",
          "purpose": "Response from idempotency check.",
          "methods": [
            "is_new",
            "is_duplicate",
            "is_conflict"
          ]
        },
        {
          "type": "function",
          "name": "canonical_json",
          "purpose": "Produce canonical JSON (sorted keys, compact format)."
        },
        {
          "type": "function",
          "name": "hash_request",
          "purpose": "Hash request data for idempotency comparison."
        },
        {
          "type": "class",
          "name": "RedisIdempotencyStore",
          "purpose": "Redis-backed idempotency store with Lua script for atomicity.",
          "methods": [
            "check",
            "mark_completed",
            "mark_failed",
            "delete",
            "get_status"
          ]
        },
        {
          "type": "class",
          "name": "InMemoryIdempotencyStore",
          "purpose": "In-memory idempotency store for testing and development.",
          "methods": [
            "check",
            "mark_completed",
            "mark_failed",
            "delete",
            "get_status"
          ]
        },
        {
          "type": "async_function",
          "name": "get_idempotency_store",
          "purpose": "Get or create idempotency store based on environment."
        }
      ]
    },
    {
      "file": "traces/models.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Trace data models",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "TraceStatus",
          "purpose": "Status of a trace step.",
          "methods": []
        },
        {
          "type": "class",
          "name": "TraceStep",
          "purpose": "A single step in an execution trace.",
          "methods": [
            "to_dict",
            "from_dict",
            "determinism_hash"
          ]
        },
        {
          "type": "class",
          "name": "TraceSummary",
          "purpose": "Summary of a trace for listing purposes.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "class",
          "name": "TraceRecord",
          "purpose": "Complete trace record with all steps.",
          "methods": [
            "total_cost_cents",
            "total_duration_ms",
            "success_count",
            "failure_count",
            "to_dict",
            "from_dict",
            "to_summary",
            "determinism_signature"
          ]
        },
        {
          "type": "class",
          "name": "ParityResult",
          "purpose": "Result of comparing two traces for replay parity.",
          "methods": [
            "to_dict"
          ]
        },
        {
          "type": "function",
          "name": "compare_traces",
          "purpose": "Compare two traces to verify replay parity."
        }
      ]
    },
    {
      "file": "traces/pg_store.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "PostgreSQL trace storage",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PostgresTraceStore",
          "purpose": "PostgreSQL-based trace storage for production.",
          "methods": [
            "close",
            "start_trace",
            "record_step",
            "complete_trace",
            "store_trace",
            "get_trace",
            "get_trace_by_root_hash",
            "search_traces",
            "list_traces",
            "delete_trace"
          ]
        },
        {
          "type": "function",
          "name": "get_postgres_trace_store",
          "purpose": "Get singleton PostgreSQL trace store."
        }
      ]
    },
    {
      "file": "traces/redact.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Trace data redaction for security",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "redact_json_string",
          "purpose": "Apply PII redaction patterns to a JSON string."
        },
        {
          "type": "function",
          "name": "redact_dict",
          "purpose": "Recursively redact sensitive fields in a dictionary."
        },
        {
          "type": "function",
          "name": "redact_list",
          "purpose": "Recursively redact sensitive fields in a list."
        },
        {
          "type": "function",
          "name": "redact_string_value",
          "purpose": "Redact sensitive patterns in a string value."
        },
        {
          "type": "function",
          "name": "redact_trace_data",
          "purpose": "Redact PII from a complete trace object."
        },
        {
          "type": "function",
          "name": "is_sensitive_field",
          "purpose": "Check if a field name indicates sensitive data."
        },
        {
          "type": "function",
          "name": "add_sensitive_field",
          "purpose": "Add a custom field name to the sensitive fields set."
        },
        {
          "type": "function",
          "name": "add_redaction_pattern",
          "purpose": "Add a custom redaction pattern."
        }
      ]
    },
    {
      "file": "traces/replay.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Trace replay execution",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ReplayBehavior",
          "purpose": "Replay behavior options.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayMismatchError",
          "purpose": "Raised when replay output doesn't match original.",
          "methods": []
        },
        {
          "type": "class",
          "name": "IdempotencyViolationError",
          "purpose": "Raised when idempotency key is violated.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ReplayResult",
          "purpose": "Result of a replay operation.",
          "methods": []
        },
        {
          "type": "function",
          "name": "hash_output",
          "purpose": "Compute hash of output data for comparison."
        },
        {
          "type": "class",
          "name": "ReplayEnforcer",
          "purpose": "Server-side replay behavior enforcer.",
          "methods": [
            "enforce_step",
            "enforce_trace"
          ]
        },
        {
          "type": "class",
          "name": "IdempotencyStore",
          "purpose": "Abstract base for idempotency storage.",
          "methods": [
            "get",
            "set",
            "delete"
          ]
        },
        {
          "type": "class",
          "name": "InMemoryIdempotencyStore",
          "purpose": "In-memory idempotency store for testing.",
          "methods": [
            "get",
            "set",
            "delete",
            "clear"
          ]
        },
        {
          "type": "class",
          "name": "RedisIdempotencyStore",
          "purpose": "Redis-based idempotency store for production.",
          "methods": [
            "get",
            "set",
            "delete"
          ]
        },
        {
          "type": "function",
          "name": "get_replay_enforcer",
          "purpose": "Get singleton replay enforcer."
        }
      ]
    },
    {
      "file": "traces/store.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Trace store abstraction",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "TraceStore",
          "purpose": "Abstract base class for trace storage.",
          "methods": [
            "start_trace",
            "record_step",
            "complete_trace",
            "get_trace",
            "list_traces",
            "delete_trace"
          ]
        },
        {
          "type": "class",
          "name": "SQLiteTraceStore",
          "purpose": "SQLite-based trace storage.",
          "methods": [
            "start_trace",
            "record_step",
            "complete_trace",
            "get_trace",
            "list_traces",
            "delete_trace",
            "get_trace_count",
            "cleanup_old_traces",
            "search_traces",
            "get_trace_by_root_hash"
          ]
        },
        {
          "type": "class",
          "name": "InMemoryTraceStore",
          "purpose": "In-memory trace storage for testing.",
          "methods": [
            "start_trace",
            "record_step",
            "complete_trace",
            "get_trace",
            "list_traces",
            "delete_trace"
          ]
        },
        {
          "type": "function",
          "name": "generate_correlation_id",
          "purpose": "Generate a unique correlation ID for tracing."
        },
        {
          "type": "function",
          "name": "generate_run_id",
          "purpose": "Generate a unique run ID."
        }
      ]
    },
    {
      "file": "traces/traces_metrics.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Trace metrics collection",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "TracesMetrics",
          "purpose": "Centralized metrics manager for traces API.",
          "methods": [
            "measure_request",
            "record_trace_stored",
            "record_replay_enforcement",
            "record_idempotency_check",
            "record_parity_check",
            "measure_storage"
          ]
        },
        {
          "type": "function",
          "name": "get_traces_metrics",
          "purpose": "Get or create global traces metrics instance."
        },
        {
          "type": "function",
          "name": "instrument_trace_request",
          "purpose": "Decorator to instrument trace API endpoints."
        },
        {
          "type": "function",
          "name": "instrument_replay_check",
          "purpose": "Decorator to instrument replay enforcement."
        },
        {
          "type": "function",
          "name": "instrument_parity_check",
          "purpose": "Decorator to instrument parity checks."
        },
        {
          "type": "class",
          "name": "StubMetric",
          "purpose": null,
          "methods": [
            "labels",
            "inc",
            "dec",
            "set",
            "observe",
            "info",
            "time"
          ]
        }
      ]
    },
    {
      "file": "utils/__init__.py",
      "layer": "L6",
      "layer_source": "inferred",
      "components": [
        {
          "type": "function",
          "name": "get_existing_run",
          "purpose": null
        },
        {
          "type": "function",
          "name": "check_idempotency",
          "purpose": null
        },
        {
          "type": "function",
          "name": "allow_request",
          "purpose": null
        },
        {
          "type": "function",
          "name": "get_rate_limiter",
          "purpose": null
        },
        {
          "type": "function",
          "name": "acquire_slot",
          "purpose": null
        },
        {
          "type": "function",
          "name": "get_concurrent_limiter",
          "purpose": null
        },
        {
          "type": "function",
          "name": "check_budget",
          "purpose": null
        },
        {
          "type": "function",
          "name": "deduct_budget",
          "purpose": null
        },
        {
          "type": "function",
          "name": "record_cost",
          "purpose": null
        },
        {
          "type": "function",
          "name": "get_budget_tracker",
          "purpose": null
        },
        {
          "type": "function",
          "name": "scalar_or_default",
          "purpose": null
        },
        {
          "type": "function",
          "name": "scalar_or_none",
          "purpose": null
        },
        {
          "type": "function",
          "name": "extract_model",
          "purpose": null
        },
        {
          "type": "function",
          "name": "extract_models",
          "purpose": null
        },
        {
          "type": "function",
          "name": "count_or_zero",
          "purpose": null
        },
        {
          "type": "function",
          "name": "sum_or_zero",
          "purpose": null
        }
      ]
    },
    {
      "file": "utils/budget_tracker.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Budget tracking utility",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "BudgetStatus",
          "purpose": "Current budget status for an agent.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BudgetCheckResult",
          "purpose": "Result of a budget enforcement check.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BudgetTracker",
          "purpose": "Tracks and enforces LLM cost budgets.",
          "methods": [
            "get_status",
            "check_budget",
            "enforce_budget",
            "deduct",
            "record_cost"
          ]
        },
        {
          "type": "function",
          "name": "get_budget_tracker",
          "purpose": "Get the singleton budget tracker."
        },
        {
          "type": "function",
          "name": "check_budget",
          "purpose": "Convenience function to check budget."
        },
        {
          "type": "function",
          "name": "deduct_budget",
          "purpose": "Convenience function to deduct budget."
        },
        {
          "type": "function",
          "name": "record_cost",
          "purpose": "Convenience function to record cost."
        },
        {
          "type": "function",
          "name": "enforce_budget",
          "purpose": "Full budget enforcement with all protection layers."
        }
      ],
      "calls": {
        "L4": [
          "app.contracts.decisions"
        ]
      }
    },
    {
      "file": "utils/canonical_json.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Canonical JSON serialization for hashing",
      "temporal": {
        "trigger": "any",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "canonical_json",
          "purpose": "Serialize object to canonical JSON format."
        },
        {
          "type": "function",
          "name": "canonical_json_bytes",
          "purpose": "Serialize object to canonical JSON bytes (UTF-8)."
        },
        {
          "type": "function",
          "name": "content_hash",
          "purpose": "Compute deterministic content hash."
        },
        {
          "type": "function",
          "name": "content_hash_full",
          "purpose": "Compute full SHA-256 content hash."
        },
        {
          "type": "function",
          "name": "deterministic_hash",
          "purpose": "Compute hash excluding allowed variance fields."
        },
        {
          "type": "function",
          "name": "is_canonical",
          "purpose": "Check if a JSON string is in canonical format."
        },
        {
          "type": "function",
          "name": "canonicalize_file",
          "purpose": "Rewrite a JSON file in canonical format."
        },
        {
          "type": "function",
          "name": "assert_canonical",
          "purpose": "Assert that a JSON file is in canonical format."
        },
        {
          "type": "function",
          "name": "compare_deterministic",
          "purpose": "Compare two outputs, checking only deterministic fields."
        }
      ]
    },
    {
      "file": "utils/concurrent_runs.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Concurrent run limit enforcement",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ConcurrentRunsLimiter",
          "purpose": "Limits concurrent runs using Redis-based semaphore.",
          "methods": [
            "acquire",
            "release",
            "get_count",
            "slot"
          ]
        },
        {
          "type": "function",
          "name": "get_concurrent_limiter",
          "purpose": "Get the singleton concurrent runs limiter."
        },
        {
          "type": "function",
          "name": "acquire_slot",
          "purpose": "Convenience context manager for acquiring a slot."
        }
      ]
    },
    {
      "file": "utils/db_helpers.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Additional database utilities",
      "temporal": {
        "trigger": "any",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "scalar_or_default",
          "purpose": "Extract scalar value from Row or return default."
        },
        {
          "type": "function",
          "name": "scalar_or_none",
          "purpose": "Extract scalar value from Row, returning None if unavailable."
        },
        {
          "type": "function",
          "name": "extract_model",
          "purpose": "Extract model instance from Row or return as-is."
        },
        {
          "type": "function",
          "name": "extract_models",
          "purpose": "Extract model instances from a list of results."
        },
        {
          "type": "function",
          "name": "count_or_zero",
          "purpose": "Extract count value, guaranteed to return int."
        },
        {
          "type": "function",
          "name": "sum_or_zero",
          "purpose": "Extract sum value, guaranteed to return numeric."
        },
        {
          "type": "function",
          "name": "query_one",
          "purpose": "Safe single-row query with automatic Row/Model detection."
        },
        {
          "type": "function",
          "name": "query_all",
          "purpose": "Safe multi-row query with automatic Row/Model detection."
        },
        {
          "type": "function",
          "name": "model_to_dict",
          "purpose": "Convert ORM model to dict to prevent DetachedInstanceError."
        },
        {
          "type": "function",
          "name": "models_to_dicts",
          "purpose": "Convert list of ORM models to list of dicts."
        },
        {
          "type": "function",
          "name": "safe_get",
          "purpose": "Safe session.get() wrapper with optional dict conversion."
        },
        {
          "type": "function",
          "name": "get_or_create",
          "purpose": "Get existing model or create new one."
        }
      ]
    },
    {
      "file": "utils/deterministic.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Deterministic execution utilities",
      "temporal": {
        "trigger": "any",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "seeded_jitter",
          "purpose": "Generate deterministic jitter value from workflow ID and attempt number."
        },
        {
          "type": "function",
          "name": "deterministic_backoff_ms",
          "purpose": "Calculate exponential backoff with deterministic jitter."
        },
        {
          "type": "function",
          "name": "deterministic_timestamp",
          "purpose": "Generate a deterministic timestamp for replay scenarios."
        },
        {
          "type": "function",
          "name": "generate_idempotency_key",
          "purpose": "Generate a deterministic idempotency key for a skill execution."
        },
        {
          "type": "function",
          "name": "hash_params",
          "purpose": "Generate a hash of skill parameters for idempotency comparison."
        }
      ]
    },
    {
      "file": "utils/guard_cache.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Guard decision caching",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "GuardCache",
          "purpose": "Redis-based cache for Guard Console API.",
          "methods": [
            "get_instance",
            "get",
            "set",
            "invalidate",
            "get_status",
            "set_status",
            "get_snapshot",
            "set_snapshot",
            "get_incidents",
            "set_incidents"
          ]
        },
        {
          "type": "function",
          "name": "get_guard_cache",
          "purpose": "Get guard cache singleton."
        }
      ]
    },
    {
      "file": "utils/idempotency.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Idempotency key utilities",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "IdempotencyResult",
          "purpose": "Result of idempotency check.",
          "methods": []
        },
        {
          "type": "function",
          "name": "get_existing_run",
          "purpose": "Check if a run with this idempotency key already exists."
        },
        {
          "type": "function",
          "name": "check_idempotency",
          "purpose": "Check idempotency and return result with status."
        },
        {
          "type": "function",
          "name": "should_return_cached",
          "purpose": "Determine if we should return cached result."
        }
      ]
    },
    {
      "file": "utils/input_sanitizer.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Input sanitization for security",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SanitizationResult",
          "purpose": "Result of input sanitization.",
          "methods": []
        },
        {
          "type": "function",
          "name": "detect_injection_patterns",
          "purpose": "Detect prompt injection patterns in text."
        },
        {
          "type": "function",
          "name": "extract_urls",
          "purpose": "Extract all URLs from text."
        },
        {
          "type": "function",
          "name": "is_url_safe",
          "purpose": "Check if a URL is safe (not targeting internal resources)."
        },
        {
          "type": "function",
          "name": "sanitize_goal",
          "purpose": "Sanitize a goal string before processing."
        },
        {
          "type": "function",
          "name": "validate_goal",
          "purpose": "Convenience function to validate a goal."
        }
      ]
    },
    {
      "file": "utils/metrics_helpers.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Metrics helper functions",
      "temporal": {
        "trigger": "any",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "get_or_create_counter",
          "purpose": "Get existing counter or create new one - idempotent."
        },
        {
          "type": "function",
          "name": "get_or_create_gauge",
          "purpose": "Get existing gauge or create new one - idempotent."
        },
        {
          "type": "function",
          "name": "get_or_create_histogram",
          "purpose": "Get existing histogram or create new one - idempotent."
        },
        {
          "type": "function",
          "name": "validate_metric_name",
          "purpose": "Validate metric name follows conventions."
        },
        {
          "type": "function",
          "name": "reset_metrics_registry",
          "purpose": "Reset the Prometheus registry for test isolation."
        }
      ]
    },
    {
      "file": "utils/plan_inspector.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Plan structure inspection",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "PlanValidationError",
          "purpose": "A single validation error.",
          "methods": []
        },
        {
          "type": "class",
          "name": "PlanValidationResult",
          "purpose": "Result of plan validation.",
          "methods": [
            "add_error",
            "add_warning"
          ]
        },
        {
          "type": "function",
          "name": "extract_urls_from_params",
          "purpose": "Extract all URLs from skill parameters."
        },
        {
          "type": "function",
          "name": "is_domain_forbidden",
          "purpose": "Check if a URL targets a forbidden domain."
        },
        {
          "type": "function",
          "name": "validate_step",
          "purpose": "Validate a single plan step."
        },
        {
          "type": "function",
          "name": "validate_plan",
          "purpose": "Validate a complete plan before execution."
        },
        {
          "type": "function",
          "name": "inspect_plan",
          "purpose": "Inspect a plan and return validation results."
        }
      ]
    },
    {
      "file": "utils/rate_limiter.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Rate limiting utilities",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "RateLimiter",
          "purpose": "Token bucket rate limiter using Redis.",
          "methods": [
            "allow",
            "get_remaining"
          ]
        },
        {
          "type": "function",
          "name": "get_rate_limiter",
          "purpose": "Get the singleton rate limiter instance."
        },
        {
          "type": "function",
          "name": "allow_request",
          "purpose": "Convenience function to check rate limit."
        }
      ]
    },
    {
      "file": "utils/runtime.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Runtime utilities",
      "temporal": {
        "trigger": "api|worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "generate_uuid",
          "purpose": "Generate a UUID string."
        },
        {
          "type": "function",
          "name": "utc_now",
          "purpose": "Return timezone-aware UTC datetime."
        },
        {
          "type": "function",
          "name": "utc_now_naive",
          "purpose": "Return timezone-naive UTC datetime (for asyncpg raw SQL compatibility)."
        }
      ]
    },
    {
      "file": "utils/schema_parity.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Schema parity checking utilities",
      "temporal": {
        "trigger": "any",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "SchemaParityError",
          "purpose": "Raised when model schema doesn't match database schema.",
          "methods": []
        },
        {
          "type": "function",
          "name": "check_schema_parity",
          "purpose": "Check that SQLModel definitions match actual database schema."
        },
        {
          "type": "function",
          "name": "check_m26_cost_tables",
          "purpose": "Specific check for M26 cost tables - the most critical."
        },
        {
          "type": "function",
          "name": "run_startup_parity_check",
          "purpose": "Run full schema parity check on startup."
        }
      ],
      "calls": {
        "L6": [
          "app.db"
        ]
      }
    },
    {
      "file": "utils/webhook_verify.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Webhook signature verification",
      "temporal": {
        "trigger": "api",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "WebhookVerifier",
          "purpose": "Webhook signature verifier with key version support.",
          "methods": [
            "verify",
            "sign"
          ]
        },
        {
          "type": "function",
          "name": "create_file_key_loader",
          "purpose": "Create a key loader that reads from files."
        },
        {
          "type": "function",
          "name": "create_vault_key_loader",
          "purpose": "Create a key loader that reads from Vault."
        },
        {
          "type": "function",
          "name": "verify_webhook",
          "purpose": "Quick verification without creating a WebhookVerifier instance."
        }
      ],
      "routes": [
        {
          "method": "POST",
          "path": "/webhook"
        }
      ]
    },
    {
      "file": "workers/business_builder/schemas/brand.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Brand schema definitions",
      "temporal": {
        "trigger": "import-time",
        "execution": "sync"
      },
      "components": [
        {
          "type": "class",
          "name": "ToneLevel",
          "purpose": "Brand tone levels.",
          "methods": []
        },
        {
          "type": "class",
          "name": "AudienceSegment",
          "purpose": "Target audience segments.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ToneRule",
          "purpose": "Rule defining acceptable tone in copy.",
          "methods": []
        },
        {
          "type": "class",
          "name": "ForbiddenClaim",
          "purpose": "Claims that must not appear in any output.",
          "methods": []
        },
        {
          "type": "class",
          "name": "VisualIdentity",
          "purpose": "Visual brand constraints.",
          "methods": []
        },
        {
          "type": "class",
          "name": "CompetitorContext",
          "purpose": "Competitor information for positioning.",
          "methods": []
        },
        {
          "type": "class",
          "name": "BrandSchema",
          "purpose": "Complete brand schema for Business Builder Worker.",
          "methods": [
            "validate_mission_not_empty",
            "validate_value_prop",
            "to_strategy_context",
            "to_policy_rules",
            "get_drift_anchors",
            "from_file",
            "to_file"
          ]
        },
        {
          "type": "function",
          "name": "create_minimal_brand",
          "purpose": "Create a minimal valid brand schema."
        }
      ]
    },
    {
      "file": "workflow/health.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Workflow health checks and status",
      "temporal": {
        "trigger": "scheduler",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "configure_health",
          "purpose": "Configure health check dependencies."
        },
        {
          "type": "function",
          "name": "record_checkpoint_activity",
          "purpose": "Record that a checkpoint operation occurred (for health tracking)."
        },
        {
          "type": "async_function",
          "name": "healthz",
          "purpose": "Liveness probe - returns OK if process is running."
        },
        {
          "type": "async_function",
          "name": "readyz",
          "purpose": "Readiness probe - checks if workflow engine is ready to accept work."
        },
        {
          "type": "async_function",
          "name": "workflow_status",
          "purpose": "Detailed workflow engine status."
        },
        {
          "type": "async_function",
          "name": "workflow_config",
          "purpose": "Return workflow engine configuration (non-sensitive)."
        },
        {
          "type": "class",
          "name": "MockResponse",
          "purpose": null,
          "methods": []
        }
      ],
      "routes": [
        {
          "method": "GET",
          "path": "/healthz"
        },
        {
          "method": "GET",
          "path": "/readyz"
        },
        {
          "method": "GET",
          "path": "/status"
        },
        {
          "method": "GET",
          "path": "/config"
        }
      ]
    },
    {
      "file": "workflow/logging_context.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Workflow logging context management",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "get_run_id",
          "purpose": "Get current run ID from context."
        },
        {
          "type": "function",
          "name": "get_workflow_id",
          "purpose": "Get current workflow ID from context."
        },
        {
          "type": "function",
          "name": "get_agent_id",
          "purpose": "Get current agent ID from context."
        },
        {
          "type": "function",
          "name": "get_step_id",
          "purpose": "Get current step ID from context."
        },
        {
          "type": "function",
          "name": "get_step_index",
          "purpose": "Get current step index from context."
        },
        {
          "type": "function",
          "name": "get_correlation_id",
          "purpose": "Get current correlation ID from context."
        },
        {
          "type": "function",
          "name": "get_tenant_id",
          "purpose": "Get current tenant ID from context."
        },
        {
          "type": "function",
          "name": "set_run_id",
          "purpose": "Set run ID in context."
        },
        {
          "type": "function",
          "name": "set_workflow_id",
          "purpose": "Set workflow ID in context."
        },
        {
          "type": "function",
          "name": "set_agent_id",
          "purpose": "Set agent ID in context."
        },
        {
          "type": "function",
          "name": "set_step_context",
          "purpose": "Set step context."
        },
        {
          "type": "function",
          "name": "set_correlation_id",
          "purpose": "Set correlation ID in context."
        },
        {
          "type": "function",
          "name": "set_tenant_id",
          "purpose": "Set tenant ID in context."
        },
        {
          "type": "function",
          "name": "get_logging_context",
          "purpose": "Get all current logging context as a dictionary."
        },
        {
          "type": "function",
          "name": "clear_context",
          "purpose": "Clear all context variables."
        },
        {
          "type": "function",
          "name": "workflow_context",
          "purpose": "Context manager for workflow-scoped logging."
        },
        {
          "type": "function",
          "name": "step_context",
          "purpose": "Context manager for step-scoped logging."
        },
        {
          "type": "class",
          "name": "ContextualLoggerAdapter",
          "purpose": "Logger adapter that automatically adds workflow context to all log records.",
          "methods": [
            "process"
          ]
        },
        {
          "type": "class",
          "name": "StructuredFormatter",
          "purpose": "Structured log formatter that outputs JSON with context fields.",
          "methods": [
            "format"
          ]
        },
        {
          "type": "function",
          "name": "configure_structured_logging",
          "purpose": "Configure a logger with structured JSON output."
        },
        {
          "type": "function",
          "name": "get_contextual_logger",
          "purpose": "Get a logger that automatically includes workflow context."
        }
      ]
    },
    {
      "file": "workflow/metrics.py",
      "layer": "L6",
      "layer_source": "declared",
      "purpose": "Workflow Prometheus metrics instrumentation",
      "temporal": {
        "trigger": "worker",
        "execution": "sync"
      },
      "components": [
        {
          "type": "function",
          "name": "record_workflow_failure",
          "purpose": "Record a workflow failure."
        },
        {
          "type": "function",
          "name": "record_step_failure",
          "purpose": "Record a step failure."
        },
        {
          "type": "function",
          "name": "record_checkpoint_operation",
          "purpose": "Record a checkpoint operation."
        },
        {
          "type": "function",
          "name": "record_replay_verification",
          "purpose": "Record a golden replay verification result."
        },
        {
          "type": "function",
          "name": "record_step_duration",
          "purpose": "Record step execution duration."
        },
        {
          "type": "function",
          "name": "record_workflow_start",
          "purpose": "Record that a workflow run started."
        },
        {
          "type": "function",
          "name": "record_workflow_end",
          "purpose": "Record that a workflow run ended."
        },
        {
          "type": "function",
          "name": "record_capability_violation",
          "purpose": "Record a capability violation (policy denial)."
        },
        {
          "type": "function",
          "name": "record_policy_decision",
          "purpose": "Record a policy evaluation result."
        },
        {
          "type": "function",
          "name": "record_budget_rejection",
          "purpose": "Record a resource request rejected due to budget constraints."
        },
        {
          "type": "function",
          "name": "record_fallback_activation",
          "purpose": "Record a fallback strategy activation."
        },
        {
          "type": "function",
          "name": "record_auto_recovery",
          "purpose": "Record an automatic recovery attempt."
        },
        {
          "type": "function",
          "name": "record_cost_simulation_drift",
          "purpose": "Record the difference between simulated and actual cost."
        },
        {
          "type": "function",
          "name": "set_emergency_stop",
          "purpose": "Set the emergency stop gauge (0=disabled, 1=enabled)."
        },
        {
          "type": "function",
          "name": "record_budget_breach",
          "purpose": "Record a budget breach."
        },
        {
          "type": "function",
          "name": "set_approval_requests_pending",
          "purpose": "Set the number of pending approval requests."
        },
        {
          "type": "function",
          "name": "record_approval_request_created",
          "purpose": "Record that an approval request was created."
        },
        {
          "type": "function",
          "name": "record_approval_escalation",
          "purpose": "Record that an approval request was escalated."
        },
        {
          "type": "function",
          "name": "record_approval_action",
          "purpose": "Record an approval action result."
        },
        {
          "type": "function",
          "name": "record_webhook_fallback",
          "purpose": "Record that a webhook callback failed and was written to fallback."
        },
        {
          "type": "function",
          "name": "set_feature_flag_drift",
          "purpose": "Set whether feature flag drift is detected (0=no drift, 1=drift)."
        },
        {
          "type": "function",
          "name": "set_feature_flag",
          "purpose": "Set a feature flag status."
        },
        {
          "type": "function",
          "name": "set_m5_signoff_present",
          "purpose": "Set whether M5 signoff is present (0=missing, 1=present)."
        },
        {
          "type": "function",
          "name": "check_m5_signoff",
          "purpose": "Check if M5 signoff file exists and update the metric."
        },
        {
          "type": "class",
          "name": "StubCounter",
          "purpose": null,
          "methods": [
            "labels",
            "inc"
          ]
        },
        {
          "type": "class",
          "name": "StubHistogram",
          "purpose": null,
          "methods": [
            "labels",
            "observe"
          ]
        },
        {
          "type": "class",
          "name": "StubGauge",
          "purpose": null,
          "methods": [
            "labels",
            "set",
            "inc",
            "dec"
          ]
        }
      ]
    }
  ]
}
