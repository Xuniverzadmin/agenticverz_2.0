#!/usr/bin/env python3
# Layer: L8 — Operational Script
# AUDIENCE: INTERNAL
# Product: system-wide
# Temporal:
#   Trigger: manual
#   Execution: sync
# Role: HOC Phase 3 — Domain Locker
# artifact_class: CODE
"""
HOC Phase 3 — Domain Locker

Post-migration domain locking. For each customer domain:
1. Inventories all .py files with SHA-256 hashes
2. Computes layer distribution
3. Generates DOMAIN_LOCK_FINAL.md (overwrites stale drafts)
4. Produces DOMAIN_LOCK_REGISTRY.json (all domains)
5. Produces DOMAIN_CI_GUARDS.yaml (BLCA integration)

Reference: PIN-470, PIN-473, PIN-479
Artifact Class: CODE
Layer: OPS
Audience: INTERNAL

Usage:
    python3 scripts/ops/hoc_phase3_domain_locker.py
"""

import hashlib
import json
import os
import re
import sys
from collections import defaultdict
from datetime import datetime, timezone
from pathlib import Path

# ---------------------------------------------------------------------------
# Paths
# ---------------------------------------------------------------------------
REPO_ROOT = Path(__file__).resolve().parent.parent.parent
BACKEND_HOC_CUS = REPO_ROOT / "backend" / "app" / "hoc" / "cus"
DOMAIN_MAP_DIR = BACKEND_HOC_CUS / "_domain_map"
LOCK_DOCS_DIR = BACKEND_HOC_CUS / "docs" / "domain-locks"
REGISTRY_PATH = DOMAIN_MAP_DIR / "DOMAIN_LOCK_REGISTRY.json"
CI_GUARDS_PATH = DOMAIN_MAP_DIR / "DOMAIN_CI_GUARDS.yaml"

CUSTOMER_DOMAINS = [
    "account", "activity", "analytics", "api_keys", "controls",
    "general", "incidents", "integrations", "logs", "overview", "policies",
]

EXCLUDED_DIRS = {"__pycache__", "_domain_map", "docs", ".git"}
LOCK_VERSION = "2.0"
TIMESTAMP = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
DATE_STR = datetime.now(timezone.utc).strftime("%Y-%m-%d")


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def sha256_file(path: Path) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()


def classify_layer(rel_path: str) -> str:
    """Extract layer from relative path like L5_engines/foo.py -> L5_engines."""
    parts = Path(rel_path).parts
    for p in parts:
        if re.match(r'^L\d+', p):
            return p
    # Special directories
    for p in parts:
        if p in ("L5_notifications", "L5_support", "L5_schemas", "L5_controls",
                 "L4_runtime", "L3_adapters"):
            return p
    return "root"


def inventory_domain(domain: str) -> dict:
    """Inventory all .py files in a domain with hashes and layer classification."""
    domain_dir = BACKEND_HOC_CUS / domain
    if not domain_dir.exists():
        return {"domain": domain, "exists": False, "files": [], "layers": {}}

    files = []
    layers = defaultdict(list)

    for root, dirs, fnames in os.walk(domain_dir):
        dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]
        for fname in sorted(fnames):
            if not fname.endswith(".py"):
                continue
            fpath = Path(root) / fname
            rel = str(fpath.relative_to(domain_dir))
            h = sha256_file(fpath)
            layer = classify_layer(rel)
            loc = sum(1 for line in fpath.read_text(encoding="utf-8", errors="replace").splitlines()
                      if line.strip() and not line.strip().startswith("#"))

            entry = {
                "file": rel,
                "layer": layer,
                "hash": h,
                "loc": loc,
            }
            files.append(entry)
            layers[layer].append(rel)

    # Compute domain-level hash (hash of all file hashes sorted)
    all_hashes = sorted(f["hash"] for f in files)
    domain_hash = hashlib.sha256("|".join(all_hashes).encode()).hexdigest()

    return {
        "domain": domain,
        "exists": True,
        "file_count": len(files),
        "total_loc": sum(f["loc"] for f in files),
        "domain_hash": domain_hash,
        "files": files,
        "layers": dict(layers),
    }


# ---------------------------------------------------------------------------
# Lock file generation
# ---------------------------------------------------------------------------

def generate_lock_md(inv: dict) -> str:
    """Generate DOMAIN_LOCK_FINAL.md content."""
    domain = inv["domain"].upper()
    lines = [
        f"# {domain} Domain Lock",
        "",
        f"**Status:** LOCKED",
        f"**Locked:** {DATE_STR}",
        f"**Lock Version:** {LOCK_VERSION}",
        f"**Files:** {inv['file_count']}",
        f"**LOC:** {inv['total_loc']}",
        f"**Domain Hash:** `{inv['domain_hash'][:16]}...`",
        f"**Generated by:** `hoc_phase3_domain_locker.py`",
        f"**Reference:** PIN-470, PIN-479 (Phase 0-1 migration complete)",
        "",
        "---",
        "",
        "## Layer Distribution",
        "",
        "| Layer | Files | LOC |",
        "|-------|-------|-----|",
    ]

    for layer in sorted(inv["layers"].keys()):
        layer_files = inv["layers"][layer]
        layer_loc = sum(f["loc"] for f in inv["files"] if f["layer"] == layer)
        lines.append(f"| {layer} | {len(layer_files)} | {layer_loc} |")

    lines += [
        "",
        "---",
        "",
        "## File Inventory",
        "",
        "| File | Layer | LOC | Hash (first 12) |",
        "|------|-------|-----|-----------------|",
    ]

    for f in sorted(inv["files"], key=lambda x: (x["layer"], x["file"])):
        lines.append(f"| `{f['file']}` | {f['layer']} | {f['loc']} | `{f['hash'][:12]}` |")

    lines += [
        "",
        "---",
        "",
        "## Modification Rules",
        "",
        "- **New files:** ALLOWED (must follow layer convention)",
        "- **Edit files:** ALLOWED (hash will change, re-lock required)",
        "- **Delete files:** REQUIRES_APPROVAL",
        "- **Move files:** BLOCKED (use migration process)",
        "- **Rename files:** BLOCKED",
        "",
        "---",
        "",
        f"*Lock generated: {TIMESTAMP}*",
        "",
    ]

    return "\n".join(lines)


# ---------------------------------------------------------------------------
# Registry + CI Guards
# ---------------------------------------------------------------------------

def generate_registry(inventories: list) -> dict:
    """Generate DOMAIN_LOCK_REGISTRY.json."""
    registry = {
        "lock_version": LOCK_VERSION,
        "generated": TIMESTAMP,
        "generator": "hoc_phase3_domain_locker.py",
        "reference": "PIN-470, PIN-479",
        "total_domains": len(inventories),
        "total_files": sum(inv["file_count"] for inv in inventories),
        "total_loc": sum(inv["total_loc"] for inv in inventories),
        "domains": {},
    }

    for inv in inventories:
        registry["domains"][inv["domain"]] = {
            "status": "LOCKED",
            "locked_at": TIMESTAMP,
            "lock_version": LOCK_VERSION,
            "file_count": inv["file_count"],
            "total_loc": inv["total_loc"],
            "domain_hash": inv["domain_hash"],
            "lock_file": f"backend/app/hoc/cus/docs/domain-locks/{inv['domain'].upper()}_DOMAIN_LOCK_FINAL.md",
            "layers": {k: len(v) for k, v in inv["layers"].items()},
        }

    return registry


def generate_ci_guards(inventories: list) -> str:
    """Generate DOMAIN_CI_GUARDS.yaml."""
    lines = [
        "# HOC Domain CI Guards",
        f"# Generated: {TIMESTAMP}",
        f"# Generator: hoc_phase3_domain_locker.py",
        f"# Reference: PIN-470, PIN-479",
        "",
        "domain_guards:",
    ]

    for inv in sorted(inventories, key=lambda x: x["domain"]):
        d = inv["domain"]
        lines += [
            f"  {d}:",
            f"    locked_at: \"{TIMESTAMP}\"",
            f"    lock_version: \"{LOCK_VERSION}\"",
            f"    file_count: {inv['file_count']}",
            f"    domain_hash: \"{inv['domain_hash'][:16]}\"",
            f"    allowed_operations:",
            f"      - ADD_FILE",
            f"      - EDIT_FILE",
            f"    blocked_operations:",
            f"      - DELETE_FILE",
            f"      - MOVE_FILE",
            f"      - RENAME_FILE",
            f"    enforcement: BLOCKING",
            "",
        ]

    lines += [
        "# Architecture rules (Phase 8 enforcement)",
        "architecture_rules:",
        "  ARCH-001:",
        "    description: \"Domains MAY import from general/\"",
        "    enforcement: WARNING",
        "  ARCH-002:",
        "    description: \"Domains MUST NOT import from other domains (except via general)\"",
        "    enforcement: BLOCKING",
        "  ARCH-003:",
        "    description: \"general/ MUST NOT import from any domain\"",
        "    enforcement: BLOCKING",
        "  ARCH-004:",
        "    description: \"All shared utilities MUST be in general/\"",
        "    enforcement: WARNING",
        "",
    ]

    return "\n".join(lines)


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    print("=" * 60)
    print("HOC Phase 3 — Domain Locker")
    print("=" * 60)

    # 1. Inventory all domains
    print(f"\n[1/4] Inventorying {len(CUSTOMER_DOMAINS)} domains...")
    inventories = []
    for domain in CUSTOMER_DOMAINS:
        inv = inventory_domain(domain)
        if inv["exists"]:
            inventories.append(inv)
            print(f"  {domain}: {inv['file_count']} files, {inv['total_loc']} LOC, {len(inv['layers'])} layers")
        else:
            print(f"  {domain}: NOT FOUND (skipped)")

    total_files = sum(inv["file_count"] for inv in inventories)
    total_loc = sum(inv["total_loc"] for inv in inventories)
    print(f"\n  Total: {total_files} files, {total_loc} LOC across {len(inventories)} domains")

    # 2. Generate lock files
    print(f"\n[2/4] Generating domain lock files...")
    LOCK_DOCS_DIR.mkdir(parents=True, exist_ok=True)
    for inv in inventories:
        lock_content = generate_lock_md(inv)
        lock_path = LOCK_DOCS_DIR / f"{inv['domain'].upper()}_DOMAIN_LOCK_FINAL.md"
        lock_path.write_text(lock_content, encoding="utf-8")
        print(f"  {lock_path.name}: {inv['file_count']} files locked")

    # 3. Generate registry
    print(f"\n[3/4] Generating lock registry...")
    registry = generate_registry(inventories)
    DOMAIN_MAP_DIR.mkdir(parents=True, exist_ok=True)
    with open(REGISTRY_PATH, "w") as f:
        json.dump(registry, f, indent=2)
    print(f"  {REGISTRY_PATH.name}: {registry['total_domains']} domains, {registry['total_files']} files")

    # 4. Generate CI guards
    print(f"\n[4/4] Generating CI guards...")
    ci_guards = generate_ci_guards(inventories)
    CI_GUARDS_PATH.write_text(ci_guards, encoding="utf-8")
    print(f"  {CI_GUARDS_PATH.name}: {len(inventories)} domain guards + 4 arch rules")

    print(f"\nPhase 3 complete.")
    print(f"  Lock files:  {LOCK_DOCS_DIR}/")
    print(f"  Registry:    {REGISTRY_PATH}")
    print(f"  CI Guards:   {CI_GUARDS_PATH}")
    return 0


if __name__ == "__main__":
    sys.exit(main() or 0)
