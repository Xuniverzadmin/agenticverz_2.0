#!/usr/bin/env python3
"""
AURORA_L2 CSV → YAML Migration Script

Purpose: Migrate L2_1_UI_INTENT_SUPERTABLE.csv to AURORA_L2 YAML intent specs
Status: Migration tool
Reference: L2.1 Pipeline Study Report, PIN-385

Usage:
    python3 scripts/tools/aurora_l2_migrate_csv_to_yaml.py [--dry-run]

Output:
    - design/l2_1/intents/{panel_id}.yaml (one per row)
    - design/l2_1/AURORA_L2_INTENT_REGISTRY.yaml (updated)
"""

import csv
import sys
import yaml
from datetime import datetime, timezone
from pathlib import Path

# Paths
SCRIPT_DIR = Path(__file__).parent
REPO_ROOT = SCRIPT_DIR.parent.parent
CSV_PATH = REPO_ROOT / "design/l2_1/supertable/L2_1_UI_INTENT_SUPERTABLE.csv"
INTENTS_DIR = REPO_ROOT / "design/l2_1/intents"
REGISTRY_PATH = REPO_ROOT / "design/l2_1/AURORA_L2_INTENT_REGISTRY.yaml"

# Migration metadata
MIGRATION_DATE = datetime.now(timezone.utc).strftime("%Y-%m-%d")
MIGRATION_VERSION = "1.0.0"


def parse_bool(value: str) -> bool:
    """Parse YES/NO to boolean."""
    return value.strip().upper() == "YES"


def parse_control_set(value: str) -> list:
    """Parse control set string like '[FILTER,SORT,SELECT_SINGLE]' to list."""
    if not value or value == "[]":
        return []
    # Remove brackets and split
    cleaned = value.strip().strip("[]\"'")
    if not cleaned:
        return []
    return [c.strip() for c in cleaned.split(",") if c.strip()]


def parse_action_list(value: str) -> list:
    """Parse action string like 'APPROVE|REJECT' to list."""
    if not value:
        return []
    return [a.strip() for a in value.split("|") if a.strip()]


def csv_row_to_intent_spec(row: dict) -> dict:
    """Convert a CSV row to an AURORA_L2 intent spec structure."""
    panel_id = row["Panel ID"].strip()

    # Build the intent spec
    spec = {
        "panel_id": panel_id,
        "version": MIGRATION_VERSION,

        "metadata": {
            "domain": row["Domain"].strip(),
            "subdomain": row["Subdomain"].strip(),
            "topic": row["Topic"].strip(),
            "topic_id": row["Topic ID"].strip(),
            "order": row["Order"].strip(),
            "action_layer": row["Action Layer"].strip(),
            "migrated_from": "CSV",
            "migration_date": MIGRATION_DATE,
            "migration_status": "UNREVIEWED",
        },

        "display": {
            "name": row["Panel Name"].strip(),
            "ranking_dimension": row["Ranking Dimension"].strip() if row["Ranking Dimension"].strip() != "NONE" else None,
            "visible_by_default": parse_bool(row["Visible by Default"]),
            "nav_required": parse_bool(row["Nav Required"]),
            "expansion_mode": "INLINE",  # Default, to be refined
        },

        "data": {
            "read": parse_bool(row["Read"]),
            "download": parse_bool(row["Download"]),
            "write": parse_bool(row["Write"]),
            "write_action": row["Write Action"].strip() if row["Write Action"].strip() else None,
            "replay": parse_bool(row["Replay"]),
        },

        "controls": {
            "filtering": parse_bool(row["Filtering"]),
            "selection_mode": row["Selection Mode"].strip() if row["Selection Mode"].strip() != "NONE" else None,
            "activate": parse_bool(row["Activate"]),
            "activate_actions": parse_action_list(row["Activate Action"]),
            "confirmation_required": parse_bool(row["Confirmation Required"]),
            "control_set": parse_control_set(row["Control Set (Explicit)"]),
        },
    }

    # Add notes if present
    notes = row.get("Notes", "").strip()
    if notes:
        spec["notes"] = notes

    # Clean up None values in nested dicts for cleaner YAML
    spec["display"] = {k: v for k, v in spec["display"].items() if v is not None}
    spec["data"] = {k: v for k, v in spec["data"].items() if v is not None}
    spec["controls"] = {k: v for k, v in spec["controls"].items() if v is not None and v != []}

    return spec


def write_intent_yaml(spec: dict, dry_run: bool = False) -> Path:
    """Write an intent spec to a YAML file."""
    panel_id = spec["panel_id"]
    output_path = INTENTS_DIR / f"{panel_id}.yaml"

    # Custom YAML formatting
    yaml_content = f"""# AURORA_L2 Intent Spec: {panel_id}
# Generated by: aurora_l2_migrate_csv_to_yaml.py
# Migration Date: {MIGRATION_DATE}
# Status: UNREVIEWED (requires human review)

{yaml.dump(spec, default_flow_style=False, sort_keys=False, allow_unicode=True)}"""

    if dry_run:
        print(f"  [DRY RUN] Would write: {output_path}")
    else:
        output_path.write_text(yaml_content)
        print(f"  [CREATED] {output_path}")

    return output_path


def update_registry(specs: list[dict], dry_run: bool = False) -> None:
    """Update the intent registry with all migrated specs."""
    registry = {
        "version": MIGRATION_VERSION,
        "generated_at": MIGRATION_DATE,
        "generator": "aurora_l2_migrate_csv_to_yaml.py",
        "migration_notes": [
            "All intents migrated from L2_1_UI_INTENT_SUPERTABLE.csv",
            "All intents marked UNREVIEWED - requires human review",
            "Lossless migration - all CSV columns preserved",
        ],
        "intents": {}
    }

    for spec in specs:
        panel_id = spec["panel_id"]
        registry["intents"][panel_id] = {
            "status": "UNREVIEWED",
            "spec_path": f"design/l2_1/intents/{panel_id}.yaml",
            "added_at": MIGRATION_DATE,
            "reviewed_by": None,
            "domain": spec["metadata"]["domain"],
            "subdomain": spec["metadata"]["subdomain"],
            "topic": spec["metadata"]["topic"],
            "order": spec["metadata"]["order"],
        }

    yaml_content = f"""# AURORA_L2 Intent Registry
# Generated by: aurora_l2_migrate_csv_to_yaml.py
# Generated at: {MIGRATION_DATE}
#
# This registry is the ALLOW-LIST gate for intent specs.
# No intent can pass to the compiler unless it is registered here.
#
# Status values:
#   UNREVIEWED - Migrated from CSV, requires human review
#   APPROVED   - Human-reviewed and approved
#   CANDIDATE  - Proposed, pending approval
#   DEPRECATED - Scheduled for removal

{yaml.dump(registry, default_flow_style=False, sort_keys=False, allow_unicode=True)}"""

    if dry_run:
        print(f"\n  [DRY RUN] Would write registry: {REGISTRY_PATH}")
        print(f"  [DRY RUN] Total intents: {len(specs)}")
    else:
        REGISTRY_PATH.write_text(yaml_content)
        print(f"\n  [UPDATED] {REGISTRY_PATH}")
        print(f"  [TOTAL] {len(specs)} intents registered")


def main():
    dry_run = "--dry-run" in sys.argv

    print("=" * 60)
    print("AURORA_L2 CSV → YAML Migration")
    print("=" * 60)
    print(f"Source: {CSV_PATH}")
    print(f"Output: {INTENTS_DIR}")
    print(f"Mode: {'DRY RUN' if dry_run else 'LIVE'}")
    print("=" * 60)

    # Verify paths
    if not CSV_PATH.exists():
        print(f"ERROR: CSV not found: {CSV_PATH}")
        sys.exit(1)

    # Ensure output directory exists
    if not dry_run:
        INTENTS_DIR.mkdir(parents=True, exist_ok=True)

    # Read and parse CSV
    specs = []
    with open(CSV_PATH, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            # Skip empty rows
            if not row.get("Panel ID", "").strip():
                continue

            spec = csv_row_to_intent_spec(row)
            specs.append(spec)
            write_intent_yaml(spec, dry_run)

    # Update registry
    update_registry(specs, dry_run)

    print("=" * 60)
    print("Migration Summary")
    print("=" * 60)
    print(f"Total rows processed: {len(specs)}")
    print(f"Intent YAMLs created: {len(specs)}")
    print(f"Registry updated: {'No (dry run)' if dry_run else 'Yes'}")
    print()

    if dry_run:
        print("Run without --dry-run to execute migration.")
    else:
        print("Migration complete!")
        print()
        print("NEXT STEPS:")
        print("1. Review generated YAMLs in design/l2_1/intents/")
        print("2. Check AURORA_L2_INTENT_REGISTRY.yaml")
        print("3. Mark reviewed intents as APPROVED")
        print("4. Commit to aurora-l2-migration branch")


if __name__ == "__main__":
    main()
