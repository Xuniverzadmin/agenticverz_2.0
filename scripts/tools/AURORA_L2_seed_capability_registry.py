#!/usr/bin/env python3
"""
AURORA_L2 Capability Registry Seeder

Purpose: One-time inventory seeding from compiled intent store.
Status: ONE-TIME USE, then archive.

This script performs CAPABILITY DISCOVERY, not Capability Declaration.
It seeds capability entries with status=DISCOVERED for all ACTION intents.

Hard Constraints (LOCKED):
1. Never overwrite existing capability files
2. Never add endpoints or methods
3. Never infer auth roles
4. Never change intent or semantics
5. Runs once, then archived

Reference: design/l2_1/AURORA_L2.md
"""

import json
import sys
from datetime import datetime, timezone
from pathlib import Path

# Paths
REPO_ROOT = Path(__file__).resolve().parent.parent.parent
INTENT_STORE = REPO_ROOT / "design/l2_1/exports/intent_store_compiled.json"
CAP_DIR = REPO_ROOT / "backend/AURORA_L2_CAPABILITY_REGISTRY"

def seed_capabilities(dry_run: bool = False) -> dict:
    """
    Seed capability registry from compiled intent store.

    Returns stats dict with counts.
    """
    stats = {
        "actions_found": 0,
        "capabilities_created": 0,
        "capabilities_skipped": 0,
        "errors": []
    }

    # Validate input exists
    if not INTENT_STORE.exists():
        stats["errors"].append(f"Intent store not found: {INTENT_STORE}")
        return stats

    # Create output directory
    if not dry_run:
        CAP_DIR.mkdir(parents=True, exist_ok=True)

    # Load compiled intents
    try:
        data = json.loads(INTENT_STORE.read_text())
    except json.JSONDecodeError as e:
        stats["errors"].append(f"Invalid JSON in intent store: {e}")
        return stats

    # Extract all unique actions from write_action and activate_actions
    # The compiled store uses these fields, not interaction_class
    actions = set()
    action_sources = {}  # Track which panels use each action

    for row in data:
        panel_id = row.get("panel_id", "unknown")

        # Extract write_action (single action)
        write_action = row.get("write_action")
        if write_action:
            actions.add(write_action)
            action_sources.setdefault(write_action, []).append(panel_id)

        # Extract activate_actions (list of actions)
        activate_actions = row.get("activate_actions", [])
        for action in activate_actions:
            actions.add(action)
            action_sources.setdefault(action, []).append(panel_id)

    stats["actions_found"] = len(actions)

    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d")

    for action_id in sorted(actions):
        # Sanitize filename (replace dots and special chars)
        safe_id = action_id.replace(".", "_").replace("-", "_")
        fname = f"AURORA_L2_CAPABILITY_{safe_id}.yaml"
        path = CAP_DIR / fname

        if path.exists():
            stats["capabilities_skipped"] += 1
            print(f"  [SKIP] {fname} (already exists)")
            continue

        # Get source panels for this action
        source_panels = action_sources.get(action_id, [])
        source_panels_yaml = "\n".join(f"    - {p}" for p in source_panels)

        # Generate capability file content
        content = f"""\
# AURORA_L2 Capability Entry
# Status: DISCOVERED (auto-seeded, not verified)
# Generated by: AURORA_L2_seed_capability_registry.py
# Date: {timestamp}

capability_id: {action_id}
status: DISCOVERED

# Implementation details (TO BE FILLED BY BACKEND TEAM)
implementation:
  endpoint: null
  method: null
  handler: null

# Auth requirements (TO BE FILLED BY BACKEND TEAM)
auth:
  roles: []
  permissions: []

# Side effects (TO BE FILLED BY BACKEND TEAM)
side_effects: []

# Source panels that use this capability
source_panels:
{source_panels_yaml}

# Metadata
metadata:
  generated_by: AURORA_L2_seed_capability_registry.py
  generated_on: {timestamp}
  reviewed: false
  promoted_on: null
  promoted_by: null

# Notes
notes: |
  This capability was auto-discovered from the intent store.
  It requires manual review and backend implementation before promotion.

  To promote to IMPLEMENTED:
  1. Implement the backend handler
  2. Fill in implementation.endpoint, implementation.method
  3. Add auth.roles and auth.permissions
  4. Document side_effects
  5. Change status: DISCOVERED -> IMPLEMENTED
  6. Set metadata.reviewed: true
  7. Set metadata.promoted_on and metadata.promoted_by
"""

        if dry_run:
            print(f"  [DRY-RUN] Would create: {fname}")
        else:
            path.write_text(content)
            print(f"  [CREATE] {fname}")

        stats["capabilities_created"] += 1

    return stats


def main():
    print("=" * 60)
    print("AURORA_L2 Capability Registry Seeder")
    print("=" * 60)
    print(f"Input:  {INTENT_STORE}")
    print(f"Output: {CAP_DIR}")
    print()

    # Check for --dry-run flag
    dry_run = "--dry-run" in sys.argv

    if dry_run:
        print("Mode: DRY-RUN (no files will be created)")
    else:
        print("Mode: FULL RUN")
    print()

    stats = seed_capabilities(dry_run=dry_run)

    print()
    print("=" * 60)
    print("Summary")
    print("=" * 60)
    print(f"  ACTION intents found:    {stats['actions_found']}")
    print(f"  Capabilities created:    {stats['capabilities_created']}")
    print(f"  Capabilities skipped:    {stats['capabilities_skipped']}")

    if stats["errors"]:
        print()
        print("ERRORS:")
        for err in stats["errors"]:
            print(f"  ! {err}")
        sys.exit(1)

    print()
    if dry_run:
        print("Dry-run complete. Run without --dry-run to create files.")
    else:
        print("Seeding complete.")
        print()
        print("Next steps:")
        print("  1. Run compiler to update binding status")
        print("  2. Inspect UI for DRAFT controls")
        print("  3. Promote capabilities as backend implements them")


if __name__ == "__main__":
    main()
